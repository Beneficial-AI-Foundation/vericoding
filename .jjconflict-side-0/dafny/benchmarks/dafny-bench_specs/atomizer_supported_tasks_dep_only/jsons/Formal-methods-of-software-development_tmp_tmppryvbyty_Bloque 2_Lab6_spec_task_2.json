{
  "skeleton": "/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\n//ATOM_PLACEHOLDER_sum\n\n/*\n//ATOM_PLACEHOLDER_vector_Sum\n\n// Structural Induction on Sequences\n//ATOM_PLACEHOLDER_left_sum_Lemma\n\n// MAXIMUM OF A SEQUENCE\n//ATOM_PLACEHOLDER_maxSeq\n\n// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j\n//ATOM_PLACEHOLDER_Cubes\n\n\n// REVERSE OF A SEQUENCE\n//ATOM_PLACEHOLDER_reverse\n\n//ATOM_PLACEHOLDER_seq2set\n\n\n//ATOM_PLACEHOLDER_seq2setRev_Lemma\n\n\n//ATOM_PLACEHOLDER_concat_seq2set_Lemma\n\n\n// REVERSE IS ITS OWN INVERSE\n\n//ATOM_PLACEHOLDER_Rev_Lemma//ATOM_PLACEHOLDER_ItsOwnInverse_Lemma\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\n//ATOM_PLACEHOLDER_scalar_product\n\n\n//ATOM_PLACEHOLDER_scalar_product_Lemma\n\n// MULTISETS\n\n//ATOM_PLACEHOLDER_multiplicity_examples\n\n// REVERSE HAS THE SAME MULTISET \n\n//ATOM_PLACEHOLDER_seqMultiset_Lemma\n*/\n//ATOM_PLACEHOLDER_empty_Lemma \nensures r == []\n{\n\tif r != []\t{\n\t}\n}\n\n//ATOM_PLACEHOLDER_elem_Lemma//ATOM_PLACEHOLDER_sumElems_Lemma\n\n",
  "atoms": {
    "maxSeq": [
      [],
      "// SPEC \n\n// MAXIMUM OF A SEQUENCE\nmethod maxSeq(v: seq<int>) returns (max:int)\nrequires |v| >= 1\nensures forall i :: 0 <= i < |v| ==> max >= v[i]\nensures max in v\n{\n}\n",
      "method"
    ]
  },
  "placeholder_mapping": {
    "//ATOM_PLACEHOLDER_maxSeq": "maxSeq"
  }
}