import Std.Do.Triple
import Std.Tactic.Do

/-!
{
  "name": "numpy.memmap",
  "category": "Memory mapping",
  "description": "Create a memory-map to an array stored in a binary file on disk",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.memmap.html",
  "doc": "Create a memory-map to an array stored in a *binary* file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory.  NumPy's\n    memmap's are array-like objects.  This differs from Python's \`\`mmap\`\`\n    module, which uses file-like objects.\n\n    This subclass of ndarray has some unpleasant interactions with\n    some operations, because it doesn't quite fit properly as a subclass.\n    An alternative to using th...",
  "code": "class memmap(ndarray):\n    \"\"\"Create a memory-map to an array stored in a *binary* file on disk.\n\n    Memory-mapped files are used for accessing small segments of large files\n    on disk, without reading the entire file into memory.  NumPy's\n    memmap's are array-like objects.  This differs from Python's \`\`mmap\`\`\n    module, which uses file-like objects.\n\n    This subclass of ndarray has some unpleasant interactions with\n    some operations, because it doesn't quite fit properly as a subclass.\n    An alternative to using this subclass is to create the \`\`mmap\`\`\n    object yourself, then create an ndarray with ndarray.__new__ directly,\n    passing the object created in its 'buffer=' parameter.\n\n    This class may at some point be turned into a factory function\n    which returns a view into an mmap buffer.\n\n    Flush the memmap instance to write the changes to the file. Currently there\n    is no API to close the underlying \`\`mmap\`\`. It is tricky to ensure the\n    resource is actually closed, since it may be shared between different\n    memmap instances.\n\n\n    Parameters\n    ----------\n    filename : str, file-like object, or pathlib.Path instance\n        The file name or file object to be used as the array data buffer.\n    dtype : data-type, optional\n        The data-type used to interpret the file contents.\n        Default is \`uint8\`.\n    mode : {'r+', 'r', 'w+', 'c'}, optional\n        The file is opened in this mode:\n\n        +------+-------------------------------------------------------------+\n        | 'r'  | Open existing file for reading only.                        |\n        +------+-------------------------------------------------------------+\n        | 'r+' | Open existing file for reading and writing.                 |\n        +------+-------------------------------------------------------------+\n        | 'w+' | Create or overwrite existing file for reading and writing.  |\n        |      | If \`\`mode == 'w+'\`\` then \`shape\` must also be specified.    |\n        +------+-------------------------------------------------------------+\n        | 'c'  | Copy-on-write: assignments affect data in memory, but       |\n        |      | changes are not saved to disk.  The file on disk is         |\n        |      | read-only.                                                  |\n        +------+-------------------------------------------------------------+\n\n        Default is 'r+'.\n    offset : int, optional\n        In the file, array data starts at this offset. Since \`offset\` is\n        measured in bytes, it should normally be a multiple of the byte-size\n        of \`dtype\`. When \`\`mode != 'r'\`\`, even positive offsets beyond end of\n        file are valid; The file will be extended to accommodate the\n        additional data. By default, \`\`memmap\`\` will start at the beginning of\n        the file, even if \`\`filename\`\` is a file pointer \`\`fp\`\` and\n        \`\`fp.tell() != 0\`\`.\n    shape : int or sequence of ints, optional\n        The desired shape of the array. If \`\`mode == 'r'\`\` and the number\n        of remaining bytes after \`offset\` is not a multiple of the byte-size\n        of \`dtype\`, you must specify \`shape\`. By default, the returned array\n        will be 1-D with the number of elements determined by file size\n        and data-type.\n\n        .. versionchanged:: 2.0\n         The shape parameter can now be any integer sequence type, previously\n         types were limited to tuple and int.\n\n    order : {'C', 'F'}, optional\n        Specify the order of the ndarray memory layout:\n        :term:\`row-major\`, C-style or :term:\`column-major\`,\n        Fortran-style.  This only has an effect if the shape is\n        greater than 1-D.  The default order is 'C'.\n\n    Attributes\n    ----------\n    filename : str or pathlib.Path instance\n        Path to the mapped file.\n    offset : int\n        Offset position in the file.\n    mode : str\n        File mode.\n\n    Methods\n    -------\n    flush\n        Flush any changes in memory to file on disk.\n        When you delete a memmap object, flush is called first to write\n        changes to disk.\n\n\n    See also\n    --------\n    lib.format.open_memmap : Create or load a memory-mapped \`\`.npy\`\` file.\n\n    Notes\n    -----\n    The memmap object can be used anywhere an ndarray is accepted.\n    Given a memmap \`\`fp\`\`, \`\`isinstance(fp, numpy.ndarray)\`\` returns\n    \`\`True\`\`.\n\n    Memory-mapped files cannot be larger than 2GB on 32-bit systems.\n\n    When a memmap causes a file to be created or extended beyond its\n    current size in the filesystem, the contents of the new part are\n    unspecified. On systems with POSIX filesystem semantics, the extended\n    part will be filled with zero bytes.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> data = np.arange(12, dtype='float32')\n    >>> data.resize((3,4))\n\n    This example uses a temporary file so that doctest doesn't write\n    files to your directory. You would use a 'normal' filename.\n\n    >>> from tempfile import mkdtemp\n    >>> import os.path as path\n    >>> filename = path.join(mkdtemp(), 'newfile.dat')\n\n    Create a memmap with dtype and shape that matches our data:\n\n    >>> fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n    >>> fp\n    memmap([[0., 0., 0., 0.],\n            [0., 0., 0., 0.],\n            [0., 0., 0., 0.]], dtype=float32)\n\n    Write data to memmap array:\n\n    >>> fp[:] = data[:]\n    >>> fp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    >>> fp.filename == path.abspath(filename)\n    True\n\n    Flushes memory changes to disk in order to read them back\n\n    >>> fp.flush()\n\n    Load the memmap and verify data was stored:\n\n    >>> newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> newfp\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Read-only memmap:\n\n    >>> fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n    >>> fpr.flags.writeable\n    False\n\n    Copy-on-write memmap:\n\n    >>> fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n    >>> fpc.flags.writeable\n    True\n\n    It's possible to assign to copy-on-write array, but values are only\n    written into the memory copy of the array, and not written to disk:\n\n    >>> fpc\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n    >>> fpc[0,:] = 0\n    >>> fpc\n    memmap([[  0.,   0.,   0.,   0.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    File on disk is unchanged:\n\n    >>> fpr\n    memmap([[  0.,   1.,   2.,   3.],\n            [  4.,   5.,   6.,   7.],\n            [  8.,   9.,  10.,  11.]], dtype=float32)\n\n    Offset into a memmap:\n\n    >>> fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n    >>> fpo\n    memmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n\n    \"\"\"\n\n    __array_priority__ = -100.0\n\n    def __new__(subtype, filename, dtype=uint8, mode='r+', offset=0,\n                shape=None, order='C'):\n        # Import here to minimize 'import numpy' overhead\n        import mmap\n        import os.path\n        try:\n            mode = mode_equivalents[mode]\n        except KeyError as e:\n            if mode not in valid_filemodes:\n                all_modes = valid_filemodes + list(mode_equivalents.keys())\n                raise ValueError(\n                    f\"mode must be one of {all_modes!r} (got {mode!r})\"\n                ) from None\n\n        if mode == 'w+' and shape is None:\n            raise ValueError(\"shape must be given if mode == 'w+'\")\n\n        if hasattr(filename, 'read'):\n            f_ctx = nullcontext(filename)\n        else:\n            f_ctx = open(\n                os.fspath(filename),\n                ('r' if mode == 'c' else mode) + 'b'\n            )\n\n        with f_ctx as fid:\n            fid.seek(0, 2)\n            flen = fid.tell()\n            descr = dtypedescr(dtype)\n            _dbytes = descr.itemsize\n\n            if shape is None:\n                bytes = flen - offset\n                if bytes % _dbytes:\n                    raise ValueError(\"Size of available data is not a \"\n                            \"multiple of the data-type size.\")\n                size = bytes // _dbytes\n                shape = (size,)\n            else:\n                if not isinstance(shape, (tuple, list)):\n                    try:\n                        shape = [operator.index(shape)]\n                    except TypeError:\n                        pass\n                shape = tuple(shape)\n                size = np.intp(1)  # avoid overflows\n                for k in shape:\n                    size *= k\n\n            bytes = int(offset + size * _dbytes)\n\n            if mode in ('w+', 'r+'):\n                # gh-27723\n                # if bytes == 0, we write out 1 byte to allow empty memmap.\n                bytes = max(bytes, 1)\n                if flen < bytes:\n                    fid.seek(bytes - 1, 0)\n                    fid.write(b'\\0')\n                    fid.flush()\n\n            if mode == 'c':\n                acc = mmap.ACCESS_COPY\n            elif mode == 'r':\n                acc = mmap.ACCESS_READ\n            else:\n                acc = mmap.ACCESS_WRITE\n\n            start = offset - offset % mmap.ALLOCATIONGRANULARITY\n            bytes -= start\n            # bytes == 0 is problematic as in mmap length=0 maps the full file.\n            # See PR gh-27723 for a more detailed explanation.\n            if bytes == 0 and start > 0:\n                bytes += mmap.ALLOCATIONGRANULARITY\n                start -= mmap.ALLOCATIONGRANULARITY\n            array_offset = offset - start\n            mm = mmap.mmap(fid.fileno(), bytes, access=acc, offset=start)\n\n            self = ndarray.__new__(subtype, shape, dtype=descr, buffer=mm,\n                                   offset=array_offset, order=order)\n            self._mmap = mm\n            self.offset = offset\n            self.mode = mode\n\n            if isinstance(filename, os.PathLike):\n                # special case - if we were constructed with a pathlib.path,\n                # then filename is a path object, not a string\n                self.filename = filename.resolve()\n            elif hasattr(fid, \"name\") and isinstance(fid.name, str):\n                # py3 returns int for TemporaryFile().name\n                self.filename = os.path.abspath(fid.name)\n            # same as memmap copies (e.g. memmap + 1)\n            else:\n                self.filename = None\n\n        return self\n\n    def __array_finalize__(self, obj):\n        if hasattr(obj, '_mmap') and np.may_share_memory(self, obj):\n            self._mmap = obj._mmap\n            self.filename = obj.filename\n            self.offset = obj.offset\n            self.mode = obj.mode\n        else:\n            self._mmap = None\n            self.filename = None\n            self.offset = None\n            self.mode = None\n\n    def flush(self):\n        \"\"\"\n        Write any changes in the array to the file on disk.\n\n        For further information, see \`memmap\`.\n\n        Parameters\n        ----------\n        None\n\n        See Also\n        --------\n        memmap\n\n        \"\"\"\n        if self.base is not None and hasattr(self.base, 'flush'):\n            self.base.flush()\n\n    def __array_wrap__(self, arr, context=None, return_scalar=False):\n        arr = super().__array_wrap__(arr, context)\n\n        # Return a memmap if a memmap was given as the output of the\n        # ufunc. Leave the arr class unchanged if self is not a memmap\n        # to keep original memmap subclasses behavior\n        if self is arr or type(self) is not memmap:\n            return arr\n\n        # Return scalar instead of 0d memmap, e.g. for np.sum with\n        # axis=None (note that subclasses will not reach here)\n        if return_scalar:\n            return arr[()]\n\n        # Return ndarray otherwise\n        return arr.view(type=ndarray)\n\n    def __getitem__(self, index):\n        res = super().__getitem__(index)\n        if type(res) is memmap and res._mmap is None:\n            return res.view(type=ndarray)\n        return res"
}
-/

open Std.Do

/-- A simplified representation of file access mode for memory mapping -/
inductive FileMode
  | /-- ReadOnly mode ('r') - read-only access to existing file -/
    ReadOnly
  | /-- ReadWrite mode ('r+') - read-write access to existing file -/
    ReadWrite
  | /-- WriteNew mode ('w+') - create new file with read-write access -/
    WriteNew
  | /-- CopyOnWrite mode ('c') - copy-on-write access, changes don't persist to disk -/
    CopyOnWrite

/-- numpy.memmap: Create a memory-map to an array stored in a binary file on disk.

    Memory-mapped files are used for accessing small segments of large files
    on disk, without reading the entire file into memory. The memmap provides
    an array-like interface to the file contents.

    This function creates a Vector view into a binary file on disk with the
    specified shape and access mode. The file is accessed starting at the
    given offset.
-/
def memmap {n : Nat} (filename : String) (mode : FileMode) (offset : Nat) : 
    Id (Vector Float n) :=
  sorry

/-- Specification: numpy.memmap creates a memory-mapped view of a file.

    This specification captures the essential properties of memory mapping:
    1. The result is a valid vector of the specified size
    2. The mapping respects the file access mode constraints
    3. The offset is within valid bounds for the file
    4. Read-only modes preserve data integrity
    5. Write modes allow modification of the underlying file

    Preconditions:
    - The filename represents a valid file path
    - The offset is non-negative and within the file bounds
    - For WriteNew mode, the file will be created if it doesn't exist
    - For ReadOnly mode, the file must exist and be readable

    Postconditions:
    - Returns a vector of the specified size n
    - The vector provides a view into the file starting at the given offset
    - Read operations reflect the file contents at the mapped region
    - Write operations (when mode allows) modify the underlying file
    - The mapping preserves the mathematical properties of array access
-/
theorem memmap_spec {n : Nat} (filename : String) (mode : FileMode) (offset : Nat)
    (h_valid_file : filename.length > 0)
    (h_valid_offset : offset ≥ 0) :
    ⦃⌜filename.length > 0 ∧ offset ≥ 0⌝⦄
    memmap filename mode offset
    ⦃⇓result => ⌜
      -- Basic properties: result is a valid vector of size n
      (result.toList.length = n) ∧
      -- Access mode constraints
      (mode = FileMode.ReadOnly → 
        (∀ i : Fin n, ∃ val : Float, result.get i = val)) ∧
      -- Consistency property: repeated access returns same values
      (∀ i : Fin n, result.get i = result.get i) ∧
      -- Boundary safety: all indices are valid
      (∀ i : Fin n, i.val < n)⌝⦄ := by
  sorry