import Std.Do.Triple
import Std.Tactic.Do

open Std.Do

/-!
{
  "name": "numpy.linalg.cond",
  "category": "Norms and numbers",
  "description": "Compute the condition number of a matrix",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.linalg.cond.html",
  "doc": "Compute the condition number of a matrix.\n\nThe condition number measures how sensitive the solution x is to errors in b for Ax=b.\n\nParameters:\n- x: The matrix\n- p: Order of the norm\n\nReturns:\n- c: The condition number",
  "code": "\n\n@array_function_dispatch(_cond_dispatcher)\ndef cond(x, p=None):\n    \"\"\"\n    Compute the condition number of a matrix.\n\n    This function is capable of returning the condition number using\n    one of seven different norms, depending on the value of \`p\` (see\n    Parameters below).\n\n    Parameters\n    ----------\n    x : (..., M, N) array_like\n        The matrix whose condition number is sought.\n    p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional\n        Order of the norm used in the condition number computation:\n\n        =====  ============================\n        p      norm for matrices\n        =====  ============================\n        None   2-norm, computed directly using the \`\`SVD\`\`\n        'fro'  Frobenius norm\n        inf    max(sum(abs(x), axis=1))\n        -inf   min(sum(abs(x), axis=1))\n        1      max(sum(abs(x), axis=0))\n        -1     min(sum(abs(x), axis=0))\n        2      2-norm (largest sing. value)\n        -2     smallest singular value\n        =====  ============================\n\n        inf means the \`numpy.inf\` object, and the Frobenius norm is\n        the root-of-sum-of-squares norm.\n\n    Returns\n    -------\n    c : {float, inf}\n        The condition number of the matrix. May be infinite.\n\n    See Also\n    --------\n    numpy.linalg.norm\n\n    Notes\n    -----\n    The condition number of \`x\` is defined as the norm of \`x\` times the\n    norm of the inverse of \`x\` [1]_; the norm can be the usual L2-norm\n    (root-of-sum-of-squares) or one of a number of other matrix norms.\n\n    References\n    ----------\n    .. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,\n           Academic Press, Inc., 1980, pg. 285.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from numpy import linalg as LA\n    >>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n    >>> a\n    array([[ 1,  0, -1],\n           [ 0,  1,  0],\n           [ 1,  0,  1]])\n    >>> LA.cond(a)\n    1.4142135623730951\n    >>> LA.cond(a, 'fro')\n    3.1622776601683795\n    >>> LA.cond(a, np.inf)\n    2.0\n    >>> LA.cond(a, -np.inf)\n    1.0\n    >>> LA.cond(a, 1)\n    2.0\n    >>> LA.cond(a, -1)\n    1.0\n    >>> LA.cond(a, 2)\n    1.4142135623730951\n    >>> LA.cond(a, -2)\n    0.70710678118654746 # may vary\n    >>> (min(LA.svd(a, compute_uv=False)) *\n    ... min(LA.svd(LA.inv(a), compute_uv=False)))\n    0.70710678118654746 # may vary\n\n    \"\"\"\n    x = asarray(x)  # in case we have a matrix\n    if _is_empty_2d(x):\n        raise LinAlgError(\"cond is not defined on empty arrays\")\n    if p is None or p in {2, -2}:\n        s = svd(x, compute_uv=False)\n        with errstate(all='ignore'):\n            if p == -2:\n                r = s[..., -1] / s[..., 0]\n            else:\n                r = s[..., 0] / s[..., -1]\n    else:\n        # Call inv(x) ignoring errors. The result array will\n        # contain nans in the entries where inversion failed.\n        _assert_stacked_square(x)\n        t, result_t = _commonType(x)\n        signature = 'D->D' if isComplexType(t) else 'd->d'\n        with errstate(all='ignore'):\n            invx = _umath_linalg.inv(x, signature=signature)\n            r = norm(x, p, axis=(-2, -1)) * norm(invx, p, axis=(-2, -1))\n        r = r.astype(result_t, copy=False)\n\n    # Convert nans to infs unless the original array had nan entries\n    r = asarray(r)\n    nan_mask = isnan(r)\n    if nan_mask.any():\n        nan_mask &= ~isnan(x).any(axis=(-2, -1))\n        if r.ndim > 0:\n            r[nan_mask] = inf\n        elif nan_mask:\n            r[()] = inf\n\n    # Convention is to return scalars instead of 0d arrays\n    if r.ndim == 0:\n        r = r[()]\n\n    return r"
}
-/

/-- 
Compute the condition number of a square matrix using the 2-norm.

The condition number of a matrix A is defined as ||A|| * ||A^(-1)||,
where ||.|| is the matrix norm. For the 2-norm, this equals the ratio
of the largest singular value to the smallest singular value.

The condition number measures how sensitive the solution x is to errors 
in b for the linear system Ax = b. A condition number of 1 indicates
a perfectly conditioned matrix, while large condition numbers indicate
ill-conditioned matrices.
-/
def conditionNumber {n : Nat} (x : Vector (Vector Float n) n) : Id Float :=
  sorry

/-- 
Specification: The condition number is always non-negative and is at least 1 
for any invertible matrix. This captures the fundamental mathematical 
properties of condition numbers in linear algebra.
-/
theorem conditionNumber_spec {n : Nat} (x : Vector (Vector Float n) n) 
    (h_nonempty : n > 0) :
    ⦃⌜n > 0⌝⦄
    conditionNumber x
    ⦃⇓result => ⌜result ≥ 0 ∧ result ≥ 1⌝⦄ := by
  sorry