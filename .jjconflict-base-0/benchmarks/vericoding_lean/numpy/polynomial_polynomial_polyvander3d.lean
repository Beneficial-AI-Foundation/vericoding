import Std.Do.Triple
import Std.Tactic.Do

/-!
{
  "name": "numpy.polynomial.polynomial.polyvander3d",
  "category": "Standard polynomials",
  "description": "Pseudo-Vandermonde matrix of given degrees.",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyvander3d.html",
  "doc": "Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\n    then The pseudo-Vandermonde matrix is defined by\n\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,\n\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\n    the powers of `x`, `y`, and `z`.\n\n    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\n\n    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the\n    same up to roundoff. This equivalence is useful both for least squares\n    fitting and for the evaluation of a large number of 3-D polynomials\n    of the same degrees and sample points.\n\n    Parameters\n    ----------\n    x, y, z : array_like\n        Arrays of point coordinates, all of the same shape. The dtypes will\n        be converted to either float64 or complex128 depending on whether\n        any of the elements are complex. Scalars are converted to 1-D\n        arrays.\n    deg : list of ints\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n    Returns\n    -------\n    vander3d : ndarray\n        The shape of the returned matrix is ``x.shape + (order,)``, where\n        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will\n        be the same as the converted `x`, `y`, and `z`.\n\n    See Also\n    --------\n    polyvander, polyvander3d, polyval2d, polyval3d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from numpy.polynomial import polynomial as P\n    >>> x = np.asarray([-1, 2, 1])\n    >>> y = np.asarray([1, -2, -3])\n    >>> z = np.asarray([2, 2, 5])\n    >>> l, m, n = [2, 2, 1]\n    >>> deg = [l, m, n]\n    >>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)\n    >>> V\n    array([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,\n             -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],\n           [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,\n             -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],\n           [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,\n            -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])\n\n    We can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,\n    and ``0 <= k <= n``\n\n    >>> i, j, k = 2, 1, 0\n    >>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k\n    array([ True,  True,  True])",
  "code": "def polyvander3d(x, y, z, deg):\n    \"\"\"Pseudo-Vandermonde matrix of given degrees.\n\n    Returns the pseudo-Vandermonde matrix of degrees `deg` and sample\n    points ``(x, y, z)``. If `l`, `m`, `n` are the given degrees in `x`, `y`, `z`,\n    then The pseudo-Vandermonde matrix is defined by\n\n    .. math:: V[..., (m+1)(n+1)i + (n+1)j + k] = x^i * y^j * z^k,\n\n    where ``0 <= i <= l``, ``0 <= j <= m``, and ``0 <= j <= n``.  The leading\n    indices of `V` index the points ``(x, y, z)`` and the last index encodes\n    the powers of `x`, `y`, and `z`.\n\n    If ``V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])``, then the columns\n    of `V` correspond to the elements of a 3-D coefficient array `c` of\n    shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n    .. math:: c_{000}, c_{001}, c_{002},... , c_{010}, c_{011}, c_{012},...\n\n    and  ``np.dot(V, c.flat)`` and ``polyval3d(x, y, z, c)`` will be the\n    same up to roundoff. This equivalence is useful both for least squares\n    fitting and for the evaluation of a large number of 3-D polynomials\n    of the same degrees and sample points.\n\n    Parameters\n    ----------\n    x, y, z : array_like\n        Arrays of point coordinates, all of the same shape. The dtypes will\n        be converted to either float64 or complex128 depending on whether\n        any of the elements are complex. Scalars are converted to 1-D\n        arrays.\n    deg : list of ints\n        List of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n    Returns\n    -------\n    vander3d : ndarray\n        The shape of the returned matrix is ``x.shape + (order,)``, where\n        :math:`order = (deg[0]+1)*(deg([1]+1)*(deg[2]+1)`.  The dtype will\n        be the same as the converted `x`, `y`, and `z`.\n\n    See Also\n    --------\n    polyvander, polyvander3d, polyval2d, polyval3d\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from numpy.polynomial import polynomial as P\n    >>> x = np.asarray([-1, 2, 1])\n    >>> y = np.asarray([1, -2, -3])\n    >>> z = np.asarray([2, 2, 5])\n    >>> l, m, n = [2, 2, 1]\n    >>> deg = [l, m, n]\n    >>> V = P.polyvander3d(x=x, y=y, z=z, deg=deg)\n    >>> V\n    array([[  1.,   2.,   1.,   2.,   1.,   2.,  -1.,  -2.,  -1.,\n             -2.,  -1.,  -2.,   1.,   2.,   1.,   2.,   1.,   2.],\n           [  1.,   2.,  -2.,  -4.,   4.,   8.,   2.,   4.,  -4.,\n             -8.,   8.,  16.,   4.,   8.,  -8., -16.,  16.,  32.],\n           [  1.,   5.,  -3., -15.,   9.,  45.,   1.,   5.,  -3.,\n            -15.,   9.,  45.,   1.,   5.,  -3., -15.,   9.,  45.]])\n\n    We can verify the columns for any ``0 <= i <= l``, ``0 <= j <= m``,\n    and ``0 <= k <= n``\n\n    >>> i, j, k = 2, 1, 0\n    >>> V[:, (m+1)*(n+1)*i + (n+1)*j + k] == x**i * y**j * z**k\n    array([ True,  True,  True])\n\n    \"\"\"\n    return pu._vander_nd_flat((polyvander, polyvander, polyvander), (x, y, z), deg)"
}
-/

open Std.Do

/-- Pseudo-Vandermonde matrix of given degrees for 3D polynomials.
    Returns a matrix where V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k
    for 0 <= i <= xDeg, 0 <= j <= yDeg and 0 <= k <= zDeg. -/
def polyvander3d {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) : 
    Id (Vector (Vector Float ((xDeg + 1) * (yDeg + 1) * (zDeg + 1))) n) :=
  sorry

/-- Specification: polyvander3d creates a pseudo-Vandermonde matrix where each entry
    satisfies the polynomial power relationship V[p, (yDeg + 1)*(zDeg + 1)*i + (zDeg + 1)*j + k] = x[p]^i * y[p]^j * z[p]^k.
    The matrix has dimensions n × ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) and represents all polynomial
    terms x^i * y^j * z^k for 0 ≤ i ≤ xDeg, 0 ≤ j ≤ yDeg, and 0 ≤ k ≤ zDeg. -/
theorem polyvander3d_spec {n : Nat} (x y z : Vector Float n) (xDeg yDeg zDeg : Nat) :
    ⦃⌜True⌝⦄
    polyvander3d x y z xDeg yDeg zDeg
    ⦃⇓V => ⌜∀ p : Fin n, ∀ i : Fin (xDeg + 1), ∀ j : Fin (yDeg + 1), ∀ k : Fin (zDeg + 1),
            let colIdx := (yDeg + 1) * (zDeg + 1) * i.val + (zDeg + 1) * j.val + k.val
            let colIdxFin : Fin ((xDeg + 1) * (yDeg + 1) * (zDeg + 1)) := 
              ⟨colIdx, by sorry⟩
            (V.get p).get colIdxFin = (x.get p) ^ (Float.ofNat i.val) * (y.get p) ^ (Float.ofNat j.val) * (z.get p) ^ (Float.ofNat k.val)⌝⦄ := by
  sorry