vc-description: |-
  /--
  function_signature: "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]"
  docstring: |
      From a supplied list of numbers (of length at least two) select and return two that are the closest to each
      other and return them in order (smaller number, larger number).
  test_cases:
    - input: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]
      expected_output: (2.0, 2.2)
    - input: [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]
      expected_output: (2.0, 2.0)
  -/

vc-preamble: |-
  import Imports.AllImports

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-code: |-
  def implementation (numbers: List Rat): (Rat × Rat) :=
  -- <vc-code>
  let n := numbers.length;
  let sorted_numbers := numbers.mergeSort;
  let min_diff := sorted_numbers.get! 1 - sorted_numbers.get! 0;
  let min_pair := (sorted_numbers.get! 0, sorted_numbers.get! 1);
  let rec loop (i: Nat) (min_diff: Rat) (min_pair: (Rat × Rat)): (Rat × Rat) :=
    if i < n - 1 then
      let diff := sorted_numbers.get! (i + 1) - sorted_numbers.get! i;
      if diff < min_diff then
        loop (i + 1) diff (sorted_numbers.get! i, sorted_numbers.get! (i + 1))
      else
        loop (i + 1) min_diff min_pair
    else
      min_pair;
  loop 1 min_diff min_pair
  -- </vc-code>
  
  #test implementation [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] = (2.0, 2.2)
  #test implementation [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] = (2.0, 2.0)

vc-spec: |-
  def problem_spec
  -- function signature
  (implementation: List Rat → (Rat × Rat))
  -- inputs
  (numbers: List Rat) :=
  -- spec
  let spec (result: (Rat × Rat)) :=
  2 ≤ numbers.length →
  (let (smaller, larger) := result;
  let abs_diff := |larger - smaller|;
  smaller ≤ larger ∧
  smaller ∈ numbers ∧
  larger ∈ numbers ∧
  (∀ x y, x ∈ numbers → y ∈ numbers →  abs_diff ≤ |x - y|) ∧
  (smaller = larger → 1 ≤ (numbers.filter (fun z => z = smaller)).length));
  -- program termination
  ∃ result, implementation numbers = result ∧
  spec result
  
  theorem correctness
  (numbers: List Rat)
  : problem_spec implementation numbers
  :=
  -- <vc-proof>
  by
  unfold problem_spec
  let result := implementation numbers
  use result
  simp [result]
  sorry
  -- </vc-proof>

vc-postamble: |-
  #test implementation [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] = (2.0, 2.2)
  #test implementation [1.0, 2.0, 3.0, 4.0, 5.0, 2.0] = (2.0, 2.0)
  
  

