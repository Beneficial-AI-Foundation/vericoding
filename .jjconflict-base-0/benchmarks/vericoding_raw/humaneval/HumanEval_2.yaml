vc-description: |-
  /--
  function_signature: "def truncate_number(number: float) -> float"
  docstring: |
      Given a positive floating point number, it can be decomposed into
      and integer part (largest integer smaller than given number) and decimals
      (leftover part always smaller than 1).
  
      Return the decimal part of the number.
  test_cases:
    - input: 3.5
      expected_output: 0.5
  -/

vc-preamble: |-
  import Imports.AllImports

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-code: |-
  def implementation (number: Rat) : Rat :=
  -- <vc-code>
  number - number.floor
  -- </vc-code>
  
  #test implementation 3.5 = 0.5

vc-spec: |-
  def problem_spec
  -- function signature
  (impl: Rat → Rat)
  -- inputs
  (number: Rat) :=
  -- spec
  let spec (res) :=
  0 ≤ res ∧
  res < 1 ∧
  number.floor + res = number;
  number > 0 →
  -- program terminates
  (∃ result, impl number = result ∧
  -- return value satisfies spec
  spec result)
  
  theorem correctness
  (number: Rat)
  : problem_spec implementation number :=
  -- <vc-proof>
  by
  unfold problem_spec
  let result := implementation number
  simp [result]
  simp [implementation]
  have h1: ∀ x: Rat, x.floor ≤ x := by
    intro x
    rw [←Rat.le_floor]
  intro npos
  apply And.intro
  apply h1
  have h2 := h1 number
  sorry
  -- </vc-proof>

vc-postamble: |-
  #test implementation 3.5 = 0.5
  
  

