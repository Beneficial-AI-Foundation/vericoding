vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn expr_inner_longest(strings: &Vec<Vec<u8>>, result: Option<&Vec<u8>>) -> (result: bool) {
      match result {
          None => strings.len() == 0,
          Some(s) => {
              (forall|i: int| #![auto] 0 <= i < strings.len() ==> s.len() >= strings[i].len())
                  && (exists|i: int|
                  #![auto]
                  (0 <= i < strings.len() && s == strings[i] && (forall|j: int|
                      #![auto]
                      0 <= j < i ==> strings[j].len() < s.len())))
          },
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_max_len_exists(strings: &Vec<Vec<u8>>) -> (max_len: usize)
      requires strings.len() > 0
      ensures forall|i: int| #![auto] 0 <= i < strings.len() ==> strings[i].len() <= max_len
      ensures exists|i: int| #![auto] 0 <= i < strings.len() && strings[i].len() == max_len
  {
      let mut max_len = strings[0].len();
      let mut j = 0;
      
      while j < strings.len()
          invariant
              0 <= j <= strings.len(),
              forall|k: int| #![auto] 0 <= k < j ==> strings[k].len() <= max_len,
              exists|k: int| #![auto] 0 <= k < j && strings[k].len() == max_len,
      {
          if strings[j].len() > max_len {
              max_len = strings[j].len();
          }
          j += 1;
      }
      max_len
  }
  
  proof fn lemma_first_longest_exists(strings: &Vec<Vec<u8>>, max_len: usize) -> (idx: usize)
      requires 
          strings.len() > 0,
          forall|i: int| #![auto] 0 <= i < strings.len() ==> strings[i].len() <= max_len,
          exists|i: int| #![auto] 0 <= i < strings.len() && strings[i].len() == max_len,
      ensures
          0 <= idx < strings.len(),
          strings[idx].len() == max_len,
          forall|j: int| #![auto] 0 <= j < idx ==> strings[j].len() < max_len,
  {
      let mut i = 0;
      while i < strings.len()
          invariant
              0 <= i <= strings.len(),
              forall|j: int| #![auto] 0 <= j < i ==> strings[j].len() < max_len,
      {
          if strings[i].len() == max_len {
              return i;
          }
          i += 1;
      }
      unreached()
  }

vc-spec: |-
  fn longest(strings: &Vec<Vec<u8>>) -> (result: Option<&Vec<u8>>)
      // post-conditions-start
      ensures
          expr_inner_longest(strings, result),
      // post-conditions-end

vc-code: |-
  {
      if strings.len() == 0 {
          return None;
      }
      
      proof {
          let max_len = lemma_max_len_exists(strings);
          let first_idx = lemma_first_longest_exists(strings, max_len);
      }
      
      let mut max_len = strings[0].len();
      let mut i = 1;
      
      while i < strings.len()
          invariant
              1 <= i <= strings.len(),
              forall|j: int| #![auto] 0 <= j < i ==> strings[j].len() <= max_len,
              exists|j: int| #![auto] 0 <= j < i && strings[j].len() == max_len,
      {
          if strings[i].len() > max_len {
              max_len = strings[i].len();
          }
          i += 1;
      }
      
      i = 0;
      while i < strings.len()
          invariant
              0 <= i <= strings.len(),
              forall|j: int| #![auto] 0 <= j < i ==> strings[j].len() < max_len,
              forall|j: int| #![auto] 0 <= j < strings.len() ==> strings[j].len() <= max_len,
              exists|j: int| #![auto] 0 <= j < strings.len() && strings[j].len() == max_len,
      {
          if strings[i].len() == max_len {
              return Some(&strings[i]);
          }
          i += 1;
      }
      
      unreached()
  }

vc-postamble: |-
  
  }
  fn main() {}

