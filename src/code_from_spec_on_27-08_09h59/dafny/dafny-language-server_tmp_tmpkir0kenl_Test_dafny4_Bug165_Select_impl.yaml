vc-preamble: |-
  // RUN: %dafny /compile:0 "%s" > "%t"
  // RUN: %diff "%s.expect" "%t"
  
  
  type T
  function f(a: T) : bool

vc-helpers: |-
  lemma MultisetSliceExtension<T>(s: seq<T>, i: int, elem: T)
    requires 0 <= i < |s|
    ensures multiset(s[..i+1]) == multiset(s[..i]) + multiset{s[i]}
  {
    assert s[..i+1] == s[..i] + [s[i]];
    assert multiset(s[..i] + [s[i]]) == multiset(s[..i]) + multiset([s[i]]);
    assert multiset([s[i]]) == multiset{s[i]};
  }
  
  lemma MultisetAppendSingle<T>(s: seq<T>, elem: T)
    ensures multiset(s + [elem]) == multiset(s) + multiset{elem}
  {
  }
  
  lemma MultisetSliceComplete<T>(s: seq<T>)
    ensures multiset(s[..|s|]) == multiset(s)
  {
    assert s[..|s|] == s;
  }

vc-spec: |-
  // <vc-spec>
  method Select(s1: seq<T>) returns (r: seq<T>)
    ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])
    ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])
  
  method Main(s1: seq<T>)
  // </vc-spec>

vc-code: |-
  method SelectImpl(s1: seq<T>) returns (r: seq<T>)
    ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])
    ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])
  {
    r := [];
    for i := 0 to |s1|
      invariant forall e: T :: f(e) ==> multiset(s1[..i])[e] == multiset(r)[e]
      invariant forall e: T :: !f(e) ==> multiset(r)[e] == 0
    {
      if f(s1[i]) {
        MultisetSliceExtension(s1, i, s1[i]);
        MultisetAppendSingle(r, s1[i]);
        r := r + [s1[i]];
      } else {
        MultisetSliceExtension(s1, i, s1[i]);
      }
    }
    MultisetSliceComplete(s1);
  }
  
  method MainImpl(s1: seq<T>)
  {
    var result := SelectImpl(s1);
  }

vc-postamble: |-


