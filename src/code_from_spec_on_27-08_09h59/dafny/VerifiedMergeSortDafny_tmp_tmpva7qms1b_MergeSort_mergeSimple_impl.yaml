vc-preamble: |-
  predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)
    reads b
    requires end - start  == |a2| + |a1|
    requires 0 <= start <= end <= b.Length
  {
    multiset(a1) + multiset(a2) == multiset(b[start..end])
  }
  
  predicate sorted_slice(a: array<int>, start: int, end: int)
    requires 0 <= start <= end <= a.Length
    reads a
  {
    forall i, j :: start <= i <= j < end ==> a[i] <= a[j]
  }
  
  predicate sorted_seq(a: seq<int>)
  {
    forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
  }
  
  predicate sorted(a: array<int>)
    reads a
  {
    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
  }

vc-helpers: |-
  lemma multiset_concat_property(s1: seq<int>, s2: seq<int>, s3: seq<int>)
    ensures multiset(s1 + s2) == multiset(s1) + multiset(s2)
  {
  }
  
  lemma sorted_seq_slice(s: seq<int>, i: int, j: int)
    requires sorted_seq(s)
    requires 0 <= i <= j <= |s|
    ensures sorted_seq(s[i..j])
  {
  }
  
  lemma sorted_seq_head(s: seq<int>)
    requires sorted_seq(s) && |s| > 0
    ensures forall i :: 1 <= i < |s| ==> s[0] <= s[i]
  {
  }
  
  lemma array_slice_property(b: array<int>, start: int, end: int, i: int, val: int)
    requires 0 <= start <= i < end <= b.Length
    ensures forall k {:trigger} :: start <= k <= i ==> k < end
  {
  }
  
  lemma size_constraint_lemma(a1: seq<int>, a2: seq<int>, start: int, end: int)
    requires |a1| + |a2| == end - start + 1
    requires 0 <= start <= end
    ensures end - start >= 0
    ensures |a1| + |a2| >= 1
  {
  }

vc-spec: |-
  // <vc-spec>
  method mergeSimple(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)
    modifies b
    requires sorted_seq(a1)
    requires sorted_seq(a2)
    requires 0 <= start <= end <= b.Length
    requires |a1| +  |a2| == end - start + 1
    ensures sorted_slice(b, start, end)
  // </vc-spec>

vc-code: |-
  {
    var i1 := 0;
    var i2 := 0;
    var k := start;
    
    while k < end && i1 < |a1| && i2 < |a2|
      invariant start <= k <= end
      invariant 0 <= i1 <= |a1|
      invariant 0 <= i2 <= |a2|
      invariant i1 + i2 == k - start
      invariant sorted_slice(b, start, k)
      invariant i1 < |a1| ==> forall m {:trigger b[m]} :: start <= m < k ==> b[m] <= a1[i1]
      invariant i2 < |a2| ==> forall m {:trigger b[m]} :: start <= m < k ==> b[m] <= a2[i2]
      decreases end - k
    {
      if a1[i1] <= a2[i2] {
        b[k] := a1[i1];
        i1 := i1 + 1;
      } else {
        b[k] := a2[i2];
        i2 := i2 + 1;
      }
      k := k + 1;
    }
    
    while i1 < |a1|
      invariant start <= k < end
      invariant i1 <= |a1|
      invariant i2 <= |a2|
      invariant i1 + i2 == k - start
      invariant sorted_slice(b, start, k)
      invariant i1 < |a1| ==> forall m {:trigger b[m]} :: start <= m < k ==> b[m] <= a1[i1]
      invariant i2 == |a2|
      decreases |a1| - i1
    {
      b[k] := a1[i1];
      i1 := i1 + 1;
      k := k + 1;
    }
    
    while i2 < |a2|
      invariant start <= k < end
      invariant i1 <= |a1|
      invariant i2 <= |a2|
      invariant i1 + i2 == k - start
      invariant sorted_slice(b, start, k)
      invariant i2 < |a2| ==> forall m {:trigger b[m]} :: start <= m < k ==> b[m] <= a2[i2]
      invariant i1 == |a1|
      decreases |a2| - i2
    {
      b[k] := a2[i2];
      i2 := i2 + 1;
      k := k + 1;
    }
  }

vc-postamble: |-


