vc-preamble: |-
  predicate isSubstring(sub: seq<char>, str: seq<char>)
  {
      exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub
  }
  
  predicate isPrefixPred(pre:string, str:string)
  {
      (|pre| <= |str|) && 
      pre == str[..|pre|]
  }
  
  predicate isNotPrefixPred(pre:string, str:string)
  {
      (|pre| > |str|) || 
      pre != str[..|pre|]
  }
  
  predicate isSubstringPred(sub:string, str:string)
  {
      (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))
  }
  
  predicate isNotSubstringPred(sub:string, str:string)
  {
      (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))
  }
  
  
  
  predicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)
  {
      exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)
  }
  
  predicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)
  {
      forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)
  }
  
  method haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)
      ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)
      //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.
  {
      // Check that both strings are larger than k 
      if (k > |str1| || k > |str2| ){
          return false;
      }
      // Initialize variables
      var i := 0;
      var temp := false;
  
      // Don't want to exceed the bounds of str1 when checking for the element that is k entries away
      while i <= |str1|-k
      // Invariant to stay within bounds
      invariant 0 <= i <= (|str1|-k) + 1
      // Invariant to show that when temp is true, it is a substring
      invariant temp ==> 0 <= i <= (|str1| - k) && isSubstringPred(str1[i..i+k], str2)
      // Invariant to show that when temp is false, it is not a substring
      invariant !temp ==> (forall m,n :: (0 <= m < i && n == m+k) ==> isNotSubstringPred(str1[m..n], str2))
      // Telling dafny that i is that value that is increasing
      decreases |str1| - k - i
      {
          assume false;
  
          // Get an index from the array position were are at to the array position that is k away and check the substring
          temp := isSubstring(str1[i..(i + k)], str2);
          if  temp == true 
          {
              return true;
          }
          i := i + 1;
      }
      return false;
  }

vc-helpers: |-
  lemma emptySubstringExists(str: string)
      ensures haveCommonKSubstringPred(0, "", str)
  {
      assert isPrefixPred("", str[0..]);
      assert isSubstringPred("", str);
      assert 0 <= 0 <= |""| - 0 && 0 == 0 + 0;
      assert isSubstringPred(""[0..0], str);
  }
  
  lemma emptyStringCommon(str1: string, str2: string)
      ensures haveCommonKSubstringPred(0, str1, str2)
  {
      if |str1| == 0 {
          emptySubstringExists(str2);
      } else {
          assert str1[0..0] == "";
          assert isPrefixPred("", str2[0..]);
          assert isSubstringPred(str1[0..0], str2);
          assert 0 <= 0 <= |str1| - 0 && 0 == 0 + 0;
      }
  }
  
  lemma haveCommonKSubstringEquivalence(k: nat, str1: string, str2: string)
      ensures haveCommonKSubstringPred(k, str1, str2) <==> !haveNotCommonKSubstringPred(k, str1, str2)
  {
  }
  
  lemma zeroLengthSubstringAlwaysExists(str1: string, str2: string)
      ensures haveCommonKSubstringPred(0, str1, str2)
  {
      emptyStringCommon(str1, str2);
  }

vc-spec: |-
  // <vc-spec>
  method maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)
      requires (|str1| <= |str2|)
      ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))
      ensures haveCommonKSubstringPred(len,str1,str2)
  // </vc-spec>

vc-code: |-
  {
      if |str1| == 0 {
          assert 0 <= 0 <= |str1| - 0 && 0 == 0 + 0;
          assert str1[0..0] == "";
          assert isPrefixPred("", str2[0..]);
          assert isSubstringPred(str1[0..0], str2);
          return 0;
      }
      
      var k := |str1|;
      
      while k > 0
          invariant 0 <= k <= |str1|
          invariant forall j :: k < j <= |str1| ==> !haveCommonKSubstringPred(j, str1, str2)
          decreases k
      {
          var hasCommon := haveCommonKSubstring(k, str1, str2);
          if hasCommon {
              return k;
          }
          k := k - 1;
      }
      
      zeroLengthSubstringAlwaysExists(str1, str2);
      return 0;
  }

vc-postamble: |-


