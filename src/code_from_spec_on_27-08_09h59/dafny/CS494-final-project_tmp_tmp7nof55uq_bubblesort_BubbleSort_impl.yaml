vc-preamble: |-
  //Bubblesort CS 494 submission
  //References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785
  
  
  // predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array
  
  predicate sorted(a:array<int>, from:int, to:int)
    requires a != null; // requires array to have n amount of elements
    reads a; 
    requires 0 <= from <= to <= a.Length; // pre condition checks that from is the start of the range and to is the end of the range, requires values to be within 0 - a.Length
  {
    forall x, y :: from <= x < y < to ==> a[x] <= a[y]
  }
  
  //helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept 
  predicate pivot(a:array<int>, to:int, pvt:int)
    requires a != null; // requires array to have n amount of elements
    reads a;
    requires 0 <= pvt < to <= a.Length;
  {
    forall x, y :: 0 <= x < pvt < y < to ==> a[x] <= a[y] // all values within the array should be in ascending order
  }
  
  // Here having the algorithm for the bubblesort

vc-helpers: |-
  lemma SortedTransitive(a: array<int>, from: int, mid: int, to: int)
    requires 0 <= from <= mid <= to <= a.Length
    requires sorted(a, from, mid)
    requires sorted(a, mid, to)
    requires mid == from || mid == to || (mid > from && mid < to && a[mid-1] <= a[mid])
    ensures sorted(a, from, to)
  {
    if from < to {
      forall x, y | from <= x < y < to
        ensures a[x] <= a[y]
      {
        if y < mid {
          assert sorted(a, from, mid);
        } else if x >= mid {
          assert sorted(a, mid, to);
        } else {
          assert x < mid <= y;
          if mid > from && mid < to {
            assert a[x] <= a[mid-1] <= a[mid] <= a[y];
          }
        }
      }
    }
  }
  
  lemma SwapPreservesMultiset(a: array<int>, i: int, j: int)
    requires 0 <= i < a.Length && 0 <= j < a.Length
    ensures multiset(a[..][i := a[j]][j := a[i]]) == multiset(a[..])
  {
  }
  
  lemma PivotImpliesSorted(a: array<int>, to: int, pvt: int)
    requires 0 <= pvt < to <= a.Length
    requires pivot(a, to, pvt)
    requires sorted(a, 0, pvt)
    requires sorted(a, pvt, to)
    ensures sorted(a, 0, to)
  {
    forall x, y | 0 <= x < y < to
      ensures a[x] <= a[y]
    {
      if y < pvt {
        assert sorted(a, 0, pvt);
      } else if x >= pvt {
        assert sorted(a, pvt, to);
      } else {
        assert pivot(a, to, pvt);
        assert 0 <= x < pvt < y < to;
      }
    }
  }
  
  lemma BubbleOnePassHelper(a: array<int>, start: int, end: int) returns (max_idx: int)
    requires 0 <= start < end <= a.Length
    ensures start <= max_idx < end
    ensures forall k :: start <= k < end ==> a[k] <= a[max_idx]
  {
    max_idx := start;
    var k := start;
    while k < end
      invariant start <= k <= end
      invariant start <= max_idx < end
      invariant forall l :: start <= l < k ==> a[l] <= a[max_idx]
    {
      if a[k] > a[max_idx] {
        max_idx := k;
      }
      k := k + 1;
    }
  }
  
  lemma SortedExtend(a: array<int>, from: int, to: int)
    requires 0 <= from <= to <= a.Length
    requires sorted(a, from, to)
    requires to < a.Length
    requires from == to || a[to-1] <= a[to]
    ensures sorted(a, from, to+1)
  {
    if from < to + 1 {
      forall x, y | from <= x < y < to + 1
        ensures a[x] <= a[y]
      {
        if y < to {
          assert sorted(a, from, to);
        } else {
          assert y == to;
          if x < to {
            if from == to {
              assert false;
            } else {
              assert a[x] <= a[to-1] <= a[to];
            }
          }
        }
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method BubbleSort (a: array<int>)
      requires a != null && a.Length > 0; // makes sure a is not empty and length is greater than 0
      modifies a; // as method runs, we are changing a
      ensures sorted(a, 0, a.Length); // makes sure elements of array a are sorted from 0 - a.Length
      ensures multiset(a[..]) == multiset(old(a[..])); // Since a is being modified, we deference the heap 
                                                        //and compare the previous elements to current elements.
  // </vc-spec>

vc-code: |-
  {
    var n := a.Length;
    var i := 0;
    
    while i < n - 1
      invariant 0 <= i <= n - 1
      invariant sorted(a, n - i, n)
      invariant forall x, y {:trigger a[x], a[y]} :: 0 <= x < n - i && n - i <= y < n ==> a[x] <= a[y]
      invariant multiset(a[..]) == multiset(old(a[..]))
    {
      var j := 0;
      
      while j < n - 1 - i
        invariant 0 <= j <= n - 1 - i
        invariant sorted(a, n - i, n)
        invariant forall x, y {:trigger a[x], a[y]} :: 0 <= x < n - i && n - i <= y < n ==> a[x] <= a[y]
        invariant forall k {:trigger a[k]} :: 0 <= k <= j ==> (forall l :: j < l < n - i ==> a[k] <= a[l])
        invariant forall k {:trigger a[k]} :: n - i <= k < n ==> (forall l :: 0 <= l <= j ==> a[l] <= a[k])
        invariant multiset(a[..]) == multiset(old(a[..]))
      {
        if a[j] > a[j + 1] {
          a[j], a[j + 1] := a[j + 1], a[j];
        }
        j := j + 1;
      }
      
      assert sorted(a, n - i - 1, n);
      i := i + 1;
    }
    
    assert i == n - 1;
    assert sorted(a, 1, n);
    assert sorted(a, 0, 1);
    SortedTransitive(a, 0, 1, n);
  }

vc-postamble: |-


