vc-preamble: |-
  // see pdf 'ex6 & 7 documentation' for excercise question
  
  
  datatype Bases = A | C | G | T
  
  //swaps two sequence indexes
  method Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)
  requires 0 < |s| && x < |s| && y < |s|
  ensures |t| == |s|
  ensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]
  ensures t[x] == s[y] && s[x] == t[y]
  ensures multiset(s) == multiset(t)
  {
    assume{:axiom} false;
  }
  
  //idea from Rustan Leino video "Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm"
  //modified for 4 elements
  predicate below(first: Bases, second: Bases)
  {
      first == second ||
      first == A || 
      (first == C && (second ==  G || second == T)) || 
      (first == G && second == T) ||
      second == T
  }
  
  //checks if a sequence is in base order
  predicate bordered(s:seq<Bases>)
  {
      forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])
  }

vc-helpers: |-
  lemma BelowTransitive(a: Bases, b: Bases, c: Bases)
    requires below(a, b) && below(b, c)
    ensures below(a, c)
  {
  }
  
  lemma BelowReflexive(a: Bases)
    ensures below(a, a)
  {
  }
  
  lemma BelowTotal(a: Bases, b: Bases)
    ensures below(a, b) || below(b, a)
  {
  }
  
  lemma ExchangerPreservesBordered(s: seq<Bases>, x: nat, y: nat, t: seq<Bases>)
    requires 0 < |s| && x < |s| && y < |s|
    requires |t| == |s|
    requires forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]
    requires t[x] == s[y] && s[x] == t[y]
    requires x <= y
    requires forall i :: 0 <= i < x ==> below(s[i], s[y])
    requires forall i :: x < i < y ==> below(s[x], s[i])
    requires forall i :: y < i < |s| ==> below(s[x], s[i])
    ensures forall i :: 0 <= i < x ==> below(t[i], t[x])
    ensures forall i :: x < i < y ==> below(t[y], t[i])
    ensures forall i :: y < i < |s| ==> below(t[y], t[i])
  {
  }
  
  lemma MultisetPreservedByExchange(s: seq<Bases>, t: seq<Bases>, x: nat, y: nat)
    requires 0 < |s| && x < |s| && y < |s|
    requires |t| == |s|
    requires forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]
    requires t[x] == s[y] && s[x] == t[y]
    ensures multiset(s) == multiset(t)
  {
  }
  
  lemma SortedSequenceIsBordered(s: seq<Bases>)
    requires |s| >= 3
    requires forall i :: 0 <= i < |s| - 3 ==> (s[i] == A)
    requires forall i :: |s| - 3 <= i < |s| - 2 && |s| >= 3 ==> (s[i] == C)
    requires forall i :: |s| - 2 <= i < |s| - 1 && |s| >= 2 ==> (s[i] == G)
    requires forall i :: |s| - 1 <= i < |s| && |s| >= 1 ==> (s[i] == T)
    ensures bordered(s)
  {
  }
  
  lemma FourRegionsBordered(s: seq<Bases>, a: int, c: int, g: int)
    requires 0 <= a <= c <= g <= |s|
    requires forall i :: 0 <= i < a ==> s[i] == A
    requires forall i :: a <= i < c ==> s[i] == C
    requires forall i :: c <= i < g ==> s[i] == G
    requires forall i :: g <= i < |s| ==> s[i] == T
    ensures bordered(s)
  {
  }

vc-spec: |-
  // <vc-spec>
  method Sorter(bases: seq<Bases>) returns (sobases:seq<Bases>)
  requires 0 < |bases|
  ensures |sobases| == |bases|
  ensures bordered(sobases)
  ensures multiset(bases) == multiset(sobases);
  // </vc-spec>

vc-code: |-
  {
    sobases := bases;
    var n := |bases|;
    var a := 0;
    var c := 0;
    var g := 0;
    
    while g < n
      invariant 0 <= a <= c <= g <= n
      invariant |sobases| == |bases|
      invariant multiset(sobases) == multiset(bases)
      invariant forall i :: 0 <= i < a ==> sobases[i] == A
      invariant forall i :: a <= i < c ==> sobases[i] == C
      invariant forall i :: c <= i < g ==> sobases[i] == G
      invariant forall i :: g <= i < n ==> sobases[i] == G || sobases[i] == T
      invariant n <= |sobases|
      decreases n - g
    {
      if sobases[g] == A {
        if c > a {
          sobases := Exchanger(sobases, g, c);
          sobases := Exchanger(sobases, c, a);
        } else {
          sobases := Exchanger(sobases, g, a);
        }
        a := a + 1;
        c := c + 1;
      } else if sobases[g] == C {
        sobases := Exchanger(sobases, g, c);
        c := c + 1;
      } else if sobases[g] == G {
        g := g + 1;
      } else {
        assert sobases[g] == T;
        sobases := Exchanger(sobases, g, n - 1);
        n := n - 1;
      }
    }
    
    assert g == n;
    assert 0 <= a <= c <= g <= |sobases|;
    assert forall i :: 0 <= i < a ==> sobases[i] == A;
    assert forall i :: a <= i < c ==> sobases[i] == C;
    assert forall i :: c <= i < g ==> sobases[i] == G;
    assert forall i :: g <= i < |sobases| ==> sobases[i] == T;
    
    FourRegionsBordered(sobases, a, c, g);
  }

vc-postamble: |-


