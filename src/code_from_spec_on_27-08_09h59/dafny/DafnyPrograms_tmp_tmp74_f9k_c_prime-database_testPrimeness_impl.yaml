vc-preamble: |-
  //predicate for primeness
  ghost predicate prime(n: nat)
  
  { n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }
  
  datatype Answer = Yes | No | Unknown
  
  //the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number
  //is not in the database it returns Unknown
  class {:autocontracts} PrimeMap{
  
    var database: map<nat, bool>; 
  
  //the valid invariant of the class
    ghost predicate Valid()
      reads this
    {
      forall i | i in database.Keys :: (database[i] == true <==> prime(i)) 
    }
  
  //the constructor
    constructor()
      ensures database == map[]
    {
      database := map[];
    }
  
  
    // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,
    // or with Unknown when it's not in the databse
  method IsPrime?(n: nat) returns (answer: Answer) 
        ensures database.Keys == old(database.Keys)
        ensures (n in database) && prime(n) <==> answer == Yes 
        ensures (n in database) && !prime(n) <==> answer == No 
        ensures !(n in database) <==> answer == Unknown
  {
    assume{:axiom} false;
  }
  
    // method to test whether a number is prime, returns bool
  
  }

vc-helpers: |-
  lemma PrimeZeroOne()
    ensures !prime(0)
    ensures !prime(1)
  {
  }
  
  lemma PrimeTwo()
    ensures prime(2)
  {
  }
  
  lemma PrimeThree()
    ensures prime(3)
  {
  }
  
  lemma NotPrimeFour()
    ensures !prime(4)
  {
    assert 4 % 2 == 0;
    assert 1 < 2 < 4;
  }
  
  lemma PrimeTestCorrect(n: nat, i: nat)
    requires n > 1
    requires 1 < i < n
    requires n % i == 0
    ensures !prime(n)
  {
  }
  
  lemma AllDivisorsChecked(n: nat)
    requires n > 1
    requires forall i | 1 < i < n :: n % i != 0
    ensures prime(n)
  {
  }

vc-spec: |-
  // <vc-spec>
  method testPrimeness(n: nat) returns (result: bool) 
        requires n >= 0
        ensures result <==> prime(n)
  // </vc-spec>

vc-code: |-
  {
    if n <= 1 {
      PrimeZeroOne();
      return false;
    }
    if n == 2 {
      PrimeTwo();
      return true;
    }
    if n == 3 {
      PrimeThree();
      return true;
    }
    if n == 4 {
      NotPrimeFour();
      return false;
    }
    
    var i := 2;
    while i < n
      invariant 2 <= i <= n
      invariant forall j | 1 < j < i :: n % j != 0
      decreases n - i
    {
      if n % i == 0 {
        PrimeTestCorrect(n, i);
        return false;
      }
      i := i + 1;
    }
    
    AllDivisorsChecked(n);
    return true;
  }

vc-postamble: |-


