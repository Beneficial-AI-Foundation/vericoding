vc-preamble: |-
  predicate SplitPoint(a: array<int>, n: int)
      reads a
      requires 0 <= n <= n
  
  {
      forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]
  }
  
  
  
  twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)
      requires 0 <= lo <= hi <= a.Length
      reads a
  {
      (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))
  }
  
  method Partition(a: array<int>, lo: int, hi: int) returns (p: int)
      requires 0 <= lo < hi <= a.Length
      requires SplitPoint(a, lo) && SplitPoint(a, hi)
      modifies a
      ensures lo <= p < hi
      ensures forall i :: lo <= i < p ==> a[i] < a[p]
      ensures forall i :: p <= i < hi ==> a[p] <= a[i]
      ensures SplitPoint(a, lo) && SplitPoint(a, hi)
      ensures SwapFrame(a, lo, hi)
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma PartitionPreservesSplitPoint(a: array<int>, lo: int, hi: int, p: int)
      requires 0 <= lo <= p < hi <= a.Length
      requires SplitPoint(a, lo) && SplitPoint(a, hi)
      requires forall i :: lo <= i < p ==> a[i] < a[p]
      requires forall i :: p <= i < hi ==> a[p] <= a[i]
      ensures SplitPoint(a, p) && SplitPoint(a, p+1)
  {
      forall i,j | 0 <= i < p <= j < a.Length
          ensures a[i] <= a[j]
      {
          if j < hi {
              if i >= lo {
                  assert a[i] < a[p] <= a[j];
              } else {
                  assert SplitPoint(a, lo);
                  assert a[i] <= a[p] <= a[j];
              }
          } else {
              assert SplitPoint(a, hi);
              assert a[p] <= a[j];
              if i >= lo {
                  assert a[i] < a[p];
              } else {
                  assert SplitPoint(a, lo);
                  assert a[i] <= a[p];
              }
          }
      }
      
      forall i,j | 0 <= i < p+1 <= j < a.Length
          ensures a[i] <= a[j]
      {
          if i < p {
              if j < hi {
                  if i >= lo {
                      assert a[i] < a[p] <= a[j];
                  } else {
                      assert SplitPoint(a, lo);
                      assert a[i] <= a[p] <= a[j];
                  }
              } else {
                  assert SplitPoint(a, hi);
                  assert a[p] <= a[j];
                  if i >= lo {
                      assert a[i] < a[p];
                  } else {
                      assert SplitPoint(a, lo);
                      assert a[i] <= a[p];
                  }
              }
          } else {
              assert i == p;
              if j < hi {
                  assert a[p] <= a[j];
              } else {
                  assert SplitPoint(a, hi);
                  assert a[p] <= a[j];
              }
          }
      }
  }
  
  lemma SortedPreservesSplitPoint(a: array<int>, lo: int, hi: int, mid: int)
      requires 0 <= lo <= mid < hi <= a.Length
      requires forall i,j :: lo <= i < j < mid ==> a[i] <= a[j]
      requires forall i,j :: mid+1 <= i < j < hi ==> a[i] <= a[j]
      requires SplitPoint(a, lo) && SplitPoint(a, hi)
      requires forall i :: lo <= i < mid ==> a[i] <= a[mid]
      requires forall i :: mid < i < hi ==> a[mid] <= a[i]
      ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]
  {
      forall i,j | lo <= i < j < hi
          ensures a[i] <= a[j]
      {
          if i < mid && j < mid {
              assert a[i] <= a[j];
          } else if i > mid && j > mid {
              assert a[i] <= a[j];
          } else if i == mid && j > mid {
              assert a[mid] <= a[j];
          } else if i < mid && j == mid {
              assert a[i] <= a[mid];
          } else {
              assert i < mid < j;
              assert a[i] <= a[mid] <= a[j];
          }
      }
  }
  
  lemma QuickSortPreservesPartitionBounds(a: array<int>, lo: int, hi: int, p: int, pivot_val: int)
      requires 0 <= lo <= p < hi <= a.Length
      requires SplitPoint(a, lo) && SplitPoint(a, hi)
      requires a[p] == pivot_val
      requires forall i :: lo <= i < p ==> a[i] <= pivot_val
      requires forall i :: p < i < hi ==> pivot_val <= a[i]
      requires forall i,j :: lo <= i < j < p ==> a[i] <= a[j]
      requires forall i,j :: p+1 <= i < j < hi ==> a[i] <= a[j]
      ensures forall i :: lo <= i < p ==> a[i] <= a[p]
      ensures forall i :: p < i < hi ==> a[p] <= a[i]
  {
      forall i | lo <= i < p
          ensures a[i] <= a[p]
      {
          assert a[i] <= pivot_val == a[p];
      }
      
      forall i | p < i < hi
          ensures a[p] <= a[i]
      {
          assert a[p] == pivot_val <= a[i];
      }
  }

vc-spec: |-
  // <vc-spec>
  method QuickSortAux(a: array<int>, lo: int, hi: int)
      requires 0 <= lo <= hi <= a.Length
      requires SplitPoint(a, lo) && SplitPoint(a, hi)
      modifies a
      ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]
      ensures SwapFrame(a, lo, hi)
      ensures SplitPoint(a, lo) && SplitPoint(a, hi)
      decreases hi - lo
  // </vc-spec>

vc-code: |-
  {
      if lo >= hi - 1 {
          return;
      }
      
      var p := Partition(a, lo, hi);
      var pivot_val := a[p];
      
      PartitionPreservesSplitPoint(a, lo, hi, p);
      
      QuickSortAux(a, lo, p);
      QuickSortAux(a, p+1, hi);
      
      assert a[p] == pivot_val;
      assert forall i :: lo <= i < p ==> a[i] <= pivot_val;
      assert forall i :: p < i < hi ==> pivot_val <= a[i];
      
      QuickSortPreservesPartitionBounds(a, lo, hi, p, pivot_val);
      SortedPreservesSplitPoint(a, lo, hi, p);
  }

vc-postamble: |-


