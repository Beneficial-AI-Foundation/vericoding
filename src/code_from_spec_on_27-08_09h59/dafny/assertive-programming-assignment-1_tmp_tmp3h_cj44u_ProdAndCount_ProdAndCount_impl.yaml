vc-preamble: |-
  
  function RecursivePositiveProduct(q: seq<int>): int
      decreases |q|
  {
      if q == [] then 1
      else if q[0] <= 0 then RecursivePositiveProduct(q[1..])
      else q[0] * RecursivePositiveProduct(q[1..])
  }
  
  function RecursiveCount(key: int, q: seq<int>): int
      decreases |q|
  {
      if q == [] then 0
      else if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])
      else RecursiveCount(key, q[..|q|-1])
  }
  
  function county(elem: int, key: int): int{
      if elem==key then 1 else 0
  }
  
  function prody(elem: int): int{
      if elem <= 0 then 1 else elem
  }

vc-helpers: |-
  lemma RecursivePositiveProductAppend(q1: seq<int>, q2: seq<int>)
      ensures RecursivePositiveProduct(q1 + q2) == RecursivePositiveProduct(q1) * RecursivePositiveProduct(q2)
  {
      if q1 == [] {
          assert q1 + q2 == q2;
      } else {
          RecursivePositiveProductAppend(q1[1..], q2);
          assert q1 + q2 == [q1[0]] + (q1[1..] + q2);
      }
  }
  
  lemma SeqAssociativity(a: seq<int>, b: seq<int>, c: seq<int>)
      ensures (a + b) + c == a + (b + c)
  {
  }
  
  lemma RecursiveCountAppend(key: int, q1: seq<int>, q2: seq<int>)
      ensures RecursiveCount(key, q1 + q2) == RecursiveCount(key, q1) + RecursiveCount(key, q2)
  {
      if q1 == [] {
          assert q1 + q2 == q2;
      } else {
          RecursiveCountAppend(key, q1[..|q1|-1], q2);
          assert q1 == q1[..|q1|-1] + [q1[|q1|-1]];
          SeqAssociativity(q1[..|q1|-1], [q1[|q1|-1]], q2);
          assert q1 + q2 == (q1[..|q1|-1] + [q1[|q1|-1]]) + q2;
          assert q1 + q2 == q1[..|q1|-1] + ([q1[|q1|-1]] + q2);
      }
  }
  
  lemma ProdInvariant(q: seq<int>, i: int, acc_prod: int)
      requires 0 <= i <= |q|
      requires acc_prod == RecursivePositiveProduct(q[..i])
      ensures acc_prod * RecursivePositiveProduct(q[i..]) == RecursivePositiveProduct(q)
  {
      RecursivePositiveProductAppend(q[..i], q[i..]);
      assert q[..i] + q[i..] == q;
  }
  
  lemma CountInvariant(key: int, q: seq<int>, i: int, acc_count: int)
      requires 0 <= i <= |q|
      requires acc_count == RecursiveCount(key, q[..i])
      ensures acc_count + RecursiveCount(key, q[i..]) == RecursiveCount(key, q)
  {
      RecursiveCountAppend(key, q[..i], q[i..]);
      assert q[..i] + q[i..] == q;
  }
  
  lemma ProdStep(q: seq<int>, i: int)
      requires 0 <= i < |q|
      ensures RecursivePositiveProduct(q[..i+1]) == RecursivePositiveProduct(q[..i]) * (if q[i] > 0 then q[i] else 1)
  {
      assert q[..i+1] == q[..i] + [q[i]];
      RecursivePositiveProductAppend(q[..i], [q[i]]);
  }
  
  lemma CountStep(key: int, q: seq<int>, i: int)
      requires 0 <= i < |q|
      ensures RecursiveCount(key, q[..i+1]) == RecursiveCount(key, q[..i]) + (if q[i] == key then 1 else 0)
  {
      assert q[..i+1] == q[..i] + [q[i]];
      RecursiveCountAppend(key, q[..i], [q[i]]);
  }

vc-spec: |-
  // <vc-spec>
  method ProdAndCount(q: seq<int>, key: int) returns (prod: int, count: nat)
      ensures prod == RecursivePositiveProduct(q)
      ensures count == RecursiveCount(key, q)
  // </vc-spec>

vc-code: |-
  {
      prod := 1;
      count := 0;
      var i := 0;
      
      while i < |q|
          invariant 0 <= i <= |q|
          invariant prod == RecursivePositiveProduct(q[..i])
          invariant count == RecursiveCount(key, q[..i])
      {
          ProdStep(q, i);
          CountStep(key, q, i);
          
          if q[i] > 0 {
              prod := prod * q[i];
          }
          if q[i] == key {
              count := count + 1;
          }
          i := i + 1;
      }
      
      assert q[..|q|] == q;
  }

vc-postamble: |-


