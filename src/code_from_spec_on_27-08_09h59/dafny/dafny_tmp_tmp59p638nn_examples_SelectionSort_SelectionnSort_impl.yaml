vc-preamble: |-
  twostate predicate Preserved(a: array<int>, left: nat, right: nat)
      reads a
      requires left <= right <= a.Length
  {
      multiset(a[left..right]) == multiset(old(a[left..right]))
  }
  
  ghost predicate Ordered(a: array<int>, left: nat, right: nat)
      reads a
      requires left <= right <= a.Length
  {
      forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]
  }
  
  twostate predicate Sorted(a: array<int>)
      reads a
  {
      Ordered(a,0,a.Length) && Preserved(a,0,a.Length)
  }

vc-helpers: |-
  lemma PreservedTransitive(a: array<int>, left: nat, right: nat)
      requires left <= right <= a.Length
      requires multiset(a[left..right]) == multiset(old(a[left..right]))
      ensures Preserved(a, left, right)
  {
  }
  
  lemma MultisetSwapPreserved(a: array<int>, i: nat, j: nat)
      requires 0 <= i < a.Length
      requires 0 <= j < a.Length
      modifies a
      ensures multiset(a[..]) == multiset(old(a[..]))
  {
      var oldArray := a[..];
      a[i], a[j] := a[j], a[i];
      assert multiset(a[..]) == multiset(oldArray);
  }

vc-spec: |-
  // <vc-spec>
  method SelectionnSort(a: array<int>)
      modifies a
      ensures Sorted(a)
  // </vc-spec>

vc-code: |-
  {
      ghost var original := a[..];
      var n := 0;
      while n < a.Length
          invariant 0 <= n <= a.Length
          invariant Ordered(a, 0, n)
          invariant multiset(a[..]) == multiset(original)
          invariant forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]
      {
          var minIndex := n;
          var k := n + 1;
          
          while k < a.Length
              invariant n <= minIndex < a.Length
              invariant n <= k <= a.Length
              invariant forall i :: n <= i < k ==> a[minIndex] <= a[i]
              invariant multiset(a[..]) == multiset(original)
          {
              if a[k] < a[minIndex] {
                  minIndex := k;
              }
              k := k + 1;
          }
          
          if minIndex != n {
              MultisetSwapPreserved(a, n, minIndex);
              a[n], a[minIndex] := a[minIndex], a[n];
          }
          
          n := n + 1;
      }
      
      assert multiset(a[..]) == multiset(original);
      assert Preserved(a, 0, a.Length) by {
          PreservedTransitive(a, 0, a.Length);
      }
  }

vc-postamble: |-


