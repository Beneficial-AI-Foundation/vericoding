vc-preamble: |-
  predicate IsEven(n: int)
  {
      n % 2 == 0
  }
  
  predicate IsOdd(n: int)
  {
      n % 2 != 0
  }
  
  predicate IsFirstEven(evenIndex: int, lst: seq<int>)
      requires 0 <= evenIndex < |lst|
      requires IsEven(lst[evenIndex])
  {
      forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])
  }
  
  predicate IsFirstOdd(oddIndex: int, lst: seq<int>)
      requires 0 <= oddIndex < |lst|
      requires IsOdd(lst[oddIndex])
  {
      forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])
  }
  
  
  method FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)
      requires |lst| >= 2
      requires exists i :: 0 <= i < |lst| && IsEven(lst[i])
      requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])
      ensures 0 <= evenIndex < |lst|
      ensures 0 <= oddIndex < |lst|
      // This is the postcondition that ensures that it's the first, not just any
      ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)
      ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma FirstEvenOddExists(lst: seq<int>)
      requires exists i :: 0 <= i < |lst| && IsEven(lst[i])
      requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])
      ensures exists i :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst)
      ensures exists i :: 0 <= i < |lst| && IsOdd(lst[i]) && IsFirstOdd(i, lst)
  {
      var evenWitness :| 0 <= evenWitness < |lst| && IsEven(lst[evenWitness]);
      var oddWitness :| 0 <= oddWitness < |lst| && IsOdd(lst[oddWitness]);
      
      var firstEven := FindFirstEvenIndex(lst, 0);
      var firstOdd := FindFirstOddIndex(lst, 0);
      
      assert IsEven(lst[firstEven]) && IsFirstEven(firstEven, lst);
      assert IsOdd(lst[firstOdd]) && IsFirstOdd(firstOdd, lst);
  }
  
  lemma FindFirstEvenIndexIsFirst(lst: seq<int>, start: int)
      requires 0 <= start <= |lst|
      requires exists i :: start <= i < |lst| && IsEven(lst[i])
      requires forall j :: 0 <= j < start ==> IsOdd(lst[j])
      ensures IsFirstEven(FindFirstEvenIndex(lst, start), lst)
      decreases |lst| - start
  {
      if start >= |lst| {
          return;
      } else if IsEven(lst[start]) {
          // Found even at start, prove all before start are odd
          assert forall j :: 0 <= j < start ==> IsOdd(lst[j]);
      } else {
          // lst[start] is odd, continue search
          assert IsOdd(lst[start]);
          assert forall j :: 0 <= j < start + 1 ==> IsOdd(lst[j]);
          FindFirstEvenIndexIsFirst(lst, start + 1);
      }
  }
  
  lemma FindFirstOddIndexIsFirst(lst: seq<int>, start: int)
      requires 0 <= start <= |lst|
      requires exists i :: start <= i < |lst| && IsOdd(lst[i])
      requires forall j :: 0 <= j < start ==> IsEven(lst[j])
      ensures IsFirstOdd(FindFirstOddIndex(lst, start), lst)
      decreases |lst| - start
  {
      if start >= |lst| {
          return;
      } else if IsOdd(lst[start]) {
          // Found odd at start, prove all before start are even
          assert forall j :: 0 <= j < start ==> IsEven(lst[j]);
      } else {
          // lst[start] is even, continue search
          assert IsEven(lst[start]);
          assert forall j :: 0 <= j < start + 1 ==> IsEven(lst[j]);
          FindFirstOddIndexIsFirst(lst, start + 1);
      }
  }
  
  function FindFirstEvenIndex(lst: seq<int>, start: int): int
      requires 0 <= start <= |lst|
      requires exists i :: start <= i < |lst| && IsEven(lst[i])
      ensures start <= FindFirstEvenIndex(lst, start) < |lst|
      ensures IsEven(lst[FindFirstEvenIndex(lst, start)])
      ensures start == 0 ==> IsFirstEven(FindFirstEvenIndex(lst, start), lst)
      decreases |lst| - start
  {
      if start >= |lst| then start
      else if IsEven(lst[start]) then start
      else FindFirstEvenIndex(lst, start + 1)
  }
  
  function FindFirstOddIndex(lst: seq<int>, start: int): int
      requires 0 <= start <= |lst|
      requires exists i :: start <= i < |lst| && IsOdd(lst[i])
      ensures start <= FindFirstOddIndex(lst, start) < |lst|
      ensures IsOdd(lst[FindFirstOddIndex(lst, start)])
      ensures start == 0 ==> IsFirstOdd(FindFirstOddIndex(lst, start), lst)
      decreases |lst| - start
  {
      if start >= |lst| then start
      else if IsOdd(lst[start]) then start
      else FindFirstOddIndex(lst, start + 1)
  }

vc-spec: |-
  // <vc-spec>
  method ProductEvenOdd(lst: seq<int>) returns (product : int)
      requires |lst| >= 2
      requires exists i :: 0 <= i < |lst| && IsEven(lst[i])
      requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])
      ensures exists i, j :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst) && 
                             0 <= j < |lst| && IsOdd(lst[j])  && IsFirstOdd(j, lst) && product == lst[i] * lst[j]
  // </vc-spec>

vc-code: |-
  {
      FirstEvenOddExists(lst);
      var evenIndex := FindFirstEvenIndex(lst, 0);
      var oddIndex := FindFirstOddIndex(lst, 0);
      product := lst[evenIndex] * lst[oddIndex];
  }

vc-postamble: |-


