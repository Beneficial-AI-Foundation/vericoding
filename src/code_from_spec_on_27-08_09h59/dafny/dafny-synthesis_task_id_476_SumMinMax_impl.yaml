vc-preamble: |-
  // The order of the recursion in these two functions
  // must match the order of the iteration in the algorithm above
  function Min(a: seq<int>) : int
      requires |a| > 0
  {
      if |a| == 1 then a[0]
      else
          var minPrefix := Min(a[..|a|-1]);
          if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])
  }
  
  function Max(a: seq<int>) : int
      requires |a| > 0
  {
      if |a| == 1 then a[0]
      else
          var maxPrefix := Max(a[..|a|-1]);
          if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])
  }

vc-helpers: |-
  lemma MinMaxInvariant(a: seq<int>, i: int, currentMin: int, currentMax: int)
      requires 0 < i <= |a|
      requires currentMin == Min(a[..i])
      requires currentMax == Max(a[..i])
      ensures i == |a| ==> currentMin == Min(a) && currentMax == Max(a)
  {
      if i == |a| {
          assert a[..i] == a;
      }
  }
  
  lemma MinUpdate(a: seq<int>, i: int, currentMin: int)
      requires 0 < i < |a|
      requires currentMin == Min(a[..i])
      ensures Min(a[..i+1]) == if a[i] <= currentMin then a[i] else currentMin
  {
      var prefix := a[..i];
      var extended := a[..i+1];
      assert extended == prefix + [a[i]];
      
      if |prefix| == 1 {
          assert Min(prefix) == prefix[0];
      }
  }
  
  lemma MaxUpdate(a: seq<int>, i: int, currentMax: int)
      requires 0 < i < |a|
      requires currentMax == Max(a[..i])
      ensures Max(a[..i+1]) == if a[i] >= currentMax then a[i] else currentMax
  {
      var prefix := a[..i];
      var extended := a[..i+1];
      assert extended == prefix + [a[i]];
      
      if |prefix| == 1 {
          assert Max(prefix) == prefix[0];
      }
  }

vc-spec: |-
  // <vc-spec>
  method SumMinMax(a: array<int>) returns (sum: int)
      requires a.Length > 0
      ensures sum == Max(a[..]) + Min(a[..])
  // </vc-spec>

vc-code: |-
  {
      var currentMin := a[0];
      var currentMax := a[0];
      var i := 1;
      
      while i < a.Length
          invariant 1 <= i <= a.Length
          invariant currentMin == Min(a[..i])
          invariant currentMax == Max(a[..i])
      {
          MinUpdate(a[..], i, currentMin);
          MaxUpdate(a[..], i, currentMax);
          
          if a[i] <= currentMin {
              currentMin := a[i];
          }
          if a[i] >= currentMax {
              currentMax := a[i];
          }
          i := i + 1;
      }
      
      MinMaxInvariant(a[..], i, currentMin, currentMax);
      sum := currentMin + currentMax;
  }

vc-postamble: |-


