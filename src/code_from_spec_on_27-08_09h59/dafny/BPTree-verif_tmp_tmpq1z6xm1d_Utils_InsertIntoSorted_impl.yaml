vc-preamble: |-
  // method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)
  // //   ensures count == |set i | i in numbers && i < threshold|
  //     ensures count == |SetLessThan(numbers, threshold)|
  // {
  //   count := 0;
  //   var ss := numbers;
  //   while ss != {}
  //     decreases |ss|
  //   {
  //     var i: int :| i in ss;
  //     ss := ss - {i};
  //     if i < threshold {
  //       count := count + 1;
  //     }
  
  //   }
  //   assert count == |SetLessThan(numbers, threshold)|;
  // //   assert count == |set i | i in numbers && i < threshold|;
  // }
  
  function SetLessThan(numbers: set<int>, threshold: int): set<int>
  {
    set i | i in numbers && i < threshold
  }
  
  
  /*
  */
  
  function seqSet(nums: seq<int>, index: nat): set<int> {
      set x | 0 <= x < index < |nums| :: nums[x]
  }
  
  
  // lemma numElemsOfSet(a: seq<int>)
  //   requires sorted(a)
  // {
  //   assert distinct(a);
  //   var s := set x | x in a;
  //   assert forall x :: x in s ==> x in a[..];
  //   assert forall x :: x in a ==> x in s;
  //   assert |s| == |a|;
  // }
  
  // lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)
  //   requires s == set x | x in a
  //   requires distinct(a)
  //   ensures |s| == |a|
  // {
  //     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;
  //     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];
  //     // Assert that each element in the array is in the set
  //     assert forall i :: 0 <= i < |a| ==> a[i] in s;
  //     // Assert that the set contains exactly the elements in the array
  //     assert s == set x | x in a;
  //     // Assert that the set is a subset of the array
  //     assert forall x :: x in s <==> x in a;
  
  //     // Conclude the equivalence
  //     assert |s| == |a|;
  // }
  
  
  /*
  
  
  */
  
  // TODO play with this for keys==Contents
  
  
  ghost predicate SortedSeq(a: seq<int>)
    //sequence is sorted from left to right
  {
    (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))
  }
  
  method GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)
    // get index so that array stays sorted
    requires x !in a[..]
    requires 0 <= limit <= a.Length
    requires SortedSeq(a[..limit])
    ensures 0<= idx <= limit
    ensures SortedSeq(a[..limit])
    ensures idx > 0 ==> a[idx-1]< x
    ensures idx < limit ==> x < a[idx]
  {
    assume{:axiom} false;
  }
  
  predicate sorted(a: seq<int>)
  {
    forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]
  }
  
  predicate distinct(a: seq<int>)
  {
    forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]
  }
  
  predicate sorted_eq(a: seq<int>)
  {
    forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]
  }
  
  predicate lessThan(a:seq<int>, key:int) {
    forall i :: 0 <= i < |a| ==> a[i] < key
  }
  
  predicate greaterThan(a:seq<int>, key:int) {
    forall i :: 0 <= i < |a| ==> a[i] > key
  }
  
  predicate greaterEqualThan(a:seq<int>, key:int) {
    forall i :: 0 <= i < |a| ==> a[i] >= key
  }
  /*
  method InsertSorted(a: array<int>, key: int ) returns (b: array<int>)
    requires sorted_eq(a[..])
    ensures sorted_eq(b[..])
  {
    assume{:axiom} false;
  }
  */
  
  function count(a: seq<bool>): nat
  {
    if |a| == 0 then 0 else
      (if a[0] then 1 else 0) + count(a[1..])
  }
  
  // verifies in more than 45 seconds, but less than 100 seconds

vc-helpers: |-
  lemma SortedSubsequencePreservation(a: seq<int>, b: seq<int>, limit: int)
    requires sorted(a)
    requires |b| == |a| + 1
    requires limit < |a|
    requires forall i :: 0 <= i < limit ==> a[i] in b
    ensures forall i, j :: 0 <= i < j < limit && a[i] in b && a[j] in b ==> a[i] < a[j]
  {
    // Proof follows from sorted property of a
  }
  
  lemma InsertionPreservesSorted(a: seq<int>, key: int, idx: int)
    requires sorted(a)
    requires 0 <= idx <= |a|
    requires idx > 0 ==> a[idx-1] < key
    requires idx < |a| ==> key < a[idx]
    ensures sorted(a[..idx] + [key] + a[idx..])
  {
    var result := a[..idx] + [key] + a[idx..];
    assert |result| == |a| + 1;
    
    forall i, j | 0 <= i < j < |result|
      ensures result[i] < result[j]
    {
      if j <= idx {
        if i < idx && j < idx {
          assert result[i] == a[i] && result[j] == a[j];
        }
      } else if i >= idx + 1 {
        assert result[i] == a[i-1] && result[j] == a[j-1];
      } else if i < idx && j == idx {
        assert result[i] == a[i] && result[j] == key;
        assert a[i] < key;
      } else if i == idx && j > idx {
        assert result[i] == key && result[j] == a[j-1];
        assert key < a[j-1];
      } else if i < idx && j > idx {
        assert result[i] == a[i] && result[j] == a[j-1];
        assert a[i] < key < a[j-1];
      }
    }
  }
  
  lemma ArraySliceProperties(arr: array<int>, start: int, end: int)
    requires 0 <= start <= end <= arr.Length
    ensures |arr[start..end]| == end - start
  {
    // Built-in property of array slicing
  }
  
  lemma SortedInsertionHelper(a: array<int>, b: array<int>, limit: int, key: int, insertIdx: int)
    requires 0 <= insertIdx <= limit < a.Length
    requires sorted(a[..limit])
    requires key > 0
    requires insertIdx > 0 ==> a[insertIdx-1] < key
    requires insertIdx < limit ==> key < a[insertIdx]
    requires b.Length == a.Length
    requires forall i :: 0 <= i < insertIdx ==> b[i] == a[i]
    requires b[insertIdx] == key
    requires forall i :: insertIdx < i <= limit ==> b[i] == a[i-1]
    ensures sorted(b[..limit+1])
  {
    InsertionPreservesSorted(a[..limit], key, insertIdx);
    assert b[..limit+1] == a[..limit][..insertIdx] + [key] + a[..limit][insertIdx..];
    assert a[..limit][..insertIdx] == a[..insertIdx];
    assert a[..limit][insertIdx..] == a[insertIdx..limit];
  }

vc-spec: |-
  // <vc-spec>
  method InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)
      requires key > 0
      requires key !in a[..]
      requires 0 <= limit < a.Length
      requires forall i :: 0 <= i < limit ==> a[i] > 0
      requires forall i :: limit <= i < a.Length ==> a[i] == 0
      requires sorted(a[..limit]) 
      ensures b.Length == a.Length
      ensures sorted(b[..(limit+ 1)])
      ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  
      ensures forall i :: 0 <= i < limit ==> a[i] in b[..]
      ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0
  // </vc-spec>

vc-code: |-
  {
    b := new int[a.Length];
    
    // Initialize all positions to 0 first
    var init := 0;
    while init < b.Length
      invariant 0 <= init <= b.Length
      invariant forall idx :: 0 <= idx < init ==> b[idx] == 0
    {
      b[init] := 0;
      init := init + 1;
    }
    
    var insertIdx := GetInsertIndex(a, limit, key);
    
    var i := 0;
    while i < insertIdx
      invariant 0 <= i <= insertIdx
      invariant forall j :: 0 <= j < i ==> b[j] == a[j]
      invariant forall j :: 0 <= j < i ==> b[j] > 0
      invariant forall j :: i <= j < b.Length ==> b[j] == 0
    {
      b[i] := a[i];
      i := i + 1;
    }
    
    b[insertIdx] := key;
    
    var j := insertIdx;
    while j < limit
      invariant insertIdx <= j <= limit
      invariant forall k :: 0 <= k < insertIdx ==> b[k] == a[k]
      invariant b[insertIdx] == key
      invariant forall k :: insertIdx < k <= j ==> b[k] == a[k-1]
      invariant forall k :: 0 <= k <= j ==> b[k] > 0
      invariant forall k :: j + 1 <= k < b.Length ==> b[k] == 0
    {
      b[j + 1] := a[j];
      j := j + 1;
    }
    
    assert forall k :: limit + 1 <= k < b.Length ==> b[k] == 0;
    
    SortedInsertionHelper(a, b, limit, key, insertIdx);
    
    // Prove that all original elements are preserved
    forall i | 0 <= i < limit
      ensures a[i] in b[..]
    {
      if i < insertIdx {
        assert b[i] == a[i];
        assert a[i] in b[..];
      } else {
        assert b[i+1] == a[i];
        assert a[i] in b[..];
      }
    }
    
    assert forall i :: 0 <= i < limit + 1 ==> b[i] > 0;
  }

vc-postamble: |-


