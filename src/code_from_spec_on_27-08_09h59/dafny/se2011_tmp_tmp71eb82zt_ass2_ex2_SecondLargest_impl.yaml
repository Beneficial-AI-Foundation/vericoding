vc-preamble: |-
  // ex2
  
  // this was me playing around to try and get an ensures for the method 
  /*predicate method check(a: array<int>, seclar:int)
  requires a.Length > 0
  reads a
  { ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

vc-helpers: |-
  predicate IsMaximum(a: array<int>, maxIdx: int)
    reads a
    requires 0 <= maxIdx < a.Length
  {
    forall j :: 0 <= j < a.Length ==> a[j] <= a[maxIdx]
  }
  
  predicate IsSecondLargest(a: array<int>, seclar: int)
    reads a
    requires a.Length > 0
  {
    exists maxIdx :: 0 <= maxIdx < a.Length && 
      IsMaximum(a, maxIdx) &&
      (if exists j :: 0 <= j < a.Length && a[j] < a[maxIdx]
       then (exists secIdx :: 0 <= secIdx < a.Length && 
            a[secIdx] < a[maxIdx] &&
            seclar == a[secIdx] &&
            forall k :: 0 <= k < a.Length && a[k] < a[maxIdx] ==> a[k] <= seclar)
       else seclar == a[maxIdx])
  }

vc-spec: |-
  // <vc-spec>
  method SecondLargest(a:array<int>) returns (seclar:int)
  requires a.Length > 0
  //ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])
  // </vc-spec>

vc-code: |-
  {
    var maxVal := a[0];
    var maxIdx := 0;
    var i := 1;
    
    while i < a.Length
      invariant 1 <= i <= a.Length
      invariant 0 <= maxIdx < a.Length
      invariant maxVal == a[maxIdx]
      invariant forall j :: 0 <= j < i ==> a[j] <= maxVal
    {
      if a[i] > maxVal {
        maxVal := a[i];
        maxIdx := i;
      }
      i := i + 1;
    }
    
    var hasSecond := false;
    var secVal := maxVal;
    i := 0;
    
    while i < a.Length
      invariant 0 <= i <= a.Length
      invariant IsMaximum(a, maxIdx)
      invariant maxVal == a[maxIdx]
      invariant !hasSecond ==> secVal == maxVal
      invariant hasSecond ==> (secVal < maxVal && 
                             exists j :: 0 <= j < a.Length && a[j] == secVal && secVal < maxVal)
      invariant hasSecond ==> (forall j :: 0 <= j < i && a[j] < maxVal ==> a[j] <= secVal)
    {
      if a[i] < maxVal {
        if !hasSecond || a[i] > secVal {
          secVal := a[i];
          hasSecond := true;
        }
      }
      i := i + 1;
    }
    
    seclar := secVal;
  }

vc-postamble: |-


