vc-preamble: |-


vc-helpers: |-
  lemma SortedEquivalence(a: array<int>)
      requires a.Length > 0
      ensures (forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]) <==> 
              (forall k :: 0 <= k < a.Length - 1 ==> a[k] <= a[k + 1])
  {
      if forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j] {
          forall k | 0 <= k < a.Length - 1
              ensures a[k] <= a[k + 1]
          {
              assert 0 <= k < k + 1 < a.Length;
          }
      }
      
      if forall k :: 0 <= k < a.Length - 1 ==> a[k] <= a[k + 1] {
          forall i, j | 0 <= i < j < a.Length
              ensures a[i] <= a[j]
          {
              TransitiveProperty(a, i, j);
          }
      }
  }
  
  lemma TransitiveProperty(a: array<int>, i: int, j: int)
      requires a.Length > 0
      requires 0 <= i < j < a.Length
      requires forall k :: 0 <= k < a.Length - 1 ==> a[k] <= a[k + 1]
      ensures a[i] <= a[j]
  {
      if i + 1 == j {
          assert a[i] <= a[j];
      } else {
          TransitiveProperty(a, i, j - 1);
          assert a[i] <= a[j - 1] <= a[j];
      }
  }

vc-spec: |-
  // <vc-spec>
  method IsSorted(a: array<int>) returns (sorted: bool)
      requires a.Length > 0
      ensures sorted <== forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
      ensures !sorted ==> exists i, j :: 0 <= i < j < a.Length && a[i] > a[j]
  // </vc-spec>

vc-code: |-
  {
      SortedEquivalence(a);
      
      var i := 0;
      while i < a.Length - 1
          invariant 0 <= i <= a.Length - 1
          invariant forall k :: 0 <= k < i ==> a[k] <= a[k + 1]
      {
          if a[i] > a[i + 1] {
              sorted := false;
              return;
          }
          i := i + 1;
      }
      
      sorted := true;
  }

vc-postamble: |-


