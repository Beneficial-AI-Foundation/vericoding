vc-preamble: |-
  /**
  Consider cellular automata: a row of cells is repeatedly updated according to a rule. In this exercise I dabbled with,
  each cell has the value either false or true. Each cell's next state depends only on the immediate neighbours, in the 
  case where the cell is at the edges of the row, the inexistent neighbours are replaced by "false". The automaton table 
  will contain the initial row, plus a row for each number of steps.
   */
  class Automaton {
  
  /**
  This method computes the automaton.
  Provide the initial row: init, the rule and the desired number of steps
   */
  
  }

vc-helpers: |-
  lemma NextRowLength(prev: seq<bool>, rule: (bool, bool, bool) -> bool)
    requires |prev| >= 2
    ensures |ComputeNextRow(prev, rule)| == |prev|
  {
  }
  
  function ComputeNextRow(prev: seq<bool>, rule: (bool, bool, bool) -> bool): seq<bool>
    requires |prev| >= 2
    ensures |ComputeNextRow(prev, rule)| == |prev|
  {
    seq(|prev|, i requires 0 <= i < |prev| => 
      if i == 0 then
        rule(false, prev[0], prev[1])
      else if i == |prev| - 1 then
        rule(prev[i-1], prev[i], false)
      else
        rule(prev[i-1], prev[i], prev[i+1])
    )
  }
  
  lemma ComputeNextRowCorrectness(prev: seq<bool>, rule: (bool, bool, bool) -> bool)
    requires |prev| >= 2
    ensures var next := ComputeNextRow(prev, rule);
      && |next| == |prev|
      && next[0] == rule(false, prev[0], prev[1])
      && next[|prev| - 1] == rule(prev[|prev| - 2], prev[|prev| - 1], false)
      && (forall j | 1 <= j <= |prev| - 2 :: next[j] == rule(prev[j-1], prev[j], prev[j+1]))
  {
  }
  
  lemma TableInvariantPreservation(table: seq<seq<bool>>, current: seq<bool>, next: seq<bool>, rule: (bool, bool, bool) -> bool, init: seq<bool>)
    requires |init| >= 2
    requires |table| >= 1
    requires table[0] == init
    requires |current| == |init|
    requires current == table[|table| - 1]
    requires forall i | 0 <= i < |table| :: |table[i]| == |init|
    requires next == ComputeNextRow(current, rule)
    requires forall i | 0 <= i < |table| - 1 ::
               forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])
    requires forall i | 0 <= i < |table| - 1 ::
               table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)
    ensures var newTable := table + [next];
      (|newTable| == |table| + 1
      && newTable[0] == init
      && (forall i | 0 <= i < |newTable| :: |newTable[i]| == |init|)
      && (forall i | 0 <= i < |newTable| - 1 ::
           (forall j | 1 <= j <= |newTable[i]| - 2 :: newTable[i + 1][j] == rule(newTable[i][j - 1], newTable[i][j], newTable[i][j + 1])))
      && (forall i | 0 <= i < |newTable| - 1 ::
           newTable[i + 1][0] == rule(false, newTable[i][0], newTable[i][1]) && newTable[i + 1][|newTable[i]| - 1] == rule(newTable[i][|newTable[i]| - 2], newTable[i][|newTable[i]| - 1], false)))
  {
    ComputeNextRowCorrectness(current, rule);
    var newTable := table + [next];
    
    assert |newTable| == |table| + 1;
    assert newTable[0] == table[0] == init;
    assert forall i | 0 <= i < |table| :: newTable[i] == table[i];
    assert newTable[|table|] == next;
    assert |next| == |current| == |init|;
    
    forall i | 0 <= i < |newTable|
      ensures |newTable[i]| == |init|
    {
      if i < |table| {
        assert newTable[i] == table[i];
        assert |table[i]| == |init|;
      } else {
        assert i == |table|;
        assert newTable[i] == next;
        assert |next| == |init|;
      }
    }
    
    forall i | 0 <= i < |newTable| - 1
      ensures forall j | 1 <= j <= |newTable[i]| - 2 :: newTable[i + 1][j] == rule(newTable[i][j - 1], newTable[i][j], newTable[i][j + 1])
    {
      if i < |table| - 1 {
        assert newTable[i] == table[i];
        assert newTable[i + 1] == table[i + 1];
        forall j | 1 <= j <= |newTable[i]| - 2
          ensures newTable[i + 1][j] == rule(newTable[i][j - 1], newTable[i][j], newTable[i][j + 1])
        {
          assert table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1]);
        }
      } else {
        assert i == |table| - 1;
        assert newTable[i] == table[i] == current;
        assert newTable[i + 1] == next;
        forall j | 1 <= j <= |newTable[i]| - 2
          ensures newTable[i + 1][j] == rule(newTable[i][j - 1], newTable[i][j], newTable[i][j + 1])
        {
          assert next[j] == rule(current[j - 1], current[j], current[j + 1]);
        }
      }
    }
    
    forall i | 0 <= i < |newTable| - 1
      ensures newTable[i + 1][0] == rule(false, newTable[i][0], newTable[i][1]) && newTable[i + 1][|newTable[i]| - 1] == rule(newTable[i][|newTable[i]| - 2], newTable[i][|newTable[i]| - 1], false)
    {
      if i < |table| - 1 {
        assert newTable[i] == table[i];
        assert newTable[i + 1] == table[i + 1];
        assert table[i + 1][0] == rule(false, table[i][0], table[i][1]);
        assert table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false);
      } else {
        assert i == |table| - 1;
        assert newTable[i] == table[i] == current;
        assert newTable[i + 1] == next;
        assert next[0] == rule(false, current[0], current[1]);
        assert next[|current| - 1] == rule(current[|current| - 2], current[|current| - 1], false);
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method ExecuteAutomaton(init: seq<bool>, rule: (bool, bool, bool) -> bool, steps: nat)
    returns (table: seq<seq<bool>>)
    // we need the initial row to have the length bigger or equal to two
    requires |init| >= 2
    // after computation the automaton is made of the initial row plus a row for each of the steps
    ensures |table| == 1 + steps
    // the automaton must have the initial row at the top
    ensures table[0] == init;
    // all rows in the automaton must be the same length
    ensures forall i | 0 <= i < |table| :: |table[i]| == |init|
    // all the middle row elements (with existing neighbours) after a step, will be equal to the rule applied on the element in the previous state
    // and its neigbours
    ensures forall i | 0 <= i < |table| - 1 ::
              forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])
    // the corner row elements (with non-existing neighbours) after a step, will be equal to the rule applied on the element in the previous state,
    // its neighbour and false
    ensures forall i | 0 <= i < |table| - 1 ::
              table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)
  // </vc-spec>

vc-code: |-
  {
    table := [init];
    var current := init;
    var step := 0;
    
    while step < steps
      invariant 0 <= step <= steps
      invariant |table| == 1 + step
      invariant table[0] == init
      invariant |current| == |init|
      invariant current == table[step]
      invariant forall i | 0 <= i < |table| :: |table[i]| == |init|
      invariant forall i | 0 <= i < |table| - 1 ::
                  forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])
      invariant forall i | 0 <= i < |table| - 1 ::
                  table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)
    {
      var next := ComputeNextRow(current, rule);
      TableInvariantPreservation(table, current, next, rule, init);
      table := table + [next];
      current := next;
      step := step + 1;
    }
  }

vc-postamble: |-


