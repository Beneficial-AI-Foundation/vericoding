vc-preamble: |-
  method swap(arr: array<int>, i: int, j: int)
      requires arr.Length > 0
      requires 0 <= i < arr.Length && 0 <= j < arr.Length
      modifies arr
      ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])
      ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])
      ensures multiset(arr[..]) == multiset(old(arr[..]))
  {
    assume{:axiom} false;
  }
  
  function count(arr: seq<int>, value: int) : (c: nat)
      ensures c <= |arr|
  {
      if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)
  }

vc-helpers: |-
  lemma SwapPreservesMultiset(arr: array<int>, i: int, j: int)
      requires 0 <= i < arr.Length && 0 <= j < arr.Length
      ensures multiset(arr[..][i := arr[j]][j := arr[i]]) == multiset(arr[..])
  {
      var old_seq := arr[..];
      var new_seq := old_seq[i := arr[j]][j := arr[i]];
      
      if i == j {
          assert new_seq == old_seq;
      } else {
          assert multiset(new_seq) == multiset(old_seq);
      }
  }
  
  lemma MultisetPreservation(s1: seq<int>, s2: seq<int>, s3: seq<int>)
      requires multiset(s1) == multiset(s2)
      requires multiset(s2) == multiset(s3)
      ensures multiset(s1) == multiset(s3)
  {
  }
  
  lemma ZerosToRight(arr: array<int>, writeIndex: int)
      requires 0 <= writeIndex <= arr.Length
      requires forall k :: 0 <= k < writeIndex ==> arr[k] != 0
      requires forall k :: writeIndex <= k < arr.Length ==> arr[k] == 0
      ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0
  {
      forall i, j | 0 <= i < j < arr.Length && arr[i] == 0 ensures arr[j] == 0
      {
          assert i >= writeIndex;
          assert j >= writeIndex;
          assert arr[j] == 0;
      }
  }
  
  lemma OrderPreservationLemma(original: seq<int>, arr: array<int>, writeIndex: int)
      requires 0 <= writeIndex <= arr.Length
      requires forall k :: 0 <= k < writeIndex ==> arr[k] != 0
      requires forall k :: writeIndex <= k < arr.Length ==> arr[k] == 0
      requires multiset(arr[..]) == multiset(original)
      requires arr.Length == |original|
      ensures forall n, m :: 0 <= n < m < arr.Length && original[n] != 0 && original[m] != 0 ==> 
              exists k, l :: 0 <= k < l < arr.Length && arr[k] == original[n] && arr[l] == original[m]
  {
      forall n, m | 0 <= n < m < arr.Length && original[n] != 0 && original[m] != 0 
      ensures exists k, l :: 0 <= k < l < arr.Length && arr[k] == original[n] && arr[l] == original[m]
      {
          assert original[n] != 0 && original[m] != 0;
          assert multiset(arr[..]) == multiset(original);
          assert original[n] in multiset(original);
          assert original[m] in multiset(original);
          assert original[n] in multiset(arr[..]);
          assert original[m] in multiset(arr[..]);
          
          var k :| 0 <= k < arr.Length && arr[k] == original[n];
          var l :| 0 <= l < arr.Length && arr[l] == original[m];
          
          assert arr[k] != 0 && arr[l] != 0;
          assert k < writeIndex && l < writeIndex;
          
          if k > l {
              var temp_k := l;
              var temp_l := k;
              assert 0 <= temp_k < temp_l < arr.Length && arr[temp_k] == original[m] && arr[temp_l] == original[n];
          } else {
              assert 0 <= k < l < arr.Length && arr[k] == original[n] && arr[l] == original[m];
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  method MoveZeroesToEnd(arr: array<int>)
      requires arr.Length >= 2
      modifies arr
      // Same size
      ensures arr.Length == old(arr.Length)
      // Zeros to the right of the first zero
      ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0
      // The final array is a permutation of the original one
      ensures multiset(arr[..]) == multiset(old(arr[..]))
      // Relative order of non-zero elements is preserved
      ensures forall n, m /* on old array */:: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> 
              exists k, l /* on new array */:: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])
      //ensures IsOrderPreserved(arr[..], old(arr[..]))
      // Number of zeros is preserved
  // </vc-spec>

vc-code: |-
  {
      ghost var original := arr[..];
      var writeIndex := 0;
      var readIndex := 0;
      
      while readIndex < arr.Length
          invariant 0 <= writeIndex <= readIndex <= arr.Length
          invariant forall k :: 0 <= k < writeIndex ==> arr[k] != 0
          invariant multiset(arr[..]) == multiset(original)
      {
          if arr[readIndex] != 0 {
              if writeIndex != readIndex {
                  swap(arr, writeIndex, readIndex);
              }
              writeIndex := writeIndex + 1;
          }
          readIndex := readIndex + 1;
      }
      
      var k := writeIndex;
      while k < arr.Length
          invariant writeIndex <= k <= arr.Length
          invariant forall i :: 0 <= i < writeIndex ==> arr[i] != 0
          invariant forall i :: writeIndex <= i < k ==> arr[i] == 0
          invariant multiset(arr[..]) == multiset(original)
      {
          arr[k] := 0;
          k := k + 1;
      }
      
      ZerosToRight(arr, writeIndex);
      OrderPreservationLemma(original, arr, writeIndex);
  }

vc-postamble: |-


