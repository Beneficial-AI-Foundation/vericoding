vc-preamble: |-
  //Problem01
  function fib(n: nat):nat
  {
      if n < 2 then n else fib(n-2)+fib(n-1)
  }
  
  //# 2 pts
  
  //Problem02
  function fact(n:nat):nat
  {if n==0 then 1 else n*fact(n-1)}
  
  //# 3 pts
  //Problem03
  function gcd(m: nat, n: nat): nat
      requires m > 0 && n > 0
  {
      if m == n then m
      else if m > n then gcd(m - n, n)
      else gcd(m, n - m)
  }

vc-helpers: |-
  lemma gcd_symmetric(m: nat, n: nat)
      requires m > 0 && n > 0
      ensures gcd(m, n) == gcd(n, m)
      decreases m + n
  {
      if m == n {
          assert gcd(m, n) == m == n == gcd(n, m);
      } else if m > n {
          gcd_symmetric(m - n, n);
          gcd_symmetric(n, m - n);
      } else {
          gcd_symmetric(m, n - m);
          gcd_symmetric(n - m, m);
      }
  }
  
  lemma gcd_subtract_property(m: nat, n: nat)
      requires m > 0 && n > 0
      ensures m > n ==> gcd(m, n) == gcd(m - n, n)
      ensures n > m ==> gcd(m, n) == gcd(m, n - m)
  {
  }

vc-spec: |-
  // <vc-spec>
  method gcdI(m: int, n: int) returns (g: int)
      requires  m > 0 && n > 0 
      ensures g == gcd(m, n);
  // </vc-spec>

vc-code: |-
  {
      var a := m;
      var b := n;
      
      while a != b
          invariant a > 0 && b > 0
          invariant gcd(a, b) == gcd(m, n)
          decreases a + b
      {
          if a > b {
              a := a - b;
          } else {
              b := b - a;
          }
      }
      
      g := a;
  }

vc-postamble: |-
  //# 3 pts
  
  
  // # sum: 9 pts

