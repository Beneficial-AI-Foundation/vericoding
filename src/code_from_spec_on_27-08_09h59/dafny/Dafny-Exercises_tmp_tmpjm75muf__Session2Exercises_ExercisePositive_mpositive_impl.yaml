vc-preamble: |-
  predicate positive(s:seq<int>)
  {forall u::0<=u<|s| ==> s[u]>=0}

vc-helpers: |-
  lemma positive_empty()
    ensures positive([])
  {
    // Empty sequence vacuously satisfies the predicate
  }
  
  lemma positive_single(x: int)
    ensures positive([x]) <==> x >= 0
  {
    // For a single element sequence, positive means x >= 0
    if x >= 0 {
      assert forall u :: 0 <= u < |[x]| ==> [x][u] >= 0;
    } else {
      assert [x][0] < 0;
      assert !(forall u :: 0 <= u < |[x]| ==> [x][u] >= 0);
    }
  }
  
  lemma positive_extend(s: seq<int>, x: int)
    requires positive(s)
    ensures positive(s + [x]) <==> x >= 0
  {
    var extended := s + [x];
    if x >= 0 {
      assert forall u :: 0 <= u < |extended| ==> extended[u] >= 0;
    } else {
      assert extended[|s|] < 0;
      assert !(forall u :: 0 <= u < |extended| ==> extended[u] >= 0);
    }
  }

vc-spec: |-
  // <vc-spec>
  method mpositive(v:array<int>) returns (b:bool)
  ensures b==positive(v[0..v.Length])
  // </vc-spec>

vc-code: |-
  {
    var i := 0;
    while i < v.Length
      invariant 0 <= i <= v.Length
      invariant positive(v[0..i])
    {
      if v[i] < 0 {
        assert v[0..v.Length][i] == v[i] < 0;
        assert !positive(v[0..v.Length]);
        return false;
      }
      assert v[i] >= 0;
      positive_extend(v[0..i], v[i]);
      assert v[0..i+1] == v[0..i] + [v[i]];
      i := i + 1;
    }
    assert i == v.Length;
    assert v[0..i] == v[0..v.Length];
    return true;
  }

vc-postamble: |-


