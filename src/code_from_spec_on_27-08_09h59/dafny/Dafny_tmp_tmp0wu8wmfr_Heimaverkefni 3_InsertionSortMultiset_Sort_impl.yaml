vc-preamble: |-
  // Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is
  // Permalink spurningar: https://rise4fun.com/Dafny/G4sc3
  
  // Höfundur lausnar:     Alexander Guðmundsson
  // Permalink lausnar:    https://rise4fun.com/Dafny/nujsu
  
  // Insertion sort með hjálp helmingunarleitar.
  
  
  method Search( s: seq<int>, x: int ) returns ( k: int )
      // Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins
      requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];
      ensures 0 <= k <= |s|;
      ensures forall i | 0 <= i < k :: s[i] <= x;
      ensures forall i | k <= i < |s| :: s[i] >= x;
      ensures forall z | z in s[..k] :: z <= x;
      ensures forall z | z in s[k..] :: z >= x;
      ensures s == s[..k]+s[k..];
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma MultisetInsertPreservation(s: seq<int>, x: int, k: int)
      requires 0 <= k <= |s|
      ensures multiset(s[..k] + [x] + s[k..]) == multiset(s) + multiset{x}
  {
      assert s[..k] + [x] + s[k..] == s[..k] + ([x] + s[k..]);
      assert multiset(s[..k] + ([x] + s[k..])) == multiset(s[..k]) + multiset([x] + s[k..]);
      assert multiset([x] + s[k..]) == multiset{x} + multiset(s[k..]);
      SequencePartitioning(s, k);
  }
  
  lemma SortedInsertPreservation(s: seq<int>, x: int, k: int)
      requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q]
      requires 0 <= k <= |s|
      requires forall i | 0 <= i < k :: s[i] <= x
      requires forall i | k <= i < |s| :: s[i] >= x
      ensures forall p,q | 0 <= p < q < |s[..k] + [x] + s[k..]| :: (s[..k] + [x] + s[k..])[p] <= (s[..k] + [x] + s[k..])[q]
  {
      var result := s[..k] + [x] + s[k..];
      forall p,q | 0 <= p < q < |result|
          ensures result[p] <= result[q]
      {
          if p < k && q < k {
              assert result[p] == s[p] && result[q] == s[q];
          } else if p < k && q == k {
              assert result[p] == s[p] && result[q] == x;
          } else if p < k && q > k {
              assert result[p] == s[p] && result[q] == s[q-1];
          } else if p == k && q > k {
              assert result[p] == x && result[q] == s[q-1];
          } else if p > k && q > k {
              assert result[p] == s[p-1] && result[q] == s[q-1];
          }
      }
  }
  
  lemma SequencePartitioning(s: seq<int>, k: int)
      requires 0 <= k <= |s|
      ensures s == s[..k] + s[k..]
      ensures multiset(s[..k]) + multiset(s[k..]) == multiset(s)
  {
      assert s == s[..k] + s[k..];
      
      if |s| == 0 {
          assert s[..k] == [] && s[k..] == [];
          assert multiset(s[..k]) + multiset(s[k..]) == multiset{} + multiset{} == multiset(s);
      } else {
          var left := s[..k];
          var right := s[k..];
          assert s == left + right;
          
          forall i | 0 <= i < |s|
              ensures s[i] in multiset(left + right)
          {
              if i < k {
                  assert s[i] == left[i];
                  assert s[i] in multiset(left);
              } else {
                  assert s[i] == right[i - k];
                  assert s[i] in multiset(right);
              }
          }
          
          assert multiset(left + right) == multiset(left) + multiset(right);
          assert multiset(s) == multiset(left + right);
          assert multiset(s) == multiset(left) + multiset(right);
      }
  }

vc-spec: |-
  // <vc-spec>
  method Sort( m: multiset<int> ) returns ( r: seq<int> )
      ensures multiset(r) == m;
      ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];
  // </vc-spec>

vc-code: |-
  {
      var elements := [];
      var remaining := m;
      
      while remaining != multiset{}
          invariant multiset(elements) + remaining == m
          invariant forall p,q | 0 <= p < q < |elements| :: elements[p] <= elements[q]
          decreases |remaining|
      {
          var x :| x in remaining;
          remaining := remaining - multiset{x};
          
          var k := Search(elements, x);
          var oldElements := elements;
          
          SequencePartitioning(oldElements, k);
          
          elements := oldElements[..k] + [x] + oldElements[k..];
          
          MultisetInsertPreservation(oldElements, x, k);
          SortedInsertPreservation(oldElements, x, k);
      }
      
      return elements;
  }

vc-postamble: |-


