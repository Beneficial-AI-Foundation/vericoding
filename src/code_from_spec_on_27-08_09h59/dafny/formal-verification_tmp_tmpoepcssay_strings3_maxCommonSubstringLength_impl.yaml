vc-preamble: |-
  predicate isSubstring(sub: string, str: string)
  {
      exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub
  }
  
  predicate isPrefixPred(pre:string, str:string)
  {
      (|pre| <= |str|) && 
      pre == str[..|pre|]
  }
  
  predicate isNotPrefixPred(pre:string, str:string)
  {
      (|pre| > |str|) || 
      pre != str[..|pre|]
  }
  
  predicate isSubstringPred(sub:string, str:string)
  {
      (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))
  }
  
  predicate isNotSubstringPred(sub:string, str:string)
  {
      (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))
  }
  
  
  
  
  predicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)
  {
      exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)
  }
  
  predicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)
  {
      forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)
  }
  
  method haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)
      ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)
      ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma haveCommonZeroSubstring(str1: string, str2: string)
      ensures haveCommonKSubstringPred(0, str1, str2)
  {
      var i1 := 0;
      var j1 := 0;
      assert 0 <= i1 <= |str1| - 0;
      assert j1 == i1 + 0;
      assert str1[i1..j1] == str1[0..0] == "";
      assert |""| <= |str2|;
      assert isPrefixPred("", str2[0..]);
      assert isSubstringPred("", str2);
      assert haveCommonKSubstringPred(0, str1, str2);
  }
  
  lemma haveCommonImpliesSmaller(k1: nat, k2: nat, str1: string, str2: string)
      requires k1 <= k2
      requires haveCommonKSubstringPred(k2, str1, str2)
      requires k2 <= |str1|
      ensures haveCommonKSubstringPred(k1, str1, str2)
  {
      if k1 == 0 {
          haveCommonZeroSubstring(str1, str2);
      } else {
          var i1, j1 :| 0 <= i1 <= |str1| - k2 && j1 == i1 + k2 && isSubstringPred(str1[i1..j1], str2);
          var sub1 := str1[i1..i1+k1];
          assert sub1 == str1[i1..j1][..k1];
          assert isPrefixPred(sub1, str1[i1..j1]);
          
          var i2 :| 0 <= i2 <= |str2| && isPrefixPred(str1[i1..j1], str2[i2..]);
          assert isPrefixPred(sub1, str2[i2..]);
          assert isSubstringPred(sub1, str2);
          assert haveCommonKSubstringPred(k1, str1, str2);
      }
  }

vc-spec: |-
  // <vc-spec>
  method maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)
      requires (|str1| <= |str2|)
      ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))
      ensures haveCommonKSubstringPred(len,str1,str2)
  // </vc-spec>

vc-code: |-
  {
      haveCommonZeroSubstring(str1, str2);
      len := 0;
      
      var k := 1;
      while k <= |str1|
          invariant 1 <= k <= |str1| + 1
          invariant haveCommonKSubstringPred(len, str1, str2)
          invariant forall j :: len < j < k ==> !haveCommonKSubstringPred(j, str1, str2)
      {
          var hasCommon := haveCommonKSubstring(k, str1, str2);
          if hasCommon {
              len := k;
          }
          k := k + 1;
      }
  }

vc-postamble: |-


