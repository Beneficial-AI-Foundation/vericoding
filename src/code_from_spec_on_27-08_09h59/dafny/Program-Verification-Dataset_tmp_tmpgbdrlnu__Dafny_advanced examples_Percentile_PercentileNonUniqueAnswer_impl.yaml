vc-preamble: |-
  // Sum of elements of A from indices 0 to end.
  // end is inclusive! (not James's normal way of thinking!!)
  function SumUpto(A: array<real>, end: int): real
    requires -1 <= end < A.Length
    reads A
  {
    if end == -1 then
      0.0
    else
      A[end] + SumUpto(A, end-1)
  }
  
  function Sum(A: array<real>): real
    reads A
  {
    SumUpto(A, A.Length-1)
  }
  
  
  // example showing that, with the original postcondition, the answer is non-unique!

vc-helpers: |-
  lemma SumUptoIncreasing(A: array<real>, i: int, j: int)
    requires 0 <= i < j < A.Length
    requires forall k | 0 <= k < A.Length :: A[k] > 0.0
    ensures SumUpto(A, i) < SumUpto(A, j)
  {
    if i + 1 == j {
      assert SumUpto(A, j) == A[j] + SumUpto(A, j-1);
      assert SumUpto(A, j-1) == SumUpto(A, i);
      assert A[j] > 0.0;
      assert SumUpto(A, j) == A[j] + SumUpto(A, i) > SumUpto(A, i);
    } else {
      SumUptoIncreasing(A, i, j-1);
      assert SumUpto(A, i) < SumUpto(A, j-1);
      assert SumUpto(A, j) == A[j] + SumUpto(A, j-1);
      assert A[j] > 0.0;
      assert SumUpto(A, j) > SumUpto(A, j-1);
      assert SumUpto(A, i) < SumUpto(A, j);
    }
  }
  
  lemma SumUptoCompute(A: array<real>)
    requires A.Length == 3
    requires A[0] == 10.0 && A[1] == 20.0 && A[2] == 30.0
    ensures SumUpto(A, -1) == 0.0
    ensures SumUpto(A, 0) == 10.0
    ensures SumUpto(A, 1) == 30.0
    ensures SumUpto(A, 2) == 60.0
    ensures Sum(A) == 60.0
  {
    assert SumUpto(A, -1) == 0.0;
    assert SumUpto(A, 0) == A[0] + SumUpto(A, -1) == 10.0 + 0.0 == 10.0;
    assert SumUpto(A, 1) == A[1] + SumUpto(A, 0) == 20.0 + 10.0 == 30.0;
    assert SumUpto(A, 2) == A[2] + SumUpto(A, 1) == 30.0 + 30.0 == 60.0;
    assert Sum(A) == SumUpto(A, A.Length-1) == SumUpto(A, 2) == 60.0;
  }

vc-spec: |-
  // <vc-spec>
  method PercentileNonUniqueAnswer() returns (p: real, A: array<real>, total: real, i1: int, i2: int)
    ensures forall i | 0 <= i < A.Length :: A[i] > 0.0
    ensures 0.0 <= p <= 100.0
    ensures total == Sum(A)
    ensures total > 0.0
  
    ensures -1 <= i1 < A.Length
    ensures SumUpto(A, i1) <= (p/100.0) * total
    ensures i1+1 < A.Length ==> SumUpto(A, i1+1) >= (p/100.0) * total
  
    ensures -1 <= i2 < A.Length
    ensures SumUpto(A, i2) <= (p/100.0) * total
    ensures i2+1 < A.Length ==> SumUpto(A, i2+1) >= (p/100.0) * total
  
    ensures i1 != i2
  // </vc-spec>

vc-code: |-
  {
    A := new real[3];
    A[0] := 10.0;
    A[1] := 20.0;
    A[2] := 30.0;
    
    p := 50.0;
    total := Sum(A);
    
    SumUptoCompute(A);
    assert total == 60.0;
    assert (p/100.0) * total == 30.0;
    
    i1 := 0;
    i2 := 1;
    
    assert SumUpto(A, 0) == 10.0;
    assert SumUpto(A, 1) == 30.0;
    
    assert SumUpto(A, i1) == 10.0 <= 30.0;
    assert i1+1 < A.Length && SumUpto(A, i1+1) == 30.0 >= 30.0;
    
    assert SumUpto(A, i2) == 30.0 <= 30.0;
    assert i2+1 < A.Length && SumUpto(A, i2+1) == 60.0 >= 30.0;
  }

vc-postamble: |-
  // proof that, with the corrected postcondition, the answer is unique
  // lemma for previous proof: when an array has strictly positive elements, the
  // sums strictly increase left to right

