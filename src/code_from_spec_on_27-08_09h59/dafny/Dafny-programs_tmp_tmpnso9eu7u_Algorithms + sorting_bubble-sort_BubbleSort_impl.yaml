vc-preamble: |-
  /*
  Bubble Sort is the simplest sorting algorithm that works by 
  repeatedly swapping the adjacent elements if they are in wrong order.
  */
  
  predicate sorted_between(A:array<int>, from:int, to:int)
      reads A
  {
      forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]
  }
  
  predicate sorted(A:array<int>)
      reads A
  {
      sorted_between(A, 0, A.Length-1)
  }
  
  /* Explanation:
  
  invariant forall n, m :: 0 <= n <= i <m <N ==> A [n] <= A [m]
       // A is ordered for each pair of elements such that
       // the first element belongs to the left partition of i
       // and the second element belongs to the right partition of i
  
  invariant forall n :: 0 <= n <= j ==> A [n] <= A [j]
       // There is a variable defined by the value that the array takes at position j
       // Therefore, each value that the array takes for all elements from 0 to j
       // They are less than or equal to the value of the variable
  */

vc-helpers: |-
  lemma sorted_between_extend(A: array<int>, from: int, to: int)
      requires 0 <= from <= to < A.Length
      requires sorted_between(A, from, to)
      requires to + 1 < A.Length
      requires A[to] <= A[to + 1]
      ensures sorted_between(A, from, to + 1)
  {
  }
  
  lemma sorted_between_subset(A: array<int>, from1: int, to1: int, from2: int, to2: int)
      requires 0 <= from2 <= from1 <= to1 <= to2 < A.Length
      requires sorted_between(A, from2, to2)
      ensures sorted_between(A, from1, to1)
  {
  }
  
  lemma swap_preserves_multiset_helper(s: seq<int>, i: int, j: int) returns (s': seq<int>)
      requires 0 <= i < |s| && 0 <= j < |s|
      ensures s' == s[i := s[j]][j := s[i]]
      ensures multiset(s') == multiset(s)
  {
      s' := s[i := s[j]][j := s[i]];
  }
  
  lemma bubble_sort_inner_loop_maintains_sorted(A: array<int>, start: int, end: int, pos: int)
      requires 0 <= start <= pos <= end < A.Length
      requires sorted_between(A, start, end)
      requires forall k :: pos < k <= end ==> A[pos] <= A[k]
      ensures sorted_between(A, start, end)
  {
  }
  
  lemma after_inner_loop_sorted_extends(A: array<int>, N: int, i: int)
      requires 0 <= i < N - 1
      requires A.Length == N
      requires N >= 2
      requires forall k :: 0 <= k < N - i - 1 ==> A[k] <= A[N - i - 1]
      requires sorted_between(A, N - i, N - 1)
      ensures sorted_between(A, N - i - 1, N - 1)
  {
  }
  
  lemma inner_loop_invariant_init(A: array<int>, N: int, i: int)
      requires 0 <= i < N - 1
      requires A.Length == N
      requires forall p, q :: 0 <= p < N - i && N - i <= q < N ==> A[p] <= A[q]
      ensures forall k :: 0 < k < N - i ==> A[0] <= A[k]
  {
  }
  
  lemma swap_maintains_invariants(A: array<int>, j: int, N: int, i: int)
      requires 0 <= j < N - i - 1
      requires A.Length == N
      requires 0 <= i < N - 1
      requires forall k :: j < k < N - i ==> A[j] <= A[k]
      requires forall k :: 0 <= k <= j ==> A[k] <= A[j]
      requires forall p, q :: 0 <= p < N - i && N - i <= q < N ==> A[p] <= A[q]
      requires A[j] > A[j + 1]
      modifies A
      ensures forall k :: j + 1 < k < N - i ==> A[j + 1] <= A[k]
      ensures forall k :: 0 <= k <= j + 1 ==> A[k] <= A[j + 1]
      ensures forall p, q :: 0 <= p < N - i && N - i <= q < N ==> A[p] <= A[q]
  {
      A[j], A[j + 1] := A[j + 1], A[j];
  }

vc-spec: |-
  // <vc-spec>
  method BubbleSort(A:array<int>)
      modifies A
      ensures sorted(A)
      ensures multiset(A[..]) == multiset(old(A[..]))
  // </vc-spec>

vc-code: |-
  {
      var N := A.Length;
      if N <= 1 { return; }
      
      var i := 0;
      while i < N - 1
          invariant 0 <= i <= N - 1
          invariant multiset(A[..]) == multiset(old(A[..]))
          invariant sorted_between(A, N - i, N - 1)
          invariant forall p, q :: 0 <= p < N - i && N - i <= q < N ==> A[p] <= A[q]
      {
          var j := 0;
          
          if N - i - 1 > 0 {
              inner_loop_invariant_init(A, N, i);
          }
          
          while j < N - i - 1
              invariant 0 <= j <= N - i - 1
              invariant multiset(A[..]) == multiset(old(A[..]))
              invariant sorted_between(A, N - i, N - 1)
              invariant forall p, q :: 0 <= p < N - i && N - i <= q < N ==> A[p] <= A[q]
              invariant j == 0 || (forall k :: j < k < N - i ==> A[j] <= A[k])
              invariant j == 0 || (forall k :: 0 <= k <= j ==> A[k] <= A[j])
          {
              if A[j] > A[j + 1] {
                  ghost var old_seq := A[..];
                  swap_maintains_invariants(A, j, N, i);
                  ghost var new_seq := swap_preserves_multiset_helper(old_seq, j, j + 1);
                  assert multiset(A[..]) == multiset(old_seq);
              }
              j := j + 1;
          }
          
          after_inner_loop_sorted_extends(A, N, i);
          
          i := i + 1;
      }
  }

vc-postamble: |-


