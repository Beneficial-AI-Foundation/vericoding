vc-preamble: |-
  function Sum(v:array<int>,i:int,j:int):int
  reads v
  requires 0<=i<=j<=v.Length
  decreases j
  {
      if (i==j) then 0
      else Sum(v,i,j-1)+v[j-1]
  }
  
  predicate SumMaxToRight(v:array<int>,i:int,s:int)
  reads v
  requires 0<=i<v.Length
  {
  forall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s
  }
  
  function Sum2(v:array<int>,i:int,j:int):int
  reads v
  requires 0<=i<=j<=v.Length
  decreases j-i
  {
      if (i==j) then 0
      else v[i]+Sum2(v,i+1,j)
  }
  
  //Now do the same but with a loop from right to left
  predicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right
  reads v
  requires 0<=j<=i<v.Length
  {(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}

vc-helpers: |-
  lemma SumExtendLeft(v: array<int>, i: int, j: int)
    requires 0 <= i < j <= v.Length
    ensures Sum(v, i, j) == v[i] + Sum(v, i+1, j)
    decreases j - i
  {
    if i + 1 == j {
      assert Sum(v, i, j) == Sum(v, i, j-1) + v[j-1] == Sum(v, i, i) + v[i] == 0 + v[i] == v[i];
      assert Sum(v, i+1, j) == Sum(v, j, j) == 0;
      assert Sum(v, i, j) == v[i] + Sum(v, i+1, j);
    } else {
      assert Sum(v, i, j) == Sum(v, i, j-1) + v[j-1];
      SumExtendLeft(v, i, j-1);
      assert Sum(v, i, j-1) == v[i] + Sum(v, i+1, j-1);
      assert Sum(v, i+1, j) == Sum(v, i+1, j-1) + v[j-1];
      assert Sum(v, i, j) == v[i] + Sum(v, i+1, j-1) + v[j-1];
      assert Sum(v, i, j) == v[i] + Sum(v, i+1, j);
    }
  }
  
  lemma SumMonotonic(v: array<int>, i: int, j: int, k: int)
    requires 0 <= i <= j <= k <= v.Length
    requires forall x :: j <= x < k ==> v[x] >= 0
    ensures Sum(v, i, j) <= Sum(v, i, k)
    decreases k - j
  {
    if j == k {
    } else {
      SumMonotonic(v, i, j, k-1);
    }
  }
  
  lemma SumSingle(v: array<int>, i: int)
    requires 0 <= i < v.Length
    ensures Sum(v, i, i+1) == v[i]
  {
  }
  
  lemma SumMaxToRightHelper(v: array<int>, i: int, s: int, k: int)
    requires 0 <= k <= i < v.Length
    requires s == Sum(v, k, i+1)
    requires forall l {:trigger Sum(v, l, i+1)} :: 0 <= l <= i ==> Sum(v, l, i+1) <= s
    ensures SumMaxToRight(v, i, s)
  {
  }
  
  lemma SumComputeHelper(v: array<int>, i: int, j: int)
    requires 0 <= i <= j < v.Length
    ensures Sum(v, i, j+1) == v[i] + Sum(v, i+1, j+1) || i == j+1
  {
    if i < j+1 {
      SumExtendLeft(v, i, j+1);
    }
  }
  
  lemma InvariantPreservation(v: array<int>, j: int, i: int, s: int)
    requires 0 <= j < i < v.Length
    requires forall l {:trigger Sum(v, l, i+1)} :: j+1 <= l <= i ==> Sum(v, l, i+1) <= s
    requires Sum(v, j, i+1) <= s
    ensures forall l {:trigger Sum(v, l, i+1)} :: j <= l <= i ==> Sum(v, l, i+1) <= s
  {
  }

vc-spec: |-
  // <vc-spec>
  method segMaxSum(v:array<int>,i:int) returns (s:int,k:int)
  requires v.Length>0 && 0<=i<v.Length
  ensures 0<=k<=i && s==Sum(v,k,i+1) &&  SumMaxToRight(v,i,s)
  // </vc-spec>

vc-code: |-
  {
    s := v[i];
    k := i;
    
    var j := i;
    while j > 0
      invariant 0 <= j <= i
      invariant 0 <= k <= i
      invariant s == Sum(v, k, i+1)
      invariant forall l {:trigger Sum(v, l, i+1)} :: j <= l <= i ==> Sum(v, l, i+1) <= s
      decreases j
    {
      j := j - 1;
      
      SumExtendLeft(v, j, i+1);
      var temp := Sum(v, j, i+1);
      assert temp == v[j] + Sum(v, j+1, i+1);
      
      if temp > s {
        s := temp;
        k := j;
      } else {
        InvariantPreservation(v, j, i, s);
      }
    }
    
    SumMaxToRightHelper(v, i, s, k);
  }

vc-postamble: |-


