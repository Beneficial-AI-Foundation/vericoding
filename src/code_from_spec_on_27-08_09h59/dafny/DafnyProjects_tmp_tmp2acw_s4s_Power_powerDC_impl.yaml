vc-preamble: |-
  /* 
  * Formal verification of an O(log n) algorithm to calculate the natural power of a real number (x^n), 
  * illustrating the usage of lemmas and automatic induction in Dafny.
  * J.  Pascoal Faria, FEUP, Jan/2022.
  */
  
  // Recursive definition of x^n in functional style, with time and space complexity O(n).
  function power(x: real, n: nat) : real {
      if n == 0 then 1.0 else x * power(x, n-1)
  }
  
  // Computation of x^n in time and space O(log n).

vc-helpers: |-
  lemma powerEven(x: real, n: nat)
    requires n % 2 == 0 && n > 0
    ensures power(x, n) == power(x, n/2) * power(x, n/2)
  {
    if n == 2 {
      assert power(x, 2) == x * power(x, 1);
      assert power(x, 1) == x * power(x, 0);
      assert power(x, 0) == 1.0;
      assert power(x, 1) == x * 1.0 == x;
      assert power(x, 2) == x * x;
      assert power(x, n/2) == power(x, 1) == x;
      assert power(x, n/2) * power(x, n/2) == x * x;
    } else {
      var half := n / 2;
      assert n == half + half;
      powerAdditive(x, half, half);
    }
  }
  
  lemma powerOdd(x: real, n: nat)
    requires n % 2 == 1 && n > 0
    ensures power(x, n) == x * power(x, n-1)
  {
  }
  
  lemma powerAdditive(x: real, m: nat, n: nat)
    ensures power(x, m + n) == power(x, m) * power(x, n)
  {
    if n == 0 {
      assert m + n == m;
      assert power(x, n) == 1.0;
      assert power(x, m) * power(x, n) == power(x, m) * 1.0 == power(x, m);
    } else {
      assert power(x, m + n) == x * power(x, m + n - 1);
      assert m + n - 1 == m + (n - 1);
      powerAdditive(x, m, n - 1);
      assert power(x, m + (n - 1)) == power(x, m) * power(x, n - 1);
      assert power(x, n) == x * power(x, n - 1);
      assert power(x, m) * power(x, n) == power(x, m) * (x * power(x, n - 1));
      assert power(x, m) * (x * power(x, n - 1)) == x * (power(x, m) * power(x, n - 1));
    }
  }

vc-spec: |-
  // <vc-spec>
  method powerDC(x: real, n: nat) returns (p : real)
    ensures p == power(x, n)
  // </vc-spec>

vc-code: |-
  {
    if n == 0 {
      p := 1.0;
    } else if n % 2 == 0 {
      var half := powerDC(x, n/2);
      powerEven(x, n);
      p := half * half;
    } else {
      var prev := powerDC(x, n-1);
      powerOdd(x, n);
      p := x * prev;
    }
  }

vc-postamble: |-
  
  
  
  // A few test cases (checked statically by Dafny).

