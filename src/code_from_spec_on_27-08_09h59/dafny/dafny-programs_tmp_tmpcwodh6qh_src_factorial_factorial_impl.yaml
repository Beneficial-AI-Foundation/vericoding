vc-preamble: |-
  function fact(n: nat): nat 
      ensures fact(n) >= 1
  {
      if n == 0 then 1 else n * fact(n - 1)
  }

vc-helpers: |-
  lemma fact_positive(n: nat)
      ensures fact(n) >= 1
  {
      if n == 0 {
          assert fact(0) == 1;
      } else {
          fact_positive(n - 1);
          assert fact(n) == n * fact(n - 1);
          assert fact(n - 1) >= 1;
          assert n >= 1;
          assert fact(n) >= 1;
      }
  }
  
  lemma fact_iterative_correct(n: nat, i: nat, acc: nat)
      requires i <= n
      requires acc == fact(i)
      ensures acc * fact_range(i + 1, n) == fact(n)
      decreases n - i
  {
      if i == n {
          assert fact_range(i + 1, n) == 1;
      } else {
          assert fact(i + 1) == (i + 1) * fact(i);
          assert acc * (i + 1) == fact(i + 1);
          fact_iterative_correct(n, i + 1, acc * (i + 1));
      }
  }
  
  function fact_range(start: nat, end: nat): nat
      requires start <= end + 1
      ensures fact_range(start, end) >= 1
      decreases end - start + 1
  {
      if start > end then 1
      else if start == 0 then fact_range(1, end)
      else start * fact_range(start + 1, end)
  }
  
  lemma fact_range_property(n: nat)
      ensures fact_range(1, n) == fact(n)
      decreases n
  {
      if n == 0 {
          assert fact_range(1, 0) == 1;
          assert fact(0) == 1;
      } else {
          fact_range_property(n - 1);
          assert fact_range(1, n) == 1 * fact_range(2, n);
          assert fact(n) == n * fact(n - 1);
          
          if n == 1 {
              assert fact_range(1, 1) == 1 * fact_range(2, 1);
              assert fact_range(2, 1) == 1;
              assert fact_range(1, 1) == 1;
              assert fact(1) == 1;
          } else {
              fact_range_shift_lemma(2, n);
              assert fact_range(2, n) == fact_range(1, n - 1);
              assert fact_range(1, n - 1) == fact(n - 1);
              assert fact_range(1, n) == 1 * fact(n - 1);
          }
      }
  }
  
  lemma fact_range_shift_lemma(start: nat, end: nat)
      requires start >= 2
      requires start <= end
      ensures fact_range(start, end) == fact_range(start - 1, end - 1)
      decreases end - start + 1
  {
      if start == end {
          assert fact_range(start, end) == start;
          assert fact_range(start - 1, end - 1) == start - 1;
      } else {
          fact_range_shift_lemma(start + 1, end);
          assert fact_range(start + 1, end) == fact_range(start, end - 1);
          assert fact_range(start, end) == start * fact_range(start + 1, end);
          assert fact_range(start, end) == start * fact_range(start, end - 1);
          assert fact_range(start - 1, end - 1) == (start - 1) * fact_range(start, end - 1);
      }
  }

vc-spec: |-
  // <vc-spec>
  method factorial(n: nat) returns (res: nat)
      ensures res == fact(n)
  // </vc-spec>

vc-code: |-
  {
      res := 1;
      var i := 0;
      while i < n
          invariant 0 <= i <= n
          invariant res == fact(i)
      {
          i := i + 1;
          res := res * i;
      }
  }

vc-postamble: |-


