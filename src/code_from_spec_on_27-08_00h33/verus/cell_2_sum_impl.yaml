vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  spec fn seq_sum_bounded(s: Seq<u32>, bound: u32) -> bool {
      forall|i: int| 0 <= i < s.len() ==> s[i] <= bound
  }
  
  spec fn seq_sum(s: Seq<u32>) -> nat 
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else {
          s[s.len() - 1] as nat + seq_sum(s.subrange(0, s.len() - 1))
      }
  }
  
  proof fn seq_sum_bound_lemma(s: Seq<u32>, bound: u32)
      requires seq_sum_bounded(s, bound)
      ensures seq_sum(s) <= s.len() * bound
      decreases s.len()
  {
      if s.len() == 0 {
          assert(seq_sum(s) == 0);
          assert(s.len() * bound == 0);
      } else {
          let sub = s.subrange(0, s.len() - 1);
          assert(forall|j: int| 0 <= j < sub.len() ==> sub[j] == s[j]);
          assert(forall|j: int| 0 <= j < sub.len() ==> s[j] <= bound);
          assert(seq_sum_bounded(sub, bound));
          seq_sum_bound_lemma(sub, bound);
          assert(seq_sum(sub) <= sub.len() * bound);
          assert(s[s.len() - 1] <= bound);
          assert(seq_sum(s) == s[s.len() - 1] as nat + seq_sum(sub));
          assert(seq_sum(s) <= bound as nat + sub.len() * bound as nat);
          assert(sub.len() == s.len() - 1);
          assert(seq_sum(s) <= bound as nat + (s.len() - 1) * bound as nat);
          assert(bound as nat + (s.len() - 1) * bound as nat == s.len() * bound as nat);
          assert(seq_sum(s) <= s.len() * bound);
      }
  }
  
  proof fn seq_sum_extend_lemma(s: Seq<u32>, i: int)
      requires 0 <= i < s.len()
      ensures seq_sum(s.subrange(0, i + 1)) == seq_sum(s.subrange(0, i)) + s[i] as nat
  {
      let sub = s.subrange(0, i + 1);
      assert(sub.len() == i + 1);
      assert(sub[sub.len() - 1] == s[i]);
      assert(sub.subrange(0, sub.len() - 1) == s.subrange(0, i));
  }
  
  proof fn seq_sum_bounded_extend_lemma(s: Seq<u32>, bound: u32, i: int)
      requires 
          0 <= i < s.len(),
          seq_sum_bounded(s.subrange(0, i), bound),
          s[i] <= bound
      ensures seq_sum_bounded(s.subrange(0, i + 1), bound)
  {
      let sub = s.subrange(0, i + 1);
      assert(forall|j: int| 0 <= j < i ==> sub[j] == s.subrange(0, i)[j] && s.subrange(0, i)[j] <= bound);
      assert(sub[i] == s[i] && s[i] <= bound);
      assert(forall|j: int| 0 <= j < sub.len() ==> sub[j] <= bound);
  }

vc-spec: |-
  fn myfun(a: &mut Vec<u32>, N: u32) -> (sum: u32)
      // pre-conditions-start
      requires 
          old(a).len() == N,
          N <= 0x7FFF_FFFF,
      // pre-conditions-end
      // post-conditions-start
      ensures
          sum <= 2*N,
      // post-conditions-end

vc-code: |-
  {
      let mut sum: u32 = 0;
      let mut i: usize = 0;
      
      while i < a.len()
          invariant
              i <= a.len(),
              sum <= 2 * i,
              seq_sum_bounded(a@.subrange(0, i as int), 2),
              sum as nat == seq_sum(a@.subrange(0, i as int)),
              forall|j: int| 0 <= j < i ==> a@[j] <= 2,
          decreases a.len() - i
      {
          if a[i] > 2 {
              a.set(i, 2);
          }
          
          proof {
              assert(a@[i as int] <= 2);
              seq_sum_bounded_extend_lemma(a@, 2, i as int);
              assert(seq_sum_bounded(a@.subrange(0, i as int + 1), 2));
              
              let old_subrange = a@.subrange(0, i as int);
              let new_subrange = a@.subrange(0, i as int + 1);
              
              seq_sum_extend_lemma(a@, i as int);
              assert(seq_sum(new_subrange) == seq_sum(old_subrange) + a@[i as int] as nat);
              assert(sum as nat == seq_sum(old_subrange));
              assert(sum as nat + a@[i as int] as nat == seq_sum(new_subrange));
              
              assert(sum <= 2 * i);
              assert(a@[i as int] <= 2);
              assert(sum as nat + a@[i as int] as nat <= 2 * i + 2);
              assert(2 * i + 2 == 2 * (i + 1));
              assert(i < a.len() && a.len() == N && N <= 0x7FFF_FFFF);
              assert(2 * (i + 1) <= u32::MAX);
              assert(sum as nat + a@[i as int] as nat <= u32::MAX);
          }
          
          sum = sum + a[i];
          i = i + 1;
      }
      
      proof {
          assert(i == a.len());
          assert(a@.subrange(0, i as int) == a@.subrange(0, a.len() as int));
          assert(a@.subrange(0, a.len() as int) == a@);
          assert(seq_sum_bounded(a@, 2));
          seq_sum_bound_lemma(a@, 2);
          assert(sum as nat == seq_sum(a@));
          assert(seq_sum(a@) <= a@.len() * 2);
          assert(a@.len() == a.len() && a.len() == N);
          assert(sum as nat <= 2 * N);
          assert(sum <= 2 * N);
      }
      
      sum
  }

vc-postamble: |-
  
  }
  
  fn main() {}

