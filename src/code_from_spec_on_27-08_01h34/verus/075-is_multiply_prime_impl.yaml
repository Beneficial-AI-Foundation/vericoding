vc-description: |-


vc-preamble: |-
  use vstd::arithmetic::mul::*;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn spec_prime(p: int) -> (ret:bool) {
      p > 1 && forall|k: int| 1 < k < p ==> #[trigger] (p % k) != 0
  }
  // pure-end

vc-helpers: |-
  fn prime(p: u32) -> (ret: bool)
      ensures
          ret <==> spec_prime(p as int),
  {
      if p <= 1 {
          return false;
      }
      for k in 2..p
          invariant
              forall|j: int| 1 < j < k ==> #[trigger] (p as int % j) != 0,
              k <= p,
      {
          if p % k == 0 {
              return false;
          }
      }
      true
  }
  
  fn checked_mul_thrice(x: u32, y: u32, z: u32) -> (ret: Option<u32>)
      ensures
          ret.is_some() ==> ret.unwrap() == x * y * z,
          ret.is_none() ==> x * y * z > u32::MAX,
  {
      if (x == 0 || y == 0 || z == 0) {
          proof {
              assert(x * y * z == 0);
          }
          return Some(0);
      }
      assert(x > 0 && y > 0 && z > 0);
      let prod2 = x.checked_mul(y);
      if prod2.is_some() {
          let prod3 = prod2.unwrap().checked_mul(z);
          if prod3.is_some() {
              let ans = prod3.unwrap();
              assert(ans == x * y * z);
              Some(ans)
          } else {
              assert(x * y * z > u32::MAX);
              None
          }
      } else {
          broadcast use group_mul_properties;
          assert(x * y * z >= y * z);
          None
      }
  }
  
  proof fn bound_lemma(a: int, b: int, c: int, x: int)
      requires
          a >= 2, b >= 2, c >= 2, x > 1, x == a * b * c
      ensures
          a < x || b < x || c < x
  {
      if a >= x && b >= x && c >= x {
          assert(a * b >= x * x);
          assert(a * b * c >= x * x * x);
          assert(x >= x * x * x);
          assert(1 >= x * x);
          assert(false);
      }
  }

vc-spec: |-
  fn is_multiply_prime(x: u32) -> (ans: bool)
      // pre-conditions-start
      requires
          x > 1,
      // pre-conditions-end
      // post-conditions-start
      ensures
          ans <==> exists|a: int, b: int, c: int|
              spec_prime(a) && spec_prime(b) && spec_prime(c) && x == a * b * c,
      // post-conditions-end

vc-code: |-
  {
      for a in 2..x
          invariant
              forall|a_val: int, b_val: int, c_val: int| 
                  2 <= a_val < a && spec_prime(a_val) && spec_prime(b_val) && spec_prime(c_val) ==> x != a_val * b_val * c_val,
      {
          if prime(a) {
              for b in a..x
                  invariant
                      spec_prime(a as int),
                      forall|a_val: int, b_val: int, c_val: int| 
                          2 <= a_val < a && spec_prime(a_val) && spec_prime(b_val) && spec_prime(c_val) ==> x != a_val * b_val * c_val,
                      forall|b_val: int, c_val: int| 
                          (a as int) <= b_val < b && spec_prime(b_val) && spec_prime(c_val) ==> x != (a as int) * b_val * c_val,
              {
                  if prime(b) {
                      for c in b..x
                          invariant
                              spec_prime(a as int),
                              spec_prime(b as int),
                              forall|a_val: int, b_val: int, c_val: int| 
                                  2 <= a_val < a && spec_prime(a_val) && spec_prime(b_val) && spec_prime(c_val) ==> x != a_val * b_val * c_val,
                              forall|b_val: int, c_val: int| 
                                  (a as int) <= b_val < b && spec_prime(b_val) && spec_prime(c_val) ==> x != (a as int) * b_val * c_val,
                              forall|c_val: int| 
                                  (b as int) <= c_val < c && spec_prime(c_val) ==> x != (a as int) * (b as int) * c_val,
                      {
                          if prime(c) {
                              let product = checked_mul_thrice(a, b, c);
                              if product.is_some() && product.unwrap() == x {
                                  proof {
                                      assert(spec_prime(a as int) && spec_prime(b as int) && spec_prime(c as int));
                                      assert(x == (a as int) * (b as int) * (c as int));
                                  }
                                  return true;
                              }
                          }
                      }
                  }
              }
          }
      }
      proof {
          if exists|a: int, b: int, c: int| spec_prime(a) && spec_prime(b) && spec_prime(c) && x == a * b * c {
              let a_wit = choose|a: int| #[trigger] spec_prime(a) && exists|b: int, c: int| spec_prime(b) && spec_prime(c) && x == a * b * c;
              let b_wit = choose|b: int| #[trigger] spec_prime(b) && exists|c: int| spec_prime(c) && x == a_wit * b * c;
              let c_wit = choose|c: int| #[trigger] spec_prime(c) && x == a_wit * b_wit * c;
              assert(spec_prime(a_wit) && a_wit > 1);
              assert(spec_prime(b_wit) && b_wit > 1);
              assert(spec_prime(c_wit) && c_wit > 1);
              assert(x == a_wit * b_wit * c_wit && x > 1);
              assert(a_wit >= 2 && b_wit >= 2 && c_wit >= 2);
              
              bound_lemma(a_wit, b_wit, c_wit, x as int);
              
              if a_wit < x && b_wit < x && c_wit < x {
                  let min_val = if a_wit <= b_wit && a_wit <= c_wit { a_wit } else if b_wit <= c_wit { b_wit } else { c_wit };
                  assert(min_val >= 2);
                  assert(min_val < x as int);
                  assert(false);
              }
          }
      }
      false
  }

vc-postamble: |-
  
  }
  fn main() {}

