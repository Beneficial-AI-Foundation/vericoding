vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn has_divisor_in_range(n: int, start: int, end: int) -> bool {
      exists|k: int| start <= k < end && #[trigger] (n % k) == 0
  }
  
  proof fn divisor_range_split(n: int, start: int, mid: int, end: int)
      requires start <= mid <= end
      ensures has_divisor_in_range(n, start, end) == 
              (has_divisor_in_range(n, start, mid) || has_divisor_in_range(n, mid, end))
  {
  }
  
  proof fn divisor_range_extend(n: int, start: int, end: int)
      requires start < end
      ensures has_divisor_in_range(n, start, end + 1) == 
              (has_divisor_in_range(n, start, end) || n % end == 0)
  {
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn is_non_prime(n: u32) -> (result: bool)
      // pre-conditions-start
      requires
          n >= 2,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result == exists|k: int| 2 <= k < n && #[trigger] (n as int % k) == 0,
      // post-conditions-end

vc-code: |-
  {
      let mut i = 2u32;
      while i < n
          invariant
              2 <= i <= n,
              !has_divisor_in_range(n as int, 2, i as int),
      {
          if n % i == 0 {
              proof {
                  assert(n as int % i as int == 0);
                  assert(2 <= i as int);
                  assert((i as int) < (n as int));
              }
              return true;
          }
          i = i + 1;
          proof {
              divisor_range_extend(n as int, 2, i as int - 1);
          }
      }
      proof {
          assert(!has_divisor_in_range(n as int, 2, n as int));
          assert(has_divisor_in_range(n as int, 2, n as int) == 
                 exists|k: int| 2 <= k < n && #[trigger] (n as int % k) == 0);
      }
      false
  }

vc-postamble: |-
  
  fn main() {}
  }

