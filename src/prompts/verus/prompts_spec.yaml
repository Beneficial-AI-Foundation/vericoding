generate_code: |
  The task is to generate a Verus (Rust with verification) file that is verified and satisfies the constraints described in the specifications.
  
  INPUT: a Verus file containing one or more function definitions (including spec functions, helper functions, and main), possibly with empty bodies or bodies containing TODO comments (e.g., `return 0;  // TODO: Remove this line and implement the function body`).
  - The file may include:
    - Standard Rust/Verus imports (e.g., `use vstd::prelude::*;`)
    - A `verus! {{ ... }}` block wrapping the code
    - Function definitions with `requires` and `ensures` clauses
    - `spec fn`, `fn`, and possibly proof blocks
    - Attributes such as `#[verifier::loop_isolation(false)]`
    - Helper/spec functions that may be used in ensures/requirements
    - A `fn main() {{}}` function (which should be preserved)
  - Function bodies may contain `unimplemented!()`, `return ...; // TODO: ...`, or be empty.

  OUTPUT: ONLY return the implementation sections that need to be filled in. DO NOT return the entire file.
  
  IMPORTANT: Look for sections marked with `// <vc-code>` in the input. Return ONLY the content that should go inside that section - typically just the function body in curly braces.
  
  Example:
  Input file contains:
  ```
  fn binary_search(a: &[i32], x: i32) -> (index: i32)
      requires sorted(a),
      ensures ...
  // <vc-code>
  {{
      assume(false);
      -1
  }}
  // </vc-code>
  ```
  
  Your response should contain ONLY:
  ```vc-code
  {{
      let mut left: usize = 0;
      let mut right: usize = a.len();
      
      while left < right
          invariant left <= right <= a.len(),
      {{
          let mid = left + (right - left) / 2;
          if a[mid] == x {{
              return mid as i32;
          }} else if a[mid] < x {{
              left = mid + 1;
          }} else {{
              right = mid;
          }}
      }}
      -1
  }}
  ```
  
  - Implementations must not use `assume` statements.
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses).
  - Use Verus types like `nat`, `int`, `Vec<T>`, `Seq<T>`, etc.
  - Use `@` for sequence/vector indexing when needed (e.g., `v@[i]`).
  - Use proof blocks with `proof {{ ... }}` when necessary.

  VERUS SPECIFICATION WITH EMPTY OR TODO METHOD/FUNCTION BODIES:
  {code}

fix_verification: |
  INPUT: a Verus file containing one or more function definitions (including spec functions, helper functions, and main), possibly with incomplete or incorrect implementations that do not verify.
  - The file may include:
    - Standard Rust/Verus imports (e.g., `use vstd::prelude::*;`)
    - A `verus! {{ ... }}` block wrapping the code
    - Function definitions with `requires` and `ensures` clauses
    - `spec fn`, `fn`, and possibly proof blocks
    - Attributes such as `#[verifier::loop_isolation(false)]`
    - Helper/spec functions that may be used in ensures/requirements
    - A `fn main() {{}}` function (which should be preserved)
  - Function bodies may contain incomplete code, `unimplemented!()`, or TODO comments.

  OUTPUT: ONLY return the sections that need to be fixed. DO NOT return the entire file.
  
  IMPORTANT: Look for sections marked with `// <vc-helpers>`, `// <vc-spec>`, or `// <vc-code>` in the input. Return ONLY the content that should replace those sections.
  
  Example:
  If the input has a broken function body in the `// <vc-code>` section:
  ```
  // <vc-code>
  {{
      let x = a[0];  // broken: index out of bounds
      x
  }}
  // </vc-code>
  ```
  
  Your response should contain ONLY:
  ```vc-code
  {{
      if a.len() > 0 {{
          a[0]
      }} else {{
          -1
      }}
  }}
  ```
  
  - You may add proof annotations, helper functions, predicates, and spec functions as needed in the appropriate sections.
  - PRIORITY: If the error is a compilation error (syntax, type, resolution errors), fix it first before addressing verification issues.
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses).
  - Use proof blocks with `proof {{ ... }}` for complex proofs.
  - Use `assert()` statements within proof blocks for intermediate steps.
  - Use Verus types and operators (`nat`, `int`, `Vec<T>`, `Seq<T>`, `@`, etc.).
  - Use `@` for sequence/vector access (e.g., `v@[i]` for indexing).
  - Do not use `assume` statements in implementations.

  COMMENT FORMAT: add this comment right before any code or annotation block in a function body that you add or modify
  /* code modified by LLM (iteration {{iteration}}): [brief description] */
  
  ERROR DETAILS from Verus verification of the given code:
  {errorDetails}

  Code Below:
  {code}
