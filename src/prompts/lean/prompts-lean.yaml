generate_code: |
  ⚠️  CRITICAL: DO NOT USE SORRY IN YOUR RESPONSE! You must provide actual implementations and proofs.
  
  The task is to generate a COMPLETE Lean file with all implementations and proofs filled in.
  
  INPUT: An incomplete Lean file containing "sorry" placeholders in place of implementations and proofs.
  
  OUTPUT: Return the COMPLETE Lean file with ALL "sorry" replaced by actual implementations and proofs.
  
  IMPORTANT FORMATTING:
  - Return ONLY the complete Lean code wrapped in ```lean code block
  - NO explanations, reasoning, or markdown outside the code block
  - The entire file contents should be inside the code block
  
  CRITICAL RULES:
  - ⚠️  ABSOLUTELY NO "sorry" ANYWHERE IN YOUR OUTPUT - provide real implementations and proofs
  - Do NOT change function names, theorem names, or type signatures
  - You can add helper definitions, theorems, and lemmas as needed
  - For any new definition/lemma/theorem you add, put a comment "-- LLM HELPER" on the line before it
  - Return the COMPLETE file - all imports, all definitions, all theorems, all proofs
  
  LEAN SPECIFICATION FILE TO COMPLETE:
  {code}

fix_verification: |
 The task is to review definitions and theorems in a Lean file that do not verify due to missing or invalid implementations or proofs. 
 INPUT: a Lean file that contains some definitions and theorems that dont verify due to missing or invalid implementations or proofs. 
 The file contains:
 - some atoms (def, lemma, theorem, ...) that have the comment -- LLM HELPER before them. These atoms you can change and remove at will. 

 For all the other atoms (that do not have the comment -- LLM HELPER) your are allowed to change the definition or prooof body, but you are not allowed to change the name, type, or signature of the atom.

  More precisely, these atoms will be of the form:
  def def_type_1 := implementation_1
  ...
  def def_type_n := implementation_n
  theorem thm_type_1 := proof_1
  ...
  theorem thm_type_n := proof_n
    
  and you are allowed to change the implementation_i and proof_i, but you are not allowed to change def_type_i or thm_type_i. So the output file should contain:

  def def_type_1 := implementation_upd_1
  ...
  def def_type_n := implementation_upd_n
  theorem thm_type_1 := proof_upd_1
  ...
  theorem thm_type_n := proof_upd_n
  where implementation_upd_i and proof_upd_i are the updated implementations and proofs that should verify.

    
  POSITIVE CRITICAL RULES:
  - you can change the implementation of def_type_i and proof of thm_type_i to fix the verification errors
  - you can add helper definitions, theorems, and lemmas as needed, but the initial definitions and theorems must remain unchanged. 
  Moreover, for any new definition, lemma or theorem you add, add a comment of the form -- LLM HELPER on the line just before it. 
  
  NEGATIVE CRITICAL RULES:
  - you should not add trivial annotations (requires true, invariant true, ensures true, etc.)
  - you should not add null checks on non-nullable types
  - do not use sorry in the output file
  - output valid Lean code
  - Return ONLY the Lean code, no explanations or markdown

  OUTPUT: Return ONLY the complete Lean code file, wrapped in a ```lean code block. Do not include any explanations, reasoning, or markdown outside the code block.
  
  ERROR DETAILS from Lean verification of the given code:
  {errorDetails}

  Code Below:
  {code}
