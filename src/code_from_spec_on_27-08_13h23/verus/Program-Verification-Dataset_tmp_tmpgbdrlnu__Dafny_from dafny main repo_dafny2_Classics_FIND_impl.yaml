vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // RUN: %testDafnyForEachResolver "%s" -- --warn-deprecation:false
  
  
  // A version of Turing's additive factorial program [Dr. A. Turing, "Checking a large routine",
  // In "Report of a Conference of High Speed Automatic Calculating Machines", pp. 67-69, 1949].
  
  spec fn factorial(n: nat) -> nat
      decreases n
  {
      if n == 0 { 1 } else { n * factorial(sub(n, 1)) }
  }
  
  
  // Hoare's FIND program [C.A.R. Hoare, "Proof of a program: FIND", CACM 14(1): 39-45, 1971].
  // The proof annotations here are not the same as in Hoare's article.
  
  // In Hoare's words:
  //   This program operates on an array A[1:N], and a value of f (1 <= f <= N).
  //   Its effect is to rearrange the elements of A in such a way that:
  //     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).
  //
  // Here, we use 0-based indices, so we would say:
  //   This method operates on an array A[0..N], and a value of f (0 <= f < N).
  //   Its effect is to rearrange the elements of A in such a way that:
  //     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).

vc-helpers: |-
  spec fn sub(a: nat, b: nat) -> nat
      requires a >= b
      decreases a
  {
      if a < b { 0 } else { a - b }
  }
  
  proof fn lemma_factorial_positive(n: nat)
      ensures factorial(n) > 0
      decreases n
  {
      if n == 0 {
          assert(factorial(0) == 1);
      } else {
          lemma_factorial_positive(sub(n, 1));
          assert(factorial(n) == n * factorial(sub(n, 1)));
      }
  }

vc-spec: |-
  // <vc-spec>
  fn find(A: &mut Vec<i32>, N: usize, f: usize)
      requires 
          old(A)@.len() == N,
          f < N,
      ensures
          forall|p: int, q: int| 0 <= p <= f as int <= q < N as int ==> A@[p] <= A@[q],
  // </vc-spec>

vc-code: |-
  fn find(A: &mut Vec<i32>, N: usize, f: usize)
      requires 
          old(A)@.len() == N,
          f < N,
      ensures
          forall|p: int, q: int| 0 <= p <= f as int <= q < N as int ==> A@[p] <= A@[f as int] <= A@[q],
  {
      let mut m: usize = 0;
      let mut n: usize = N - 1;
      
      while m < n
          invariant
              0 <= m <= f <= n < N,
              forall|p: int, q: int| 0 <= p <= m as int <= f as int <= n as int <= q < N as int ==> A@[p] <= A@[f as int] <= A@[q],
          decreases n - m
      {
          if A[m] <= A[f] {
              m = m + 1;
          } else if A[n] >= A[f] {
              n = n - 1;
          } else {
              let temp = A[m];
              A[m] = A[n];
              A[n] = temp;
              if m < f {
                  m = m + 1;
              }
              if n > f {
                  n = n - 1;
              }
          }
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

