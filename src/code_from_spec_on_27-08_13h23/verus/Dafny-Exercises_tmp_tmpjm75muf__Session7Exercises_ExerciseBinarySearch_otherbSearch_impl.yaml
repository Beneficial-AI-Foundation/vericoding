vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted(s: Seq<i32>) -> bool {
      forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] <= s[w]
  }
  
  fn binary_search(v: &Vec<i32>, elem: i32) -> (p: i32)
      requires sorted(v@)
      ensures -1 <= p < v.len()
      ensures forall|u: int| 0 <= u <= p ==> v[u] <= elem
      ensures forall|w: int| p < w < v.len() ==> v[w] > elem
  {
      assume(false);
      -1
  }
  
  
  
  
  
  
  // Recursive binary search

vc-helpers: |-
  spec fn mid_point(low: int, high: int) -> int {
      low + (high - low) / 2
  }
  
  proof fn lemma_sorted_subrange(v: Seq<i32>, low: int, high: int)
      requires
          sorted(v),
          0 <= low <= high <= v.len(),
      ensures
          sorted(v.subrange(low, high))
  {
      reveal_with_fuel(forall_2_args, 4);
  }

vc-spec: |-
  // <vc-spec>
  fn other_b_search(v: &Vec<i32>, elem: i32) -> (res: (bool, usize))
      requires sorted(v@)
      ensures 0 <= res.1 <= v.len()
      ensures res.0 == v@.contains(elem)
      ensures res.0 ==> res.1 < v.len() && v[res.1 as int] == elem
      ensures !res.0 ==> forall|u: int| 0 <= u < res.1 ==> v[u] < elem
      ensures !res.0 ==> forall|w: int| res.1 <= w < v.len() ==> v[w] > elem
  // Implement and verify
  // </vc-spec>

vc-code: |-
  fn other_b_search(v: &Vec<i32>, elem: i32) -> (res: (bool, usize))
      requires sorted(v@)
      ensures
          0 <= res.1 <= v.len(),
          res.0 == v@.contains(elem),
          res.0 ==> res.1 < v.len() && v@[res.1 as int] == elem,
          !res.0 ==> forall|u: int| 0 <= u < res.1 ==> v@[u] < elem,
          !res.0 ==> forall|w: int| res.1 <= w < v.len() ==> v@[w] > elem
  {
      let mut low: usize = 0;
      let mut high: usize = v.len();
      while low < high
          invariant
              0 <= low <= high <= v.len(),
              sorted(v@),
              forall|u: int| 0 <= u < low as int ==> v@[u] < elem,
              forall|w: int| high as int <= w < v.len() ==> v@[w] > elem
          decreases high - low
      {
          let mid = mid_point(low as int, high as int) as usize;
          if v[mid] == elem {
              return (true, mid);
          } else if v[mid] < elem {
              low = mid + 1;
          } else {
              high = mid;
          }
      }
      (false, low)
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

