vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Checks if array 'a' is sorted.
  spec fn is_sorted(a: &[i32]) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
  }
  
  // Finds a value 'x' in a sorted array 'a', and returns its index,
  // or -1 if not found.
  
  // Simple test cases to check the post-condition.
  
  /*
  a) Identify adequate pre and post-conditions for this method, 
  and encode them as "requires" and "ensures" clauses in Verus. 
  You can use the predicate below if needed.
  
  b) Identify an adequate loop variant and loop invariant, and encode them 
  as "decreases" and "invariant" clauses in Verus.
  */

vc-helpers: |-
  // No additional helper functions or proofs needed for this implementation

vc-spec: |-
  // <vc-spec>
  fn binary_search(a: &[i32], x: i32) -> (index: i32)
      requires is_sorted(a)
      ensures -1 <= index < a.len() && 
              (index != -1 ==> a[index as int] == x) &&
              (index == -1 ==> !a@.contains(x))
  // </vc-spec>

vc-code: |-
  fn binary_search(a: &[i32], x: i32) -> (index: i32)
      requires is_sorted(a)
      ensures -1 <= index < a.len() as i32 &&
              (index != -1 ==> a[index as usize] == x) &&
              (index == -1 ==> !a@.contains(x))
  {
      let mut left: i32 = 0;
      let mut right: i32 = (a.len() as i32) - 1;
      
      while left <= right
          invariant 0 <= left <= right + 1,
                    right < a.len() as i32,
                    forall|i: int| 0 <= i < left ==> a[i as usize] < x,
                    forall|i: int| right < i < a.len() ==> a[i as usize] > x
          decreases right - left
      {
          let mid: i32 = left + (right - left) / 2;
          if a[mid as usize] == x {
              return mid;
          } else if a[mid as usize] < x {
              left = mid + 1;
          } else {
              right = mid - 1;
          }
      }
      -1
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

