vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn split_point(a: &Vec<int>, n: int) -> bool {
      0 <= n <= a.len() &&
      forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]
  }
  
  spec fn swap_frame(a_old: &Vec<int>, a_new: &Vec<int>, lo: int, hi: int) -> bool {
      0 <= lo <= hi <= a_old.len() &&
      a_old.len() == a_new.len() &&
      (forall|i: int| (0 <= i < lo || hi <= i < a_old.len()) ==> a_new[i] == a_old[i]) &&
      a_new@.to_multiset() == a_old@.to_multiset()
  }

vc-helpers: |-
  proof fn lemma_split_point_monotonic(a: &Vec<int>, n1: int, n2: int)
      requires
          0 <= n1 <= n2 <= a.len(),
          split_point(a, n1),
          split_point(a, n2),
      ensures
          forall|i: int, j: int| 0 <= i < n1 <= j < n2 ==> a[i] <= a[j]
  {
      assert forall|i: int, j: int| 0 <= i < n1 <= j < n2 implies a[i] <= a[j] by {
          if j < a.len() {
              assert(0 <= i < n1 <= j < a.len());
          }
      };
  }
  
  proof fn lemma_swap_frame_preserved(a_old: &Vec<int>, a_new: &Vec<int>, lo: int, hi: int, n: int)
      requires
          0 <= lo <= hi <= a_old.len(),
          0 <= n <= a_old.len(),
          split_point(a_old, n),
          swap_frame(a_old, a_new, lo, hi),
      ensures
          split_point(a_new, n)
  {
      assert forall|i: int, j: int| 0 <= i < n <= j < a_new.len() implies a_new[i] <= a_new[j] by {
          if 0 <= i < n && n <= j < a_new.len() {
              if !(lo <= i < hi) {
                  assert(a_new[i] == a_old[i]);
              }
              if !(lo <= j < hi) {
                  assert(a_new[j] == a_old[j]);
              }
              assert(a_old[i] <= a_old[j]);
          }
      };
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<int>)
      ensures
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  fn selection_sort(a: &mut Vec<int>)
      ensures
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          a@.to_multiset() == old(a)@.to_multiset(),
  {
      let mut n: int = 0;
      while n < a.len()
          invariant
              0 <= n <= a.len(),
              split_point(a, n),
              a@.to_multiset() == old(a)@.to_multiset(),
      {
          let mut min_idx: int = n;
          let mut i: int = n + 1;
          while i < a.len()
              invariant
                  n <= min_idx < a.len(),
                  n <= i <= a.len(),
                  0 <= n <= a.len(),
                  split_point(a, n),
                  a@.to_multiset() == old(a)@.to_multiset(),
                  forall|k: int| n <= k < i ==> a[min_idx] <= a[k],
          {
              if a[i] < a[min_idx] {
                  min_idx = i;
              }
              i = i + 1;
          }
          if min_idx != n {
              let ghost a_old = a@;
              a.swap(n as usize, min_idx as usize);
              proof {
                  assert(swap_frame(&a_old.view(), &a.view(), n, min_idx + 1));
                  lemma_swap_frame_preserved(&a_old.view(), &a.view(), n, min_idx + 1, n);
              }
          }
          n = n + 1;
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

