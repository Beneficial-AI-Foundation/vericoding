vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  //Bubblesort CS 494 submission
  //References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785
  
  
  // predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array
  
  spec fn sorted(a: &Vec<i32>, from: usize, to: usize) -> bool
      recommends 
          from <= to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]
  }
  
  //helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept 
  spec fn pivot(a: &Vec<i32>, to: usize, pvt: usize) -> bool
      recommends
          pvt < to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| 0 <= x < pvt < y < to ==> a[x as int] <= a[y as int] // all values within the array should be in ascending order
  }
  
  // Here having the algorithm for the bubblesort

vc-helpers: |-
  // Helper function to swap elements in the vector
  proof fn swap_preserves_multiset(a: &Vec<i32>, i: usize, j: usize)
      requires
          i < a.len(),
          j < a.len(),
      ensures
          {
              let mut new_a = a.clone();
              new_a.set(i as int, a[j as int]);
              new_a.set(j as int, a[i as int]);
              new_a.to_multiset() == a.to_multiset()
          },
  {
      let mut new_a = a.clone();
      new_a.set(i as int, a[j as int]);
      new_a.set(j as int, a[i as int]);
      assert(new_a.to_multiset() == a.to_multiset());
  }
  
  // Helper lemma to prove that swapping two elements maintains the multiset
  proof fn swap_maintains_multiset(a: &Vec<i32>, i: usize, j: usize, new_a: &Vec<i32>)
      requires
          i < a.len(),
          j < a.len(),
          new_a@ == {
              let mut temp = a@;
              temp.set(i as int, a[j as int]);
              temp.set(j as int, a[i as int]);
              temp
          },
      ensures
          new_a.to_multiset() == a.to_multiset(),
  {
      assert(new_a.to_multiset() == a.to_multiset());
  }

vc-spec: |-
  // <vc-spec>
  fn BubbleSort(a: &mut Vec<i32>)
      requires 
          old(a).len() > 0, // makes sure a is not empty and length is greater than 0
      ensures 
          sorted(a, 0, a.len()), // makes sure elements of array a are sorted from 0 - a.len()
          a@.to_multiset() == old(a)@.to_multiset(), // Since a is being modified, we compare the previous elements to current elements.
  // </vc-spec>

vc-code: |-
  fn BubbleSort(a: &mut Vec<i32>)
      requires
          old(a).len() > 0,
      ensures
          sorted(a, 0, a.len()),
          a@.to_multiset() == old(a)@.to_multiset(),
  {
      let n = a.len();
      let mut i: usize = 0;
      while i < n
          invariant
              0 <= i <= n,
              sorted(a, 0, i),
              pivot(a, n, i),
              a@.to_multiset() == old(a)@.to_multiset(),
      {
          let mut j: usize = 0;
          while j < n - i - 1
              invariant
                  0 <= j < n - i,
                  0 <= i < n,
                  sorted(a, 0, i),
                  pivot(a, n - i - 1, i),
                  forall|x: usize, y: usize| i <= x < y < n ==> a@[x as int] <= a@[y as int],
                  a@.to_multiset() == old(a)@.to_multiset(),
          {
              if a@[j] > a@[j + 1] {
                  let temp = a@[j];
                  a.set(j as int, a@[j + 1]);
                  a.set(j + 1 as int, temp);
                  proof {
                      swap_preserves_multiset(a, j, j + 1);
                  }
              }
              j = j + 1;
          }
          i = i + 1;
      }
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

