vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(X_val: Seq<int>, X_crd: Seq<nat>, 
             v_val: Seq<int>, v_crd: Seq<nat>, 
             kX: nat, kV: nat, pX_end: nat, pV_end: nat) -> int
      decreases pX_end + pV_end - (kX + kV)
  {
      if pV_end <= kV || pX_end <= kX {
          0
      } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] == v_crd[kV as int] {
          sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + 
          (if kV < v_val.len() && kX < X_val.len() { v_val[kV as int] * X_val[kX as int] } else { 0 })
      } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] < v_crd[kV as int] {
          sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)
      } else {
          sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)
      }
  }
  
  spec fn min(x: nat, y: nat) -> nat {
      if x <= y { x } else { y }
  }
  
  spec fn notin(y: nat, x: Seq<nat>) -> bool {
      forall|i: int| 0 <= i < x.len() ==> y != #[trigger] x[i]
  }
  
  spec fn index_seq(x: nat, y: Seq<nat>) -> nat
      decreases y.len()
  {
      if y.len() == 0 {
          0
      } else if y[0] == x {
          0
      } else {
          1 + index_seq(x, y.subrange(1, y.len() as int))
      }
  }
  
  spec fn index(x: nat, y: Seq<nat>) -> nat {
      index_seq(x, y)
  }

vc-helpers: |-
  proof fn sum_non_negative(X_val: Seq<int>, X_crd: Seq<nat>, v_val: Seq<int>, v_crd: Seq<nat>, 
                            kX: nat, kV: nat, pX_end: nat, pV_end: nat)
      requires
          forall|i: int| kX <= i < pX_end ==> 0 <= #[trigger] X_val[i],
          forall|i: int| kV <= i < pV_end ==> 0 <= #[trigger] v_val[i],
      ensures
          sum(X_val, X_crd, v_val, v_crd, kX, kV, pX_end, pV_end) >= 0,
      decreases pX_end + pV_end - (kX + kV)
  {
      if pV_end <= kV || pX_end <= kX {
          assert(sum(X_val, X_crd, v_val, v_crd, kX, kV, pX_end, pV_end) == 0);
      } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] == v_crd[kV as int] {
          sum_non_negative(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end);
          assert(sum(X_val, X_crd, v_val, v_crd, kX, kV, pX_end, pV_end) >= 0);
      } else if kX < X_crd.len() && kV < v_crd.len() && X_crd[kX as int] < v_crd[kV as int] {
          sum_non_negative(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end);
      } else {
          sum_non_negative(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn DSpMSpV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], X_crd1: &[nat], X_len: nat,
             v_val: &[int], v_crd: &[nat]) -> (result: Vec<int>)
      // X requirements 
      requires X_pos.len() >= 1,
      requires X_val.len() == X_crd.len(),
      requires forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> #[trigger] X_pos[i] <= #[trigger] X_pos[j],
      requires forall|i: int| 0 <= i < X_pos.len() ==> 0 <= #[trigger] X_pos[i] <= X_val.len(),
  
      requires X_len >= X_crd1.len(),
      requires forall|i: int| 0 <= i < X_crd1.len() ==> #[trigger] X_crd1[i] < X_len,
  
      requires X_crd1.len() < X_pos.len(),
      requires forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> #[trigger] X_crd1[i] < #[trigger] X_crd1[j],
  
      // v requirements 
      requires v_val.len() == v_crd.len(),
  
      ensures result.len() == X_len,
      ensures forall|i: int| 0 <= i < result.len() ==> {
          let idx = index(i as nat, X_crd1@);
          #[trigger] result[i] == if idx < X_crd1.len() {
              sum(X_val@, X_crd@, v_val@, v_crd@, X_pos[idx as int], 0, 
                  X_pos[idx as int + 1], v_val.len() as nat)
          } else {
              0
          }
      }
  // </vc-spec>

vc-code: |-
  fn DSpMSpV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], X_crd1: &[nat], X_len: nat,
             v_val: &[int], v_crd: &[nat]) -> (result: Vec<int>)
      requires
          X_pos.len() >= 1,
          X_val.len() == X_crd.len(),
          forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> #[trigger] X_pos[i] <= #[trigger] X_pos[j],
          forall|i: int| 0 <= i < X_pos.len() ==> 0 <= #[trigger] X_pos[i] <= X_val.len(),
          X_len >= X_crd1.len(),
          forall|i: int| 0 <= i < X_crd1.len() ==> #[trigger] X_crd1[i] < X_len,
          X_crd1.len() < X_pos.len(),
          forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> #[trigger] X_crd1[i] < #[trigger] X_crd1[j],
          v_val.len() == v_crd.len(),
      ensures
          result.len() == X_len,
          forall|i: int| 0 <= i < result.len() ==> {
              let idx = index(i as nat, X_crd1@);
              #[trigger] result[i] == if idx < X_crd1.len() {
                  sum(X_val@, X_crd@, v_val@, v_crd@, X_pos[idx as int], 0, 
                      X_pos[idx as int + 1], v_val.len() as nat)
              } else {
                  0
              }
          }
  {
      let mut result: Vec<int> = Vec::with_capacity(X_len as usize);
      let mut i: usize = 0;
      let mut k: usize = 0;
  
      while i < X_len as usize
          invariant
              result.len() == i,
              forall|j: int| 0 <= j < i ==> {
                  let idx = index(j as nat, X_crd1@);
                  #[trigger] result[j] == if idx < X_crd1.len() {
                      sum(X_val@, X_crd@, v_val@, v_crd@, X_pos[idx as int], 0, 
                          X_pos[idx as int + 1], v_val.len() as nat)
                  } else {
                      0
                  }
              },
              0 <= k <= X_crd1.len(),
              forall|j: int| 0 <= j < k ==> X_crd1[j] < i as nat,
      {
          let idx = if k < X_crd1.len() && X_crd1[k] == i as nat {
              k
          } else {
              X_crd1.len()
          };
  
          let sum_val = if idx < X_crd1.len() {
              let start = X_pos[idx];
              let end = X_pos[idx + 1];
              let mut sum_result: int = 0;
              let mut kX: usize = start as usize;
              let mut kV: usize = 0;
  
              while kX < end as usize && kV < v_val.len()
                  invariant
                      start <= kX as nat <= end,
                      0 <= kV <= v_val.len(),
                      sum_result == sum(X_val@, X_crd@, v_val@, v_crd@, start, 0, kX as nat, kV as nat),
                  decreases (end - kX as nat) + (v_val.len() as nat - kV as nat)
              {
                  if kX < X_crd.len() && kV < v_crd.len() {
                      if X_crd[kX] == v_crd[kV] {
                          sum_result = sum_result + X_val[kX] * v_val[kV];
                          kX = kX + 1;
                          kV = kV + 1;
                      } else if X_crd[kX] < v_crd[kV] {
                          kX = kX + 1;
                      } else {
                          kV = kV + 1;
                      }
                  } else {
                      break;
                  }
              }
              sum_result
          } else {
              0
          };
  
          result.push(sum_val);
          if k < X_crd1.len() && X_crd1[k] == i as nat {
              k = k + 1;
          }
          i = i + 1;
      }
      result
  }

vc-postamble: |-
  fn main() {}
  
  }

