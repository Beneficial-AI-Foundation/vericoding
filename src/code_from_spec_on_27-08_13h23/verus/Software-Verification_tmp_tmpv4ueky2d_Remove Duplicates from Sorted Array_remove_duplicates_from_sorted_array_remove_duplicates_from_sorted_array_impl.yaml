vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Helper predicate
  spec fn is_sorted(nums: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]
  }
  
  spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]
  }

vc-helpers: |-
  spec fn count_distinct(nums: Seq<int>, i: int) -> int
      decreases i
  {
      if i <= 0 {
          0
      } else if i == 1 {
          1
      } else {
          let prev_count = count_distinct(nums, i - 1);
          if nums[i - 1] == nums[i - 2] {
              prev_count
          } else {
              prev_count + 1
          }
      }
  }
  
  proof fn lemma_contains_preservation(nums: Seq<int>, result: Seq<int>, i: int, k: int)
      requires
          0 <= i <= nums.len(),
          result.len() <= i,
          is_sorted(nums),
          forall|j: int| 0 <= j < i ==> #![trigger nums[j], result[j]] (j == 0 || nums[j] != nums[j - 1]) ==> result.contains(nums[j]),
          forall|j: int| 0 <= j < result.len() ==> #![trigger result[j]] result[j] == nums[j],
          !result.contains(nums[k]),
          0 <= k < i,
      ensures
          !nums.subrange(0, i).contains(nums[k]),
  {
      if k < i {
          if k == 0 || nums[k] != nums[k - 1] {
              assert(result.contains(nums[k])); // contradiction with !result.contains(nums[k])
          } else {
              lemma_contains_preservation(nums, result, k, k - 1);
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)
      requires 
          is_sorted(nums),
          1 <= nums.len() <= 30000,
          forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() ==> -100 <= nums[i] <= 100,
      ensures 
          is_sorted_and_distinct(result),
          forall|i: int| #![trigger nums.contains(i)] nums.contains(i) <==> result.contains(i),
  // </vc-spec>

vc-code: |-
  fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)
      requires
          is_sorted(nums),
          1 <= nums.len() <= 30000,
          forall|i: int| #![trigger nums[i]] 0 <= i < nums.len() ==> -100 <= nums[i] <= 100,
      ensures
          is_sorted_and_distinct(result),
          forall|i: int| #![trigger nums.contains(i)] nums.contains(i) <==> result.contains(i),
  {
      let mut result: Vec<int> = Vec::new();
      let mut i: usize = 0;
  
      while i < nums.len()
          invariant
              i <= nums.len(),
              result.len() <= i,
              forall|j: int| 0 <= j < result.len() ==> #![trigger result[j]] result[j] == nums[j],
              forall|j: int| 0 <= j < i ==> #![trigger nums[j]] (j == 0 || nums[j] != nums[j - 1]) ==> result.contains(nums[j]),
              is_sorted_and_distinct(result@),
      {
          if i == 0 || nums[i] != nums[i - 1] {
              result.push(nums[i]);
          }
          i = i + 1;
      }
  
      proof {
          let result_seq = result@;
          assert forall|i: int| #![trigger nums.contains(i)] nums.contains(i) implies result_seq.contains(i) by {
              let idx = choose|idx: int| 0 <= idx < nums.len() && nums[idx] == i;
              if idx == 0 || nums[idx] != nums[idx - 1] {
                  assert(result_seq.contains(nums[idx]));
              } else {
                  assert(nums.subrange(0, idx + 1).contains(nums[idx]));
              }
          };
  
          assert forall|i: int| #![trigger result_seq.contains(i)] result_seq.contains(i) implies nums.contains(i) by {
              let idx = choose|idx: int| 0 <= idx < result_seq.len() && result_seq[idx] == i;
              assert(nums[idx] == i);
              assert(nums.contains(i));
          };
      }
  
      result@
  }

vc-postamble: |-
  
  fn main() {}
  
  }

