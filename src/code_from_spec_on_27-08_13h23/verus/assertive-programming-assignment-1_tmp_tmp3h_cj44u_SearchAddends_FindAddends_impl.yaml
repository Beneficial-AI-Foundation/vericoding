vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted(q: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]
  }
  
  spec fn has_addends(q: Seq<int>, x: int) -> bool {
      exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x
  }
  
  spec fn is_valid_index<T>(q: Seq<T>, i: nat) -> bool {
      0 <= i < q.len()
  }
  
  spec fn are_ordered_indices<T>(q: Seq<T>, i: nat, j: nat) -> bool {
      0 <= i < j < q.len()
  }
  
  spec fn are_addends_indices(q: Seq<int>, x: int, i: nat, j: nat) -> bool
      recommends is_valid_index(q, i) && is_valid_index(q, j)
  {
      q[i as int] + q[j as int] == x
  }
  
  spec fn has_addends_in_indices_range(q: Seq<int>, x: int, i: nat, j: nat) -> bool
      recommends are_ordered_indices(q, i, j)
  {
      has_addends(q.subrange(i as int, (j + 1) as int), x)
  }
  
  spec fn loop_inv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {
      are_ordered_indices(q, i, j) &&
      has_addends_in_indices_range(q, x, i, j) &&
      are_addends_indices(q, sum, i, j)
  }

vc-helpers: |-
  proof fn lemma_subrange_has_addends(q: Seq<int>, x: int, i: nat, j: nat, k1: int, k2: int)
      requires
          are_ordered_indices(q, i, j),
          0 <= k1 < k2 < q.subrange(i as int, (j + 1) as int).len(),
          q.subrange(i as int, (j + 1) as int)[k1] + q.subrange(i as int, (j + 1) as int)[k2] == x,
      ensures
          exists|idx1: int, idx2: int| i <= idx1 < idx2 <= j && q[idx1] + q[idx2] == x,
  {
      let idx1 = i + k1;
      let idx2 = i + k2;
      assert(idx1 < idx2);
      assert(idx1 >= i);
      assert(idx2 <= j);
      assert(q[idx1] == q.subrange(i as int, (j + 1) as int)[k1]);
      assert(q[idx2] == q.subrange(i as int, (j + 1) as int)[k2]);
      assert(q[idx1] + q[idx2] == x);
  }

vc-spec: |-
  // <vc-spec>
  fn find_addends(q: Seq<int>, x: int) -> (result: (usize, usize))
      requires sorted(q) && has_addends(q, x)
      ensures ({
          let (i, j) = result;
          i < j < q.len() && q[i as int] + q[j as int] == x
      })
  // </vc-spec>

vc-code: |-
  fn find_addends(q: Seq<int>, x: int) -> (result: (usize, usize))
      requires sorted(q) && has_addends(q, x)
      ensures ({
          let (i, j) = result;
          i < j < q.len() && q[i as int] + q[j as int] == x
      })
  {
      let mut i: usize = 0;
      let mut j: usize = q.len() - 1;
  
      while i < j
          invariant
              0 <= i < j < q.len(),
              has_addends_in_indices_range(q, x, i as nat, j as nat),
      {
          let sum = q[i as int] + q[j as int];
          if sum == x {
              return (i, j);
          } else if sum < x {
              i = i + 1;
          } else {
              j = j - 1;
          }
      }
      assert(false); // This line should be unreachable due to the invariant and requires
      (0, 0)
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

