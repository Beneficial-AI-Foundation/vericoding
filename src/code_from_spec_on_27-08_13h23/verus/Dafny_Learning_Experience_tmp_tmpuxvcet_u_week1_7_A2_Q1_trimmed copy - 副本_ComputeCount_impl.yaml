vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn count(hi: nat, s: Seq<int>) -> int
      recommends 0 <= hi <= s.len()
      decreases hi
  {
      if hi == 0 {
          0
      } else if s[hi-1] % 2 == 0 {
          1 + count((hi-1) as nat, s)
      } else {
          count((hi-1) as nat, s)
      }
  }

vc-helpers: |-
  proof fn count_decreases(hi: nat, s: Seq<int>)
      requires 0 <= hi <= s.len()
      ensures count(hi, s) == if hi == 0 { 0 } else if s[hi-1] % 2 == 0 { 1 + count((hi-1) as nat, s) } else { count((hi-1) as nat, s) }
      decreases hi
  {
      if hi == 0 {
      } else {
          count_decreases((hi-1) as nat, s);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn compute_count(count_index: usize, a: Seq<int>, b: &mut Vec<int>) -> (p: usize)
      requires count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len())
      ensures p == count(count_index as nat, a)
  // </vc-spec>

vc-code: |-
  fn compute_count(count_index: usize, a: Seq<int>, b: &mut Vec<int>) -> (p: usize)
      requires count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len())
      ensures p == count(count_index as nat, a)
  {
      let mut count_val = 0;
      let mut i = 0;
  
      while i < count_index
          invariant
              0 <= i <= count_index,
              count_val == count(i as nat, a)
      {
          if a[i] % 2 == 0 {
              count_val = count_val + 1;
          }
          i = i + 1;
      }
  
      count_val
  }

vc-postamble: |-
  fn main() {
  }
  
  }

