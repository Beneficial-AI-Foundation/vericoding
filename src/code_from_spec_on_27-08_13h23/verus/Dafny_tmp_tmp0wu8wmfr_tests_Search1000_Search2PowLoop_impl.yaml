vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Author: Snorri Agnarsson, snorri@hi.is
  
  // Search1000 is a Verus version of a function shown
  // by Jon Bentley in his old Programming Pearls
  // column in CACM.  
  
  // Is2Pow(n) is true iff n==2^k for some k>=0.
  spec fn is_2_pow(n: int) -> bool
      decreases n
  {
      if n < 1 {
          false
      } else if n == 1 {
          true
      } else {
          n % 2 == 0 && is_2_pow(n / 2)
      }
  }
  
  // This method is a binary search that only works for array
  // segments of size n == 2^k-1 for some k>=0.

vc-helpers: |-
  // Helper lemma to prove properties about power of 2
  proof fn lemma_2_pow_div(n: int)
      requires
          n > 1,
          is_2_pow(n),
      ensures
          is_2_pow(n / 2),
      decreases n
  {
      if n > 2 {
          lemma_2_pow_div(n / 2);
      }
  }
  
  // Helper lemma to ensure bounds for mid calculation
  proof fn lemma_mid_bounds(i: usize, k: usize, half: usize, n: usize, len: usize)
      requires
          0 <= i,
          0 <= k,
          0 <= half,
          i <= k <= i + n,
          half <= m,
          k + half <= i + n,
          i + n <= len,
      ensures
          0 <= k + half <= len,
  {
      assert(0 <= k);
      assert(0 <= half);
      assert(0 <= k + half);
      assert(k + half <= i + n);
      assert(i + n <= len);
  }

vc-spec: |-
  // <vc-spec>
  fn search_2_pow_loop(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)
      requires
          i <= i + n <= a.len(),
          forall|p: int, q: int| i <= p < q < (i + n) && 0 <= p < a.len() && 0 <= q < a.len() ==> 
              a@[p] <= a@[q],
          is_2_pow((n + 1) as int),
      ensures
          i <= k <= i + n,
          forall|r: int| i <= r < k && 0 <= r < a.len() ==> a@[r] < x,
          forall|r: int| k <= r < (i + n) && 0 <= r < a.len() ==> a@[r] >= x,
  // </vc-spec>

vc-code: |-
  {
      let mut k: usize = i;
      let mut m: usize = n;
  
      while m > 0
          invariant
              i <= k <= i + n,
              k + m <= i + n,
              m <= n,
              forall|r: int| i <= r < k && 0 <= r < a.len() ==> a@[r] < x,
              forall|r: int| k + m <= r < i + n && 0 <= r < a.len() ==> a@[r] >= x,
              is_2_pow((m + 1) as int) || m == 0,
          decreases m
      {
          let half = m / 2;
          let mid = k + half;
          proof {
              lemma_2_pow_div((m + 1) as int);
              lemma_mid_bounds(i, k, half, n, a.len());
          }
          if a[mid] < x {
              k = mid + 1;
          }
          m = half;
      }
      k
  }

vc-postamble: |-
  // This method is a binary search that only works for array
  // segments of size n == 2^k-1 for some k>=0.
  
  fn main() {}
  
  }

