vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted_seg(a: Seq<int>, i: int, j: int) -> bool
      recommends 0 <= i <= j <= a.len()
  {
      forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]
  }

vc-helpers: |-
  spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool {
      a.to_multiset() == b.to_multiset()
  }
  
  proof fn lemma_swap_preserves_multiset(a: Seq<int>, i: int, j: int)
      requires
          0 <= i < a.len(),
          0 <= j < a.len(),
      ensures
          is_permutation(a, a.update(i, a[j]).update(j, a[i])),
  {
      assert(a.to_multiset() == a.update(i, a[j]).update(j, a[i]).to_multiset());
  }
  
  proof fn lemma_swap_preserves_other_indices(a: Seq<int>, i: int, j: int, start: int, end: int)
      requires
          0 <= start <= end <= a.len(),
          0 <= i < a.len(),
          0 <= j < a.len(),
      ensures
          forall|k: int| start <= k < end && k != i && k != j ==> a[k] == a.update(i, a[j]).update(j, a[i])[k],
  {
      assert(forall|k: int| start <= k < end && k != i && k != j ==> a[k] == a.update(i, a[j]).update(j, a[i])[k]);
  }
  
  proof fn lemma_bubble_pass_sorted(a: Seq<int>, c: int, f: int, i: int)
      requires
          0 <= c <= f <= a.len(),
          c <= i < f,
          forall|j: int| c <= j < i ==> a[j] <= a[j+1],
      ensures
          forall|j: int| c <= j < i ==> a[j] <= a[i],
  {
      if i > c {
          assert(a[i-1] <= a[i]);
          lemma_bubble_pass_sorted(a, c, f, i-1);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn bubble_sort(a: &mut Vec<int>, c: usize, f: usize)
      requires 
          0 <= c <= f <= old(a).len(),
      ensures 
          sorted_seg(a@, c as int, f as int),
          a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
          a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
          a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),
  // </vc-spec>

vc-code: |-
  fn bubble_sort(a: &mut Vec<int>, c: usize, f: usize)
      requires 
          0 <= c <= f <= old(a).len(),
      ensures 
          sorted_seg(a@, c as int, f as int),
          a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
          a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
          a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),
  {
      let mut i: usize = f;
      while i > c
          invariant
              c <= i <= f,
              sorted_seg(a@, i as int, f as int),
              a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
              a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
              a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),
          decreases i,
      {
          let mut j: usize = c;
          while j < i
              invariant
                  c <= j <= i <= f,
                  sorted_seg(a@, i as int, f as int),
                  forall|k: int| c as int <= k < j as int ==> a@[k] <= a@[k+1],
                  a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
                  a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
                  a@.subrange(f as int, a@.len() as int) == old(a)@.subrange(f as int, old(a)@.len() as int),
              decreases i - j,
          {
              if a[j] > a[j + 1] {
                  let tmp = a[j];
                  a.set(j, a[j + 1]);
                  a.set(j + 1, tmp);
              }
              j = j + 1;
          }
          i = i - 1;
      }
  }

vc-postamble: |-
  fn main() {
  }
  
  }

