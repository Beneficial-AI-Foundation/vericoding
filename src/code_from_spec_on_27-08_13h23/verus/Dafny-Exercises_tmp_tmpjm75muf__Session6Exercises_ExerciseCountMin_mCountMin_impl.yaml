vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn min(v: Seq<int>, i: int) -> int
      decreases i
  {
      if 1 <= i <= v.len() {
          if i == 1 {
              v[0]
          } else if v[i-1] <= min(v, i-1) {
              v[i-1]
          } else {
              min(v, i-1)
          }
      } else {
          0  // dummy value for invalid inputs
      }
  }
  
  proof fn min_property(v: Seq<int>, i: int)
      requires 1 <= i <= v.len()
      ensures forall|k: int| 0 <= k < i ==> v[k] >= min(v, i)
      decreases i
  {
      if i > 1 {
          min_property(v, i-1);
      }
  }
  
  spec fn count_min(v: Seq<int>, x: int, i: int) -> int
      decreases i
  {
      if 0 <= i <= v.len() {
          if i == 0 {
              0
          } else if v[i-1] == x {
              1 + count_min(v, x, i-1)
          } else {
              count_min(v, x, i-1)
          }
      } else {
          0  // dummy value for invalid inputs
      }
  }
  
  proof fn count_min_property(v: Seq<int>, x: int, i: int)
      requires 0 <= i <= v.len()
      ensures !(exists|k: int| 0 <= k < i && v[k] == x) ==> count_min(v, x, i) == 0
      decreases i
  {
      if i > 0 {
          count_min_property(v, x, i-1);
      }
  }

vc-helpers: |-
  proof fn min_property_stronger(v: Seq<int>, i: int)
      requires 1 <= i <= v.len()
      ensures forall|k: int| 0 <= k < i ==> v[k] >= min(v, i)
      decreases i
  {
      if i > 1 {
          min_property_stronger(v, i-1);
      }
  }
  
  proof fn count_min_correctness(v: Seq<int>, x: int, i: int)
      requires 0 <= i <= v.len()
      ensures count_min(v, x, i) == (seq_filter_count(|k: int| k == x, v.subrange(0, i as int64)))
      decreases i
  {
      if i > 0 {
          count_min_correctness(v, x, i-1);
          reveal_with_fuel(seq_filter_count, 2);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn m_count_min(v: &Vec<i32>) -> (c: i32)
      requires v.len() > 0
      ensures c == count_min(v@.map_values(|x: i32| x as int), 
                            min(v@.map_values(|x: i32| x as int), v.len() as int), 
                            v.len() as int)
      //Implement and verify an O(v.len()) algorithm
  // </vc-spec>

vc-code: |-
  fn m_count_min(v: &Vec<i32>) -> (c: i32)
      requires v.len() > 0
      ensures c == count_min(v@.map_values(|x: i32| x as int), 
                            min(v@.map_values(|x: i32| x as int), v.len() as int), 
                            v.len() as int)
  {
      let mut min_val: i32 = v[0];
      let mut count: i32 = 1;
      let mut i: usize = 1;
  
      while i < v.len()
          invariant
              1 <= i <= v.len(),
              min_val as int == min(v@.map_values(|x: i32| x as int), i as int),
              count as int == count_min(v@.map_values(|x: i32| x as int), min_val as int, i as int)
      {
          if v[i] < min_val {
              min_val = v[i];
              count = 1;
          } else if v[i] == min_val {
              count = count + 1;
          }
          i = i + 1;
      }
  
      proof {
          min_property_stronger(v@.map_values(|x: i32| x as int), v.len() as int);
          count_min_correctness(v@.map_values(|x: i32| x as int), min_val as int, v.len() as int);
      }
  
      count
  }

vc-postamble: |-
  fn main() {
  }
  
  }

