vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  // Helper function to check if a single node satisfies the min-heap property
  proof fn check_node_min_heap(a: &Vec<i32>, i: int)
      requires
          0 <= i < (a.len() as int) / 2,
      ensures
          {
              let left_idx = 2 * i + 1;
              let right_idx = 2 * i + 2;
              (left_idx < a.len() as int ==> a[i] <= a[left_idx]) &&
              (right_idx < a.len() as int ==> a[i] <= a[right_idx])
          }
  {
      // No additional proof needed as the ensures clause is directly checkable
  }

vc-spec: |-
  // <vc-spec>
  fn is_min_heap(a: &Vec<i32>) -> (result: bool)
      requires a.len() > 0
      ensures 
          result ==> forall|i: int| 0 <= i < (a.len() as int) / 2 ==> {
              let left_idx = 2 * i + 1;
              let right_idx = 2 * i + 2;
              (left_idx < a.len()) ==> (#[trigger] a[i as int] <= a[left_idx]) &&
              (right_idx < a.len()) ==> (a[i as int] <= a[right_idx])
          },
          !result ==> exists|i: int| 0 <= i < (a.len() as int) / 2 && {
              let left_idx = 2 * i + 1;
              let right_idx = 2 * i + 2;
              (#[trigger] a[i as int] > a[left_idx] && left_idx < a.len()) ||
              (a[i as int] > a[right_idx] && right_idx < a.len())
          }
  // </vc-spec>

vc-code: |-
  fn is_min_heap(a: &Vec<i32>) -> (result: bool)
      requires a.len() > 0
      ensures 
          result ==> forall|i: int| 0 <= i < (a.len() as int) / 2 ==> {
              let left_idx = 2 * i + 1;
              let right_idx = 2 * i + 2;
              (left_idx < a.len() as int ==> #[trigger] a[i] <= a[left_idx]) &&
              (right_idx < a.len() as int ==> a[i] <= a[right_idx])
          },
          !result ==> exists|i: int| 0 <= i < (a.len() as int) / 2 && {
              let left_idx = 2 * i + 1;
              let right_idx = 2 * i + 2;
              (#[trigger] a[i] > a[left_idx] && left_idx < a.len() as int) ||
              (a[i] > a[right_idx] && right_idx < a.len() as int)
          }
  {
      let mut is_heap = true;
      let len = a.len() as int;
      let mut i = 0;
  
      while i < len / 2
          invariant
              0 <= i <= len / 2,
              is_heap ==> forall|j: int| 0 <= j < i ==> {
                  let left_idx = 2 * j + 1;
                  let right_idx = 2 * j + 2;
                  (left_idx < len ==> #[trigger] a[j] <= a[left_idx]) &&
                  (right_idx < len ==> a[j] <= a[right_idx])
              },
              !is_heap ==> exists|j: int| 0 <= j < i && {
                  let left_idx = 2 * j + 1;
                  let right_idx = 2 * j + 2;
                  (#[trigger] a[j] > a[left_idx] && left_idx < len) ||
                  (a[j] > a[right_idx] && right_idx < len)
              }
      {
          let left_idx = 2 * i + 1;
          let right_idx = 2 * i + 2;
  
          if left_idx < len && a[i] > a[left_idx] {
              is_heap = false;
              break;
          }
          if right_idx < len && a[i] > a[right_idx] {
              is_heap = false;
              break;
          }
          i = i + 1;
      }
  
      is_heap
  }

vc-postamble: |-
  fn main() {}
  
  }

