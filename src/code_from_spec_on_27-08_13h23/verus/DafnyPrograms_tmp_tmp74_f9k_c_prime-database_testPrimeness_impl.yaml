vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // predicate for primeness
  spec fn prime(n: nat) -> bool {
      n > 1 && (forall|nr: nat| 1 < nr < n ==> #[trigger] (n % nr) != 0)
  }
  
  #[derive(PartialEq, Eq)]
  enum Answer {
      Yes,
      No,
      Unknown,
  }
  
  // the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number
  // is not in the database it returns Unknown
  struct PrimeMap {
      database: Ghost<Map<nat, bool>>,
  }
  
  impl PrimeMap {
      // the valid invariant of the class
      spec fn valid(&self) -> bool {
          forall|i: nat| self.database@.dom().contains(i) ==> (self.database@[i] == prime(i))
      }
  
      // the constructor
      fn new() -> (result: PrimeMap)
          ensures 
              result.database@ === Map::empty(),
              result.valid(),
      {
          PrimeMap {
              database: Ghost(Map::empty())
          }
      }
  
      // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,
      // or with Unknown when it's not in the databse
      fn is_prime(&self, n: nat) -> (answer: Answer)
          requires self.valid(),
          ensures 
              self.database@.dom().contains(n) && prime(n) <==> answer == Answer::Yes,
              self.database@.dom().contains(n) && !prime(n) <==> answer == Answer::No,
              !self.database@.dom().contains(n) <==> answer == Answer::Unknown,
      {
          assume(false);
          Answer::Unknown
      }
  
      // method to test whether a number is prime, returns bool
  
  }

vc-helpers: |-
  // Helper function to check divisibility up to sqrt(n)
  spec fn has_divisor(n: nat, start: nat, end: nat) -> bool {
      exists|nr: nat| start <= nr <= end && #[trigger] (n % nr) == 0
  }
  
  proof fn prove_no_divisors(n: nat, start: nat, end: nat)
      requires n > 1, start <= end, !has_divisor(n, start, end),
      ensures forall|nr: nat| start <= nr <= end ==> #[trigger] (n % nr) != 0,
  {
      assert forall|nr: nat| start <= nr <= end implies #[trigger] (n % nr) != 0 by {
          if (n % nr) == 0 {
              assert(has_divisor(n, start, end)); // contradiction
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn test_primeness(n: nat) -> (result: bool) 
        requires n >= 0,
        ensures result <==> prime(n),
  // </vc-spec>

vc-code: |-
  fn test_primeness(n: nat) -> (result: bool)
      requires n >= 0,
      ensures result <==> prime(n),
  {
      if n <= 1 {
          return false;
      }
  
      let mut i: nat = 2;
      let upper_limit: nat = (n / 2) + 1; // rough approximation of sqrt(n)
  
      while i < n && i < upper_limit
          invariant
              2 <= i <= n,
              i <= upper_limit,
              !has_divisor(n, 2, i-1),
          decreases n - i,
      {
          if (n % i) == 0 {
              return false;
          }
          i = i + 1;
      }
  
      proof {
          if i >= n || i >= upper_limit {
              prove_no_divisors(n, 2, n-1);
          }
      }
  
      true
  }

vc-postamble: |-
  fn main() {}
  
  }

