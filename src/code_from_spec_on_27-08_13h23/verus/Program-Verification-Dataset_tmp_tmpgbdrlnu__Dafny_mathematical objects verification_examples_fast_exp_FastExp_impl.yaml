vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(s: Seq<int>, i: nat) -> int
      recommends i <= s.len()
      decreases i
  {
      if i == 0 { 0 } else { sum(s, (i - 1) as nat) + s[i - 1] }
  }
  
  spec fn exp(b: nat, n: nat) -> nat
      decreases n
  {
      if n == 0 { 1nat } else { b * exp(b, (n - 1) as nat) }
  }
  
  spec fn bits(n: nat) -> Seq<bool>
      decreases n
  {
      if n == 0 {
          seq![]
      } else {
          seq![n % 2 != 0].add(bits((n / 2) as nat))
      }
  }
  
  spec fn from_bits(s: Seq<bool>) -> nat
      decreases s.len()
  {
      if s.len() == 0 {
          0nat
      } else {
          (if s[0] { 1nat } else { 0nat }) + 2nat * from_bits(s.subrange(1, s.len() as int))
      }
  }

vc-helpers: |-
  proof fn lemma_from_bits_bits(n: nat)
      ensures from_bits(bits(n)) == n
      decreases n
  {
      if n == 0 {
          assert(from_bits(bits(0)) == from_bits(seq![]) == 0);
      } else {
          let b_seq = bits(n);
          let bit = n % 2 != 0;
          let next_n = (n / 2) as nat;
          lemma_from_bits_bits(next_n);
          assert(b_seq == seq![bit].add(bits(next_n)));
          assert(from_bits(b_seq) == (if bit { 1nat } else { 0nat }) + 2nat * from_bits(bits(next_n)));
          assert(from_bits(bits(next_n)) == next_n);
          assert(from_bits(b_seq) == (if bit { 1nat } else { 0nat }) + 2nat * next_n);
          if bit {
              assert(n % 2 == 1);
              assert(n == 2 * next_n + 1);
              assert(from_bits(b_seq) == 1 + 2 * next_n);
              assert(from_bits(b_seq) == n);
          } else {
              assert(n % 2 == 0);
              assert(n == 2 * next_n);
              assert(from_bits(b_seq) == 0 + 2 * next_n);
              assert(from_bits(b_seq) == n);
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn fast_exp(b: u32, n: u32) -> (r: u32)
      ensures r == exp(b as nat, n as nat)
  // </vc-spec>

vc-code: |-
  fn fast_exp(b: u32, n: u32) -> (r: u32)
      ensures r == exp(b as nat, n as nat)
  {
      let mut result = 1u32;
      let mut base = b;
      let mut exponent = n;
      while exponent > 0
          invariant
              result as nat * exp(base as nat, exponent as nat) == exp(b as nat, n as nat)
      {
          if exponent % 2 == 1 {
              result = result * base;
          }
          base = base * base;
          exponent = exponent / 2;
      }
      result
  }

vc-postamble: |-
  fn main() {}
  
  }

