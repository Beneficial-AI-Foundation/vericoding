vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn quick_sorted(seq: Seq<int>) -> bool {
      forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < seq.len() ==> seq[idx_1] <= seq[idx_2]
  }
  
  #[verifier::exec_allows_no_decreases_clause]
  fn threshold(thres: int, seq: Seq<int>) -> (res: (Seq<int>, Seq<int>))
      ensures
          (forall|x: int| res.0.contains(x) ==> x <= thres) && (forall|x: int| res.1.contains(x) ==> x >= thres) &&
          res.0.len() + res.1.len() == seq.len() &&
          res.0.to_multiset().add(res.1.to_multiset()) == seq.to_multiset()
  {
      assume(false);
      loop {}
  }

vc-helpers: |-
  spec fn partition(seq: Seq<int>, pivot: int) -> (Seq<int>, Seq<int>)
      ensures
          (forall|x: int| result.0.contains(x) ==> x <= pivot) &&
          (forall|x: int| result.1.contains(x) ==> x > pivot) &&
          result.0.len() + result.1.len() == seq.len() &&
          result.0.to_multiset().add(result.1.to_multiset()) == seq.to_multiset()
  {
      let mut left: Seq<int> = Seq::empty();
      let mut right: Seq<int> = Seq::empty();
      let mut i: int = 0;
      while i < seq.len()
          invariant
              0 <= i <= seq.len(),
              (forall|x: int| left.contains(x) ==> x <= pivot),
              (forall|x: int| right.contains(x) ==> x > pivot),
              left.len() + right.len() == i,
              left.to_multiset().add(right.to_multiset()) == seq.subrange(0, i).to_multiset()
      {
          if seq[i] <= pivot {
              left = left.push(seq[i]);
          } else {
              right = right.push(seq[i]);
          }
          i = i + 1;
      }
      (left, right)
  }
  
  proof fn lemma_seq_concat_multiset(left: Seq<int>, right: Seq<int>)
      ensures
          left.to_multiset().add(right.to_multiset()) == left.add(right).to_multiset()
  {
  }

vc-spec: |-
  // <vc-spec>
  fn quick_sort(seq: Seq<int>) -> (res: Seq<int>)
      ensures seq.to_multiset() == res.to_multiset()
      decreases seq.len()
  // </vc-spec>

vc-code: |-
  fn quick_sort(seq: Seq<int>) -> (res: Seq<int>)
      ensures
          seq.to_multiset() == res.to_multiset(),
          quick_sorted(res)
      decreases seq.len()
  {
      if seq.len() <= 1 {
          seq
      } else {
          let pivot = seq[0];
          let (left, right) = partition(seq.subrange(1, seq.len() as int), pivot);
          let sorted_left = quick_sort(left);
          let sorted_right = quick_sort(right);
          let result = sorted_left.push(pivot).add(sorted_right);
          proof {
              lemma_seq_concat_multiset(sorted_left.push(pivot), sorted_right);
          }
          result
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

