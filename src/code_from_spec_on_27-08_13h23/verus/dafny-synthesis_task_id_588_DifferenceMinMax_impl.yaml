vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // The order of the recursion in these two functions
  // must match the order of the iteration in the algorithm above
  spec fn min(a: Seq<int>) -> int
      recommends a.len() > 0
      decreases a.len() when a.len() > 0
  {
      if a.len() == 1 {
          a[0]
      } else {
          let prefix = a.take(a.len() - 1);
          let min_prefix = min(prefix);
          if a[a.len() - 1] <= min_prefix {
              a[a.len() - 1]
          } else {
              min_prefix
          }
      }
  }
  
  spec fn max(a: Seq<int>) -> int
      recommends a.len() > 0  
      decreases a.len() when a.len() > 0
  {
      if a.len() == 1 {
          a[0]
      } else {
          let prefix = a.take(a.len() - 1);
          let max_prefix = max(prefix);
          if a[a.len() - 1] >= max_prefix {
              a[a.len() - 1]
          } else {
              max_prefix
          }
      }
  }

vc-helpers: |-
  proof fn min_correct(a: Seq<int>)
      requires a.len() > 0
      ensures min(a) == a.fold_left(a[0], |acc: int, x: int| if x < acc { x } else { acc })
      decreases a.len()
  {
      if a.len() == 1 {
          assert(a[0] == a.fold_left(a[0], |acc: int, x: int| if x < acc { x } else { acc }));
      } else {
          let prefix = a.take(a.len() - 1);
          min_correct(prefix);
          let min_prefix = min(prefix);
          let last = a[a.len() - 1];
          if last <= min_prefix {
              assert(last == a.fold_left(a[0], |acc: int, x: int| if x < acc { x } else { acc }));
          } else {
              assert(min_prefix == a.fold_left(a[0], |acc: int, x: int| if x < acc { x } else { acc }));
          }
      }
  }
  
  proof fn max_correct(a: Seq<int>)
      requires a.len() > 0
      ensures max(a) == a.fold_left(a[0], |acc: int, x: int| if x > acc { x } else { acc })
      decreases a.len()
  {
      if a.len() == 1 {
          assert(a[0] == a.fold_left(a[0], |acc: int, x: int| if x > acc { x } else { acc }));
      } else {
          let prefix = a.take(a.len() - 1);
          max_correct(prefix);
          let max_prefix = max(prefix);
          let last = a[a.len() - 1];
          if last >= max_prefix {
              assert(last == a.fold_left(a[0], |acc: int, x: int| if x > acc { x } else { acc }));
          } else {
              assert(max_prefix == a.fold_left(a[0], |acc: int, x: int| if x > acc { x } else { acc }));
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn difference_min_max(a: &[i32]) -> (diff: i32)
      requires a.len() > 0
      ensures diff == max(a@.map(|i, x| x as int)) - min(a@.map(|i, x| x as int))
  // </vc-spec>

vc-code: |-
  fn difference_min_max(a: &[i32]) -> (diff: i32)
      requires a.len() > 0
      ensures diff == max(a@.map(|i, x| x as int)) - min(a@.map(|i, x| x as int))
  {
      let mut min_val = a[0];
      let mut max_val = a[0];
      let mut i = 0;
  
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              min_val == a@.take(i as int).fold_left(a[0] as int, |acc: int, x: int| if x < acc { x } else { acc }),
              max_val == a@.take(i as int).fold_left(a[0] as int, |acc: int, x: int| if x > acc { x } else { acc })
      {
          if a[i] < min_val {
              min_val = a[i];
          }
          if a[i] > max_val {
              max_val = a[i];
          }
          i = i + 1;
      }
  
      proof {
          min_correct(a@.map(|i, x| x as int));
          max_correct(a@.map(|i, x| x as int));
      }
  
      max_val - min_val
  }

vc-postamble: |-
  
  fn main() {}
  
  }

