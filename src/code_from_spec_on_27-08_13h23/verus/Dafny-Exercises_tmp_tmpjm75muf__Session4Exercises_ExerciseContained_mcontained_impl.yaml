vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn strict_sorted(s: Seq<i32>) -> bool {
      forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] < s[w]
  }

vc-helpers: |-
  spec fn contains_subrange(s: Seq<i32>, sub: Seq<i32>, start: int, end: int) -> bool {
      forall|k: int| 0 <= k < sub.len() ==> s.subrange(start, end).contains(sub[k])
  }

vc-spec: |-
  // <vc-spec>
  fn mcontained(v: &[i32], w: &[i32], n: usize, m: usize) -> (b: bool)
  //Specify and implement an O(m+n) algorithm that returns b
  //v and w are strictly increasing ordered arrays
  //b is true iff the first n elements of v are contained in the first m elements of w
      requires 
          n <= m,
          n >= 0,
          strict_sorted(v@),
          strict_sorted(w@),
          v@.len() >= n,
          w@.len() >= m,
      ensures
          b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])
  // </vc-spec>

vc-code: |-
  fn mcontained(v: &[i32], w: &[i32], n: usize, m: usize) -> (b: bool)
      requires 
          n <= m,
          n >= 0,
          strict_sorted(v@),
          strict_sorted(w@),
          v@.len() >= n,
          w@.len() >= m,
      ensures
          b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])
  {
      let mut i: usize = 0;
      let mut j: usize = 0;
      let mut found_all = true;
  
      while i < n && j < m
          invariant
              0 <= i <= n,
              0 <= j <= m,
              forall|k: int| 0 <= k < i ==> w@.subrange(0, m as int).contains(v@[k]),
              i < n ==> j <= m
      {
          if v[i] == w[j] {
              i = i + 1;
              j = j + 1;
          } else {
              j = j + 1;
          }
      }
  
      if i < n {
          found_all = false;
      }
  
      found_all
  }

vc-postamble: |-
  fn main() {}
  
  }

