vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  // Helper function to check if a slice is sorted
  pub fn is_sorted<T: Ord>(arr: &[T]) -> bool {
      forall|i: int, j: int| 0 <= i < j < arr.len() as int ==> arr[i] <= arr[j]
  }
  
  // Helper function to merge two sorted arrays for finding median
  proof fn merged_array_median(a: &[i32], b: &[i32])
      requires
          a.len() == b.len(),
          a.len() > 0,
          is_sorted(a),
          is_sorted(b),
      ensures
          true,
  {
      // Proof logic can be added if needed for complex median properties
  }

vc-spec: |-
  // <vc-spec>
  fn find_median(a: &[i32], b: &[i32]) -> (median: i32)
      requires 
          a.len() == b.len(),
          a.len() > 0,
          forall|i: int| #[trigger] a[i] == a[i] ==> (0 <= i < (a.len() - 1) as int ==> a[i] <= a[add(i, 1)]),
          forall|i: int| #[trigger] b[i] == b[i] ==> (0 <= i < (b.len() - 1) as int ==> b[i] <= b[add(i, 1)]),
      ensures 
          median as int == if a.len() % 2 == 0 { 
              (a[(a.len() / 2 - 1) as int] + b[0int]) / 2 
          } else { 
              a[(a.len() / 2) as int] as int
          }
  // </vc-spec>

vc-code: |-
  fn find_median(a: &[i32], b: &[i32]) -> (median: i32)
      requires 
          a.len() == b.len(),
          a.len() > 0,
          forall|i: int| 0 <= i < (a.len() - 1) as int ==> a[i] <= a[i + 1],
          forall|i: int| 0 <= i < (b.len() - 1) as int ==> b[i] <= b[i + 1],
      ensures 
          median as int == if a.len() % 2 == 0 { 
              (a[(a.len() / 2 - 1) as int] + a[(a.len() / 2) as int]) / 2 
          } else { 
              a[(a.len() / 2) as int] as int
          }
  {
      let n = a.len();
      if n % 2 == 0 {
          let idx1 = (n / 2 - 1) as int;
          let idx2 = (n / 2) as int;
          let val1 = a[idx1];
          let val2 = a[idx2];
          (val1 + val2) / 2
      } else {
          let idx = (n / 2) as int;
          a[idx]
      }
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

