vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn recursive_positive_product(q: Seq<int>) -> int
      decreases q.len()
  {
      if q.len() == 0 {
          1
      } else if q[0] <= 0 {
          recursive_positive_product(q.subrange(1, q.len() as int))
      } else {
          q[0] * recursive_positive_product(q.subrange(1, q.len() as int))
      }
  }
  
  spec fn recursive_count(key: int, q: Seq<int>) -> int
      decreases q.len()
  {
      if q.len() == 0 {
          0
      } else if q[q.len() - 1] == key {
          1 + recursive_count(key, q.subrange(0, q.len() as int - 1))
      } else {
          recursive_count(key, q.subrange(0, q.len() as int - 1))
      }
  }
  
  spec fn county(elem: int, key: int) -> int {
      if elem == key { 1 } else { 0 }
  }
  
  spec fn prody(elem: int) -> int {
      if elem <= 0 { 1 } else { elem }
  }

vc-helpers: |-
  proof fn lemma_recursive_positive_product(q: Seq<int>)
      ensures
          recursive_positive_product(q) == q.fold_left(1, |acc: int, x: int| acc * prody(x))
      decreases q.len()
  {
      if q.len() == 0 {
          assert(recursive_positive_product(q) == 1);
      } else {
          let subseq = q.subrange(1, q.len() as int);
          lemma_recursive_positive_product(subseq);
          if q[0] <= 0 {
              assert(recursive_positive_product(q) == recursive_positive_product(subseq));
          } else {
              assert(recursive_positive_product(q) == q[0] * recursive_positive_product(subseq));
          }
      }
  }
  
  proof fn lemma_recursive_count(key: int, q: Seq<int>)
      ensures
          recursive_count(key, q) == q.fold_left(0, |acc: int, x: int| acc + county(x, key))
      decreases q.len()
  {
      if q.len() == 0 {
          assert(recursive_count(key, q) == 0);
      } else {
          let subseq = q.subrange(0, q.len() as int - 1);
          lemma_recursive_count(key, subseq);
          if q[q.len() - 1] == key {
              assert(recursive_count(key, q) == 1 + recursive_count(key, subseq));
          } else {
              assert(recursive_count(key, q) == recursive_count(key, subseq));
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn prod_and_count(q: &[i32], key: i32) -> (i32, u32)
      ensures |result: (i32, u32)| 
          result.0 == recursive_positive_product(q@.map(|_, x: i32| x as int)) &&
          result.1 == recursive_count(key as int, q@.map(|_, x: i32| x as int)) as u32
  // </vc-spec>

vc-code: |-
  fn prod_and_count(q: &[i32], key: i32) -> (i32, u32)
      ensures |result: (i32, u32)| 
          result.0 == recursive_positive_product(q@.map(|_, x: i32| x as int)) &&
          result.1 == recursive_count(key as int, q@.map(|_, x: i32| x as int)) as u32
  {
      let mut prod: i32 = 1;
      let mut count: u32 = 0;
      let mut i: usize = 0;
  
      while i < q.len()
          invariant
              0 <= i <= q.len(),
              prod == recursive_positive_product(q@.subrange(0, i as int).map(|_, x: i32| x as int)),
              count == recursive_count(key as int, q@.subrange(0, i as int).map(|_, x: i32| x as int)) as u32
      {
          if q[i] > 0 {
              prod = prod * q[i];
          }
          if q[i] == key {
              count = count + 1;
          }
          i = i + 1;
      }
  
      (prod, count)
  }

vc-postamble: |-
  
  fn main() {}
  
  }

