vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Works by dividing the input list into two parts: sorted and unsorted. At the beginning, 
  // the sorted part is empty and the unsorted part contains all the elements.

vc-helpers: |-
  spec fn is_minimum(a: &Vec<i32>, start: int, end: int, min_val: i32) -> bool {
      forall|k: int| start <= k < end ==> a@[k] >= min_val
  }
  
  proof fn lemma_multiset_unchanged_on_swap(a: &Vec<i32>, i: int, j: int, new_a: &Vec<i32>)
      requires
          0 <= i < a.len(),
          0 <= j < a.len(),
          new_a.len() == a.len(),
          new_a@[i] == a@[j],
          new_a@[j] == a@[i],
          forall|k: int| 0 <= k < a.len() && k != i && k != j ==> new_a@[k] == a@[k],
      ensures
          a@.to_multiset() == new_a@.to_multiset(),
  {
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<i32>)
      ensures
          // Ensures the final array is sorted in ascending order
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          // Ensures that the final array has the same elements as the initial array
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  fn selection_sort(a: &mut Vec<i32>)
      ensures
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j],
          a@.to_multiset() == old(a)@.to_multiset(),
  {
      let mut i: usize = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int, l: int| 0 <= k < l < i ==> a@[k] <= a@[l],
              forall|k: int| 0 <= k < i ==> is_minimum(a, k, a.len() as int, a@[k]),
              a@.to_multiset() == old(a)@.to_multiset(),
      {
          let mut min_idx = i;
          let mut j = i + 1;
          while j < a.len()
              invariant
                  0 <= i < a.len(),
                  i <= min_idx < a.len(),
                  i < j <= a.len(),
                  forall|k: int, l: int| 0 <= k < l < i ==> a@[k] <= a@[l],
                  forall|k: int| i <= k < j ==> a@[min_idx] <= a@[k],
                  a@.to_multiset() == old(a)@.to_multiset(),
          {
              if a@[j] < a@[min_idx] {
                  min_idx = j;
              }
              j = j + 1;
          }
          if min_idx != i {
              let a_old = a@;
              let temp = a@[i];
              a.set(i, a@[min_idx]);
              a.set(min_idx, temp);
              proof {
                  lemma_multiset_unchanged_on_swap(&a_old.view(), i as int, min_idx as int, a);
              }
          }
          i = i + 1;
      }
  }

vc-postamble: |-
  fn main() {
  }
  
  }

