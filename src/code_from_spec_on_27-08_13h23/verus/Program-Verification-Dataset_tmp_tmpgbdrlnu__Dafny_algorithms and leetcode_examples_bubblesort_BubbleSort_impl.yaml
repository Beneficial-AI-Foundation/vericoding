vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  //https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny
  spec fn n_choose_2(n: int) -> int
  {
      n * (n - 1) / 2
  }
  
  // sum of all integers in the range [lo, hi)
  // (inclusive of lo, exclusive of hi)
  spec fn sum_range(lo: int, hi: int) -> int
      decreases hi - lo
  {
      if lo >= hi { 0 }
      else { sum_range(lo, hi - 1) + hi - 1 }
  }
  
  // dafny proves this automatically by induction

vc-helpers: |-
  spec fn is_sorted(v: &Vec<i32>) -> bool {
      forall|i: int, j: int| 0 <= i && i < j && j < v.len() ==> v@[i] <= v@[j]
  }
  
  spec fn count_inversions(v: &Vec<i32>) -> int {
      let mut count = 0;
      for i in 0..v.len()
          invariant count <= sum_range(0, i)
      {
          for j in (i + 1)..v.len()
              invariant count <= sum_range(0, i) + sum_range(i + 1, j)
          {
              if v@[i] > v@[j] {
                  count = count + 1;
              }
          }
      }
      count
  }
  
  proof fn inversion_count_bound(v: &Vec<i32>)
      ensures count_inversions(v) <= n_choose_2(v.len() as int)
  {
      let mut i = 0;
      let mut count = 0;
      while i < v.len()
          invariant i <= v.len(),
                    count <= sum_range(0, i),
                    count <= n_choose_2(v.len() as int)
      {
          let mut j = i + 1;
          let count_i = count;
          while j < v.len()
              invariant i < v.len(),
                        j <= v.len(),
                        count <= count_i + sum_range(i + 1, j),
                        count <= n_choose_2(v.len() as int)
          {
              if v@[i] > v@[j] {
                  count = count + 1;
              }
              j = j + 1;
          }
          i = i + 1;
      }
  }

vc-spec: |-
  // <vc-spec>
  fn bubble_sort(a: &mut Vec<i32>) -> (n: usize) 
      ensures n <= n_choose_2(a.len() as int) as usize
  // </vc-spec>

vc-code: |-
  fn bubble_sort(a: &mut Vec<i32>) -> (n: usize)
      ensures n <= n_choose_2(a.len() as int) as usize,
              is_sorted(a)
  {
      let mut swaps = 0;
      let mut i = a.len();
      while i > 0
          invariant i <= a.len(),
                    swaps <= n_choose_2(a.len() as int) as usize,
                    forall|k: int, l: int| i <= k && k < l && l < a.len() ==> a@[k] <= a@[l]
      {
          let mut j = 0;
          while j < i - 1
              invariant i <= a.len(),
                        j < i,
                        swaps <= n_choose_2(a.len() as int) as usize,
                        forall|k: int, l: int| i <= k && k < l && l < a.len() ==> a@[k] <= a@[l],
                        forall|k: int| 0 <= k && k <= j ==> forall|l: int| k < l && l < i ==> a@[k] <= a@[l]
          {
              if a@[j] > a@[j + 1] {
                  let tmp = a@[j];
                  a.set(j, a@[j + 1]);
                  a.set(j + 1, tmp);
                  swaps = swaps + 1;
              }
              j = j + 1;
          }
          i = i - 1;
      }
      proof {
          inversion_count_bound(a);
      }
      swaps
  }

vc-postamble: |-
  fn main() {
  }
  
  }

