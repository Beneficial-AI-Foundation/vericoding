vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_modulo_properties(a: int, b: int)
      requires b > 0,
      ensures
          (a % b) >= 0,
          (a % b) < b,
          a == (a / b) * b + (a % b),
  {
  }
  
  proof fn lemma_seq_index_modulo(l: Seq<int>, i: int, n: int)
      requires
          n > 0,
          0 <= i < l.len(),
      ensures
          l.index(i) == l.index((i + n) % n),
  {
      lemma_modulo_properties(i + n, n);
  }

vc-spec: |-
  // <vc-spec>
  fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)
      requires n >= 0,
      ensures 
          r.len() == l.len(),
          forall|i: int| 0 <= i < l.len() ==> r.index(i) == l.index((i - n + l.len() as int) % l.len() as int),
  // </vc-spec>

vc-code: |-
  fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)
      requires n >= 0,
      ensures
          r.len() == l.len(),
          forall|i: int| 0 <= i < l.len() ==> r.index(i) == l.index((i - n + l.len() as int) % l.len() as int),
  {
      let len = l.len() as int;
      if len == 0 {
          return l;
      }
      let n_mod = if n >= len { n % len } else { n };
      proof {
          lemma_modulo_properties(n, len);
      }
      let mut result: Vec<int> = Vec::new();
      let mut i: usize = 0;
      while i < l.len()
          invariant
              result.len() == i,
              forall|j: int| 0 <= j < i ==> result@[j] == l.index((j - n_mod + len) % len),
      {
          let idx = ((i as int) - n_mod + len) % len;
          result.push(l.index(idx as int));
          i = i + 1;
      }
      result.into_seq()
  }

vc-postamble: |-
  fn main() {}
  
  }

