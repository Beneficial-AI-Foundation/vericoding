vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  /* 
  * Formal verification of the selection sort algorithm with Verus.
  * FEUP, MIEIC, MFES, 2020/21.
  */
  
  // Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).
  spec fn is_sorted(a: Seq<i32>, from: int, to: int) -> bool
      recommends 0 <= from <= to <= a.len()
  {
      forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]
  }
  
  // Sorts array 'a' using the selection sort algorithm.
  
  // Finds the position of a minimum value in non-empty subarray 'a' between positions 
  // 'from' (inclusive) and 'to' (exclusive)
  fn find_min(a: &Vec<i32>, from: usize, to: usize) -> (index: usize)
      requires 
          0 <= from < to <= a.len(),
      ensures 
          from <= index < to,
          forall|k: int| from as int <= k < to as int ==> a@[k] >= a@[index as int],
  {
      assume(false);
      0
  }

vc-helpers: |-
  // Helper function to check if a sequence is a permutation of another (via multiset)
  spec fn is_permutation(s1: Seq<i32>, s2: Seq<i32>) -> bool {
      s1.to_multiset() == s2.to_multiset()
  }
  
  // Lemma to ensure swapping preserves permutation
  proof fn lemma_swap_preserves_multiset(a: Seq<i32>, i: int, j: int)
      requires 
          0 <= i < a.len(),
          0 <= j < a.len(),
      ensures
          a.swap(i, j).to_multiset() == a.to_multiset()
  {
  }
  
  // Helper spec to ensure the prefix of the array is sorted and contains the smallest elements
  spec fn prefix_sorted_and_smallest(a: Seq<i32>, sorted_up_to: int) -> bool
      recommends 0 <= sorted_up_to <= a.len()
  {
      is_sorted(a, 0, sorted_up_to) && 
      forall|i: int, j: int| 0 <= i < sorted_up_to && sorted_up_to <= j < a.len() ==> a[i] <= a[j]
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<i32>)
      ensures 
          is_sorted(a@, 0, a@.len() as int),
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  fn selection_sort(a: &mut Vec<i32>)
      ensures 
          is_sorted(a@, 0, a@.len() as int),
          a@.to_multiset() == old(a)@.to_multiset(),
  {
      let mut i: usize = 0;
      let n = a.len();
      while i < n
          invariant
              0 <= i <= n,
              prefix_sorted_and_smallest(a@, i as int),
              a@.to_multiset() == old(a)@.to_multiset(),
      {
          let min_idx = find_min(a, i, n);
          if i != min_idx {
              a.swap(i, min_idx);
              proof {
                  lemma_swap_preserves_multiset(a@, i as int, min_idx as int);
              }
          }
          i = i + 1;
      }
  }
  
  fn find_min(a: &Vec<i32>, from: usize, to: usize) -> (index: usize)
      requires 
          0 <= from < to <= a.len(),
      ensures 
          from <= index < to,
          forall|k: int| from as int <= k < to as int ==> a@[k] >= a@[index as int],
  {
      let mut min_idx = from;
      let mut i = from + 1;
      while i < to
          invariant
              from <= i <= to,
              from <= min_idx < to,
              forall|k: int| from as int <= k < i as int ==> a@[k] >= a@[min_idx as int],
      {
          if a[i] < a[min_idx] {
              min_idx = i;
          }
          i = i + 1;
      }
      min_idx
  }

vc-postamble: |-
  
  fn main() {}
  
  }

