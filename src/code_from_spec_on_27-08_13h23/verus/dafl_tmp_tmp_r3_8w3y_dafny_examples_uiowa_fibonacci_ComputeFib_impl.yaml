vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  /*
     CS:5810 Formal Methods in Software Engineering
     Fall 2017
     The University of Iowa
  
     Instructor: Cesare Tinelli
  
     Credits: Example adapted from Dafny tutorial
  */
  
  
  //      n = 0, 1, 2, 3, 4, 5, 6,  7,  8, ...
  // fib(n) = 0, 1, 1, 2, 3, 5, 8, 13, 21, ...
  spec fn fib(n: nat) -> nat
      decreases n
  {
      if n == 0 { 0 }
      else if n == 1 { 1 }
      else { fib((n - 1) as nat) + fib((n - 2) as nat) }
  }

vc-helpers: |-
  spec fn fib_lemma(n: nat) -> nat
      decreases n
  {
      if n == 0 { 0 }
      else if n == 1 { 1 }
      else { fib_lemma((n - 1) as nat) + fib_lemma((n - 2) as nat) }
  }
  
  proof fn fib_equivalence(n: nat)
      ensures fib(n) == fib_lemma(n)
      decreases n
  {
      if n > 1 {
          fib_equivalence((n - 1) as nat);
          fib_equivalence((n - 2) as nat);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn ComputeFib(n: usize) -> (f: usize)
      ensures f == fib(n as nat)
  // </vc-spec>

vc-code: |-
  fn ComputeFib(n: usize) -> (f: usize)
      ensures f == fib(n as nat)
  {
      if n == 0 {
          return 0;
      }
      if n == 1 {
          return 1;
      }
      
      let mut prev = 0;
      let mut curr = 1;
      let mut i = 2;
      
      while i <= n
          invariant
              i <= n + 1,
              prev == fib((i - 2) as nat),
              curr == fib((i - 1) as nat)
      {
          let next = prev + curr;
          prev = curr;
          curr = next;
          i = i + 1;
      }
      
      curr
  }

vc-postamble: |-
  fn main() {
  }
  
  }

