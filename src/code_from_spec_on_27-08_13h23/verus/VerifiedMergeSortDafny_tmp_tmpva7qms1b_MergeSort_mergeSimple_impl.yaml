vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn merged(a1: Seq<i32>, a2: Seq<i32>, b: &Vec<i32>, start: int, end: int) -> bool {
      &&& end - start == a2.len() + a1.len()
      &&& 0 <= start <= end <= b.len()
      &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()
  }
  
  spec fn sorted_slice(a: &Vec<i32>, start: int, end: int) -> bool {
      &&& 0 <= start <= end <= a.len()
      &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]
  }
  
  spec fn sorted_seq(a: Seq<i32>) -> bool {
      forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
  }
  
  spec fn sorted(a: &Vec<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]
  }

vc-helpers: |-
  proof fn lemma_multiset_add_commutative(a: Seq<i32>, b: Seq<i32>)
      ensures
          a.to_multiset().add(b.to_multiset()) == b.to_multiset().add(a.to_multiset())
  {
  }
  
  proof fn lemma_subrange_multiset(v: Seq<i32>, start: int, end: int, i: int, val: i32)
      requires
          0 <= start <= i < end <= v.len(),
      ensures
          v.update(i, val).subrange(start, end).to_multiset() == v.subrange(start, end).to_multiset().remove(val).insert(v[i])
  {
  }

vc-spec: |-
  // <vc-spec>
  fn mergeSimple(a1: Seq<i32>, a2: Seq<i32>, start: usize, end: usize, b: &mut Vec<i32>)
      requires
          sorted_seq(a1),
          sorted_seq(a2),
          0 <= start <= end <= old(b).len(),
          a1.len() + a2.len() == end - start + 1,
      ensures
          sorted_slice(b, start as int, end as int),
  // </vc-spec>

vc-code: |-
  fn mergeSimple(a1: Seq<i32>, a2: Seq<i32>, start: usize, end: usize, b: &mut Vec<i32>)
      requires
          sorted_seq(a1),
          sorted_seq(a2),
          0 <= start <= end <= old(b).len(),
          a1.len() + a2.len() == end - start,
      ensures
          sorted_slice(b, start as int, end as int),
  {
      let mut i: usize = 0;
      let mut j: usize = 0;
      let mut k: usize = start;
  
      while k < end
          invariant
              0 <= i <= a1.len(),
              0 <= j <= a2.len(),
              start <= k <= end,
              sorted_slice(b, start as int, k as int),
              i + j == k - start,
      {
          if i < a1.len() && (j >= a2.len() || a1[i] <= a2[j]) {
              b.set(k, a1[i]);
              i = i + 1;
          } else {
              b.set(k, a2[j]);
              j = j + 1;
          }
          k = k + 1;
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

