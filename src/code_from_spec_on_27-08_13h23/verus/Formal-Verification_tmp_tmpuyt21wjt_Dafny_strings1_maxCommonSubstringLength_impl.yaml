vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
      (pre.len() > str.len()) || 
      pre != str.subrange(0, pre.len() as int)
  }
  
  fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures 
          !res <==> is_not_prefix_pred(pre, str),
          res <==> is_prefix_predicate(pre, str),
  {
      assume(false);
      true
  }
  
  spec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {
      str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)
  }
  
  spec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {
      str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && is_prefix_predicate(sub, str.subrange(i, str.len() as int)))
  }
  
  fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures res == is_substring_predicate(sub, str),
  {
      assume(false);
      true
  }
  
  spec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
      str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && is_substring_predicate((str1.subrange(i, str1.len() as int)).subrange(0, k as int), str2))
  }
  
  fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
      requires k <= usize::MAX,
      ensures 
          (str1.len() < k || str2.len() < k) ==> !found,
          have_common_k_substring_predicate(k as nat, str1, str2) == found,
  {
      assume(false);
      true
  }
  
  spec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {
      forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)
  }

vc-helpers: |-
  proof fn prefix_implies_not_prefix(pre: Seq<char>, str: Seq<char>)
      ensures
          is_prefix_predicate(pre, str) ==> !is_not_prefix_pred(pre, str),
          !is_prefix_predicate(pre, str) ==> is_not_prefix_pred(pre, str),
  {
      if is_prefix_predicate(pre, str) {
          assert(str.len() >= pre.len());
          assert(pre == str.subrange(0, pre.len() as int));
      }
  }
  
  spec fn min(a: usize, b: usize) -> usize {
      if a < b { a } else { b }
  }

vc-spec: |-
  // <vc-spec>
  fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
      ensures 
          len <= str1.len() && len <= str2.len(),
          len >= 0,
          max_common_substring_predicate(str1, str2, len as nat),
  // </vc-spec>

vc-code: |-
  fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
      ensures 
          len <= str1.len() && len <= str2.len(),
          len >= 0,
          max_common_substring_predicate(str1, str2, len as nat),
  {
      let max_possible = min(str1.len(), str2.len());
      let mut current_len: usize = max_possible;
      while current_len > 0
          invariant
              current_len <= max_possible,
              current_len <= str1.len(),
              current_len <= str2.len(),
              forall|k: int| current_len < k <= max_possible ==> !have_common_k_substring_predicate(k as nat, str1, str2),
      {
          if have_common_k_substring(current_len, str1, str2) {
              return current_len;
          }
          current_len = current_len - 1;
      }
      0
  }
  
  fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures 
          !res <==> is_not_prefix_pred(pre, str),
          res <==> is_prefix_predicate(pre, str),
  {
      if pre.len() > str.len() {
          return false;
      }
      let mut i: usize = 0;
      while i < pre.len()
          invariant
              i <= pre.len(),
              i <= str.len(),
              forall|j: int| 0 <= j < i ==> pre@[j] == str@[j],
      {
          if pre@[i] != str@[i] {
              return false;
          }
          i = i + 1;
      }
      true
  }
  
  fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures res == is_substring_predicate(sub, str),
  {
      if sub.len() > str.len() {
          return false;
      }
      let mut i: usize = 0;
      while i <= str.len() - sub.len()
          invariant
              i <= str.len(),
              sub.len() <= str.len(),
              forall|j: int| 0 <= j < i ==> !is_prefix_predicate(sub, str.subrange(j, str.len() as int)),
      {
          if is_prefix(sub, str.subrange(i as int, str.len() as int)) {
              return true;
          }
          i = i + 1;
      }
      false
  }
  
  fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
      requires k <= usize::MAX,
      ensures 
          (str1.len() < k || str2.len() < k) ==> !found,
          have_common_k_substring_predicate(k as nat, str1, str2) == found,
  {
      if str1.len() < k || str2.len() < k {
          return false;
      }
      let mut i: usize = 0;
      while i <= str1.len() - k
          invariant
              i <= str1.len(),
              k <= str1.len(),
              forall|j: int| 0 <= j < i ==> !is_substring_predicate(str1.subrange(j, str1.len() as int).subrange(0, k as int), str2),
      {
          let substr = str1.subrange(i as int, str1.len() as int).subrange(0, k as int);
          if is_substring(substr, str2) {
              return true;
          }
          i = i + 1;
      }
      false
  }

vc-postamble: |-
  fn main() {}
  
  }

