vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // By `lol sort` here, I refer to a seemingly-broken sorting algorithm,
  // which actually somehow manages to work perfectly:
  //
  // for i in 0..n
  //   for j in 0..n
  //     if i < j
  //       swap a[i], a[j]
  //
  // It is perhaps the simpliest sorting algorithm to "memorize",
  // even "symmetrically beautiful" as if `i` and `j` just played highly
  // similar roles. And technically it's still O(n^2) time lol...
  //
  // Proving its correctness is tricky (interesting) though.
  
  // Successfully verified with Verus
  
  
  
  // We define "valid permutation" using multiset:
  
  spec fn valid_permut(a: Seq<int>, b: Seq<int>) -> bool
      recommends a.len() == b.len()
  {
      a.to_multiset() == b.to_multiset()
  }
  
  // This is a swap-based sorting algorithm, so permutedness is trivial:
  // note that: if i == j, the spec just says a[..] remains the same.
  
  // We then define "sorted" (by increasing order):
  spec fn sorted(a: Seq<int>) -> bool
  {
      forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
  }
  
  
  // Now, the lol sort algorithm:
  // (Some invariants were tricky to find, but Verus was smart enough otherwise)

vc-helpers: |-
  spec fn is_minimal_in_range(a: Seq<int>, idx: int, start: int, end: int) -> bool
      recommends 0 <= start <= idx < end <= a.len()
  {
      forall|k: int| start <= k < end ==> a[idx] <= a[k]
  }
  
  proof fn prove_minimal_transitive(a: Seq<int>, i: int, j: int, k: int)
      requires 
          0 <= i <= j <= k < a.len(),
          is_minimal_in_range(a, i, 0, j),
          is_minimal_in_range(a, j, 0, k),
      ensures
          is_minimal_in_range(a, i, 0, k)
  {
      assert forall|idx: int| 0 <= idx < k implies a[i] <= a[idx] by {
          if idx < j {
              assert(a[i] <= a[idx]); // from is_minimal_in_range(a, i, 0, j)
          } else {
              assert(a[i] <= a[j]); // from is_minimal_in_range(a, i, 0, j)
              assert(a[j] <= a[idx]); // from is_minimal_in_range(a, j, 0, k)
          }
      };
  }

vc-spec: |-
  // <vc-spec>
  fn swap(a: &mut Vec<int>, i: usize, j: usize)
      requires 
          i < old(a).len(),
          j < old(a).len(),
      ensures 
          a.len() == old(a).len(),
          a@ == old(a)@.update(i as int, old(a)@[j as int]).update(j as int, old(a)@[i as int]),
          valid_permut(a@, old(a)@),
  // </vc-spec>

vc-code: |-
  fn swap(a: &mut Vec<int>, i: usize, j: usize)
      requires 
          i < old(a).len(),
          j < old(a).len(),
      ensures 
          a.len() == old(a).len(),
          a@ == old(a)@.update(i as int, old(a)@[j as int]).update(j as int, old(a)@[i as int]),
          valid_permut(a@, old(a)@),
  {
      let temp = a[i];
      a.set(i, a[j]);
      a.set(j, temp);
  }
  
  fn lol_sort(a: &mut Vec<int>)
      requires true
      ensures 
          a.len() == old(a).len(),
          sorted(a@),
          valid_permut(a@, old(a)@),
  {
      let n = a.len();
      let mut i: usize = 0;
      while i < n
          invariant
              0 <= i <= n,
              a.len() == n,
              valid_permut(a@, old(a)@),
              forall|k: int| 0 <= k < i ==> is_minimal_in_range(a@, k, 0, i as int),
              forall|k1: int, k2: int| 0 <= k1 <= k2 < i ==> a@[k1] <= a@[k2],
      {
          let mut j: usize = 0;
          while j < n
              invariant
                  0 <= i <= n,
                  0 <= j <= n,
                  a.len() == n,
                  valid_permut(a@, old(a)@),
                  forall|k: int| 0 <= k < i ==> is_minimal_in_range(a@, k, 0, i as int),
                  forall|k1: int, k2: int| 0 <= k1 <= k2 < i ==> a@[k1] <= a@[k2],
                  forall|k: int| i <= k < j ==> a@[i as int] <= a@[k],
          {
              if i < j {
                  swap(a, i, j);
              }
              j = j + 1;
          }
          i = i + 1;
      }
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

