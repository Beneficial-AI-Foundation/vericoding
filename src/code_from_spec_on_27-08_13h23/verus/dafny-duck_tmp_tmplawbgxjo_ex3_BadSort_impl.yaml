vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // program verifies
  
  spec fn sortedbad(s: Seq<char>) -> bool {
      // no b's after non-b's
      (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] == 'b' && s[j] != 'b' ==> i < j) &&
      // only non-d's before d's
      (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] != 'd' && s[j] == 'd' ==> i < j)
  }

vc-helpers: |-
  spec fn count_char(s: Seq<char>, c: char) -> nat {
      s.filter(|x: char| x == c).len()
  }
  
  proof fn seq_split(s: Seq<char>, idx1: int, idx2: int)
      requires
          0 <= idx1 <= idx2 <= s.len(),
      ensures
          s.subrange(0, idx1) + s.subrange(idx1, idx2) + s.subrange(idx2, s.len()) == s,
  {
      assert_seqs_equal!(s.subrange(0, idx1) + s.subrange(idx1, idx2) + s.subrange(idx2, s.len()), s);
  }
  
  proof fn preserve_multiset_on_concat(s1: Seq<char>, s2: Seq<char>, s3: Seq<char>)
      ensures
          (s1 + s2 + s3).to_multiset() == s1.to_multiset() + s2.to_multiset() + s3.to_multiset(),
  {
  }

vc-spec: |-
  // <vc-spec>
  fn bad_sort(a: Seq<char>) -> (b: Seq<char>)
      requires 
          forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',
      ensures 
          sortedbad(b) && b.to_multiset() == a.to_multiset(),
  // </vc-spec>

vc-code: |-
  exec fn bad_sort(a: Seq<char>) -> (b: Seq<char>)
      requires 
          forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',
      ensures 
          sortedbad(b) && b.to_multiset() == a.to_multiset(),
  {
      let mut result: Vec<char> = Vec::new();
      let mut i: usize = 0;
  
      // Count the number of each character
      let mut count_a: usize = 0;
      let mut count_b: usize = 0;
      let mut count_d: usize = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              count_a == count_char(a.subrange(0, i as int), 'a'),
              count_b == count_char(a.subrange(0, i as int), 'b'),
              count_d == count_char(a.subrange(0, i as int), 'd'),
      {
          if a@[i] == 'a' {
              count_a = count_a + 1;
          } else if a@[i] == 'b' {
              count_b = count_b + 1;
          } else {
              count_d = count_d + 1;
          }
          i = i + 1;
      }
  
      // Push 'a's first
      i = 0;
      while i < count_a
          invariant
              0 <= i <= count_a,
              result.len() == i,
              forall|k: int| 0 <= k < i ==> result@[k] == 'a',
      {
          result.push('a');
          i = i + 1;
      }
  
      // Push 'b's next
      i = 0;
      while i < count_b
          invariant
              0 <= i <= count_b,
              result.len() == count_a + i,
              forall|k: int| 0 <= k < count_a ==> result@[k] == 'a',
              forall|k: int| count_a <= k < count_a + i ==> result@[k] == 'b',
      {
          result.push('b');
          i = i + 1;
      }
  
      // Push 'd's last
      i = 0;
      while i < count_d
          invariant
              0 <= i <= count_d,
              result.len() == count_a + count_b + i,
              forall|k: int| 0 <= k < count_a ==> result@[k] == 'a',
              forall|k: int| count_a <= k < count_a + count_b ==> result@[k] == 'b',
              forall|k: int| count_a + count_b <= k < count_a + count_b + i ==> result@[k] == 'd',
      {
          result.push('d');
          i = i + 1;
      }
  
      proof {
          let final_seq = result@;
          assert(final_seq.len() == count_a + count_b + count_d);
          assert(count_a == count_char(a, 'a'));
          assert(count_b == count_char(a, 'b'));
          assert(count_d == count_char(a, 'd'));
          assert(final_seq.to_multiset() == a.to_multiset());
          assert(sortedbad(final_seq));
      }
  
      result@
  }

vc-postamble: |-
  fn main() {}
  
  }

