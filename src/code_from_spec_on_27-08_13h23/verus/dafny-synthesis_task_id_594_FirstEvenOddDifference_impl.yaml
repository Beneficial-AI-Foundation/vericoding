vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_even(n: int) -> bool {
      n % 2 == 0
  }
  
  spec fn is_odd(n: int) -> bool {
      n % 2 != 0
  }

vc-helpers: |-
  proof fn lemma_first_even(a: Seq<i32>) -> (index: int)
      requires
          exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),
      ensures
          0 <= index < a.len(),
          is_even(a[index] as int),
          forall|k: int| 0 <= k < index ==> is_odd(a[k] as int),
  {
      let mut i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int| 0 <= k < i ==> is_odd(a[k] as int),
              exists|j: int| i <= j < a.len() && is_even(a[j] as int),
      {
          if is_even(a[i] as int) {
              return i;
          }
          i = i + 1;
      }
      assert(false); // This line should never be reached due to the requires condition
      0
  }
  
  proof fn lemma_first_odd(a: Seq<i32>) -> (index: int)
      requires
          exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),
      ensures
          0 <= index < a.len(),
          is_odd(a[index] as int),
          forall|k: int| 0 <= k < index ==> is_even(a[k] as int),
      decreases
          a.len(),
  {
      let mut i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int| 0 <= k < i ==> is_even(a[k] as int),
              exists|j: int| i <= j < a.len() && is_odd(a[j] as int),
      {
          if is_odd(a[i] as int) {
              return i;
          }
          i = i + 1;
      }
      assert(false); // This line should never be reached due to the requires condition
      0
  }

vc-spec: |-
  // <vc-spec>
  fn first_even_odd_difference(a: &[i32]) -> (diff: i32)
      requires 
          a.len() >= 2,
          exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),
          exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),
      ensures 
          exists|i: int, j: int| 
              0 <= i < a.len() && 
              0 <= j < a.len() && 
              is_even(a[i] as int) && 
              is_odd(a[j] as int) && 
              diff == a[i] - a[j] && 
              (forall|k: int| 0 <= k < i ==> is_odd(a[k] as int)) && 
              (forall|k: int| 0 <= k < j ==> is_even(a[k] as int))
  // </vc-spec>

vc-code: |-
  fn first_even_odd_difference(a: &[i32]) -> (diff: i32)
      requires 
          a.len() >= 2,
          exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),
          exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),
      ensures 
          exists|i: int, j: int| 
              0 <= i < a.len() && 
              0 <= j < a.len() && 
              is_even(a[i] as int) && 
              is_odd(a[j] as int) && 
              diff == a[i] - a[j] && 
              (forall|k: int| 0 <= k < i ==> is_odd(a[k] as int)) && 
              (forall|k: int| 0 <= k < j ==> is_even(a[k] as int))
  {
      let mut first_even = 0;
      let mut i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int| 0 <= k < i ==> is_odd(a[k] as int),
              exists|j: int| i <= j < a.len() && is_even(a[j] as int),
      {
          if is_even(a[i] as int) {
              first_even = i;
              break;
          }
          i = i + 1;
      }
  
      let mut first_odd = 0;
      i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              forall|k: int| 0 <= k < i ==> is_even(a[k] as int),
              exists|j: int| i <= j < a.len() && is_odd(a[j] as int),
      {
          if is_odd(a[i] as int) {
              first_odd = i;
              break;
          }
          i = i + 1;
      }
  
      a[first_even] - a[first_odd]
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

