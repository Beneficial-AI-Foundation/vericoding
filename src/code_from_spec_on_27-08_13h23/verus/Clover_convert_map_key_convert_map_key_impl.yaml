vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_map_contains_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat, k: nat)
      requires
          forall|n1: nat, n2: nat| 
              #[trigger] f(n1) != #[trigger] f(n2) ==> n1 != n2,
      ensures
          forall|k1: nat| inputs.contains_key(k1) ==> inputs.contains_key(k1),
  {
  }

vc-spec: |-
  // <vc-spec>
  fn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)
      requires
          forall|n1: nat, n2: nat| 
              #[trigger] f(n1) != #[trigger] f(n2) ==> n1 != n2,
      ensures
          forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k)),
          forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k],
  // </vc-spec>

vc-code: |-
  exec fn convert_map_key(inputs: Map<nat, bool>, f: impl FnSpec(nat) -> nat) -> (r: Map<nat, bool>)
      requires
          forall|n1: nat, n2: nat| 
              #[trigger] f(n1) != #[trigger] f(n2) ==> n1 != n2,
      ensures
          forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k)),
          forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k],
  {
      let mut result: Map<nat, bool> = Map::empty();
      let mut iter = inputs.keys().into_iter();
      while let Some(k) = iter.next()
          invariant
              forall|k: nat| result.contains_key(f(k)) ==> result[f(k)] == inputs[k],
              forall|k: nat| inputs.contains_key(k) ==> result.contains_key(f(k)) || iter.contains(k),
      {
          let fk = f(k);
          result = result.insert(fk, inputs[k]);
      }
      result
  }

vc-postamble: |-
  
  fn main() {}
  
  }

