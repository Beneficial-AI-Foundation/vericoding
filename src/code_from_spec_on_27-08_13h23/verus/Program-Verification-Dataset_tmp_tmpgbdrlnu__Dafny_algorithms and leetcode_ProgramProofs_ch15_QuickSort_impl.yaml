vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  fn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)
      requires 0 <= lo < hi <= old(a).len(),
      ensures lo <= p < hi,
  {
      assume(false);
      0
  }
  
  spec fn split_point(a: &Vec<int>, n: usize) -> bool
      recommends 0 <= n <= a.len(),
  {
      forall|i: int, j: int| 0 <= i < n && n <= j < a.len() ==> a[i] <= a[j]
  }
  
  spec fn swap_frame(a: &Vec<int>, old_a: &Vec<int>, lo: usize, hi: usize) -> bool
      recommends 0 <= lo <= hi <= a.len(),
  {
      (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) &&
      a@.to_multiset() =~= old_a@.to_multiset()
  }
  
  fn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)
      requires 
          0 <= lo <= hi <= old(a).len(),
          split_point(old(a), lo),
          split_point(old(a), hi),
      ensures 
          forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],
          swap_frame(a, old(a), lo, hi),
          split_point(a, lo),
          split_point(a, hi),
      decreases hi - lo,
  {
      assume(false);
  }

vc-helpers: |-
  spec fn is_sorted(a: &Vec<int>, start: usize, end: usize) -> bool
      recommends 0 <= start <= end <= a.len(),
  {
      forall|i: int, j: int| start <= i < j < end ==> a[i] <= a[j]
  }
  
  proof fn lemma_multiset_swap(a: &Vec<int>, i: usize, j: usize)
      requires 0 <= i < a.len(), 0 <= j < a.len(),
      ensures a@.to_multiset() =~= a@.update(i, a[j]).update(j, a[i]).to_multiset(),
  {
  }
  
  proof fn lemma_swap_frame(a: &Vec<int>, old_a: &Vec<int>, i: usize, j: usize, lo: usize, hi: usize)
      requires 
          0 <= lo <= hi <= a.len(),
          0 <= i < a.len(),
          0 <= j < a.len(),
          forall|k: int| (0 <= k < lo || hi <= k < a.len()) ==> a[k] == old_a[k],
          a@.to_multiset() =~= old_a@.to_multiset(),
      ensures
          forall|k: int| (0 <= k < lo || hi <= k < a.len()) ==> a@.update(i, a[j]).update(j, a[i])[k] == old_a[k],
          a@.update(i, a[j]).update(j, a[i]).to_multiset() =~= old_a@.to_multiset(),
  {
  }

vc-spec: |-
  // <vc-spec>
  fn quick_sort(a: &mut Vec<int>)
      ensures 
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          a@.to_multiset() =~= old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  fn quick_sort(a: &mut Vec<int>)
      ensures 
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          a@.to_multiset() =~= old(a)@.to_multiset(),
  {
      if a.len() > 0 {
          quick_sort_aux(a, 0, a.len());
      }
  }
  
  fn quick_sort_aux(a: &mut Vec<int>, lo: usize, hi: usize)
      requires 
          0 <= lo <= hi <= old(a).len(),
          split_point(old(a), lo),
          split_point(old(a), hi),
      ensures 
          forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],
          swap_frame(a, old(a), lo, hi),
          split_point(a, lo),
          split_point(a, hi),
      decreases hi - lo,
  {
      if lo + 1 < hi {
          let p = partition(a, lo, hi);
          quick_sort_aux(a, lo, p);
          quick_sort_aux(a, p, hi);
      }
  }
  
  fn partition(a: &mut Vec<int>, lo: usize, hi: usize) -> (p: usize)
      requires 0 <= lo < hi <= old(a).len(),
      ensures lo <= p < hi,
          forall|i: int| lo <= i < p ==> a[i] <= a[p],
          forall|i: int| p < i < hi ==> a[p] <= a[i],
          swap_frame(a, old(a), lo, hi),
  {
      let pivot = a[hi - 1];
      let mut i = lo;
      let mut j = lo;
      
      while j < hi - 1
          invariant 
              lo <= i <= j < hi,
              forall|k: int| lo <= k < i ==> a[k] <= pivot,
              forall|k: int| i <= k < j ==> a[k] > pivot,
              swap_frame(a, old(a), lo, hi),
      {
          if a[j] <= pivot {
              let temp = a[i];
              a.set(i, a[j]);
              a.set(j, temp);
              i = i + 1;
          }
          j = j + 1;
      }
      
      let temp = a[i];
      a.set(i, a[hi - 1]);
      a.set(hi - 1, temp);
      
      i
  }

vc-postamble: |-
  
  fn main() {}
  
  }

