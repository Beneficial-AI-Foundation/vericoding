vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Two-state predicate for checking if multiset is preserved
  spec fn preserved(a_old: Seq<i32>, a_new: Seq<i32>, left: nat, right: nat) -> bool
      recommends left <= right <= a_old.len() && a_old.len() == a_new.len()
  {
      a_old.subrange(left as int, right as int).to_multiset() == a_new.subrange(left as int, right as int).to_multiset()
  }
  
  // Predicate for checking if array slice is ordered
  spec fn ordered(a: Seq<i32>, left: nat, right: nat) -> bool
      recommends left <= right <= a.len()
  {
      forall|i: int| #![trigger a[i]] left < i < right ==> a[i-1] <= a[i]
  }
  
  // Two-state predicate for sorted array
  spec fn sorted(a_old: Seq<i32>, a_new: Seq<i32>) -> bool
      recommends a_old.len() == a_new.len()
  {
      ordered(a_new, 0, a_new.len() as nat) && preserved(a_old, a_new, 0, a_old.len() as nat)
  }

vc-helpers: |-
  // Helper lemma to prove that swapping elements preserves the multiset
  proof fn lemma_swap_preserves_multiset(a_old: Seq<i32>, a_new: Seq<i32>, i: nat, j: nat)
      requires
          i < a_old.len(),
          j < a_old.len(),
          a_old.len() == a_new.len(),
          forall|k: int| k != i && k != j ==> a_old[k] == a_new[k],
          a_new[i] == a_old[j],
          a_new[j] == a_old[i],
      ensures
          preserved(a_old, a_new, 0, a_old.len() as nat)
  {
      assert(a_old.to_multiset() == a_new.to_multiset()) by {
          reveal(Seq::to_multiset);
      }
  }
  
  // Helper lemma to prove that a subrange remains ordered after swapping
  proof fn lemma_swap_maintains_order(a: Seq<i32>, i: nat, j: nat, left: nat, right: nat)
      requires
          i < a.len(),
          j < a.len(),
          left <= i,
          i < j,
          j < right,
          right <= a.len(),
          ordered(a, left, right),
          a[i] <= a[j],
      ensures
          ordered(a, left, right)
  {
  }
  
  // Helper lemma to show that finding the minimum preserves ordering invariants
  proof fn lemma_min_index_preserves_order(a: Seq<i32>, min_idx: nat, start: nat, end: nat)
      requires
          start <= end <= a.len(),
          start <= min_idx < end,
          forall|k: int| start <= k < end ==> a[min_idx] <= a[k],
          ordered(a, 0, start),
      ensures
          ordered(a, 0, start)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<i32>)
      ensures sorted(old(a)@, a@)
  // </vc-spec>

vc-code: |-
  fn selection_sort(a: &mut Vec<i32>)
      ensures sorted(old(a)@, a@)
  {
      let mut i: usize = 0;
      let n = a.len();
  
      while i < n
          invariant
              0 <= i <= n,
              n == a.len(),
              ordered(a@, 0, i as nat),
              preserved(old(a)@, a@, 0, n as nat)
      {
          let mut min_idx = i;
          let mut j = i + 1;
  
          while j < n
              invariant
                  i <= min_idx < n,
                  i < j <= n,
                  n == a.len(),
                  forall|k: int| i <= k < j ==> a@[min_idx as int] <= a@[k],
                  ordered(a@, 0, i as nat),
                  preserved(old(a)@, a@, 0, n as nat)
          {
              if a[j] < a[min_idx] {
                  min_idx = j;
              }
              j = j + 1;
          }
  
          if min_idx != i {
              let ghost a_old = a@;
              a.swap(i, min_idx);
              proof {
                  lemma_swap_preserves_multiset(a_old, a@, i as nat, min_idx as nat);
              }
          }
  
          proof {
              lemma_min_index_preserves_order(a@, min_idx as nat, i as nat, n as nat);
          }
          i = i + 1;
      }
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

