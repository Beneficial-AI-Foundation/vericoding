generate_code: |
  The task is to generate implementations for `<vc-code>` sections in a Dafny file.
  
  INPUT: a Dafny file containing `<vc-code>` tags around placeholder implementations that need to be filled in.
  
  OUTPUT: Return a JSON array with one replacement for each `<vc-code>` section in the file, in order from top to bottom:
  ```json
  ["{\n  prefixes := [];\n  // implementation here\n}", "{\n  // second implementation\n}"]
  ```
  
  CRITICAL RULES:
  - Provide exactly one replacement for each `<vc-code>` section in the file, in the exact order they appear (top to bottom)
  - Each replacement should be the exact code that will replace everything between the `<vc-code>` tags
  - Include opening/closing braces if they were in the original `<vc-code>` content
  - Do not use `assume` statements or `assume {:axiom} false` in replacements
  - Use valid Dafny syntax for all implementations
  - Satisfy all `requires` and `ensures` clauses from the method/function specifications
  - Do not add trivial or unnecessary annotations
  - Return ONLY a valid JSON array, no explanations or markdown
  
  DAFNY FILE WITH <vc-code> SECTIONS:
  {code}

fix_verification: |
 INPUT: a Dafny file that contain blocks of code marked //ATOM or //IMPL. The file is of the form
         B_1 
         ...
         B_n
         where each B_i is:
         - either an ATOM of the form 
          //ATOM
          atom_i
         - or an IMPL of the form 
          //IMPL [spec name]
          [//CONSTRAINTS: [constraint_1] ... [constraint_k]]
          spec_impl_i
    WHERE:
    - each atom_i is a function, lemma, predicate, or method.
    - each spec_i is a method, function, or lemma with requires and ensures clauses that must be satisfied
    - each spec_impl_i is an implementation of spec_i that cannot be verified
    - if //CONSTRAINTS: is present, then each constraints_i describes the type of code that is not allowed in implementations of spec_i
  OUTPUT:a verified Dafny file of the form
        B_impl_1 
        ...
        B_impl_n
  WHERE:
    - if B_i is an ATOM, then B_impl_i is equal to B_i 
    - if B_i is an IMPL, then B_impl_i is of the form: 
      //IMPL [spec name]
      [//CONSTRAINTS: [constraint_1] ... [constraint_k]]
      spec_impl_updated_i
      where spec_impl_updated_i is a revised implementation of spec_i that can be verified. 
    
  POSITIVE CRITICAL RULES:
  - you can add proof annotations to the body of spec_impl_i to fix the verification errors starting
  - you can change the code in spec_impl_i to fix the verification errors
  - you can add helper functions, predicates, and lemmas as needed
  - PRIORITY: If the error is a compilation error (syntax, type, resolution errors), fix it first before addressing verification issues
  - For compilation errors: focus on syntax, missing brackets, type mismatches, undefined identifiers, and termination issues
  
  NEGATIVE CRITICAL RULES:
  - preserve each spec_i as it is: do not change method/function/lemma names, parameter type, return type, ensures and requires clauses
  - the atoms are assumed to be true; do not attempt to prove or change them
  - you should not use "assume" statements in spec_impl_updated_i
  - you should not add trivial annotations (requires true, invariant true, ensures true, etc.)
  - you should not add null checks on non-nullable types
  - output valid Dafny code

  COMMENT FORMAT: add this comment right before any code or annotation block in spec_impl_updated_i that you add or modify
  /* code modified by LLM (iteration {{iteration}}): [brief description] */
  
  ERROR DETAILS from Dafny verification of the given code:
  {errorDetails}

  Code Below:
  {code}
