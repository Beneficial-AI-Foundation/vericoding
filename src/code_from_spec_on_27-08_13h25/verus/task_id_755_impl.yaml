vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn min_spec(seq: Seq<i32>) -> (result: int)
      recommends
          0 < seq.len(),
      decreases seq.len(),
  {
      if seq.len() == 1 {
          seq[0] as int
      } else if seq.len() == 0 {
          0
      } else {
          let later_min = min_spec(seq.drop_first());
          if seq[0] <= later_min {
              seq[0] as int
          } else {
              later_min as int
          }
      }
  }
  // pure-end

vc-helpers: |-
  proof fn min_spec_correct(seq: Seq<i32>)
      requires
          seq.len() > 0,
      ensures
          forall|k: int| 0 <= k < seq.len() ==> min_spec(seq) <= seq[k],
          exists|k: int| 0 <= k < seq.len() && min_spec(seq) == seq[k],
      decreases seq.len(),
  {
      if seq.len() == 1 {
          assert(min_spec(seq) == seq[0]);
      } else {
          let later_min = min_spec(seq.drop_first());
          min_spec_correct(seq.drop_first());
          if seq[0] <= later_min {
              assert(min_spec(seq) == seq[0]);
              assert(forall|k: int| 0 <= k < seq.drop_first().len() ==> later_min <= seq.drop_first()[k]);
              assert(forall|k: int| 0 <= k < seq.len() ==> min_spec(seq) <= seq[k]);
          } else {
              assert(min_spec(seq) == later_min);
              assert(exists|k: int| 0 <= k < seq.drop_first().len() && later_min == seq.drop_first()[k]);
              assert(exists|k: int| 0 <= k < seq.len() && min_spec(seq) == seq[k]);
              assert(forall|k: int| 0 <= k < seq.len() ==> min_spec(seq) <= seq[k]);
          }
      }
  }
  
  proof fn min_spec_drop_first(seq: Seq<i32>, idx: int)
      requires
          seq.len() > 0,
          0 <= idx < seq.len(),
          seq[idx] == min_spec(seq),
      ensures
          idx == 0 || min_spec(seq.drop_first()) <= seq[idx],
      decreases seq.len(),
  {
      if seq.len() == 1 {
      } else {
          let later_min = min_spec(seq.drop_first());
          min_spec_correct(seq.drop_first());
          if seq[0] <= later_min {
              if idx == 0 {
              } else {
                  assert(min_spec(seq) == seq[0]);
              }
          } else {
              assert(min_spec(seq) == later_min);
              if idx > 0 {
                  min_spec_drop_first(seq.drop_first(), idx - 1);
              }
          }
      }
  }

vc-spec: |-
  fn second_smallest(numbers: &Vec<i32>) -> (indices: (usize, usize))
      // pre-conditions-start
      requires
          numbers.len() >= 2,
      // pre-conditions-end
      // post-conditions-start
      ensures
          forall|k: int|
              0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(
                  numbers@,
              ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),
          exists|k: int|
              0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]
                  == numbers[indices.1 as int]),
      // post-conditions-end

vc-code: |-
  {
      let mut min_idx: usize = 0;
      let mut second_min_idx: usize = 1;
  
      if numbers.len() > 1 && numbers[1] < numbers[0] {
          min_idx = 1;
          second_min_idx = 0;
      }
  
      let mut i: usize = 2;
      while i < numbers.len()
          invariant
              0 <= min_idx < numbers.len(),
              0 <= second_min_idx < numbers.len(),
              min_idx != second_min_idx,
              i <= numbers.len(),
              numbers[min_idx as int] == min_spec(numbers@.subrange(0, i as int)),
              forall|k: int| 0 <= k < i as int && k != min_idx as int ==> numbers[k] >= numbers[second_min_idx as int],
              exists|k: int| 0 <= k < i as int && k != min_idx as int && numbers[k] == numbers[second_min_idx as int],
          decreases numbers.len() - i,
      {
          if numbers[i] < numbers[min_idx as int] {
              second_min_idx = min_idx;
              min_idx = i;
          } else if numbers[i] < numbers[second_min_idx as int] {
              second_min_idx = i;
          }
          i = i + 1;
      }
  
      proof {
          min_spec_correct(numbers@);
      }
  
      (min_idx, second_min_idx)
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

