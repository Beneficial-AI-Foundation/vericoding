vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn seq_max(a: Seq<i32>) -> (ret: i32)
      decreases a.len(),
  {
      if a.len() == 0 {
          i32::MIN
      } else if a.last() > seq_max(a.drop_last()) {
          a.last()
      } else {
          seq_max(a.drop_last())
      }
  }

vc-helpers: |-
  spec fn seq_max(a: Seq<i32>) -> (ret: i32)
      decreases a.len()
  {
      if a.len() == 0 {
          i32::MIN
      } else if a.last() > seq_max(a.drop_last()) {
          a.last()
      } else {
          seq_max(a.drop_last())
      }
  }
  
  proof fn seq_max_monotonic(a: Seq<i32>, b: Seq<i32>)
      requires
          a.len() <= b.len(),
          forall|i: int| 0 <= i < a.len() ==> a[i] == b[i]
      ensures
          seq_max(a) <= seq_max(b)
      decreases b.len()
  {
      if a.len() == b.len() {
          assert(seq_max(a) == seq_max(b));
      } else if b.len() == 0 {
          assert(false);
      } else {
          let b_last = b.last();
          let b_prefix = b.drop_last();
          if a.len() == b_prefix.len() {
              seq_max_monotonic(a, b_prefix);
              if b_last > seq_max(b_prefix) {
                  assert(seq_max(a) <= b_last);
                  assert(seq_max(b) == b_last);
              } else {
                  assert(seq_max(b) == seq_max(b_prefix));
              }
          } else {
              seq_max_monotonic(a, b_prefix);
          }
      }
  }

vc-spec: |-
  fn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)
      // post-conditions-start
      ensures
          result.len() == numbers.len(),
          forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),
      // post-conditions-end

vc-code: |-
  fn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)
      ensures
          result.len() == numbers.len(),
          forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1))
  {
      let mut result = Vec::new();
      let mut i: usize = 0;
      let numbers_len = numbers.len();
  
      while i < numbers_len
          invariant
              i <= numbers_len,
              result.len() == i,
              forall|j: int| 0 <= j < i ==> result[j as usize] == seq_max(numbers@.take(j + 1))
      {
          if i == 0 {
              result.push(numbers[0]);
          } else {
              let prev_max = result[i - 1];
              let current_num = numbers[i];
              let current_max = if current_num > prev_max { current_num } else { prev_max };
              result.push(current_max);
          }
          proof {
              let current_seq = numbers@.take((i + 1) as int);
              let prev_seq = numbers@.take(i as int);
              if i > 0 {
                  seq_max_monotonic(prev_seq, current_seq);
                  assert(current_seq.last() == numbers@[i as int]);
                  assert(result[i as usize] == seq_max(current_seq));
              } else {
                  assert(current_seq.len() == 1);
                  assert(current_seq.last() == numbers@[0]);
                  assert(result[0] == seq_max(current_seq));
              }
          }
          i = i + 1;
      }
      result
  }

vc-postamble: |-
  
  fn main() {}
  }

