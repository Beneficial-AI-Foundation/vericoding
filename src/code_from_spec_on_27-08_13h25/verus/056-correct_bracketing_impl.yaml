vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn spec_bracketing_helper(brackets: Seq<char>) -> (result:(int, bool)) {
      brackets.fold_left(
          (0, true),
          |p: (int, bool), c|
              {
                  let (x, b) = p;
                  match (c) {
                      '<' => (x + 1, b),
                      '>' => (x - 1, b && x - 1 >= 0),
                      _ => (x, b),
                  }
              },
      )
  }
  // pure-end
  // pure-end
  
  spec fn spec_bracketing(brackets: Seq<char>) -> (result:bool) {
      let p = spec_bracketing_helper(brackets);
      p.1 && p.0 == 0
  }
  // pure-end

vc-helpers: |-
  proof fn bracketing_helper_matches_spec(brackets: Seq<char>)
      ensures
          spec_bracketing_helper(brackets).0 == brackets.fold_left(
              0,
              |x: int, c|
                  {
                      match (c) {
                          '<' => x + 1,
                          '>' => x - 1,
                          _ => x,
                      }
                  },
          ),
          spec_bracketing_helper(brackets).1 == brackets.fold_left(
              true,
              |b: bool, c|
                  {
                      let x = brackets.fold_left(
                          0,
                          |x: int, c|
                              {
                                  match (c) {
                                      '<' => x + 1,
                                      '>' => x - 1,
                                      _ => x,
                                  }
                              },
                      );
                      match (c) {
                          '<' => b,
                          '>' => b && x - 1 >= 0,
                          _ => b,
                      }
                  },
          )
  {
  }

vc-spec: |-
  fn correct_bracketing(brackets: &str) -> (ret: bool)
      // pre-conditions-start
      requires
          brackets@.len() <= i32::MAX,
          -brackets@.len() >= i32::MIN,
      // pre-conditions-end
      // post-conditions-start
      ensures
          ret <==> spec_bracketing(brackets@),
      // post-conditions-end

vc-code: |-
  {
      let mut count: i32 = 0;
      let mut valid: bool = true;
      let mut i: usize = 0;
      let bracket_seq = brackets@;
  
      while i < bracket_seq.len()
          invariant
              0 <= i <= bracket_seq.len(),
              count as int == bracket_seq.subrange(0, i as int).fold_left(
                  0,
                  |x: int, c|
                      {
                          match (c) {
                              '<' => x + 1,
                              '>' => x - 1,
                              _ => x,
                          }
                      },
              ),
              valid <==> bracket_seq.subrange(0, i as int).fold_left(
                  true,
                  |b: bool, c|
                      {
                          let x = bracket_seq.subrange(0, i as int).fold_left(
                              0,
                              |x: int, c|
                                  {
                                      match (c) {
                                          '<' => x + 1,
                                          '>' => x - 1,
                                          _ => x,
                                      }
                                  },
                          );
                          match (c) {
                              '<' => b,
                              '>' => b && x - 1 >= 0,
                              _ => b,
                          }
                      },
              ),
          decreases bracket_seq.len() - i
      {
          let c = bracket_seq[i];
          match c {
              '<' => { count = count + 1; },
              '>' => {
                  count = count - 1;
                  if count < 0 {
                      valid = false;
                  }
              },
              _ => {},
          }
          i = i + 1;
      }
  
      proof {
          bracketing_helper_matches_spec(bracket_seq);
      }
  
      valid && count == 0
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

