vc-description: |-


vc-preamble: |-
  
  use vstd::arithmetic::mul::*;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          1
      } else {
          n * factorial((n - 1) as nat)
      }
  }
  // pure-end
  // pure-end
  
  spec fn brazilian_factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          factorial(1)
      } else {
          factorial(n) * brazilian_factorial((n - 1) as nat)
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_factorial_positive(n: nat)
      ensures
          factorial(n) >= 1,
      decreases n,
  {
      if n == 0 {
      } else {
          lemma_factorial_positive((n - 1) as nat);
          assert(factorial(n) >= 1) by {
              broadcast use lemma_mul_strictly_positive;
          };
      }
  }
  
  proof fn lemma_brazilian_factorial_positive(n: nat)
      ensures
          brazilian_factorial(n) >= 1,
      decreases n,
  {
      if n == 0 {
      } else {
          lemma_factorial_positive(n);
          lemma_brazilian_factorial_positive((n - 1) as nat);
          assert(brazilian_factorial(n) >= 1) by {
              lemma_mul_strictly_positive(
                  factorial(n) as int,
                  brazilian_factorial((n - 1) as nat) as int,
              );
          };
      }
  }
  
  proof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)
      requires
          0 <= i <= j,
      ensures
          brazilian_factorial(i) <= brazilian_factorial(j),
      decreases j - i,
  {
      if i == j {
      } else if j == i + 1 {
          assert(factorial(j) >= 1) by { lemma_factorial_positive(j); };
          assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {
              broadcast use lemma_mul_increases;
          };
      } else {
          lemma_brazilian_fib_monotonic(i, (j - 1) as nat);
          lemma_brazilian_fib_monotonic((j - 1) as nat, j);
      }
  }
  
  proof fn lemma_factorial_u64_max(n: nat)
      ensures
          n > 20 ==> factorial(n) > u64::MAX as nat,
  {
      if n > 20 {
          assert(factorial(21) > u64::MAX as nat) by {
              broadcast use lemma_mul_strictly_increases;
          };
          if n > 21 {
              lemma_brazilian_fib_monotonic(21, n);
          }
      }
  }

vc-spec: |-
  fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)
      // post-conditions-start
      ensures
          match ret {
              None => brazilian_factorial(n as nat) > u64::MAX,
              Some(bf) => bf == brazilian_factorial(n as nat),
          },
      // post-conditions-end

vc-code: |-
  fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)
      ensures
          match ret {
              None => brazilian_factorial(n as nat) > u64::MAX,
              Some(bf) => bf == brazilian_factorial(n as nat),
          },
  {
      let mut result: u64 = 1;
      let mut i: u64 = 1;
      let mut current_factorial: u64 = 1;
  
      while i <= n
          invariant
              i <= n + 1,
              result == brazilian_factorial((i - 1) as nat) as u64,
              current_factorial == factorial((i - 1) as nat) as u64,
              brazilian_factorial((i - 1) as nat) <= u64::MAX,
              factorial((i - 1) as nat) <= u64::MAX,
      {
          if i > 20 {
              proof {
                  lemma_factorial_u64_max(i as nat);
              }
              return None;
          }
  
          let new_factorial = if i == 1 {
              1
          } else {
              if current_factorial > u64::MAX / i {
                  return None;
              }
              current_factorial * i
          };
  
          let new_result = if result > u64::MAX / new_factorial {
              return None;
          } else {
              result * new_factorial
          };
  
          result = new_result;
          current_factorial = new_factorial;
          i = i + 1;
      }
  
      Some(result)
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

