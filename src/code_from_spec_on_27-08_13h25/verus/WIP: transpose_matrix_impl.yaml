vc-description: |-


vc-preamble: |-
  #![crate_name = "transpose_matrix"]
  
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_vec_push<T>(v: &mut Vec<T>, elem: T)
      ensures
          v.len() == old(v).len() + 1,
  {
      v.push(elem);
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn transpose(matrix: Vec<Vec<i32>>) -> (result: Vec<Vec<i32>>)
      requires
          matrix.len() > 0,
          forall|i: int| #![trigger matrix[i]]
              0 <= i < matrix.len() ==> matrix[i].len() == matrix[0].len(),
          forall|i: int| #![trigger matrix[i]]
              0 <= i < matrix.len() ==> matrix[i].len() == matrix.len()
      ensures
          result.len() == matrix[0].len(),
          forall|i: int| #![trigger result[i]]
              0 <= i < result.len() ==> result[i].len() == matrix.len(),
          forall|i: int, j: int| #![trigger result[i], matrix[j]]
              0 <= i < result.len() && 0 <= j < result[i].len() ==> result[i][j] == matrix[j][i]

vc-code: |-
  {
      let n = matrix.len();
      let mut result: Vec<Vec<i32>> = Vec::new();
      let mut i: usize = 0;
  
      while i < n
          invariant
              0 <= i <= n,
              result.len() == i,
              forall|k: int| #![trigger result[k]]
                  0 <= k < i ==> result[k].len() == n,
              forall|k: int, l: int| #![trigger result[k], matrix[l]]
                  0 <= k < i && 0 <= l < n ==> result[k][l] == matrix[l][k],
      {
          let mut new_row: Vec<i32> = Vec::new();
          let mut j: usize = 0;
  
          while j < n
              invariant
                  0 <= j <= n,
                  new_row.len() == j,
                  forall|k: int| #![trigger new_row[k], matrix[k]]
                      0 <= k < j ==> new_row[k] == matrix[k][i],
          {
              new_row.push(matrix[j][i]);
              j = j + 1;
          }
  
          result.push(new_row);
          i = i + 1;
      }
  
      result
  }

vc-postamble: |-
  
  fn main() {}
  }

