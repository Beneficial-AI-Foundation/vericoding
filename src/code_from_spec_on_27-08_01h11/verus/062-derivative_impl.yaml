vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn spec_derivative(xs: Seq<usize>) -> Seq<usize> {
      if xs.len() == 0 {
          seq![]
      } else {
          xs.skip(1).map_values(|x: usize| (xs.index_of(x) + 1) * x)
      }
  }

vc-spec: |-
  fn derivative(xs: &Vec<usize>) -> (ret: Option<Vec<usize>>)
      // post-conditions-start
      ensures
          ret.is_some() ==> xs@.len() == 0 || xs@.map(|i: int, x| i * x).skip(1)
              =~= ret.unwrap()@.map_values(|x| x as int),
      // post-conditions-end

vc-code: |-
  {
      if xs.len() == 0 {
          return Some(Vec::new());
      }
      
      let mut result = Vec::new();
      let mut i = 1;
      
      while i < xs.len()
          invariant
              1 <= i <= xs@.len(),
              result@.len() == i - 1,
              forall|j: int| 0 <= j < i - 1 ==> result@[j] == (j + 1) * xs@[j + 1],
          decreases xs@.len() - i,
      {
          proof {
              assert(i < xs.len());
              assert(i >= 1);
          }
          let derivative_coeff = i * xs[i];
          result.push(derivative_coeff);
          i += 1;
      }
      
      Some(result)
  }

vc-postamble: |-
  
  }
  fn main() {}

