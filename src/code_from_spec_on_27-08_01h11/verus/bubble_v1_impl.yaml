vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  
  verus! {
  
  spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
          forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
      }
      // pure-end
  // pure-end
  
  spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
      &&& r.len() == s.len()
      &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
      &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
      &&& p =~= r.map_values(|i: int| s[i])
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_swap_preserves_multiset<T>(s: Seq<T>, i: int, j: int)
      requires 0 <= i < s.len(), 0 <= j < s.len()
      ensures s.update(i, s[j]).update(j, s[i]).to_multiset() =~= s.to_multiset()
  {
  }
  
  proof fn lemma_update_preserves_multiset<T>(s: Seq<T>, i: int, val: T)
      requires 0 <= i < s.len(), s[i] == val
      ensures s.update(i, val).to_multiset() =~= s.to_multiset()
  {
  }
  
  proof fn lemma_reorder_implies_multiset_eq<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>)
      requires is_reorder_of(r, p, s)
      ensures p.to_multiset() =~= s.to_multiset()
  {
  }
  
  spec fn min_index_from(a: Seq<u32>, from: int, to: int) -> (result: int) 
      recommends from < to, from >= 0, to <= a.len()
  {
      let min_val = seq_min(a, from, to);
      choose|i: int| from <= i < to && a[i] == min_val
  }
  
  spec fn seq_min(a: Seq<u32>, from: int, to: int) -> (result: u32)
      recommends from < to, from >= 0, to <= a.len()
  {
      if from + 1 == to {
          a[from]
      } else {
          let mid = from + (to - from) / 2;
          if seq_min(a, from, mid) <= seq_min(a, mid, to) {
              seq_min(a, from, mid)
          } else {
              seq_min(a, mid, to)
          }
      }
  }
  
  proof fn lemma_min_index_from_correct(a: Seq<u32>, from: int, to: int)
      requires from < to, from >= 0, to <= a.len()
      ensures 
          from <= min_index_from(a, from, to) < to,
          forall|i: int| from <= i < to ==> a[min_index_from(a, from, to)] <= a[i]
  {
  }
  
  fn find_min_index(nums: &Vec<u32>, from: usize, to: usize) -> (result: usize)
      requires from < to, to <= nums.len()
      ensures 
          from <= result < to,
          forall|i: int| from <= i < to ==> nums@[result as int] <= nums@[i],
          result == min_index_from(nums@, from as int, to as int)
  {
      let mut min_idx = from;
      let mut i = from + 1;
      
      while i < to
          invariant
              from <= min_idx < to,
              from < i <= to,
              forall|j: int| from <= j < i ==> nums@[min_idx as int] <= nums@[j],
      {
          if nums[i] < nums[min_idx] {
              min_idx = i;
          }
          i += 1;
      }
      
      proof {
          lemma_min_index_from_correct(nums@, from as int, to as int);
      }
      
      min_idx
  }
  
  fn swap_vec(v: &mut Vec<u32>, i: usize, j: usize)
      requires i < old(v).len(), j < old(v).len()
      ensures 
          v.len() == old(v).len(),
          v@[i as int] == old(v)@[j as int],
          v@[j as int] == old(v)@[i as int],
          forall|k: int| 0 <= k < v.len() && k != i && k != j ==> v@[k] == old(v)@[k],
          v@.to_multiset() =~= old(v)@.to_multiset()
  {
      let temp = v[i];
      let val_j = v[j];
      v.set(i, val_j);
      v.set(j, temp);
      
      proof {
          lemma_swap_preserves_multiset(old(v)@, i as int, j as int);
      }
  }

vc-spec: |-
  fn test1(nums: &mut Vec<u32>)
          // post-conditions-start
          ensures
              sorted_between(nums@, 0, nums@.len() as int),
              exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
          // post-conditions-end

vc-code: |-
  {
      let mut i = 0;
      let ghost mut reorder_seq: Seq<int> = Seq::new(nums.len() as nat, |j: int| j);
      
      while i < nums.len()
          invariant
              0 <= i <= nums.len(),
              sorted_between(nums@, 0, i as int),
              nums@.to_multiset() =~= old(nums)@.to_multiset(),
              is_reorder_of(reorder_seq, nums@, old(nums)@),
      {
          let min_idx = find_min_index(nums, i, nums.len());
          
          if min_idx != i {
              swap_vec(nums, i, min_idx);
              proof {
                  let old_reorder = reorder_seq;
                  let old_nums = old(nums)@;
                  reorder_seq = reorder_seq.update(i as int, reorder_seq[min_idx as int])
                                         .update(min_idx as int, reorder_seq[i as int]);
                  
                  assert(is_reorder_of(reorder_seq, nums@, old_nums));
              }
          }
          
          i += 1;
      }
      
      proof {
          lemma_reorder_implies_multiset_eq(reorder_seq, nums@, old(nums)@);
      }
  }

vc-postamble: |-
  
  }
  
  fn main() {}

