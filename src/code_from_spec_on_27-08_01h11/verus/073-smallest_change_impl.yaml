vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn zip_halves<T>(v: Seq<T>) -> (ret: Seq<(T, T)>) {
      v.take((v.len() / 2) as int).zip_with(v.skip(((v.len() + 1) / 2) as int).reverse())
  }
  // pure-end
  // pure-end
  
  spec fn diff(s: Seq<(i32, i32)>) -> (ret: int) {
      s.fold_left(
          0,
          |acc: int, x: (i32, i32)|
              if (x.0 != x.1) {
                  acc + 1
              } else {
                  acc
              },
      )
  }
  // pure-end

vc-helpers: |-
  proof fn zip_halves_len<T>(v: Seq<T>)
      ensures zip_halves(v).len() == (v.len() / 2) as int
  {
  }
  
  proof fn zip_halves_index<T>(v: Seq<T>, i: int)
      requires 0 <= i < zip_halves(v).len()
      ensures zip_halves(v)[i] == (
          v[i],
          v[v.len() as int - 1 - i]
      )
  {
  }
  
  proof fn fold_left_add_one(s: Seq<(i32, i32)>, i: int, acc: int)
      requires 0 <= i <= s.len()
      ensures s.take(i).fold_left(acc, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
          == acc + s.take(i).fold_left(0, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
  {
      if i == 0 {
          assert(s.take(i).len() == 0);
      } else {
          assert(i > 0);
          let s_head = s.take(i - 1);
          let elem = s[i - 1];
          fold_left_add_one(s, i - 1, acc);
          fold_left_add_one(s, i - 1, 0);
          if elem.0 != elem.1 {
              assert(s.take(i).fold_left(acc, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
                  == s_head.fold_left(acc, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc }) + 1);
              assert(s.take(i).fold_left(0, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
                  == s_head.fold_left(0, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc }) + 1);
          } else {
              assert(s.take(i).fold_left(acc, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
                  == s_head.fold_left(acc, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc }));
              assert(s.take(i).fold_left(0, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc })
                  == s_head.fold_left(0, |acc: int, x: (i32, i32)| if x.0 != x.1 { acc + 1 } else { acc }));
          }
      }
  }

vc-spec: |-
  fn smallest_change(v: Vec<i32>) -> (change: usize)
      // pre-conditions-start
      requires
          v@.len() < usize::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          change == diff(zip_halves(v@)),
      // post-conditions-end

vc-code: |-
  {
      let len = v.len();
      let half = len / 2;
      let mut change = 0usize;
      let mut i = 0usize;
      
      while i < half
          invariant
              0 <= i <= half,
              half <= len,
              len < usize::MAX,
              i < len,
              len - 1 - i < len,
              change <= usize::MAX - 1,
              change == diff(zip_halves(v@).take(i as int)),
          decreases half - i
      {
          let left_elem = v[i];
          let right_elem = v[len - 1 - i];
          
          if left_elem != right_elem {
              change = change + 1;
          }
          
          proof {
              let zipped = zip_halves(v@);
              zip_halves_index(v@, i as int);
              assert(i as int < zipped.len());
              assert(zipped[i as int] == (left_elem, right_elem));
              fold_left_add_one(zipped, (i + 1) as int, 0);
              if left_elem != right_elem {
                  assert(diff(zipped.take((i + 1) as int)) == diff(zipped.take(i as int)) + 1);
              } else {
                  assert(diff(zipped.take((i + 1) as int)) == diff(zipped.take(i as int)));
              }
          }
          
          i = i + 1;
      }
      
      proof {
          let zipped = zip_halves(v@);
          zip_halves_len(v@);
          assert(zipped.len() == half as int);
          assert(zipped.take(half as int) == zipped);
      }
      
      change
  }

vc-postamble: |-
  
  }
  fn main() {}

