vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn rotation_split(len: usize, n: usize) -> (result: int) {
      len - (n % len)
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_rotation_split_bounds(len: usize, n: usize)
      requires len > 0
      ensures 
          0 <= rotation_split(len, n) <= len,
          rotation_split(len, n) == len - (n % len)
  {
  }
  
  proof fn lemma_subrange_properties(s: Seq<u32>, i: int, j: int)
      requires 0 <= i <= j <= s.len()
      ensures s.subrange(i, j).len() == j - i
  {
  }
  
  proof fn lemma_index_bounds(list: &Vec<u32>, split_point: usize, i: usize)
      requires 
          list.len() > 0,
          split_point <= list.len(),
          i < list.len()
      ensures i < list@.len()
  {
  }
  
  proof fn lemma_vec_len_equals_seq_len(list: &Vec<u32>)
      ensures list.len() == list@.len()
  {
  }

vc-spec: |-
  fn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)
      // pre-conditions-start
      requires
          list.len() > 0,
      // pre-conditions-end
      // post-conditions-start
      ensures
          new_list.len() == list.len(),
          new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(
              list@.subrange(0, rotation_split(list.len(), n) as int),
          ),
      // post-conditions-end

vc-code: |-
  {
      let len = list.len();
      let split_point = len - (n % len);
      
      let mut new_list = Vec::new();
      
      proof {
          lemma_vec_len_equals_seq_len(list);
      }
      
      // Add elements from split_point to end
      let mut i = split_point;
      while i < len
          invariant
              0 <= i <= len,
              split_point <= len,
              len > 0,
              len == list@.len(),
              new_list.len() == i - split_point,
              forall|k: int| 0 <= k < new_list.len() ==> 
                  split_point + k < list@.len() && new_list@[k] == list@[split_point + k]
          decreases len - i
      {
          proof {
              assert(i < len);
              assert(len == list@.len());
              assert(i < list@.len());
          }
          new_list.push(list[i]);
          i += 1;
      }
      
      // Add elements from beginning to split_point
      let mut j = 0;
      while j < split_point
          invariant
              0 <= j <= split_point,
              split_point <= len,
              len > 0,
              len == list@.len(),
              new_list.len() == (len - split_point) + j,
              forall|k: int| 0 <= k < len - split_point ==> 
                  split_point + k < list@.len() && new_list@[k] == list@[split_point + k],
              forall|k: int| 0 <= k < j ==> 
                  len - split_point + k < new_list@.len() &&
                  k < list@.len() && 
                  new_list@[len - split_point + k] == list@[k]
          decreases split_point - j
      {
          proof {
              assert(j < split_point);
              assert(split_point <= len);
              assert(len == list@.len());
              assert(j < list@.len());
              assert(len - split_point + j == new_list@.len());
          }
          new_list.push(list[j]);
          j += 1;
      }
      
      proof {
          lemma_rotation_split_bounds(len, n);
          assert(new_list.len() == len);
          
          let right_part = list@.subrange(split_point as int, len as int);
          let left_part = list@.subrange(0, split_point as int);
          let expected = right_part.add(left_part);
          
          assert(new_list@ =~= expected);
      }
      
      new_list
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

