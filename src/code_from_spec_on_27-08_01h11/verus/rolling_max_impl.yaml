vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn seq_max(a: Seq<i32>) -> (ret: i32)
      decreases a.len(),
  {
      if a.len() == 0 {
          i32::MIN
      } else if a.last() > seq_max(a.drop_last()) {
          a.last()
      } else {
          seq_max(a.drop_last())
      }
  }

vc-helpers: |-
  spec fn seq_max_up_to(a: Seq<i32>, n: nat) -> i32
      decreases n
  {
      if n == 0 {
          i32::MIN
      } else if n <= a.len() && a[(n - 1) as int] > seq_max_up_to(a, (n - 1) as nat) {
          a[(n - 1) as int]
      } else if n <= a.len() {
          seq_max_up_to(a, (n - 1) as nat)
      } else {
          i32::MIN
      }
  }
  
  proof fn seq_max_equiv(a: Seq<i32>, n: nat)
      requires n <= a.len()
      ensures seq_max(a.take(n as int)) == seq_max_up_to(a, n)
      decreases n
  {
      if n == 0 {
          assert(a.take(0) == Seq::<i32>::empty());
      } else {
          seq_max_equiv(a, (n - 1) as nat);
          assert(a.take(n as int).last() == a[(n - 1) as int]);
          assert(a.take(n as int).drop_last() =~= a.take((n - 1) as int));
      }
  }
  
  proof fn seq_max_up_to_monotonic(a: Seq<i32>, n: nat, current_max: i32)
      requires 
          n <= a.len(),
          n > 0,
          current_max == seq_max_up_to(a, (n - 1) as nat)
      ensures seq_max_up_to(a, n) == if a[(n - 1) as int] > current_max { a[(n - 1) as int] } else { current_max }
      decreases n
  {
  }
  
  proof fn seq_max_base_case(a: Seq<i32>)
      requires a.len() > 0
      ensures seq_max(a.take(1)) == a[0]
  {
      assert(a.take(1).len() == 1);
      assert(a.take(1).last() == a[0]);
      assert(a.take(1).drop_last() == Seq::<i32>::empty());
      assert(seq_max(a.take(1).drop_last()) == i32::MIN);
  }

vc-spec: |-
  fn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)
      // post-conditions-start
      ensures
          result.len() == numbers.len(),
          forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),
      // post-conditions-end

vc-code: |-
  {
      let mut result = Vec::new();
      let mut current_max = i32::MIN;
      
      for i in 0..numbers.len()
          invariant
              result.len() == i,
              i <= numbers.len(),
              forall|j: int| 0 <= j < i ==> result[j] == seq_max(numbers@.take(j + 1)),
              current_max == if i == 0 { i32::MIN } else { seq_max(numbers@.take(i as int)) }
      {
          if i == 0 {
              current_max = numbers[0];
              proof {
                  seq_max_base_case(numbers@);
              }
          } else {
              let prev_max = current_max;
              if numbers[i] > current_max {
                  current_max = numbers[i];
              }
              proof {
                  assert(prev_max == seq_max(numbers@.take(i as int)));
                  seq_max_equiv(numbers@, i as nat);
                  assert(seq_max(numbers@.take(i as int)) == seq_max_up_to(numbers@, i as nat));
                  seq_max_up_to_monotonic(numbers@, (i + 1) as nat, seq_max_up_to(numbers@, i as nat));
                  assert(seq_max_up_to(numbers@, (i + 1) as nat) == if numbers[i] > prev_max { numbers[i] } else { prev_max });
                  assert(current_max == if numbers[i] > prev_max { numbers[i] } else { prev_max });
                  seq_max_equiv(numbers@, (i + 1) as nat);
                  assert(current_max == seq_max(numbers@.take((i + 1) as int)));
              }
          }
          
          result.push(current_max);
      }
      
      result
  }

vc-postamble: |-
  
  fn main() {}
  }

