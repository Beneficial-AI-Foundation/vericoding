vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn is_non_decreasing(s: Seq<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
  }
  
  spec fn is_non_increasing(s: Seq<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] >= s[j]
  }
  
  proof fn monotonic_empty_or_single(s: Seq<i32>)
      requires s.len() <= 1
      ensures is_non_decreasing(s) && is_non_increasing(s)
  {
  }
  
  proof fn transitive_helper_non_dec(s: Seq<i32>, i: int, j: int)
      requires
          0 <= i < j < s.len(),
          forall|k: int| 0 <= k < s.len() - 1 ==> #[trigger] s[k] <= s[k + 1]
      ensures s[i] <= s[j]
      decreases j - i
  {
      if i + 1 == j {
      } else {
          transitive_helper_non_dec(s, i, j - 1);
      }
  }
  
  proof fn transitive_helper_non_inc(s: Seq<i32>, i: int, j: int)
      requires
          0 <= i < j < s.len(),
          forall|k: int| 0 <= k < s.len() - 1 ==> #[trigger] s[k] >= s[k + 1]
      ensures s[i] >= s[j]
      decreases j - i
  {
      if i + 1 == j {
      } else {
          transitive_helper_non_inc(s, i, j - 1);
      }
  }
  
  proof fn monotonic_check_helper(s: Seq<i32>, non_dec: bool, non_inc: bool, len: int)
      requires 
          len == s.len(),
          len >= 2,
          non_dec ==> (forall|i: int| 0 <= i < len - 1 ==> #[trigger] s[i] <= s[i + 1]),
          non_inc ==> (forall|i: int| 0 <= i < len - 1 ==> #[trigger] s[i] >= s[i + 1]),
          non_dec || non_inc
      ensures is_non_decreasing(s) || is_non_increasing(s)
  {
      if non_dec {
          assert forall|i: int, j: int| 0 <= i < j < len implies s[i] <= s[j] by {
              transitive_helper_non_dec(s, i, j);
          };
      }
      if non_inc {
          assert forall|i: int, j: int| 0 <= i < j < len implies s[i] >= s[j] by {
              transitive_helper_non_inc(s, i, j);
          };
      }
  }

vc-spec: |-
  fn monotonic(l: Vec<i32>) -> (ret: bool)
      // post-conditions-start
      ensures
          ret <==> (forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) <= l@.index(j)) || (
          forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) >= l@.index(j)),
      // post-conditions-end

vc-code: |-
  {
      if l.len() <= 1 {
          proof {
              monotonic_empty_or_single(l@);
          }
          return true;
      }
  
      let mut non_decreasing = true;
      let mut non_increasing = true;
      let mut i = 0;
  
      while i < l.len() - 1
          invariant
              0 <= i <= l.len() - 1,
              non_decreasing ==> (forall|k: int| 0 <= k < i ==> l@[k] <= l@[k + 1]),
              non_increasing ==> (forall|k: int| 0 <= k < i ==> l@[k] >= l@[k + 1])
          decreases l.len() - 1 - i
      {
          if l[i] > l[i + 1] {
              non_decreasing = false;
          }
          if l[i] < l[i + 1] {
              non_increasing = false;
          }
          if !non_decreasing && !non_increasing {
              return false;
          }
          i += 1;
      }
  
      proof {
          if non_decreasing || non_increasing {
              monotonic_check_helper(l@, non_decreasing, non_increasing, l@.len() as int);
          }
      }
  
      true
  }

vc-postamble: |-
  
  }
  fn main() {}

