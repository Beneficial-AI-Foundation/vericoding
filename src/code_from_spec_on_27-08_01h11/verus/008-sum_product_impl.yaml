vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(0, |acc: int, x| acc + x)
  }
  // pure-end
  // pure-end
  
  spec fn product(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(1, |acc: int, x| acc * x)
  }
  // pure-end

vc-helpers: |-
  proof fn sum_bound(numbers: Seq<u32>)
      ensures
          sum(numbers) <= numbers.len() * u32::MAX,
      decreases numbers.len(),
  {
      if numbers.len() == 0 {
      } else {
          sum_bound(numbers.drop_last());
      }
  }
  
  proof fn product_overflow_lemma(numbers: Seq<u32>, i: int)
      requires 
          0 <= i < numbers.len(),
          numbers[i] as int * product(numbers.take(i as int)) > u32::MAX,
      ensures
          product(numbers) > u32::MAX,
      decreases numbers.len() - i,
  {
      let prefix = numbers.take(i as int);
      let current = numbers[i];
      let suffix = numbers.skip(i as int + 1);
      
      assert(numbers === prefix + seq![current] + suffix);
      assert(product(numbers) == product(prefix) * current * product(suffix));
      assert(product(prefix) * current > u32::MAX);
      assert(product(suffix) >= 1);
  }
  
  proof fn sum_u64_bound(numbers: Seq<u32>)
      ensures
          sum(numbers) <= u64::MAX,
  {
      sum_bound(numbers);
      assert(numbers.len() <= u32::MAX);
      assert(sum(numbers) <= numbers.len() * u32::MAX <= u32::MAX * u32::MAX);
  }
  
  proof fn sum_incremental(numbers: Seq<u32>, i: int)
      requires 
          0 <= i < numbers.len(),
      ensures
          sum(numbers.take(i as int + 1)) == sum(numbers.take(i as int)) + numbers[i],
  {
  }
  
  proof fn product_incremental(numbers: Seq<u32>, i: int)
      requires 
          0 <= i < numbers.len(),
      ensures
          product(numbers.take(i as int + 1)) == product(numbers.take(i as int)) * numbers[i],
  {
  }

vc-spec: |-
  fn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))
      // pre-conditions-start
      requires
          numbers.len() < u32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result.0 == sum(numbers@),
          result.1 matches Some(v) ==> v == product(numbers@),
      // post-conditions-end

vc-code: |-
  {
      let mut total_sum: u64 = 0;
      let mut total_product: u64 = 1;
      let mut product_overflow = false;
      
      proof {
          sum_u64_bound(numbers@);
      }
      
      for i in 0..numbers.len()
          invariant
              total_sum == sum(numbers@.take(i as int)),
              total_sum <= u64::MAX,
              !product_overflow ==> total_product == product(numbers@.take(i as int)),
              !product_overflow ==> total_product <= u32::MAX,
              product_overflow ==> product(numbers@.take(i as int)) > u32::MAX,
      {
          proof {
              sum_incremental(numbers@, i as int);
          }
          total_sum = total_sum + numbers[i] as u64;
          
          if !product_overflow {
              if numbers[i] > 0 && total_product > u32::MAX as u64 / numbers[i] as u64 {
                  product_overflow = true;
                  proof {
                      product_incremental(numbers@, i as int);
                      assert(product(numbers@.take(i as int + 1)) == total_product * numbers[i] as u64);
                      assert(total_product * numbers[i] as u64 > u32::MAX);
                  }
              } else {
                  proof {
                      product_incremental(numbers@, i as int);
                  }
                  total_product = total_product * numbers[i] as u64;
                  if total_product > u32::MAX as u64 {
                      product_overflow = true;
                  }
              }
          }
      }
      
      let final_product = if product_overflow {
          None
      } else {
          Some(total_product as u32)
      };
      
      (total_sum, final_product)
  }

vc-postamble: |-
  
  }
  fn main() {}

