vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  spec fn sum_bounds(b: &Vec<i32>, N: i32) -> bool {
      forall |k: int| 0 <= k < N ==> k <= #[trigger] b@[k] <= k + 1
  }
  
  proof fn lemma_sum_range(b: &Vec<i32>, N: i32, i: int)
      requires
          0 <= i < N,
          forall |k: int| 0 <= k < N ==> k <= #[trigger] b@[k] <= k + 1,
          i < b@.len(),
      ensures
          i <= b@[i] <= i + 1
  {
  }

vc-spec: |-
  fn simple_nested(a: &mut Vec<i32>, b: &Vec<i32>, N: i32) -> (sum: i32)
      // pre-conditions-start
      requires 
          forall |k:int| k <= #[trigger] b[k] <= k + 1,
          old(a).len() == N,
          b.len() == N,
          N <= 0x3FFF_FFFF,
      // pre-conditions-end
      // post-conditions-start
      ensures
          N <= sum <= 2*N,
      // post-conditions-end

vc-code: |-
  {
      let mut sum = 0;
      let mut i = 0;
      
      while i < N
          invariant
              0 <= i <= N,
              N >= 0,
              b.len() == N,
              forall |k: int| 0 <= k < N ==> k <= #[trigger] b@[k] <= k + 1,
              i <= sum <= 2 * i,
              sum <= 0x7FFF_FFFE,
          decreases N - i
      {
          proof {
              lemma_sum_range(b, N, i as int);
              assert(i <= b@[i as int] <= i + 1);
              assert(sum + i <= sum + b@[i as int] <= sum + i + 1);
              assert(sum + i + 1 <= 2 * (i + 1));
              assert(sum + b@[i as int] <= 2 * N);
          }
          sum = sum + b[i as usize];
          i = i + 1;
      }
      
      sum
  }

vc-postamble: |-
  
  }
  
  fn main() {}

