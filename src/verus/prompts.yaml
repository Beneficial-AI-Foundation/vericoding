generate_code: |
  The task is to generate implementations for `<vc-code>` sections in a Verus file.
  
  INPUT: a Verus file containing `<vc-code>` tags around placeholder implementations that need to be filled in.
  
  OUTPUT: Return a JSON array with one replacement for each `<vc-code>` section in the file, in order from top to bottom:
  ```json
  ["{\n    let mut low = 0;\n    // implementation here\n}", "{\n    // second implementation\n}"]
  ```
  
  CRITICAL RULES:
  - Provide exactly one replacement for each `<vc-code>` section in the file, in the exact order they appear (top to bottom)
  - Each replacement should be the exact code that will replace everything between the `<vc-code>` tags
  - Include opening/closing braces if they were in the original `<vc-code>` content
  - Do not use `assume` statements or `unimplemented!()` in replacements
  - Use valid Verus/Rust syntax for all implementations
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses)
  - Use Verus types like `nat`, `int`, `Vec<T>`, `Seq<T>`, etc.
  - Use `@` for sequence/vector indexing when needed (e.g., `v@[i]`)
  - Use proof blocks with `proof {{ ... }}` when necessary
  - Return ONLY a valid JSON array, no explanations or markdown
  
  VERUS FILE WITH <vc-code> SECTIONS:
  {code}

fix_verification: |
  INPUT: a Verus file containing one or more function definitions (including spec functions, helper functions, and main), possibly with incomplete or incorrect implementations that do not verify.
  - The file may include:
    - Standard Rust/Verus imports (e.g., `use vstd::prelude::*;`)
    - A `verus! {{ ... }}` block wrapping the code
    - Function definitions with `requires` and `ensures` clauses
    - `spec fn`, `fn`, and possibly proof blocks
    - Attributes such as `#[verifier::loop_isolation(false)]`
    - Helper/spec functions that may be used in ensures/requirements
    - A `fn main() {{}}` function (which should be preserved)
  - Function bodies may contain incomplete code, `unimplemented!()`, or TODO comments.

  OUTPUT: a verified Verus file of the same structure, but with all function bodies implemented or fixed so that they verify.
  - You may add proof annotations, helper functions, predicates, and spec functions as needed.
  - PRIORITY: If the error is a compilation error (syntax, type, resolution errors), fix it first before addressing verification issues.
  - For compilation errors: focus on syntax, missing brackets, type mismatches, undefined identifiers, and termination issues.
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses).
  - Use proof blocks with `proof {{ ... }}` for complex proofs.
  - Use `assert()` statements within proof blocks for intermediate steps.
  - Use Verus types and operators (`nat`, `int`, `Vec<T>`, `Seq<T>`, `@`, etc.).
  - Preserve all imports, structure, and helper/spec functions.
  - Maintain the `verus! {{ ... }}` block structure.
  - Use `@` for sequence/vector access (e.g., `v@[i]` for indexing).
  - Do not use `assume` statements in implementations.
  - Do not add trivial annotations (e.g., `requires true`, `invariant true`, `ensures true`).
  - Output valid Verus/Rust code.
  - Do not change the overall file structure (imports, main function, verus block).

  COMMENT FORMAT: add this comment right before any code or annotation block in a function body that you add or modify
  /* code modified by LLM (iteration {{iteration}}): [brief description] */
  
  ERROR DETAILS from Verus verification of the given code:
  {errorDetails}

  Code Below:
  {code}
