generate_code: |
  CRITICAL: Respond with ONLY a JSON array. No explanations, reasoning, or markdown. Start with [ and end with ].
  
  The task is to generate implementations for `<vc-code>` and `<vc-helpers>` sections in a Verus file.
  
  TURN 1 of {max_iterations}: This is the initial code generation phase. You have {max_iterations} total turns to get this right, so you can iterate and improve.
  
  INPUT: a Verus file containing {placeholder_count} placeholder sections (`<vc-code>` and/or `<vc-helpers>` tags) that need to be filled in.
  
  OUTPUT: Return a JSON array with EXACTLY {placeholder_count} replacements (one for each placeholder section in the file), in order from top to bottom:
  ```json
  ["fn min(a: int, b: int) -> int {{ if a < b {{ a }} else {{ b }} }}", "{{\n    let result = min(a, b);\n    result\n}}"]
  ```
  
  SECTION-SPECIFIC RULES:
  
  **For `<vc-helpers>` sections:**
  - Provide COMPLETE helper function/lemma definitions ONLY
  - Each helper should be a standalone function/predicate/lemma with proper signature
  - Example: `fn min(a: int, b: int) -> int {{ if a < b {{ a }} else {{ b }} }}`
  - Example: `spec fn is_valid(x: int) -> bool {{ x >= 0 }}`
  - Example: `proof fn helper_lemma(x: int) ensures x + 0 == x {{ }}`
  - DO NOT include method body code, variable assignments, or code fragments
  - DO NOT include opening/closing braces unless they're part of the function body
  
  **For `<vc-code>` sections:**
  - Provide method/function body implementation code ONLY
  - Always include opening/closing braces: `{{\n \n}}`
  - Example: `{{\n    let result = min(a, b);\n    result\n}}`
  - This is where you call helper functions and implement the main logic
  - Include variable declarations, assignments, and control flow
  
  CRITICAL RULES:
  - The ORIGINAL file contains EXACTLY {placeholder_count} placeholder sections - your JSON array must have EXACTLY {placeholder_count} elements
  - Provide exactly one replacement for each placeholder section in the file, in the exact order they appear (top to bottom)
  - Each replacement should be the exact code that will replace everything between the tags
  - NEVER use verification bypasses: `assume` statements, `unimplemented!()`, or other verification shortcuts
  - Implement actual proofs and logic instead of bypassing verification
  - Use valid Verus/Rust syntax for all implementations
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses)
  - IMPORTANT: Use each of `requires`, `ensures`, and `invariant` AT MOST ONCE per item
    - List multiple conditions as comma-separated entries on separate lines
    - Do NOT repeat `requires`/`ensures`/`invariant` keywords for additional lines
    - Prefer commas at line ends in spec blocks; avoid semicolons
  - While-loop header style (single invariant block):
    
    while CONDITION
        invariant
            INV1,
            INV2,
        decreases MEASURE
    {{
        // body
    }}
    
  - Function spec header style (single requires/ensures blocks):
    
    fn f(..) -> T
        requires
            PRE1,
            PRE2,
        ensures
            POST1,
            POST2,
    {{
        // body
    }}
  - Use Verus types like `nat`, `int`, `Vec<T>`, `Seq<T>`, etc.
  - Use `@` for sequence/vector indexing when needed (e.g., `v@[i]`)
  - Use proof blocks with `proof {{ ... }}` when necessary
  - Return ONLY a valid JSON array, no explanations or markdown
  - DO NOT include any reasoning, explanations, or commentary
  - DO NOT use markdown code blocks around the JSON
  - Your response must start with [ and end with ]
  - Each JSON string must be properly escaped with double quotes
  
  CRITICAL: Your entire response must be ONLY the JSON array. Any text before or after the JSON will cause parsing failure.
  
  CRITICAL: Do NOT use `assume`, `unimplemented!()`, or any verification bypasses. Implement real logic!
  
  VERUS FILE WITH PLACEHOLDER SECTIONS:
  {code}

fix_verification: |
  CRITICAL: Respond with ONLY a JSON array. No explanations, reasoning, or markdown. Start with [ and end with ].
  
  The task is to fix implementations in `<vc-code>` and `<vc-helpers>` sections that failed verification.
  
  TURN {iteration} of {max_iterations}: You are making progress and have multiple turns to iterate and improve your implementation.
  
  INPUT: The ORIGINAL file contains {placeholder_count} placeholder sections (`<vc-code>` and/or `<vc-helpers>` tags) that need to be fixed based on verification errors.
  
  OUTPUT: Return a JSON array with EXACTLY {placeholder_count} fixed replacements (one for each placeholder section in the ORIGINAL file), in order from top to bottom:
  ```json
  ["fn min(a: int, b: int) -> int {{ if a < b {{ a }} else {{ b }} }}", "{{\n    let result = min(a, b);\n    result\n}}"]
  ```
  
  SECTION-SPECIFIC RULES:
  
  **For `<vc-helpers>` sections:**
  - Provide COMPLETE helper function/lemma definitions ONLY
  - Each helper should be a standalone function/predicate/lemma with proper signature
  - Example: `fn min(a: int, b: int) -> int {{ if a < b {{ a }} else {{ b }} }}`
  - Example: `spec fn is_valid(x: int) -> bool {{ x >= 0 }}`
  - Example: `proof fn helper_lemma(x: int) ensures x + 0 == x {{ }}`
  - DO NOT include method body code, variable assignments, or code fragments
  - DO NOT include opening/closing braces unless they're part of the function body
  - Add comment `/* helper modified by LLM (iteration {iteration}): [brief description] */` before modified helpers
  
  **For `<vc-code>` sections:**
  - Provide method/function body implementation code ONLY
  - Always include opening/closing braces: `{{\n  \n}}`
  - Example: `{{\n    let result = min(a, b);\n    result\n}}`
  - This is where you call helper functions and implement the main logic
  - Include variable declarations, assignments, and control flow
  - Add comment `/* code modified by LLM (iteration {iteration}): [brief description] */` at the start of method body
  
  CRITICAL RULES:
  - The ORIGINAL file contains EXACTLY {placeholder_count} placeholder sections - your JSON array must have EXACTLY {placeholder_count} elements
  - Provide exactly one replacement for each placeholder section in the file, in the exact order they appear (top to bottom)
  - Each replacement should be the exact fixed code that will replace everything between the tags
  - PRIORITY: If the error is a compilation error (syntax, type, resolution errors), fix it first before addressing verification issues
  - Use proper Verus syntax: `requires`, `ensures`, `invariant`, `decreases` (without parentheses)
  - IMPORTANT: Use each of `requires`, `ensures`, and `invariant` AT MOST ONCE per item
    - List multiple conditions as comma-separated entries on separate lines
    - Do NOT repeat `requires`/`ensures`/`invariant` keywords for additional lines
    - Prefer commas at line ends in spec blocks; avoid semicolons
  - While-loop header style (single invariant block):
    
    while CONDITION
        invariant
            INV1,
            INV2,
        decreases MEASURE
    {{
        // body
    }}
    
  - Function spec header style (single requires/ensures blocks):
    
    fn f(..) -> T
        requires
            PRE1,
            PRE2,
        ensures
            POST1,
            POST2,
    {{
        // body
    }}
  - Use proof blocks with `proof {{ ... }}` for complex proofs
  - Use `assert()` statements within proof blocks for intermediate steps
  - Use Verus types and operators (`nat`, `int`, `Vec<T>`, `Seq<T>`, `@`, etc.)
  - NEVER use verification bypasses: `assume` statements, `unimplemented!()`, or other verification shortcuts
  - Implement actual proofs and logic instead of bypassing verification
  - Use `@` for sequence/vector indexing when needed (e.g., `v@[i]`)
  - Return ONLY a valid JSON array, no explanations or markdown
  - DO NOT include any reasoning, explanations, or commentary
  - DO NOT use markdown code blocks around the JSON
  - Your response must start with [ and end with ]
  - Each JSON string must be properly escaped with double quotes
  
  CRITICAL: Your entire response must be ONLY the JSON array. Any text before or after the JSON will cause parsing failure.
  
  CRITICAL: Do NOT use `assume`, `unimplemented!()`, or any verification bypasses. Implement real logic!
  
  ERROR DETAILS from Verus verification:
  {errorDetails}

  ORIGINAL FILE (for context):
  {original_code}

  CURRENT ITERATION FILE (with failed implementations to learn from):
  {code}
