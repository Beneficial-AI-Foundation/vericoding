vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  /* https://leetcode.com/problems/longest-substring-without-repeating-characters/
  Given a string s, find the length of the longest substring without repeating characters.
  
  Example 1:
  Input: s = "abcabcbb"
  Output: 3
  Explanation: The answer is "abc", with the length of 3.
  */
  
  
  // a left-inclusive right-exclusive interval:
  pub struct Interval {
      pub start: int,
      pub end: int,
  }
  
  impl Interval {
      pub open spec fn valid(self) -> bool {
          self.start <= self.end
      }
  }
  
  pub open spec fn length(iv: Interval) -> int {
      iv.end - iv.start
  }
  
  pub open spec fn valid_interval(s: Seq<char>, iv: Interval) -> bool {
      &&& 0 <= iv.start <= iv.end <= s.len()                             // interval is in valid range
      &&& forall|i: int, j: int| iv.start <= i < j < iv.end ==> s[i] != s[j]   // no repeating characters in interval
  }
  
  // Below shows an efficient solution using standard "sliding window" technique. 
  // For verification simplicity, we pretend as if:
  // - `set` were Python set (or even better, a fixed-size array -- if the "alphabet" is small)
  //
  // `best_iv` is for verification purpose, not returned by the real program, thus `ghost`.
  
  /* Discussions
  1. The "sliding window" technique is the most "fancy" part of the solution,
    ensuring an O(n) time despite the O(n^2) search space.
    The reason why it works lies in the last two invariants: (A) and (B).
  
    Invariant (A) is simply a "partial" guarantee for the longest valid substring in `s[..hi]`,
    so once the loop finishes, as `hi == |s|`, this "partial" guarantee becomes "full".
  
    Invariant (B) is crucial: it encodes why we can monotonically increase `lo` as we increase `hi`.
    What's the "intuition" behind that? Let me share an "informal proof" below:
  
      Let `sub(i)` be the longest valid substring whose last character is `s[i]`.
      Apparently, the final answer will be "the longest among the longests", i.e.
      `max(|sub(0)|, |sub(1)|, ..., |sub(|s|-1)|)`.
  
      Now, notice that the "starting position" of `sub(i)` is monotonically increasing regarding `i`!
      Otherwise, imagine `sub(i+1)` started at `j` while `sub(i)` started at `j+1` (or even worse),
      then `sub(i)` could be made longer (by starting at `j` instead).
      This is an obvious contradiction.
  
      Therefore, when we search for the starting position of `sub(i)` (the `lo`) for each `i` (the `hi`),
      there's no need to "look back".
  
  2. The solution above can be made more efficient, using "jumping window" instead of "sliding window".
    Namely, we use a dict (instead of set) to look up the "position of repetition",
    and move `lo` right after that position at once.
  
    You can even "early terminate" (based on `lo`) when all remaining intervals are doomed "no longer",
    resulting in even fewer number of loop iterations.
    (Time complexity will still be O(n), though.)
  
    The corresponding verification code is shown below:
  */
  
  
  // For verification simplicity, we pretend as if:
  // - `map` were Python dict (or even better, a fixed-size array -- if the "alphabet" is small)
  
  // Bonus Question:
  //   "Why can we safely use (C) instead of (D) as the loop condition? Won't `hi` go out-of-bound?"
  // Can you figure it out?

vc-helpers: |-
  pub open spec fn substring_has_no_repeats(s: Seq<char>, start: int, end: int) -> bool {
      forall|i: int, j: int| start <= i < j < end ==> s[i] != s[j]
  }
  
  pub open spec fn contains_char_in_range(s: Seq<char>, c: char, start: int, end: int) -> bool {
      exists|i: int| start <= i < end && s[i] == c
  }
  
  pub open spec fn max_valid_length_up_to(s: Seq<char>, hi: int) -> int
      decreases hi
  {
      if hi <= 0 {
          0
      } else {
          let prev_max = max_valid_length_up_to(s, hi - 1);
          let mut max_ending_here = 0;
          let mut start = 0;
          while start < hi 
              invariant 0 <= start <= hi
          {
              if valid_interval(s, Interval { start: start, end: hi }) {
                  if hi - start > max_ending_here {
                      max_ending_here = hi - start;
                  }
              }
              start = start + 1;
          }
          if max_ending_here > prev_max { max_ending_here } else { prev_max }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn lengthOfLongestSubstring(s: Seq<char>) -> (result: (usize, Ghost<Interval>))
      ensures 
          valid_interval(s, result.1@) && length(result.1@) == result.0 as int,    /** `result.1@` is valid */
          forall|iv: Interval| valid_interval(s, iv) ==> length(iv) <= result.0 as int,  /** `result.1@` is longest */
  // </vc-spec>

vc-code: |-
  {
      if s.len() == 0 {
          return (0, Ghost(Interval { start: 0, end: 0 }));
      }
  
      let mut lo: usize = 0;
      let mut hi: usize = 0;
      let mut best_len: usize = 0;
      let mut best_iv: Ghost<Interval> = Ghost(Interval { start: 0, end: 0 });
  
      while hi < s.len()
          invariant 
              0 <= lo <= hi <= s.len(),
              valid_interval(s, best_iv@),
              length(best_iv@) == best_len as int,
              forall|iv: Interval| valid_interval(s, iv) && iv.end <= hi ==> length(iv) <= best_len as int,
              hi > 0 ==> !contains_char_in_range(s, s[hi as int - 1], lo as int, hi as int - 1)
      {
          // Check if s[hi] appears in current window [lo, hi)
          let mut found_duplicate = false;
          let mut duplicate_pos: usize = lo;
          
          let mut i = lo;
          while i < hi
              invariant 
                  lo <= i <= hi,
                  found_duplicate ==> (lo <= duplicate_pos < i && s[duplicate_pos as int] == s[hi as int]),
                  !found_duplicate ==> forall|j: int| lo <= j < i ==> s[j] != s[hi as int]
          {
              if s[i as int] == s[hi as int] {
                  found_duplicate = true;
                  duplicate_pos = i;
                  break;
              }
              i = i + 1;
          }
  
          if found_duplicate {
              // Move lo to right after the duplicate
              lo = duplicate_pos + 1;
          }
  
          // Now [lo, hi+1) is a valid interval
          let current_len = hi + 1 - lo;
          if current_len > best_len {
              best_len = current_len;
              best_iv = Ghost(Interval { start: lo as int, end: (hi + 1) as int });
          }
  
          hi = hi + 1;
      }
  
      (best_len, best_iv)
  }
  
  fn main() {}

vc-postamble: |-
  
  fn main() {}
  
  }

