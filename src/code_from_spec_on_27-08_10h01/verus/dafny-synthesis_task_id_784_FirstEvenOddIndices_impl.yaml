vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_even(n: int) -> bool {
      n % 2 == 0
  }
  
  spec fn is_odd(n: int) -> bool {
      n % 2 != 0
  }
  
  spec fn is_first_even(even_index: int, lst: Seq<i32>) -> bool
      recommends 0 <= even_index < lst.len(), is_even(lst[even_index] as int)
  {
      forall|i: int| 0 <= i < even_index ==> is_odd(lst[i] as int)
  }
  
  spec fn is_first_odd(odd_index: int, lst: Seq<i32>) -> bool
      recommends 0 <= odd_index < lst.len(), is_odd(lst[odd_index] as int)
  {
      forall|i: int| 0 <= i < odd_index ==> is_even(lst[i] as int)
  }

vc-helpers: |-
  proof fn lemma_is_first_even_unique(lst: Seq<i32>, i: int, j: int)
      requires 0 <= i < lst.len(),
               0 <= j < lst.len(),
               is_even(lst[i] as int),
               is_even(lst[j] as int),
               is_first_even(i, lst),
               is_first_even(j, lst)
      ensures i == j
  {
      if i != j {
          if i < j {
              assert(is_odd(lst[i] as int));
              assert(is_even(lst[i] as int));
              assert(false);
          } else {
              assert(is_odd(lst[j] as int));
              assert(is_even(lst[j] as int));
              assert(false);
          }
      }
  }
  
  proof fn lemma_is_first_odd_unique(lst: Seq<i32>, i: int, j: int)
      requires 0 <= i < lst.len(),
               0 <= j < lst.len(),
               is_odd(lst[i] as int),
               is_odd(lst[j] as int),
               is_first_odd(i, lst),
               is_first_odd(j, lst)
      ensures i == j
  {
      if i != j {
          if i < j {
              assert(is_even(lst[i] as int));
              assert(is_odd(lst[i] as int));
              assert(false);
          } else {
              assert(is_even(lst[j] as int));
              assert(is_odd(lst[j] as int));
              assert(false);
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn first_even_odd_indices(lst: Vec<i32>) -> (result: (usize, usize))
      requires lst.len() >= 2,
               exists|i: int| 0 <= i < lst.len() && is_even(lst[i] as int),
               exists|i: int| 0 <= i < lst.len() && is_odd(lst[i] as int)
      ensures 0 <= result.0 < lst.len(),
              0 <= result.1 < lst.len(),
              // This is the postcondition that ensures that it's the first, not just any
              is_even(lst[result.0 as int] as int) && is_first_even(result.0 as int, lst@),
              is_odd(lst[result.1 as int] as int) && is_first_odd(result.1 as int, lst@)
  // </vc-spec>

vc-code: |-
  {
      let mut first_even_idx: Option<usize> = None;
      let mut first_odd_idx: Option<usize> = None;
      
      let mut i = 0;
      while i < lst.len()
          invariant 
              0 <= i <= lst.len(),
              first_even_idx.is_some() ==> (
                  0 <= first_even_idx.unwrap() < lst.len() &&
                  is_even(lst[first_even_idx.unwrap() as int] as int) &&
                  is_first_even(first_even_idx.unwrap() as int, lst@)
              ),
              first_odd_idx.is_some() ==> (
                  0 <= first_odd_idx.unwrap() < lst.len() &&
                  is_odd(lst[first_odd_idx.unwrap() as int] as int) &&
                  is_first_odd(first_odd_idx.unwrap() as int, lst@)
              ),
              first_even_idx.is_none() ==> (forall|j: int| 0 <= j < i ==> is_odd(lst[j] as int)),
              first_odd_idx.is_none() ==> (forall|j: int| 0 <= j < i ==> is_even(lst[j] as int)),
              first_even_idx.is_some() && first_odd_idx.is_some() ==> (
                  first_even_idx.unwrap() < i && first_odd_idx.unwrap() < i
              )
      {
          let ghost current_val = lst@[i as int] as int;
          
          if first_even_idx.is_none() {
              proof {
                  if is_even(current_val) {
                      // This will be the first even index
                  }
              }
              if is_even(current_val) {
                  first_even_idx = Some(i);
              }
          }
          
          if first_odd_idx.is_none() {
              proof {
                  if is_odd(current_val) {
                      // This will be the first odd index
                  }
              }
              if is_odd(current_val) {
                  first_odd_idx = Some(i);
              }
          }
          
          if first_even_idx.is_some() && first_odd_idx.is_some() {
              return (first_even_idx.unwrap(), first_odd_idx.unwrap());
          }
          
          i += 1;
      }
      
      (first_even_idx.unwrap(), first_odd_idx.unwrap())
  }

vc-postamble: |-
  
  fn main() {}
  
  }

