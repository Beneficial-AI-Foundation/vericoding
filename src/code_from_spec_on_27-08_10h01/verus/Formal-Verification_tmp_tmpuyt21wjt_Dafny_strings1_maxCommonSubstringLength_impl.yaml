vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool {
      (pre.len() > str.len()) || 
      pre != str.subrange(0, pre.len() as int)
  }
  
  fn is_prefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures 
          !res <==> is_not_prefix_pred(pre, str),
          res <==> is_prefix_predicate(pre, str),
  {
      assume(false);
      true
  }
  
  spec fn is_prefix_predicate(pre: Seq<char>, str: Seq<char>) -> bool {
      str.len() >= pre.len() && pre == str.subrange(0, pre.len() as int)
  }
  
  spec fn is_substring_predicate(sub: Seq<char>, str: Seq<char>) -> bool {
      str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && is_prefix_predicate(sub, str.subrange(i, str.len() as int)))
  }
  
  fn is_substring(sub: Seq<char>, str: Seq<char>) -> (res: bool)
      ensures res == is_substring_predicate(sub, str),
  {
      assume(false);
      true
  }
  
  spec fn have_common_k_substring_predicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {
      str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && is_substring_predicate((str1.subrange(i, str1.len() as int)).subrange(0, k as int), str2))
  }
  
  fn have_common_k_substring(k: usize, str1: Seq<char>, str2: Seq<char>) -> (found: bool)
      requires k <= usize::MAX,
      ensures 
          (str1.len() < k || str2.len() < k) ==> !found,
          have_common_k_substring_predicate(k as nat, str1, str2) == found,
  {
      assume(false);
      true
  }
  
  spec fn max_common_substring_predicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool {
      forall|k: int| len < k <= str1.len() ==> !#[trigger] have_common_k_substring_predicate(k as nat, str1, str2)
  }

vc-helpers: |-
  proof fn lemma_is_prefix_correct(pre: Seq<char>, str: Seq<char>)
      ensures is_prefix_predicate(pre, str) == !is_not_prefix_pred(pre, str)
  {
      if pre.len() > str.len() {
          assert(!is_prefix_predicate(pre, str));
          assert(is_not_prefix_pred(pre, str));
      } else {
          if pre == str.subrange(0, pre.len() as int) {
              assert(is_prefix_predicate(pre, str));
              assert(!is_not_prefix_pred(pre, str));
          } else {
              assert(!is_prefix_predicate(pre, str));
              assert(is_not_prefix_pred(pre, str));
          }
      }
  }
  
  proof fn lemma_max_common_decreases(str1: Seq<char>, str2: Seq<char>, len: nat)
      requires len <= str1.len() && len <= str2.len()
      ensures len == 0 ==> max_common_substring_predicate(str1, str2, len)
  {
      if len == 0 {
          assert(forall|k: int| 0 < k <= str1.len() ==> !have_common_k_substring_predicate(k as nat, str1, str2) || have_common_k_substring_predicate(k as nat, str1, str2));
      }
  }
  
  proof fn lemma_common_substring_monotonic(k1: nat, k2: nat, str1: Seq<char>, str2: Seq<char>)
      requires k1 <= k2
      ensures have_common_k_substring_predicate(k2, str1, str2) ==> have_common_k_substring_predicate(k1, str1, str2) || k1 == 0
  {
  }

vc-spec: |-
  // <vc-spec>
  fn max_common_substring_length(str1: Seq<char>, str2: Seq<char>) -> (len: usize)
      ensures 
          len <= str1.len() && len <= str2.len(),
          len >= 0,
          max_common_substring_predicate(str1, str2, len as nat),
  // </vc-spec>

vc-code: |-
  {
      let mut len: usize = 0;
      let max_len_nat = if str1.len() < str2.len() { str1.len() } else { str2.len() };
      let max_len: usize = max_len_nat as usize;
      
      while len <= max_len
          invariant 
              len <= max_len + 1,
              max_len <= str1.len() && max_len <= str2.len(),
              forall|k: int| len <= k <= str1.len() ==> !have_common_k_substring_predicate(k as nat, str1, str2) || k < len as int,
      {
          if len == max_len + 1 {
              break;
          }
          
          if len == 0 {
              len = len + 1;
              continue;
          }
          
          let found = have_common_k_substring(len, str1, str2);
          
          if !found {
              len = len - 1;
              break;
          }
          
          len = len + 1;
      }
      
      if len > max_len {
          len = max_len;
      }
      
      len
  }

vc-postamble: |-
  fn main() {}
  
  }

