vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted(a: &[int]) -> bool {
      forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] <= a[k]
  }

vc-helpers: |-
  spec fn all_elements_less_than(a: &[int], end: int, value: int) -> bool {
      forall|i: int| 0 <= i < end ==> a[i] < value
  }
  
  spec fn all_elements_greater_than(a: &[int], start: int, value: int) -> bool {
      forall|i: int| start <= i < a.len() ==> a[i] > value
  }
  
  proof fn sorted_implies_partitioned(a: &[int], mid: int, value: int)
      requires
          sorted(a),
          0 <= mid < a.len(),
          a[mid] < value,
      ensures
          all_elements_less_than(a, mid + 1, value)
  {
      assert forall|i: int| 0 <= i <= mid implies a[i] <= a[mid] by {
          if 0 <= i <= mid {
              if i == mid {
                  assert(a[i] <= a[mid]);
              } else if i < mid {
                  assert(a[i] <= a[mid]);
              }
          }
      }
  }
  
  proof fn sorted_implies_partitioned_greater(a: &[int], mid: int, value: int)
      requires
          sorted(a),
          0 <= mid < a.len(),
          a[mid] > value,
      ensures
          all_elements_greater_than(a, mid, value)
  {
      assert forall|i: int| mid <= i < a.len() implies a[mid] <= a[i] by {
          if mid <= i < a.len() {
              if i == mid {
                  assert(a[mid] <= a[i]);
              } else if mid < i {
                  assert(a[mid] <= a[i]);
              }
          }
      }
  }
  
  proof fn empty_range_properties(a: &[int], value: int)
      ensures
          all_elements_less_than(a, 0, value),
          all_elements_greater_than(a, a.len() as int, value)
  {
      assert forall|i: int| 0 <= i < 0 implies a[i] < value by {};
      assert forall|i: int| a.len() <= i < a.len() implies a[i] > value by {};
  }

vc-spec: |-
  // <vc-spec>
  fn binary_search(a: &[int], value: int) -> (index: i32)
      requires 
          sorted(a),
      ensures 
          0 <= index ==> index < a.len() && a[index as int] == value,
          index < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != value,
  // </vc-spec>

vc-code: |-
  {
      let mut left = 0i32;
      let mut right = (#[verifier::truncate] a.len()) as i32;
      
      proof {
          empty_range_properties(a, value);
          assert(0 <= left);
          assert(left <= right);
          assert(right <= a.len());
      }
      
      while left < right
          invariant
              0 <= left <= right <= a.len(),
              all_elements_less_than(a, left as int, value),
              all_elements_greater_than(a, right as int, value),
              sorted(a),
          decreases right - left
      {
          let mid = left + (right - left) / 2;
          
          if a[mid as usize] == value {
              return mid;
          } else if a[mid as usize] < value {
              proof {
                  sorted_implies_partitioned(a, mid as int, value);
              }
              left = mid + 1;
          } else {
              proof {
                  sorted_implies_partitioned_greater(a, mid as int, value);
              }
              right = mid;
          }
      }
      
      -1
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

