vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn count(hi: nat, s: Seq<int>) -> int
      recommends 0 <= hi <= s.len()
      decreases hi
  {
      if hi == 0 {
          0
      } else if s[hi-1] % 2 == 0 {
          1 + count((hi-1) as nat, s)
      } else {
          count((hi-1) as nat, s)
      }
  }

vc-helpers: |-
  proof fn count_monotonic(hi1: nat, hi2: nat, s: Seq<int>)
      requires hi1 <= hi2 <= s.len()
      ensures count(hi1, s) <= count(hi2, s)
      decreases hi2 - hi1
  {
      if hi1 == hi2 {
          return;
      }
      count_monotonic(hi1, hi2 - 1, s);
  }
  
  proof fn count_step_lemma(hi: nat, s: Seq<int>)
      requires hi > 0 && hi <= s.len()
      ensures count(hi, s) == count(hi - 1, s) + (if s[hi - 1] % 2 == 0 { 1 } else { 0 })
  {
  }
  
  proof fn count_at_zero(s: Seq<int>)
      ensures count(0, s) == 0
  {
  }

vc-spec: |-
  // <vc-spec>
  fn compute_count(count_index: usize, a: Seq<int>, b: &mut Vec<int>) -> (p: usize)
      requires count_index == 0 || (a.len() == old(b).len() && 1 <= count_index <= a.len())
      ensures p == count(count_index as nat, a)
  // </vc-spec>

vc-code: |-
  {
      let mut i = count_index;
      let mut result = 0;
      
      proof {
          count_at_zero(a);
      }
      
      while i > 0
          invariant 
              i <= count_index,
              result + count(i as nat, a) == count(count_index as nat, a),
              i <= a.len()
          decreases i
      {
          proof {
              count_step_lemma(i as nat, a);
          }
          if a[i - 1] % 2 == 0 {
              result = result + 1;
          }
          i = i - 1;
      }
      
      result
  }

vc-postamble: |-
  fn main() {
  }
  
  }

