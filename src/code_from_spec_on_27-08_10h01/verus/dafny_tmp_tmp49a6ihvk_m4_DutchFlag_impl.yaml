vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  #[derive(PartialEq, Eq, Clone, Copy)]
  enum Color {
      Red,
      White,
      Blue,
  }
  
  spec fn below(c: Color, d: Color) -> bool {
      c == Color::Red || c == d || d == Color::Blue
  }

vc-helpers: |-
  spec fn is_sorted_by_below(s: Seq<Color>) -> bool {
      forall|i: int, j: int| 0 <= i < j < s.len() ==> below(s[i], s[j])
  }
  
  spec fn partition_invariant(s: Seq<Color>, red_end: int, blue_start: int) -> bool {
      &&& 0 <= red_end <= blue_start <= s.len()
      &&& forall|i: int| 0 <= i < red_end ==> s[i] == Color::Red
      &&& forall|i: int| blue_start <= i < s.len() ==> s[i] == Color::Blue
      &&& forall|i: int| red_end <= i < blue_start ==> s[i] == Color::White
  }
  
  proof fn partition_implies_sorted(s: Seq<Color>, red_end: int, blue_start: int)
      requires partition_invariant(s, red_end, blue_start)
      ensures is_sorted_by_below(s)
  {
      assert forall|i: int, j: int| 0 <= i < j < s.len() implies below(s[i], s[j]) by {
          if 0 <= i < j < s.len() {
              if i < red_end {
                  assert(s[i] == Color::Red);
                  assert(below(s[i], s[j]));
              } else if j >= blue_start {
                  assert(s[j] == Color::Blue);
                  assert(below(s[i], s[j]));
              } else {
                  assert(red_end <= i < blue_start);
                  assert(red_end <= j < blue_start);
                  assert(s[i] == Color::White);
                  assert(s[j] == Color::White);
                  assert(below(s[i], s[j]));
              }
          }
      }
  }
  
  fn swap_colors(a: &mut Vec<Color>, i: usize, j: usize)
      requires i < old(a).len(), j < old(a).len()
      ensures 
          a.len() == old(a).len(),
          a@[i as int] == old(a)@[j as int],
          a@[j as int] == old(a)@[i as int],
          forall|k: int| 0 <= k < a.len() && k != i && k != j ==> a@[k] == old(a)@[k],
          a@.to_multiset() == old(a)@.to_multiset()
  {
      proof {
          let ghost old_a = old(a)@;
          let ghost i_val = old_a[i as int];
          let ghost j_val = old_a[j as int];
          
          assert(old_a.to_multiset().count(i_val) >= 1);
          assert(old_a.to_multiset().count(j_val) >= 1);
      }
      
      let temp = a[i];
      let val_j = a[j];
      a.set(i, val_j);
      a.set(j, temp);
      
      proof {
          let ghost new_a = a@;
          let ghost old_a = old(a)@;
          
          assert(new_a.to_multiset() =~= old_a.to_multiset()) by {
              assert forall|color: Color| new_a.to_multiset().count(color) == old_a.to_multiset().count(color) by {
                  if i == j {
                      assert(new_a =~= old_a);
                  } else {
                      let ghost old_i_val = old_a[i as int];
                      let ghost old_j_val = old_a[j as int];
                      
                      if old_i_val == old_j_val {
                          assert(new_a =~= old_a);
                      } else {
                          if color == old_i_val {
                              assert(new_a.to_multiset().count(color) == old_a.to_multiset().count(color));
                          } else if color == old_j_val {
                              assert(new_a.to_multiset().count(color) == old_a.to_multiset().count(color));
                          } else {
                              assert(new_a.to_multiset().count(color) == old_a.to_multiset().count(color));
                          }
                      }
                  }
              }
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn dutch_flag(a: &mut Vec<Color>)
      ensures 
          forall|i: int, j: int| 0 <= i < j < a.len() ==> below(a[i], a[j]),
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  {
      let mut red_end = 0;
      let mut blue_start = a.len();
      let mut current = 0;
      
      let ghost original_multiset = a@.to_multiset();
      
      while current < blue_start
          invariant
              0 <= red_end <= current <= blue_start <= a.len(),
              forall|i: int| 0 <= i < red_end ==> a[i] == Color::Red,
              forall|i: int| blue_start <= i < a.len() ==> a[i] == Color::Blue,
              forall|i: int| red_end <= i < current ==> a[i] == Color::White,
              a@.to_multiset() == original_multiset,
          decreases blue_start - current
      {
          match a[current] {
              Color::Red => {
                  swap_colors(a, current, red_end);
                  red_end += 1;
                  current += 1;
              }
              Color::White => {
                  current += 1;
              }
              Color::Blue => {
                  blue_start -= 1;
                  swap_colors(a, current, blue_start);
              }
          }
      }
      
      proof {
          assert(partition_invariant(a@, red_end as int, blue_start as int));
          partition_implies_sorted(a@, red_end as int, blue_start as int);
          assert(a@.to_multiset() == original_multiset);
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

