vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Function
  spec fn find_max(x: int, y: int) -> int {
      if x > y { x } else { y }
  }

vc-helpers: |-
  spec fn is_increasing_subseq(nums: Seq<i32>, indices: Seq<int>) -> bool {
      &&& indices.len() > 0
      &&& (forall|i: int| 0 <= i < indices.len() ==> 0 <= indices[i] < nums.len())
      &&& (forall|i: int| 0 <= i < indices.len() - 1 ==> indices[i] < indices[i + 1])
      &&& (forall|i: int| 0 <= i < indices.len() - 1 ==> nums[indices[i]] < nums[indices[i + 1]])
  }
  
  spec fn lis_length_ending_at(nums: Seq<i32>, pos: int) -> int
      decreases pos
  {
      if pos < 0 || pos >= nums.len() {
          1
      } else {
          lis_length_ending_at_helper(nums, pos, 0, 1)
      }
  }
  
  spec fn lis_length_ending_at_helper(nums: Seq<i32>, pos: int, i: int, max_len: int) -> int
      decreases pos - i
  {
      if i >= pos {
          max_len
      } else {
          let new_max = if nums[i] < nums[pos] {
              let len = 1 + lis_length_ending_at(nums, i);
              if len > max_len { len } else { max_len }
          } else {
              max_len
          };
          lis_length_ending_at_helper(nums, pos, i + 1, new_max)
      }
  }
  
  spec fn lis_length(nums: Seq<i32>) -> int
      decreases nums.len()
  {
      if nums.len() == 0 {
          0
      } else {
          let max_ending_here = lis_length_ending_at(nums, (nums.len() - 1) as int);
          let max_not_ending_here = lis_length(nums.drop_last());
          if max_ending_here > max_not_ending_here {
              max_ending_here
          } else {
              max_not_ending_here
          }
      }
  }
  
  proof fn lis_length_positive(nums: Seq<i32>)
      requires nums.len() > 0
      ensures lis_length(nums) >= 1
  {
  }

vc-spec: |-
  // <vc-spec>
  fn longest_increasing_subsequence(nums: &Vec<i32>) -> (max: i32)
      requires 
          1 <= nums.len() <= 2500,
          forall|i: int| 0 <= i < nums.len() ==> #[trigger] nums[i] >= -10000 && #[trigger] nums[i] <= 10000,
      // TODO: modify the ensures clause so that max is indeed equal to the longest increasing subsequence
      ensures 
          max >= 1,
  // </vc-spec>

vc-code: |-
  {
      let n = nums.len();
      let mut dp: Vec<i32> = Vec::new();
      let mut i: usize = 0;
      
      while i < n
          invariant 
              0 <= i <= n,
              dp.len() == i,
              forall|j: int| 0 <= j < i ==> dp@[j] >= 1
      {
          let mut max_len: i32 = 1;
          let mut j: usize = 0;
          
          while j < i
              invariant 
                  0 <= j <= i,
                  max_len >= 1
          {
              if nums@[j as int] < nums@[i as int] && dp@[j as int] + 1 > max_len {
                  max_len = dp@[j as int] + 1;
              }
              j += 1;
          }
          
          dp.push(max_len);
          i += 1;
      }
      
      let mut max_lis: i32 = 1;
      let mut k: usize = 0;
      
      while k < n
          invariant 
              0 <= k <= n,
              max_lis >= 1,
              forall|j: int| 0 <= j < k ==> dp@[j] <= max_lis
      {
          if dp@[k as int] > max_lis {
              max_lis = dp@[k as int];
          }
          k += 1;
      }
      
      max_lis
  }

vc-postamble: |-
  fn main() {
  }
  
  }

