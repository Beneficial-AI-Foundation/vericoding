vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  proof fn lemma_set_count_equals_loop_count(a: Seq<int>, b: Seq<int>, c: Seq<int>, count: usize)
      requires
          a.len() == b.len() && b.len() == c.len(),
          count == ({
              let mut i = 0nat;
              let mut result = 0;
              while i < a.len() {
                  if a[i as int] == b[i as int] && b[i as int] == c[i as int] {
                      result = result + 1;
                  }
                  i = i + 1;
              }
              result
          } as usize),
      ensures
          count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len(),
  {
      let target_set = Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]);
      
      let mut i = 0nat;
      let mut counted: usize = 0;
      let mut seen_set = Set::<int>::empty();
      
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              counted == seen_set.len(),
              seen_set == Set::<int>::new(|j: int| 0 <= j < i && a[j] == b[j] && b[j] == c[j]),
              seen_set.subset_of(target_set),
      {
          if a[i as int] == b[i as int] && b[i as int] == c[i as int] {
              counted = counted + 1;
              seen_set = seen_set.insert(i as int);
          }
          i = i + 1;
      }
      
      assert(seen_set == target_set);
      assert(counted == target_set.len());
  }

vc-spec: |-
  // <vc-spec>
  fn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: usize)
      requires
          a.len() == b.len() && b.len() == c.len(),
      ensures
          count >= 0,
          count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len(),
  // </vc-spec>

vc-code: |-
  {
      let mut count = 0;
      let mut i = 0nat;
      
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              count == Set::<int>::new(|j: int| 0 <= j < i && a[j] == b[j] && b[j] == c[j]).len(),
      {
          if a[i as int] == b[i as int] && b[i as int] == c[i as int] {
              count = count + 1;
          }
          i = i + 1;
      }
      
      proof {
          let final_set = Set::<int>::new(|j: int| 0 <= j < a.len() && a[j] == b[j] && b[j] == c[j]);
          let loop_set = Set::<int>::new(|j: int| 0 <= j < i && a[j] == b[j] && b[j] == c[j]);
          assert(i == a.len());
          assert(loop_set == final_set);
      }
      
      count
  }

vc-postamble: |-
  fn main() {
  }
  
  }

