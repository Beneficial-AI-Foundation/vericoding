vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn has_divisor(n: int, k: int) -> bool {
      2 <= k < n && n % k == 0
  }
  
  spec fn has_divisor_in_range(n: int, start: int, end: int) -> bool {
      exists|k: int| start <= k < end && has_divisor(n, k)
  }
  
  proof fn divisor_transitivity(n: int, start: int, mid: int, end: int)
      requires 2 <= start <= mid <= end <= n
      ensures has_divisor_in_range(n, start, end) <==> 
              (has_divisor_in_range(n, start, mid) || has_divisor_in_range(n, mid, end))
  {
  }
  
  proof fn divisor_base_case(n: int, k: int)
      requires 2 <= k < n
      ensures has_divisor_in_range(n, k, k + 1) <==> has_divisor(n, k)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn is_non_prime(n: int) -> (result: bool)
      requires n >= 2
      ensures result <==> (exists|k: int| 2 <= k < n && #[trigger] (n % k) == 0)
  // </vc-spec>

vc-code: |-
  {
      let mut i = 2;
      while i < n
          invariant 2 <= i <= n
          invariant !has_divisor_in_range(n, 2, i)
      {
          if n % i == 0 {
              proof {
                  assert(has_divisor(n, i));
                  assert(has_divisor_in_range(n, 2, n));
              }
              return true;
          }
          i = i + 1;
      }
      proof {
          assert(!has_divisor_in_range(n, 2, n));
          assert(forall|k: int| 2 <= k < n ==> n % k != 0);
      }
      false
  }

vc-postamble: |-
  
  fn main() {}
  
  }

