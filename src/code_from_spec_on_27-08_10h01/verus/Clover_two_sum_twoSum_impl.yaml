vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn has_solution_at(nums: &[i32], target: i32, i: int, j: int) -> bool {
      0 <= i < j < nums.len() && nums[i] + nums[j] == target
  }
  
  spec fn is_first_solution(nums: &[i32], target: i32, i: int, j: int) -> bool {
      has_solution_at(nums, target, i, j) &&
      forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] 
          (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target &&
      forall|jj: int| #![trigger nums[jj]] 
          i < jj < j ==> nums[i] + nums[jj] != target
  }

vc-spec: |-
  // <vc-spec>
  fn twoSum(nums: &[i32], target: i32) -> (result: (usize, usize))
      requires 
          nums.len() > 1,
          exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,
      ensures 
          0 <= result.0 < result.1 < nums.len() && nums[result.0 as int] + nums[result.1 as int] == target
          && forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] (0 <= ii < result.0 && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target
          && forall|jj: int| #![trigger nums[jj]] result.0 < jj < result.1 ==> nums[result.0 as int] + nums[jj] != target,
  // </vc-spec>

vc-code: |-
  {
      let mut i = 0;
      while i < nums.len() - 1
          invariant
              0 <= i <= nums.len() - 1,
              forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] 
                  (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target,
              exists|k: int, l: int| i <= k < l < nums.len() && nums[k] + nums[l] == target,
          decreases nums.len() - i,
      {
          let mut j = i + 1;
          while j < nums.len()
              invariant
                  i + 1 <= j <= nums.len(),
                  0 <= i < nums.len() - 1,
                  forall|jj: int| #![trigger nums[jj]] 
                      (i + 1) as int <= jj < j ==> nums[i as int] + nums[jj] != target,
                  forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] 
                      (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target,
                  exists|k: int, l: int| i <= k < l < nums.len() && nums[k] + nums[l] == target,
              decreases nums.len() - j,
          {
              if nums[i] + nums[j] == target {
                  proof {
                      assert(0 <= i < j < nums.len());
                      assert(nums[i as int] + nums[j as int] == target);
                      assert(forall|ii: int, jj: int| #![trigger nums[ii], nums[jj]] 
                          (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target);
                      assert(forall|jj: int| #![trigger nums[jj]] 
                          (i + 1) as int <= jj < j ==> nums[i as int] + nums[jj] != target);
                      assert(forall|jj: int| #![trigger nums[jj]] 
                          i < jj < j ==> nums[i as int] + nums[jj] != target);
                  }
                  return (i, j);
              }
              j += 1;
          }
          i += 1;
      }
      unreached()
  }

vc-postamble: |-
  fn main() {}
  
  }

