vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove
  // that 'sum <= N * max'.
  // Rustan Leino, 18 August 2010.
  //
  // The problem statement gave the pseudo-code for the method, but did not ask to prove
  // that 'sum' or 'max' return as the sum and max, respectively, of the array.  The
  // given assumption that the array's elements are non-negative is not needed to establish
  // the requested postcondition.

vc-helpers: |-
  spec fn seq_sum(s: Seq<int>, end: int) -> int
      decreases end
  {
      if end <= 0 {
          0
      } else {
          seq_sum(s, end - 1) + s[end - 1]
      }
  }
  
  spec fn seq_max(s: Seq<int>, end: int) -> int
      decreases end
  {
      if end <= 0 {
          0
      } else if end == 1 {
          s[0]
      } else {
          if s[end - 1] > seq_max(s, end - 1) {
              s[end - 1]
          } else {
              seq_max(s, end - 1)
          }
      }
  }
  
  proof fn sum_max_lemma(s: Seq<int>, n: int)
      requires
          n >= 0,
          s.len() == n,
          forall|k: int| 0 <= k && k < n ==> 0 <= s[k],
      ensures
          seq_sum(s, n) <= n * seq_max(s, n)
      decreases n
  {
      if n <= 0 {
          return;
      }
      if n == 1 {
          return;
      }
      
      sum_max_lemma(s, n - 1);
      
      let sum_prev = seq_sum(s, n - 1);
      let max_prev = seq_max(s, n - 1);
      let sum_curr = seq_sum(s, n);
      let max_curr = seq_max(s, n);
      
      assert(sum_curr == sum_prev + s[n - 1]);
      
      if s[n - 1] > max_prev {
          assert(max_curr == s[n - 1]);
          assert(sum_prev <= (n - 1) * max_prev);
          assert(sum_prev <= (n - 1) * s[n - 1]);
          assert(sum_curr == sum_prev + s[n - 1] <= (n - 1) * s[n - 1] + s[n - 1] == n * s[n - 1]);
      } else {
          assert(max_curr == max_prev);
          assert(sum_prev <= (n - 1) * max_prev);
          assert(sum_curr == sum_prev + s[n - 1] <= (n - 1) * max_prev + s[n - 1] <= (n - 1) * max_prev + max_prev == n * max_prev);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn M(N: int, a: &[int]) -> (result: (int, int))
      requires 
          0 <= N,
          a.len() == N,
          forall|k: int| 0 <= k && k < N ==> 0 <= a[k],
      ensures 
          result.0 <= N * result.1;
  // </vc-spec>

vc-code: |-
  fn M(N: int, a: &[int]) -> (result: (int, int))
      requires 
          0 <= N,
          a.len() == N,
          forall|k: int| 0 <= k && k < N ==> 0 <= a[k],
      ensures 
          result.0 <= N * result.1
  {
      if N == 0 {
          return (0, 0);
      }
      
      let mut sum = 0;
      let mut max = a[0];
      let mut i = 0;
      
      while i < N
          invariant
              0 <= i && i <= N,
              sum == seq_sum(a@, i),
              max == seq_max(a@, if i == 0 { 1 } else { i }),
              sum <= i * max,
      {
          sum = sum + a[i];
          if a[i] > max {
              max = a[i];
          }
          i = i + 1;
      }
      
      proof {
          sum_max_lemma(a@, N);
          assert(sum == seq_sum(a@, N));
          assert(max == seq_max(a@, N));
      }
      
      (sum, max)
  }

vc-postamble: |-
  
  fn main() {}
  
  }

