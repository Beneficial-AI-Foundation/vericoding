vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn fib(n: nat) -> nat 
      decreases n
  {
      if n == 0 { 
          1 
      } else if n == 1 { 
          1 
      } else { 
          fib((n-1) as nat) + fib((n-2) as nat)
      }
  }
  
  
  // 2.
  enum List<T> {
      Nil,
      Cons(T, Box<List<T>>)
  }
  
  spec fn add(l: List<int>) -> int 
      decreases l
  {
      match l {
          List::Nil => 0,
          List::Cons(x, xs) => x + add(*xs)
      }
  }
  
  
  // 3.
  
  // 5.
  
  // 6
  spec fn sum(n: nat) -> nat 
      decreases n
  {
      if n == 0 { 
          0 
      } else { 
          n + sum((n-1) as nat)
      }
  }

vc-helpers: |-
  spec fn sum_iter(acc: nat, n: nat) -> nat
      decreases n
  {
      if n == 0 {
          acc
      } else {
          sum_iter(acc + n, (n-1) as nat)
      }
  }
  
  proof fn lemma_sum_iter_equiv(acc: nat, n: nat)
      ensures sum_iter(acc, n) == acc + sum(n)
      decreases n
  {
      if n == 0 {
      } else {
          lemma_sum_iter_equiv(acc + n, (n-1) as nat);
      }
  }
  
  proof fn lemma_sum_step(i: nat)
      requires i > 0
      ensures sum(i) == i + sum((i-1) as nat)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn sum_backwards(n: u32) -> (r: u32)
      ensures r == sum(n as nat)
  // </vc-spec>

vc-code: |-
  {
      let mut acc: u32 = 0;
      let mut i: u32 = n;
      
      while i > 0
          invariant acc + sum(i as nat) == sum(n as nat)
          invariant acc <= u32::MAX - i
          decreases i
      {
          proof {
              lemma_sum_step(i as nat);
          }
          i = i - 1;
          acc = acc + (i + 1);
      }
      
      acc
  }

vc-postamble: |-
  
  fn main() {}
  
  }

