vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn is_sorted(arr: &Vec<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]
  }
  
  spec fn valid_last_position(arr: &Vec<i32>, elem: i32, pos: i32) -> bool {
      pos == -1 || (0 <= pos < arr.len() && arr[pos as int] == elem && 
          (pos >= arr.len() - 1 || arr[(pos + 1) as int] > elem))
  }

vc-spec: |-
  // <vc-spec>
  fn last_position(arr: &Vec<i32>, elem: i32) -> (pos: i32)
      requires 
          arr.len() > 0,
          forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],
      ensures
          pos == -1 || (0 <= pos < arr.len() && arr[pos as int] == elem && 
              (pos >= arr.len() - 1 || arr[(pos + 1) as int] > elem)),
  // </vc-spec>

vc-code: |-
  {
      if arr.len() == 0 {
          return -1;
      }
      
      let mut left: i32 = 0;
      let mut right: i32 = (arr.len() - 1) as i32;
      let mut result: i32 = -1;
      
      while left <= right
          invariant
              0 <= left <= arr.len(),
              -1 <= right < arr.len(),
              left <= right + 1,
              result == -1 || (0 <= result < arr.len() && arr[result as int] == elem),
              forall|i: int| 0 <= i < left ==> arr[i] <= elem,
              forall|i: int| right < i < arr.len() ==> arr[i] > elem,
              result == -1 || forall|j: int| result < j < arr.len() ==> arr[j] != elem || arr[j] > elem,
          decreases right - left + 1
      {
          let mid: i32 = left + (right - left) / 2;
          
          if arr[mid as usize] == elem {
              result = mid;
              left = mid + 1;
          } else if arr[mid as usize] < elem {
              left = mid + 1;
          } else {
              right = mid - 1;
          }
      }
      
      result
  }

vc-postamble: |-
  
  fn main() {}
  
  }

