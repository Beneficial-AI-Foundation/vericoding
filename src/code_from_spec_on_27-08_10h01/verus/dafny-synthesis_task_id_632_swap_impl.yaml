vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn count(arr: Seq<int>, value: int) -> nat
      decreases arr.len()
  {
      if arr.len() == 0 { 0nat } else { (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value) }
  }
  
  proof fn count_bound(arr: Seq<int>, value: int)
      ensures count(arr, value) <= arr.len()
      decreases arr.len()
  {
      if arr.len() > 0 {
          count_bound(arr.skip(1), value);
      }
  }

vc-helpers: |-
  proof fn multiset_swap_preserves(s1: Seq<int>, s2: Seq<int>, i: int, j: int)
      requires
          s1.len() == s2.len(),
          0 <= i < s1.len(),
          0 <= j < s1.len(),
          s2[i] == s1[j],
          s2[j] == s1[i],
          forall|k: int| 0 <= k < s1.len() && k != i && k != j ==> s2[k] == s1[k]
      ensures
          s2.to_multiset() == s1.to_multiset()
  {
      if i == j {
          assert(s1 =~= s2);
      } else {
          let ms1 = s1.to_multiset();
          let ms2 = s2.to_multiset();
          
          assert forall|x: int| ms1.count(x) == ms2.count(x) by {
              if x == s1[i] && x == s1[j] {
                  // When both elements are the same, swapping doesn't change count
                  assert(ms1.count(x) == ms2.count(x));
              } else if x == s1[i] && x != s1[j] {
                  // x appears at position i in s1, at position j in s2
                  // Count from other positions remains the same
                  assert(s2[j] == s1[i]);
                  assert(s2[i] == s1[j]);
                  // Since x == s1[i] and x != s1[j], we have s2[j] == x and s2[i] != x
                  // The element x moved from position i to position j
                  assert(ms1.count(x) == ms2.count(x));
              } else if x != s1[i] && x == s1[j] {
                  // x appears at position j in s1, at position i in s2
                  assert(s2[j] == s1[i]);
                  assert(s2[i] == s1[j]);
                  // Since x == s1[j] and x != s1[i], we have s2[i] == x and s2[j] != x
                  // The element x moved from position j to position i
                  assert(ms1.count(x) == ms2.count(x));
              } else {
                  // x is neither s1[i] nor s1[j]
                  // All other positions remain unchanged, and positions i,j don't affect count of x
                  assert(forall|k: int| 0 <= k < s1.len() && k != i && k != j ==> s2[k] == s1[k]);
                  assert(s2[i] == s1[j]);
                  assert(s2[j] == s1[i]);
                  // Since x != s1[i] and x != s1[j], positions i and j contribute equally in both sequences
                  assert(ms1.count(x) == ms2.count(x));
              }
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn swap(arr: &mut Vec<int>, i: usize, j: usize)
      requires 
          old(arr).len() > 0,
          i < old(arr).len(),
          j < old(arr).len(),
      ensures 
          arr[i as int] == old(arr)[j as int],
          arr[j as int] == old(arr)[i as int],
          forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],
          arr@.to_multiset() == old(arr)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  {
      let temp = arr[i];
      let val_j = arr[j];
      arr.set(i, val_j);
      arr.set(j, temp);
      
      proof {
          multiset_swap_preserves(old(arr)@, arr@, i as int, j as int);
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

