vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum_r(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else {
          sum_r(s.subrange(0, s.len() - 1)) + s[s.len() - 1]
      }
  }
  
  spec fn sum_l(s: Seq<int>) -> int
      decreases s.len()
  {
      if s.len() == 0 {
          0
      } else {
          s[0] + sum_l(s.subrange(1, s.len() as int))
      }
  }
  
  spec fn sum_v(v: Seq<int>, c: int, f: int) -> int {
      if 0 <= c <= f <= v.len() {
          sum_r(v.subrange(c, f))
      } else {
          0
      }
  }

vc-helpers: |-
  proof fn lemma_sum_r_extend(s: Seq<int>, x: int)
      ensures sum_r(s.push(x)) == sum_r(s) + x
      decreases s.len()
  {
      if s.len() == 0 {
          assert(s.push(x).len() == 1);
          assert(sum_r(s.push(x)) == sum_r(s.push(x).subrange(0, 0)) + s.push(x)[0]);
          assert(s.push(x).subrange(0, 0) == Seq::<int>::empty());
          assert(sum_r(Seq::<int>::empty()) == 0);
          assert(s.push(x)[0] == x);
      } else {
          let s_pushed = s.push(x);
          assert(s_pushed.len() == s.len() + 1);
          assert(s_pushed.subrange(0, s_pushed.len() - 1) == s);
          assert(s_pushed[s_pushed.len() - 1] == x);
          assert(sum_r(s_pushed) == sum_r(s) + x);
      }
  }
  
  proof fn lemma_sum_r_slice_map(v: &[i32], i: usize)
      requires i < v.len()
      ensures sum_r(v@.subrange(0, i as int + 1).map(|j, x| x as int)) == 
              sum_r(v@.subrange(0, i as int).map(|j, x| x as int)) + v@[i as int] as int
  {
      let mapped_full = v@.subrange(0, i as int + 1).map(|j, x| x as int);
      let mapped_prefix = v@.subrange(0, i as int).map(|j, x| x as int);
      
      assert(mapped_full == mapped_prefix.push(v@[i as int] as int));
      lemma_sum_r_extend(mapped_prefix, v@[i as int] as int);
  }

vc-spec: |-
  // <vc-spec>
  fn sum_elems(v: &[i32]) -> (sum: i32)
  //ensures sum as int == sum_l(v@.map(|i, x| x as int))
  ensures sum as int == sum_r(v@.map(|i, x| x as int))
  //ensures sum as int == sum_v(v@.map(|i, x| x as int), 0, v@.len())
  // </vc-spec>

vc-code: |-
  {
      let mut sum: i32 = 0;
      let mut i: usize = 0;
      
      while i < v.len()
          invariant 
              i <= v.len(),
              sum as int == sum_r(v@.subrange(0, i as int).map(|j, x| x as int)),
              sum_r(v@.map(|j, x| x as int)) <= i32::MAX,
              sum_r(v@.map(|j, x| x as int)) >= i32::MIN
          decreases v.len() - i
      {
          proof {
              lemma_sum_r_slice_map(v, i);
              assert(sum_r(v@.subrange(0, i as int + 1).map(|j, x| x as int)) <= sum_r(v@.map(|j, x| x as int)));
              assert(sum as int + v@[i as int] as int <= i32::MAX);
              assert(sum as int + v@[i as int] as int >= i32::MIN);
          }
          sum = sum + v[i];
          i = i + 1;
      }
      
      proof {
          assert(v@.subrange(0, i as int) == v@);
      }
      
      sum
  }

vc-postamble: |-
  fn main() {}
  
  }

