vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  //Bubblesort CS 494 submission
  //References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785
  
  
  // predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array
  
  spec fn sorted(a: &Vec<i32>, from: usize, to: usize) -> bool
      recommends 
          from <= to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| from <= x < y < to ==> a[x as int] <= a[y as int]
  }
  
  //helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept 
  spec fn pivot(a: &Vec<i32>, to: usize, pvt: usize) -> bool
      recommends
          pvt < to,
          to <= a.len(),
  {
      forall|x: usize, y: usize| 0 <= x < pvt < y < to ==> a[x as int] <= a[y as int] // all values within the array should be in ascending order
  }
  
  // Here having the algorithm for the bubblesort

vc-helpers: |-
  proof fn bubble_sort_preserves_multiset(a: &mut Vec<i32>, i: usize, j: usize)
      requires
          0 <= i < old(a).len(),
          0 <= j < old(a).len(),
      ensures
          a@.to_multiset() == old(a)@.to_multiset(),
  {
      // Swapping two elements preserves multiset
  }
  
  proof fn bubble_maintains_pivot(a: &mut Vec<i32>, to: usize, pvt: usize, j: usize)
      requires
          pvt < to,
          to <= old(a).len(),
          j < to - 1,
          pivot(old(a), to, pvt),
          j >= pvt,
          old(a)[j as int] > old(a)[(j + 1) as int],
      ensures
          pivot(a, to, pvt),
  {
  }
  
  proof fn sorted_extends(a: &Vec<i32>, from: usize, to: usize)
      requires
          from < to,
          to <= a.len(),
          sorted(a, (from + 1) as usize, to),
          forall|k: usize| from + 1 <= k < to ==> a[from as int] <= a[k as int],
      ensures
          sorted(a, from, to),
  {
  }
  
  proof fn pivot_to_sorted(a: &Vec<i32>, to: usize)
      requires
          to <= a.len(),
          pivot(a, to, 0),
      ensures
          sorted(a, 0, to),
  {
  }

vc-spec: |-
  // <vc-spec>
  fn BubbleSort(a: &mut Vec<i32>)
      requires 
          old(a).len() > 0, // makes sure a is not empty and length is greater than 0
      ensures 
          sorted(a, 0, a.len()), // makes sure elements of array a are sorted from 0 - a.len()
          a@.to_multiset() == old(a)@.to_multiset(), // Since a is being modified, we compare the previous elements to current elements.
  // </vc-spec>

vc-code: |-
  {
      let mut n = a.len();
      
      while n > 1
          invariant
              1 <= n <= a.len(),
              sorted(a, n, a.len()),
              forall|x: usize, y: usize| n <= x < a.len() && 0 <= y < n ==> a[y as int] <= a[x as int],
              a@.to_multiset() == old(a)@.to_multiset(),
          decreases n,
      {
          let mut j = 0;
          
          while j < n - 1
              invariant
                  0 <= j < n,
                  n <= a.len(),
                  sorted(a, n, a.len()),
                  forall|x: usize, y: usize| n <= x < a.len() && 0 <= y < n ==> a[y as int] <= a[x as int],
                  sorted(a, 0, (j + 1) as usize),
                  forall|k: usize| j + 1 <= k < n ==> a[j as int] <= a[k as int],
                  a@.to_multiset() == old(a)@.to_multiset(),
              decreases n - j,
          {
              if a[j] > a[j + 1] {
                  let temp = a[j];
                  let next_val = a[j + 1];
                  a.set(j, next_val);
                  a.set(j + 1, temp);
              }
              j = j + 1;
          }
          
          n = n - 1;
      }
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

