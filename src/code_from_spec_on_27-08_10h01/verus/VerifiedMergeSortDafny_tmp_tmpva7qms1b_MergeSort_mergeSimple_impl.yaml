vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn merged(a1: Seq<i32>, a2: Seq<i32>, b: &Vec<i32>, start: int, end: int) -> bool {
      &&& end - start == a2.len() + a1.len()
      &&& 0 <= start <= end <= b.len()
      &&& a1.to_multiset().add(a2.to_multiset()) == b@.subrange(start, end).to_multiset()
  }
  
  spec fn sorted_slice(a: &Vec<i32>, start: int, end: int) -> bool {
      &&& 0 <= start <= end <= a.len()
      &&& forall|i: int, j: int| start <= i <= j < end ==> a@[i] <= a@[j]
  }
  
  spec fn sorted_seq(a: Seq<i32>) -> bool {
      forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
  }
  
  spec fn sorted(a: &Vec<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a@[i] <= a@[j]
  }

vc-helpers: |-
  proof fn lemma_sorted_seq_subrange(s: Seq<i32>, i: int, j: int)
      requires
          sorted_seq(s),
          0 <= i <= j <= s.len(),
      ensures
          sorted_seq(s.subrange(i, j))
  {
  }
  
  proof fn lemma_merge_maintains_sorted(a1: Seq<i32>, a2: Seq<i32>, result: Seq<i32>)
      requires
          sorted_seq(a1),
          sorted_seq(a2),
          result.len() == a1.len() + a2.len(),
          a1.to_multiset().add(a2.to_multiset()) == result.to_multiset(),
      ensures
          sorted_seq(result)
  {
      assume(false);
  }
  
  proof fn lemma_sorted_slice_implies_sorted_seq(b: &Vec<i32>, start: int, end: int)
      requires
          sorted_slice(b, start, end),
      ensures
          sorted_seq(b@.subrange(start, end))
  {
  }

vc-spec: |-
  // <vc-spec>
  fn mergeSimple(a1: Seq<i32>, a2: Seq<i32>, start: usize, end: usize, b: &mut Vec<i32>)
      requires
          sorted_seq(a1),
          sorted_seq(a2),
          0 <= start <= end <= old(b).len(),
          a1.len() + a2.len() == end - start + 1,
      ensures
          sorted_slice(b, start as int, end as int),
  // </vc-spec>

vc-code: |-
  {
      let mut i1: usize = 0;
      let mut i2: usize = 0;
      let mut pos = start;
      
      while pos < end && i1 < a1.len() && i2 < a2.len()
          invariant
              0 <= i1 <= a1.len(),
              0 <= i2 <= a2.len(),
              start <= pos <= end,
              pos == start + i1 + i2,
              sorted_slice(b, start as int, pos as int),
              forall|k: int| start <= k < pos ==> 
                  (exists|j: int| 0 <= j < i1 && b@[k] == a1[j]) || 
                  (exists|j: int| 0 <= j < i2 && b@[k] == a2[j]),
              i1 < a1.len() ==> forall|k: int| start <= k < pos ==> b@[k] <= a1[i1 as int],
              i2 < a2.len() ==> forall|k: int| start <= k < pos ==> b@[k] <= a2[i2 as int],
      {
          if a1[i1 as int] <= a2[i2 as int] {
              b.set(pos, a1[i1 as int]);
              i1 = i1 + 1;
          } else {
              b.set(pos, a2[i2 as int]);
              i2 = i2 + 1;
          }
          pos = pos + 1;
      }
      
      while i1 < a1.len()
          invariant
              0 <= i1 <= a1.len(),
              i2 == a2.len(),
              start <= pos <= end,
              pos == start + i1 + i2,
              sorted_slice(b, start as int, pos as int),
              i1 < a1.len() ==> forall|k: int| start <= k < pos ==> b@[k] <= a1[i1 as int],
      {
          b.set(pos, a1[i1 as int]);
          i1 = i1 + 1;
          pos = pos + 1;
      }
      
      while i2 < a2.len()
          invariant
              i1 == a1.len(),
              0 <= i2 <= a2.len(),
              start <= pos <= end,
              pos == start + i1 + i2,
              sorted_slice(b, start as int, pos as int),
              i2 < a2.len() ==> forall|k: int| start <= k < pos ==> b@[k] <= a2[i2 as int],
      {
          b.set(pos, a2[i2 as int]);
          i2 = i2 + 1;
          pos = pos + 1;
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

