vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  /* 
  * Formal verification of the selection sort algorithm with Verus.
  * FEUP, MIEIC, MFES, 2020/21.
  */
  
  // Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).
  spec fn is_sorted(a: Seq<i32>, from: int, to: int) -> bool
      recommends 0 <= from <= to <= a.len()
  {
      forall|i: int, j: int| from <= i < j < to ==> a[i] <= a[j]
  }
  
  // Sorts array 'a' using the selection sort algorithm.
  
  // Finds the position of a minimum value in non-empty subarray 'a' between positions 
  // 'from' (inclusive) and 'to' (exclusive)
  fn find_min(a: &Vec<i32>, from: usize, to: usize) -> (index: usize)
      requires 
          0 <= from < to <= a.len(),
      ensures 
          from <= index < to,
          forall|k: int| from as int <= k < to as int ==> a@[k] >= a@[index as int],
  {
      assume(false);
      0
  }

vc-helpers: |-
  proof fn lemma_swap_preserves_sorted_prefix(a: Seq<i32>, b: Seq<i32>, i: int, j: int, k: int)
      requires
          0 <= i < a.len(),
          0 <= j < a.len(),
          0 <= k < i,
          a.len() == b.len(),
          forall|x: int| 0 <= x < a.len() && x != i && x != j ==> a[x] == b[x],
          a[i] == b[j],
          a[j] == b[i],
          is_sorted(a, 0, k + 1),
          forall|x: int| 0 <= x <= k ==> a[x] <= a[j],
          a[j] <= a[i],
      ensures
          is_sorted(b, 0, k + 1),
  {
      assert(forall|x: int, y: int| 0 <= x < y <= k ==> b[x] <= b[y]) by {
          assert(forall|x: int, y: int| 0 <= x < y <= k ==> a[x] <= a[y]);
          assert(forall|x: int, y: int| 0 <= x < y <= k ==> b[x] == a[x] && b[y] == a[y]);
      }
  }
  
  proof fn lemma_find_min_implies_smaller_than_suffix(a: Seq<i32>, min_idx: int, from: int, to: int)
      requires
          0 <= from <= min_idx < to <= a.len(),
          forall|k: int| from <= k < to ==> a[k] >= a[min_idx],
      ensures
          forall|k: int| min_idx < k < to ==> a[min_idx] <= a[k],
  {
  }
  
  proof fn lemma_multiset_preserved_after_swap<T>(a: Seq<T>, b: Seq<T>, i: int, j: int)
      requires
          0 <= i < a.len(),
          0 <= j < a.len(),
          a.len() == b.len(),
          forall|x: int| 0 <= x < a.len() && x != i && x != j ==> a[x] == b[x],
          a[i] == b[j],
          a[j] == b[i],
      ensures
          a.to_multiset() == b.to_multiset(),
  {
      assert(a.to_multiset().count(a[i]) == b.to_multiset().count(b[i]));
      assert(a.to_multiset().count(a[j]) == b.to_multiset().count(b[j]));
      assert(forall|v: T| #[trigger] a.to_multiset().count(v) == b.to_multiset().count(v));
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<i32>)
      ensures 
          is_sorted(a@, 0, a@.len() as int),
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  {
      let mut i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              is_sorted(a@, 0, i as int),
              forall|j: int, k: int| 0 <= j < i && i <= k < a@.len() ==> a@[j] <= a@[k],
              a@.to_multiset() == old(a)@.to_multiset(),
          decreases a.len() - i,
      {
          if i < a.len() - 1 {
              let ghost old_a = a@;
              let min_index = find_min(a, i, a.len());
              
              proof {
                  lemma_find_min_implies_smaller_than_suffix(a@, min_index as int, i as int, a.len() as int);
                  assert(forall|x: int| i <= x < a@.len() ==> a@[x] >= a@[min_index as int]);
                  assert(forall|x: int| 0 <= x < i ==> a@[x] <= a@[min_index as int]) by {
                      assert(forall|k: int| i <= k < a@.len() ==> a@[min_index as int] <= a@[k]);
                  };
              }
              
              let temp = a[i];
              let min_value = a[min_index];
              a.set(i, min_value);
              a.set(min_index, temp);
              
              proof {
                  lemma_multiset_preserved_after_swap(old_a, a@, i as int, min_index as int);
                  if i > 0 {
                      lemma_swap_preserves_sorted_prefix(old_a, a@, i as int, min_index as int, (i - 1) as int);
                  }
                  assert(forall|x: int| 0 <= x < i ==> a@[x] <= a@[i as int]);
                  assert(forall|j: int, k: int| 0 <= j < (i + 1) && (i + 1) <= k < a@.len() ==> a@[j] <= a@[k]) by {
                      assert(forall|j: int, k: int| 0 <= j < i && (i + 1) <= k < a@.len() ==> a@[j] <= a@[k]);
                      assert(forall|k: int| (i + 1) <= k < a@.len() ==> a@[i as int] <= a@[k]);
                  };
              }
          }
          i += 1;
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

