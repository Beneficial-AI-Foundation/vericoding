vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn is_divisor(n: u32, d: u32) -> bool {
      d > 0 && n % d == 0
  }
  
  spec fn is_common_divisor(a: u32, b: u32, d: u32) -> bool {
      is_divisor(a, d) && is_divisor(b, d)
  }
  
  spec fn sum_divisors_up_to(a: u32, b: u32, limit: u32) -> u32
      decreases limit
  {
      if limit == 0 {
          0
      } else {
          let prev_sum = sum_divisors_up_to(a, b, (limit - 1) as u32);
          if is_common_divisor(a, b, limit) {
              (prev_sum + limit) as u32
          } else {
              prev_sum
          }
      }
  }
  
  proof fn lemma_sum_contains_divisor(a: u32, b: u32, d: u32, limit: u32)
      requires
          d <= limit,
          is_common_divisor(a, b, d),
      ensures
          sum_divisors_up_to(a, b, limit) >= d,
      decreases limit
  {
      if limit == 0 {
          assert(false);
      } else if limit == d {
          let prev_sum = sum_divisors_up_to(a, b, (d - 1) as u32);
          assert(sum_divisors_up_to(a, b, d) == prev_sum + d);
          assert(sum_divisors_up_to(a, b, d) >= d);
      } else {
          lemma_sum_contains_divisor(a, b, d, (limit - 1) as u32);
          lemma_sum_divisors_up_to_monotonic_step(a, b, limit);
          assert(sum_divisors_up_to(a, b, limit) >= sum_divisors_up_to(a, b, (limit - 1) as u32));
          assert(sum_divisors_up_to(a, b, (limit - 1) as u32) >= d);
          assert(sum_divisors_up_to(a, b, limit) >= d);
      }
  }
  
  proof fn lemma_sum_divisors_up_to_monotonic(a: u32, b: u32, limit: u32)
      ensures sum_divisors_up_to(a, b, limit) >= 0
  {
  }
  
  proof fn lemma_sum_divisors_up_to_monotonic_step(a: u32, b: u32, limit: u32)
      requires limit > 0
      ensures sum_divisors_up_to(a, b, limit) >= sum_divisors_up_to(a, b, (limit - 1) as u32)
  {
      let prev_sum = sum_divisors_up_to(a, b, (limit - 1) as u32);
      if is_common_divisor(a, b, limit) {
          assert(sum_divisors_up_to(a, b, limit) == prev_sum + limit);
          assert(sum_divisors_up_to(a, b, limit) >= prev_sum);
      } else {
          assert(sum_divisors_up_to(a, b, limit) == prev_sum);
          assert(sum_divisors_up_to(a, b, limit) >= prev_sum);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn sum_of_common_divisors(a: u32, b: u32) -> (sum: u32)
      requires 
          a > 0 && b > 0,
      ensures 
          sum >= 0,
          forall|d: u32| #![trigger a % d, b % d] 
              1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d,
  // </vc-spec>

vc-code: |-
  {
      let max_limit = if a <= b { a } else { b };
      let mut sum = 0u32;
      let mut i = 1u32;
      
      while i <= max_limit
          invariant
              1 <= i <= max_limit + 1,
              sum == sum_divisors_up_to(a, b, (i - 1) as u32),
              forall|d: u32| #![trigger a % d, b % d]
                  1 <= d < i && is_common_divisor(a, b, d) ==> sum >= d,
              sum <= i * max_limit,
          decreases max_limit + 1 - i
      {
          if a % i == 0 && b % i == 0 {
              sum = sum + i;
          }
          i = i + 1;
      }
      
      proof {
          assert(i == max_limit + 1);
          assert(sum == sum_divisors_up_to(a, b, max_limit));
          
          assert forall|d: u32| #![trigger a % d, b % d]
              1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 implies sum >= d
          by {
              if 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 {
                  assert(d <= max_limit);
                  assert(is_common_divisor(a, b, d));
                  lemma_sum_contains_divisor(a, b, d, max_limit);
              }
          }
      }
      
      sum
  }

vc-postamble: |-
  fn main() {}
  
  }

