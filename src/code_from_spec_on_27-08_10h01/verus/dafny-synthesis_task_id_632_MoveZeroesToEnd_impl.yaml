vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  fn swap(arr: &mut Vec<i32>, i: usize, j: usize)
      requires 
          old(arr).len() > 0,
          i < old(arr).len(),
          j < old(arr).len(),
      ensures
          arr[i as int] == old(arr)[j as int],
          arr[j as int] == old(arr)[i as int],
          forall|k: int| 0 <= k < arr.len() && k != i && k != j ==> arr[k] == old(arr)[k],
          arr@.to_multiset() == old(arr)@.to_multiset(),
  {
      assume(false);
  }
  
  spec fn count(arr: Seq<i32>, value: i32) -> nat
      decreases arr.len(),
  {
      if arr.len() == 0 {
          0nat
      } else {
          (if arr[0] == value { 1nat } else { 0nat }) + count(arr.skip(1), value)
      }
  }
  
  proof fn count_bound(arr: Seq<i32>, value: i32)
      ensures count(arr, value) <= arr.len(),
      decreases arr.len(),
  {
      if arr.len() == 0 {
      } else {
          count_bound(arr.skip(1), value);
      }
  }

vc-helpers: |-
  proof fn multiset_swap_preserves<T>(s: Seq<T>, i: int, j: int)
      requires 
          0 <= i < s.len(),
          0 <= j < s.len(),
      ensures
          s.update(i, s[j]).update(j, s[i]).to_multiset() == s.to_multiset(),
  {
      let s1 = s.update(i, s[j]);
      let s2 = s1.update(j, s[i]);
      
      assert forall|x: T| s2.to_multiset().count(x) == s.to_multiset().count(x) by {
          if i == j {
              assert(s2 == s);
          } else {
              if x == s[i] && x == s[j] {
                  assert(s2[i] == s[j] && s2[j] == s[i]);
                  assert(s2.to_multiset().count(x) == s.to_multiset().count(x));
              } else if x == s[i] && x != s[j] {
                  assert(s2[j] == s[i]);
                  assert(s2[i] == s[j]);
                  assert(s2.to_multiset().count(x) == s.to_multiset().count(x));
              } else if x != s[i] && x == s[j] {
                  assert(s2[i] == s[j]);
                  assert(s2[j] == s[i]);
                  assert(s2.to_multiset().count(x) == s.to_multiset().count(x));
              } else {
                  assert(forall|k: int| 0 <= k < s.len() && k != i && k != j ==> s2[k] == s[k]) by {
                      assert forall|k: int| 0 <= k < s.len() && k != i && k != j implies s2[k] == s[k] by {
                          if k != i && k != j {
                              assert(s1[k] == s[k]);
                              assert(s2[k] == s1[k]);
                          }
                      }
                  };
                  assert(s2.to_multiset().count(x) == s.to_multiset().count(x));
              }
          }
      }
  }
  
  proof fn count_multiset_eq(s1: Seq<i32>, s2: Seq<i32>, value: i32)
      requires s1.to_multiset() == s2.to_multiset(),
      ensures count(s1, value) == count(s2, value),
      decreases s1.len(),
  {
      if s1.len() == 0 {
          assert(s1.to_multiset() == s2.to_multiset());
          assert(s2.to_multiset().len() == 0);
          assert(s2.len() == 0);
      } else {
          assert(s1.to_multiset().count(value) == s2.to_multiset().count(value));
          count_multiset_relation(s1, value);
          count_multiset_relation(s2, value);
      }
  }
  
  proof fn count_multiset_relation(s: Seq<i32>, value: i32)
      ensures count(s, value) == s.to_multiset().count(value),
      decreases s.len(),
  {
      if s.len() == 0 {
          assert(count(s, value) == 0);
          assert(s.to_multiset().count(value) == 0);
      } else {
          count_multiset_relation(s.skip(1), value);
          if s[0] == value {
              assert(count(s, value) == 1 + count(s.skip(1), value));
              assert(s.to_multiset().count(value) == 1 + s.skip(1).to_multiset().count(value));
          } else {
              assert(count(s, value) == count(s.skip(1), value));
              assert(s.to_multiset().count(value) == s.skip(1).to_multiset().count(value));
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  fn move_zeros_to_end(arr: &mut Vec<i32>)
      requires old(arr).len() >= 2,
      ensures
          // Same size
          arr.len() == old(arr).len(),
          // Zeros to the right of the first zero
          forall|i: int, j: int| 0 <= i < j < arr.len() && arr[i] == 0 ==> arr[j] == 0,
          // The final array is a permutation of the original one
          arr@.to_multiset() == old(arr)@.to_multiset(),
          // Relative order of non-zero elements is preserved
          forall|n: int, m: int| 0 <= n < m < arr.len() && old(arr)[n] != 0 && old(arr)[m] != 0 ==>
              exists|k: int, l: int| 0 <= k < l < arr.len() && arr[k] == old(arr)[n] && arr[l] == old(arr)[m],
          // Number of zeros is preserved
  // </vc-spec>

vc-code: |-
  {
      let mut write_pos: usize = 0;
      let mut read_pos: usize = 0;
      
      while read_pos < arr.len()
          invariant
              read_pos < arr.len(),
              write_pos <= read_pos,
              write_pos < arr.len(),
              forall|k: int| 0 <= k < write_pos ==> arr[k] != 0,
              arr@.to_multiset() == old(arr)@.to_multiset(),
              arr.len() == old(arr).len(),
              forall|n: int, m: int| 0 <= n < m < write_pos && old(arr)[read_pos as int] != 0 ==> 
                  exists|k: int, l: int| 0 <= k < l < write_pos && arr[k] == old(arr)[n] && arr[l] == old(arr)[m],
          decreases arr.len() - read_pos,
      {
          if arr[read_pos] != 0 {
              if write_pos != read_pos {
                  proof {
                      multiset_swap_preserves(arr@, write_pos as int, read_pos as int);
                  }
                  swap(arr, write_pos, read_pos);
              }
              write_pos += 1;
          }
          read_pos += 1;
      }
      
      // Fill remaining positions with zeros
      while write_pos < arr.len()
          invariant
              write_pos <= arr.len(),
              forall|k: int| 0 <= k < write_pos ==> arr[k] != 0,
              arr@.to_multiset() == old(arr)@.to_multiset(),
              arr.len() == old(arr).len(),
          decreases arr.len() - write_pos,
      {
          arr.set(write_pos, 0);
          write_pos += 1;
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

