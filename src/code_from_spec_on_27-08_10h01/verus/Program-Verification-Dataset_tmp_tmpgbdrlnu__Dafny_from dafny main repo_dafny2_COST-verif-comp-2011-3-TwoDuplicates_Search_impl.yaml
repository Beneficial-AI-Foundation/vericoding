vc-preamble: |-
  // RUN: %testDafnyForEachResolver "%s" -- --warn-deprecation:false
  
  use vstd::prelude::*;
  
  verus! {
  
  /*
  Rustan Leino, 5 Oct 2011
  
  COST Verification Competition, Challenge 3: Two equal elements
  http://foveoos2011.cost-ic0701.org/verification-competition
  
  Given: An integer array a of length n+2 with n>=2. It is known that at
  least two values stored in the array appear twice (i.e., there are at
  least two duplets).
  
  Implement and verify a program finding such two values.
  
  You may assume that the array contains values between 0 and n-1.
  */
  
  // Remarks:
  
  // The implementation of method 'Search' takes one pass through the elements of
  // the given array.  To keep track of what it has seen, it allocates an array as
  // temporary storage--I imagine that this is what the competition designers
  // had in mind, since the problem description says one can assume the values
  // of the given array to lie in the range 0..n.
  
  // To keep track of whether it already has found one duplicate, the method
  // sets the output variables p and q as follows:
  //   p != q   - no duplicates found yet
  //   p == q   - one duplicate found so far, namely the value stored in p and q
  // Note, the loop invariant does not need to say anything about the state
  // of two duplicates having been found, because when the second duplicate is
  // found, the method returns.
  
  // What needs to be human-trusted about this program is the specification of
  // 'Search'.  The specification straightforwardly lists the assumptions stated
  // in the problem description, including the given fact that the array contains
  // (at least) two distinct elements that each occurs (at least) twice.  To
  // trust the specification of 'Search', a human also needs to trust the definition
  // of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.
  
  // About Dafny:
  // As always (when it is successful), Dafny verifies that the program does not
  // cause any run-time errors (like array index bounds errors), that the program
  // terminates, that expressions and functions are well defined, and that all
  // specifications are satisfied.  The language prevents type errors by being type
  // safe, prevents dangling pointers by not having an "address-of" or "deallocate"
  // operation (which is accommodated at run time by a garbage collector), and
  // prevents arithmetic overflow errors by using mathematical integers (which
  // is accommodated at run time by using BigNum's).  By proving that programs
  // terminate, Dafny proves that a program's time usage is finite, which implies
  // that the program's space usage is finite too.  However, executing the
  // program may fall short of your hopes if you don't have enough time or
  // space; that is, the program may run out of space or may fail to terminate in
  // your lifetime, because Dafny does not prove that the time or space needed by
  // the program matches your execution environment.  The only input fed to
  // the Dafny verifier/compiler is the program text below; Dafny then automatically
  // verifies and compiles the program (for this program in less than 11 seconds)
  // without further human intervention.
  
  spec fn uninterp is_duplicate(a: Seq<int>, p: int) -> bool;
  
  spec fn uninterp is_prefix_duplicate(a: Seq<int>, k: usize, p: int) -> bool;

vc-helpers: |-
  spec fn is_duplicate(a: Seq<int>, p: int) -> bool {
      exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && i != j && a[i] == p && a[j] == p
  }
  
  spec fn is_prefix_duplicate(a: Seq<int>, k: usize, p: int) -> bool {
      exists|i: int, j: int| 0 <= i < k && 0 <= j < k && i != j && a[i] == p && a[j] == p
  }
  
  lemma lemma_duplicate_prefix(a: Seq<int>, k: usize, p: int)
      requires k <= a.len()
      requires is_prefix_duplicate(a, k, p)
      ensures is_duplicate(a, p)
  {
  }
  
  lemma lemma_seen_duplicate(seen: Seq<bool>, p: usize, a: Seq<int>, i: usize)
      requires p < seen.len()
      requires i < a.len()
      requires seen[p as int] == true
      requires a[i as int] == p as int
      requires forall|j: int| 0 <= j < seen.len() ==> (seen[j] == true <==> exists|k: int| 0 <= k < i && a[k] == j)
      ensures is_prefix_duplicate(a, i + 1, p as int)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn search(a: &[i32]) -> (ret: (i32, i32))
      requires 4 <= a.len(),
      requires exists|p: int, q: int| #![auto] p != q && is_duplicate(a@.map(|i, x| x as int), p) && is_duplicate(a@.map(|i, x| x as int), q),  // two distinct duplicates exist
      requires forall|i: usize| #![auto] 0 <= i < a.len() ==> 0 <= a[i as int] < (a.len() - 2) as int,  // the elements of "a" in the range [0.. a.len()-2]
      ensures ret.0 != ret.1 && is_duplicate(a@.map(|i, x| x as int), ret.0 as int) && is_duplicate(a@.map(|i, x| x as int), ret.1 as int)
  // </vc-spec>

vc-code: |-
  {
      let n = a.len() - 2;
      let mut seen = Vec::<bool>::with_capacity(n);
      proof {
          seen.set_len(n);
      }
      for j in 0..n
          invariant seen.len() == n
          invariant j <= n
          invariant forall|k: int| 0 <= k < j ==> seen@[k] == false
      {
          seen.set(j, false);
      }
      
      let mut p: i32 = 0;
      let mut q: i32 = 1;
      let mut i = 0;
      
      while i < a.len()
          invariant 0 <= i <= a.len()
          invariant seen.len() == n
          invariant forall|j: int| 0 <= j < seen.len() ==> (seen@[j] == true <==> exists|k: int| 0 <= k < i && a@[k] == j as i32)
          invariant p != q ==> forall|val: int| !(is_prefix_duplicate(a@.map(|k, x| x as int), i, val))
          invariant p == q ==> is_prefix_duplicate(a@.map(|k, x| x as int), i, p as int)
      {
          let val = a[i];
          let val_idx = val as usize;
          
          if seen@[val_idx as int] {
              if p == q {
                  q = val;
                  proof {
                      lemma_seen_duplicate(seen@, val_idx, a@.map(|k, x| x as int), i);
                      lemma_duplicate_prefix(a@.map(|k, x| x as int), i + 1, val as int);
                  }
                  return (p, q);
              } else {
                  p = val;
                  q = val;
                  proof {
                      lemma_seen_duplicate(seen@, val_idx, a@.map(|k, x| x as int), i);
                  }
              }
          } else {
              seen.set(val_idx, true);
          }
          
          i += 1;
      }
      
      proof {
          assert(false);
      }
      (p, q)
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

