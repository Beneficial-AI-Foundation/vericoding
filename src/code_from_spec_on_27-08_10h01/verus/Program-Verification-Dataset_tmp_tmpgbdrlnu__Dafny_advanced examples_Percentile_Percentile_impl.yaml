vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Sum of elements of A from indices 0 to end.
  // end is inclusive! (not James's normal way of thinking!!)
  spec fn sum_upto(a: Seq<int>, end: int) -> int
      decreases end + 2
  {
      if end < 0 {
          0
      } else if end >= a.len() {
          0  // out of bounds
      } else {
          a[end] + sum_upto(a, end - 1)
      }
  }
  
  spec fn sum(a: Seq<int>) -> int {
      sum_upto(a, a.len() - 1)
  }

vc-helpers: |-
  lemma sum_upto_monotonic(a: Seq<int>, i: int, j: int)
      requires 
          forall|idx: int| 0 <= idx < a.len() ==> a[idx] > 0,
          0 <= i <= j < a.len(),
      ensures sum_upto(a, i) < sum_upto(a, j)
      decreases j - i
  {
      if i == j {
          assert(false);
      } else if i + 1 == j {
          assert(sum_upto(a, j) == a[j] + sum_upto(a, j - 1));
          assert(sum_upto(a, i) == sum_upto(a, j - 1));
          assert(a[j] > 0);
      } else {
          sum_upto_monotonic(a, i, j - 1);
          assert(sum_upto(a, i) < sum_upto(a, j - 1));
          assert(sum_upto(a, j) == a[j] + sum_upto(a, j - 1));
          assert(a[j] > 0);
      }
  }
  
  lemma sum_upto_bounds(a: Seq<int>, i: int)
      requires 
          forall|idx: int| 0 <= idx < a.len() ==> a[idx] > 0,
          0 <= i < a.len(),
      ensures sum_upto(a, i) > 0
      decreases i + 1
  {
      if i == 0 {
          assert(sum_upto(a, 0) == a[0]);
      } else {
          sum_upto_bounds(a, i - 1);
          assert(sum_upto(a, i) == a[i] + sum_upto(a, i - 1));
      }
  }
  
  lemma sum_upto_step(a: Seq<int>, i: int)
      requires 0 <= i < a.len()
      ensures sum_upto(a, i) == a[i] + sum_upto(a, i - 1)
  {
  }
  
  lemma sum_upto_extension(a: Seq<int>, i: int)
      requires 
          forall|idx: int| 0 <= idx < a.len() ==> a[idx] > 0,
          -1 <= i < a.len() - 1,
      ensures sum_upto(a, i + 1) > sum_upto(a, i)
  {
      if i == -1 {
          assert(sum_upto(a, -1) == 0);
          assert(sum_upto(a, 0) == a[0]);
      } else {
          assert(sum_upto(a, i + 1) == a[i + 1] + sum_upto(a, i));
          assert(a[i + 1] > 0);
      }
  }

vc-spec: |-
  // <vc-spec>
  fn percentile(p: int, a: &[int], total: int) -> (i: i32)
      requires 
          forall|idx: int| 0 <= idx < a.len() ==> a@[idx] > 0,
          0 <= p <= 100,
          total == sum(a@),
          total > 0,
      ensures 
          -1 <= i < a.len(),
          sum_upto(a@, i as int) <= (p * total) / 100,
          i as int + 1 < a.len() ==> sum_upto(a@, i as int + 1) > (p * total) / 100,
  // </vc-spec>

vc-code: |-
  {
      let threshold = (p * total) / 100;
      let mut running_sum = 0;
      let mut i = -1i32;
      
      while i + 1 < a.len() as i32
          invariant
              -1 <= i < a.len() as i32,
              running_sum == sum_upto(a@, i as int),
              running_sum <= threshold,
              forall|idx: int| 0 <= idx < a@.len() ==> a@[idx] > 0,
          decreases a.len() - (i + 1) as usize
      {
          let next_sum = running_sum + a[(i + 1) as usize];
          if next_sum > threshold {
              proof {
                  assert(sum_upto(a@, i as int + 1) == a@[i as int + 1] + sum_upto(a@, i as int));
                  assert(next_sum == sum_upto(a@, i as int + 1));
                  assert(sum_upto(a@, i as int + 1) > threshold);
              }
              break;
          }
          i += 1;
          running_sum = next_sum;
          
          proof {
              sum_upto_step(a@, i as int);
              assert(sum_upto(a@, i as int) == a@[i as int] + sum_upto(a@, i as int - 1));
              assert(running_sum == sum_upto(a@, i as int));
          }
      }
      
      i
  }

vc-postamble: |-
  // example showing that, with the original postcondition, the answer is non-unique!
  
  
  // proof that, with the corrected postcondition, the answer is unique
  // lemma for previous proof: when an array has strictly positive elements, the
  // sums strictly increase left to right
  
  fn main() {
  }
  
  }

