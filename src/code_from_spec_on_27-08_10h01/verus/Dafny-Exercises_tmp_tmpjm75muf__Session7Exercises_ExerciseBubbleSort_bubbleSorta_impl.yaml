vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sorted_seg(a: Seq<i32>, i: int, j: int) -> bool //j excluded
      recommends 0 <= i <= j <= a.len()
  {
      forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]
  }

vc-helpers: |-
  spec fn lemma_swap_preserves_multiset(a: Seq<i32>, i: int, j: int) -> bool
  {
      0 <= i < a.len() && 0 <= j < a.len() ==> 
      a.update(i, a[j]).update(j, a[i]).to_multiset() == a.to_multiset()
  }
  
  spec fn lemma_subrange_update_outside(s: Seq<i32>, idx: int, val: i32, start: int, end: int) -> bool
  {
      (0 <= start <= end <= s.len() && 0 <= idx < s.len() && (idx < start || idx >= end)) ==>
      s.update(idx, val).subrange(start, end) == s.subrange(start, end)
  }
  
  spec fn lemma_sorted_seg_after_swap(a: Seq<i32>, i: int, j: int, start: int, end: int) -> bool
  {
      (0 <= i < a.len() && 0 <= j < a.len() && 0 <= start <= end <= a.len() && 
       sorted_seg(a, start, end) && (i < start || i >= end) && (j < start || j >= end)) ==>
      sorted_seg(a.update(i, a[j]).update(j, a[i]), start, end)
  }
  
  spec fn lemma_sorted_seg_bubble_step(a: Seq<i32>, i: int, start: int, end: int) -> bool
  {
      (0 <= start <= i < i + 1 < end <= a.len() && sorted_seg(a, start, i + 1) && a[i] <= a[i + 1]) ==>
      sorted_seg(a, start, i + 2)
  }
  
  spec fn lemma_sorted_seg_after_bubble_pass(a: Seq<i32>, start: int, end: int) -> bool
  {
      (0 <= start < end <= a.len() && sorted_seg(a, start, end - 1) && 
       (forall|k: int| start <= k < end - 1 ==> a[k] <= a[end - 1])) ==>
      sorted_seg(a, start, end)
  }

vc-spec: |-
  // <vc-spec>
  fn bubbleSorta(a: &mut Vec<i32>, c: usize, f: usize) //f excluded
      requires 
          c <= f,
          f <= old(a).len(), //when c==f empty sequence
      ensures 
          sorted_seg(a@, c as int, f as int),
          a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
          a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
          a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),
  // </vc-spec>

vc-code: |-
  {
      if c >= f {
          return;
      }
      
      let mut i = f;
      while i > c
          invariant
              c <= i <= f,
              sorted_seg(a@, i as int, f as int),
              a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
              a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
              a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),
          decreases i - c
      {
          let mut j = c;
          while j < i - 1
              invariant
                  c <= j < i,
                  i <= f,
                  a@.subrange(c as int, f as int).to_multiset() == old(a)@.subrange(c as int, f as int).to_multiset(),
                  a@.subrange(0, c as int) == old(a)@.subrange(0, c as int),
                  a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),
                  sorted_seg(a@, i as int, f as int),
                  forall|k: int| c <= k <= j ==> a@[k] <= a@[i as int - 1],
              decreases i - 1 - j
          {
              if a[j] > a[j + 1] {
                  let temp = a[j];
                  let next = a[j + 1];
                  a.set(j, next);
                  a.set(j + 1, temp);
              }
              j += 1;
          }
          i -= 1;
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

