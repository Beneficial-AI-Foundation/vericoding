vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // The order of the recursion in these two functions
  // must match the order of the iteration in the algorithm above
  spec fn min_seq(a: Seq<int>) -> int
      recommends a.len() > 0
      decreases a.len() when a.len() > 0
  {
      if a.len() == 1 {
          a[0]
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          assume(prefix.len() < a.len());
          let min_prefix = min_seq(prefix);
          if a[a.len() - 1] <= min_prefix {
              a[a.len() - 1]
          } else {
              min_prefix
          }
      }
  }
  
  spec fn max_seq(a: Seq<int>) -> int
      recommends a.len() > 0
      decreases a.len() when a.len() > 0
  {
      if a.len() == 1 {
          a[0]
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          assume(prefix.len() < a.len());
          let max_prefix = max_seq(prefix);
          if a[a.len() - 1] >= max_prefix {
              a[a.len() - 1]
          } else {
              max_prefix
          }
      }
  }

vc-helpers: |-
  proof fn lemma_min_seq_correctness(a: Seq<int>, i: int)
      requires 
          a.len() > 0,
          0 <= i < a.len()
      ensures min_seq(a) <= a[i]
      decreases a.len()
  {
      if a.len() == 1 {
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          if i < prefix.len() {
              lemma_min_seq_correctness(prefix, i);
          }
      }
  }
  
  proof fn lemma_max_seq_correctness(a: Seq<int>, i: int)
      requires 
          a.len() > 0,
          0 <= i < a.len()
      ensures max_seq(a) >= a[i]
      decreases a.len()
  {
      if a.len() == 1 {
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          if i < prefix.len() {
              lemma_max_seq_correctness(prefix, i);
          }
      }
  }
  
  proof fn lemma_min_seq_exists(a: Seq<int>)
      requires a.len() > 0
      ensures exists|i: int| 0 <= i < a.len() && min_seq(a) == a[i]
      decreases a.len()
  {
      if a.len() == 1 {
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          lemma_min_seq_exists(prefix);
      }
  }
  
  proof fn lemma_max_seq_exists(a: Seq<int>)
      requires a.len() > 0
      ensures exists|i: int| 0 <= i < a.len() && max_seq(a) == a[i]
      decreases a.len()
  {
      if a.len() == 1 {
      } else {
          let prefix = a.subrange(0, a.len() - 1);
          lemma_max_seq_exists(prefix);
      }
  }
  
  proof fn lemma_subseq_min_extends(a: Seq<int>, i: nat)
      requires 
          a.len() > 0,
          i < a.len(),
          i > 0
      ensures
          min_seq(a.subrange(0, i as int + 1)) == 
          if a[i as int] <= min_seq(a.subrange(0, i as int)) {
              a[i as int]
          } else {
              min_seq(a.subrange(0, i as int))
          }
  {
  }
  
  proof fn lemma_subseq_max_extends(a: Seq<int>, i: nat)
      requires 
          a.len() > 0,
          i < a.len(),
          i > 0
      ensures
          max_seq(a.subrange(0, i as int + 1)) == 
          if a[i as int] >= max_seq(a.subrange(0, i as int)) {
              a[i as int]
          } else {
              max_seq(a.subrange(0, i as int))
          }
  {
  }

vc-spec: |-
  // <vc-spec>
  fn sum_min_max(a: &[i32]) -> (sum: i32)
      requires a.len() > 0
      ensures sum == max_seq(a@.map(|i: int, x: i32| x as int)) + min_seq(a@.map(|i: int, x: i32| x as int))
  // </vc-spec>

vc-code: |-
  fn sum_min_max(a: &[i32]) -> (sum: i32)
      requires a.len() > 0
      ensures sum == max_seq(a@.map(|i: int, x: i32| x as int)) + min_seq(a@.map(|i: int, x: i32| x as int))
  {
      let mut min_val = a[0];
      let mut max_val = a[0];
      let mut i = 1;
      
      while i < a.len()
          invariant 
              1 <= i <= a.len(),
              min_val == min_seq(a@.subrange(0, i as int).map(|i: int, x: i32| x as int)),
              max_val == max_seq(a@.subrange(0, i as int).map(|i: int, x: i32| x as int))
      {
          proof {
              lemma_subseq_min_extends(a@.map(|i: int, x: i32| x as int), i as nat);
              lemma_subseq_max_extends(a@.map(|i: int, x: i32| x as int), i as nat);
          }
          
          if a[i] < min_val {
              min_val = a[i];
          }
          if a[i] > max_val {
              max_val = a[i];
          }
          i += 1;
      }
      
      min_val + max_val
  }

vc-postamble: |-
  
  fn main() {}
  
  }

