vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(v: Seq<i32>, i: int, j: int) -> int
      recommends 0 <= i <= j <= v.len()
      decreases j - i when i < j
  {
      if i == j {
          0
      } else {
          sum(v, i, (j - 1) as int) + v[(j - 1) as int] as int
      }
  }
  
  spec fn sum_max_to_right(v: Seq<i32>, i: int, s: int) -> bool
      recommends 0 <= i < v.len()
  {
      forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> sum(v, l, ss) <= s
  }
  
  
  
  spec fn sum2(v: Seq<i32>, i: int, j: int) -> int
      recommends 0 <= i <= j <= v.len()
      decreases j - i when i < j
  {
      if i == j {
          0
      } else {
          v[i] as int + sum2(v, i + 1, j)
      }
  }
  
  //Now do the same but with a loop from right to left
  spec fn sum_max_to_right2(v: Seq<i32>, j: int, i: int, s: int) -> bool //maximum sum stuck to the right
      recommends 0 <= j <= i < v.len()
  {
      forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> sum2(v, l, ss) <= s
  }

vc-helpers: |-
  proof fn lemma_sum2_extend_left(v: Seq<i32>, i: int, j: int)
      requires 0 < i <= j <= v.len()
      ensures sum2(v, i - 1, j) == v[i - 1] as int + sum2(v, i, j)
      decreases j - i
  {
  }
  
  proof fn lemma_sum2_single(v: Seq<i32>, i: int)
      requires 0 <= i < v.len()
      ensures sum2(v, i, i + 1) == v[i] as int
  {
  }
  
  proof fn lemma_sum_max_monotonic(v: Seq<i32>, j: int, i: int, s1: int, s2: int)
      requires 0 <= j <= i < v.len() && s1 <= s2 && sum_max_to_right2(v, j, i, s1)
      ensures sum_max_to_right2(v, j, i, s2)
  {
  }
  
  proof fn lemma_sum_max_extend_range(v: Seq<i32>, j: int, i: int, s: int)
      requires 0 < j <= i < v.len() && sum_max_to_right2(v, j, i, s)
      ensures sum_max_to_right2(v, j - 1, i, s) ==> sum2(v, j - 1, i + 1) <= s
  {
  }

vc-spec: |-
  // <vc-spec>
  fn seg_suma_maxima2(v: &[i32], i: usize) -> (result: (i32, usize))
      requires v.len() > 0 && i < v.len()
      ensures 
          0 <= result.1 <= i && 
          result.0 as int == sum2(v@, result.1 as int, (i + 1) as int) && 
          sum_max_to_right2(v@, 0, i as int, result.0 as int)
  //Implement and verify
  // </vc-spec>

vc-code: |-
  {
      let mut max_sum = v[i];
      let mut max_start = i;
      let mut current_sum = v[i];
      let mut k = i;
      
      proof {
          lemma_sum2_single(v@, i as int);
      }
      
      while k > 0
          invariant 
              k <= i,
              current_sum as int == sum2(v@, k as int, (i + 1) as int),
              max_sum >= current_sum,
              k <= max_start <= i,
              max_sum as int == sum2(v@, max_start as int, (i + 1) as int),
              sum_max_to_right2(v@, k as int, i as int, max_sum as int)
          decreases k
      {
          k = k - 1;
          let ghost old_max_sum: i32 = max_sum;
          current_sum = current_sum + v[k];
          
          proof {
              lemma_sum2_extend_left(v@, (k + 1) as int, (i + 1) as int);
          }
          
          if current_sum > old_max_sum {
              max_sum = current_sum;
              max_start = k;
          }
          
          proof {
              if current_sum > old_max_sum {
                  // max_sum was updated, so the property holds trivially for the new max_sum
              } else {
                  // max_sum didn't change, use monotonicity
                  lemma_sum_max_monotonic(v@, k as int, i as int, old_max_sum as int, max_sum as int);
              }
          }
      }
      
      (max_sum, max_start)
  }

vc-postamble: |-
  
  fn main() {}
  
  }

