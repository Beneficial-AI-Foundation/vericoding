vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn is_sorted(s: Seq<i32>) -> bool {
      forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]
  }
  
  spec fn min_index_in_range(s: Seq<i32>, start: int, end: int) -> int
      recommends 0 <= start <= end <= s.len()
  {
      start
  }
  
  proof fn multiset_swap_preserves<T>(s1: Seq<T>, s2: Seq<T>, i: int, j: int)
      requires
          0 <= i < s1.len(),
          0 <= j < s1.len(),
          s1.len() == s2.len(),
          s2[i] == s1[j],
          s2[j] == s1[i],
          forall|k: int| 0 <= k < s1.len() && k != i && k != j ==> s1[k] == s2[k]
      ensures
          s1.to_multiset() == s2.to_multiset()
  {
  }
  
  proof fn sorted_prefix_preserved(s1: Seq<i32>, s2: Seq<i32>, pivot: int)
      requires
          s1.len() == s2.len(),
          0 <= pivot < s1.len(),
          is_sorted(s1.subrange(0, pivot as int)),
          forall|i: int| 0 <= i < pivot ==> s1[i] == s2[i]
      ensures
          is_sorted(s2.subrange(0, pivot as int))
  {
  }
  
  fn swap_spec(a: &mut Vec<i32>, i: usize, j: usize)
      requires
          i < old(a).len(),
          j < old(a).len(),
      ensures
          a.len() == old(a).len(),
          a@[i as int] == old(a)@[j as int],
          a@[j as int] == old(a)@[i as int],
          forall|k: int| 0 <= k < a.len() && k != i && k != j ==> a@[k] == old(a)@[k]
  {
      let temp = a[i];
      a.set(i, a[j]);
      a.set(j, temp);
  }

vc-spec: |-
  // <vc-spec>
  fn selection_sort(a: &mut Vec<i32>)
      ensures
          forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],
          a@.to_multiset() == old(a)@.to_multiset(),
  // </vc-spec>

vc-code: |-
  {
      let ghost original_a = a@;
      let mut i = 0;
      while i < a.len()
          invariant
              0 <= i <= a.len(),
              is_sorted(a@.subrange(0, i as int)),
              forall|x: int, y: int| 0 <= x < i && i <= y < a.len() ==> a@[x] <= a@[y],
              a@.to_multiset() == original_a.to_multiset()
      {
          let mut min_idx = i;
          let mut j = i + 1;
          
          while j < a.len()
              invariant
                  i <= min_idx < a.len(),
                  i + 1 <= j <= a.len(),
                  forall|k: int| i <= k < j ==> a@[min_idx as int] <= a@[k],
                  a@.to_multiset() == original_a.to_multiset()
          {
              if a[j] < a[min_idx] {
                  min_idx = j;
              }
              j = j + 1;
          }
          
          if min_idx != i {
              let ghost old_a = a@;
              swap_spec(a, i, min_idx);
              
              proof {
                  multiset_swap_preserves(old_a, a@, i as int, min_idx as int);
              }
          }
          
          proof {
              sorted_prefix_preserved(original_a, a@, i as int + 1);
          }
          
          i = i + 1;
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

