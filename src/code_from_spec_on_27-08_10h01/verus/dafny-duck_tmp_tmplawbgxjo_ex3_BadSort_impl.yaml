vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // program verifies
  
  spec fn sortedbad(s: Seq<char>) -> bool {
      // no b's after non-b's
      (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] == 'b' && s[j] != 'b' ==> i < j) &&
      // only non-d's before d's
      (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] != 'd' && s[j] == 'd' ==> i < j)
  }

vc-helpers: |-
  fn count_char(s: Seq<char>, c: char) -> (result: nat)
      ensures result == s.filter(FnSpec(|x: char| x == c)).len()
  {
      s.filter(FnSpec(|x: char| x == c)).len()
  }
  
  spec fn sorted_bad_form(b_count: nat, a_count: nat, d_count: nat) -> Seq<char> {
      Seq::new(b_count, |i: int| 'b') + Seq::new(a_count, |i: int| 'a') + Seq::new(d_count, |i: int| 'd')
  }
  
  proof fn lemma_sorted_bad_form_is_sortedbad(b_count: nat, a_count: nat, d_count: nat)
      ensures sortedbad(sorted_bad_form(b_count, a_count, d_count))
  {
      let result = sorted_bad_form(b_count, a_count, d_count);
      assert forall|i: int, j: int| 0 <= i <= j < result.len() && result[i] == 'b' && result[j] != 'b' implies i < j by {
          if 0 <= i <= j < result.len() && result[i] == 'b' && result[j] != 'b' {
              assert(i < b_count);
              assert(j >= b_count);
          }
      };
      assert forall|i: int, j: int| 0 <= i <= j < result.len() && result[i] != 'd' && result[j] == 'd' implies i < j by {
          if 0 <= i <= j < result.len() && result[i] != 'd' && result[j] == 'd' {
              assert(i < (b_count + a_count) as int);
              assert(j >= (b_count + a_count) as int);
          }
      };
  }
  
  proof fn lemma_multiset_preservation(a: Seq<char>, b_count: nat, a_count: nat, d_count: nat)
      requires 
          forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',
          b_count == a.filter(FnSpec(|x: char| x == 'b')).len(),
          a_count == a.filter(FnSpec(|x: char| x == 'a')).len(),
          d_count == a.filter(FnSpec(|x: char| x == 'd')).len()
      ensures sorted_bad_form(b_count, a_count, d_count).to_multiset() == a.to_multiset()
  {
      let result = sorted_bad_form(b_count, a_count, d_count);
      assert(result.to_multiset().count('b') == b_count);
      assert(result.to_multiset().count('a') == a_count);
      assert(result.to_multiset().count('d') == d_count);
      assert(a.to_multiset().count('b') == b_count);
      assert(a.to_multiset().count('a') == a_count);
      assert(a.to_multiset().count('d') == d_count);
  }

vc-spec: |-
  // <vc-spec>
  fn bad_sort(a: Seq<char>) -> (b: Seq<char>)
      requires 
          forall|i: int| 0 <= i < a.len() ==> a[i] == 'b' || a[i] == 'a' || a[i] == 'd',
      ensures 
          sortedbad(b) && b.to_multiset() == a.to_multiset(),
  // </vc-spec>

vc-code: |-
  {
      let b_count = count_char(a, 'b');
      let a_count = count_char(a, 'a');
      let d_count = count_char(a, 'd');
      
      let result = sorted_bad_form(b_count, a_count, d_count);
      
      proof {
          lemma_sorted_bad_form_is_sortedbad(b_count, a_count, d_count);
          lemma_multiset_preservation(a, b_count, a_count, d_count);
      }
      
      result
  }

vc-postamble: |-
  fn main() {}
  
  }

