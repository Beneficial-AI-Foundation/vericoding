vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // flips (i.e., reverses) array elements in the range [0..num]

vc-helpers: |-
  spec fn swap_preserves_other_elements(a: Seq<i32>, b: Seq<i32>, i: int, j: int) -> bool {
      forall|k: int| 0 <= k < a.len() && k != i && k != j ==> a[k] == b[k]
  }
  
  spec fn partial_flip_property(original: Seq<i32>, current: Seq<i32>, num: int, flipped_up_to: int) -> bool {
      forall|k: int| 0 <= k < flipped_up_to ==> current[k] == original[num - k]
  }

vc-spec: |-
  // <vc-spec>
  fn flip(a: &mut Vec<i32>, num: usize)
      requires 
          old(a).len() > 0,
          num < old(a).len(),
      ensures
          forall|k: int| 0 <= k <= num as int ==> #[trigger] a[k] == old(a)[num as int - k],
          // forall k :: num < k < a.Length ==> a[k] == old(a[k])
          a.len() == old(a).len(),
  // </vc-spec>

vc-code: |-
  {
      let mut i = 0;
      let mut j = num;
      
      while i < j
          invariant
              0 <= i <= j + 1,
              j < a.len(),
              i + j == num,
              a.len() == old(a).len(),
              forall|k: int| 0 <= k < i ==> a@[k] == old(a)@[num as int - k],
              forall|k: int| j < k <= num as int ==> a@[k] == old(a)@[num as int - k],
              forall|k: int| i <= k <= j ==> a@[k] == old(a)@[k],
              forall|k: int| (num as int < k) && (k < a.len() as int) ==> a@[k] == old(a)@[k],
          decreases j - i,
      {
          let temp = a[i];
          a.set(i, a[j]);
          a.set(j, temp);
          i = i + 1;
          j = j - 1;
      }
  }

vc-postamble: |-
  
  fn main() {}
  
  }

