vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn summing_pair(i: nat, j: nat, nums: Seq<int>, target: int) -> bool
      recommends 
          i < nums.len(),
          j < nums.len(),
  {
      i != j && nums[i as int] + nums[j as int] == target
  }

vc-helpers: |-


vc-spec: |-
  // <vc-spec>
  fn two_sum(nums: Seq<int>, target: int) -> (pair: (usize, usize))
      requires exists|i: nat, j: nat| i < j < nums.len() && summing_pair(i, j, nums, target) && forall|l: nat, m: nat| l < m < nums.len() && l != i && m != j ==> !summing_pair(l, m, nums, target)
      ensures 
          0 <= pair.0 < nums.len() && 
          0 <= pair.1 < nums.len() && 
          summing_pair(pair.0 as nat, pair.1 as nat, nums, target)
  // </vc-spec>

vc-code: |-
  {
      let mut i: usize = 0;
      while i < nums.len()
          invariant
              0 <= i <= nums.len(),
              forall|l: nat, m: nat| l < m < (i as nat) && summing_pair(l, m, nums, target) ==> 
                  exists|target_i: nat, target_j: nat| target_i < target_j < nums.len() && summing_pair(target_i, target_j, nums, target) && 
                  forall|x: nat, y: nat| x < y < nums.len() && x != target_i && y != target_j ==> !summing_pair(x, y, nums, target)
      {
          let mut j: usize = i + 1;
          while j < nums.len()
              invariant
                  0 <= i < nums.len(),
                  i + 1 <= j <= nums.len(),
                  forall|m: nat| (i as nat) < m < (j as nat) ==> !summing_pair(i as nat, m, nums, target)
          {
              if nums[i as int] + nums[j as int] == target {
                  return (i, j);
              }
              j += 1;
          }
          i += 1;
      }
      
      proof {
          assert(exists|i: nat, j: nat| i < j < nums.len() && summing_pair(i, j, nums, target));
          assert(false);
      }
      (0, 0)
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

