vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn in_array(a: &[i32], x: i32) -> bool {
      exists|i: int| 0 <= i < a.len() && a[i] == x
  }

vc-helpers: |-
  spec fn slice_contains(s: &[i32], x: i32) -> bool {
      exists|i: int| 0 <= i < s.len() && s[i] == x
  }
  
  proof fn slice_contains_equiv_in_array(s: &[i32], x: i32)
      ensures slice_contains(s, x) <==> in_array(s, x)
  {
  }
  
  proof fn in_array_from_index(a: &[i32], i: usize, x: i32)
      requires i < a.len(), a[i as int] == x
      ensures in_array(a, x)
  {
  }
  
  proof fn vec_seq_contains_equiv(v: &Vec<i32>, x: i32)
      ensures v@.contains(x) <==> exists|i: int| 0 <= i < v.len() && v[i] == x
  {
  }
  
  fn slice_contains_exec(s: &[i32], x: i32) -> (result: bool)
      ensures result == slice_contains(s, x)
  {
      for i in 0..s.len()
          invariant
              forall|j: int| 0 <= j < i ==> s[j] != x
      {
          if s[i] == x {
              proof {
                  assert(s[i as int] == x);
                  assert(0 <= i < s.len());
                  assert(exists|k: int| 0 <= k < s.len() && s[k] == x);
              }
              return true;
          }
      }
      proof {
          assert(forall|j: int| 0 <= j < s.len() ==> s[j] != x);
          assert(!exists|j: int| 0 <= j < s.len() && s[j] == x);
      }
      false
  }
  
  fn vec_contains_exec(v: &Vec<i32>, x: i32) -> (result: bool)
      ensures result == v@.contains(x)
  {
      for i in 0..v.len()
          invariant
              forall|j: int| 0 <= j < i ==> v[j] != x
      {
          if v[i] == x {
              proof {
                  vec_seq_contains_equiv(v, x);
                  assert(v[i as int] == x);
                  assert(0 <= i < v.len());
                  assert(exists|k: int| 0 <= k < v.len() && v[k] == x);
              }
              return true;
          }
      }
      proof {
          vec_seq_contains_equiv(v, x);
          assert(forall|j: int| 0 <= j < v.len() ==> v[j] != x);
          assert(!exists|j: int| 0 <= j < v.len() && v[j] == x);
      }
      false
  }

vc-spec: |-
  // <vc-spec>
  fn shared_elements(a: &[i32], b: &[i32]) -> (result: Vec<i32>)
      ensures
          // All elements in the output are in both a and b
          forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),
          // The elements in the output are all different
          forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]
  // </vc-spec>

vc-code: |-
  {
      let mut result = Vec::new();
      
      for i in 0..a.len()
          invariant
              forall|x: i32| result@.contains(x) ==> (in_array(a, x) && in_array(b, x)),
              forall|k: int, l: int| 0 <= k < l < result.len() ==> result[k] != result[l]
      {
          let elem = a[i];
          
          if slice_contains_exec(b, elem) && !vec_contains_exec(&result, elem) {
              proof {
                  in_array_from_index(a, i, elem);
                  slice_contains_equiv_in_array(b, elem);
              }
              result.push(elem);
          }
      }
      
      result
  }

vc-postamble: |-
  fn main() {
  }
  
  }

