vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  ///////////////////
  // Binary search
  ///////////////////
  
  
  spec fn is_sorted(a: &[int]) -> bool {
      forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]
  }
  
  
  // a[lo] <= a[lo+1] <= ... <= a[hi-2] <= a[hi-1]
  
  /* Note: the following definition of is_sorted:
  
  
  although equivalent to the one above is not enough for Verus to be able 
  to prove the invariants for the loop in bin_search.
  
  The given one works because it *explicitly* states that every element 
  of the input array is smaller than or equal to all later elements. 
  This fact is implied by the alternative definition of is_sorted given 
  here (which only talks about array elements and their successors). 
  However, it needs to be derived as an auxiliary lemma first, something 
  that Verus is not currently able to do automatically. 
  */

vc-helpers: |-
  fn sorted_transitive(a: &[int], i: int, j: int, k: int)
      requires
          is_sorted(a),
          0 <= i <= j <= k < a.len(),
      ensures a[i] <= a[k]
  {
  }
  
  fn sorted_slice_property(a: &[int], lo: int, hi: int, target: int)
      requires
          is_sorted(a),
          0 <= lo < a.len(),
          0 <= hi < a.len(),
          lo <= hi,
          a[lo] > target,
      ensures forall|i: int| lo <= i <= hi ==> a[i] > target
  {
  }
  
  fn sorted_slice_property_upper(a: &[int], lo: int, hi: int, target: int)
      requires
          is_sorted(a),
          0 <= lo < a.len(),
          0 <= hi < a.len(),
          lo <= hi,
          a[hi] < target,
      ensures forall|i: int| lo <= i <= hi ==> a[i] < target
  {
  }

vc-spec: |-
  // <vc-spec>
  fn bin_search(a: &[int], k: int) -> (b: bool)
      requires is_sorted(a)
      ensures b == exists|i: int| 0 <= i < a.len() && a[i] == k
  // </vc-spec>

vc-code: |-
  {
      if a.len() == 0 {
          return false;
      }
      
      let mut lo: usize = 0;
      let mut hi: usize = a.len() - 1;
      
      while lo <= hi
          invariant
              0 <= lo <= a.len(),
              hi < a.len(),
              is_sorted(a),
              forall|i: int| 0 <= i < lo ==> a[i] < k,
              forall|i: int| hi < i < a.len() ==> a[i] > k,
              (exists|i: int| 0 <= i < a.len() && a[i] == k) == 
                  (exists|i: int| lo <= i <= hi && a[i] == k),
          decreases hi + 1 - lo
      {
          let mid = lo + (hi - lo) / 2;
          
          if a[mid] == k {
              return true;
          } else if a[mid] < k {
              if mid == a.len() - 1 {
                  proof {
                      assert(forall|i: int| hi < i < a.len() ==> a[i] > k);
                      assert(a[mid as int] < k);
                      assert(forall|i: int| lo <= i <= hi ==> a[i] < k);
                      assert(forall|i: int| 0 <= i < a.len() ==> a[i] != k);
                  }
                  break;
              }
              lo = mid + 1;
          } else {
              if mid == 0 {
                  proof {
                      assert(forall|i: int| 0 <= i < lo ==> a[i] < k);
                      assert(a[mid as int] > k);
                      assert(forall|i: int| 0 <= i <= hi ==> a[i] > k);
                      assert(forall|i: int| 0 <= i < a.len() ==> a[i] != k);
                  }
                  break;
              }
              hi = mid - 1;
          }
      }
      
      proof {
          assert(lo > hi);
          assert((exists|i: int| 0 <= i < a.len() && a[i] == k) == 
                 (exists|i: int| lo <= i <= hi && a[i] == k));
          assert(!(exists|i: int| lo <= i <= hi && a[i] == k));
          assert(!(exists|i: int| 0 <= i < a.len() && a[i] == k));
      }
      
      false
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

