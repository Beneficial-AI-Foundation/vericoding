vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(a: Seq<i32>, i: int) -> int
      recommends 
          0 <= i < a.len(),
      decreases i
  {
      if 0 <= i < a.len() {
          a[i] as int + if i == 0 { 0 } else { sum(a, i - 1) }
      } else {
          0
      }
  }

vc-helpers: |-
  proof fn lemma_sum_monotonic(a: Seq<i32>, i: int)
      requires 
          0 <= i < a.len(),
      ensures 
          sum(a, i) == a[i] as int + sum(a, i - 1),
      decreases i
  {
  }
  
  proof fn lemma_index_bounds(i: usize, len: usize)
      requires i < len
      ensures 
          i as int < len as int,
          0 <= i as int
  {
  }
  
  proof fn lemma_bounds_check(i: usize, len: usize)
      requires i > 0, i < len
      ensures 
          (i - 1) < len,
          0 <= (i - 1) as int,
          (i - 1) as int < len as int
  {
  }

vc-spec: |-
  // <vc-spec>
  fn cumsum(a: &[i32], b: &mut [i32])
      requires 
          a.len() == old(b).len(),
          a.len() > 0,
      ensures 
          forall|i: int| 0 <= i < a.len() ==> b[i] as int == sum(a@, i),
  // </vc-spec>

vc-code: |-
  {
      let mut i = 0;
      while i < a.len()
          invariant
              i <= a.len(),
              forall|j: int| 0 <= j < i ==> 0 <= j < a.len() && 0 <= j < b.len() && b[j] as int == sum(a@, j),
          decreases a.len() - i
      {
          if i == 0 {
              proof {
                  lemma_index_bounds(i, a.len());
              }
              b[i] = a[i];
          } else {
              proof {
                  lemma_bounds_check(i, a.len());
                  lemma_index_bounds(i, a.len());
              }
              b[i] = a[i] + b[i - 1];
              proof {
                  lemma_sum_monotonic(a@, i as int);
              }
          }
          i += 1;
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

