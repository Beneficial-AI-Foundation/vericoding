vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  // Function SetLessThan equivalent
  spec fn set_less_than(numbers: Set<int>, threshold: int) -> Set<int> {
      numbers.filter(|i: int| i < threshold)
  }
  
  // Function seqSet equivalent
  spec fn seq_set(nums: Seq<int>, index: nat) -> Set<int> {
      if index < nums.len() {
          Set::new(|x: int| exists|i: int| 0 <= i < index && i < nums.len() && nums[i] == x)
      } else {
          Set::empty()
      }
  }
  
  // Predicate SortedSeq equivalent
  spec fn sorted_seq(a: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
  }
  
  // Method GetInsertIndex equivalent
  fn get_insert_index(a: &[int], limit: usize, x: int) -> (idx: usize)
      requires 
          !a@.contains(x),
          limit <= a.len(),
          sorted_seq(a@.take(limit as int)),
      ensures
          idx <= limit,
          sorted_seq(a@.take(limit as int)),
          idx > 0 ==> a[(idx - 1) as int] < x,
          idx < limit ==> x < a[idx as int],
  {
      assume(false);
      0
  }
  
  // Predicate sorted equivalent
  spec fn sorted(a: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] < a[j]
  }
  
  // Predicate distinct equivalent
  spec fn distinct(a: Seq<int>) -> bool {
      forall|i: int, j: int| (0 <= i < a.len() && 0 <= j < a.len() && i != j) ==> a[i] != a[j]
  }
  
  // Predicate sorted_eq equivalent
  spec fn sorted_eq(a: Seq<int>) -> bool {
      forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]
  }
  
  // Predicate lessThan equivalent
  spec fn less_than(a: Seq<int>, key: int) -> bool {
      forall|i: int| 0 <= i < a.len() ==> a[i] < key
  }
  
  // Predicate greaterThan equivalent
  spec fn greater_than(a: Seq<int>, key: int) -> bool {
      forall|i: int| 0 <= i < a.len() ==> a[i] > key
  }
  
  // Predicate greaterEqualThan equivalent
  spec fn greater_equal_than(a: Seq<int>, key: int) -> bool {
      forall|i: int| 0 <= i < a.len() ==> a[i] >= key
  }
  
  // Function count equivalent
  spec fn count(a: Seq<bool>) -> nat
      decreases a.len()
  {
      if a.len() == 0 { 
          0nat 
      } else { 
          (if a[0] { 1nat } else { 0nat }) + count(a.drop_first())
      }
  }

vc-helpers: |-
  spec fn get_insert_index_spec(a: Seq<int>, limit: nat, x: int) -> nat
      requires 
          !a.contains(x),
          limit <= a.len(),
          sorted_seq(a.take(limit as int)),
  {
      if limit == 0 {
          0
      } else {
          let mut idx: nat = 0;
          while idx < limit && a[idx as int] < x {
              idx = idx + 1;
          }
          idx
      }
  }
  
  proof fn lemma_sorted_implies_sorted_eq(s: Seq<int>)
      requires sorted(s)
      ensures sorted_eq(s)
  {
  }
  
  proof fn lemma_get_insert_index_properties(a: &[int], limit: usize, x: int, idx: usize)
      requires 
          !a@.contains(x),
          limit <= a.len(),
          sorted_seq(a@.take(limit as int)),
          idx == get_insert_index(a, limit, x),
      ensures
          idx <= limit,
          idx > 0 ==> a[(idx - 1) as int] < x,
          idx < limit ==> x < a[idx as int],
  {
  }
  
  proof fn lemma_take_preserves_sorted(s: Seq<int>, n: int)
      requires sorted(s), n <= s.len()
      ensures sorted(s.take(n))
  {
  }
  
  proof fn lemma_insert_preserves_sorted(left: Seq<int>, x: int, right: Seq<int>)
      requires 
          sorted(left),
          sorted(right),
          less_than(left, x),
          greater_than(right, x),
      ensures sorted(left + seq![x] + right)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn insert_into_sorted(a: &[int], limit: usize, key: int) -> (b: Vec<int>)
      requires 
          key > 0,
          !a@.contains(key),
          limit < a.len(),
          forall|i: int| 0 <= i < limit ==> a[i] > 0,
          forall|i: int| limit <= i < a.len() ==> a[i] == 0,
          sorted(a@.take(limit as int)),
      ensures
          b.len() == a.len(),
          sorted(b@.take((limit + 1) as int)),
          forall|i: int| limit + 1 <= i < b.len() ==> b[i] == 0,
          forall|i: int| 0 <= i < limit ==> a@.contains(b[i]),
          forall|i: int| 0 <= i < limit + 1 ==> b[i] > 0,
  // </vc-spec>

vc-code: |-
  {
      let ghost spec_idx = get_insert_index_spec(a@, limit as nat, key);
      let idx = get_insert_index(a, limit, key);
      assert(idx == spec_idx);
      
      let mut b: Vec<int> = Vec::with_capacity(a.len());
      
      let mut i: usize = 0;
      while i < idx
          invariant
              0 <= i <= idx,
              idx <= limit,
              b.len() == i,
              forall|j: int| 0 <= j < i ==> b@[j] == a[j],
              forall|j: int| 0 <= j < i ==> b@[j] > 0,
              sorted(b@),
      {
          b.push(a[i]);
          i += 1;
      }
      
      b.push(key);
      
      while i < limit
          invariant
              idx <= i <= limit,
              b.len() == i + 1,
              b@[idx as int] == key,
              forall|j: int| 0 <= j < idx ==> b@[j] == a[j],
              forall|j: int| idx < j < i + 1 ==> b@[j] == a[(j - 1) as int],
              forall|j: int| 0 <= j < i + 1 ==> b@[j] > 0,
              sorted(b@.take((i + 1) as int)),
      {
          b.push(a[i]);
          i += 1;
      }
      
      while i < a.len()
          invariant
              limit <= i <= a.len(),
              b.len() == i + 1,
              b@[idx as int] == key,
              forall|j: int| 0 <= j < idx ==> b@[j] == a[j],
              forall|j: int| idx < j < limit + 1 ==> b@[j] == a[(j - 1) as int],
              forall|j: int| limit + 1 <= j < i + 1 ==> b@[j] == 0,
              forall|j: int| 0 <= j < limit + 1 ==> b@[j] > 0,
              sorted(b@.take((limit + 1) as int)),
      {
          b.push(a[i]);
          i += 1;
      }
      
      b
  }

vc-postamble: |-
  fn main() {}
  
  }

