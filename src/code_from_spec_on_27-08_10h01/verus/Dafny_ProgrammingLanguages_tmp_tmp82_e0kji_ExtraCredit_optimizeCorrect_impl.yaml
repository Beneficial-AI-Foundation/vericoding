vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  #[derive(PartialEq, Eq)]
  enum Exp {
      Const(int),
      Var(String),
      Plus(Box<Exp>, Box<Exp>),
      Mult(Box<Exp>, Box<Exp>),
  }
  
  spec fn eval(e: Exp, store: Map<String, int>) -> int
      decreases e
  {
      match e {
          Exp::Const(n) => n,
          Exp::Var(s) => if store.dom().contains(s) { store[s] } else { -1 },
          Exp::Plus(e1, e2) => eval(*e1, store) + eval(*e2, store),
          Exp::Mult(e1, e2) => eval(*e1, store) * eval(*e2, store),
      }
  }
  
  //fill this function in to make optimizeFeatures work
  spec fn optimize(e: Exp) -> Exp
      decreases e
  {
      match e {
          Exp::Mult(e1, e2) => {
              match (*e1, *e2) {
                  (Exp::Const(n1), _) if n1 == 0 => Exp::Const(0),
                  (_, Exp::Const(n2)) if n2 == 0 => Exp::Const(0),
                  (Exp::Const(n1), e2_inner) if n1 == 1 => e2_inner,
                  (e1_inner, Exp::Const(n2)) if n2 == 1 => e1_inner,
                  (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 * n2),
                  _ => e,
              }
          },
          Exp::Plus(e1, e2) => {
              match (*e1, *e2) {
                  (Exp::Const(n1), e2_inner) if n1 == 0 => e2_inner,
                  (e1_inner, Exp::Const(n2)) if n2 == 0 => e1_inner,
                  (Exp::Const(n1), Exp::Const(n2)) => Exp::Const(n1 + n2),
                  _ => e,
              }
          },
          _ => e,
      }
  } 
  
  //as you write optimize this will become unproved
  //you must write proof code so that Verus can prove this

vc-helpers: |-
  proof fn eval_mult_zero_left(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e1, s) == 0
      ensures eval(Exp::Mult(Box::new(e1), Box::new(e2)), s) == 0
  {
  }
  
  proof fn eval_mult_zero_right(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e2, s) == 0
      ensures eval(Exp::Mult(Box::new(e1), Box::new(e2)), s) == 0
  {
  }
  
  proof fn eval_mult_one_left(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e1, s) == 1
      ensures eval(Exp::Mult(Box::new(e1), Box::new(e2)), s) == eval(e2, s)
  {
  }
  
  proof fn eval_mult_one_right(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e2, s) == 1
      ensures eval(Exp::Mult(Box::new(e1), Box::new(e2)), s) == eval(e1, s)
  {
  }
  
  proof fn eval_plus_zero_left(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e1, s) == 0
      ensures eval(Exp::Plus(Box::new(e1), Box::new(e2)), s) == eval(e2, s)
  {
  }
  
  proof fn eval_plus_zero_right(e1: Exp, e2: Exp, s: Map<String, int>)
      requires eval(e2, s) == 0
      ensures eval(Exp::Plus(Box::new(e1), Box::new(e2)), s) == eval(e1, s)
  {
  }

vc-spec: |-
  // <vc-spec>
  fn optimize_correct(e: Exp, s: Map<String, int>)
      ensures eval(e, s) == eval(optimize(e), s)
  // </vc-spec>

vc-code: |-
  {
      proof {
          match e {
              Exp::Mult(e1, e2) => {
                  match (*e1, *e2) {
                      (Exp::Const(n1), _) if n1 == 0 => {
                          eval_mult_zero_left(*e1, *e2, s);
                      },
                      (_, Exp::Const(n2)) if n2 == 0 => {
                          eval_mult_zero_right(*e1, *e2, s);
                      },
                      (Exp::Const(n1), e2_inner) if n1 == 1 => {
                          eval_mult_one_left(*e1, *e2, s);
                      },
                      (e1_inner, Exp::Const(n2)) if n2 == 1 => {
                          eval_mult_one_right(*e1, *e2, s);
                      },
                      (Exp::Const(n1), Exp::Const(n2)) => {
                      },
                      _ => {
                      },
                  }
              },
              Exp::Plus(e1, e2) => {
                  match (*e1, *e2) {
                      (Exp::Const(n1), e2_inner) if n1 == 0 => {
                          eval_plus_zero_left(*e1, *e2, s);
                      },
                      (e1_inner, Exp::Const(n2)) if n2 == 0 => {
                          eval_plus_zero_right(*e1, *e2, s);
                      },
                      (Exp::Const(n1), Exp::Const(n2)) => {
                      },
                      _ => {
                      },
                  }
              },
              _ => {
              },
          }
      }
  }

vc-postamble: |-
  fn main() {}
  
  }

