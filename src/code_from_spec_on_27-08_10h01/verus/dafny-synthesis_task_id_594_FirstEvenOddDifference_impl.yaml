vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_even(n: int) -> bool {
      n % 2 == 0
  }
  
  spec fn is_odd(n: int) -> bool {
      n % 2 != 0
  }

vc-helpers: |-
  proof fn lemma_mod_properties(n: i32)
      ensures 
          is_even(n as int) <==> (n as int) % 2 == 0,
          is_odd(n as int) <==> (n as int) % 2 != 0,
          is_even(n as int) <==> !is_odd(n as int)
  {
  }
  
  proof fn lemma_exists_indices(a: &[i32]) -> (res: (usize, usize))
      requires 
          exists|i: int| 0 <= i < a.len() && is_even(a@[i] as int),
          exists|i: int| 0 <= i < a.len() && is_odd(a@[i] as int),
      ensures 
          res.0 < a.len(),
          res.1 < a.len(),
          is_even(a@[res.0 as int] as int),
          is_odd(a@[res.1 as int] as int)
  {
      let even_idx = choose|i: int| 0 <= i < a.len() && is_even(a@[i] as int);
      let odd_idx = choose|i: int| 0 <= i < a.len() && is_odd(a@[i] as int);
      (even_idx as usize, odd_idx as usize)
  }

vc-spec: |-
  // <vc-spec>
  fn first_even_odd_difference(a: &[i32]) -> (diff: i32)
      requires 
          a.len() >= 2,
          exists|i: int| 0 <= i < a.len() && is_even(a[i] as int),
          exists|i: int| 0 <= i < a.len() && is_odd(a[i] as int),
      ensures 
          exists|i: int, j: int| 
              0 <= i < a.len() && 
              0 <= j < a.len() && 
              is_even(a[i] as int) && 
              is_odd(a[j] as int) && 
              diff == a[i] - a[j] && 
              (forall|k: int| 0 <= k < i ==> is_odd(a[k] as int)) && 
              (forall|k: int| 0 <= k < j ==> is_even(a[k] as int))
  // </vc-spec>

vc-code: |-
  {
      let mut first_even_idx: Option<usize> = None;
      let mut first_odd_idx: Option<usize> = None;
      
      let mut i = 0;
      while i < a.len()
          invariant 
              0 <= i <= a.len(),
              first_even_idx.is_some() ==> (
                  first_even_idx.unwrap() < a.len() &&
                  is_even(a@[first_even_idx.unwrap() as int] as int) &&
                  forall|k: int| 0 <= k < first_even_idx.unwrap() ==> is_odd(a@[k] as int)
              ),
              first_odd_idx.is_some() ==> (
                  first_odd_idx.unwrap() < a.len() &&
                  is_odd(a@[first_odd_idx.unwrap() as int] as int) &&
                  forall|k: int| 0 <= k < first_odd_idx.unwrap() ==> is_even(a@[k] as int)
              ),
              first_even_idx.is_none() ==> forall|k: int| 0 <= k < i ==> is_odd(a@[k] as int),
              first_odd_idx.is_none() ==> forall|k: int| 0 <= k < i ==> is_even(a@[k] as int),
      {
          let ghost n = a@[i as int] as int;
          if first_even_idx.is_none() && is_even(n) {
              first_even_idx = Some(i);
          }
          if first_odd_idx.is_none() && is_odd(n) {
              first_odd_idx = Some(i);
          }
          if first_even_idx.is_some() && first_odd_idx.is_some() {
              break;
          }
          i = i + 1;
      }
      
      let even_idx = first_even_idx.unwrap();
      let odd_idx = first_odd_idx.unwrap();
      
      a[even_idx] - a[odd_idx]
  }

vc-postamble: |-
  
  fn main() {
  }
  
  }

