vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_substring(sub: Seq<char>, str: Seq<char>) -> bool
  {
      exists|i: int| 0 <= i <= str.len() - sub.len() && str.subrange(i, i + sub.len()) == sub
  }
  
  spec fn is_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool
  {
      pre.len() <= str.len() && pre == str.subrange(0, pre.len() as int)
  }
  
  spec fn is_not_prefix_pred(pre: Seq<char>, str: Seq<char>) -> bool
  {
      pre.len() > str.len() || pre != str.subrange(0, pre.len() as int)
  }
  
  spec fn is_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool
  {
      exists|i: int| 0 <= i <= str.len() && is_prefix_pred(sub, str.subrange(i, str.len() as int))
  }
  
  spec fn is_not_substring_pred(sub: Seq<char>, str: Seq<char>) -> bool
  {
      forall|i: int| 0 <= i <= str.len() ==> is_not_prefix_pred(sub, str.subrange(i, str.len() as int))
  }
  
  spec fn have_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool
  {
      exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && is_substring_pred(str1.subrange(i1, j1), str2)
  }
  
  spec fn have_not_common_k_substring_pred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool
  {
      forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> is_not_substring_pred(str1.subrange(i1, j1), str2)
  }
  
  fn have_common_k_substring(k: usize, str1: &Vec<char>, str2: &Vec<char>) -> (found: bool)
      ensures found <==> have_common_k_substring_pred(k as nat, str1@, str2@)
  {
      // Check that both strings are larger than k
      if k > str1.len() || k > str2.len() {
          return false;
      }
      // Initialize variables
      let mut i: usize = 0;
      let mut temp = false;
  
      // Don't want to exceed the bounds of str1 when checking for the element that is k entries away
      while i <= str1.len() - k
          invariant 
              // Invariant to stay within bounds
              0 <= i <= (str1.len() - k) + 1,
              // Invariant to show that when temp is true, it is a substring
              temp ==> 0 <= i <= (str1.len() - k) && is_substring_pred(str1@.subrange(i as int, (i + k) as int), str2@),
              // Invariant to show that when temp is false, it is not a substring
              !temp ==> (forall|m: int, n: int| (0 <= m < i && n == m + (k as int)) ==> is_not_substring_pred(str1@.subrange(m, n), str2@)),
          // Telling Verus that i is the value that is increasing
          decreases str1.len() - k - i
      {
          assume(false);
  
          // Get an index from the array position we are at to the array position that is k away and check the substring
          proof {
              let ghost_i = i as int;
              let ghost_k = k as int;
              let substr = str1@.subrange(ghost_i, ghost_i + ghost_k);
              temp = is_substring(substr, str2@);
          }
          if temp == true {
              return true;
          }
          i = i + 1;
      }
      false
  }

vc-helpers: |-
  proof fn lemma_empty_substring_exists(str1: Seq<char>, str2: Seq<char>)
      ensures have_common_k_substring_pred(0, str1, str2)
  {
      assert(str1.subrange(0, 0) == Seq::<char>::empty());
      assert(is_substring_pred(Seq::<char>::empty(), str2)) by {
          assert(is_prefix_pred(Seq::<char>::empty(), str2.subrange(0, str2.len() as int)));
      }
  }
  
  proof fn lemma_k_too_large_no_substring(k: nat, str1: Seq<char>, str2: Seq<char>)
      requires k > str1.len()
      ensures !have_common_k_substring_pred(k, str1, str2)
  {
      assert(forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> false) by {
          assert(str1.len() - k < 0);
      }
  }
  
  proof fn lemma_have_common_preserves_smaller(k1: nat, k2: nat, str1: Seq<char>, str2: Seq<char>)
      requires k1 <= k2, have_common_k_substring_pred(k2, str1, str2), k2 <= str1.len()
      ensures have_common_k_substring_pred(k1, str1, str2)
  {
      if k1 == 0 {
          lemma_empty_substring_exists(str1, str2);
      } else {
          let (i1, j1) = choose|i1: int, j1: int| 
              0 <= i1 <= str1.len() - k2 && j1 == i1 + k2 && 
              is_substring_pred(str1.subrange(i1, j1), str2);
          
          let substr_k2 = str1.subrange(i1, j1);
          let substr_k1 = str1.subrange(i1, i1 + k1 as int);
          
          assert(is_substring_pred(substr_k1, str2)) by {
              assert(is_prefix_pred(substr_k1, substr_k2));
              assert(exists|pos: int| 0 <= pos <= str2.len() && 
                     is_prefix_pred(substr_k2, str2.subrange(pos, str2.len() as int)));
              let pos: int = choose|pos: int| 0 <= pos <= str2.len() && 
                            is_prefix_pred(substr_k2, str2.subrange(pos, str2.len() as int));
              assert(is_prefix_pred(substr_k1, str2.subrange(pos, str2.len() as int)));
          }
          
          assert(0 <= i1 <= str1.len() - k1);
      }
  }
  
  exec fn is_substring_exec(substr: &Vec<char>, str: &Vec<char>) -> (result: bool)
      ensures result <==> is_substring(substr@, str@)
  {
      if substr.len() > str.len() {
          return false;
      }
      
      let mut i = 0;
      while i <= str.len() - substr.len()
          invariant 
              0 <= i <= str.len() - substr.len() + 1,
              forall|j: int| 0 <= j < i ==> str@.subrange(j, j + substr.len() as int) != substr@
          decreases str.len() - substr.len() - i
      {
          let mut match_found = true;
          let mut k = 0;
          while k < substr.len()
              invariant 
                  0 <= k <= substr.len(),
                  match_found <==> (forall|m: int| 0 <= m < k ==> str@[i as int + m] == substr@[m])
              decreases substr.len() - k
          {
              if str[i + k] != substr[k] {
                  match_found = false;
                  break;
              }
              k = k + 1;
          }
          
          if match_found {
              return true;
          }
          i = i + 1;
      }
      false
  }

vc-spec: |-
  // <vc-spec>
  fn max_common_substring_length(str1: &Vec<char>, str2: &Vec<char>) -> (len: usize)
      requires str1.len() <= str2.len()
      ensures 
          forall|k: int| len < k <= str1.len() ==> !have_common_k_substring_pred(k as nat, str1@, str2@),
          have_common_k_substring_pred(len as nat, str1@, str2@)
  // </vc-spec>

vc-code: |-
  {
      if str1.len() == 0 {
          proof {
              lemma_empty_substring_exists(str1@, str2@);
          }
          return 0;
      }
      
      let mut max_len = 0;
      let mut k = str1.len();
      
      while k > 0
          invariant 
              0 <= k <= str1.len(),
              0 <= max_len <= str1.len(),
              max_len <= k,
              forall|i: int| max_len < i <= str1.len() ==> !have_common_k_substring_pred(i as nat, str1@, str2@),
              max_len == 0 || have_common_k_substring_pred(max_len as nat, str1@, str2@)
          decreases k
      {
          let found = have_common_k_substring(k, str1, str2);
          if found {
              max_len = k;
              break;
          }
          k = k - 1;
      }
      
      if max_len == 0 {
          proof {
              lemma_empty_substring_exists(str1@, str2@);
          }
      }
      
      max_len
  }

vc-postamble: |-
  
  fn main() {}
  
  }

