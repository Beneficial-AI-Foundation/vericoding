vc-description: |-


vc-preamble: |-
  #![crate_name = "max_segment_sum"]
  
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(a: Seq<i32>, s: int, t: int) -> int
      decreases t - s,
  {
      if s < 0 || s >= t || t > a.len() {
          0
      } else {
          a[t - 1] + sum(a, s, t - 1)
      }
  }

vc-helpers: |-
  #[verifier::external_body]
  fn add(a: i64, b: i32) -> (result: i64)
      ensures
          result == a + b,
  {
      a + b as i64
  }
  
  spec fn sum_nonneg(a: Seq<i32>, s: int, t: int) -> bool {
      s >= 0 && s <= t && t <= a.len()
  }
  
  proof fn sum_empty(a: Seq<i32>, s: int)
      ensures sum(a, s, s) == 0
  {
  }
  
  proof fn sum_extend(a: Seq<i32>, s: int, t: int)
      requires sum_nonneg(a, s, t + 1)
      ensures sum(a, s, t + 1) == sum(a, s, t) + a[t]
  {
  }
  
  proof fn sum_monotone_helper(a: Seq<i32>, s1: int, t1: int, s2: int, t2: int)
      requires 
          sum_nonneg(a, s1, t1),
          sum_nonneg(a, s2, t2),
          s1 <= s2,
          t1 <= t2,
          forall|i: int| 0 <= i < a.len() ==> a[i] >= 0
      ensures sum(a, s1, t1) <= sum(a, s2, t2)
  {
  }

vc-spec: |-
  #[verifier::loop_isolation(false)]
  fn max_segment_sum(a: &Vec<i32>, s: usize, t: usize) -> (p: (usize, usize)) by (nonlinear_arith)
      ensures
          ({ let (i, j) = p; 0 <= i <= j <= a.len() }),
          ({ let (i, j) = p; forall|k: int, l: int| 0 <= k <= l <= a.len() ==> sum(a@, k, l) <= sum(a@, i as int, j as int) })

vc-code: |-
  {
      let mut best_i = 0;
      let mut best_j = 0;
      let mut best_sum = 0;
      
      let mut i = 0;
      while i <= a.len()
          invariant
              0 <= i <= a.len(),
              0 <= best_i <= best_j <= a.len(),
              forall|k: int, l: int| 0 <= k <= l <= i ==> sum(a@, k, l) <= sum(a@, best_i as int, best_j as int)
      {
          let mut j = i;
          while j <= a.len()
              invariant
                  i <= j <= a.len(),
                  0 <= best_i <= best_j <= a.len(),
                  forall|k: int, l: int| 0 <= k <= l <= i ==> sum(a@, k, l) <= sum(a@, best_i as int, best_j as int),
                  forall|l: int| i <= l <= j ==> sum(a@, i as int, l) <= sum(a@, best_i as int, best_j as int)
          {
              let current_sum = if i == j { 
                  0 
              } else {
                  let mut curr = 0i64;
                  let mut k = i;
                  while k < j
                      invariant
                          i <= k <= j,
                          curr == sum(a@, i as int, k as int)
                  {
                      curr = add(curr, a[k]);
                      k += 1;
                  }
                  curr as i32
              };
              
              if current_sum > best_sum {
                  best_i = i;
                  best_j = j;
                  best_sum = current_sum;
              }
              j += 1;
          }
          i += 1;
      }
      
      (best_i, best_j)
  }

vc-postamble: |-
  
  fn main() {}
  }

