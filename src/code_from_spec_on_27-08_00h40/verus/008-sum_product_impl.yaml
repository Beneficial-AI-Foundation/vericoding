vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(0, |acc: int, x| acc + x)
  }
  // pure-end
  // pure-end
  
  spec fn product(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(1, |acc: int, x| acc * x)
  }
  // pure-end

vc-helpers: |-
  proof fn sum_bound(numbers: Seq<u32>)
      ensures
          sum(numbers) <= numbers.len() * u32::MAX,
      decreases numbers.len(),
  {
      if numbers.len() == 0 {
      } else {
          sum_bound(numbers.drop_last());
      }
  }
  
  proof fn product_bound_helper(numbers: Seq<u32>, acc: u64)
      requires acc <= u32::MAX,
      ensures product_fits_u32(numbers) ==> acc * product(numbers) <= u32::MAX,
      decreases numbers.len(),
  {
      if numbers.len() == 0 {
      } else if numbers[0] == 0 {
      } else {
          let new_acc = acc * numbers[0] as u64;
          if new_acc <= u32::MAX {
              product_bound_helper(numbers.drop_first(), new_acc);
          }
      }
  }
  
  spec fn product_fits_u32(numbers: Seq<u32>) -> bool {
      product(numbers) <= u32::MAX
  }

vc-spec: |-
  fn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))
      // pre-conditions-start
      requires
          numbers.len() < u32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result.0 == sum(numbers@),
          result.1 matches Some(v) ==> v == product(numbers@),
      // post-conditions-end

vc-code: |-
  {
      let mut total_sum: u64 = 0;
      let mut total_product: u64 = 1;
      let mut product_valid = true;
      
      for i in 0..numbers.len()
          invariant
              total_sum == sum(numbers@.subrange(0, i as int)),
              total_sum <= u64::MAX,
              product_valid ==> total_product == product(numbers@.subrange(0, i as int)),
              product_valid ==> total_product <= u32::MAX,
      {
          total_sum = total_sum + numbers[i] as u64;
          
          if product_valid {
              if numbers[i] == 0 {
                  total_product = 0;
              } else {
                  let new_product = total_product * numbers[i] as u64;
                  if new_product <= u32::MAX as u64 {
                      total_product = new_product;
                  } else {
                      product_valid = false;
                  }
              }
          }
      }
      
      let result_product = if product_valid {
          Some(total_product as u32)
      } else {
          None
      };
      
      (total_sum, result_product)
  }

vc-postamble: |-
  
  }
  fn main() {}

