vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_divisible(n: int, divisor: int) -> (result: bool) {
      (n % divisor) == 0
  }
  // pure-end

vc-helpers: |-
  spec fn is_prime(n: int) -> bool {
      n >= 2 && (forall|k: int| 2 <= k < n ==> !is_divisible(n, k))
  }
  
  proof fn prime_divisor_bound(n: int)
      requires n >= 2
      ensures forall|k: int| 2 <= k < n ==> !is_divisible(n, k) <==> forall|k: int| 2 <= k <= n / 2 ==> !is_divisible(n, k)
  {
      assert(forall|k: int| k > n / 2 && k < n ==> !is_divisible(n, k)) by {
          assert forall|k: int| k > n / 2 && k < n implies !is_divisible(n, k) by {
              if is_divisible(n, k) {
                  let q = n / k;
                  assert(n % k == 0);
                  assert(q * k == n) by {
                      vstd::arithmetic::lemmas::fundamental_div_mod_lemma(n, k);
                  };
                  assert(q >= 1) by {
                      assert(n >= 2);
                      assert(k >= 1);
                      assert(q * k == n >= 2);
                  };
                  if q == 1 {
                      assert(k == n);
                      assert(false);
                  }
                  assert(q >= 2);
                  assert(k > n / 2);
                  assert(k * 2 > n);
                  assert(k * q >= k * 2) by {
                      vstd::arithmetic::lemmas::mul_mono_nonneg(k, 2, q);
                  };
                  assert(n >= k * 2) by {
                      assert(n == k * q);
                      assert(k * q >= k * 2);
                  };
                  assert(n > n);
                  assert(false);
              }
          };
      };
  }

vc-spec: |-
  fn prime_num(n: u64) -> (result: bool)
      // pre-conditions-start
      requires
          n >= 2,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),
      // post-conditions-end

vc-code: |-
  {
      let mut i: u64 = 2;
      while i <= n / 2
          invariant
              2 <= i <= n / 2 + 1,
              forall|k: int| 2 <= k < i ==> !is_divisible(n as int, k),
          decreases n / 2 + 1 - i,
      {
          if n % i == 0 {
              proof {
                  assert(is_divisible(n as int, i as int));
              }
              return false;
          }
          i = i + 1;
      }
      
      proof {
          prime_divisor_bound(n as int);
          assert(forall|k: int| 2 <= k <= n as int / 2 ==> !is_divisible(n as int, k));
          assert(forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k));
      }
      
      true
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

