vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> (result:nat)
      decreases string.len(),
  {
      if (string.len() == 0) {
          0
      } else if substring.is_prefix_of(string) {
          1 + how_many_times(string.skip(1), substring)
      } else {
          how_many_times(string.skip(1), substring)
      }
  }
  // pure-end
  // pure-end
  
  spec fn inner_expr_how_many_times_impl(opt_k: Option<u32>, string: Vec<char>, substring: Vec<char>) -> (result:bool) {
      match opt_k {
          Some(k) => k as nat == how_many_times(string@, substring@),
          None => how_many_times(string@, substring@) > u32::MAX,
      }
  }
  // pure-end

vc-helpers: |-
  fn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)
      // post-conditions-start
      ensures
          b == substring@.is_prefix_of(string@),
      // post-conditions-end
  {
      // impl-start
      let mut current_substring = substring.clone();
      let mut current_string = string.clone();
  
      if substring.len() > string.len() {
          return false
      }
      while (current_substring.len() > 0)
          // invariants-start
          invariant
              0 <= current_substring.len() <= current_string.len(),
              substring.len() <= string.len(),
              (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@
                  =~= current_string@.subrange(0, current_substring@.len() as int)),
          decreases current_substring.len(),
          // invariants-end
      {
          if (current_substring[0] != current_string[0]) {
              return false;
          }
          let old_substring = current_substring.clone();
          let old_string = current_string.clone();
  
          let substring_first = current_substring.remove(0);
          let string_first = current_string.remove(0);
          // assert-start
          assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (
          old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (
          old_substring@.skip(1) =~= old_string@.skip(1).subrange(
              0,
              old_substring@.skip(1).len() as int,
          )))) by { lemma_step_subrange(old_substring@, old_string@) };
          // assert-end
      }
      return true;
      // impl-end
  }
  
  // pure-end
  
  proof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)
      // pre-conditions-start
      requires
          substring.len() > 0,
          string.len() >= substring.len(),
      // pre-conditions-end
      // post-conditions-start
      ensures
          (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)
              =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring
              =~= string.subrange(0, substring.len() as int)),
      decreases substring.len(),
      // post-conditions-end
  {
      // impl-start
      if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)
          =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {
          assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]
              == string.subrange(0, substring.len() as int)[i] by {
              if i == 0 {
              } else {
                  assert(forall|j: int|
                      (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]
                          == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);
                  assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);
              }
          }
      } else {
      }
      // impl-end
  }
  // pure-end
  
  proof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)
      // pre-conditions-start
      requires
          string.len() < substring.len(),
      // pre-conditions-end
      // post-conditions-start
      ensures
          how_many_times(string, substring) == 0,
      decreases string.len(),
      // post-conditions-end
  {
      // impl-start
      if string.len() == 0 {
      } else {
          lemma_how_many_times_zero(string.skip(1), substring)
      }
      // impl-end
  }
  
  proof fn lemma_how_many_times_skip(string: Seq<char>, substring: Seq<char>)
      requires
          string.len() > 0,
          substring.len() >= 1,
      ensures
          how_many_times(string, substring) == (if substring.is_prefix_of(string) {
              1 + how_many_times(string.skip(1), substring)
          } else {
              how_many_times(string.skip(1), substring)
          }),
  {
  }
  
  proof fn lemma_how_many_times_split(string: Seq<char>, substring: Seq<char>, split_at: int)
      requires
          substring.len() >= 1,
          0 <= split_at <= string.len(),
          string.len() >= substring.len() ==> split_at >= string.len() - substring.len() + 1,
      ensures
          how_many_times(string, substring) == how_many_times(string.subrange(0, split_at), substring) + how_many_times(string.skip(split_at), substring),
      decreases string.len(),
  {
      if string.len() == 0 {
          return;
      }
      if split_at == 0 {
          return;
      }
      if string.len() < substring.len() {
          lemma_how_many_times_zero(string, substring);
          lemma_how_many_times_zero(string.subrange(0, split_at), substring);
          lemma_how_many_times_zero(string.skip(split_at), substring);
          return;
      }
      
      lemma_how_many_times_skip(string, substring);
      lemma_how_many_times_split(string.skip(1), substring, split_at - 1);
      
      if substring.is_prefix_of(string) {
          assert(how_many_times(string, substring) == 1 + how_many_times(string.skip(1), substring));
          assert(how_many_times(string.skip(1), substring) == how_many_times(string.skip(1).subrange(0, split_at - 1), substring) + how_many_times(string.skip(1).skip(split_at - 1), substring));
          assert(string.subrange(0, split_at) == string.subrange(0, 1).add(string.skip(1).subrange(0, split_at - 1)));
          assert(how_many_times(string.subrange(0, split_at), substring) == 1 + how_many_times(string.skip(1).subrange(0, split_at - 1), substring));
      } else {
          assert(how_many_times(string, substring) == how_many_times(string.skip(1), substring));
          assert(how_many_times(string.skip(1), substring) == how_many_times(string.skip(1).subrange(0, split_at - 1), substring) + how_many_times(string.skip(1).skip(split_at - 1), substring));
          assert(how_many_times(string.subrange(0, split_at), substring) == how_many_times(string.skip(1).subrange(0, split_at - 1), substring));
      }
  }
  // pure-end

vc-spec: |-
  fn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)
      // pre-conditions-start
      requires
          substring.len() >= 1,
      // pre-conditions-end
      // post-conditions-start
      ensures
          inner_expr_how_many_times_impl(opt_k, string, substring),
      // post-conditions-end

vc-code: |-
  {
      if string.len() < substring.len() {
          proof {
              lemma_how_many_times_zero(string@, substring@);
          }
          return Some(0);
      }
  
      let mut count: u32 = 0;
      let mut i: usize = 0;
      let string_len = string.len();
      let substring_len = substring.len();
  
      while i < string_len - substring_len + 1
          invariant
              substring_len >= 1,
              i <= string_len - substring_len + 1,
              string_len >= substring_len,
              count as nat == how_many_times(string@.subrange(0, i as int), substring@),
          decreases string_len - substring_len + 1 - i,
      {
          let mut string_copy = string.clone();
          let remaining_string = string_copy.split_off(i);
          
          if is_prefix(substring.clone(), remaining_string) {
              if count == u32::MAX {
                  return None;
              }
              count = count + 1;
          }
          
          i = i + 1;
  
          proof {
              if i > 0 {
                  assert(i - 1 < string_len);
                  assert(string@.subrange(0, i as int) == string@.subrange(0, (i-1) as int).push(string@[i-1]));
                  lemma_how_many_times_skip(string@.skip((i-1) as int), substring@);
              }
          }
      }
  
      proof {
          assert(i == string_len - substring_len + 1);
          let remaining = string@.skip((string_len - substring_len + 1) as int);
          lemma_how_many_times_zero(remaining, substring@);
          lemma_how_many_times_split(string@, substring@, (string_len - substring_len + 1) as int);
      }
  
      Some(count)
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

