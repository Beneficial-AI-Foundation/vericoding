vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn spec_sum_to_n(n: nat) -> (ret:nat)
      decreases n,
  {
      if (n == 0) {
          0
      } else {
          n + spec_sum_to_n((n - 1) as nat)
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_sum_to_n_bound(n: nat)
      ensures spec_sum_to_n(n) == n * (n + 1) / 2
      decreases n
  {
      if n == 0 {
          assert(spec_sum_to_n(0) == 0);
          assert(0 * (0 + 1) / 2 == 0);
      } else {
          lemma_sum_to_n_bound((n - 1) as nat);
          assert(spec_sum_to_n(n) == n + spec_sum_to_n((n - 1) as nat));
          assert(spec_sum_to_n((n - 1) as nat) == (n - 1) * n / 2);
          assert(spec_sum_to_n(n) == n + (n - 1) * n / 2);
          assert(n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2) by {
              assert(2 * n / 2 == n);
              assert(n + (n - 1) * n / 2 == 2 * n / 2 + (n - 1) * n / 2);
          };
          assert((2 * n + (n - 1) * n) / 2 == (2 * n + n * n - n) / 2) by {
              assert((n - 1) * n == n * n - n);
          };
          assert((2 * n + n * n - n) / 2 == (n + n * n) / 2) by {
              assert(2 * n - n == n);
          };
          assert((n + n * n) / 2 == n * (1 + n) / 2) by {
              assert(n + n * n == n * (1 + n));
          };
          assert(n * (1 + n) / 2 == n * (n + 1) / 2) by {
              assert(1 + n == n + 1);
          };
      }
  }
  
  proof fn lemma_sum_to_n_monotonic(n: nat)
      ensures n <= 65535 ==> spec_sum_to_n(n) <= spec_sum_to_n(65535)
      decreases n
  {
      if n <= 65535 {
          lemma_sum_to_n_bound(n);
          lemma_sum_to_n_bound(65535);
          assert(spec_sum_to_n(n) == n * (n + 1) / 2);
          assert(spec_sum_to_n(65535) == 65535 * (65535 + 1) / 2);
          assert(n <= 65535);
          assert(n * (n + 1) <= 65535 * (65535 + 1)) by {
              if n <= 65535 {
                  assert(n + 1 <= 65536);
                  assert(n * (n + 1) <= 65535 * 65536);
                  assert(65535 * 65536 <= 65535 * (65535 + 1));
              }
          };
          assert(n * (n + 1) / 2 <= 65535 * (65535 + 1) / 2);
          
          if n == 0 {
              assert(spec_sum_to_n(0) == 0);
          } else {
              lemma_sum_to_n_monotonic_helper(n, 65535);
          }
      }
  }
  
  proof fn lemma_sum_to_n_monotonic_helper(n: nat, m: nat)
      requires n <= m
      ensures spec_sum_to_n(n) <= spec_sum_to_n(m)
      decreases m - n
  {
      if n == m {
          assert(spec_sum_to_n(n) == spec_sum_to_n(m));
      } else if n < m {
          lemma_sum_to_n_monotonic_helper(n, (m - 1) as nat);
          assert(spec_sum_to_n(m) == m + spec_sum_to_n((m - 1) as nat));
          assert(spec_sum_to_n(n) <= spec_sum_to_n((m - 1) as nat));
          assert(spec_sum_to_n(n) <= spec_sum_to_n((m - 1) as nat) <= m + spec_sum_to_n((m - 1) as nat));
      }
  }

vc-spec: |-
  fn sum_to_n(n: u32) -> (sum: Option<u32>)
      // post-conditions-start
      ensures
          sum.is_some() ==> sum.unwrap() == spec_sum_to_n(n as nat),
      // post-conditions-end

vc-code: |-
  {
      if n > 65535 {
          return None;
      }
      
      proof {
          lemma_sum_to_n_bound(n as nat);
      }
      
      let mut sum: u32 = 0;
      let mut i: u32 = 0;
      
      while i < n
          invariant
              i <= n,
              sum == spec_sum_to_n(i as nat),
              sum <= u32::MAX,
          decreases n - i
      {
          if sum > u32::MAX - (i + 1) {
              return None;
          }
          i = i + 1;
          sum = sum + i;
      }
      
      Some(sum)
  }

vc-postamble: |-
  
  }
  fn main() {}

