vc-description: |-


vc-preamble: |-
  
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(s: Seq<int>) -> (result:int)
      decreases s.len(),
  {
      if s.len() == 0 {
          0
      } else {
          s[0] + sum(s.skip(1))
      }
  }
  // pure-end
  // pure-end
  
  spec fn sum_other_way(s: Seq<int>) -> (result:int)
      decreases s.len(),
  {
      if s.len() == 0 {
          0
      } else {
          s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_sum_equals_sum_other_way(s: Seq<int>)
      ensures
          sum(s) == sum_other_way(s),
      decreases s.len(),
  {
      if s.len() == 1 {
          assert(sum(s.skip(1)) == 0);
          assert(sum_other_way(s.take(s.len() - 1)) == 0);
      } else if s.len() > 1 {
          let ss = s.skip(1);
          lemma_sum_equals_sum_other_way(ss);
          assert(sum_other_way(ss) == ss[ss.len() - 1] + sum_other_way(ss.take(ss.len() - 1)));
          lemma_sum_equals_sum_other_way(ss.take(ss.len() - 1));
          assert(ss.take(ss.len() - 1) == s.take(s.len() - 1).skip(1));
          lemma_sum_equals_sum_other_way(s.take(s.len() - 1));
      }
  }
  
  proof fn lemma_sum_monotonic(s: Seq<int>, i: int, j: int)
      requires
          0 <= i <= j <= s.len(),
      ensures
          sum(s.take(j)) == sum(s.take(i)) + sum(s.skip(i).take(j - i)),
      decreases j - i,
  {
      if i == j {
          assert(s.skip(i).take(0) == Seq::<int>::empty());
          assert(sum(s.skip(i).take(0)) == 0);
      } else {
          lemma_sum_monotonic(s, i + 1, j);
          lemma_sum_append(s.take(i), s[i]);
          lemma_sum_split(s.skip(i).take(j - i), 1);
      }
  }
  
  proof fn lemma_sum_append(s: Seq<int>, x: int)
      ensures
          sum(s.push(x)) == sum(s) + x,
      decreases s.len(),
  {
      if s.len() == 0 {
      } else {
          lemma_sum_append(s.skip(1), x);
      }
  }
  
  proof fn lemma_sum_split(s: Seq<int>, k: int)
      requires
          0 <= k <= s.len(),
      ensures
          sum(s) == sum(s.take(k)) + sum(s.skip(k)),
      decreases k,
  {
      if k == 0 {
          assert(s.take(0) == Seq::<int>::empty());
      } else if k < s.len() {
          lemma_sum_split(s.skip(1), k - 1);
          assert(s.take(k) == seq![s[0]].add(s.skip(1).take(k - 1)));
          lemma_sum_append(s.skip(1).take(k - 1), s[0]);
      }
  }
  
  proof fn lemma_map_take(s: Seq<i32>, i: int)
      requires
          0 <= i <= s.len(),
      ensures
          s.take(i).map(|_idx, j: i32| j as int) == s.map(|_idx, j: i32| j as int).take(i),
  {
  }

vc-spec: |-
  fn below_zero(operations: Vec<i32>) -> (result: bool)
      // pre-conditions-start
      requires
          forall|i: int|
              0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))
                  <= i32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result <==> exists|i: int|
              0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))
                  < 0,
      // post-conditions-end

vc-code: |-
  {
      let mut balance: i32 = 0;
      let mut i: usize = 0;
      
      while i < operations.len()
          invariant
              0 <= i <= operations@.len(),
              balance == sum(operations@.take(i as int).map(|_idx, j: i32| j as int)),
              forall|k: int| 0 <= k < i ==> sum(operations@.take(k).map(|_idx, j: i32| j as int)) >= 0,
          decreases operations@.len() - i
      {
          if balance < 0 {
              return true;
          }
          
          let old_i = i;
          i = i + 1;
          balance = balance + operations[old_i] as i32;
          
          proof {
              let current_seq = operations@.take(i as int).map(|_idx, j: i32| j as int);
              let prev_seq = operations@.take(old_i as int).map(|_idx, j: i32| j as int);
              lemma_map_take(operations@, i as int);
              lemma_map_take(operations@, old_i as int);
              assert(current_seq == prev_seq.push((operations@[old_i as int]) as int));
              lemma_sum_append(prev_seq, (operations@[old_i as int]) as int);
          }
      }
      
      balance < 0
  }

vc-postamble: |-
  
  }
  fn main() {}

