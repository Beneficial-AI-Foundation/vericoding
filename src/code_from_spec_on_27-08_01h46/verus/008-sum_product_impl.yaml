vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn sum(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(0, |acc: int, x| acc + x)
  }
  // pure-end
  // pure-end
  
  spec fn product(numbers: Seq<u32>) -> (result:int) {
      numbers.fold_left(1, |acc: int, x| acc * x)
  }
  // pure-end

vc-helpers: |-
  proof fn sum_bound(numbers: Seq<u32>)
      ensures
          sum(numbers) <= numbers.len() * u32::MAX,
      decreases numbers.len(),
  {
      if numbers.len() == 0 {
      } else {
          sum_bound(numbers.drop_last());
      }
  }
  
  proof fn sum_fits_u64(numbers: Seq<u32>)
      requires numbers.len() < u32::MAX
      ensures sum(numbers) <= u64::MAX
  {
      sum_bound(numbers);
      assert(numbers.len() * u32::MAX < u32::MAX * u32::MAX);
      assert(u32::MAX * u32::MAX <= u64::MAX);
  }
  
  spec fn product_overflows_u32(numbers: Seq<u32>) -> bool {
      product(numbers) > u32::MAX
  }
  
  proof fn sum_subrange_property(numbers: Seq<u32>, i: int, num: u32)
      requires 0 <= i < numbers.len(),
      requires numbers[i] == num,
      ensures sum(numbers.subrange(0, i + 1)) == sum(numbers.subrange(0, i)) + num,
  {
      let left = numbers.subrange(0, i);
      let extended = numbers.subrange(0, i + 1);
      assert(extended == left.push(num));
  }

vc-spec: |-
  fn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))
      // pre-conditions-start
      requires
          numbers.len() < u32::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          result.0 == sum(numbers@),
          result.1 matches Some(v) ==> v == product(numbers@),
      // post-conditions-end

vc-code: |-
  {
      proof {
          sum_fits_u64(numbers@);
      }
      
      let mut total_sum: u64 = 0;
      let mut total_product: u64 = 1;
      let mut overflow = false;
      
      let mut i = 0;
      while i < numbers.len()
          invariant
              0 <= i <= numbers.len(),
              total_sum == sum(numbers@.subrange(0, i as int)),
              !overflow ==> total_product == product(numbers@.subrange(0, i as int)),
              !overflow ==> total_product <= u32::MAX,
              total_sum <= u64::MAX,
          decreases numbers.len() - i,
      {
          let num = numbers[i];
          
          proof {
              sum_subrange_property(numbers@, i as int, num);
              assert(total_sum + (num as u64) <= u64::MAX);
          }
          
          total_sum = total_sum + num as u64;
          
          if !overflow {
              if total_product > (u32::MAX as u64) / (num as u64).max(1) {
                  overflow = true;
              } else {
                  total_product = total_product * num as u64;
                  if total_product > u32::MAX as u64 {
                      overflow = true;
                  }
              }
          }
          
          i = i + 1;
      }
      
      let final_product = if overflow {
          None
      } else {
          Some(total_product as u32)
      };
      
      proof {
          assert(numbers@.subrange(0, numbers.len() as int) =~= numbers@);
      }
      
      (total_sum, final_product)
  }

vc-postamble: |-
  
  }
  fn main() {}

