vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> (result:int)
      decreases seq.len(),
  {
      if seq.len() == 0 {
          0
      } else {
          count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {
              1 as int
          } else {
              0 as int
          }
      }
  }
  // pure-end

vc-helpers: |-
  fn count_frequency(elements: &Vec<i64>, key: i64) -> (frequency: usize)
      // post-conditions-start
      ensures
          count_frequency_spec(elements@, key) == frequency,
      // post-conditions-end
  {
      // impl-start
      let ghost elements_length = elements.len();
      let mut counter = 0;
      let mut index = 0;
      while index < elements.len()
          // invariants-start
          invariant
              0 <= index <= elements.len(),
              0 <= counter <= index,
              count_frequency_spec(elements@.subrange(0, index as int), key) == counter,
          // invariants-end
          decreases elements.len() - index,
      {
          if (elements[index] == key) {
              counter += 1;
          }
          index += 1;
          // assert-start
          assert(elements@.subrange(0, index - 1 as int) == elements@.subrange(
              0,
              index as int,
          ).drop_last());
          // assert-end
      }
      // assert-start
      assert(elements@ == elements@.subrange(0, elements_length as int));
      // assert-end
      counter
      // impl-end
  }
  
  proof fn filter_preserves_order<T>(s: Seq<T>, pred: spec_fn(T) -> bool)
      ensures
          forall|i: int, j: int| 
              0 <= i < j < s.filter(pred).len() ==> 
              exists|ii: int, jj: int| 0 <= ii < jj < s.len() && 
              s[ii] == s.filter(pred)[i] && 
              s[jj] == s.filter(pred)[j],
  {
  }
  
  proof fn count_frequency_subrange_relationship(elements: Seq<i64>, i: int, key: i64)
      requires
          0 <= i < elements.len(),
      ensures
          count_frequency_spec(elements.subrange(0, i + 1), key) == 
          count_frequency_spec(elements.subrange(0, i), key) + 
          if elements[i] == key { 1int } else { 0int },
  {
      let sub_i = elements.subrange(0, i);
      let sub_i_plus_1 = elements.subrange(0, i + 1);
      
      assert(sub_i_plus_1 == sub_i.push(elements[i]));
      assert(sub_i_plus_1.last() == elements[i]);
      assert(sub_i_plus_1.drop_last() == sub_i);
  }

vc-spec: |-
  fn remove_duplicates(numbers: &Vec<i64>) -> (unique_numbers: Vec<i64>)
      // post-conditions-start
      ensures
          unique_numbers@ == numbers@.filter(|x: i64| count_frequency_spec(numbers@, x) == 1),
      // post-conditions-end

vc-code: |-
  {
      // impl-start
      let mut unique_numbers: Vec<i64> = Vec::new();
      let mut index = 0;
      
      while index < numbers.len()
          invariant
              0 <= index <= numbers.len(),
              unique_numbers@ == numbers@.subrange(0, index as int).filter(|x: i64| count_frequency_spec(numbers@, x) == 1),
          decreases numbers.len() - index,
      {
          let current = numbers[index];
          let freq = count_frequency(numbers, current);
          
          if freq == 1 {
              unique_numbers.push(current);
          }
          
          index += 1;
          
          proof {
              let old_subrange = numbers@.subrange(0, index - 1 as int);
              let new_subrange = numbers@.subrange(0, index as int);
              
              count_frequency_subrange_relationship(numbers@, index - 1 as int, current);
              
              assert(new_subrange == old_subrange.push(current));
              
              assert(new_subrange.filter(|x: i64| count_frequency_spec(numbers@, x) == 1) ==
                     old_subrange.filter(|x: i64| count_frequency_spec(numbers@, x) == 1) +
                     if count_frequency_spec(numbers@, current) == 1 { 
                         seq![current] 
                     } else { 
                         seq![] 
                     });
          }
      }
      
      proof {
          assert(numbers@ == numbers@.subrange(0, numbers.len() as int));
      }
      
      unique_numbers
      // impl-end
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

