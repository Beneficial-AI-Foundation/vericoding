vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn is_divisible(n: int, divisor: int) -> (ret:bool) {
      (n % divisor) == 0
  }
  // pure-end
  // pure-end
  
  spec fn is_prime(n: int) -> (ret:bool) {
      if n < 2 {
          false
      } else {
          (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k))
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_small_primes()
      ensures
          is_prime(2),
          is_prime(3),
          !is_prime(4),
          !is_prime(6),
          !is_prime(8),
          !is_prime(9),
          !is_prime(10),
  {
      assert(is_divisible(4, 2));
      assert(is_divisible(6, 2));
      assert(is_divisible(8, 2));
      assert(is_divisible(9, 3));
      assert(is_divisible(10, 2));
  }
  
  proof fn lemma_not_prime_even(n: int)
      requires n >= 4 && n % 2 == 0
      ensures !is_prime(n)
  {
      assert(is_divisible(n, 2));
  }
  
  proof fn lemma_not_prime_divisible(n: int, k: int)
      requires 2 <= k < n && is_divisible(n, k)
      ensures !is_prime(n)
  {
  }
  
  proof fn lemma_sqrt_bound(n: int, k: int)
      requires n >= 2 && k >= 2 && k * k > n && k < n
      ensures !is_divisible(n, k)
  {
      if is_divisible(n, k) {
          assert(n >= k * 1);
          assert(k >= 2);
          assert(n >= k * k);
          assert(false);
      }
  }
  
  fn is_prime_check(n: usize) -> (result: bool)
      requires n <= 0x1000000
      ensures result == is_prime(n as int)
  {
      if n < 2 {
          proof { lemma_small_primes(); }
          false
      } else if n == 2 {
          proof { lemma_small_primes(); }
          true
      } else if n % 2 == 0 {
          proof { lemma_not_prime_even(n as int); }
          false
      } else {
          let mut i: usize = 3;
          while i <= 0x1000 && i * i <= n
              invariant
                  3 <= i,
                  i % 2 == 1,
                  i <= 0x1000,
                  forall|k: int| 2 <= k < i ==> !is_divisible(n as int, k),
              decreases n + 1 - i
          {
              if n % i == 0 {
                  proof { 
                      assert(2 <= i as int);
                      assert(i as int < n as int);
                      assert(is_divisible(n as int, i as int));
                      lemma_not_prime_divisible(n as int, i as int); 
                  }
                  return false;
              }
              i += 2;
          }
          
          proof {
              assert(forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)) by {
                  assert(forall|k: int| 2 <= k < i ==> !is_divisible(n as int, k));
                  assert(forall|k: int| i <= k < n ==> !is_divisible(n as int, k)) by {
                      assert(i * i > n || i > 0x1000);
                      if i * i > n {
                          assert(forall|k: int| i <= k < n ==> {
                              lemma_sqrt_bound(n as int, k);
                              !is_divisible(n as int, k)
                          });
                      }
                  }
              }
          }
          true
      }
  }

vc-spec: |-
  fn prime_length(str: &[char]) -> (result: bool)
      // post-conditions-start
      ensures
          result == is_prime(str.len() as int),
      // post-conditions-end

vc-code: |-
  {
      if str.len() <= 0x1000000 {
          is_prime_check(str.len())
      } else {
          false
      }
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

