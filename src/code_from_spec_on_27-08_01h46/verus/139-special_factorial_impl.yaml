vc-description: |-


vc-preamble: |-
  
  use vstd::arithmetic::mul::*;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          1
      } else {
          n * factorial((n - 1) as nat)
      }
  }
  // pure-end
  // pure-end
  
  spec fn brazilian_factorial(n: nat) -> (ret:nat)
      decreases n,
  {
      if n <= 1 {
          factorial(1)
      } else {
          factorial(n) * brazilian_factorial((n - 1) as nat)
      }
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_factorial_positive(n: nat)
      ensures
          factorial(n) >= 1,
      decreases n,
  {
      if (n == 0) {
      } else {
          lemma_factorial_positive((n - 1) as nat);
          assert(factorial(n) >= 1) by {
              broadcast use lemma_mul_strictly_positive;
          };
      }
  }
  
  proof fn lemma_factorial_monotonic(i: nat, j: nat)
      requires
          i <= j,
      ensures
          factorial(i) <= factorial(j),
      decreases j - i,
  {
      if i == j {
      } else {
          lemma_factorial_monotonic(i, (j - 1) as nat);
          lemma_factorial_positive(j - 1);
          assert(factorial(j) >= factorial((j - 1) as nat)) by {
              broadcast use lemma_mul_increases;
          };
      }
  }
  
  proof fn lemma_brazilian_factorial_positive(n: nat)
      ensures
          brazilian_factorial(n) >= 1,
      decreases n,
  {
      if (n == 0) {
      } else {
          lemma_factorial_positive((n) as nat);
          lemma_brazilian_factorial_positive((n - 1) as nat);
          assert(brazilian_factorial(n) >= 1) by {
              lemma_mul_strictly_positive(
                  factorial(n) as int,
                  brazilian_factorial((n - 1) as nat) as int,
              )
          };
      }
  }
  
  proof fn lemma_brazilian_factorial_ge_factorial(n: nat)
      ensures
          brazilian_factorial(n) >= factorial(n),
      decreases n,
  {
      if n <= 1 {
          assert(brazilian_factorial(n) == factorial(1));
          assert(factorial(1) == 1);
          lemma_factorial_positive(n);
      } else {
          lemma_brazilian_factorial_positive((n - 1) as nat);
          lemma_factorial_positive(n);
          assert(brazilian_factorial(n) == factorial(n) * brazilian_factorial((n - 1) as nat));
          assert(brazilian_factorial((n - 1) as nat) >= 1);
          assert(brazilian_factorial(n) >= factorial(n)) by {
              broadcast use lemma_mul_increases;
          };
      }
  }
  
  proof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)
      requires
          0 <= i <= j,
      ensures
          brazilian_factorial(i) <= brazilian_factorial(j),
      decreases j - i,
  {
      if (i == j) {
      } else if (j == i + 1) {
          assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };
          assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {
              broadcast use lemma_mul_increases;
          };
      } else {
          lemma_brazilian_fib_monotonic(i, (j - 1) as nat);
          lemma_brazilian_fib_monotonic((j - 1) as nat, j);
      }
  }
  
  proof fn lemma_factorial_overflow_monotonic(i: nat, j: nat)
      requires
          i <= j,
          factorial(i) > u64::MAX,
      ensures
          factorial(j) > u64::MAX,
      decreases j - i,
  {
      if i == j {
      } else {
          lemma_factorial_positive(i);
          lemma_factorial_overflow_monotonic(i, (j - 1) as nat);
          lemma_factorial_monotonic((j - 1) as nat, j);
          assert(factorial(j) >= factorial((j - 1) as nat));
          assert(factorial((j - 1) as nat) > u64::MAX);
      }
  }
  
  proof fn lemma_brazilian_factorial_overflow_monotonic(i: nat, j: nat)
      requires
          i <= j,
          brazilian_factorial(i) > u64::MAX,
      ensures
          brazilian_factorial(j) > u64::MAX,
      decreases j - i,
  {
      if i == j {
      } else {
          lemma_brazilian_factorial_positive(i);
          lemma_brazilian_factorial_overflow_monotonic(i, (j - 1) as nat);
          lemma_brazilian_fib_monotonic((j - 1) as nat, j);
      }
  }
  
  fn factorial_impl(n: u64) -> (ret: Option<u64>)
      ensures
          match ret {
              None => factorial(n as nat) > u64::MAX,
              Some(f) => f == factorial(n as nat),
          },
  {
      if n <= 1 {
          Some(1)
      } else {
          let mut result: u64 = 1;
          let mut i: u64 = 2;
          while i <= n
              invariant
                  2 <= i <= n + 1,
                  result == factorial((i - 1) as nat),
                  result <= u64::MAX,
              decreases n + 1 - i,
          {
              if i == 0 || result > u64::MAX / i {
                  proof {
                      assert(factorial(i as nat) > u64::MAX);
                      lemma_factorial_overflow_monotonic(i as nat, n as nat);
                  }
                  return None;
              }
              result = result * i;
              i = i + 1;
          }
          Some(result)
      }
  }

vc-spec: |-
  fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)
      // post-conditions-start
      ensures
          match ret {
              None => brazilian_factorial(n as nat) > u64::MAX,
              Some(bf) => bf == brazilian_factorial(n as nat),
          },
      // post-conditions-end

vc-code: |-
  {
      if n <= 1 {
          return Some(1);
      }
      
      let mut bf: u64 = 1;
      let mut i: u64 = 1;
      
      while i <= n
          invariant
              1 <= i <= n + 1,
              bf == brazilian_factorial((i - 1) as nat),
              bf <= u64::MAX,
          decreases n + 1 - i,
      {
          let fact_opt = factorial_impl(i);
          match fact_opt {
              None => {
                  proof {
                      assert(factorial(i as nat) > u64::MAX);
                      lemma_brazilian_factorial_ge_factorial(i as nat);
                      assert(brazilian_factorial(i as nat) >= factorial(i as nat));
                      assert(brazilian_factorial(i as nat) > u64::MAX);
                      lemma_brazilian_factorial_overflow_monotonic(i as nat, n as nat);
                  }
                  return None;
              }
              Some(fact_i) => {
                  if fact_i == 0 || bf > u64::MAX / fact_i {
                      proof {
                          assert(bf == brazilian_factorial((i - 1) as nat));
                          assert(fact_i == factorial(i as nat));
                          assert(brazilian_factorial(i as nat) == factorial(i as nat) * brazilian_factorial((i - 1) as nat));
                          assert(bf * fact_i == brazilian_factorial(i as nat));
                          assert(bf * fact_i > u64::MAX);
                          assert(brazilian_factorial(i as nat) > u64::MAX);
                          lemma_brazilian_factorial_overflow_monotonic(i as nat, n as nat);
                      }
                      return None;
                  }
                  proof {
                      assert(bf == brazilian_factorial((i - 1) as nat));
                      assert(fact_i == factorial(i as nat));
                      assert(brazilian_factorial(i as nat) == factorial(i as nat) * brazilian_factorial((i - 1) as nat));
                      assert(bf * fact_i == brazilian_factorial(i as nat));
                  }
                  bf = bf * fact_i;
              }
          }
          i = i + 1;
      }
      
      Some(bf)
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

