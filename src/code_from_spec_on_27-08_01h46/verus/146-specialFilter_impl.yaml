vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn extract_first_digit_spec(n: int) -> (ret:int)
      decreases n,
  {
      if n < 10 {
          n
      } else {
          extract_first_digit_spec(n / 10)
      }
  }
  // pure-end
  spec fn extract_last_digit_spec(n: int) -> (ret:int) {
      n % 10
  }
  // pure-end
  spec fn is_odd(n: int) -> (ret:bool) {
      (n % 2) != 0
  }
  // pure-end
  // pure-end
  
  
  spec fn is_valid_element_spec(n: int) -> (ret:bool) {
      &&& (n > 10)
      &&& is_odd(extract_first_digit_spec(n))
      &&& is_odd(extract_last_digit_spec(n))
  }
  // pure-end
  spec fn special_filter_spec(seq: Seq<i32>) -> (ret:int)
      decreases seq.len(),
  {
      if seq.len() == 0 {
          0
      } else {
          special_filter_spec(seq.drop_last()) + if (is_valid_element_spec(seq.last() as int)) {
              1 as int
          } else {
              0 as int
          }
      }
  }
  // pure-end

vc-helpers: |-
  fn extract_first_digit(n: u32) -> (res: u32)
      decreases n
      ensures
          res == extract_first_digit_spec(n as int)
  {
      if n < 10 {
          n
      } else {
          extract_first_digit(n / 10)
      }
  }
  
  fn extract_last_digit(n: u32) -> (res: u32)
      ensures
          res == extract_last_digit_spec(n as int)
  {
      n % 10
  }
  
  fn is_valid_element(n: i32) -> (res: bool)
      ensures
          res == is_valid_element_spec(n as int)
  {
      ((n > 10) && (extract_first_digit(n as u32) % 2 != 0) && (extract_last_digit(n as u32) % 2
          != 0))
  }
  
  proof fn special_filter_lemma(s: Seq<i32>, i: int)
      requires 0 <= i <= s.len()
      ensures special_filter_spec(s.take(i as int)) == special_filter_spec(s.take((i-1) as int)) + 
          if i > 0 && is_valid_element_spec(s[(i-1) as int] as int) { 1int } else { 0int }
  {
      if i == 0 {
          assert(s.take(0) =~= Seq::<i32>::empty());
      } else {
          let prefix = s.take((i-1) as int);
          let full_prefix = s.take(i as int);
          assert(full_prefix =~= prefix.push(s[(i-1) as int]));
          assert(full_prefix.drop_last() =~= prefix);
          assert(full_prefix.last() == s[(i-1) as int]);
      }
  }

vc-spec: |-
  fn special_filter(numbers: &Vec<i32>) -> (count: usize)
      // post-conditions-start
      ensures
          count == special_filter_spec(numbers@),
      // post-conditions-end

vc-code: |-
  {
      let mut count = 0;
      let mut i = 0;
      
      while i < numbers.len()
          invariant
              0 <= i <= numbers.len(),
              count == special_filter_spec(numbers@.take(i as int))
      {
          proof {
              special_filter_lemma(numbers@, (i + 1) as int);
          }
          
          if is_valid_element(numbers[i]) {
              count = count + 1;
          }
          i = i + 1;
      }
      
      proof {
          assert(numbers@.take(numbers.len() as int) =~= numbers@);
      }
      
      count
  }

vc-postamble: |-
  
  } // verus!
  fn main() {}

