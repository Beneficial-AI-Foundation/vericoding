vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn rotation_split(len: usize, n: usize) -> (result: int) {
      len - (n % len)
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_rotation_split_bounds(len: usize, n: usize)
      requires len > 0
      ensures 
          0 <= rotation_split(len, n) <= len,
          rotation_split(len, n) == len - (n % len)
  {
  }
  
  proof fn lemma_subrange_properties(s: Seq<u32>, len: usize, split_pos: int)
      requires 
          len > 0,
          0 <= split_pos <= len,
          s.len() == len
      ensures
          s.subrange(split_pos, len as int).add(s.subrange(0, split_pos)).len() == len
  {
  }
  
  proof fn lemma_rotation_split_in_bounds(len: usize, n: usize)
      requires len > 0
      ensures rotation_split(len, n) <= len
  {
      lemma_rotation_split_bounds(len, n);
  }
  
  proof fn lemma_int_bounds_for_usize(x: int, bound: usize)
      requires 0 <= x <= bound, bound < 0x1_0000_0000_0000_0000
      ensures x < 0x1_0000_0000_0000_0000
  {
  }

vc-spec: |-
  fn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)
      // pre-conditions-start
      requires
          list.len() > 0,
      // pre-conditions-end
      // post-conditions-start
      ensures
          new_list.len() == list.len(),
          new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(
              list@.subrange(0, rotation_split(list.len(), n) as int),
          ),
      // post-conditions-end

vc-code: |-
  {
      let len = list.len();
      
      proof {
          lemma_rotation_split_bounds(len, n);
          lemma_rotation_split_in_bounds(len, n);
      }
      
      let split_pos_int = rotation_split(len, n);
      
      proof {
          lemma_int_bounds_for_usize(split_pos_int, len);
      }
      
      let split_pos = split_pos_int.try_into().unwrap();
      
      proof {
          lemma_subrange_properties(list@, len, rotation_split(len, n));
      }
      
      let mut result = Vec::with_capacity(len);
      
      let mut i = split_pos;
      while i < len
          invariant
              split_pos <= len,
              split_pos <= i <= len,
              result.len() == (i - split_pos),
              forall|k: int| 0 <= k < (i - split_pos) ==> result@[k] == list@[split_pos + k]
      {
          result.push(list[i]);
          i = i + 1;
      }
      
      let mut j = 0;
      while j < split_pos
          invariant
              0 <= j <= split_pos,
              result.len() == (len - split_pos) + j,
              forall|k: int| 0 <= k < (len - split_pos) ==> result@[k] == list@[split_pos + k],
              forall|k: int| 0 <= k < j ==> result@[(len - split_pos) + k] == list@[k]
      {
          result.push(list[j]);
          j = j + 1;
      }
      
      proof {
          assert(result.len() == len);
          assert(result@ == list@.subrange(split_pos as int, len as int).add(list@.subrange(0, split_pos as int)));
      }
      
      result
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

