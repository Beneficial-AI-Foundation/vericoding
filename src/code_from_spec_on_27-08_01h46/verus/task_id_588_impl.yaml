vc-description: |-


vc-preamble: |-
  #![verifier::loop_isolation(false)]
  use vstd::math::*;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn max_rcur(seq: Seq<i32>) -> (result: int)
      decreases seq.len(),
  {
      if seq.len() <= 1 {
          seq.first() as int
      } else {
          max(seq.last() as int, max_rcur(seq.drop_last()))
      }
  }
  // pure-end
  // pure-end
  
  spec fn min_rcur(seq: Seq<i32>) -> (result: int)
      decreases seq.len(),
  {
      if seq.len() <= 1 {
          seq.first() as int
      } else {
          min(seq.last() as int, min_rcur(seq.drop_last()))
      }
  }
  // pure-end

vc-helpers: |-
  spec fn max_iter_spec(seq: Seq<i32>, start: nat, current_max: int) -> int
      decreases seq.len() - start
  {
      if start >= seq.len() {
          current_max
      } else {
          max_iter_spec(seq, start + 1, max(current_max, seq[start as int] as int))
      }
  }
  
  spec fn min_iter_spec(seq: Seq<i32>, start: nat, current_min: int) -> int
      decreases seq.len() - start
  {
      if start >= seq.len() {
          current_min
      } else {
          min_iter_spec(seq, start + 1, min(current_min, seq[start as int] as int))
      }
  }
  
  proof fn max_iter_equiv_rcur(seq: Seq<i32>, start: nat, current_max: int)
      requires 
          seq.len() > 0,
          start <= seq.len(),
          start == 0 ==> current_max == seq[0] as int,
          start > 0 ==> current_max == max_iter_spec(seq, 0, seq[0] as int),
      ensures 
          max_iter_spec(seq, start, current_max) == max_rcur(seq),
      decreases seq.len() - start
  {
      if start >= seq.len() {
          assert(max_iter_spec(seq, start, current_max) == current_max);
          if start == 0 {
              assert(seq.len() == 0);
          } else {
              assert(current_max == max_rcur(seq));
          }
      } else if start == 0 {
          let next_max = max(current_max, seq[0] as int);
          if seq.len() == 1 {
              assert(max_iter_spec(seq, 1, next_max) == next_max);
              assert(max_rcur(seq) == seq[0] as int);
              assert(next_max == max(seq[0] as int, seq[0] as int));
              assert(next_max == seq[0] as int);
          } else {
              max_iter_equiv_rcur(seq, start + 1, next_max);
          }
      } else {
          let next_max = max(current_max, seq[start as int] as int);
          max_iter_equiv_rcur(seq, start + 1, next_max);
      }
  }
  
  proof fn min_iter_equiv_rcur(seq: Seq<i32>, start: nat, current_min: int)
      requires 
          seq.len() > 0,
          start <= seq.len(),
          start == 0 ==> current_min == seq[0] as int,
          start > 0 ==> current_min == min_iter_spec(seq, 0, seq[0] as int),
      ensures 
          min_iter_spec(seq, start, current_min) == min_rcur(seq),
      decreases seq.len() - start
  {
      if start >= seq.len() {
          assert(min_iter_spec(seq, start, current_min) == current_min);
          if start == 0 {
              assert(seq.len() == 0);
          } else {
              assert(current_min == min_rcur(seq));
          }
      } else if start == 0 {
          let next_min = min(current_min, seq[0] as int);
          if seq.len() == 1 {
              assert(min_iter_spec(seq, 1, next_min) == next_min);
              assert(min_rcur(seq) == seq[0] as int);
              assert(next_min == min(seq[0] as int, seq[0] as int));
              assert(next_min == seq[0] as int);
          } else {
              min_iter_equiv_rcur(seq, start + 1, next_min);
          }
      } else {
          let next_min = min(current_min, seq[start as int] as int);
          min_iter_equiv_rcur(seq, start + 1, next_min);
      }
  }

vc-spec: |-
  fn difference_max_min(arr: &Vec<i32>) -> (diff: i32)
      // pre-conditions-start
      requires
          arr.len() > 0,
          forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,
      // pre-conditions-end
      // post-conditions-start
      ensures
          diff == max_rcur(arr@) - min_rcur(arr@),
      // post-conditions-end

vc-code: |-
  {
      let mut max_val = arr[0];
      let mut min_val = arr[0];
      let mut i = 1;
      
      while i < arr.len()
          invariant
              1 <= i <= arr.len(),
              max_val == max_iter_spec(arr@, i as nat, arr[0] as int) as i32,
              min_val == min_iter_spec(arr@, i as nat, arr[0] as int) as i32,
              i32::MIN / 2 < max_val < i32::MAX / 2,
              i32::MIN / 2 < min_val < i32::MAX / 2,
          decreases arr.len() - i,
      {
          if arr[i] > max_val {
              max_val = arr[i];
          }
          if arr[i] < min_val {
              min_val = arr[i];
          }
          i += 1;
      }
      
      proof {
          max_iter_equiv_rcur(arr@, 0, arr[0] as int);
          min_iter_equiv_rcur(arr@, 0, arr[0] as int);
      }
      
      max_val - min_val
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

