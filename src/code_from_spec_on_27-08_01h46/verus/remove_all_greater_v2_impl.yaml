vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
      requires
          l == vec.len(),
      ensures
          forall |k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
          vec.push(i).index(l as int) == i,
  {
      assert(vec.push(i).len() == vec.len() + 1);
      assert forall |k: int| 0 <= k < vec.len() implies vec[k] == vec.push(i)[k] by {
          assert(vec.push(i)[k] == vec[k]);
      }
      assert(vec.push(i)[l as int] == i);
  }
  
  proof fn lemma_contains_preserved<T>(v1: Seq<T>, v2: Seq<T>, x: T)
      requires
          v1.contains(x),
          forall |k: int| 0 <= k < v1.len() ==> v2.contains(v1[k]),
      ensures
          v2.contains(x),
  {
  }
  
  proof fn lemma_push_preserves_contains<T>(result_old: Seq<T>, result_new: Seq<T>, x: T)
      requires
          result_new == result_old.push(x),
          result_old.contains(x),
      ensures
          result_new.contains(x),
  {
  }

vc-spec: |-
  fn remove_all_greater(v: Vec<i32>, e: i32) -> (result: Vec<i32>)
      // pre-conditions-start
      requires 
          forall |k1:int,k2:int| 0 <= k1 < k2 < v.len() ==> v[k1] != v[k2],
      // pre-conditions-end
      // post-conditions-start
      ensures
          forall |k:int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
          forall |k:int| 0 <= k < v.len() && v[k] <= e ==> result@.contains(v[k]),
      // post-conditions-end

vc-code: |-
  {
      let mut result: Vec<i32> = Vec::new();
      let mut i = 0;
      
      while i < v.len()
          invariant
              0 <= i <= v.len(),
              forall |k: int| 0 <= k < result.len() ==> result[k] <= e && v@.contains(result[k]),
              forall |k: int| 0 <= k < i && v[k] <= e ==> result@.contains(v[k]),
          decreases v.len() - i,
      {
          if v[i] <= e {
              proof {
                  assert(v[i] <= e);
                  assert(v@.contains(v[i]));
              }
              result.push(v[i]);
              proof {
                  assert(result@.contains(v[i]));
                  assert forall |k: int| 0 <= k < i && v[k] <= e implies result@.contains(v[k]) by {
                      if 0 <= k < i && v[k] <= e {
                          assert(result@.drop_last().contains(v[k]));
                          assert(result@.contains(v[k]));
                      }
                  }
              }
          }
          i += 1;
      }
      
      result
  }

vc-postamble: |-
  
  }
  
  fn main() {}

