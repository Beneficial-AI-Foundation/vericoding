vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn rotation_split(len: usize, n: usize) -> (result: int) {
      len - (n % len)
  }
  // pure-end

vc-helpers: |-
  spec fn rotation_split_helper(len: usize, n: usize) -> usize {
      (len - (n % len)) as usize
  }

vc-spec: |-
  fn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)
      // pre-conditions-start
      requires
          list.len() > 0,
      // pre-conditions-end
      // post-conditions-start
      ensures
          new_list.len() == list.len(),
          new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(
              list@.subrange(0, rotation_split(list.len(), n) as int),
          ),
      // post-conditions-end

vc-code: |-
  {
      let len = list.len();
      let split = rotation_split_helper(len, n);
      let mut result = Vec::with_capacity(len);
      
      // Copy the elements from split to end
      let mut i = split;
      while i < len
          invariant
              0 <= split <= len,
              result.len() == i - split,
              forall |k: usize| split <= k < i ==> result@[(k - split) as int] == list@[k as int],
      {
          result.push(list[i]);
          i = i + 1;
      }
      
      // Copy the elements from 0 to split
      let mut i = 0;
      while i < split
          invariant
              0 <= split <= len,
              result.len() == len - split + i,
              forall |k: usize| split <= k < len ==> result@[(k - split) as int] == list@[k as int],
              forall |k: usize| 0 <= k < i ==> result@[(len - split + k) as int] == list@[k as int],
      {
          result.push(list[i]);
          i = i + 1;
      }
      
      result
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

