vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  
  verus! {
  
  spec fn sorted_between(a: Seq<u32>, from: int, to: int) -> (result:bool) {
          forall |i: int, j:int|  from <= i < j < to ==> a[i] <= a[j]
      }
      // pure-end
  // pure-end
  
  spec fn is_reorder_of<T>(r: Seq<int>, p: Seq<T>, s: Seq<T>) -> (result:bool) {
      &&& r.len() == s.len()
      &&& forall|i: int| 0 <= i < r.len() ==> 0 <= #[trigger] r[i] < r.len()
      &&& forall|i: int, j: int| 0 <= i < j < r.len() ==> r[i] != r[j]
      &&& p =~= r.map_values(|i: int| s[i])
  }
  // pure-end

vc-helpers: |-
  fn swap<T>(v: &mut Vec<T>, i: usize, j: usize)
      requires
          0 <= i < v.len(),
          0 <= j < v.len(),
      ensures
          v@ =~= old(v)@.update(i as int, old(v)@[j as int]).update(j as int, old(v)@[i as int]),
  {
      let temp = v[j];
      v.set(j, v[i]);
      v.set(i, temp);
  }
  
  proof fn lemma_sorted_after_swap(a: Seq<u32>, i: int, j: int)
      requires
          0 <= i < j < a.len(),
          sorted_between(a, 0, a.len() as int),
          a[i] > a[j],
      ensures
          sorted_between(a.update(i, a[j]).update(j, a[i]), 0, a.len() as int),
  {
  }
  
  spec fn count_inversions(a: Seq<u32>, i: int, j: int) -> nat
      decreases j - i
  {
      if i >= j {
          0
      } else {
          let mid = (i + j) / 2;
          count_inversions(a, i, mid) + count_inversions(a, mid, j) + count_merge_inversions(a, i, mid, j)
      }
  }
  
  spec fn count_merge_inversions(a: Seq<u32>, i: int, mid: int, j: int) -> nat
  {
      0
  }

vc-spec: |-
  fn test1(nums: &mut Vec<u32>)
          // post-conditions-start
          ensures
              sorted_between(nums@, 0, nums@.len() as int),
              exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
          // post-conditions-end

vc-code: |-
  fn test1(nums: &mut Vec<u32>)
      ensures
          sorted_between(nums@, 0, nums@.len() as int),
          exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
  {
      let mut i: usize = 0;
      while i < nums.len()
          invariant
              0 <= i <= nums.len(),
              sorted_between(nums@, 0, i as int),
              exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
      {
          let mut min_idx = i;
          let mut j = i + 1;
          while j < nums.len()
              invariant
                  i < nums.len(),
                  min_idx >= i,
                  min_idx < nums.len(),
                  forall|k: int| i as int <= k < j as int ==> nums@[min_idx as int] <= nums@[k],
                  sorted_between(nums@, 0, i as int),
                  exists|r: Seq<int>| is_reorder_of(r, nums@, old(nums)@),
          {
              if nums[j] < nums[min_idx] {
                  min_idx = j;
              }
              j = j + 1;
          }
          if min_idx != i {
              swap(nums, i, min_idx);
          }
          i = i + 1;
      }
  }

vc-postamble: |-
  
  }
  
  fn main() {}

