vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  fn contains(arr: &Vec<i32>, key: i32) -> (result: bool)
      ensures
          result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),
  {
      let mut i = 0;
      while i < arr.len()
          invariant
              forall|m: int| 0 <= m < i ==> (arr[m] != key),
          decreases
              arr.len() - i,
      {
          if (arr[i] == key) {
              return true;
          }
          i += 1;
      }
      false
  }
  
  proof fn lemma_contains_implies_element(seq: Seq<i32>, key: i32)
      requires
          seq.contains(key),
      ensures
          exists|i: int| 0 <= i < seq.len() && seq[i] == key,
  {
  }
  
  proof fn lemma_unique_elements(vec: &Vec<i32>, result: &Vec<i32>, new_elem: i32)
      requires
          forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],
          forall|i: int| 0 <= i < result.len() ==> vec@.contains(result[i]),
          !result@.contains(new_elem),
      ensures
          forall|i: int, j: int| 0 <= i < j < result.len() + 1 ==> 
              if i == result.len() { result[j] != new_elem } else if j == result.len() { result[i] != new_elem } else { result[i] != result[j] },
  {
  }

vc-spec: |-
  fn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)
      // post-conditions-start
      ensures
          forall|i: int|
              0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(
                  #[trigger] shared[i],
              )),
          forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],
      // post-conditions-end

vc-code: |-
  {
      let mut result = Vec::new();
      let mut i = 0;
      while i < list1.len()
          invariant
              forall|m: int| 0 <= m < result.len() ==> list1@.contains(result[m]) && list2@.contains(result[m]),
              forall|m: int, n: int| 0 <= m < n < result.len() ==> result[m] != result[n],
              forall|m: int| 0 <= m < i ==> !list2@.contains(list1[m]) ==> !result@.contains(list1[m]),
          decreases
              list1.len() - i,
      {
          let elem = list1[i];
          let mut found_in_list2 = false;
          let mut j = 0;
          while j < list2.len()
              invariant
                  0 <= j <= list2.len(),
                  found_in_list2 ==> list2@.contains(elem),
                  !found_in_list2 ==> forall|k: int| 0 <= k < j ==> list2[k] != elem,
              decreases
                  list2.len() - j,
          {
              if list2[j] == elem {
                  found_in_list2 = true;
                  break;
              }
              j += 1;
          }
          let mut found_in_result = false;
          let mut k = 0;
          while k < result.len()
              invariant
                  0 <= k <= result.len(),
                  found_in_result ==> result@.contains(elem),
                  !found_in_result ==> forall|m: int| 0 <= m < k ==> result[m] != elem,
              decreases
                  result.len() - k,
          {
              if result[k] == elem {
                  found_in_result = true;
                  break;
              }
              k += 1;
          }
          if found_in_list2 && !found_in_result {
              proof {
                  lemma_contains_implies_element(list2@, elem);
                  lemma_unique_elements(list1, &result, elem);
              }
              result.push(elem);
          }
          i += 1;
      }
      result
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

