vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn min_spec(seq: Seq<i32>) -> (result: int)
      recommends
          0 < seq.len(),
      decreases seq.len(),
  {
      if seq.len() == 1 {
          seq[0] as int
      } else if seq.len() == 0 {
          0
      } else {
          let later_min = min_spec(seq.drop_first());
          if seq[0] <= later_min {
              seq[0] as int
          } else {
              later_min as int
          }
      }
  }
  // pure-end

vc-helpers: |-
  spec fn min_index_spec(seq: Seq<i32>) -> (result: int)
      recommends
          0 < seq.len(),
      decreases seq.len(),
  {
      if seq.len() == 1 {
          0
      } else {
          let later_min_idx = min_index_spec(seq.drop_first());
          let later_min_val = seq.drop_first()[later_min_idx];
          if seq[0] <= later_min_val {
              0
          } else {
              later_min_idx + 1
          }
      }
  }
  
  spec fn second_min_spec(seq: Seq<i32>, min_idx: int) -> (result: int)
      recommends
          0 < seq.len(),
          seq.len() >= 2,
          0 <= min_idx < seq.len(),
      decreases seq.len(),
  {
      let without_min = seq.remove(min_idx);
      if without_min.len() == 1 {
          if min_idx == 0 {
              1
          } else {
              0
          }
      } else {
          let later_min_idx = min_index_spec(without_min);
          if min_idx <= later_min_idx {
              later_min_idx + 1
          } else {
              later_min_idx
          }
      }
  }
  
  proof fn min_is_correct(seq: Seq<i32>)
      requires
          seq.len() > 0,
      ensures
          forall|k: int| 0 <= k < seq.len() ==> seq[min_index_spec(seq)] <= seq[k],
      decreases seq.len(),
  {
      if seq.len() == 1 {
      } else {
          let later = seq.drop_first();
          min_is_correct(later);
          let later_min_idx = min_index_spec(later);
          let min_idx = min_index_spec(seq);
          if seq[0] <= later[later_min_idx] {
              assert(min_idx == 0);
          } else {
              assert(min_idx == later_min_idx + 1);
              assert(later[later_min_idx] == seq[min_idx]);
          }
      }
  }
  
  proof fn second_min_is_correct(seq: Seq<i32>, min_idx: int)
      requires
          seq.len() >= 2,
          0 <= min_idx < seq.len(),
      ensures
          forall|k: int| 0 <= k < seq.len() && k != min_idx ==> seq[second_min_spec(seq, min_idx)] <= seq[k],
          exists|k: int| 0 <= k < seq.len() && k != min_idx && seq[k] == seq[second_min_spec(seq, min_idx)],
      decreases seq.len(),
  {
      let without_min = seq.remove(min_idx);
      min_is_correct(without_min);
      let second_idx = second_min_spec(seq, min_idx);
      let later_min_idx = min_index_spec(without_min);
      if min_idx <= later_min_idx {
          assert(second_idx == later_min_idx + 1);
      } else {
          assert(second_idx == later_min_idx);
      }
      assert(forall|k: int| 0 <= k < without_min.len() ==> without_min[later_min_idx] <= without_min[k]);
      assert(exists|k: int| 0 <= k < without_min.len() && without_min[k] == without_min[later_min_idx]);
  }

vc-spec: |-
  fn second_smallest(numbers: &Vec<i32>) -> (indices: (usize, usize))
      // pre-conditions-start
      requires
          numbers.len() >= 2,
      // pre-conditions-end
      // post-conditions-start
      ensures
          forall|k: int|
              0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(
                  numbers@,
              ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),
          exists|k: int|
              0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]
                  == numbers[indices.1 as int]),
      // post-conditions-end

vc-code: |-
  {
      let min_idx: usize = {
          let mut current_min_idx: usize = 0;
          let mut i: usize = 1;
          while i < numbers.len()
              invariant
                  0 <= current_min_idx < numbers.len(),
                  1 <= i <= numbers.len(),
                  forall|k: int| 0 <= k < i ==> numbers[current_min_idx as int] <= numbers[k],
              decreases numbers.len() - i,
          {
              if numbers[i] < numbers[current_min_idx] {
                  current_min_idx = i;
              }
              i = i + 1;
          }
          current_min_idx
      };
  
      let second_min_idx: usize = {
          let mut current_min_idx: usize = if min_idx == 0 { 1 } else { 0 };
          let mut i: usize = 0;
          while i < numbers.len()
              invariant
                  0 <= current_min_idx < numbers.len(),
                  current_min_idx != min_idx,
                  0 <= i <= numbers.len(),
                  forall|k: int| 0 <= k < i && k != min_idx ==> numbers[current_min_idx as int] <= numbers[k],
              decreases numbers.len() - i,
          {
              if i != min_idx && numbers[i] < numbers[current_min_idx] {
                  current_min_idx = i;
              }
              i = i + 1;
          }
          current_min_idx
      };
  
      proof {
          min_is_correct(numbers@);
          second_min_is_correct(numbers@, min_idx as int);
      }
  
      (min_idx, second_min_idx)
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

