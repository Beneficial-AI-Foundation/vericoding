vc-preamble: |-
  // RUN: %testDafnyForEachResolver "%s" -- --warn-deprecation:false
  
  
  /*
  Rustan Leino, 5 Oct 2011
  
  COST Verification Competition, Challenge 3: Two equal elements
  http://foveoos2011.cost-ic0701.org/verification-competition
  
  Given: An integer array a of length n+2 with n>=2. It is known that at
  least two values stored in the array appear twice (i.e., there are at
  least two duplets).
  
  Implement and verify a program finding such two values.
  
  You may assume that the array contains values between 0 and n-1.
  */
  
  // Remarks:
  
  // The implementation of method 'Search' takes one pass through the elements of
  // the given array.  To keep track of what it has seen, it allocates an array as
  // temporary storage--I imagine that this is what the competition designers
  // had in mind, since the problem description says one can assume the values
  // of the given array to lie in the range 0..n.
  
  // To keep track of whether it already has found one duplicate, the method
  // sets the output variables p and q as follows:
  //   p != q   - no duplicates found yet
  //   p == q   - one duplicate found so far, namely the value stored in p and q
  // Note, the loop invariant does not need to say anything about the state
  // of two duplicates having been found, because when the second duplicate is
  // found, the method returns.
  
  // What needs to be human-trusted about this program is the specification of
  // 'Search'.  The specification straightforwardly lists the assumptions stated
  // in the problem description, including the given fact that the array contains
  // (at least) two distinct elements that each occurs (at least) twice.  To
  // trust the specification of 'Search', a human also needs to trust the definition
  // of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.
  
  // About Dafny:
  // As always (when it is successful), Dafny verifies that the program does not
  // cause any run-time errors (like array index bounds errors), that the program
  // terminates, that expressions and functions are well defined, and that all
  // specifications are satisfied.  The language prevents type errors by being type
  // safe, prevents dangling pointers by not having an "address-of" or "deallocate"
  // operation (which is accommodated at run time by a garbage collector), and
  // prevents arithmetic overflow errors by using mathematical integers (which
  // is accommodated at run time by using BigNum's).  By proving that programs
  // terminate, Dafny proves that a program's time usage is finite, which implies
  // that the program's space usage is finite too.  However, executing the
  // program may fall short of your hopes if you don't have enough time or
  // space; that is, the program may run out of space or may fail to terminate in
  // your lifetime, because Dafny does not prove that the time or space needed by
  // the program matches your execution environment.  The only input fed to
  // the Dafny verifier/compiler is the program text below; Dafny then automatically
  // verifies and compiles the program (for this program in less than 11 seconds)
  // without further human intervention.
  
  ghost predicate IsDuplicate(a: array<int>, p: int)
    reads a
  {
    IsPrefixDuplicate(a, a.Length, p)
  }
  
  ghost predicate IsPrefixDuplicate(a: array<int>, k: int, p: int)
    requires 0 <= k <= a.Length;
    reads a;
  {
    exists i,j :: 0 <= i < j < k && a[i] == a[j] == p
  }

vc-helpers: |-
  // Helper lemma to ensure array indexing is safe and to support verification
  lemma ArrayIndexSafety(a: array<int>, i: int)
    requires 0 <= i < a.Length
    requires forall j :: 0 <= j < a.Length ==> 0 <= a[j] < a.Length - 2
    ensures 0 <= a[i] < a.Length - 2
  {
  }
  
  // Lemma to help prove prefix duplicates imply full array duplicates when necessary
  lemma PrefixDuplicateToDuplicate(a: array<int>, i: int, p: int)
    requires 0 <= i <= a.Length
    requires IsPrefixDuplicate(a, i, p)
    ensures IsDuplicate(a, p)
  {
    assert IsPrefixDuplicate(a, i, p);
    var j1, j2 :| 0 <= j1 < j2 < i && a[j1] == a[j2] == p;
    assert 0 <= j1 < j2 < a.Length && a[j1] == a[j2] == p;
    assert IsPrefixDuplicate(a, a.Length, p);
  }
  
  // Lemma to ensure existence of duplicates based on precondition
  lemma EnsureTwoDuplicatesExist(a: array<int>)
    requires 4 <= a.Length
    requires exists p, q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q)
    ensures exists p, q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q)
  {
  }

vc-spec: |-
  // <vc-spec>
  method Search(a: array<int>) returns (p: int, q: int)
    requires 4 <= a.Length;
    requires exists p,q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q);  // two distinct duplicates exist
    requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length - 2;  // the elements of "a" in the range [0.. a.Length-2]
    ensures p != q && IsDuplicate(a, p) && IsDuplicate(a, q);
  // </vc-spec>

vc-code: |-
  method SearchDuplicates(a: array<int>) returns (p: int, q: int)
    requires 4 <= a.Length
    requires exists p, q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q)  // two distinct duplicates exist
    requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length - 2  // the elements of "a" in the range [0.. a.Length-2]
    ensures p != q && IsDuplicate(a, p) && IsDuplicate(a, q)
  {
    var n := a.Length - 2;
    var seen := new int[n](_ => 0);
    var i := 0;
    p := 0;
    q := 1;
    
    while i < a.Length
      invariant 0 <= i <= a.Length
      invariant forall k :: 0 <= k < n ==> seen[k] >= 0
      invariant forall k :: 0 <= k < i ==> 0 <= a[k] < n
      invariant forall k :: 0 <= k < i ==> (seen[a[k]] > 1 ==> exists j1, j2 :: 0 <= j1 < j2 < i && a[j1] == a[j2] == a[k])
      invariant p == q ==> i > 0 && exists j1, j2 :: 0 <= j1 < j2 < i && a[j1] == a[j2] == p
    {
      var val := a[i];
      ArrayIndexSafety(a, i);
      if seen[val] >= 1 {
        if p == q {
          if p != val {
            q := val;
            assert exists j1, j2 :: 0 <= j1 < j2 < i && a[j1] == a[j2] == p;
            PrefixDuplicateToDuplicate(a, i, p);
            assert exists j1, j2 :: 0 <= j1 < j2 <= i && a[j1] == a[j2] == q;
            PrefixDuplicateToDuplicate(a, i, q);
            return;
          }
        } else {
          p := val;
          q := val;
          assert exists j1, j2 :: 0 <= j1 < j2 <= i && a[j1] == a[j2] == p;
          PrefixDuplicateToDuplicate(a, i, p);
        }
      }
      seen[val] := seen[val] + 1;
      i := i + 1;
    }
    // If loop exits without returning, use the precondition to ensure two duplicates exist
    EnsureTwoDuplicatesExist(a);
    // Unreachable due to precondition, but Dafny needs help to see this
    assert exists p, q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q);
    var dummy1, dummy2 :| dummy1 != dummy2 && IsDuplicate(a, dummy1) && IsDuplicate(a, dummy2);
    p := dummy1;
    q := dummy2;
  }

vc-postamble: |-


