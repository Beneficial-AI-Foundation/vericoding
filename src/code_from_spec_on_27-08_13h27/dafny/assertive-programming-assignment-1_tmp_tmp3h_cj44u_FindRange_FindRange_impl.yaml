vc-preamble: |-
  predicate Sorted(q: seq<int>)
  {
      forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] 
  }
  
  // all the values in the range satisfy `comparer` (comparer(q[i], key) == true)
  predicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)
      requires 0 <= lowerBound <= upperBound <= |q|
  {
      forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)
  }
  
  // all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)
  predicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)
      requires 0 <= lowerBound <= upperBound <= |q|
  {
      RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))
  }
  
  method BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)
      requires Sorted(q)
      requires 0 <= lowerBound <= upperBound <= |q|
      requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)
      requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)
      // comparer is '>' or '>='
      requires
          (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||
          (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))
  
      ensures lowerBound <= index <= upperBound
      ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)
      ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma BinarySearchProperties(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool, index: nat)
      requires Sorted(q)
      requires 0 <= lowerBound <= upperBound <= |q|
      requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)
      requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)
      requires (forall n1, n2 :: comparer(n1, n2) == (n1 > n2)) || (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))
      requires lowerBound <= index <= upperBound
      requires RangeSatisfiesComparerNegation(q, key, 0, index, comparer)
      requires RangeSatisfiesComparer(q, key, index, |q|, comparer)
      ensures forall i :: 0 <= i < index ==> !comparer(q[i], key)
      ensures forall i :: index <= i < |q| ==> comparer(q[i], key)
  {
  }

vc-spec: |-
  // <vc-spec>
  method FindRange(q: seq<int>, key: int) returns (left: nat, right: nat)
      requires Sorted(q)
      ensures left <= right <= |q|
      ensures forall i :: 0 <= i < left ==> q[i] < key
      ensures forall i :: left <= i < right ==> q[i] == key
      ensures forall i :: right <= i < |q| ==> q[i] > key
  // </vc-spec>

vc-code: |-
  {
      var leftIndex := BinarySearch(q, key, 0, |q|, (x, y) => x >= y);
      var rightIndex := BinarySearch(q, key, 0, |q|, (x, y) => x > y);
      BinarySearchProperties(q, key, 0, |q|, (x, y) => x >= y, leftIndex);
      BinarySearchProperties(q, key, 0, |q|, (x, y) => x > y, rightIndex);
      return leftIndex, rightIndex;
  }

vc-postamble: |-


