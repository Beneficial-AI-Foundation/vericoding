vc-preamble: |-
  //Method barrier below receives an array and an integer p
  //and returns a boolean b which is true if and only if 
  //all the positions to the left of p and including also position p contain elements 
  //that are strictly smaller than all the elements contained in the positions to the right of p 
  
  //Examples:
  // If v=[7,2,5,8] and p=0 or p=1 then the method must return false, 
  // but for p=2 the method should return true
  //1.Specify the method
  //2.Implement an O(v.size()) method
  //3.Verify the method

vc-helpers: |-
  // Helper lemma to assist in proving properties about arrays if needed
  lemma ArrayProperty(v: array<int>, p: int)
    requires v.Length > 0
    requires 0 <= p < v.Length
    ensures true
  {
    // No additional lemmas needed for this specific case
  }

vc-spec: |-
  // <vc-spec>
  method barrier(v:array<int>,p:int) returns (b:bool)
  //Give the precondition
  //Give the postcondition
  //{Implement and verify}
  requires v.Length > 0
  requires 0<=p<v.Length
  ensures b==forall k,l::0<=k<=p && p<l<v.Length ==> v[k]<v[l]
  // </vc-spec>

vc-code: |-
  method Barrier(v: array<int>, p: int) returns (b: bool)
    requires v.Length > 0
    requires 0 <= p < v.Length
    ensures b == forall k, l :: 0 <= k <= p && p < l < v.Length ==> v[k] < v[l]
  {
    var leftMax := v[0];
    var i := 1;
    // Find the maximum value in the left part including position p
    while i <= p
      invariant 0 <= i <= p + 1
      invariant leftMax == if i == 0 then v[0] else MaxValue(v, 0, i - 1)
      invariant forall k :: 0 <= k < i ==> v[k] <= leftMax
    {
      if v[i] > leftMax {
        leftMax := v[i];
      }
      i := i + 1;
    }
    
    // Check if all elements to the right of p are greater than leftMax
    b := true;
    i := p + 1;
    while i < v.Length
      invariant p + 1 <= i <= v.Length
      invariant b ==> forall k :: p < k < i ==> v[k] > leftMax
      invariant !b ==> exists k :: p < k < i && v[k] <= leftMax
    {
      if v[i] <= leftMax {
        b := false;
      }
      i := i + 1;
    }
    
    // Prove the postcondition
    if b {
      assert forall k :: 0 <= k <= p ==> v[k] <= leftMax;
      assert forall l :: p < l < v.Length ==> v[l] > leftMax;
      assert forall k, l :: 0 <= k <= p && p < l < v.Length ==> v[k] <= leftMax < v[l];
    } else {
      assert exists l :: p < l < v.Length && v[l] <= leftMax;
      assert !(forall k, l :: 0 <= k <= p && p < l < v.Length ==> v[k] < v[l]);
    }
  }
  
  // Helper function to compute maximum value in a range
  function MaxValue(v: array<int>, start: int, end: int): int
    requires 0 <= start <= end < v.Length
    ensures forall k :: start <= k <= end ==> v[k] <= MaxValue(v, start, end)
    ensures exists k :: start <= k <= end && v[k] == MaxValue(v, start, end)
  {
    if start == end then v[start]
    else if v[start] > MaxValue(v, start + 1, end) then v[start]
    else MaxValue(v, start + 1, end)
  }

vc-postamble: |-


