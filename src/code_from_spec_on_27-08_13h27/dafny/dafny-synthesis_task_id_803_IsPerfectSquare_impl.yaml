vc-preamble: |-


vc-helpers: |-
  lemma MulInequality(a: int, b: int)
    ensures a < b && a >= 0 && b >= 0 ==> a * a < b * b
  {
    if a < b && a >= 0 && b >= 0 {
      var diff := b - a;
      assert diff > 0;
      assert b * b - a * a == (b - a) * (b + a);
      assert b + a > 0;
      assert (b - a) * (b + a) > 0;
      assert b * b > a * a;
    }
  }

vc-spec: |-
  // <vc-spec>
  method IsPerfectSquare(n: int) returns (result: bool)
      requires n >= 0
      ensures result == true ==> (exists i: int :: 0 <= i <= n && i * i == n)
      ensures result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)
  // </vc-spec>

vc-code: |-
  method IsPerfectSquareImpl(n: int) returns (result: bool)
    requires n >= 0
    ensures result == true ==> (exists i: int :: 0 <= i <= n && i * i == n)
    ensures result == false ==> (forall a: int :: 0 < a * a < n ==> a * a != n)
  {
    if n == 0 {
      return true;
    }
  
    var low := 0;
    var high := n;
  
    while low <= high
      invariant 0 <= low <= n
      invariant 0 <= high <= n
      invariant forall k: int :: 0 <= k < low ==> k * k < n
      invariant forall k: int :: high < k <= n ==> k * k > n
    {
      var mid := (low + high) / 2;
      var midSquared := mid * mid;
  
      if midSquared == n {
        assert 0 <= mid <= n && mid * mid == n;
        return true;
      } else if midSquared < n {
        low := mid + 1;
      } else {
        high := mid - 1;
      }
    }
  
    // When loop ends, low > high, and no perfect square was found
    assert forall a: int :: 0 < a * a < n ==> a * a != n by {
      forall a: int | 0 < a * a < n {
        if a <= high {
          assert a * a <= high * high < n;
        } else if a >= low {
          assert a * a >= low * low > n;
        }
      }
    }
    return false;
  }

vc-postamble: |-


