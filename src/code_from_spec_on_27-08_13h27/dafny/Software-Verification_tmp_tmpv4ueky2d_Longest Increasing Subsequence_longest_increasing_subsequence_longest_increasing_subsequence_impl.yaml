vc-preamble: |-
  // Function
  function find_max(x: int, y: int): int
  {
      if x > y then x
      else y
  }

vc-helpers: |-
  // Helper function to check if a subsequence is increasing
  predicate isIncreasing(nums: array<int>, start: int, end: int)
    requires 0 <= start <= end < nums.Length
    reads nums
  {
    forall i, j :: start <= i < j <= end ==> nums[i] <= nums[j]
  }
  
  // Helper lemma to establish properties of increasing subsequences
  lemma IncreasingSubsequenceProperty(nums: array<int>, start: int, end: int)
    requires 0 <= start <= end < nums.Length
    requires isIncreasing(nums, start, end)
    ensures forall k :: start <= k <= end ==> isIncreasing(nums, start, k) && isIncreasing(nums, k, end)
  {
  }
  
  // Helper lemma to prove existence of increasing subsequence for dp values
  lemma DpRepresentsIncreasingSubsequence(nums: array<int>, dp: array<int>, i: int, startIndices: array<int>)
    requires 0 <= i <= nums.Length
    requires dp.Length == nums.Length
    requires startIndices.Length == nums.Length
    requires forall k :: 0 <= k < i ==> dp[k] >= 1
    requires forall k :: 0 <= k < i ==> 0 <= startIndices[k] <= k
    requires forall k :: 0 <= k < i ==> exists p, q :: 0 <= p <= q < nums.Length && q - p + 1 == dp[k] && isIncreasing(nums, p, q)
    ensures i < nums.Length ==> exists p, q :: 0 <= p <= q < nums.Length && q - p + 1 == dp[i] && isIncreasing(nums, p, q)
  {
    if i == 0 {
      if nums.Length > 0 {
        assert exists p, q :: 0 <= p <= q < nums.Length && p == 0 && q == 0 && q - p + 1 == dp[0] && isIncreasing(nums, p, q);
      }
    } else if i < nums.Length {
      var j := 0;
      var maxLen := 1;
      var startIdx := i;
      while j < i
        invariant 0 <= j <= i
        invariant maxLen >= 1
        invariant 0 <= startIdx < nums.Length
      {
        if j < i && nums[j] <= nums[i] {
          if dp[j] + 1 > maxLen {
            maxLen := dp[j] + 1;
            startIdx := startIndices[j];
          }
        }
        j := j + 1;
      }
      if maxLen > 1 {
        var p, q :| 0 <= p <= q < nums.Length && q - p + 1 == dp[startIdx] && isIncreasing(nums, p, q);
        assert nums[q] <= nums[i];
        assert isIncreasing(nums, p, i);
        assert exists p', q' :: 0 <= p' <= q' < nums.Length && p' == p && q' == i && q' - p' + 1 == dp[startIdx] + (i - q) && isIncreasing(nums, p', q');
      } else {
        assert exists p, q :: 0 <= p <= q < nums.Length && p == i && q == i && q - p + 1 == 1 && isIncreasing(nums, p, q);
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method longest_increasing_subsequence(nums: array<int>) returns (max: int)
      requires 1 <= nums.Length <= 2500
      requires forall i :: 0 <= i < nums.Length ==> -10000 <= nums[i] <= 10000
      // TODO: modify the ensures clause so that max is indeed equal to the longest increasing subsequence
      ensures max >= 1
  // </vc-spec>

vc-code: |-
  method LongestIncreasingSubsequence(nums: array<int>) returns (max: int)
    requires 1 <= nums.Length <= 2500
    requires forall i :: 0 <= i < nums.Length ==> -10000 <= nums[i] <= 10000
    ensures max >= 1
    ensures exists i, j :: 0 <= i <= j < nums.Length && isIncreasing(nums, i, j) && max == j - i + 1
    ensures forall i, j :: 0 <= i <= j < nums.Length && isIncreasing(nums, i, j) ==> j - i + 1 <= max
  {
    var dp := new int[nums.Length];
    var startIndices := new int[nums.Length];
    var i := 0;
    max := 1;
  
    // Initialize dp array with 1 as each number by itself is an increasing subsequence of length 1
    while i < nums.Length
      invariant 0 <= i <= nums.Length
      invariant forall k :: 0 <= k < i ==> dp[k] == 1
      invariant forall k :: 0 <= k < i ==> startIndices[k] == k
      invariant forall k :: 0 <= k < i ==> exists p, q :: p == k && q == k && 0 <= p <= q < nums.Length && q - p + 1 == dp[k] && isIncreasing(nums, p, q)
    {
      dp[i] := 1;
      startIndices[i] := i;
      i := i + 1;
    }
  
    i := 1;
    while i < nums.Length
      invariant 0 <= i <= nums.Length
      invariant forall k :: 0 <= k < i ==> dp[k] >= 1
      invariant max >= 1
      invariant forall k :: 0 <= k < i ==> exists p, q :: 0 <= p <= q < nums.Length && q - p + 1 == dp[k] && isIncreasing(nums, p, q)
      invariant forall k, l :: 0 <= k <= l < i && isIncreasing(nums, k, l) ==> l - k + 1 <= max
      invariant forall k :: 0 <= k < i ==> 0 <= startIndices[k] <= k
    {
      var j := 0;
      var current_dp := 1;
      var startIdx := i;
      while j < i
        invariant 0 <= j <= i
        invariant current_dp >= 1
        invariant 0 <= startIdx < nums.Length
      {
        if nums[j] <= nums[i]
        {
          if dp[j] + 1 > current_dp
          {
            current_dp := dp[j] + 1;
            startIdx := startIndices[j];
          }
        }
        j := j + 1;
      }
      dp[i] := current_dp;
      startIndices[i] := startIdx;
      if dp[i] > max
      {
        max := dp[i];
      }
      i := i + 1;
    }
    
    // Prove the postcondition
    DpRepresentsIncreasingSubsequence(nums, dp, nums.Length, startIndices);
    assert exists k :: 0 <= k < nums.Length && dp[k] == max;
    var k :| 0 <= k < nums.Length && dp[k] == max;
    var p, q :| 0 <= p <= q < nums.Length && q - p + 1 == dp[k] && isIncreasing(nums, p, q);
    assert exists i, j :: 0 <= i <= j < nums.Length && isIncreasing(nums, i, j) && max == j - i + 1;
  }

vc-postamble: |-


