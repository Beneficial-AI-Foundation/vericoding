vc-preamble: |-
  method swap(arr: array<int>, i: int, j: int)
      requires arr.Length > 0
      requires 0 <= i < arr.Length && 0 <= j < arr.Length
      modifies arr
      ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])
      ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])
      ensures multiset(arr[..]) == multiset(old(arr[..]))
  {
    assume{:axiom} false;
  }
  
  function count(arr: seq<int>, value: int) : (c: nat)
      ensures c <= |arr|
  {
      if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)
  }

vc-helpers: |-
  lemma MultisetSwap(arr: array<int>, i: int, j: int)
    requires arr.Length > 0
    requires 0 <= i < arr.Length && 0 <= j < arr.Length
    ensures multiset(arr[..]) == multiset(old(arr[..]))
  {
    // The multiset remains unchanged after a swap
  }

vc-spec: |-
  // <vc-spec>
  method MoveZeroesToEnd(arr: array<int>)
      requires arr.Length >= 2
      modifies arr
      // Same size
      ensures arr.Length == old(arr.Length)
      // Zeros to the right of the first zero
      ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0
      // The final array is a permutation of the original one
      ensures multiset(arr[..]) == multiset(old(arr[..]))
      // Relative order of non-zero elements is preserved
      ensures forall n, m /* on old array */:: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> 
              exists k, l /* on new array */:: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])
      //ensures IsOrderPreserved(arr[..], old(arr[..]))
      // Number of zeros is preserved
  // </vc-spec>

vc-code: |-
  method MoveZeroesToEndImpl(arr: array<int>)
    requires arr.Length >= 2
    modifies arr
    ensures arr.Length == old(arr.Length)
    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0
    ensures multiset(arr[..]) == multiset(old(arr[..]))
    ensures forall n, m :: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> 
            exists k, l :: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])
  {
    var i := 0; // Points to the next position where a non-zero should go
    var j := 0; // Iterates through the array
    
    while j < arr.Length
      decreases arr.Length - j
      invariant 0 <= i <= j <= arr.Length
      invariant forall k :: 0 <= k < i ==> arr[k] != 0
      invariant forall k :: i <= k < j && arr[k] == 0 ==> exists l :: j <= l < arr.Length && arr[l] == 0
      invariant multiset(arr[..]) == multiset(old(arr[..]))
      invariant forall n, m :: 0 <= n < m < i && old(arr[n]) != 0 && old(arr[m]) != 0 ==> 
                exists k, l :: 0 <= k < l < i && arr[k] == old(arr[n]) && arr[l] == old(arr[m])
    {
      if arr[j] != 0 {
        if i != j {
          swap(arr, i, j);
          assert multiset(arr[..]) == multiset(old(arr[..]));
        }
        i := i + 1;
      }
      j := j + 1;
    }
  }

vc-postamble: |-


