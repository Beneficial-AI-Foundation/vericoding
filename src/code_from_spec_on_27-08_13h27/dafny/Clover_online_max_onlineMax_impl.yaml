vc-preamble: |-


vc-helpers: |-
  lemma MaxLemma(a: array<int>, x: int, m: int, p: int)
    requires 1 <= x < a.Length
    requires a.Length != 0
    requires forall i :: 0 <= i < x ==> a[i] <= m
    requires exists i :: 0 <= i < x && a[i] == m
    requires x <= p < a.Length
    requires x <= p < a.Length - 1 ==> (forall i :: 0 <= i < p ==> a[i] < a[p])
    requires (forall i :: x <= i < a.Length && a[i] <= m) ==> p == a.Length - 1
    ensures x <= p < a.Length
    ensures forall i :: 0 <= i < x ==> a[i] <= m
    ensures exists i :: 0 <= i < x && a[i] == m
    ensures x <= p < a.Length - 1 ==> (forall i :: 0 <= i < p ==> a[i] < a[p])
    ensures (forall i :: x <= i < a.Length && a[i] <= m) ==> p == a.Length - 1
  {
  }

vc-spec: |-
  // <vc-spec>
  method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)
    requires 1<=x<a.Length
    requires a.Length!=0
    ensures x<=p<a.Length
    ensures forall i::0<=i<x==> a[i]<=m
    ensures exists i::0<=i<x && a[i]==m
    ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])
    ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1
  // </vc-spec>

vc-code: |-
  method OnlineMax(a: array<int>, x: int) returns (m: int, p: int)
    requires 1 <= x < a.Length
    requires a.Length != 0
    ensures x <= p < a.Length
    ensures forall i :: 0 <= i < x ==> a[i] <= m
    ensures exists i :: 0 <= i < x && a[i] == m
    ensures x <= p < a.Length - 1 ==> (forall i :: 0 <= i < p ==> a[i] < a[p])
    ensures (forall i :: x <= i < a.Length && a[i] <= m) ==> p == a.Length - 1
  {
    // Initialize m as the maximum of the first x elements
    m := a[0];
    var maxIndex := 0;
    var i := 0;
    while i < x
      invariant 0 <= i <= x
      invariant forall k :: 0 <= k < i ==> a[k] <= m
      invariant 0 <= maxIndex < i || i == 0
      invariant i > 0 ==> a[maxIndex] == m
    {
      if a[i] > m {
        m := a[i];
        maxIndex := i;
      }
      i := i + 1;
    }
    
    // Initialize p to start from x
    p := x;
    while p < a.Length
      invariant x <= p <= a.Length
      invariant forall i :: 0 <= i < x ==> a[i] <= m
      invariant exists i :: 0 <= i < x && a[i] == m
      invariant p < a.Length ==> (forall i :: x <= i < p ==> a[i] <= m)
      invariant p > x ==> (forall i :: 0 <= i < p - 1 ==> a[i] < a[p - 1])
    {
      if p < a.Length - 1 && a[p] > m {
        var isMax := true;
        var k := 0;
        while k < p
          invariant 0 <= k <= p
          invariant isMax ==> forall i :: 0 <= i < k ==> a[i] < a[p]
        {
          if a[k] >= a[p] {
            isMax := false;
          }
          k := k + 1;
        }
        if isMax {
          assert x <= p < a.Length;
          assert forall i :: 0 <= i < x ==> a[i] <= m;
          assert exists i :: 0 <= i < x && a[i] == m;
          assert p < a.Length - 1 ==> (forall i :: 0 <= i < p ==> a[i] < a[p]);
          return;
        }
      }
      if a[p] > m {
        m := a[p];
      }
      p := p + 1;
    }
    // When loop ends, p == a.Length, and all elements from x to a.Length-1 are <= m
    assert p == a.Length;
    assert forall i :: x <= i < a.Length ==> a[i] <= m;
  }

vc-postamble: |-


