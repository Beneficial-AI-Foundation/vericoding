vc-preamble: |-
  datatype Exp = Const(int) | Var(string) | Plus(Exp, Exp) |  Mult(Exp, Exp)
  
  function eval(e:Exp, store:map<string, int>):int
  {
      match(e)
          case Const(n) => n
          case Var(s) => if(s in store) then store[s] else -1
          case Plus(e1, e2) => eval(e1, store) + eval(e2, store)
          case Mult(e1, e2) => eval(e1, store) * eval(e2, store)
  }
  
  //fill this function in to make optimizeFeatures work
  function optimize(e:Exp):Exp
  {
      match e
      case Mult(Const(0), e) => Const(0)
      case Mult(e, Const(0)) => Const(0)
      case Mult(Const(1), e) => e
      case Mult(e, Const(1)) => e
      case Mult(Const(n1), Const(n2)) => Const(n1*n2)
      case Plus(Const(0), e) => e
      case Plus(e, Const(0)) => e
      case Plus(Const(n1), Const(n2)) => Const(n1+ n2)
      case e => e
  
  } 
  
  //as you write optimize this will become unproved
  //you must write proof code so that Dafny can prove this

vc-helpers: |-
  lemma optimizePreservesEval(e: Exp, store: map<string, int>)
    ensures eval(optimize(e), store) == eval(e, store)
  {
    match e {
      case Const(n) => {}
      case Var(s) => {}
      case Plus(e1, e2) => {
        optimizePreservesEval(e1, store);
        optimizePreservesEval(e2, store);
        match optimize(e1) {
          case Const(n1) => {
            match optimize(e2) {
              case Const(n2) => {
                assert eval(optimize(e), store) == n1 + n2;
                assert eval(e, store) == n1 + n2;
              }
              case _ => {}
            }
          }
          case _ => {}
        }
      }
      case Mult(e1, e2) => {
        optimizePreservesEval(e1, store);
        optimizePreservesEval(e2, store);
        match optimize(e1) {
          case Const(n1) => {
            match optimize(e2) {
              case Const(n2) => {
                assert eval(optimize(e), store) == n1 * n2;
                assert eval(e, store) == n1 * n2;
              }
              case _ => {
                if n1 == 0 {
                  assert eval(optimize(e), store) == 0;
                  assert eval(e, store) == 0;
                } else if n1 == 1 {
                  assert eval(optimize(e), store) == eval(e2, store);
                  assert eval(e, store) == eval(e2, store);
                }
              }
            }
          }
          case _ => {
            match optimize(e2) {
              case Const(n2) => {
                if n2 == 0 {
                  assert eval(optimize(e), store) == 0;
                  assert eval(e, store) == 0;
                } else if n2 == 1 {
                  assert eval(optimize(e), store) == eval(e1, store);
                  assert eval(e, store) == eval(e1, store);
                }
              }
              case _ => {}
            }
          }
        }
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method optimizeCorrect(e:Exp, s:map<string, int>)
  ensures eval(e,s) == eval(optimize(e), s)
  // </vc-spec>

vc-code: |-
  method OptimizeCorrect(e: Exp, s: map<string, int>)
    ensures eval(e, s) == eval(optimize(e), s)
  {
    optimizePreservesEval(e, s);
  }

vc-postamble: |-


