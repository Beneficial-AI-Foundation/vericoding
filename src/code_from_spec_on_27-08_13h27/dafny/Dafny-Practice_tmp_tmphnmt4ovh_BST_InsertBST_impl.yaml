vc-preamble: |-
  datatype Tree = Empty | Node(int,Tree,Tree)
  
  
  
  function NumbersInTree(t: Tree): set<int>
  {
      NumbersInSequence(Inorder(t))
  }
  
  function NumbersInSequence(q: seq<int>): set<int>
  {
      set x | x in q
  }
  
  predicate BST(t: Tree)
  {
      Ascending(Inorder(t))
  }
  
  function Inorder(t: Tree): seq<int>
  {
      match t {
          case Empty => []
          case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)
      }
  }
  
  predicate Ascending(q: seq<int>)
  {
      forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]
  }
  
  predicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }
  
  /*
      Goal: Implement correctly, clearly. No need to document the proof obligations.
  */
  
  /*
      Goal: Implement correctly, efficiently, clearly, documenting the proof obligations
      as we've learned, with assertions and a lemma for each proof goal
  */

vc-helpers: |-
  lemma InorderPreservesAscending(t1: Tree, t2: Tree, x: int)
    requires Ascending(Inorder(t1)) && Ascending(Inorder(t2))
    requires forall y :: y in NumbersInTree(t1) ==> y < x
    requires forall y :: y in NumbersInTree(t2) ==> y > x
    ensures Ascending(Inorder(t1) + [x] + Inorder(t2))
  {
    var s1 := Inorder(t1);
    var s2 := Inorder(t2);
    var combined := s1 + [x] + s2;
    assert Ascending(s1);
    assert Ascending(s2);
    assert forall i :: 0 <= i < |s1| ==> s1[i] < x;
    assert forall j :: 0 <= j < |s2| ==> x < s2[j];
    assert forall i, j :: 0 <= i < |s1| && 0 <= j < |s2| ==> s1[i] < x < s2[j];
    assert forall i, j :: 0 <= i < j < |combined| ==> combined[i] < combined[j];
  }
  
  lemma NumbersInTreeUnion(t1: Tree, t2: Tree, x: int)
    ensures NumbersInTree(Node(x, t1, t2)) == NumbersInTree(t1) + {x} + NumbersInTree(t2)
  {
    calc {
      NumbersInTree(Node(x, t1, t2));
      == NumbersInSequence(Inorder(Node(x, t1, t2)));
      == NumbersInSequence(Inorder(t1) + [x] + Inorder(t2));
      == set y | y in (Inorder(t1) + [x] + Inorder(t2));
      == (set y | y in Inorder(t1)) + {x} + (set y | y in Inorder(t2));
      == NumbersInTree(t1) + {x} + NumbersInTree(t2);
    }
  }
  
  lemma BSTPreservesOrder(t: Tree, y: int, left: Tree, right: Tree)
    requires t == Node(y, left, right)
    requires BST(t)
    ensures forall z :: z in NumbersInTree(left) ==> z < y
    ensures forall z :: z in NumbersInTree(right) ==> z > y
  {
    var inorder := Inorder(t);
    var leftInorder := Inorder(left);
    var rightInorder := Inorder(right);
    assert inorder == leftInorder + [y] + rightInorder;
    assert Ascending(inorder);
    assert forall i, j :: 0 <= i < j < |inorder| ==> inorder[i] < inorder[j];
    assert forall i :: 0 <= i < |leftInorder| ==> leftInorder[i] < y;
    assert forall i :: 0 <= i < |rightInorder| ==> y < rightInorder[i];
  }
  
  lemma BSTImpliesAscending(t: Tree)
    requires BST(t)
    ensures Ascending(Inorder(t))
  {
    // Trivially true by definition of BST
  }
  
  lemma NumbersPreservedInBST(t: Tree, x: int, newT: Tree)
    requires BST(t) && x !in NumbersInTree(t)
    requires NumbersInTree(newT) == NumbersInTree(t) + {x}
    ensures x in NumbersInTree(newT)
  {
    // Trivially true by set union
  }

vc-spec: |-
  // <vc-spec>
  method InsertBST(t0: Tree, x: int) returns (t: Tree)
      requires BST(t0) && x !in NumbersInTree(t0)
      ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}
  // </vc-spec>

vc-code: |-
  method InsertBSTImpl(t0: Tree, x: int) returns (t: Tree)
    requires BST(t0) && x !in NumbersInTree(t0)
    ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0) + {x}
  {
    match t0 {
      case Empty =>
        t := Node(x, Empty, Empty);
        assert Inorder(t) == [x];
        assert Ascending(Inorder(t));
        assert NumbersInTree(t) == {x};
        assert NumbersInTree(t) == NumbersInTree(t0) + {x};
      case Node(y, left, right) =>
        BSTPreservesOrder(t0, y, left, right);
        assert forall z :: z in NumbersInTree(left) ==> z < y;
        assert forall z :: z in NumbersInTree(right) ==> z > y;
        if x < y {
          assert x !in NumbersInTree(left);
          var newLeft := InsertBSTImpl(left, x);
          assert BST(newLeft);
          assert NumbersInTree(newLeft) == NumbersInTree(left) + {x};
          t := Node(y, newLeft, right);
          NumbersInTreeUnion(newLeft, right, y);
          assert NumbersInTree(t) == NumbersInTree(newLeft) + {y} + NumbersInTree(right);
          assert NumbersInTree(t) == NumbersInTree(left) + {x} + {y} + NumbersInTree(right);
          assert NumbersInTree(t) == NumbersInTree(t0) + {x};
          assert forall z :: z in NumbersInTree(newLeft) ==> z < y;
          assert forall z :: z in NumbersInTree(right) ==> z > y;
          InorderPreservesAscending(newLeft, right, y);
          assert Ascending(Inorder(t));
          assert BST(t);
        } else {
          assert x !in NumbersInTree(right);
          var newRight := InsertBSTImpl(right, x);
          assert BST(newRight);
          assert NumbersInTree(newRight) == NumbersInTree(right) + {x};
          t := Node(y, left, newRight);
          NumbersInTreeUnion(left, newRight, y);
          assert NumbersInTree(t) == NumbersInTree(left) + {y} + NumbersInTree(newRight);
          assert NumbersInTree(t) == NumbersInTree(left) + {y} + NumbersInTree(right) + {x};
          assert NumbersInTree(t) == NumbersInTree(t0) + {x};
          assert forall z :: z in NumbersInTree(left) ==> z < y;
          assert forall z :: z in NumbersInTree(newRight) ==> z > y;
          InorderPreservesAscending(left, newRight, y);
          assert Ascending(Inorder(t));
          assert BST(t);
        }
    }
  }

vc-postamble: |-


