vc-preamble: |-
  //https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny
  function NChoose2(n: int): int
  {
    n * (n - 1) / 2
  }
  
  // sum of all integers in the range [lo, hi)
  // (inclusive of lo, exclusive of hi)
  function SumRange(lo: int, hi: int): int
    decreases hi - lo
  {
    if lo >= hi then 0
    else SumRange(lo, hi - 1) + hi - 1
  }
  
  // dafny proves this automatically by induction

vc-helpers: |-
  lemma SumRangeLemma(lo: int, hi: int)
    ensures SumRange(lo, hi) == (hi * (hi - 1)) / 2 - (lo * (lo - 1)) / 2
    decreases hi - lo
  {
    if lo >= hi {
      calc {
        SumRange(lo, hi);
        0;
        (hi * (hi - 1)) / 2 - (lo * (lo - 1)) / 2;
      }
    } else {
      SumRangeLemma(lo, hi - 1);
      calc {
        SumRange(lo, hi);
        SumRange(lo, hi - 1) + (hi - 1);
        ((hi - 1) * (hi - 2)) / 2 - (lo * (lo - 1)) / 2 + (hi - 1);
        == {
          var term1 := ((hi - 1) * (hi - 2)) / 2;
          var term2 := (hi - 1);
          var combined := term1 + term2;
          assert combined == (hi * (hi - 1)) / 2 by {
            calc {
              term1 + term2;
              ((hi - 1) * (hi - 2)) / 2 + (hi - 1);
              ((hi - 1) * (hi - 2) + 2 * (hi - 1)) / 2;
              ((hi - 1) * ((hi - 2) + 2)) / 2;
              ((hi - 1) * hi) / 2;
              (hi * (hi - 1)) / 2;
            }
          }
        }
        (hi * (hi - 1)) / 2 - (lo * (lo - 1)) / 2;
      }
    }
  }
  
  lemma NChoose2Relation(n: int)
    requires n >= 1
    ensures NChoose2(n + 1) - NChoose2(1) == NChoose2(n) + n
  {
    calc {
      NChoose2(n + 1) - NChoose2(1);
      ((n + 1) * n) / 2 - (1 * 0) / 2;
      ((n + 1) * n) / 2;
      (n * n + n) / 2;
      (n * (n - 1) + 2 * n) / 2;
      (n * (n - 1)) / 2 + (2 * n) / 2;
      NChoose2(n) + n;
    }
  }
  
  lemma SumRangeBound(i: int, len: int)
    requires 0 <= i <= len
    ensures SumRange(i + 1, len + 1) <= NChoose2(len)
  {
    SumRangeLemma(i + 1, len + 1);
    calc {
      SumRange(i + 1, len + 1);
      ((len + 1) * len) / 2 - ((i + 1) * i) / 2;
      <= ((len + 1) * len) / 2;
      NChoose2(len + 1);
      >= NChoose2(len) by { NChoose2Monotonic(len); }
    }
  }
  
  lemma NChoose2Monotonic(len: int)
    requires len >= 0
    ensures NChoose2(len) <= NChoose2(len + 1)
  {
    calc {
      NChoose2(len);
      (len * (len - 1)) / 2;
      <= ((len + 1) * len) / 2;
      NChoose2(len + 1);
    }
  }

vc-spec: |-
  // <vc-spec>
  method BubbleSort(a: array<int>) returns (n: nat) 
    modifies a
    ensures n <= NChoose2(a.Length)
  // </vc-spec>

vc-code: |-
  method BubbleSortImpl(a: array<int>) returns (n: nat)
    modifies a
    ensures n <= NChoose2(a.Length)
  {
    var i := a.Length - 1;
    n := 0;
    while i >= 0
      invariant 0 <= i <= a.Length - 1 || i == -1
      invariant i >= 0 ==> n <= SumRange(i + 1, a.Length)
      invariant i == -1 ==> n <= SumRange(0, a.Length)
      decreases i
    {
      if i < 0 {
        break;
      }
      var j := 0;
      while j < i
        invariant 0 <= j <= i
        invariant n <= SumRange(i + 1, a.Length)
        decreases i - j
      {
        if a[j] > a[j + 1]
        {
          var temp := a[j];
          a[j] := a[j + 1];
          a[j + 1] := temp;
          n := n + 1;
        }
        j := j + 1;
      }
      i := i - 1;
    }
    SumRangeLemma(0, a.Length);
    SumRangeBound(-1, a.Length);
    assert n <= SumRange(0, a.Length);
    assert SumRange(0, a.Length) <= NChoose2(a.Length);
  }

vc-postamble: |-


