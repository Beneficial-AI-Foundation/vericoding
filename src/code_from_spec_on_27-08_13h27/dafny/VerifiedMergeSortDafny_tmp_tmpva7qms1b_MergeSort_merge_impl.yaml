vc-preamble: |-
  predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)
    reads b
    requires end - start  == |a2| + |a1|
    requires 0 <= start <= end <= b.Length
  {
    multiset(a1) + multiset(a2) == multiset(b[start..end])
  }
  
  predicate sorted_slice(a: array<int>, start: int, end: int)
    requires 0 <= start <= end <= a.Length
    reads a
  {
    forall i, j :: start <= i <= j < end ==> a[i] <= a[j]
  }
  
  predicate sorted_seq(a: seq<int>)
  {
    forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
  }
  
  predicate sorted(a: array<int>)
    reads a
  {
    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
  }

vc-helpers: |-
  lemma MergePreservesMultiset(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int, i: int, j: int, k: int)
    requires 0 <= start <= end <= b.Length
    requires end - start == |a1| + |a2|
    requires 0 <= i <= |a1|
    requires 0 <= j <= |a2|
    requires start <= k <= end
    requires k == start + i + j
    requires multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k])
    ensures multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k])
  {
  }
  
  lemma SortedMerge(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int, i: int, j: int, k: int)
    requires sorted_seq(a1)
    requires sorted_seq(a2)
    requires 0 <= start <= k <= end <= b.Length
    requires 0 <= i <= |a1|
    requires 0 <= j <= |a2|
    requires k == start + i + j
    requires end - start == |a1| + |a2|
    requires forall x :: start <= x < k ==> b[x] <= b[k-1]
    ensures forall x :: start <= x < k ==> b[x] <= b[k-1]
  {
  }
  
  lemma MultisetUpdate(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int, i: int, j: int, k: int)
    requires 0 <= start <= end <= b.Length
    requires end - start == |a1| + |a2|
    requires 0 <= i < |a1|
    requires 0 <= j <= |a2|
    requires start <= k < end
    requires k == start + i + j
    requires multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k])
    ensures multiset(a1[..i+1]) + multiset(a2[..j]) == multiset(b[start..k+1])
  {
    calc {
      multiset(a1[..i+1]) + multiset(a2[..j]);
      multiset(a1[..i]) + multiset([a1[i]]) + multiset(a2[..j]);
      multiset(b[start..k]) + multiset([a1[i]]);
      multiset(b[start..k] + [a1[i]]);
      multiset(b[start..k+1]);
    }
  }
  
  lemma MultisetUpdate2(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int, i: int, j: int, k: int)
    requires 0 <= start <= end <= b.Length
    requires end - start == |a1| + |a2|
    requires 0 <= i <= |a1|
    requires 0 <= j < |a2|
    requires start <= k < end
    requires k == start + i + j
    requires multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k])
    ensures multiset(a1[..i]) + multiset(a2[..j+1]) == multiset(b[start..k+1])
  {
    calc {
      multiset(a1[..i]) + multiset(a2[..j+1]);
      multiset(a1[..i]) + multiset(a2[..j]) + multiset([a2[j]]);
      multiset(b[start..k]) + multiset([a2[j]]);
      multiset(b[start..k] + [a2[j]]);
      multiset(b[start..k+1]);
    }
  }
  
  lemma SortedPreservation(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int, i: int, j: int, k: int, val: int)
    requires sorted_seq(a1)
    requires sorted_seq(a2)
    requires 0 <= start <= k < end <= b.Length
    requires 0 <= i <= |a1|
    requires 0 <= j <= |a2|
    requires k == start + i + j
    requires end - start == |a1| + |a2|
    requires sorted_slice(b, start, k)
    requires i < |a1| ==> val == a1[i]
    requires j < |a2| ==> val == a2[j]
    requires i < |a1| && j < |a2| ==> (val == a1[i] ==> a1[i] <= a2[j])
    requires i < |a1| && j < |a2| ==> (val == a2[j] ==> a2[j] <= a1[i])
    ensures sorted_slice(b, start, k+1)
  {
    assert sorted_slice(b, start, k);
    assert b[k] == val;
    forall x | start <= x < k
      ensures b[x] <= b[k]
    {
      assert sorted_slice(b, start, k);
      assert start <= x < k ==> b[x] <= b[k-1];
      if i > 0 && k > start {
        if val == a1[i] {
          if x == k-1 {
            if i-1 >= 0 {
              assert a1[i-1] <= a1[i];
              assert b[k-1] == a1[i-1] || b[k-1] == a2[j];
            }
          }
        } else if j > 0 {
          if val == a2[j] {
            if x == k-1 {
              if j-1 >= 0 {
                assert a2[j-1] <= a2[j];
                assert b[k-1] == a2[j-1] || b[k-1] == a1[i];
              }
            }
          }
        }
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method merge(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)
    modifies b
    requires sorted_seq(a1)
    requires sorted_seq(a2)
    requires end - start == |a1| + |a2|
    requires 0 <= start < end < |a1| && end <= |a2| < b.Length
    requires end < |a1| && end < |a2|
    ensures sorted_slice(b, start, end)
    requires b.Length == |a2| + |a1|
    ensures merged(a1, a2, b, start, end)
  // </vc-spec>

vc-code: |-
  method Merge(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)
    modifies b
    requires sorted_seq(a1)
    requires sorted_seq(a2)
    requires end - start == |a1| + |a2|
    requires 0 <= start < end <= b.Length
    ensures sorted_slice(b, start, end)
    ensures merged(a1, a2, b, start, end)
  {
    var i := 0;
    var j := 0;
    var k := start;
  
    while k < end
      invariant 0 <= i <= |a1|
      invariant 0 <= j <= |a2|
      invariant start <= k <= end
      invariant k == start + i + j
      invariant multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k])
      invariant sorted_slice(b, start, k)
    {
      if i < |a1| && (j >= |a2| || a1[i] <= a2[j]) {
        b[k] := a1[i];
        MultisetUpdate(a1, a2, b, start, end, i, j, k);
        if k > start {
          SortedPreservation(a1, a2, b, start, end, i, j, k, a1[i]);
        }
        i := i + 1;
      } else {
        b[k] := a2[j];
        MultisetUpdate2(a1, a2, b, start, end, i, j, k);
        if k > start {
          SortedPreservation(a1, a2, b, start, end, i, j, k, a2[j]);
        }
        j := j + 1;
      }
      k := k + 1;
    }
  
    assert i == |a1| && j == |a2|;
    assert k == end;
    assert multiset(a1[..i]) + multiset(a2[..j]) == multiset(b[start..k]);
    assert multiset(a1) + multiset(a2) == multiset(b[start..end]);
  }

vc-postamble: |-


