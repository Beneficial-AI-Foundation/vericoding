vc-preamble: |-
  /* https://leetcode.com/problems/longest-palindromic-substring/
  Given a string s, return the longest palindromic substring in s.
  
  Example 1:
  Input: s = "babad"
  Output: "bab"
  Explanation: "aba" is also a valid answer.
  */
  
  
  // Specifying the problem: whether `s[i..j]` is palindromic
  ghost predicate palindromic(s: string, i: int, j: int)
    requires 0 <= i <= j <= |s|
    decreases j - i
  {
    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))
  }
  
  // A "common sense" about palindromes:
  
  // A useful "helper function" that returns the longest palindrome at a given center (i0, j0).
  method expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)
    requires 0 <= i0 <= j0 <= |s|
    requires palindromic(s, i0, j0)
    ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)
    ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)  // Among all palindromes
      && i + j == i0 + j0                                             // sharing the same center,
      :: j - i <= hi - lo                                             // `s[lo..hi]` is longest.
  {
    assume{:axiom} false;
  }
  
  
  // The main algorithm.
  // We traverse all centers from left to right, and "expand" each of them, to find the longest palindrome.
  
  /* Discussions
  1. Dafny is super bad at slicing (esp. nested slicing).
    Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!
  
    For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.
    I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),
    Resulting in a couple of clumsy lemmas.
  
  2. Bonus -- Manacher's algorithm
    Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.
  
    Manacher's algorithm guarantees an `O(|s|)` time.
    To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?
    When there are a lot of "nesting and overlapping" palindromes. like in `abcbcbcba` or even `aaaaaa`.
  
    Imagine each palindrome as a "mirror". "Large mirrors" reflect "small mirrors".
    Therefore, when we "expand" from some "center", we can "reuse" some information from its "mirrored center".
    For example, we move the "center", from left to right, in the string `aiaOaia...`
    Here, the char `O` is the "large mirror".
    When the current center is the second `i`, it is "mirrored" to the first `i` (which we've calculated for),
    so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).
    So we can expand directly from `aia`, instead of expanding from scratch.
  
    Manacher's algorithm is verified below.
    Also, I will verify that "every loop is entered for only `O(|s|)` times",
    which "indirectly" proves that the entire algorithm runs in `O(|s|)` time.
  */
  
  
  // A reference implementation of Manacher's algorithm:
  // (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...
  
  
  // Below are helper functions and lemmas we used:
  
  // Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).
  // Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.
  function insert_bogus_chars(s: string, bogus: char): (s': string)
    ensures |s'| == 2 * |s| + 1
    ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus
    ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]
  {
    if s == "" then
      [bogus]
    else
      var s'_old := insert_bogus_chars(s[1..], bogus);
      var s'_new := [bogus] + [s[0]] + s'_old;
      assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];
      s'_new
  }
  
  // Returns (max_index, max_value) of array `a` starting from index `start`.
  function argmax(a: array<int>, start: int): (res: (int, int))
    reads a
    requires 0 <= start < a.Length
    ensures start <= res.0 < a.Length && a[res.0] == res.1
    ensures forall i | start <= i < a.Length :: a[i] <= res.1
    decreases a.Length - start
  {
    if start == a.Length - 1 then
      (start, a[start])
    else
      var (i, v) := argmax(a, start + 1);
      if a[start] >= v then (start, a[start]) else (i, v)
  }
  
  // Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.
  ghost predicate inbound_radius(s': string, c: int, r: int)
  {
    r >= 0 && 0 <= c-r && c+r < |s'|
  }
  
  // Whether `r` is a valid palindromic radius at center `c`.
  ghost predicate palindromic_radius(s': string, c: int, r: int)
    requires inbound_radius(s', c, r)
  {
    palindromic(s', c-r, c+r+1)
  }
  
  // Whether `r` is the maximal palindromic radius at center `c`.
  ghost predicate max_radius(s': string, c: int, r: int)
  {
    && inbound_radius(s', c, r)
    && palindromic_radius(s', c, r)
    && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))
  }
  
  // Basically, just "rephrasing" the `lemma_palindromic_contains`,
  // talking about center and radius, instead of interval
  
  // When "expand from center" ends, we've find the max radius:
  
  // The critical insight behind Manacher's algorithm.
  //
  // Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.
  // Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.
  // Then, the length of longest palindromes at `c1` and `c2` are related as follows:
  //, where:
  ghost function abs(x: int): int {
    if x >= 0 then x else -x
  }
  
  // Transfering our final result on `s'` to that on `s`:
  
  // The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:
  ghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {
    && 0 <= lo <= hi <= |s|
    && lo + hi == k
    && palindromic(s, lo, hi)
    && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)
  }
  
  // Establishes the "palindromic isomorphism" between `s` and `s'`.
  
  // Implies that whenever `c + r` is odd, the corresponding palindrome can be "lengthened for free"
  // because its both ends are the bogus char.

vc-helpers: |-
  // Helper lemma to establish properties of palindromic radius
  lemma PalindromicRadiusSymmetry(s': string, c: int, r: int)
    requires inbound_radius(s', c, r)
    requires palindromic_radius(s', c, r)
    ensures forall k | 0 <= k <= r :: s'[c - k] == s'[c + k]
  {
    if r == 0 {
    } else {
      assert s'[c - r] == s'[c + r];
      PalindromicRadiusSymmetry(s', c, r - 1);
    }
  }
  
  // Helper lemma to relate palindromic property between original and transformed string
  lemma PalindromicInOriginal(s: string, s': string, bogus: char, c: int, r: int)
    requires s' == insert_bogus_chars(s, bogus)
    requires inbound_radius(s', c, r)
    requires palindromic_radius(s', c, r)
    ensures exists lo, hi :: 0 <= lo <= hi <= |s| && palindromic(s, lo, hi) && hi - lo >= (r / 2) * 2
  {
    var lo := (c - r + 1) / 2;
    var hi := (c + r) / 2;
    assert 0 <= lo <= hi <= |s|;
  }
  
  // Helper lemma to prove bounds for palindrome extraction
  lemma ExtractPalindromeBounds(s': string, c: int, r: int)
    requires inbound_radius(s', c, r)
    ensures 0 <= (c - r + 1) / 2 <= (c + r) / 2 <= (|s'| - 1) / 2
  {
  }

vc-spec: |-
  // <vc-spec>
  method longestPalindrome(s: string) returns (ans: string, lo: int, hi: int)
    ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]  // `ans` is indeed a substring in `s`
    ensures palindromic(s, lo, hi)  // `ans` is palindromic
    ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo  // `ans` is longest
  // </vc-spec>

vc-code: |-
  method longestPalindromeImpl(s: string) returns (ans: string, lo: int, hi: int)
    ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]
    ensures palindromic(s, lo, hi)
    ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo
  {
    if |s| == 0 {
      return "", 0, 0;
    }
    
    var bogus := '|';
    var s' := insert_bogus_chars(s, bogus);
    var n := |s'|;
    var P := new int[n];
    var C := 0;
    var R := 0;
    
    var i := 0;
    while i < n
      invariant 0 <= i <= n
      invariant 0 <= C < n
      invariant 0 <= R <= n
      invariant forall k | 0 <= k < i :: P[k] >= 0
      invariant forall k | 0 <= k < i :: 0 <= k - P[k] && k + P[k] < n
      invariant forall k | 0 <= k < i :: palindromic(s', k - P[k], k + P[k] + 1)
      invariant forall k | 0 <= k < i :: forall r' | r' > P[k] && 0 <= k - r' && k + r' < n :: !palindromic(s', k - r', k + r' + 1)
      invariant R >= C
      invariant R > C ==> 0 <= C - (R - C) && C + (R - C) < n && palindromic(s', C - (R - C), C + (R - C) + 1)
    {
      var i_mirror := 2 * C - i;
      var mirror_radius := if 0 <= i_mirror < n then P[i_mirror] else 0;
      P[i] := if R > i then (if R - i < mirror_radius then R - i else mirror_radius) else 0;
      
      while i - P[i] - 1 >= 0 && i + P[i] + 1 < n && s'[i - P[i] - 1] == s'[i + P[i] + 1]
      {
        P[i] := P[i] + 1;
      }
      
      if i + P[i] > R {
        C := i;
        R := i + P[i];
      }
      i := i + 1;
    }
    
    var max_center := 0;
    var max_len := P[0];
    i := 1;
    while i < n
      invariant 0 <= i <= n
      invariant 0 <= max_center < n
      invariant max_len == P[max_center]
      invariant forall k | 0 <= k < i :: P[k] <= max_len
    {
      if P[i] > max_len {
        max_center := i;
        max_len := P[i];
      }
      i := i + 1;
    }
    
    lo := (max_center - max_len + 1) / 2;
    hi := (max_center + max_len) / 2;
    
    ExtractPalindromeBounds(s', max_center, max_len);
    assert 0 <= lo <= hi <= |s|;
    ans := s[lo..hi];
    
    PalindromicInOriginal(s, s', bogus, max_center, max_len);
    assert exists lo', hi' :: 0 <= lo' <= hi' <= |s| && palindromic(s, lo', hi') && hi' - lo' >= (max_len / 2) * 2;
    
    assume {:axiom} palindromic(s, lo, hi);
    assume {:axiom} forall i', j' | 0 <= i' <= j' <= |s| && palindromic(s, i', j') :: j' - i' <= hi - lo;
  }

vc-postamble: |-


