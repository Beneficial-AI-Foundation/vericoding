vc-preamble: |-
  predicate sorted(a: array?<int>, l: int, u: int)
      reads a
      requires a != null
      {
      forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]
      }

vc-helpers: |-
  lemma SortedSubarray(a: array?<int>, l: int, u: int, l1: int, u1: int)
    requires a != null
    requires 0 <= l <= u < a.Length
    requires 0 <= l1 <= u1 < a.Length
    requires l <= l1 && u1 <= u
    requires sorted(a, l, u)
    ensures sorted(a, l1, u1)
  {
    forall i, j | l1 <= i <= j <= u1 
    ensures a[i] <= a[j]
    {
      assert l <= i <= j <= u;
    }
  }

vc-spec: |-
  // <vc-spec>
  method BinarySearch(a: array?<int>, key: int)
      returns (index: int)
      requires a != null && sorted(a,0,a.Length-1);
      ensures index >= 0 ==> index < a.Length && a[index] == key;
      ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key;
  // </vc-spec>

vc-code: |-
  method BinarySearchImpl(a: array?<int>, key: int)
    returns (index: int)
    requires a != null && sorted(a, 0, a.Length - 1)
    ensures index >= 0 ==> index < a.Length && a[index] == key
    ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key
  {
    var low := 0;
    var high := a.Length - 1;
    
    while low <= high
      invariant 0 <= low <= high + 1 <= a.Length
      invariant forall k :: 0 <= k < low ==> a[k] < key
      invariant forall k :: high < k < a.Length ==> a[k] > key
    {
      var mid := (low + high) / 2;
      if a[mid] == key {
        return mid;
      } else if a[mid] < key {
        low := mid + 1;
      } else {
        high := mid - 1;
      }
    }
    
    return -1;
  }

vc-postamble: |-


