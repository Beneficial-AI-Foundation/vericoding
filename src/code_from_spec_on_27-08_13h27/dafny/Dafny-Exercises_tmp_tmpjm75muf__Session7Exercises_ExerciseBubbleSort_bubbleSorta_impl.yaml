vc-preamble: |-
  predicate sorted_seg(a:array<int>, i:int, j:int) //j excluded
  requires 0 <= i <= j <= a.Length
  reads a
  {
      forall l, k :: i <= l <= k < j ==> a[l] <= a[k]
  }

vc-helpers: |-
  predicate sorted(a: array<int>)
    reads a
  {
    forall i, j :: 0 <= i <= j < a.Length ==> a[i] <= a[j]
  }
  
  lemma sorted_seg_implies_sorted(a: array<int>, c: int, f: int)
    requires 0 <= c <= f <= a.Length
    requires sorted_seg(a, c, f)
    ensures forall i, j :: c <= i <= j < f ==> a[i] <= a[j]
  {
  }
  
  lemma multiset_preservation(a: array<int>, c: int, f: int, i: int)
    requires 0 <= c <= i < f <= a.Length
    ensures multiset(a[c..i] + a[i..f]) == multiset(a[c..f])
  {
  }
  
  lemma multiset_swap(a: array<int>, c: int, f: int, j: int)
    requires 0 <= c <= j < f <= a.Length
    ensures multiset(a[c..f]) == multiset(a[c..j] + [a[j]] + a[j+1..f])
  {
  }
  
  lemma sorted_seg_update(a: array<int>, i: int, f: int, j: int)
    requires 0 <= i <= j < f <= a.Length
    requires sorted_seg(a, i + 1, f)
    requires j + 1 < f ==> a[j] <= a[j+1]
    requires forall k :: i <= k < j ==> a[k] <= a[j]
    ensures sorted_seg(a, i, f)
  {
  }
  
  lemma multiset_after_swap(a: array<int>, c: int, f: int, j: int)
    requires 0 <= c <= j < f - 1 < f <= a.Length
    ensures multiset(a[c..j] + [a[j+1]] + [a[j]] + a[j+2..f]) == multiset(a[c..j] + [a[j]] + [a[j+1]] + a[j+2..f])
  {
  }

vc-spec: |-
  // <vc-spec>
  method bubbleSorta(a:array<int>, c:int, f:int)//f excluded
  modifies a 
  requires 0 <= c <= f <= a.Length //when c==f empty sequence
  ensures sorted_seg(a,c,f) 
  ensures multiset(a[c..f]) == old(multiset(a[c..f]))
  ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])
  // </vc-spec>

vc-code: |-
  method bubbleSort(a: array<int>, c: int, f: int)
    modifies a
    requires 0 <= c <= f <= a.Length
    ensures sorted_seg(a, c, f)
    ensures multiset(a[c..f]) == old(multiset(a[c..f]))
    ensures a[..c] == old(a[..c]) && a[f..] == old(a[f..])
  {
    if c >= f - 1 {
      return;
    }
    var i := f - 1;
    while c <= i
      decreases i
      invariant c - 1 <= i <= f
      invariant sorted_seg(a, i + 1, f)
      invariant multiset(a[c..f]) == old(multiset(a[c..f]))
      invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])
    {
      var j := c;
      while j < i
        decreases i - j
        invariant c <= j <= i <= f
        invariant sorted_seg(a, i + 1, f)
        invariant multiset(a[c..f]) == old(multiset(a[c..f]))
        invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])
        invariant forall k :: c <= k < j ==> a[k] <= a[j]
      {
        if a[j] > a[j+1]
        {
          var temp := a[j];
          a[j] := a[j+1];
          a[j+1] := temp;
          multiset_after_swap(a, c, f, j);
          assert multiset(a[c..f]) == old(multiset(a[c..f]));
        }
        j := j + 1;
      }
      sorted_seg_update(a, c, f, i);
      i := i - 1;
    }
  }

vc-postamble: |-


