vc-preamble: |-
  predicate sorted_seg(a:array<int>, i:int, j:int) //j not included
  requires 0 <= i <= j <= a.Length
  reads a
  {
      forall l, k :: i <= l <= k < j ==> a[l] <= a[k]
  }

vc-helpers: |-
  lemma SortedSegPreservation(a: array<int>, c: int, f: int, i: int)
    requires 0 <= c <= i <= f <= a.Length
    requires sorted_seg(a, c, i)
    requires sorted_seg(a, i, f)
    ensures sorted_seg(a, c, f)
  {
    forall l, k | c <= l <= k < f
    ensures a[l] <= a[k]
    {
      if l < i <= k {
        assert c <= l < i;
        assert a[l] <= a[i-1];
        assert i <= k < f;
        assert a[i] <= a[k];
        if i > c {
          assert a[i-1] <= a[i];
        }
        assert a[l] <= a[k];
      } else if l < i && k < i {
        assert c <= l <= k < i;
        assert a[l] <= a[k];
      } else if i <= l <= k {
        assert i <= l <= k < f;
        assert a[l] <= a[k];
      }
    }
  }
  
  lemma SortedSegUpdate(a: array<int>, c: int, i: int, minIndex: int, f: int)
    requires 0 <= c <= i <= minIndex < f <= a.Length
    requires sorted_seg(a, c, i)
    requires forall k :: i <= k < f ==> a[minIndex] <= a[k]
    ensures sorted_seg(a, c, i+1)
  {
    forall l, k | c <= l <= k < i+1
    ensures a[l] <= a[k]
    {
      if k == i {
        assert i <= minIndex < f;
        assert a[minIndex] <= a[k];
        assert c <= l <= i;
        if l == i {
          assert a[l] == a[k];
        } else {
          assert c <= l < i;
          if i > c {
            assert a[l] <= a[i-1];
            assert a[i-1] <= a[i];
          }
          assert a[l] <= a[k];
        }
      } else {
        assert c <= l <= k < i;
        assert a[l] <= a[k];
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method selSort (a:array<int>, c:int, f:int)//f excluded
  modifies a 
  requires 0 <= c <= f <= a.Length //when c==f empty sequence
  ensures sorted_seg(a,c,f) 
  ensures multiset(a[c..f]) == old(multiset(a[c..f]))
  ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])
  // </vc-spec>

vc-code: |-
  method SelectionSort(a: array<int>, c: int, f: int)
    modifies a
    requires 0 <= c <= f <= a.Length
    ensures sorted_seg(a, c, f)
    ensures multiset(a[c..f]) == old(multiset(a[c..f]))
    ensures a[..c] == old(a[..c]) && a[f..] == old(a[f..])
  {
    var i := c;
    while i < f
      decreases f - i
      invariant c <= i <= f
      invariant sorted_seg(a, c, i)
      invariant multiset(a[c..f]) == old(multiset(a[c..f]))
      invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])
    {
      var minIndex := i;
      var j := i + 1;
      while j < f
        decreases f - j
        invariant i <= j <= f
        invariant i <= minIndex < f
        invariant forall k :: i <= k < j ==> a[minIndex] <= a[k]
        invariant multiset(a[c..f]) == old(multiset(a[c..f]))
        invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])
      {
        if a[j] < a[minIndex] {
          minIndex := j;
        }
        j := j + 1;
      }
      if minIndex != i {
        var temp := a[i];
        a[i] := a[minIndex];
        a[minIndex] := temp;
      }
      SortedSegUpdate(a, c, i, minIndex, f);
      i := i + 1;
    }
  }

vc-postamble: |-


