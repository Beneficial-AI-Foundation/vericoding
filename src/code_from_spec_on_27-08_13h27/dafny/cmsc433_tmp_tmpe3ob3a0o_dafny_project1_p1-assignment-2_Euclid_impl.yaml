vc-preamble: |-
  // ASSIGNMENT P1
  // CMSC 433 FALL 2023
  // PERFECT SCORE:  100 POINTS
  //
  // This assignment contains nine questions, each of which involves writing Dafny
  // code. You should include your solutions in a single Dafny file and submit it using
  // Gradescope.
  //
  // Revision history
  //
  // 2023-09-22 2:50 pm   Fixed typo in Problem 3.
  
  
  // Question 1 (5 points)
  //
  // Fill in a requires clause that enables Dafny to verify
  // method PlusOne
  
  
  
  // Question 2 (5 points)
  //
  // Fill in requires clause(s) that enable(s) Dafny to verify the array bounds
  // in method Swap (which swaps elements i and j in array a).
  
  
  // Question 3 (5 points)
  //
  // Give ensures clause(s) asserting that d is the result, and r the
  // remainder, of dividing m by n.  Your clauses cannot use "/" or "%" (which are
  // the Dafny division and mod operators, respectively). By definition, the
  // remainder must be non-negative.
  
  
  // Question 4 (5 points)
  //
  // Give ensures clause(s) asserting that the return value has the same
  // length as array a and contains as its elements the sum of the
  // corresponding elements in arrays a and b.
  
  
  // Question 5 (10 points)
  
  // Euclid's algorithm is used to compute the greatest common divisor of two
  // positive integers.  If m and n are two such integers, then gcd(m,n) is the
  // largest positve integer that evenly divides both m and n, where j evenly divides i
  // if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and
  // ensures clauses for the method header Euclid below.  Your requires clauses
  // should also specify that the first argument is at least as large as the second.
  // You do *not* need to implement the method!

vc-helpers: |-
  // Helper function to compute GCD for invariant purposes
  function Gcd(a: int, b: int): int
      requires a > 0 && b >= 0
      ensures Gcd(a, b) > 0
      decreases b
  {
      if b == 0 then a else Gcd(b, a % b)
  }
  
  // Lemma to prove that Gcd(a, b) divides both a and b
  lemma GcdDivides(a: int, b: int)
      requires a > 0 && b >= 0
      ensures b == 0 ==> a % Gcd(a, b) == 0
      ensures b != 0 ==> a % Gcd(a, b) == 0 && b % Gcd(a, b) == 0
      decreases b
  {
      if b == 0 {
          assert a % Gcd(a, b) == a % a == 0;
      } else {
          GcdDivides(b, a % b);
          assert a % Gcd(a, b) == a % Gcd(b, a % b);
          assert b % Gcd(a, b) == b % Gcd(b, a % b);
      }
  }
  
  // Lemma to prove that Gcd(a, b) is less than or equal to a and b
  lemma GcdBound(a: int, b: int)
      requires a > 0 && b >= 0
      ensures Gcd(a, b) <= a
      ensures b != 0 ==> Gcd(a, b) <= b
      decreases b
  {
      if b == 0 {
          assert Gcd(a, b) == a;
      } else {
          GcdBound(b, a % b);
          assert Gcd(a, b) == Gcd(b, a % b);
          assert Gcd(a, b) <= b;
          assert a % b < b;
          assert Gcd(a, b) <= a;
      }
  }

vc-spec: |-
  // <vc-spec>
  method Euclid (m : int, n : int) returns (gcd : int)
      requires m > 1 && n > 1 && m >= n  // TODO
      ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0 // TODO
  // </vc-spec>

vc-code: |-
  method EuclidImpl(m: int, n: int) returns (gcd: int)
      requires m > 1 && n > 1 && m >= n
      ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0
  {
      var a := m;
      var b := n;
      while b != 0
          decreases b
          invariant a > 0 && b >= 0
          invariant Gcd(a, b) == Gcd(m, n)
      {
          var temp := b;
          b := a % b;
          a := temp;
      }
      gcd := a;
      assert gcd == Gcd(m, n);
      GcdBound(m, n);
      assert gcd <= m && gcd <= n;
      GcdDivides(m, n);
      assert m % gcd == 0 && n % gcd == 0;
  }

vc-postamble: |-
  // Question 7 (20 points)
  //
  // Implement, and have Dafny verify, the method IsPrime below, which returns true
  // if and only if the given positive integer is prime.
  
  
  // Question 8 (20 points)
  //
  // Implement, and have Dafny verify, the method Reverse below, which returns a new array
  // aRev consisting of the elements of a, but in reverse order.  To create a new 
  // array of ints use the Dafny command "new int[...]", where "..." is the number
  // of elements in the array.
  
  
  // Question 9 (20 points)
  //
  // Implement and verify method NoDups, which returns true if and only if there
  // are no duplicate elements in array a.  Note that the requires clause allows
  // you to assume that a is sorted, and that this precondition is necessary for
  // the ensures clause to imply a lack of duplicates.

