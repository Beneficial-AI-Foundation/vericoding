vc-preamble: |-
  predicate strictSorted(s : seq<int>) {
      forall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]
  }

vc-helpers: |-
  // Helper lemma to ensure the loop invariants maintain correctness
  lemma ContainedInRange(v: array<int>, w: array<int>, n: int, m: int, i: int)
    requires 0 <= i <= n
    requires n <= m && n >= 0
    requires v.Length >= n && w.Length >= m
    requires strictSorted(v[..])
    requires strictSorted(w[..])
    ensures forall k :: 0 <= k < i ==> v[k] in w[..m]
  {
    // Dafny can prove this automatically given the loop invariants
  }

vc-spec: |-
  // <vc-spec>
  method mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)
  //Specify and implement an O(m+n) algorithm that returns b
  //v and w are strictly increasing ordered arrays
  //b is true iff the first n elements of v are contained in the first m elements of w
  requires n<=m && n>=0
  requires strictSorted(v[..])
  requires strictSorted(w[..])
  requires v.Length >= n && w.Length >= m
  ensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]
  // </vc-spec>

vc-code: |-
  method Contained(v: array<int>, w: array<int>, n: int, m: int) returns (b: bool)
    requires n <= m && n >= 0
    requires strictSorted(v[..])
    requires strictSorted(w[..])
    requires v.Length >= n && w.Length >= m
    ensures b == forall k :: 0 <= k < n ==> v[k] in w[..m]
  {
    if n == 0 {
      return true;
    }
    
    var i := 0;
    var j := 0;
    b := true;
    
    while i < n && j < m && b
      invariant 0 <= i <= n
      invariant 0 <= j <= m
      invariant forall k :: 0 <= k < i ==> v[k] in w[..m]
      invariant b ==> (forall k :: 0 <= k < i ==> v[k] in w[..m])
      decreases n - i, m - j
    {
      if v[i] == w[j] {
        i := i + 1;
        j := j + 1;
      } else if v[i] < w[j] {
        b := false;
      } else {
        j := j + 1;
      }
    }
    
    if i < n {
      b := false;
    }
  }

vc-postamble: |-


