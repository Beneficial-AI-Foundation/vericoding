vc-preamble: |-
  // Checks if array 'a' is sorted.
  predicate isSorted(a: array<int>)
    reads a
  {
      forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
  }
  
  // Finds a value 'x' in a sorted array 'a', and returns its index,
  // or -1 if not found.
  
  // Simple test cases to check the post-condition.
  
  /*
  a) Identify adequate pre and post-conditions for this method, 
  and encode them as “requires” and “ensures” clauses in Dafny. 
  You can use the predicate below if needed.
  
  b) Identify an adequate loop variant and loop invariant, and encode them 
  as “decreases” and “invariant” clauses in Dafny.
  */

vc-helpers: |-
  // Helper lemma to ensure the value is not in a subarray
  lemma NotInSubarray(a: array<int>, x: int, lo: int, hi: int)
    requires 0 <= lo <= hi <= a.Length
    ensures x !in a[lo..hi] <==> forall i :: lo <= i < hi ==> a[i] != x
    decreases hi - lo
  {
    if lo == hi {
      assert a[lo..hi] == [];
      assert x !in a[lo..hi];
      assert forall i :: lo <= i < hi ==> false;
    } else {
      assert a[lo..hi] == [a[lo]] + a[lo+1..hi];
      if x in a[lo..hi] {
        if x == a[lo] {
          assert exists i :: lo <= i < hi && a[i] == x;
        } else {
          assert x in a[lo+1..hi];
          NotInSubarray(a, x, lo+1, hi);
          assert exists i :: lo+1 <= i < hi && a[i] == x;
          assert exists i :: lo <= i < hi && a[i] == x;
        }
      } else {
        assert x != a[lo];
        assert x !in a[lo+1..hi];
        NotInSubarray(a, x, lo+1, hi);
        assert forall i :: lo+1 <= i < hi ==> a[i] != x;
        assert forall i :: lo <= i < hi ==> a[i] != x;
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method binarySearch(a: array<int>, x: int) returns (index: int) 
      requires isSorted(a)
      ensures -1 <= index < a.Length
      ensures if index != -1 then a[index] == x 
          else x !in a[..] //forall i :: 0 <= i < a.Length ==> a[i] != x
  // </vc-spec>

vc-code: |-
  method BinarySearch(a: array<int>, x: int) returns (index: int)
    requires isSorted(a)
    ensures -1 <= index < a.Length
    ensures if index != -1 then a[index] == x else x !in a[..]
  {
    var lo := 0;
    var hi := a.Length;
    
    while lo < hi
      invariant 0 <= lo <= hi <= a.Length
      invariant x !in a[0..lo]
      invariant x !in a[hi..a.Length]
      decreases hi - lo
    {
      var mid := (lo + hi) / 2;
      if a[mid] == x {
        return mid;
      } else if a[mid] < x {
        lo := mid + 1;
      } else {
        hi := mid;
      }
    }
    
    NotInSubarray(a, x, 0, lo);
    NotInSubarray(a, x, hi, a.Length);
    assert x !in a[0..lo];
    assert x !in a[hi..a.Length];
    assert x !in a[..];
    return -1;
  }

vc-postamble: |-


