vc-preamble: |-
  ghost function SetProduct(s : set<int>) : int
  {
      if s == {} then 1
      else var x :| x in s; 
           x * SetProduct(s - {x})
  }

vc-helpers: |-
  lemma SetProductProperty(s: set<int>, x: int)
    ensures x in s ==> SetProduct(s) == x * SetProduct(s - {x})
    ensures x !in s ==> SetProduct(s + {x}) == x * SetProduct(s)
  {
    if x in s {
      var y :| y in s;
      if x == y {
        assert SetProduct(s) == x * SetProduct(s - {x});
      } else {
        var s' := s - {y};
        assert x in s';
        SetProductProperty(s', x);
        assert SetProduct(s) == y * SetProduct(s');
        assert SetProduct(s') == x * SetProduct(s' - {x});
        assert s' - {x} == s - {x, y};
        assert SetProduct(s) == y * x * SetProduct(s - {x, y});
      }
    } else {
      assert SetProduct(s + {x}) == x * SetProduct(s);
    }
  }
  
  lemma SetProductEmpty()
    ensures SetProduct({}) == 1
  {
  }

vc-spec: |-
  // <vc-spec>
  method UniqueProduct (arr: array<int>) returns (product: int)
     ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))
  // </vc-spec>

vc-code: |-
  method ComputeUniqueProduct(arr: array<int>) returns (product: int)
    ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))
  {
    var s := set i | 0 <= i < arr.Length :: arr[i];
    product := 1;
    var remaining := s;
    while remaining != {}
      invariant product * SetProduct(remaining) == SetProduct(s)
      decreases remaining
    {
      var x :| x in remaining;
      SetProductProperty(remaining, x);
      product := product * x;
      remaining := remaining - {x};
    }
    if s == {} {
      SetProductEmpty();
    }
  }

vc-postamble: |-


