vc-preamble: |-
  // The order of the recursion in these two functions
  // must match the order of the iteration in the algorithm above
  function Min(a: seq<int>) : int
      requires |a| > 0
  {
      if |a| == 1 then a[0]
      else
          var minPrefix := Min(a[..|a|-1]);
          if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])
  }
  
  function Max(a: seq<int>) : int
      requires |a| > 0
  {
      if |a| == 1 then a[0]
      else
          var maxPrefix := Max(a[..|a|-1]);
          if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])
  }

vc-helpers: |-
  lemma MinMaxProperties(a: seq<int>)
      requires |a| > 0
      ensures forall i :: 0 <= i < |a| ==> Min(a) <= a[i]
      ensures forall i :: 0 <= i < |a| ==> Max(a) >= a[i]
  {
      if |a| == 1 {
          assert Min(a) == a[0];
          assert Max(a) == a[0];
      } else {
          var prefix := a[..|a|-1];
          MinMaxProperties(prefix);
          assert Min(a) == if a[|a|-1] <= Min(prefix) then a[|a|-1] else Min(prefix);
          assert Max(a) == if a[|a|-1] >= Max(prefix) then a[|a|-1] else Max(prefix);
      }
  }
  
  lemma MinPrefix(a: seq<int>, i: int)
      requires 0 <= i <= |a|
      requires |a| > 0
      ensures |a[..i]| == i
      ensures i > 0 ==> Min(a[..i]) <= a[i-1]
  {
      if i == 0 {
      } else if i == 1 {
          assert a[..i] == [a[0]];
          assert Min(a[..i]) == a[0];
      } else {
          MinPrefix(a, i-1);
          if a[i-1] <= Min(a[..i-1]) {
              assert Min(a[..i]) == a[i-1];
          } else {
              assert Min(a[..i]) == Min(a[..i-1]);
          }
      }
  }
  
  lemma MaxPrefix(a: seq<int>, i: int)
      requires 0 <= i <= |a|
      requires |a| > 0
      ensures |a[..i]| == i
      ensures i > 0 ==> Max(a[..i]) >= a[i-1]
  {
      if i == 0 {
      } else if i == 1 {
          assert a[..i] == [a[0]];
          assert Max(a[..i]) == a[0];
      } else {
          MaxPrefix(a, i-1);
          if a[i-1] >= Max(a[..i-1]) {
              assert Max(a[..i]) == a[i-1];
          } else {
              assert Max(a[..i]) == Max(a[..i-1]);
          }
      }
  }

vc-spec: |-
  // <vc-spec>
  method SumMinMax(a: array<int>) returns (sum: int)
      requires a.Length > 0
      ensures sum == Max(a[..]) + Min(a[..])
  // </vc-spec>

vc-code: |-
  method ComputeSumMinMax(a: array<int>) returns (sum: int)
      requires a.Length > 0
      ensures sum == Max(a[..]) + Min(a[..])
  {
      var minVal := a[0];
      var maxVal := a[0];
      var i := 1;
      
      while i < a.Length
          invariant 0 <= i <= a.Length
          invariant minVal <= Max(a[..i])
          invariant minVal == Min(a[..i])
          invariant maxVal == Max(a[..i])
      {
          if a[i] < minVal {
              minVal := a[i];
          }
          if a[i] > maxVal {
              maxVal := a[i];
          }
          i := i + 1;
      }
      
      sum := minVal + maxVal;
  }

vc-postamble: |-


