vc-preamble: |-
  function Sum(v:array<int>,i:int,j:int):int
  reads v
  requires 0<=i<=j<=v.Length
  decreases j
  {
      if (i==j) then 0
      else Sum(v,i,j-1)+v[j-1]
  }
  
  predicate SumMaxToRight(v:array<int>,i:int,s:int)
  reads v
  requires 0<=i<v.Length
  {
  forall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s
  }
  
  function Sum2(v:array<int>,i:int,j:int):int
  reads v
  requires 0<=i<=j<=v.Length
  decreases j-i
  {
      if (i==j) then 0
      else v[i]+Sum2(v,i+1,j)
  }
  
  //Now do the same but with a loop from right to left
  predicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right
  reads v
  requires 0<=j<=i<v.Length
  {(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}

vc-helpers: |-
  lemma SumEquivalence(v: array<int>, i: int, j: int)
    requires 0 <= i <= j <= v.Length
    ensures Sum(v, i, j) == Sum2(v, i, j)
    decreases j - i
  {
    if i == j {
      assert Sum(v, i, j) == 0 == Sum2(v, i, j);
    } else {
      calc {
        Sum(v, i, j);
        == Sum(v, i, j-1) + v[j-1];
        == { SumEquivalence(v, i, j-1); }
        Sum2(v, i, j-1) + v[j-1];
        == Sum2(v, i, j);
      }
    }
  }
  
  lemma SumMaxToRightEquivalence(v: array<int>, i: int, j: int, s: int)
    requires 0 <= j <= i < v.Length
    ensures SumMaxToRight2(v, j, i, s) == SumMaxToRight(v, i, s)
  {
    assert SumMaxToRight2(v, j, i, s) == (forall l :: j <= l <= i ==> Sum2(v, l, i+1) <= s);
    assert SumMaxToRight(v, i, s) == (forall l :: 0 <= l <= i ==> Sum(v, l, i+1) <= s);
    if SumMaxToRight2(v, j, i, s) {
      forall l | 0 <= l <= i {
        if j <= l <= i {
          assert Sum2(v, l, i+1) <= s;
          SumEquivalence(v, l, i+1);
          assert Sum(v, l, i+1) <= s;
        } else {
          assert Sum(v, l, i+1) <= s || true;
        }
      }
    }
  }

vc-spec: |-
  // <vc-spec>
  method segMaxSum(v:array<int>,i:int) returns (s:int,k:int)
  requires v.Length>0 && 0<=i<v.Length
  ensures 0<=k<=i && s==Sum(v,k,i+1) &&  SumMaxToRight(v,i,s)
  // </vc-spec>

vc-code: |-
  method segMaxSumImpl(v: array<int>, i: int) returns (s: int, k: int)
    requires v.Length > 0 && 0 <= i < v.Length
    ensures 0 <= k <= i && s == Sum(v, k, i+1) && SumMaxToRight(v, i, s)
  {
    s := 0;
    k := i + 1;
    var currentSum := 0;
    var l := i;
    
    while l >= 0
      invariant 0 <= l <= i
      invariant k == l + 1 || (0 <= k <= i && s == Sum(v, k, i+1))
      invariant currentSum == Sum(v, l+1, i+1)
      invariant forall m :: l < m <= i ==> Sum(v, m, i+1) <= s
      invariant s >= currentSum
      decreases l
    {
      currentSum := currentSum + v[l];
      if currentSum > s {
        s := currentSum;
        k := l;
      }
      l := l - 1;
    }
    
    assert k <= i;
    if k == i + 1 {
      k := i;
      s := v[i];
    }
    // Ensure SumMaxToRight by proving that for all l in [0..i], Sum(v, l, i+1) <= s
    forall l | 0 <= l <= i {
      if l < k {
        assert Sum(v, l, i+1) <= s;
      } else if l == k {
        assert Sum(v, l, i+1) == s;
      } else {
        assert Sum(v, l, i+1) <= s;
      }
    }
  }

vc-postamble: |-


