vc-preamble: |-
  function suma_aux(V : array?<int>, n : int) : int
  
    // suma_aux(V, n) = V[n] + V[n + 1] + ... + V[N - 1]
  
    requires V != null            // P_0
    requires 0 <= n <= V.Length       // Q_0
  
    decreases V.Length - n        // C_0
  
    reads V
  
  {
  
    if (n == V.Length) then 0                     // Caso base:      n = N
                       else V[n] + suma_aux(V, n + 1)     // Caso recursivo: n < N
  
  }

vc-helpers: |-
  lemma suma_aux_correct(V: array?<int>, n: int)
    requires V != null
    requires 0 <= n <= V.Length
    ensures suma_aux(V, n) == sum_array_slice(V, n, V.Length)
    decreases V.Length - n
  {
    if n == V.Length {
      assert suma_aux(V, n) == 0;
      assert sum_array_slice(V, n, V.Length) == 0;
    } else {
      suma_aux_correct(V, n + 1);
      assert suma_aux(V, n) == V[n] + suma_aux(V, n + 1);
      assert sum_array_slice(V, n, V.Length) == V[n] + sum_array_slice(V, n + 1, V.Length);
    }
  }
  
  function sum_array_slice(V: array?<int>, start: int, end: int): int
    requires V != null
    requires 0 <= start <= end <= V.Length
    decreases end - start
    reads V
  {
    if start == end then 0
    else V[start] + sum_array_slice(V, start + 1, end)
  }

vc-spec: |-
  // <vc-spec>
  method suma_componentes(V : array?<int>) returns (suma : int)
  
    requires V != null
    ensures  suma == suma_aux(V, 0)   // x = V[0] + V[1] + ... + V[N - 1]
  // </vc-spec>

vc-code: |-
  {
    if V.Length == 0 {
      suma := 0;
    } else {
      suma := suma_aux(V, 0);
    }
  }

vc-postamble: |-


