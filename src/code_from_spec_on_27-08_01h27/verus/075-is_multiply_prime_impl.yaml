vc-description: |-


vc-preamble: |-
  use vstd::arithmetic::mul::*;
  use vstd::prelude::*;
  
  verus! {
  
  spec fn spec_prime(p: int) -> (ret:bool) {
      p > 1 && forall|k: int| 1 < k < p ==> #[trigger] (p % k) != 0
  }
  // pure-end

vc-helpers: |-
  fn prime(p: u32) -> (ret: bool)
      ensures
          ret <==> spec_prime(p as int),
  {
      if p <= 1 {
          return false;
      }
      for k in 2..p
          invariant
              forall|j: int| 1 < j < k ==> #[trigger] (p as int % j) != 0,
              k <= p,
      {
          if p % k == 0 {
              return false;
          }
      }
      true
  }
  
  fn checked_mul_thrice(x: u32, y: u32, z: u32) -> (ret: Option<u32>)
      ensures
          ret.is_some() ==> ret.unwrap() == x * y * z,
          ret.is_none() ==> x as int * y as int * z as int > u32::MAX as int,
  {
      if (x == 0 || y == 0 || z == 0) {
          return Some(0);
      }
      let prod2 = x.checked_mul(y);
      if prod2.is_some() {
          let prod3 = prod2.unwrap().checked_mul(z);
          if prod3.is_some() {
              Some(prod3.unwrap())
          } else {
              None
          }
      } else {
          None
      }
  }

vc-spec: |-
  fn is_multiply_prime(x: u32) -> (ans: bool)
      // pre-conditions-start
      requires
          x > 1,
      // pre-conditions-end
      // post-conditions-start
      ensures
          ans <==> exists|a: int, b: int, c: int|
              spec_prime(a) && spec_prime(b) && spec_prime(c) && x == a * b * c,
      // post-conditions-end

vc-code: |-
  {
      for a in 2..x
          invariant
              forall|a_val: int, b_val: int, c_val: int|
                  spec_prime(a_val) && spec_prime(b_val) && spec_prime(c_val) && 
                  2 <= a_val < a && x as int == a_val * b_val * c_val ==> false,
      {
          if prime(a) && x % a == 0 {
              let remaining = x / a;
              
              for b in 2..(remaining + 1)
                  invariant
                      spec_prime(a as int),
                      x % a == 0,
                      remaining == x / a,
                      a as int * remaining as int == x as int,
                      forall|b_val: int, c_val: int|
                          spec_prime(b_val) && spec_prime(c_val) && 
                          2 <= b_val < b && (remaining as int) == b_val * c_val ==> false,
              {
                  if b <= remaining && remaining % b == 0 && prime(b) {
                      let c = remaining / b;
                      if c >= 2 && prime(c) {
                          proof {
                              let a_int = a as int;
                              let b_int = b as int;
                              let c_int = c as int;
                              assert(b_int * c_int == remaining as int) by {
                                  assert(remaining % b == 0);
                                  assert(c == remaining / b);
                                  assert(c_int == remaining as int / b_int);
                                  assert(c_int * b_int == remaining as int);
                              };
                              assert(x as int == a_int * b_int * c_int) by {
                                  assert(a_int * (remaining as int) == x as int);
                                  assert(b_int * c_int == remaining as int);
                                  assert(a_int * (b_int * c_int) == x as int);
                              };
                          }
                          return true;
                      }
                  }
              }
          }
      }
      false
  }

vc-postamble: |-
  
  }
  fn main() {}

