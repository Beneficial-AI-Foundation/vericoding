vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {

vc-helpers: |-
  spec fn contains(str: &Vec<i32>, key: i32) -> bool
  {
      exists|i: int| 0 <= i < str.len() && str[i] == key
  }
  
  proof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)
      requires
          l == vec.len(),
      ensures
          forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],
          vec.push(i).index(l as int) == i,
  {
  }
  
  spec fn seq_contains<T>(seq: Seq<T>, elem: T) -> bool {
      exists|i: int| 0 <= i < seq.len() && seq[i] == elem
  }
  
  proof fn lemma_contains_equiv(arr: &Vec<i32>, elem: i32)
      ensures
          contains(arr, elem) <==> seq_contains(arr@, elem)
  {
  }
  
  proof fn lemma_push_maintains_contains(result: Vec<i32>, elem: i32, arr1: &Vec<i32>, arr2: &Vec<i32>)
      requires
          arr1@.contains(elem),
          !arr2@.contains(elem),
          forall|j: int| 0 <= j < result.len() ==> (arr1@.contains(result[j]) && !arr2@.contains(result[j])),
      ensures
          forall|j: int| 0 <= j < result@.push(elem).len() ==> (arr1@.contains(result@.push(elem)[j]) && !arr2@.contains(result@.push(elem)[j])),
  {
  }
  
  proof fn lemma_push_adds_element(result: Vec<i32>, elem: i32)
      ensures
          result@.push(elem).contains(elem)
  {
  }
  
  fn exec_contains(str: &Vec<i32>, key: i32) -> (result: bool)
      ensures
          result <==> contains(str, key),
  {
      let mut i = 0;
      while i < str.len()
          invariant
              forall|m: int| 0 <= m < i ==> (str[m] != key),
          decreases str.len() - i
      {
          if (str[i] == key) {
              return true;
          }
          i += 1;
      }
      false
  }

vc-spec: |-
  fn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)
      // post-conditions-start
      ensures
          forall|i: int|
              0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(
                  #[trigger] result[i],
              )),
          forall|i: int|
              0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(
                  #[trigger] arr1[i],
              )),
      // post-conditions-end

vc-code: |-
  {
      let mut result = Vec::new();
      let mut i = 0;
      
      while i < arr1.len()
          invariant
              0 <= i <= arr1.len(),
              forall|j: int| 0 <= j < result.len() ==> (arr1@.contains(#[trigger] result[j]) && !arr2@.contains(#[trigger] result[j])),
              forall|j: int| 0 <= j < i ==> (arr2@.contains(#[trigger] arr1[i as int]) || result@.contains(#[trigger] arr1[i as int])),
          decreases arr1.len() - i
      {
          let elem = arr1[i];
          if !exec_contains(arr2, elem) {
              let old_result = result;
              result.push(elem);
              proof {
                  lemma_contains_equiv(arr2, elem);
                  lemma_push_maintains_contains(old_result, elem, arr1, arr2);
                  lemma_push_adds_element(old_result, elem);
                  assert(forall|j: int| 0 <= j < (i + 1) ==> (arr2@.contains(arr1[j]) || result@.contains(arr1[j]))) by {
                      assert(forall|j: int| 0 <= j < i ==> (arr2@.contains(arr1[j]) || result@.contains(arr1[j])));
                      assert(result@.contains(elem));
                      assert(arr1[i as int] == elem);
                  };
              }
          } else {
              proof {
                  lemma_contains_equiv(arr2, elem);
                  assert(arr2@.contains(elem));
                  assert(arr1[i as int] == elem);
                  assert(forall|j: int| 0 <= j < (i + 1) ==> (arr2@.contains(arr1[j]) || result@.contains(arr1[j]))) by {
                      assert(forall|j: int| 0 <= j < i ==> (arr2@.contains(arr1[j]) || result@.contains(arr1[j])));
                      assert(arr2@.contains(arr1[i as int]));
                  };
              }
          }
          i += 1;
      }
      
      result
  }

vc-postamble: |-
  
  } // verus!
  
  fn main() {}

