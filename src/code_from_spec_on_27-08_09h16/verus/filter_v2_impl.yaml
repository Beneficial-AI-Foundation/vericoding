vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus!{

vc-helpers: |-
  proof fn lemma_seq_take_ascend<T>(v: Seq<T>, i: int)
      requires
          0 < i <= v.len(),
      ensures
          v.take(i as int).drop_last() == v.take(i-1),
  {
      assert(v.take(i as int).drop_last() =~= v.take(i-1));
  }
  
  proof fn lemma_seq_take_all<T>(v: Seq<T>)
      ensures
          v == v.take(v.len() as int),
  {
      assert(v =~= v.take(v.len() as int));
  }
  
  proof fn lemma_filter_push<T>(s: Seq<T>, elem: T, pred: spec_fn(T) -> bool)
      ensures
          s.push(elem).filter(pred) == if pred(elem) {
              s.filter(pred).push(elem)
          } else {
              s.filter(pred)
          }
  {
  }
  
  proof fn lemma_filter_take_extend<T>(s: Seq<T>, i: int, elem: T, pred: spec_fn(T) -> bool)
      requires
          0 <= i < s.len(),
          s[i] == elem,
      ensures
          s.take(i+1).filter(pred) == if pred(elem) {
              s.take(i).filter(pred).push(elem)
          } else {
              s.take(i).filter(pred)
          }
  {
      assert(s.take(i+1) == s.take(i).push(elem));
      lemma_filter_push(s.take(i), elem, pred);
  }

vc-spec: |-
  fn myfun4(x: &Vec<u64>, y: &mut Vec<u64>)
      // pre-conditions-start
      requires 
          old(y).len() == 0,
      // pre-conditions-end
      // post-conditions-start
      ensures 
          y@ == x@.filter(|k:u64| k%3 == 0),
      // post-conditions-end

vc-code: |-
  {
      let mut i = 0;
      while i < x.len()
          invariant
              i <= x.len(),
              y@ == x@.take(i as int).filter(|k:u64| k%3 == 0),
          decreases x.len() - i,
      {
          if x[i] % 3 == 0 {
              y.push(x[i]);
          }
          i = i + 1;
          proof {
              lemma_filter_take_extend(x@, (i-1) as int, x@[i-1], |k:u64| k%3 == 0);
          }
      }
      proof {
          lemma_seq_take_all(x@);
      }
  }

vc-postamble: |-
  
  }
  
  fn main() {}

