vc-description: |-


vc-preamble: |-
  use vstd::prelude::*;
  
  verus! {
  
  spec fn zip_halves<T>(v: Seq<T>) -> (ret: Seq<(T, T)>) {
      v.take((v.len() / 2) as int).zip_with(v.skip(((v.len() + 1) / 2) as int).reverse())
  }
  // pure-end
  // pure-end
  
  spec fn diff(s: Seq<(i32, i32)>) -> (ret: int) {
      s.fold_left(
          0,
          |acc: int, x: (i32, i32)|
              if (x.0 != x.1) {
                  acc + 1
              } else {
                  acc
              },
      )
  }
  // pure-end

vc-helpers: |-
  proof fn lemma_zip_halves_len<T>(v: Seq<T>)
      ensures zip_halves(v).len() == v.len() / 2
  {
  }
  
  proof fn lemma_zip_halves_index<T>(v: Seq<T>, i: int)
      requires 0 <= i < zip_halves(v).len()
      ensures zip_halves(v)[i] == (v[i], v[v.len() - 1 - i])
  {
  }
  
  proof fn lemma_fold_left_step(s: Seq<(i32, i32)>, acc: int, x: (i32, i32))
      ensures s.push(x).fold_left(acc, |acc: int, x: (i32, i32)| if (x.0 != x.1) { acc + 1 } else { acc }) == 
              if (x.0 != x.1) { s.fold_left(acc, |acc: int, x: (i32, i32)| if (x.0 != x.1) { acc + 1 } else { acc }) + 1 } 
              else { s.fold_left(acc, |acc: int, x: (i32, i32)| if (x.0 != x.1) { acc + 1 } else { acc }) }
  {
      let f = |acc: int, x: (i32, i32)| if (x.0 != x.1) { acc + 1 } else { acc };
      assert(s.push(x).fold_left(acc, f) == f(s.fold_left(acc, f), x));
  }
  
  proof fn lemma_diff_take_step(s: Seq<(i32, i32)>, i: int)
      requires 0 <= i < s.len()
      ensures diff(s.take(i + 1)) == if s[i].0 != s[i].1 { diff(s.take(i)) + 1 } else { diff(s.take(i)) }
  {
      let prefix = s.take(i);
      let elem = s[i];
      assert(s.take(i + 1) == prefix.push(elem));
      lemma_fold_left_step(prefix, 0, elem);
  }
  
  proof fn lemma_diff_nonnegative(s: Seq<(i32, i32)>)
      ensures diff(s) >= 0
  {
  }
  
  proof fn lemma_int_to_usize(n: int)
      requires 0 <= n < usize::MAX
      ensures n as usize == n
  {
  }

vc-spec: |-
  fn smallest_change(v: Vec<i32>) -> (change: usize)
      // pre-conditions-start
      requires
          v@.len() < usize::MAX,
      // pre-conditions-end
      // post-conditions-start
      ensures
          change == diff(zip_halves(v@)),
      // post-conditions-end

vc-code: |-
  {
      let len = v.len();
      let half = len / 2;
      let mut change = 0;
      let mut i = 0;
      
      while i < half
          invariant
              i <= half,
              half == len / 2,
              len == v@.len(),
              change == diff(zip_halves(v@).take(i as int)),
              change >= 0
          decreases half - i
      {
          let left_idx = i;
          let right_idx = len - 1 - i;
          
          proof {
              lemma_zip_halves_len(v@);
              lemma_zip_halves_index(v@, i as int);
              lemma_diff_take_step(zip_halves(v@), i as int);
          }
          
          if v[left_idx] != v[right_idx] {
              change = change + 1;
          }
          
          i += 1;
      }
      
      proof {
          lemma_zip_halves_len(v@);
          lemma_diff_nonnegative(zip_halves(v@));
          assert(zip_halves(v@).len() == half as int);
          assert(zip_halves(v@).take(half as int) == zip_halves(v@));
          assert(change < usize::MAX);
          lemma_int_to_usize(change as int);
      }
      
      change
  }

vc-postamble: |-
  
  }
  fn main() {}

