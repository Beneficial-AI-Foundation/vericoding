/-!
{
  "name": "numpy.testing.assert_array_compare",
  "category": "Assertion Functions",
  "description": "Asserts that comparison between two array_like objects is satisfied",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.testing.assert_array_compare.html",
  "doc": "Asserts that comparison between two array_like objects is satisfied.\n\nThe comparison is performed elementwise, and the objects are only considered equal if their shapes are the same, and the comparison returns True for all elements.",
  "code": "def assert_array_compare(comparison, x, y, err_msg='', verbose=True, header='',\n                         precision=6, equal_nan=True, equal_inf=True,\n                         *, strict=False):\n    __tracebackhide__ = True  # Hide traceback for py.test\n    from numpy._core import array2string, empty, float_, ndarray, ones\n    \n    x = np.asanyarray(x)\n    y = np.asanyarray(y)\n    \n    # original shapes for comparison\n    x_original_shape = x.shape\n    y_original_shape = y.shape\n    \n    def array_repr(a):\n        if a.shape == ():\n            return f\"array({a})\"\n        else:\n            return np.array2string(a, separator=\", \", prefix=\" \"*9,\n                                  threshold=30)\n\n    def func_assert_same_pos(x, y, func=isnan, hasval='nan'):\n        \"\"\"Handling nan/inf.\n\n        Combine results of running func on x and y, checking that they are True\n        at the same locations.\n        \"\"\"\n        __tracebackhide__ = True  # Hide traceback for py.test\n        \n        x_id = func(x)\n        y_id = func(y)\n        # We include work-arounds here to handle three types of slightly\n        # pathological ndarray subclasses:\n        # (1) all() on \`masked\` array scalars can return masked arrays, so we\n        #     use != True\n        # (2) __eq__ on some ndarray subclasses returns Python scalars\n        # (3) subclasses with bare-bones __array_function__ implementations may\n        #     not implement np.all(), so favor using the .all() method\n        # We are not committed to supporting such subclasses, but it's nice to\n        # support them if possible.\n        if x_id == y_id:\n            return True\n        \n        if hasattr(x_id, 'all'):\n            x_id = x_id.all()\n            y_id = y_id.all()\n        else:\n            x_id = np.all(x_id)\n            y_id = np.all(y_id)\n        \n        if (x_id == False) and (y_id == False):\n            return True\n        \n        msg = build_err_msg([x, y],\n                            err_msg + f'\\nx and y {hasval} location mismatch:',\n                            verbose=verbose, header=header,\n                            names=('x', 'y'), precision=precision)\n        raise AssertionError(msg)\n\n    # If the arrays are not the same shape, the comparison is False\n    if (x.shape != y.shape) and not strict:\n        # It is possible that the shapes do not match, but the comparison\n        # may still succeed, e.g. if broadcasting can make them the same.\n        # We do the comparison first, with a trap for RecursionError, because\n        # broadcasting does not always work as one might expect, e.g. if\n        # y.shape == (1, 1, ..., 1). If the comparison fails, we try to\n        # broadcast one against the other. If that fails, or the comparison\n        # still fails, then we re-raise the comparison failure.\n        if x.shape == () or y.shape == ():\n            xy_comparison = comparison(x, y)\n        else:\n            # Catch exceptions so we can do the comparison one element at a\n            # time.\n            #\n            # TODO: If a RecursionError is raised, we can fall back to\n            # looping.\n            try:\n                xy_comparison = comparison(x, y)\n            except Exception:\n                xy_comparison = False\n\n        if np.all(xy_comparison == False):\n            # Shapes do not match and the comparison failed, check if either\n            # can be broadcast.\n            try:\n                np.broadcast_shapes(x.shape, y.shape)\n            except ValueError:\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + f'\\n(shapes {x.shape}, '\n                                    + f'{y.shape} mismatch)',\n                                    verbose=verbose, header=header,\n                                    names=('x', 'y'), precision=precision)\n                raise AssertionError(msg) from None\n            \n            # They can be broadcast, but the comparison failed.\n            # Cast y to the shape of x for simplicity.\n            y = y * ones(x.shape, bool)\n            x_original_shape = x.shape\n            y_original_shape = y.shape\n            \n            # We need to pass the exception inside the context manager because\n            # it may raise other exceptions when its string representation is\n            # computed.\n            with _assert_no_warnings_context():\n                xy_comparison = comparison(x, y)\n            # If the comparison raises an exception, re-raise the original\n            # exception.\n            if np.any(xy_comparison == False):\n                msg = build_err_msg([x, y],\n                                    err_msg\n                                    + f'\\n(shapes {x_original_shape}, '\n                                    + f'{y_original_shape} mismatch)',\n                                    verbose=verbose, header=header,\n                                    names=('x', 'y'), precision=precision)\n                raise AssertionError(msg)\n\n        if np.all(xy_comparison != False):\n            # Comparison succeeded\n            return\n    \n    if strict:\n        # Ensure no broadcasting, shape and dtype must match exactly\n        if x_original_shape != y_original_shape:\n            msg = build_err_msg([x, y],\n                                err_msg\n                                + f'\\n(shapes {x_original_shape}, '\n                                + f'{y_original_shape} mismatch)',\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n\n        if x.dtype != y.dtype:\n            msg = build_err_msg([x, y],\n                                err_msg\n                                + f'\\n(dtypes {x.dtype}, {y.dtype} mismatch)',\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n            raise AssertionError(msg)\n\n    if not comparison(x, y).all():\n        if equal_nan:\n            func_assert_same_pos(x, y, func=isnan, hasval='nan')\n        if equal_inf:\n            func_assert_same_pos(x, y, func=lambda xy: xy == +inf,\n                                hasval='+inf')\n            func_assert_same_pos(x, y, func=lambda xy: xy == -inf,\n                                hasval='-inf')\n\n        mismatch = np.logical_not(comparison(x, y))\n        mismatch_flat = mismatch.ravel()\n        if mismatch_flat.ndim == 0:\n            mismatch_flat = mismatch_flat[None]\n        if np.all(mismatch_flat):\n            msg = build_err_msg([x, y],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        \n        n_mismatch = mismatch_flat.sum()\n        n_elements = mismatch_flat.size\n        if n_elements <= 10:\n            msg = build_err_msg([x, y],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        else:\n            msg = build_err_msg([x_mismatch, y_mismatch],\n                                err_msg,\n                                verbose=verbose, header=header,\n                                names=('x', 'y'), precision=precision)\n        raise AssertionError(msg)"
}
-/

-- TODO: Implement assert_array_compare
