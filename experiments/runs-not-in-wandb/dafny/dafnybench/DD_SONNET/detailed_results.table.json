{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero.dfy", "root", true, "", "", false, "verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero.dfy", "// <vc-preamble>\nfunction getSize(i: int, j:int) : int\n{\n    j - i + 1    \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestZero(a: array<int>) returns (sz:int, pos:int)   \n    requires 1 <= a.Length\n    ensures 0 <= sz <= a.Length\n    ensures 0 <= pos < a.Length\n    ensures pos + sz <= a.Length\n    ensures forall i:int  :: pos <= i < pos + sz ==> a[i] == 0\n    ensures forall i,j :: (0 <= i < j < a.Length && getSize(i, j) > sz) ==> exists k :: i <= k <= j && a[k] != 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function getSize(i: int, j:int) : int\n{\n    j - i + 1    \n}\n\n// For a given integer array, let's find the longest subesquence of 0s.\n// sz: size, pos: position.   a[pos..(pos+sz)] will be all zeros\n\n// <vc-helpers>\nlemma SizeProperties(i: int, j: int)\n    ensures getSize(i, j) == j - i + 1\n{\n}\n\nlemma MaximalityHelper(a: array<int>, start: int, end: int, maxSz: int, maxPos: int)\n    requires 0 <= start <= end < a.Length\n    requires 0 <= maxPos < a.Length\n    requires maxPos + maxSz <= a.Length\n    requires forall k :: start <= k <= end && a[k] == 0 ==> end - k + 1 <= maxSz\n    ensures forall i, j :: start <= i <= j <= end && getSize(i, j) > maxSz ==> exists k :: i <= k <= j && a[k] != 0\n{\n    forall i, j | start <= i <= j <= end && getSize(i, j) > maxSz\n        ensures exists k :: i <= k <= j && a[k] != 0\n    {\n        if forall k :: i <= k <= j ==> a[k] == 0 {\n            assert j - i + 1 == getSize(i, j) > maxSz;\n            assert a[j] == 0;\n            assert j - j + 1 <= maxSz;\n            assert 1 <= maxSz;\n            assert getSize(i, j) <= maxSz;\n        }\n    }\n}\n\nlemma ExtendMaximalityInvariant(a: array<int>, i: int, sz: int, currentStart: int, currentEnd: int)\n    requires 0 <= i <= a.Length\n    requires 0 <= currentStart <= currentEnd < a.Length\n    requires currentEnd < i\n    requires forall start, end :: 0 <= start <= end < currentStart && getSize(start, end) > sz ==> exists k :: start <= k <= end && a[k] != 0\n    requires forall k :: currentStart <= k <= currentEnd ==> a[k] == 0\n    requires getSize(currentStart, currentEnd) <= sz\n    ensures forall start, end :: 0 <= start <= end <= currentEnd && getSize(start, end) > sz ==> exists k :: start <= k <= end && a[k] != 0\n{\n    forall start, end | 0 <= start <= end <= currentEnd && getSize(start, end) > sz\n        ensures exists k :: start <= k <= end && a[k] != 0\n    {\n        if end < currentStart {\n            // Already covered by the precondition\n        } else if start >= currentStart {\n            // This segment overlaps with the current zero sequence\n            assert forall k :: currentStart <= k <= currentEnd ==> a[k] == 0;\n            assert start <= end <= currentEnd;\n            assert forall k :: start <= k <= end ==> a[k] == 0;\n            assert getSize(start, end) <= getSize(currentStart, currentEnd) <= sz;\n            assert getSize(start, end) <= sz;\n        } else {\n            // start < currentStart <= end\n            // The segment spans across the boundary\n            if forall k :: start <= k <= end ==> a[k] == 0 {\n                assert getSize(start, end) <= sz;\n            }\n        }\n    }\n}\n\nlemma ZeroSequenceExists(a: array<int>)\n    requires a.Length >= 1\n    ensures exists i :: 0 <= i < a.Length && (a[i] == 0 || true)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestZero(a: array<int>) returns (sz:int, pos:int)   \n    requires 1 <= a.Length\n    ensures 0 <= sz <= a.Length\n    ensures 0 <= pos < a.Length\n    ensures pos + sz <= a.Length\n    ensures forall i:int  :: pos <= i < pos + sz ==> a[i] == 0\n    ensures forall i,j :: (0 <= i < j < a.Length && getSize(i, j) > sz) ==> exists k :: i <= k <= j && a[k] != 0\n// </vc-spec>\n// <vc-code>\n{\n    sz := 1;\n    pos := 0;\n    \n    // Initialize based on first element\n    if a[0] == 0 {\n        sz := 1;\n        pos := 0;\n    } else {\n        // Find first zero or use element 0 with size 1\n        var found := false;\n        var j := 0;\n        while j < a.Length && !found\n            invariant 0 <= j <= a.Length\n            invariant !found ==> forall k :: 0 <= k < j ==> a[k] != 0\n        {\n            if a[j] == 0 {\n                found := true;\n                pos := j;\n                sz := 1;\n            } else {\n                j := j + 1;\n            }\n        }\n        if !found {\n            pos := 0;\n            sz := 1;\n        }\n    }\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant 1 <= sz <= a.Length\n        invariant 0 <= pos < a.Length\n        invariant pos + sz <= a.Length\n        invariant forall k :: pos <= k < pos + sz ==> a[k] == 0\n        invariant forall start, end :: 0 <= start <= end < i && getSize(start, end) > sz ==> exists k :: start <= k <= end && a[k] != 0\n    {\n        if a[i] == 0 {\n            var currentStart := i;\n            var currentSize := 0;\n            \n            while i < a.Length && a[i] == 0\n                invariant currentStart <= i <= a.Length\n                invariant currentSize == i - currentStart\n                invariant forall k :: currentStart <= k < i ==> a[k] == 0\n                invariant 0 <= currentStart < a.Length\n                invariant forall start, end :: 0 <= start <= end < currentStart && getSize(start, end) > sz ==> exists k :: start <= k <= end && a[k] != 0\n            {\n                currentSize := currentSize + 1;\n                i := i + 1;\n            }\n            \n            if currentSize > sz {\n                sz := currentSize;\n                pos := currentStart;\n            }\n            \n            // Prove maximality for all segments ending before current position\n            forall start, end | 0 <= start <= end < i && getSize(start, end) > sz\n                ensures exists k :: start <= k <= end && a[k] != 0\n            {\n                if end < currentStart {\n                    // Already established by loop invariant\n                } else {\n                    // The segment overlaps with our zero sequence\n                    if start >= currentStart {\n                        // Entirely within the zero sequence we just processed\n                        assert getSize(start, end) <= currentSize;\n                        assert currentSize <= sz;\n                        assert getSize(start, end) <= sz;\n                    } else {\n                        // Spans across the boundary\n                        assert start < currentStart;\n                        if i < a.Length {\n                            assert a[i] != 0;\n                            if end >= i {\n                                assert start <= i <= end && a[i] != 0;\n                            } else {\n                                assert end < i;\n                                assert end >= currentStart;\n                                assert start < currentStart <= end < i;\n                                var k := currentStart - 1;\n                                if k >= start && k >= 0 {\n                                    assert start <= k <= end;\n                                    assert k < currentStart;\n                                    assert a[k] != 0;\n                                }\n                            }\n                        } else {\n                            var k := currentStart - 1;\n                            if k >= start && k >= 0 {\n                                assert start <= k <= end;\n                                assert a[k] != 0;\n                            }\n                        }\n                    }\n                }\n            }\n        } else {\n            i := i + 1;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_70_AllSequencesEqualLength.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_70_AllSequencesEqualLength.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllSequencesEqualLength(sequences: seq<seq<int>>) returns (result: bool)\n    ensures result <==> forall i, j :: 0 <= i < |sequences| && 0 <= j < |sequences| ==> |sequences[i]| == |sequences[j]|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllSequencesEqualLength(sequences: seq<seq<int>>) returns (result: bool)\n    ensures result <==> forall i, j :: 0 <= i < |sequences| && 0 <= j < |sequences| ==> |sequences[i]| == |sequences[j]|\n// </vc-spec>\n// <vc-code>\n{\n  if |sequences| <= 1 {\n    return true;\n  }\n  \n  var firstLength := |sequences[0]|;\n  var i := 1;\n  \n  while i < |sequences|\n    invariant 1 <= i <= |sequences|\n    invariant forall k :: 0 <= k < i ==> |sequences[k]| == firstLength\n  {\n    if |sequences[i]| != firstLength {\n      return false;\n    }\n    i := i + 1;\n  }\n  \n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-duck_tmp_tmplawbgxjo_p4_single.dfy", "root", true, "", "", false, "dafny-duck_tmp_tmplawbgxjo_p4_single.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod single(x:array<int>, y:array<int>) returns (b:array<int>) \nrequires x.Length > 0\nrequires y.Length > 0\nensures b[..] == x[..] + y[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Given two arrays of integers, it returns a single array with all integers merged. \n// [1,5,2,3],[4,3,5]->[1,5,2,3,4,3,5]\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod single(x:array<int>, y:array<int>) returns (b:array<int>) \nrequires x.Length > 0\nrequires y.Length > 0\n// ensuring that the new array is the two arrays joined\nensures b[..] == x[..] + y[..]\n// </vc-spec>\n// <vc-code>\n{\n  b := new int[x.Length + y.Length];\n  \n  var i := 0;\n  while i < x.Length\n    invariant 0 <= i <= x.Length\n    invariant b[..i] == x[..i]\n  {\n    b[i] := x[i];\n    i := i + 1;\n  }\n  \n  var j := 0;\n  while j < y.Length\n    invariant 0 <= j <= y.Length\n    invariant i == x.Length\n    invariant b[..i] == x[..]\n    invariant b[i..i+j] == y[..j]\n  {\n    b[i + j] := y[j];\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum.dfy", "// <vc-preamble>\npredicate isPeek(v:array<int>,i:int)\n reads v\n requires 0<=i<v.Length\n {forall k::0<=k<i ==> v[i]>=v[k]}\n\n function peekSum(v:array<int>,i:int):int\n decreases i \n reads v\n requires 0<=i<=v.Length\n {\n  if (i==0) then 0\n  else if isPeek(v,i-1) then v[i-1]+peekSum(v,i-1)\n  else peekSum(v,i-1)\n }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mPeekSum(v:array<int>) returns (sum:int)\n requires  v.Length>0\n ensures sum==peekSum(v,v.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isPeek(v:array<int>,i:int)\n reads v\n requires 0<=i<v.Length\n {forall k::0<=k<i ==> v[i]>=v[k]}\n\n function peekSum(v:array<int>,i:int):int\n decreases i \n reads v\n requires 0<=i<=v.Length\n {\n  if (i==0) then 0\n  else if isPeek(v,i-1) then v[i-1]+peekSum(v,i-1)\n  else peekSum(v,i-1)\n }\n\n// <vc-helpers>\nfunction maxUpTo(v: array<int>, i: int): int\n    reads v\n    requires 0 < i <= v.Length\n{\n    if i == 1 then v[0]\n    else if v[i-1] >= maxUpTo(v, i-1) then v[i-1]\n    else maxUpTo(v, i-1)\n}\n\nlemma maxUpToProperty(v: array<int>, i: int)\n    requires 0 < i <= v.Length\n    ensures forall k :: 0 <= k < i ==> v[k] <= maxUpTo(v, i)\n    ensures exists k :: 0 <= k < i && v[k] == maxUpTo(v, i)\n{\n    if i == 1 {\n        // Base case\n    } else {\n        maxUpToProperty(v, i-1);\n    }\n}\n\nlemma isPeekEquivalence(v: array<int>, i: int, maxVal: int)\n    requires 0 <= i < v.Length\n    requires i == 0 ==> maxVal == v[0]\n    requires i > 0 ==> (forall k :: 0 <= k < i ==> v[k] <= maxVal)\n    requires i > 0 ==> (exists k :: 0 <= k < i && v[k] == maxVal)\n    ensures isPeek(v, i) <==> v[i] >= maxVal\n{\n    if i == 0 {\n        // Base case: isPeek(v, 0) is always true (forall k::0<=k<0 is vacuously true)\n        // and maxVal == v[0], so v[0] >= maxVal is v[0] >= v[0] which is true\n        assert isPeek(v, 0);\n        assert v[0] >= v[0];\n    } else {\n        // For i > 0, isPeek(v, i) means v[i] >= v[k] for all k in [0, i)\n        // Since maxVal is the maximum of v[0..i), this is equivalent to v[i] >= maxVal\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mPeekSum(v:array<int>) returns (sum:int)\n requires  v.Length>0\n ensures sum==peekSum(v,v.Length)\n //Implement and verify an O(v.Length) algorithm to solve this problem\n// </vc-spec>\n// <vc-code>\n{\n    sum := 0;\n    var i := 0;\n    var maxVal := v[0];\n    \n    while i < v.Length\n        invariant 0 <= i <= v.Length\n        invariant sum == peekSum(v, i)\n        invariant i > 0 ==> (forall k :: 0 <= k < i ==> v[k] <= maxVal)\n        invariant i > 0 ==> (exists k :: 0 <= k < i && v[k] == maxVal)\n        invariant i == 0 ==> maxVal == v[0]\n    {\n        if i == 0 || v[i] >= maxVal {\n            isPeekEquivalence(v, i, maxVal);\n            sum := sum + v[i];\n        } else {\n            isPeekEquivalence(v, i, maxVal);\n        }\n        \n        if i == 0 || v[i] >= maxVal {\n            maxVal := v[i];\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence.dfy", "root", true, "", "", false, "AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence.dfy", "// <vc-preamble>\nghost predicate ExistsSubstring(str1: string, str2: string) {\n\n    exists offset :: 0 <= offset <= |str1| && str2 <= str1[offset..]\n}\n\nghost predicate Post(str1: string, str2: string, found: bool, i: nat) {\n    (found <==> ExistsSubstring(str1, str2)) &&\n    (found ==> i + |str2| <= |str1| && str2 <= str1[i..])\n}\n\nghost predicate Outter_Inv_correctness(str1: string, str2: string, found: bool, i : nat)\n{\n    (found ==> (i + |str2| <= |str1| && str2 <= str1[i..]))\n    &&\n    (!found &&  0 < i <= |str1| && i != |str2|-1 ==> !(ExistsSubstring(str1[..i], str2)))\n    &&\n    (!found ==> i <= |str1|)\n}\n\nghost predicate Inner_Inv_correctness(str1: string, str2: string, i : nat, j: int, found: bool){\n    0 <= j <= i &&\n    j < |str2| &&\n    i < |str1| &&\n    (str1[i] == str2[j] ==> str2[j..] <= str1[i..]) &&\n    (found ==> j==0 && str1[i] == str2[j])\n}\n\nghost predicate Inner_Inv_Termination(str1: string, str2: string, i : nat, j: int, old_i: nat, old_j: nat){\n    old_j - j == old_i - i\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOccurrence(str1: string, str2: string) returns (found: bool, i: nat)\n    ensures Post(str1, str2, found, i)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\nghost predicate ExistsSubstring(str1: string, str2: string) {\n    // string in Dafny is a sequence of characters (seq<char>) and <= on sequences is the prefix relation\n    exists offset :: 0 <= offset <= |str1| && str2 <= str1[offset..]\n}\n\nghost predicate Post(str1: string, str2: string, found: bool, i: nat) {\n    (found <==> ExistsSubstring(str1, str2)) &&\n    (found ==> i + |str2| <= |str1| && str2 <= str1[i..])\n}\n\n/*\nGoal: Verify correctness of the following code. Once done, remove the {:verify false} (or turn it into {:verify true}).\n\nFeel free to add GHOST code, including calls to lemmas. But DO NOT modify the specification or the original (executable) code.\n*/\n\n//this is our lemmas, invatiants and presicats\n\n\nghost predicate Outter_Inv_correctness(str1: string, str2: string, found: bool, i : nat)\n{\n    (found ==> (i + |str2| <= |str1| && str2 <= str1[i..])) // Second part of post condition\n    &&\n    (!found &&  0 < i <= |str1| && i != |str2|-1 ==> !(ExistsSubstring(str1[..i], str2))) // First part of post condition\n    &&\n    (!found ==> i <= |str1|)\n}\n\nghost predicate Inner_Inv_correctness(str1: string, str2: string, i : nat, j: int, found: bool){\n    0 <= j <= i && // index in range\n    j < |str2| && // index in range\n    i < |str1| &&// index in range\n    (str1[i] == str2[j] ==> str2[j..] <= str1[i..]) &&\n    (found ==> j==0 && str1[i] == str2[j])\n}\n\nghost predicate Inner_Inv_Termination(str1: string, str2: string, i : nat, j: int, old_i: nat, old_j: nat){\n    old_j - j == old_i - i\n}\n\n// <vc-helpers>\nlemma ExistsSubstringAtOffset(str1: string, str2: string, offset: nat)\n    requires 0 <= offset <= |str1|\n    requires str2 <= str1[offset..]\n    ensures ExistsSubstring(str1, str2)\n{\n    // The witness for ExistsSubstring is offset\n}\n\nlemma NoSubstringPrefix(str1: string, str2: string, prefix_len: nat)\n    requires 0 < prefix_len <= |str1|\n    requires |str2| > 0\n    requires forall k :: 0 <= k < prefix_len ==> !(str2 <= str1[k..])\n    ensures !ExistsSubstring(str1[..prefix_len], str2)\n{\n    if ExistsSubstring(str1[..prefix_len], str2) {\n        var offset :| 0 <= offset <= |str1[..prefix_len]| && str2 <= str1[..prefix_len][offset..];\n        assert offset < prefix_len;\n        assert str1[..prefix_len][offset..] == str1[offset..prefix_len];\n        assert str2 <= str1[offset..];\n        assert false;\n    }\n}\n\nlemma PrefixProperty(str1: string, str2: string, i: nat)\n    requires i <= |str1|\n    requires !ExistsSubstring(str1[..i], str2)\n    requires |str2| > 0\n    ensures forall k :: 0 <= k < i ==> !(str2 <= str1[k..])\n{\n    forall k | 0 <= k < i\n        ensures !(str2 <= str1[k..])\n    {\n        if str2 <= str1[k..] {\n            assert str1[..i][k..] == str1[k..i];\n            assert str2 <= str1[k..i];\n            assert ExistsSubstring(str1[..i], str2);\n            assert false;\n        }\n    }\n}\n\nlemma StrMatchComplete(str1: string, str2: string, i: nat)\n    requires i + |str2| <= |str1|\n    requires forall k :: 0 <= k < |str2| ==> str1[i + k] == str2[k]\n    ensures str2 <= str1[i..]\n{\n    // When all characters match, we have a substring match\n}\n\nlemma NoSubstringImpliesNoExists(str1: string, str2: string, i: nat)\n    requires |str2| > 0\n    requires i > |str1| - |str2|\n    requires forall k :: 0 <= k < i ==> !(str2 <= str1[k..])\n    ensures !ExistsSubstring(str1, str2)\n{\n    if ExistsSubstring(str1, str2) {\n        var offset :| 0 <= offset <= |str1| && str2 <= str1[offset..];\n        if offset < i {\n            assert str2 <= str1[offset..];\n            assert !(str2 <= str1[offset..]);\n            assert false;\n        } else {\n            assert i <= offset <= |str1|;\n            assert str2 <= str1[offset..];\n            assert |str2| <= |str1[offset..]| == |str1| - offset <= |str1| - i;\n            assert |str2| <= |str1| - i < |str2|;\n            assert false;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOccurrence(str1: string, str2: string) returns (found: bool, i: nat)\n    ensures Post(str1, str2, found, i)\n// </vc-spec>\n// <vc-code>\n{\n    if |str2| == 0 {\n        return true, 0;\n    }\n    \n    if |str1| < |str2| {\n        return false, 0;\n    }\n    \n    found := false;\n    i := 0;\n    \n    while i <= |str1| - |str2| && !found\n        invariant 0 <= i <= |str1| - |str2| + 1\n        invariant found ==> (i + |str2| <= |str1| && str2 <= str1[i..])\n        invariant !found ==> forall k :: 0 <= k < i ==> !(str2 <= str1[k..])\n        decreases |str1| - |str2| + 1 - i\n    {\n        var j := 0;\n        var isMatch := true;\n        \n        while j < |str2| && isMatch\n            invariant 0 <= j <= |str2|\n            invariant isMatch ==> (i + j <= |str1| && forall k :: 0 <= k < j ==> str1[i + k] == str2[k])\n            invariant !isMatch ==> (i + j > |str1| || exists k :: 0 <= k < j && str1[i + k] != str2[k])\n            decreases |str2| - j\n        {\n            if i + j >= |str1| {\n                isMatch := false;\n            } else if str1[i + j] != str2[j] {\n                isMatch := false;\n            } else {\n                j := j + 1;\n            }\n        }\n        \n        if isMatch && j == |str2| {\n            found := true;\n            StrMatchComplete(str1, str2, i);\n            ExistsSubstringAtOffset(str1, str2, i);\n        } else {\n            i := i + 1;\n        }\n    }\n    \n    if !found {\n        NoSubstringImpliesNoExists(str1, str2, i);\n        i := 0;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative.dfy", "// <vc-preamble>\npredicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n\n// <vc-helpers>\nlemma positive_prefix_property(s: seq<int>, i: int)\n  requires 0 <= i <= |s|\n  requires forall k :: 0 <= k < i ==> s[k] >= 0\n  ensures positive(s[0..i])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant positive(v[0..i])\n  {\n    if v[i] < 0 {\n      b := true;\n      return;\n    }\n    i := i + 1;\n  }\n  b := false;\n  i := 0;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_567_IsSorted.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_567_IsSorted.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSorted(a: array<int>) returns (sorted: bool)\n    requires a.Length > 0\n    ensures sorted <== forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures !sorted ==> exists i, j :: 0 <= i < j < a.Length && a[i] > a[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSorted(a: array<int>) returns (sorted: bool)\n    requires a.Length > 0\n    ensures sorted <== forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures !sorted ==> exists i, j :: 0 <= i < j < a.Length && a[i] > a[j]\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    while i < a.Length - 1\n        invariant 0 <= i <= a.Length - 1\n        invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n    {\n        if a[i] > a[i + 1] {\n            sorted := false;\n            return;\n        }\n        i := i + 1;\n    }\n    sorted := true;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_ReverseString_yarra.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_ReverseString_yarra.dfy", "// <vc-preamble>\npredicate reversed (arr : array<char>, outarr: array<char>)\nrequires arr != null && outarr != null\nrequires arr.Length == outarr.Length\nreads arr, outarr\n{\n  forall k :: 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod yarra(arr : array<char>) returns (outarr : array<char>)\nrequires arr != null && arr.Length > 0\nensures outarr != null && arr.Length == outarr.Length && reversed(arr,outarr)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Remove_Element_remove_element_remove_element.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Remove_Element_remove_element_remove_element.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod remove_element(nums: array<int>, val: int) returns (i: int)\n    modifies nums\n    requires 0 <= nums.Length <= 100\n    requires forall i :: 0 <= i < nums.Length ==> 0 <= nums[i] <= 50\n    requires 0 <= val <= 100\n    ensures forall j :: 0 < j < i < nums.Length ==> nums[j] != val\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_470_PairwiseAddition.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_470_PairwiseAddition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PairwiseAddition(a: array<int>) returns (result: array<int>)\n    requires a != null\n    requires a.Length % 2 == 0\n    ensures result != null\n    ensures result.Length == a.Length / 2\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[2*i] + a[2*i + 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod PairwiseAddition(a: array<int>) returns (result: array<int>)\n    requires a != null\n    requires a.Length % 2 == 0\n    ensures result != null\n    ensures result.Length == a.Length / 2\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[2*i] + a[2*i + 1]\n// </vc-spec>\n// <vc-code>\n{\n    var n := a.Length / 2;\n    result := new int[n];\n    \n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall j :: 0 <= j < i ==> result[j] == a[2*j] + a[2*j + 1]\n    {\n        result[i] := a[2*i] + a[2*i + 1];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_copy_part_copy.dfy", "root", true, "", "", false, "Clover_copy_part_copy.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod copy( src: array<int>, sStart: nat, dest: array<int>, dStart: nat, len: nat) returns (r: array<int>)\n  requires src.Length >= sStart + len\n  requires dest.Length >= dStart + len\n  ensures r.Length == dest.Length\n  ensures r[..dStart] == dest[..dStart]\n  ensures r[dStart + len..] == dest[dStart + len..]\n  ensures r[dStart..len+dStart] == src[sStart..len+sStart]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod copy( src: array<int>, sStart: nat, dest: array<int>, dStart: nat, len: nat) returns (r: array<int>)\n  requires src.Length >= sStart + len\n  requires dest.Length >= dStart + len\n  ensures r.Length == dest.Length\n  ensures r[..dStart] == dest[..dStart]\n  ensures r[dStart + len..] == dest[dStart + len..]\n  ensures r[dStart..len+dStart] == src[sStart..len+sStart]\n// </vc-spec>\n// <vc-code>\n{\n  r := new int[dest.Length];\n  \n  var i := 0;\n  while i < dest.Length\n    invariant 0 <= i <= dest.Length\n    invariant r[..i] == dest[..i]\n  {\n    r[i] := dest[i];\n    i := i + 1;\n  }\n  \n  i := 0;\n  while i < len\n    invariant 0 <= i <= len\n    invariant r[..dStart] == dest[..dStart]\n    invariant r[dStart..dStart+i] == src[sStart..sStart+i]\n    invariant r[dStart+i..] == dest[dStart+i..]\n  {\n    r[dStart + i] := src[sStart + i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["BinaryAddition_ArrayToSequence.dfy", "root", true, "", "", false, "BinaryAddition_ArrayToSequence.dfy", "// <vc-preamble>\nfunction ArrayToBv10(arr: array<bool>): bv10\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>)\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \nMIPS 0\nWe implement the following with bitvectors in Dafny.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\nfunction ArrayToBv10(arr: array<bool>): bv10 // Converts boolean array to bitvector\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n    ensures forall i :: 0 <= i < index ==> ((ArrayToBv10Helper(arr, i) >> i) & 1) == (if arr\n        [i] then 1 else 0)\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction Bv10ToSeq(x: bv10): seq<bool> // Converts bitvector to boolean sequence\n    ensures |Bv10ToSeq(x)| == 10\n    ensures forall i: nat :: 0 <= i < 10 ==> Bv10ToSeq(x)[i] == isBitSet(x, i)\n{\n    [isBitSet(x, 0), isBitSet(x, 1), isBitSet(x, 2), isBitSet(x, 3),\n    isBitSet(x, 4), isBitSet(x, 5), isBitSet(x, 6), isBitSet(x, 7),\n    isBitSet(x, 8), isBitSet(x, 9)]\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}\n\nfunction BitAddition(s: array<bool>, t: array<bool>): seq<bool> // Performs traditional bit addition\n    reads s\n    reads t\n    requires s.Length == 10 && t.Length == 10\n{\n    var a: bv10 := ArrayToBv10(s);\n    var b: bv10 := ArrayToBv10(t);\n    var c: bv10 := a + b;\n    Bv10ToSeq(c)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>) // Converts boolean array to boolean sequence\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n// </vc-spec>\n// <vc-code>\n{\n    res := [];\n    var i := 0;\n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant |res| == i\n        invariant forall k :: 0 <= k < i ==> res[k] == arr[k]\n    {\n        res := res + [arr[i]];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns.dfy", "root", true, "", "", false, "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns.dfy", "// <vc-preamble>\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod HoareTripleReqEns(i: int, k: int) returns (k': int)\n\n    requires  k == i*i\n    ensures  k' == (i+1)*(i+1)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat p\u00e2n\u0103 acum)\n        adnot\u0103ri care s\u0103 ajute \u00een procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod HoareTripleReqEns(i: int, k: int) returns (k': int)\n    // (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)\n    requires  k == i*i\n    ensures  k' == (i+1)*(i+1)\n// </vc-spec>\n// <vc-code>\n{\n  k' := k + 2 * i + 1;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr.dfy", "root", true, "", "", false, "Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr.dfy", "// <vc-preamble>\nfunction gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod exp_by_sqr(x0: real, n0: nat) returns (r:real)\nrequires x0 >= 0.0;\nensures r == exp(x0, n0);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }\n\n// <vc-helpers>\nlemma exp_by_sqr_lemma(x: real, n: nat)\nrequires x >= 0.0\nensures n % 2 == 0 ==> exp(x, n) == exp(x * x, n / 2)\nensures n % 2 == 1 ==> exp(x, n) == x * exp(x * x, n / 2)\ndecreases n\n{\n    if n == 0 {\n        assert exp(x, 0) == 1.0;\n        assert exp(x * x, 0) == 1.0;\n    } else if n == 1 {\n        assert exp(x, 1) == x * exp(x, 0) == x * 1.0 == x;\n        assert x * exp(x * x, 0) == x * 1.0 == x;\n    } else if n % 2 == 0 {\n        var half := n / 2;\n        assert n == 2 * half;\n        exp_by_sqr_lemma(x, 2 * half - 1);\n        exp_by_sqr_lemma(x, 2 * half - 2);\n        assert exp(x, n) == exp(x, 2 * half);\n        calc {\n            exp(x, 2 * half);\n            == x * exp(x, 2 * half - 1);\n            == x * x * exp(x, 2 * half - 2);\n        }\n        exp_by_sqr_lemma(x * x, half - 1);\n    } else {\n        var half := n / 2;\n        assert n == 2 * half + 1;\n        exp_by_sqr_lemma(x, 2 * half);\n        calc {\n            exp(x, n);\n            == exp(x, 2 * half + 1);\n            == x * exp(x, 2 * half);\n        }\n        exp_by_sqr_lemma(x * x, half);\n    }\n}\n\nlemma exp_odd_case(x: real, n: nat)\nrequires x >= 0.0 && n % 2 == 1\nensures exp(x, n) == x * exp(x, n - 1)\n{\n    if n > 0 {\n        assert exp(x, n) == x * exp(x, n - 1);\n    }\n}\n\nlemma exp_even_case(x: real, n: nat)\nrequires x >= 0.0 && n % 2 == 0 && n > 0\nensures exp(x, n) == exp(x * x, n / 2)\n{\n    exp_by_sqr_lemma(x, n);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod exp_by_sqr(x0: real, n0: nat) returns (r:real)\nrequires x0 >= 0.0;\nensures r == exp(x0, n0);\n// </vc-spec>\n// <vc-code>\n{\n    var x := x0;\n    var n := n0;\n    r := 1.0;\n    \n    while n > 0\n    invariant x >= 0.0\n    invariant r * exp(x, n) == exp(x0, n0)\n    decreases n\n    {\n        if n % 2 == 1 {\n            exp_odd_case(x, n);\n            r := r * x;\n            n := n - 1;\n        } else {\n            exp_even_case(x, n);\n            x := x * x;\n            n := n / 2;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring.dfy", "root", true, "", "", false, "formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring.dfy", "// <vc-preamble>\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n    // ensures  !res ==> !isSubstringPred(sub, str)\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\nlemma isNotPrefixEquivalence(pre: string, str: string)\n    ensures isNotPrefixPred(pre, str) <==> !isPrefixPred(pre, str)\n{\n}\n\nlemma isNotSubstringEquivalence(sub: string, str: string)\n    ensures isNotSubstringPred(sub, str) <==> !isSubstringPred(sub, str)\n{\n}\n\nlemma haveNotCommonKSubstringEquivalence(k: nat, str1: string, str2: string)\n    ensures haveNotCommonKSubstringPred(k, str1, str2) <==> !haveCommonKSubstringPred(k, str1, str2)\n{\n}\n\nlemma loopInvariantHelper(k: nat, str1: string, str2: string, i: int)\n    requires 0 <= i <= |str1| - k\n    requires i + k <= |str1|\n    requires forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 < i && i1 + k <= |str1| ==> isNotSubstringPred(str1[i1..i1+k], str2)\n    requires isNotSubstringPred(str1[i..i+k], str2)\n    ensures forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 < i + 1 && i1 + k <= |str1| ==> isNotSubstringPred(str1[i1..i1+k], str2)\n{\n    forall i1 | 0 <= i1 < i + 1 && i1 + k <= |str1|\n        ensures isNotSubstringPred(str1[i1..i1+k], str2)\n    {\n        if i1 < i {\n            assert isNotSubstringPred(str1[i1..i1+k], str2);\n        } else {\n            assert i1 == i;\n            assert isNotSubstringPred(str1[i..i+k], str2);\n        }\n    }\n}\n\nlemma completeSearchLemma(k: nat, str1: string, str2: string, i: int)\n    requires |str1| >= k\n    requires i > |str1| - k\n    requires forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 < i && i1 + k <= |str1| ==> isNotSubstringPred(str1[i1..i1+k], str2)\n    ensures forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 <= |str1| - k ==> isNotSubstringPred(str1[i1..i1+k], str2)\n{\n    forall i1 | 0 <= i1 <= |str1| - k\n        ensures isNotSubstringPred(str1[i1..i1+k], str2)\n    {\n        assert i1 < i;\n        assert i1 + k <= |str1|;\n        assert isNotSubstringPred(str1[i1..i1+k], str2);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>\n// <vc-code>\n{\n    if |str1| < k {\n        found := false;\n        haveNotCommonKSubstringEquivalence(k, str1, str2);\n        return;\n    }\n    \n    var i := 0;\n    found := false;\n    \n    while i <= |str1| - k && !found\n        invariant 0 <= i <= |str1| - k + 1\n        invariant !found ==> forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 < i && i1 + k <= |str1| ==> isNotSubstringPred(str1[i1..i1+k], str2)\n        invariant found ==> haveCommonKSubstringPred(k, str1, str2)\n        decreases |str1| - k - i + 1\n    {\n        var substring := str1[i..i+k];\n        var isSubstr := isSubstring(substring, str2);\n        \n        if isSubstr {\n            found := true;\n            assert isSubstringPred(str1[i..i+k], str2);\n            assert haveCommonKSubstringPred(k, str1, str2);\n        } else {\n            assert isNotSubstringPred(str1[i..i+k], str2);\n            assert 0 <= i <= |str1| - k;\n            assert i + k <= |str1|;\n            loopInvariantHelper(k, str1, str2, i);\n            i := i + 1;\n        }\n    }\n    \n    if !found {\n        assert i > |str1| - k;\n        completeSearchLemma(k, str1, str2, i);\n        assert forall i1 {:trigger str1[i1..i1+k]} :: 0 <= i1 <= |str1| - k ==> isNotSubstringPred(str1[i1..i1+k], str2);\n        assert haveNotCommonKSubstringPred(k, str1, str2);\n    }\n    \n    haveNotCommonKSubstringEquivalence(k, str1, str2);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_all_digits_allDigits.dfy", "root", true, "", "", false, "Clover_all_digits_allDigits.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n// </vc-spec>\n// <vc-code>\n{\n  result := true;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant result <==> (forall j :: 0 <= j < i ==> s[j] in \"0123456789\")\n  {\n    if s[i] !in \"0123456789\" {\n      result := false;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix.dfy", "root", true, "", "", false, "DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestPrefix(a: array<int>, b: array <int>) returns (i: nat) \n ensures i <= a.Length && i <= b.Length\n ensures a[..i] == b[..i]\n ensures i < a.Length && i < b.Length ==> a[i] != b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// MFES, Exam 8/Sept/20201, Exercise 5 \n\n// Computes the length (i) of the longest common prefix (initial subarray) \n// of two arrays a and b.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestPrefix(a: array<int>, b: array <int>) returns (i: nat) \n ensures i <= a.Length && i <= b.Length\n ensures a[..i] == b[..i]\n ensures i < a.Length && i < b.Length ==> a[i] != b[i]\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  while i < a.Length && i < b.Length && a[i] == b[i]\n    invariant 0 <= i <= a.Length && i <= b.Length\n    invariant a[..i] == b[..i]\n  {\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n// Test method with an example.", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort.dfy", "// <vc-preamble>\npredicate sorted_seg(a:array<int>, i:int, j:int)\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSort(a:array<int>, c:int, f:int)\nmodifies a \nrequires 0 <= c <= f <= a.Length\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted_seg(a:array<int>, i:int, j:int) //j excluded\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n\n// <vc-helpers>\nlemma sorted_seg_extension(a: array<int>, i: int, j: int, k: int)\nrequires 0 <= i <= j <= k <= a.Length\nrequires sorted_seg(a, i, j)\nrequires sorted_seg(a, j, k)\nrequires j > i && k > j ==> a[j-1] <= a[j]\nensures sorted_seg(a, i, k)\n{\n  if i == j || j == k { return; }\n  \n  forall l, m | i <= l <= m < k\n  ensures a[l] <= a[m]\n  {\n    if l < j && m < j {\n      assert a[l] <= a[m]; // from sorted_seg(a, i, j)\n    } else if l >= j && m >= j {\n      assert a[l] <= a[m]; // from sorted_seg(a, j, k)\n    } else {\n      assert l < j <= m;\n      assert a[l] <= a[j-1]; // from sorted_seg(a, i, j)\n      assert a[j-1] <= a[j]; // from precondition\n      assert a[j] <= a[m]; // from sorted_seg(a, j, k)\n    }\n  }\n}\n\nlemma sorted_seg_base_case(a: array<int>, c: int)\nrequires 0 <= c <= a.Length\nensures sorted_seg(a, c, c)\n{\n}\n\nlemma sorted_seg_single_element(a: array<int>, c: int)\nrequires 0 <= c < a.Length\nensures sorted_seg(a, c, c + 1)\n{\n}\n\nlemma establish_sorted_after_bubble(a: array<int>, c: int, i: int, f: int)\nrequires 0 <= c <= i < f <= a.Length\nrequires sorted_seg(a, c, i)\nrequires forall k :: i < k < f ==> a[i] <= a[k]\nensures sorted_seg(a, c, i + 1)\n{\n  forall l, m | c <= l <= m < i + 1\n  ensures a[l] <= a[m]\n  {\n    if m < i {\n      assert sorted_seg(a, c, i);\n      assert a[l] <= a[m];\n    } else {\n      assert m == i;\n      if l < i {\n        assert sorted_seg(a, c, i);\n        assert a[l] <= a[i-1];\n        if i+1 < f {\n          assert a[i] <= a[i+1];\n        }\n      } else {\n        assert l == i == m;\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSort(a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n  if c >= f { \n    sorted_seg_base_case(a, c);\n    return; \n  }\n  \n  if c == f - 1 {\n    sorted_seg_single_element(a, c);\n    return;\n  }\n  \n  var i := c;\n  while i < f - 1\n    invariant c <= i <= f - 1\n    invariant sorted_seg(a, c, i)\n    invariant multiset(a[c..f]) == old(multiset(a[c..f]))\n    invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])\n  {\n    var j := f - 1;\n    var old_a := a[..];\n    while j > i\n      invariant i <= j < f\n      invariant sorted_seg(a, c, i)\n      invariant forall k :: j < k < f ==> a[j] <= a[k]\n      invariant multiset(a[c..f]) == multiset(old_a[c..f])\n      invariant a[..c] == old_a[..c] && a[f..] == old_a[f..]\n    {\n      if a[j-1] > a[j] {\n        var temp := a[j-1];\n        a[j-1] := a[j];\n        a[j] := temp;\n      }\n      j := j - 1;\n    }\n    \n    assert j == i;\n    assert forall k :: i < k < f ==> a[i] <= a[k];\n    \n    establish_sorted_after_bubble(a, c, i, f);\n    \n    i := i + 1;\n  }\n  \n  assert i == f - 1;\n  assert sorted_seg(a, c, f - 1);\n  \n  if f > c {\n    sorted_seg_extension(a, c, f - 1, f);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST.dfy", "root", true, "", "", false, "Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST.dfy", "// <vc-preamble>\ndatatype Tree = Empty | Node(int,Tree,Tree)\n\nfunction NumbersInTree(t: Tree): set<int>\n{\n    NumbersInSequence(Inorder(t))\n}\n\nfunction NumbersInSequence(q: seq<int>): set<int>\n{\n    set x | x in q\n}\n\npredicate BST(t: Tree)\n{\n    Ascending(Inorder(t))\n}\n\nfunction Inorder(t: Tree): seq<int>\n{\n    match t {\n        case Empty => []\n        case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)\n    }\n}\n\npredicate Ascending(q: seq<int>)\n{\n    forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]\n}\n\npredicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertBST(t0: Tree, x: int) returns (t: Tree)\n    requires BST(t0) && x !in NumbersInTree(t0)\n    ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Tree = Empty | Node(int,Tree,Tree)\n\n\n\nfunction NumbersInTree(t: Tree): set<int>\n{\n    NumbersInSequence(Inorder(t))\n}\n\nfunction NumbersInSequence(q: seq<int>): set<int>\n{\n    set x | x in q\n}\n\npredicate BST(t: Tree)\n{\n    Ascending(Inorder(t))\n}\n\nfunction Inorder(t: Tree): seq<int>\n{\n    match t {\n        case Empty => []\n        case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)\n    }\n}\n\npredicate Ascending(q: seq<int>)\n{\n    forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]\n}\n\npredicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }\n\n/*\n    Goal: Implement correctly, clearly. No need to document the proof obligations.\n*/\n\n/*\n    Goal: Implement correctly, efficiently, clearly, documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n*/\n\n// <vc-helpers>\nlemma InorderPreservesNumbers(t1: Tree, t2: Tree, n: int)\n    ensures NumbersInSequence(Inorder(t1) + [n] + Inorder(t2)) == NumbersInTree(t1) + {n} + NumbersInTree(t2)\n{\n    var combined := Inorder(t1) + [n] + Inorder(t2);\n    assert NumbersInSequence(combined) == set x | x in combined;\n    \n    // Show that elements in combined sequence are exactly those in the union\n    forall x ensures x in NumbersInSequence(combined) <==> x in (NumbersInTree(t1) + {n} + NumbersInTree(t2))\n    {\n        if x in NumbersInSequence(combined) {\n            assert x in combined;\n            assert x in Inorder(t1) || x == n || x in Inorder(t2);\n            if x in Inorder(t1) {\n                assert x in NumbersInTree(t1);\n            } else if x == n {\n                assert x in {n};\n            } else {\n                assert x in NumbersInTree(t2);\n            }\n        }\n        \n        if x in (NumbersInTree(t1) + {n} + NumbersInTree(t2)) {\n            if x in NumbersInTree(t1) {\n                assert x in Inorder(t1);\n                assert x in combined;\n            } else if x in {n} {\n                assert x == n;\n                assert x in combined;\n            } else {\n                assert x in NumbersInTree(t2);\n                assert x in Inorder(t2);\n                assert x in combined;\n            }\n            assert x in NumbersInSequence(combined);\n        }\n    }\n}\n\nlemma SubtreeBST(t: Tree, root: int, left: Tree, right: Tree)\n    requires BST(Node(root, left, right))\n    ensures BST(left)\n    ensures BST(right)\n{\n    var inorderNode := Inorder(left) + [root] + Inorder(right);\n    assert Ascending(inorderNode);\n    \n    // Prove left subtree is BST\n    var inorderLeft := Inorder(left);\n    if |inorderLeft| > 0 {\n        forall i, j | 0 <= i < j < |inorderLeft|\n            ensures inorderLeft[i] < inorderLeft[j]\n        {\n            assert inorderLeft[i] == inorderNode[i];\n            assert inorderLeft[j] == inorderNode[j];\n        }\n    }\n    \n    // Prove right subtree is BST\n    var inorderRight := Inorder(right);\n    if |inorderRight| > 0 {\n        forall i, j | 0 <= i < j < |inorderRight|\n            ensures inorderRight[i] < inorderRight[j]\n        {\n            var leftLen := |inorderLeft|;\n            assert inorderRight[i] == inorderNode[leftLen + 1 + i];\n            assert inorderRight[j] == inorderNode[leftLen + 1 + j];\n        }\n    }\n}\n\nlemma AscendingConcatenation(left: seq<int>, right: seq<int>, root: int)\n    requires Ascending(left)\n    requires Ascending(right)\n    requires forall i | 0 <= i < |left| :: left[i] < root\n    requires forall i | 0 <= i < |right| :: root < right[i]\n    ensures Ascending(left + [root] + right)\n{\n    var combined := left + [root] + right;\n    forall i, j | 0 <= i < j < |combined|\n        ensures combined[i] < combined[j]\n    {\n        if i < |left| && j < |left| {\n            assert combined[i] == left[i];\n            assert combined[j] == left[j];\n            assert left[i] < left[j];\n        } else if i < |left| && j == |left| {\n            assert combined[i] == left[i];\n            assert combined[j] == root;\n            assert left[i] < root;\n        } else if i < |left| && j > |left| {\n            assert combined[i] == left[i];\n            assert combined[j] == right[j - |left| - 1];\n            assert left[i] < root < right[j - |left| - 1];\n        } else if i == |left| && j > |left| {\n            assert combined[i] == root;\n            assert combined[j] == right[j - |left| - 1];\n            assert root < right[j - |left| - 1];\n        } else {\n            assert i > |left| && j > |left|;\n            assert combined[i] == right[i - |left| - 1];\n            assert combined[j] == right[j - |left| - 1];\n            assert right[i - |left| - 1] < right[j - |left| - 1];\n        }\n    }\n}\n\nlemma BSTProperties(t: Tree, root: int, left: Tree, right: Tree)\n    requires BST(Node(root, left, right))\n    ensures forall x | x in NumbersInTree(left) :: x < root\n    ensures forall x | x in NumbersInTree(right) :: x > root\n{\n    var inorderNode := Inorder(left) + [root] + Inorder(right);\n    assert Ascending(inorderNode);\n    \n    forall x | x in NumbersInTree(left)\n        ensures x < root\n    {\n        assert x in Inorder(left);\n        var i :| 0 <= i < |Inorder(left)| && Inorder(left)[i] == x;\n        assert inorderNode[i] == x;\n        assert inorderNode[|Inorder(left)|] == root;\n        assert i < |Inorder(left)| <= |Inorder(left)|;\n        assert x < root;\n    }\n    \n    forall x | x in NumbersInTree(right)\n        ensures x > root\n    {\n        assert x in Inorder(right);\n        var i :| 0 <= i < |Inorder(right)| && Inorder(right)[i] == x;\n        var nodeIndex := |Inorder(left)| + 1 + i;\n        assert inorderNode[nodeIndex] == x;\n        assert inorderNode[|Inorder(left)|] == root;\n        assert |Inorder(left)| < nodeIndex;\n        assert root < x;\n    }\n}\n\nlemma InorderValuesRelation(t: Tree)\n    ensures forall i | 0 <= i < |Inorder(t)| :: Inorder(t)[i] in NumbersInTree(t)\n    ensures forall x | x in NumbersInTree(t) :: exists i :: 0 <= i < |Inorder(t)| && Inorder(t)[i] == x\n{\n    match t {\n        case Empty =>\n            assert Inorder(t) == [];\n            assert NumbersInTree(t) == {};\n        case Node(root, left, right) =>\n            InorderValuesRelation(left);\n            InorderValuesRelation(right);\n            \n            var inorderT := Inorder(left) + [root] + Inorder(right);\n            assert Inorder(t) == inorderT;\n            assert NumbersInTree(t) == NumbersInTree(left) + {root} + NumbersInTree(right);\n            \n            forall x | x in NumbersInTree(t)\n                ensures exists i :: 0 <= i < |Inorder(t)| && Inorder(t)[i] == x\n            {\n                if x in NumbersInTree(left) {\n                    var j :| 0 <= j < |Inorder(left)| && Inorder(left)[j] == x;\n                    assert Inorder(t)[j] == x;\n                } else if x == root {\n                    assert Inorder(t)[|Inorder(left)|] == root;\n                } else {\n                    assert x in NumbersInTree(right);\n                    var j :| 0 <= j < |Inorder(right)| && Inorder(right)[j] == x;\n                    var idx := |Inorder(left)| + 1 + j;\n                    assert Inorder(t)[idx] == x;\n                }\n            }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertBST(t0: Tree, x: int) returns (t: Tree)\n    requires BST(t0) && x !in NumbersInTree(t0)\n    ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}\n// </vc-spec>\n// <vc-code>\n{\n    match t0 {\n        case Empty => \n            t := Node(x, Empty, Empty);\n            InorderValuesRelation(t);\n            \n        case Node(root, left, right) =>\n            SubtreeBST(t0, root, left, right);\n            BSTProperties(t0, root, left, right);\n            \n            if x < root {\n                var newLeft := InsertBST(left, x);\n                t := Node(root, newLeft, right);\n                InorderPreservesNumbers(newLeft, right, root);\n                \n                assert forall y | y in NumbersInTree(newLeft) :: y < root;\n                assert forall y | y in NumbersInTree(right) :: y > root;\n                \n                InorderValuesRelation(newLeft);\n                InorderValuesRelation(right);\n                \n                assert forall i | 0 <= i < |Inorder(newLeft)| :: Inorder(newLeft)[i] in NumbersInTree(newLeft);\n                assert forall i | 0 <= i < |Inorder(newLeft)| :: Inorder(newLeft)[i] < root;\n                assert forall i | 0 <= i < |Inorder(right)| :: Inorder(right)[i] in NumbersInTree(right);\n                assert forall i | 0 <= i < |Inorder(right)| :: root < Inorder(right)[i];\n                \n                AscendingConcatenation(Inorder(newLeft), Inorder(right), root);\n                InorderValuesRelation(t);\n                \n            } else {\n                var newRight := InsertBST(right, x);\n                t := Node(root, left, newRight);\n                InorderPreservesNumbers(left, newRight, root);\n                \n                assert forall y | y in NumbersInTree(left) :: y < root;\n                assert forall y | y in NumbersInTree(newRight) :: y > root;\n                \n                InorderValuesRelation(left);\n                InorderValuesRelation(newRight);\n                \n                assert forall i | 0 <= i < |Inorder(left)| :: Inorder(left)[i] in NumbersInTree(left);\n                assert forall i | 0 <= i < |Inorder(left)| :: Inorder(left)[i] < root;\n                assert forall i | 0 <= i < |Inorder(newRight)| :: Inorder(newRight)[i] in NumbersInTree(newRight);\n                assert forall i | 0 <= i < |Inorder(newRight)| :: root < Inorder(newRight)[i];\n                \n                AscendingConcatenation(Inorder(left), Inorder(newRight), root);\n                InorderValuesRelation(t);\n            }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort.dfy", "// <vc-preamble>\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n{\n  assume{:axiom} false;\n}\n\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSort(a: array<int>)\n    modifies a\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\n//a)\n\n//b)\n//Problem04\n\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n{\n  assume{:axiom} false;\n}\n\n//Problem02\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n\n// <vc-helpers>\nlemma FindMinCorrectness(a: array<int>, lo: nat, minIdx: nat)\n    requires a.Length > 0 && lo < a.Length\n    requires lo <= minIdx < a.Length\n    requires forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n{\n}\n\nlemma SortedPreservation(a: array<int>, i: nat)\n    requires i < a.Length\n    requires forall k :: 0 <= k < i ==> (forall j :: k < j < a.Length ==> a[k] <= a[j])\n    requires forall k :: 0 < k < i ==> a[k-1] <= a[k]\n    ensures forall k :: 0 < k < i+1 ==> a[k-1] <= a[k]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSort(a: array<int>)\n    modifies a\n    //ensures multiset(a[..]) == multiset(old(a[..]))\n    //ensures sorted(a[..])\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 0 {\n        return;\n    }\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> (forall j :: k < j < a.Length ==> a[k] <= a[j])\n        invariant forall k :: 0 < k < i ==> a[k-1] <= a[k]\n    {\n        var minIdx := FindMin(a, i);\n        var temp := a[i];\n        a[i] := a[minIdx];\n        a[minIdx] := temp;\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n//Problem03", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod intDiv(n:int, d:int) returns (q:int, r:int)\nrequires n >= d && n >= 0 && d > 0 ;\nensures (d*q)+r == n && 0 <= q <= n/2 && 0 <= r < d;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem 01\n\n//problem02\n//a)\n\n// <vc-helpers>\nlemma DivisionProperties(n: int, d: int)\n  requires n >= 0 && d > 0\n  ensures n / d >= 0\n  ensures n / d <= n\n  ensures (n / d) * d <= n < (n / d + 1) * d\n{\n}\n\nlemma QuotientBound(n: int, d: int)\n  requires n >= d && d > 0\n  ensures n / d >= 1\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod intDiv(n:int, d:int) returns (q:int, r:int)\nrequires n >= d && n >= 0 && d > 0 ;\nensures (d*q)+r == n && 0 <= q <= n/2 && 0 <= r < d;\n// </vc-spec>\n// <vc-code>\n{\n  q := 0;\n  r := n;\n  \n  while r >= d && q < n / 2\n    invariant d * q + r == n\n    invariant r >= 0\n    invariant q >= 0\n    invariant q <= n / 2\n    decreases r\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_18_RemoveChars.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_18_RemoveChars.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma CharInStringImpliesExists(s: string, c: char)\n    requires c in s\n    ensures exists i :: 0 <= i < |s| && s[i] == c\n{\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant forall j :: 0 <= j < i ==> s[j] != c\n    {\n        if s[i] == c {\n            return;\n        }\n        i := i + 1;\n    }\n}\n\npredicate CharInString(c: char, s: string)\n{\n    exists i :: 0 <= i < |s| && s[i] == c\n}\n\nlemma CharInStringEquivalent(c: char, s: string)\n    ensures CharInString(c, s) <==> (c in s)\n{\n    if CharInString(c, s) {\n        assert c in s;\n    }\n    if c in s {\n        CharInStringImpliesExists(s, c);\n        assert CharInString(c, s);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n// </vc-spec>\n// <vc-code>\n{\n    v := \"\";\n    var i := 0;\n    while i < |s1|\n        invariant 0 <= i <= |s1|\n        invariant |v| <= i\n        invariant forall j :: 0 <= j < |v| ==> (v[j] in s1) && !(v[j] in s2)\n        invariant forall j :: 0 <= j < i ==> (s1[j] in s2) || (s1[j] in v)\n    {\n        if !(s1[i] in s2) {\n            v := v + [s1[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mlastMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: i<l<v.Length ==> v[i]>v[l]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mlastMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: i<l<v.Length ==> v[i]>v[l]\n// </vc-spec>\n// <vc-code>\n{\n  i := v.Length - 1;\n  var j := v.Length - 2;\n  \n  while j >= 0\n    invariant -1 <= j < v.Length - 1\n    invariant 0 <= i < v.Length\n    invariant forall k :: j < k < v.Length ==> v[i] >= v[k]\n    invariant forall l :: i < l < v.Length ==> v[i] > v[l]\n    decreases j + 1\n  {\n    if v[j] > v[i] {\n      i := j;\n    }\n    j := j - 1;\n  }\n}\n// </vc-code>\n\n//Algorithm : from left to right\n//Algorithm : from right to left", "", "", ""], ["dafny-synthesis_task_id_627_SmallestMissingNumber.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_627_SmallestMissingNumber.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SmallestMissingNumber(s: seq<int>) returns (v: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 0\n    ensures 0 <= v\n    ensures v !in s\n    ensures forall k :: 0 <= k < v ==> k in s\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma InSeqExists(s: seq<int>, x: int)\n    requires x in s\n    ensures exists i :: 0 <= i < |s| && s[i] == x\n{\n}\n\nlemma NotInSeqForall(s: seq<int>, x: int)\n    requires forall i :: 0 <= i < |s| ==> s[i] != x\n    ensures x !in s\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SmallestMissingNumber(s: seq<int>) returns (v: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 0\n    ensures 0 <= v\n    ensures v !in s\n    ensures forall k :: 0 <= k < v ==> k in s\n// </vc-spec>\n// <vc-code>\n{\n    v := 0;\n    var i := 0;\n    \n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant 0 <= v <= i\n        invariant forall k :: 0 <= k < v ==> k in s\n        invariant v !in s[..i]\n        invariant i < |s| ==> v <= s[i] || s[i] < v\n    {\n        if s[i] == v {\n            v := v + 1;\n        }\n        i := i + 1;\n    }\n    \n    assert v !in s[..|s|];\n    assert s[..|s|] == s;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_remove_front_remove_front.dfy", "root", true, "", "", false, "Clover_remove_front_remove_front.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod remove_front(a:array<int>) returns (c:array<int>)\n  requires a.Length>0\n  ensures  a[1..] == c[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod remove_front(a:array<int>) returns (c:array<int>)\n  requires a.Length>0\n  ensures  a[1..] == c[..]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length - 1];\n  var i := 0;\n  while i < c.Length\n    invariant 0 <= i <= c.Length\n    invariant forall j :: 0 <= j < i ==> c[j] == a[j + 1]\n  {\n    c[i] := a[i + 1];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_600_IsEven.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_600_IsEven.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsEven(n: int) returns (result: bool)\n    ensures result <==> n % 2 == 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsEven(n: int) returns (result: bool)\n    ensures result <==> n % 2 == 0\n// </vc-spec>\n// <vc-code>\n{\n  result := n % 2 == 0;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_793_LastPosition.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_793_LastPosition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma BinarySearchLastInvariant(arr: array<int>, elem: int, low: int, high: int, pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    requires 0 <= low <= high <= arr.Length\n    requires pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem)\n    requires forall i :: 0 <= i < low ==> arr[i] <= elem\n    requires forall i :: high <= i < arr.Length ==> arr[i] > elem\n    requires pos == -1 || pos < high\n    ensures pos == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != elem\n    ensures pos != -1 ==> (pos + 1 >= arr.Length || arr[pos + 1] > elem)\n{\n}\n\nlemma SortedArrayProperty(arr: array<int>, i: int, j: int)\n    requires forall x, y :: 0 <= x < y < arr.Length ==> arr[x] <= arr[y]\n    requires 0 <= i < j < arr.Length\n    ensures arr[i] <= arr[j]\n{\n}\n\nlemma ElementsAfterHighAreGreater(arr: array<int>, elem: int, high: int, pos: int)\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    requires 0 <= high <= arr.Length\n    requires forall i :: high <= i < arr.Length ==> arr[i] > elem\n    requires pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem)\n    requires pos == -1 || pos < high\n    ensures pos != -1 ==> (pos + 1 >= arr.Length || arr[pos + 1] > elem)\n{\n    if pos != -1 {\n        if pos + 1 < arr.Length {\n            if pos + 1 >= high {\n                assert arr[pos + 1] > elem;\n            } else {\n                assert pos < pos + 1 < high;\n                assert arr[pos] == elem;\n                assert arr[pos] <= arr[pos + 1];\n                assert elem <= arr[pos + 1];\n                if arr[pos + 1] == elem {\n                    assert false;\n                } else {\n                    assert arr[pos + 1] > elem;\n                }\n            }\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n    var low := 0;\n    var high := arr.Length;\n    pos := -1;\n    \n    while low < high\n        invariant 0 <= low <= high <= arr.Length\n        invariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem)\n        invariant forall i :: 0 <= i < low ==> arr[i] <= elem\n        invariant forall i :: high <= i < arr.Length ==> arr[i] > elem\n        invariant pos == -1 || pos < high\n        invariant forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n        invariant pos == -1 || forall i :: 0 <= i < pos ==> arr[i] <= elem\n    {\n        var mid := low + (high - low) / 2;\n        \n        if arr[mid] <= elem {\n            if arr[mid] == elem {\n                pos := mid;\n            }\n            low := mid + 1;\n        } else {\n            high := mid;\n        }\n    }\n    \n    if pos != -1 {\n        ElementsAfterHighAreGreater(arr, elem, high, pos);\n        assert arr[pos] == elem;\n        assert pos < arr.Length;\n        if pos + 1 < arr.Length {\n            assert arr[pos + 1] > elem;\n        }\n    } else {\n        BinarySearchLastInvariant(arr, elem, low, high, pos);\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum.dfy", "root", true, "", "", false, "Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum.dfy", "// <vc-preamble>\nfunction sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n\n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\n\n// <vc-helpers>\nlemma sum_property(a: array<int>, i: int)\n    requires 0 <= i < a.Length\n    ensures sum(a, i) == a[i] + (if i == 0 then 0 else sum(a, i - 1))\n{\n    // This follows directly from the definition of sum\n}\n\nlemma sum_incremental(a: array<int>, i: int)\n    requires 0 < i < a.Length\n    ensures sum(a, i) == sum(a, i - 1) + a[i]\n{\n    // Follows from the recursive definition\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n// </vc-spec>\n// <vc-code>\n{\n    b[0] := a[0];\n    var k := 1;\n    while k < a.Length\n        invariant 1 <= k <= a.Length\n        invariant forall j | 0 <= j < k :: b[j] == sum(a, j)\n    {\n        b[k] := b[k-1] + a[k];\n        sum_incremental(a, k);\n        k := k + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_472_ContainsConsecutiveNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_472_ContainsConsecutiveNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ContainsConsecutiveNumbers(a: array<int>) returns (result: bool)\n    requires a.Length>0\n    ensures result <==> (exists i :: 0 <= i < a.Length - 1 && a[i] + 1 == a[i + 1])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ContainsConsecutiveNumbers(a: array<int>) returns (result: bool)\n    requires a.Length>0\n    ensures result <==> (exists i :: 0 <= i < a.Length - 1 && a[i] + 1 == a[i + 1])\n// </vc-spec>\n// <vc-code>\n{\n    result := false;\n    var i := 0;\n    while i < a.Length - 1\n        invariant 0 <= i <= a.Length - 1\n        invariant result <==> (exists j :: 0 <= j < i && a[j] + 1 == a[j + 1])\n    {\n        if a[i] + 1 == a[i + 1] {\n            result := true;\n            return;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_firstE_firstE.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_firstE_firstE.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod firstE(a: array<char>) returns (x: int)\nensures if 'e' in a[..] then 0 <= x < a.Length && a[x] == 'e' && forall i | 0 <= i < x :: a[i] != 'e' else x == -1\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod firstE(a: array<char>) returns (x: int)\nensures if 'e' in a[..] then 0 <= x < a.Length && a[x] == 'e' && forall i | 0 <= i < x :: a[i] != 'e' else x == -1\n// </vc-spec>\n// <vc-code>\n{\n  x := -1;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j | 0 <= j < i :: a[j] != 'e'\n    invariant x == -1\n  {\n    if a[i] == 'e' {\n      x := i;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfFourthPowerOfOddNumbers(n: int) returns (sum: int)\n    requires n > 0\n    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SumOfFourthPowerHelper(k: int)\n    requires k >= 0\n    ensures SumOfOddFourthPowers(k) == k * (2 * k + 1) * (24 * k * k * k - 12 * k * k - 14 * k + 7) / 15\n{\n    if k == 0 {\n        assert SumOfOddFourthPowers(0) == 0;\n        assert 0 * (2 * 0 + 1) * (24 * 0 * 0 * 0 - 12 * 0 * 0 - 14 * 0 + 7) / 15 == 0;\n    } else {\n        SumOfFourthPowerHelper(k - 1);\n        calc {\n            SumOfOddFourthPowers(k);\n            == SumOfOddFourthPowers(k - 1) + Pow4(2 * k - 1);\n            == (k - 1) * (2 * (k - 1) + 1) * (24 * (k - 1) * (k - 1) * (k - 1) - 12 * (k - 1) * (k - 1) - 14 * (k - 1) + 7) / 15 + Pow4(2 * k - 1);\n        }\n        \n        var prev_term := (k - 1) * (2 * (k - 1) + 1) * (24 * (k - 1) * (k - 1) * (k - 1) - 12 * (k - 1) * (k - 1) - 14 * (k - 1) + 7) / 15;\n        var current_term := Pow4(2 * k - 1);\n        var expected := k * (2 * k + 1) * (24 * k * k * k - 12 * k * k - 14 * k + 7) / 15;\n        \n        assert prev_term + current_term == expected by {\n            calc {\n                current_term;\n                == Pow4(2 * k - 1);\n                == (2 * k - 1) * (2 * k - 1) * (2 * k - 1) * (2 * k - 1);\n            }\n            \n            var expanded_prev := (k - 1) * (2 * k - 1) * (24 * (k - 1) * (k - 1) * (k - 1) - 12 * (k - 1) * (k - 1) - 14 * (k - 1) + 7) / 15;\n            var expanded_current := (2 * k - 1) * (2 * k - 1) * (2 * k - 1) * (2 * k - 1);\n            \n            assert prev_term == expanded_prev;\n            assert current_term == expanded_current;\n            assert expanded_prev + expanded_current == expected;\n        }\n    }\n}\n\nfunction SumOfOddFourthPowers(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0\n    else SumOfOddFourthPowers(n - 1) + Pow4(2 * n - 1)\n}\n\nfunction Pow4(x: int): int\n{\n    x * x * x * x\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfFourthPowerOfOddNumbers(n: int) returns (sum: int)\n    requires n > 0\n    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15\n// </vc-spec>\n// <vc-code>\n{\n    SumOfFourthPowerHelper(n);\n    sum := n * (2 * n + 1) * (24 * n * n * n - 12 * n * n - 14 * n + 7) / 15;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_even_list_FindEvenNumbers.dfy", "root", true, "", "", false, "Clover_even_list_FindEvenNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindEvenNumbers (arr: array<int>) returns (evenNumbers: array<int>)\n  ensures forall x {:trigger (x%2) }:: x in arr[..] &&  (x%2==0)==> x in evenNumbers[..]\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n  ensures forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] % 2 == 0\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n                           exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SeqContainsElements<T>(s: seq<T>, t: seq<T>)\n  requires forall i :: 0 <= i < |t| ==> t[i] in s\n  ensures forall x :: x in t ==> x in s\n{\n}\n\nlemma ArraySliceContains<T>(arr: array<T>, i: int)\n  requires 0 <= i < arr.Length\n  ensures arr[i] in arr[..]\n{\n}\n\nlemma SeqIndexPreservation<T>(s: seq<T>, indices: seq<int>)\n  requires forall i :: 0 <= i < |indices| ==> 0 <= indices[i] < |s|\n  requires forall i, j :: 0 <= i < j < |indices| ==> indices[i] < indices[j]\n  ensures forall i, j :: 0 <= i < j < |indices| ==>\n    exists n, m :: 0 <= n < m < |s| && s[indices[i]] == s[n] && s[indices[j]] == s[m]\n{\n  forall i, j | 0 <= i < j < |indices|\n    ensures exists n, m :: 0 <= n < m < |s| && s[indices[i]] == s[n] && s[indices[j]] == s[m]\n  {\n    var n := indices[i];\n    var m := indices[j];\n    assert 0 <= n < m < |s|;\n    assert s[indices[i]] == s[n] && s[indices[j]] == s[m];\n  }\n}\n\nlemma EvenNumbersOrderingProof(arr: array<int>, evenIndices: seq<int>, evenNumbers: array<int>)\n  requires forall i :: 0 <= i < |evenIndices| ==> 0 <= evenIndices[i] < arr.Length\n  requires forall i, j :: 0 <= i < j < |evenIndices| ==> evenIndices[i] < evenIndices[j]\n  requires evenNumbers.Length == |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> 0 <= k < |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] == arr[evenIndices[k]]\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n    exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n{\n  forall k, l | 0 <= k < l < evenNumbers.Length\n    ensures exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n  {\n    assert 0 <= k < l < |evenIndices|;\n    var n := evenIndices[k];\n    var m := evenIndices[l];\n    assert 0 <= n < m < arr.Length;\n    assert evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m];\n  }\n}\n\nlemma EvenIndicesContainment(arr: array<int>, evenIndices: seq<int>)\n  requires forall i :: 0 <= i < |evenIndices| ==> 0 <= evenIndices[i] < arr.Length\n  requires forall i :: 0 <= i < |evenIndices| ==> arr[evenIndices[i]] % 2 == 0\n  requires forall j :: 0 <= j < arr.Length && arr[j] % 2 == 0 ==> j in evenIndices\n  ensures forall x :: x in arr[..] && x % 2 == 0 ==> exists k :: 0 <= k < |evenIndices| && arr[evenIndices[k]] == x\n{\n  forall x | x in arr[..] && x % 2 == 0\n    ensures exists k :: 0 <= k < |evenIndices| && arr[evenIndices[k]] == x\n  {\n    assert exists j :: 0 <= j < arr.Length && arr[j] == x;\n    var j :| 0 <= j < arr.Length && arr[j] == x;\n    assert j in evenIndices;\n    assert exists k :: 0 <= k < |evenIndices| && evenIndices[k] == j;\n    var k :| 0 <= k < |evenIndices| && evenIndices[k] == j;\n    assert arr[evenIndices[k]] == x;\n  }\n}\n\nlemma EvenNumbersNotInArray(arr: array<int>, evenNumbers: array<int>, evenIndices: seq<int>)\n  requires evenNumbers.Length == |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> 0 <= k < |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] == arr[evenIndices[k]]\n  requires forall i :: 0 <= i < |evenIndices| ==> 0 <= evenIndices[i] < arr.Length\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n{\n}\n\nlemma IndexOrderPreservation(evenIndices: seq<int>)\n  requires forall k, l :: 0 <= k < l < |evenIndices| ==> evenIndices[k] < evenIndices[l]\n  ensures forall i, j :: 0 <= i < j < |evenIndices| ==> evenIndices[i] < evenIndices[j]\n{\n}\n\nlemma EvenElementsInResult(arr: array<int>, evenNumbers: array<int>, evenIndices: seq<int>)\n  requires evenNumbers.Length == |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> 0 <= k < |evenIndices|\n  requires forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] == arr[evenIndices[k]]\n  requires forall i :: 0 <= i < |evenIndices| ==> 0 <= evenIndices[i] < arr.Length\n  requires forall i :: 0 <= i < |evenIndices| ==> arr[evenIndices[i]] % 2 == 0\n  requires forall j :: 0 <= j < arr.Length && arr[j] % 2 == 0 ==> j in evenIndices\n  ensures forall x :: x in arr[..] && x % 2 == 0 ==> x in evenNumbers[..]\n{\n  forall x | x in arr[..] && x % 2 == 0\n    ensures x in evenNumbers[..]\n  {\n    assert exists j :: 0 <= j < arr.Length && arr[j] == x;\n    var j :| 0 <= j < arr.Length && arr[j] == x;\n    assert j in evenIndices;\n    assert exists k :: 0 <= k < |evenIndices| && evenIndices[k] == j;\n    var k :| 0 <= k < |evenIndices| && evenIndices[k] == j;\n    assert evenNumbers[k] == arr[evenIndices[k]] == arr[j] == x;\n    assert x in evenNumbers[..];\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindEvenNumbers (arr: array<int>) returns (evenNumbers: array<int>)\n  ensures forall x {:trigger (x%2) }:: x in arr[..] &&  (x%2==0)==> x in evenNumbers[..]\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n  ensures forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] % 2 == 0\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n                           exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n// </vc-spec>\n// <vc-code>\n{\n  var evenIndices: seq<int> := [];\n  var i := 0;\n  \n  while i < arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < i\n    invariant forall k :: 0 <= k < |evenIndices| ==> arr[evenIndices[k]] % 2 == 0\n    invariant forall k, l :: 0 <= k < l < |evenIndices| ==> evenIndices[k] < evenIndices[l]\n    invariant forall j :: 0 <= j < i && arr[j] % 2 == 0 ==> j in evenIndices\n  {\n    if arr[i] % 2 == 0 {\n      evenIndices := evenIndices + [i];\n    }\n    i := i + 1;\n  }\n  \n  evenNumbers := new int[|evenIndices|];\n  \n  i := 0;\n  while i < |evenIndices|\n    invariant 0 <= i <= |evenIndices|\n    invariant evenNumbers.Length == |evenIndices|\n    invariant forall k :: 0 <= k < i ==> evenNumbers[k] == arr[evenIndices[k]]\n  {\n    evenNumbers[i] := arr[evenIndices[i]];\n    i := i + 1;\n  }\n  \n  assert forall k :: 0 <= k < evenNumbers.Length ==> 0 <= k < |evenIndices|;\n  assert forall i :: 0 <= i < |evenIndices| ==> 0 <= evenIndices[i] < arr.Length;\n  assert forall j :: 0 <= j < arr.Length && arr[j] % 2 == 0 ==> j in evenIndices;\n  \n  IndexOrderPreservation(evenIndices);\n  \n  if evenNumbers.Length > 0 {\n    EvenNumbersOrderingProof(arr, evenNumbers, evenIndices);\n  }\n  \n  EvenElementsInResult(arr, evenNumbers, evenIndices);\n  EvenNumbersNotInArray(arr, evenNumbers, evenIndices);\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven.dfy", "root", true, "", "", false, "DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven.dfy", "// <vc-preamble>\npredicate  odd(n: nat) { n % 2 == 1 }\npredicate  even(n: nat) { n % 2 == 0 }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod partitionOddEven(a: array<nat>) \n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures ! exists i, j :: 0 <= i < j < a.Length && even(a[i]) && odd(a[j])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Rearranges the elements in an array 'a' of natural numbers,\n// so that all odd numbers appear before all even numbers.\n\npredicate  odd(n: nat) { n % 2 == 1 }\npredicate  even(n: nat) { n % 2 == 0 }\n\n// <vc-helpers>\nlemma MultisetPreservation(old_contents: seq<nat>, new_contents: seq<nat>, i: int, j: int)\n  requires 0 <= i < |old_contents| && 0 <= j < |old_contents|\n  requires |new_contents| == |old_contents|\n  requires new_contents == old_contents[i := old_contents[j]][j := old_contents[i]]\n  ensures multiset(new_contents) == multiset(old_contents)\n{\n  assert multiset(new_contents) == multiset(old_contents[i := old_contents[j]][j := old_contents[i]]);\n}\n\nlemma PartitionInvariant(a: array<nat>, left: int)\n  requires 0 <= left <= a.Length\n  requires forall k :: 0 <= k < left ==> odd(a[k])\n  ensures forall k :: 0 <= k < left ==> odd(a[k])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod partitionOddEven(a: array<nat>) \n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures ! exists i, j :: 0 <= i < j < a.Length && even(a[i]) && odd(a[j])\n// </vc-spec>\n// <vc-code>\n{\n  var left := 0;\n  var right := a.Length;\n  \n  while left < right\n    invariant 0 <= left <= right <= a.Length\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall k :: 0 <= k < left ==> odd(a[k])\n    invariant forall k :: right <= k < a.Length ==> even(a[k])\n    invariant ! exists i, j :: 0 <= i < left && right <= j < a.Length && even(a[i]) && odd(a[j])\n  {\n    if odd(a[left]) {\n      left := left + 1;\n    } else {\n      right := right - 1;\n      var temp := a[left];\n      a[left] := a[right];\n      a[right] := temp;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort.dfy", "// <vc-preamble>\npredicate sortedbad(s:string) \n{\n\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'b' && (s[j] == 'a' || s[j] == 'd') ==> i < j &&\n\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'b' ==> i > j &&\n\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'd' ==> i < j &&\n\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'd' && (s[j] == 'a' || s[j] == 'b') ==> i > j\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall k :: 0 <= k < |a| ==> a[k] == 'b' || a[k] == 'a' || a[k] == 'd';\nensures sortedbad(b);\nensures multiset(a[..]) == multiset(b[..]);\nensures |a| == |b|;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// verifies\n// all bs are before all as which are before all ds\n\npredicate sortedbad(s:string) \n{\n    // all b's are before all a's and d's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'b' && (s[j] == 'a' || s[j] == 'd') ==> i < j &&\n    // all a's are after all b's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'b' ==> i > j &&\n    // all a's are before all d's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'd' ==> i < j &&\n    // all d's are after a;; b's and a's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'd' && (s[j] == 'a' || s[j] == 'b') ==> i > j\n}\n\n// <vc-helpers>\nlemma SortedBadProperties(s: string)\nrequires sortedbad(s)\nensures forall i,j :: 0 <= i < j < |s| && s[i] == 'b' && s[j] == 'a' ==> i < j\nensures forall i,j :: 0 <= i < j < |s| && s[i] == 'a' && s[j] == 'd' ==> i < j\nensures forall i,j :: 0 <= i < j < |s| && s[i] == 'b' && s[j] == 'd' ==> i < j\n{\n}\n\nfunction CountChar(s: string, c: char): nat\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + CountChar(s[1..], c)\n}\n\nlemma CountCharMultiset(s: string, c: char)\nensures CountChar(s, c) == |multiset(s[..])| - |multiset(s[..]) - multiset{c}|\n{\n    if |s| == 0 {\n    } else {\n        CountCharMultiset(s[1..], c);\n    }\n}\n\nfunction BuildSorted(bs: nat, ases: nat, ds: nat): string\n{\n    seq(bs, i => 'b') + seq(ases, i => 'a') + seq(ds, i => 'd')\n}\n\nlemma BuildSortedCorrect(bs: nat, ases: nat, ds: nat)\nensures sortedbad(BuildSorted(bs, ases, ds))\nensures CountChar(BuildSorted(bs, ases, ds), 'b') == bs\nensures CountChar(BuildSorted(bs, ases, ds), 'a') == ases\nensures CountChar(BuildSorted(bs, ases, ds), 'd') == ds\n{\n    var result := BuildSorted(bs, ases, ds);\n    \n    forall i, j | 0 <= i < |result| && 0 <= j < |result| && result[i] == 'b' && (result[j] == 'a' || result[j] == 'd')\n    ensures i < j\n    {\n        assert i < bs;\n        assert j >= bs;\n    }\n    \n    forall i, j | 0 <= i < |result| && 0 <= j < |result| && result[i] == 'a' && result[j] == 'b'\n    ensures i > j\n    {\n        assert i >= bs && i < bs + ases;\n        assert j < bs;\n    }\n    \n    forall i, j | 0 <= i < |result| && 0 <= j < |result| && result[i] == 'a' && result[j] == 'd'\n    ensures i < j\n    {\n        assert i >= bs && i < bs + ases;\n        assert j >= bs + ases;\n    }\n    \n    forall i, j | 0 <= i < |result| && 0 <= j < |result| && result[i] == 'd' && (result[j] == 'a' || result[j] == 'b')\n    ensures i > j\n    {\n        assert i >= bs + ases;\n        assert j < bs + ases;\n    }\n}\n\nfunction MultisetTimes(n: nat, m: multiset<char>): multiset<char>\n{\n    if n == 0 then multiset{}\n    else m + MultisetTimes(n-1, m)\n}\n\nlemma MultisetRepeatChar(n: nat, c: char)\nensures multiset(seq(n, i => c)[..]) == MultisetTimes(n, multiset([c]))\n{\n    if n == 0 {\n        assert seq(0, i => c) == [];\n        assert multiset([][..]) == multiset{};\n        assert MultisetTimes(0, multiset([c])) == multiset{};\n    } else {\n        var s := seq(n, i => c);\n        assert s == [c] + seq(n-1, i => c);\n        MultisetRepeatChar(n-1, c);\n        assert multiset(seq(n-1, i => c)[..]) == MultisetTimes(n-1, multiset([c]));\n        assert multiset(s[..]) == multiset([c]) + multiset(seq(n-1, i => c)[..]);\n        assert multiset(s[..]) == multisetTimes(1, multiset([c])) + MultisetTimes(n-1, multiset([c]));\n        MultisetTimesAdditive(1, n-1, multiset([c]));\n        assert multiset(s[..]) == MultisetTimes(n, multiset([c]));\n    }\n}\n\nlemma MultisetTimesAdditive(n1: nat, n2: nat, m: multiset<char>)\nensures MultisetTimes(n1, m) + MultisetTimes(n2, m) == MultisetTimes(n1 + n2, m)\n{\n    if n1 == 0 {\n        assert MultisetTimes(0, m) == multiset{};\n        assert multiset{} + MultisetTimes(n2, m) == MultisetTimes(n2, m);\n        assert MultisetTimes(0 + n2, m) == MultisetTimes(n2, m);\n    } else {\n        MultisetTimesAdditive(n1-1, n2, m);\n        assert MultisetTimes(n1-1, m) + MultisetTimes(n2, m) == MultisetTimes(n1-1 + n2, m);\n        assert MultisetTimes(n1, m) == m + MultisetTimes(n1-1, m);\n        assert MultisetTimes(n1, m) + MultisetTimes(n2, m) == m + MultisetTimes(n1-1, m) + MultisetTimes(n2, m);\n        assert MultisetTimes(n1, m) + MultisetTimes(n2, m) == m + (MultisetTimes(n1-1, m) + MultisetTimes(n2, m));\n        assert MultisetTimes(n1, m) + MultisetTimes(n2, m) == m + MultisetTimes(n1-1 + n2, m);\n        assert MultisetTimes(n1, m) + MultisetTimes(n2, m) == MultisetTimes(1 + n1-1 + n2, m);\n        assert MultisetTimes(n1, m) + MultisetTimes(n2, m) == MultisetTimes(n1 + n2, m);\n    }\n}\n\nlemma CountCharCorrect(s: string)\nrequires forall k :: 0 <= k < |s| ==> s[k] == 'b' || s[k] == 'a' || s[k] == 'd'\nensures |s| == CountChar(s, 'b') + CountChar(s, 'a') + CountChar(s, 'd')\nensures multiset(s[..]) == MultisetTimes(CountChar(s, 'b'), multiset(['b'])) + MultisetTimes(CountChar(s, 'a'), multiset(['a'])) + MultisetTimes(CountChar(s, 'd'), multiset(['d']))\n{\n    if |s| == 0 {\n        assert MultisetTimes(0, multiset(['b'])) == multiset{};\n        assert MultisetTimes(0, multiset(['a'])) == multiset{};\n        assert MultisetTimes(0, multiset(['d'])) == multiset{};\n    } else {\n        CountCharCorrect(s[1..]);\n        assert s[..] == [s[0]] + s[1..];\n        assert multiset(s[..]) == multiset([s[0]]) + multiset(s[1..]);\n        \n        if s[0] == 'b' {\n            assert CountChar(s, 'b') == 1 + CountChar(s[1..], 'b');\n            assert CountChar(s, 'a') == CountChar(s[1..], 'a');\n            assert CountChar(s, 'd') == CountChar(s[1..], 'd');\n            assert multiset([s[0]]) == multiset(['b']);\n            MultisetTimesAdditive(1, CountChar(s[1..], 'b'), multiset(['b']));\n        } else if s[0] == 'a' {\n            assert CountChar(s, 'b') == CountChar(s[1..], 'b');\n            assert CountChar(s, 'a') == 1 + CountChar(s[1..], 'a');\n            assert CountChar(s, 'd') == CountChar(s[1..], 'd');\n            assert multiset([s[0]]) == multiset(['a']);\n            MultisetTimesAdditive(1, CountChar(s[1..], 'a'), multiset(['a']));\n        } else {\n            assert s[0] == 'd';\n            assert CountChar(s, 'b') == CountChar(s[1..], 'b');\n            assert CountChar(s, 'a') == CountChar(s[1..], 'a');\n            assert CountChar(s, 'd') == 1 + CountChar(s[1..], 'd');\n            assert multiset([s[0]]) == multiset(['d']);\n            MultisetTimesAdditive(1, CountChar(s[1..], 'd'), multiset(['d']));\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall k :: 0 <= k < |a| ==> a[k] == 'b' || a[k] == 'a' || a[k] == 'd';\nensures sortedbad(b);\nensures multiset(a[..]) == multiset(b[..]);\nensures |a| == |b|;\n// </vc-spec>\n// <vc-code>\n{\n    var bCount := CountChar(a, 'b');\n    var aCount := CountChar(a, 'a');\n    var dCount := CountChar(a, 'd');\n    \n    b := BuildSorted(bCount, aCount, dCount);\n    \n    BuildSortedCorrect(bCount, aCount, dCount);\n    CountCharCorrect(a);\n    \n    MultisetRepeatChar(bCount, 'b');\n    MultisetRepeatChar(aCount, 'a');\n    MultisetRepeatChar(dCount, 'd');\n    \n    assert |b| == bCount + aCount + dCount;\n    assert |a| == CountChar(a, 'b') + CountChar(a, 'a') + CountChar(a, 'd');\n    \n    var aMultiset := multiset(a[..]);\n    var bMultiset := multiset(b[..]);\n    \n    assert multiset(seq(bCount, i => 'b')[..]) == MultisetTimes(bCount, multiset(['b']));\n    assert multiset(seq(aCount, i => 'a')[..]) == MultisetTimes(aCount, multiset(['a']));\n    assert multiset(seq(dCount, i => 'd')[..]) == MultisetTimes(dCount, multiset(['d']));\n    \n    assert bMultiset == MultisetTimes(bCount, multiset(['b'])) + MultisetTimes(aCount, multiset(['a'])) + MultisetTimes(dCount, multiset(['d']));\n    assert aMultiset == MultisetTimes(bCount, multiset(['b'])) + MultisetTimes(aCount, multiset(['a'])) + MultisetTimes(dCount, multiset(['d']));\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC.dfy", "root", true, "", "", false, "DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC.dfy", "// <vc-preamble>\nfunction power(x: real, n: nat) : real {\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerDC(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal verification of an O(log n) algorithm to calculate the natural power of a real number (x^n), \n* illustrating the usage of lemmas and automatic induction in Dafny.\n* J.  Pascoal Faria, FEUP, Jan/2022.\n*/\n\n// Recursive definition of x^n in functional style, with time and space complexity O(n).\nfunction power(x: real, n: nat) : real {\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Computation of x^n in time and space O(log n).\n\n// <vc-helpers>\nlemma powerEven(x: real, n: nat)\n  requires n % 2 == 0\n  ensures power(x, n) == power(x * x, n / 2)\n{\n  if n == 0 {\n  } else {\n    calc {\n      power(x, n);\n    == x * power(x, n - 1);\n    == x * x * power(x, n - 2);\n    == power(x * x, 1) * power(x, n - 2);\n    }\n    powerEven(x, n - 2);\n    calc {\n      power(x * x, 1) * power(x, n - 2);\n    == (x * x) * power(x, n - 2);\n    == (x * x) * power(x * x, (n - 2) / 2);\n    == power(x * x, 1 + (n - 2) / 2);\n    == power(x * x, n / 2);\n    }\n  }\n}\n\nlemma powerOdd(x: real, n: nat)\n  requires n % 2 == 1 && n > 0\n  ensures power(x, n) == x * power(x * x, (n - 1) / 2)\n{\n  calc {\n    power(x, n);\n  == x * power(x, n - 1);\n  }\n  powerEven(x, n - 1);\n  calc {\n    x * power(x, n - 1);\n  == x * power(x * x, (n - 1) / 2);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerDC(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    p := 1.0;\n  } else if n % 2 == 0 {\n    powerEven(x, n);\n    var temp := powerDC(x * x, n / 2);\n    p := temp;\n  } else {\n    powerOdd(x, n);\n    var temp := powerDC(x * x, (n - 1) / 2);\n    p := x * temp;\n  }\n}\n// </vc-code>\n\n// A few test cases (checked statically by Dafny).", "", "", ""], ["dafny-synthesis_task_id_566_SumOfDigits.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_566_SumOfDigits.dfy", "// <vc-preamble>\nghost function IntValues(n: int) : (r: seq<int>)\n  requires n >= 0\n  ensures 0 in r\n  ensures n in r\n  ensures n/10 in r\n\n{\n  if n == 0 then [0]\n  else [n] + IntValues(n/10)\n}\n\nfunction Power10(n: nat): (r: nat)\n  ensures r >= 1\n  ensures n > 0 ==> r % 10 == 0\n{\n  if (n == 0) then 1 else 10 * Power10(n-1)\n}\n\nfunction NumberToSeq(number: int) : seq<int>\n  requires number >= 0\n{\n  if number == 0 then []\n  else [number % 10] + NumberToSeq(number/10)\n}\n\nfunction Sum(digits: seq<int>) : int\n{\n  if |digits| == 0 then 0 else digits[0] + Sum(digits[1..])\n}\n\nfunction SumDigits(n: nat) : nat\n{\n  var ndigits := NumberOfDigits(n);\n  var p := Power10(ndigits-1);\n  SumDigitsRecursive(n, p)\n}\n\nfunction SumDigitsRecursive(n: nat, p: nat) : (r: nat)\n{\n  if n == 0 || p == 0 then 0\n  else\n    var leftMostDigit := n/p;\n    var rest := n%p;\n    leftMostDigit + SumDigitsRecursive(rest, p/10)\n\n}\n\nfunction NumberOfDigits(n: nat) : (r: nat)\n  ensures r >= 1\n  ensures r == 1 <==> 0 <= n <= 9\n{\n  if 0 <= n <= 9 then 1 else 1+NumberOfDigits(n/10)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfDigits(number: nat) returns (sum: nat)\n  requires number >= 0\n  ensures sum >= 0\n  ensures sum == SumDigits(number)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//lemma DivIsZero()\n//  ensures forall num, den : nat :: den >= 1 && num < den ==> num/den == 0\n\n// ghost function ValuesOfn(number: nat, ndigits: nat) : (r: seq<nat>)\n// {\n//   seq(ndigits+1, i requires 0 <= i <= ndigits => number / PowersOfTen[i])\n// }\n\nghost function IntValues(n: int) : (r: seq<int>)\n  requires n >= 0\n  ensures 0 in r\n  ensures n in r\n  ensures n/10 in r\n  //    ensures forall p :: p in powersOfTen ==> n/p in r\n{\n  if n == 0 then [0]\n  else [n] + IntValues(n/10)\n}\n\nfunction Power10(n: nat): (r: nat)\n  ensures r >= 1\n  ensures n > 0 ==> r % 10 == 0\n{\n  if (n == 0) then 1 else 10 * Power10(n-1)\n}\n\nfunction NumberToSeq(number: int) : seq<int>\n  requires number >= 0\n{\n  if number == 0 then []\n  else [number % 10] + NumberToSeq(number/10)\n}\n\nfunction Sum(digits: seq<int>) : int\n{\n  if |digits| == 0 then 0 else digits[0] + Sum(digits[1..])\n}\n\nfunction SumDigits(n: nat) : nat\n{\n  var ndigits := NumberOfDigits(n);\n  var p := Power10(ndigits-1);\n  SumDigitsRecursive(n, p)\n}\n\nfunction SumDigitsRecursive(n: nat, p: nat) : (r: nat)\n{\n  if n == 0 || p == 0 then 0\n  else\n    var leftMostDigit := n/p;\n    var rest := n%p;\n    leftMostDigit + SumDigitsRecursive(rest, p/10)\n\n}\n\nfunction NumberOfDigits(n: nat) : (r: nat)\n  ensures r >= 1\n  ensures r == 1 <==> 0 <= n <= 9\n{\n  if 0 <= n <= 9 then 1 else 1+NumberOfDigits(n/10)\n}\n\n// <vc-helpers>\nlemma SumDigitsRecursiveZero(p: nat)\n  ensures SumDigitsRecursive(0, p) == 0\n{\n}\n\nlemma SumDigitsEquivalence(n: nat, sum: nat, remaining: nat, p: nat)\n  requires remaining == n % Power10(NumberOfDigits(n))\n  requires sum + SumDigitsRecursive(remaining, p) == SumDigits(n)\n  requires p == Power10(NumberOfDigits(remaining)) || remaining == 0\n  ensures sum == SumDigits(n) - SumDigitsRecursive(remaining, p)\n{\n}\n\nlemma SumDigitsIterativeCorrectness(n: nat, sum: nat, temp: nat)\n  requires temp >= 0\n  requires sum >= 0\n  requires sum + SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == SumDigits(n)\n  ensures temp == 0 ==> sum == SumDigits(n)\n{\n  if temp == 0 {\n    assert SumDigitsRecursive(0, Power10(NumberOfDigits(0))) == 0;\n  }\n}\n\nlemma NumberOfDigitsPositive(n: nat)\n  ensures NumberOfDigits(n) >= 1\n{\n}\n\nlemma Power10Positive(n: nat)\n  ensures Power10(n) >= 1\n{\n}\n\nlemma Power10Of1()\n  ensures Power10(1) == 10\n{\n}\n\nlemma SumDigitsRecursiveProperty(temp: nat)\n  requires temp > 0\n  requires temp < 10\n  ensures SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == temp\n{\n  assert NumberOfDigits(temp) == 1;\n  Power10Of1();\n  assert Power10(1) == 10;\n  assert temp / 10 == 0;\n  assert temp % 10 == temp;\n  assert SumDigitsRecursive(temp, 10) == temp + SumDigitsRecursive(0, 1);\n  assert SumDigitsRecursive(0, 1) == 0;\n}\n\nlemma SumDigitsRecursiveDecomposition(temp: nat)\n  requires temp >= 10\n  ensures SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == \n          (temp % 10) + SumDigitsRecursive(temp / 10, Power10(NumberOfDigits(temp / 10)))\n{\n  var ndigits := NumberOfDigits(temp);\n  var p := Power10(ndigits - 1);\n  \n  assert ndigits >= 2;\n  assert p >= 10;\n  \n  var digit := temp % 10;\n  var rest := temp / 10;\n  \n  calc {\n    SumDigitsRecursive(temp, p);\n    == {\n      assert temp >= 10;\n      assert p >= 10;\n      if temp >= p {\n        var leftMost := temp / p;\n        var remainder := temp % p;\n        assert SumDigitsRecursive(temp, p) == leftMost + SumDigitsRecursive(remainder, p / 10);\n      } else {\n        assert SumDigitsRecursive(temp, p) == SumDigitsRecursive(temp, p / 10);\n      }\n      SumDigitsRecursive(temp, p / 10);\n    }\n    == SumDigitsRecursive(temp, Power10(ndigits - 2));\n  }\n}\n\nlemma SumDigitsRecursiveStepInvariant(number: nat, sum: nat, temp: nat)\n  requires temp > 0\n  requires sum + SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == SumDigits(number)\n  ensures (sum + (temp % 10)) + SumDigitsRecursive(temp / 10, Power10(NumberOfDigits(temp / 10))) == SumDigits(number)\n{\n  var digit := temp % 10;\n  var newTemp := temp / 10;\n  \n  if temp < 10 {\n    SumDigitsRecursiveProperty(temp);\n    assert SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == temp;\n    assert temp == digit;\n    assert newTemp == 0;\n    assert SumDigitsRecursive(0, Power10(NumberOfDigits(0))) == 0;\n  } else {\n    SumDigitsRecursiveDecomposition(temp);\n    assert SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == \n           digit + SumDigitsRecursive(newTemp, Power10(NumberOfDigits(newTemp)));\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfDigits(number: nat) returns (sum: nat)\n  requires number >= 0\n  ensures sum >= 0\n  ensures sum == SumDigits(number)\n// </vc-spec>\n// <vc-code>\n{\n  sum := 0;\n  var temp := number;\n  \n  if temp == 0 {\n    return;\n  }\n  \n  while temp > 0\n    invariant temp >= 0\n    invariant sum >= 0\n    invariant temp == 0 ==> sum == SumDigits(number)\n    invariant temp > 0 ==> sum + SumDigitsRecursive(temp, Power10(NumberOfDigits(temp))) == SumDigits(number)\n    decreases temp\n  {\n    var digit := temp % 10;\n    \n    SumDigitsRecursiveStepInvariant(number, sum, temp);\n    \n    sum := sum + digit;\n    temp := temp / 10;\n  }\n  \n  assert temp == 0;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search.dfy", "// <vc-preamble>\nghost predicate IsDuplicate(a: array<int>, p: int)\n  reads a\n{\n  IsPrefixDuplicate(a, a.Length, p)\n}\n\nghost predicate IsPrefixDuplicate(a: array<int>, k: int, p: int)\n  requires 0 <= k <= a.Length;\n  reads a;\n{\n  exists i,j :: 0 <= i < j < k && a[i] == a[j] == p\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search(a: array<int>) returns (p: int, q: int)\n  requires 4 <= a.Length;\n  requires exists p,q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q);\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length - 2;\n  ensures p != q && IsDuplicate(a, p) && IsDuplicate(a, q);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB.dfy", "// <vc-preamble>\nfunction SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {SumR(v[c..f])}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumElemsB(v:array<int>) returns (sum:int)\nensures sum==SumR(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {SumR(v[c..f])}\n\n// <vc-helpers>\nlemma SumREquivalence(s: seq<int>, i: int)\n  requires 0 <= i <= |s|\n  ensures SumR(s[0..i]) == if i == 0 then 0 else SumR(s[0..i-1]) + s[i-1]\n{\n  if i == 0 {\n    assert s[0..0] == [];\n  } else {\n    assert s[0..i] == s[0..i-1] + [s[i-1]];\n    assert s[0..i][..|s[0..i]|-1] == s[0..i-1];\n    assert s[0..i][|s[0..i]|-1] == s[i-1];\n  }\n}\n\nlemma SumRInvariant(v: array<int>, i: int, sum: int)\n  requires 0 <= i <= v.Length\n  requires sum == SumR(v[0..i])\n  ensures sum + SumR(v[i..v.Length]) == SumR(v[0..v.Length])\n{\n  if i == v.Length {\n    assert v[i..v.Length] == [];\n    assert SumR(v[i..v.Length]) == 0;\n    assert v[0..i] == v[0..v.Length];\n  } else {\n    var fullSeq := v[0..v.Length];\n    var leftPart := v[0..i];\n    var rightPart := v[i..v.Length];\n    assert fullSeq == leftPart + rightPart;\n    SumRConcatenation(leftPart, rightPart);\n  }\n}\n\nlemma SumRConcatenation(s1: seq<int>, s2: seq<int>)\n  ensures SumR(s1 + s2) == SumR(s1) + SumR(s2)\n{\n  if s2 == [] {\n    assert s1 + s2 == s1;\n  } else if s1 == [] {\n    assert s1 + s2 == s2;\n  } else {\n    var combined := s1 + s2;\n    assert combined[..|combined|-1] == s1 + s2[..|s2|-1];\n    assert combined[|combined|-1] == s2[|s2|-1];\n    SumRConcatenation(s1, s2[..|s2|-1]);\n  }\n}\n\nlemma SumRUpdateLemma(v: array<int>, i: int, sum: int)\n  requires 0 <= i < v.Length\n  requires sum == SumR(v[0..i])\n  ensures sum + v[i] == SumR(v[0..i+1])\n{\n  if i == 0 {\n    assert v[0..0] == [];\n    assert SumR(v[0..0]) == 0;\n    assert v[0..1] == [v[0]];\n    assert SumR(v[0..1]) == v[0];\n  } else {\n    assert v[0..i+1][..|v[0..i+1]|-1] == v[0..i];\n    assert v[0..i+1][|v[0..i+1]|-1] == v[i];\n    assert SumR(v[0..i+1]) == SumR(v[0..i]) + v[i];\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumElemsB(v:array<int>) returns (sum:int)\n//ensures sum==SumL(v[0..v.Length])\nensures sum==SumR(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  sum := 0;\n  var i := 0;\n  \n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant sum == SumR(v[0..i])\n  {\n    SumRUpdateLemma(v, i, sum);\n    sum := sum + v[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_304_ElementAtIndexAfterRotation.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_304_ElementAtIndexAfterRotation.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementAtIndexAfterRotation(l: seq<int>, n: int, index: int) returns (element: int)\n    requires n >= 0\n    requires 0 <= index < |l|\n    ensures element == l[(index - n + |l|) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementAtIndexAfterRotation(l: seq<int>, n: int, index: int) returns (element: int)\n    requires n >= 0\n    requires 0 <= index < |l|\n    ensures element == l[(index - n + |l|) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n  var original_index := (index - n + |l|) % |l|;\n  element := l[original_index];\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpmvs2dmry_examples2_Product.dfy", "root", true, "", "", false, "Dafny_tmp_tmpmvs2dmry_examples2_Product.dfy", "// <vc-preamble>\nfunction gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Product(m: nat, n:nat) returns (res:nat)\nensures res == m*n;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Product(m: nat, n:nat) returns (res:nat)\nensures res == m*n;\n// </vc-spec>\n// <vc-code>\n{\n    res := 0;\n    var i := 0;\n    while (i < n)\n        invariant 0 <= i <= n\n        invariant res == m * i\n        decreases n - i\n    {\n        res := res + m;\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive.dfy", "// <vc-preamble>\npredicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  b := true;\n  var i := 0;\n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant b == positive(v[0..i])\n  {\n    if v[i] < 0 {\n      b := false;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate.dfy", "// <vc-preamble>\npredicate strictNegative(v:array<int>,i:int,j:int)\nreads v\nrequires 0<=i<=j<=v.Length\n{forall u | i<=u<j :: v[u]<0}\n\npredicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n\npredicate isPermutation(s:seq<int>, t:seq<int>)\n{multiset(s)==multiset(t)}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod separate(v:array<int>) returns (i:int)\nmodifies v\nensures 0<=i<=v.Length\nensures positive(v[0..i]) && strictNegative(v,i,v.Length)\nensures isPermutation(v[0..v.Length], old(v[0..v.Length]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate strictNegative(v:array<int>,i:int,j:int)\nreads v\nrequires 0<=i<=j<=v.Length\n{forall u | i<=u<j :: v[u]<0}\n\npredicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n\npredicate isPermutation(s:seq<int>, t:seq<int>)\n{multiset(s)==multiset(t)}\n\n/**\nreturns an index st new array is a permutation of the old array\npositive first and then strictnegative, i is the firs neg or len if not any */\n\n// <vc-helpers>\nlemma swapPreservesMultiset(s: seq<int>, i: int, j: int) returns (s': seq<int>)\n  requires 0 <= i < |s| && 0 <= j < |s|\n  ensures |s'| == |s|\n  ensures multiset(s) == multiset(s')\n  ensures s'[i] == s[j] && s'[j] == s[i]\n  ensures forall k :: 0 <= k < |s| && k != i && k != j ==> s'[k] == s[k]\n{\n  s' := s[i := s[j]][j := s[i]];\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod separate(v:array<int>) returns (i:int)\nmodifies v\nensures 0<=i<=v.Length\nensures positive(v[0..i]) && strictNegative(v,i,v.Length)\nensures isPermutation(v[0..v.Length], old(v[0..v.Length]))\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  var j := v.Length - 1;\n  \n  while i <= j\n    invariant 0 <= i <= j + 1 <= v.Length\n    invariant positive(v[0..i])\n    invariant strictNegative(v, j + 1, v.Length)\n    invariant multiset(v[0..v.Length]) == multiset(old(v[0..v.Length]))\n    decreases j - i\n  {\n    if v[i] >= 0 {\n      i := i + 1;\n    } else if v[j] < 0 {\n      j := j - 1;\n    } else {\n      var temp := v[i];\n      v[i] := v[j];\n      v[j] := temp;\n      i := i + 1;\n      j := j - 1;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_canyon_search_CanyonSearch.dfy", "root", true, "", "", false, "Clover_canyon_search_CanyonSearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d:nat)\n  requires a.Length !=0 && b.Length!=0\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  requires forall i,j :: 0<=i<j<b.Length ==> b[i]<=b[j]\n  ensures exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n  ensures forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d:nat)\n  requires a.Length !=0 && b.Length!=0\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  requires forall i,j :: 0<=i<j<b.Length ==> b[i]<=b[j]\n  ensures exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n  ensures forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n// </vc-spec>\n// <vc-code>\n{\n  var minDist := if a[0] < b[0] then (b[0] - a[0]) else (a[0] - b[0]);\n  var bestI := 0;\n  var bestJ := 0;\n  \n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant 0 <= bestI < a.Length && 0 <= bestJ < b.Length\n    invariant minDist == (if a[bestI] < b[bestJ] then (b[bestJ]-a[bestI]) else (a[bestI]-b[bestJ]))\n    invariant forall x,y :: 0<=x<i && 0<=y<b.Length ==> minDist <= (if a[x] < b[y] then (b[y]-a[x]) else (a[x]-b[y]))\n  {\n    var j := 0;\n    while j < b.Length\n      invariant 0 <= j <= b.Length\n      invariant 0 <= bestI < a.Length && 0 <= bestJ < b.Length\n      invariant minDist == (if a[bestI] < b[bestJ] then (b[bestJ]-a[bestI]) else (a[bestI]-b[bestJ]))\n      invariant forall x,y :: 0<=x<i && 0<=y<b.Length ==> minDist <= (if a[x] < b[y] then (b[y]-a[x]) else (a[x]-b[y]))\n      invariant forall y :: 0<=y<j ==> minDist <= (if a[i] < b[y] then (b[y]-a[i]) else (a[i]-b[y]))\n    {\n      var currentDist := if a[i] < b[j] then (b[j] - a[i]) else (a[i] - b[j]);\n      if currentDist < minDist {\n        minDist := currentDist;\n        bestI := i;\n        bestJ := j;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  \n  return minDist;\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Best_Time_to_Buy_and_Sell_Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Best_Time_to_Buy_and_Sell_Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_587_ArrayToSeq.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_587_ArrayToSeq.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArrayToSeq(a: array<int>) returns (s: seq<int>)\n    requires a != null\n    ensures |s| == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> s[i] == a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArrayToSeq(a: array<int>) returns (s: seq<int>)\n    requires a != null\n    ensures |s| == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> s[i] == a[i]\n// </vc-spec>\n// <vc-code>\n{\n  s := a[..];\n}\n// </vc-code>\n\n", "", "", ""], ["llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements.dfy", "root", true, "", "", false, "llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements.dfy", "// <vc-preamble>\nfunction abs(x: real): real\n{\n  if x < 0.0 then -x else x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (result: bool)\n    ensures result <==> exists i, j ::\n      0 <= i < |numbers| &&\n      0 <= j < |numbers| &&\n      i != j &&\n      abs(numbers[i] - numbers[j]) < threshold\n    ensures result ==> |numbers| > 1\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function abs(x: real): real\n{\n  if x < 0.0 then -x else x\n}\n\n// <vc-helpers>\nlemma abs_difference_symmetric(a: real, b: real)\n    ensures abs(a - b) == abs(b - a)\n{\n    if a >= b {\n        assert a - b >= 0.0;\n        assert b - a <= 0.0;\n        assert abs(a - b) == a - b;\n        assert abs(b - a) == -(b - a) == a - b;\n    } else {\n        assert a - b < 0.0;\n        assert b - a > 0.0;\n        assert abs(a - b) == -(a - b) == b - a;\n        assert abs(b - a) == b - a;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (result: bool)\n    ensures result <==> exists i, j ::\n      0 <= i < |numbers| &&\n      0 <= j < |numbers| &&\n      i != j &&\n      abs(numbers[i] - numbers[j]) < threshold\n    ensures result ==> |numbers| > 1\n// </vc-spec>\n// <vc-code>\n{\n    if |numbers| <= 1 {\n        return false;\n    }\n    \n    var i := 0;\n    while i < |numbers|\n        invariant 0 <= i <= |numbers|\n        invariant forall x, y :: 0 <= x < i && 0 <= y < |numbers| && x != y ==> abs(numbers[x] - numbers[y]) >= threshold\n    {\n        var j := 0;\n        while j < |numbers|\n            invariant 0 <= j <= |numbers|\n            invariant forall y :: 0 <= y < j && i != y ==> abs(numbers[i] - numbers[y]) >= threshold\n            invariant forall x, y :: 0 <= x < i && 0 <= y < |numbers| && x != y ==> abs(numbers[x] - numbers[y]) >= threshold\n        {\n            if i != j && abs(numbers[i] - numbers[j]) < threshold {\n                return true;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_return_seven_M.dfy", "root", true, "", "", false, "Clover_return_seven_M.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod M(x: int) returns (seven: int)\n  ensures seven==7\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod M(x: int) returns (seven: int)\n  ensures seven==7\n// </vc-spec>\n// <vc-code>\n{\n  seven := 7;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_557_ToggleCase.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_557_ToggleCase.dfy", "// <vc-preamble>\npredicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToggleCase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}\n\n// <vc-helpers>\nlemma ShiftMinus32Properties(c: char)\n    requires IsLowerCase(c)\n    ensures IsUpperCase(ShiftMinus32(c))\n    ensures IsLowerUpperPair(c, ShiftMinus32(c))\n{\n    assert 97 <= c as int <= 122;\n    assert 65 <= c as int - 32 <= 90;\n    assert IsUpperCase(ShiftMinus32(c));\n    assert (c as int) == (ShiftMinus32(c) as int) + 32;\n}\n\nlemma Shift32Properties(c: char)\n    requires IsUpperCase(c)\n    ensures IsLowerCase(Shift32(c))\n    ensures IsUpperLowerPair(c, Shift32(c))\n{\n    assert 65 <= c as int <= 90;\n    assert 97 <= c as int + 32 <= 122;\n    assert IsLowerCase(Shift32(c));\n    assert (c as int) == (Shift32(c) as int) - 32;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToggleCase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n    var result := \"\";\n    var i := 0;\n    \n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |result| == i\n        invariant forall j :: 0 <= j < i ==> \n            if IsLowerCase(s[j]) then IsLowerUpperPair(s[j], result[j]) \n            else if IsUpperCase(s[j]) then IsUpperLowerPair(s[j], result[j]) \n            else result[j] == s[j]\n    {\n        if IsLowerCase(s[i]) {\n            ShiftMinus32Properties(s[i]);\n            result := result + [ShiftMinus32(s[i])];\n        } else if IsUpperCase(s[i]) {\n            Shift32Properties(s[i]);\n            result := result + [Shift32(s[i])];\n        } else {\n            result := result + [s[i]];\n        }\n        i := i + 1;\n    }\n    \n    return result;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort.dfy", "// <vc-preamble>\nfunction multisets<T>(s: seq<T>): multiset<T>\n{\n    if |s| == 0 then multiset{} \n    else multiset{s[0]} + multiset(s[1..])\n}\n\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\n\nfunction multisets<T>(s: seq<T>): multiset<T>\n{\n    if |s| == 0 then multiset{} \n    else multiset{s[0]} + multiset(s[1..])\n}\n\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  assume{:axiom} false;\n}\n\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\n\n// <vc-helpers>\nlemma multiset_swap<T>(s: seq<T>, i: int, j: int)\n  requires 0 <= i < j < |s|\n  ensures multiset(s) == multiset(s[i := s[j]][j := s[i]])\n{\n  var s' := s[i := s[j]][j := s[i]];\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  assert forall k :: 0 <= k < |s| && k != i && k != j ==> s'[k] == s[k];\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length <= 1 { return; }\n  \n  var i := 0;\n  var j := a.Length - 1;\n  \n  while i < j\n    invariant 0 <= i <= j + 1 <= a.Length\n    invariant forall k :: 0 <= k < i ==> !a[k]\n    invariant forall k :: j < k < a.Length ==> a[k]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if !a[i] {\n      i := i + 1;\n    } else if a[j] {\n      j := j - 1;\n    } else {\n      multiset_swap(a[..], i, j);\n      swap(a, i, j);\n      i := i + 1;\n      j := j - 1;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_14_TriangularPrismVolume.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_14_TriangularPrismVolume.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod TriangularPrismVolume(base: int, height: int, length: int) returns (volume: int)\n    requires base > 0\n    requires height > 0\n    requires length > 0\n    ensures volume == (base * height * length) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod TriangularPrismVolume(base: int, height: int, length: int) returns (volume: int)\n    requires base > 0\n    requires height > 0\n    requires length > 0\n    ensures volume == (base * height * length) / 2\n// </vc-spec>\n// <vc-code>\n{\n  volume := (base * height * length) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_581_SquarePyramidSurfaceArea.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_581_SquarePyramidSurfaceArea.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SquarePyramidSurfaceArea(baseEdge: int, height: int) returns (area: int)\n    requires baseEdge > 0\n    requires height > 0\n    ensures area == baseEdge * baseEdge + 2 * baseEdge * height\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SquarePyramidSurfaceArea(baseEdge: int, height: int) returns (area: int)\n    requires baseEdge > 0\n    requires height > 0\n    ensures area == baseEdge * baseEdge + 2 * baseEdge * height\n// </vc-spec>\n// <vc-code>\n{\n  area := baseEdge * baseEdge + 2 * baseEdge * height;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_rotate_rotate.dfy", "root", true, "", "", false, "Clover_rotate_rotate.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod rotate(a: array<int>, offset:int) returns (b: array<int> )\n  requires 0<=offset\n  ensures b.Length==a.Length\n  ensures forall  i::0<=i<a.Length ==>  b[i]==a[(i+offset)%a.Length]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod rotate(a: array<int>, offset:int) returns (b: array<int> )\n  requires 0<=offset\n  ensures b.Length==a.Length\n  ensures forall  i::0<=i<a.Length ==>  b[i]==a[(i+offset)%a.Length]\n// </vc-spec>\n// <vc-code>\n{\n  b := new int[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> b[j] == a[(j + offset) % a.Length]\n  {\n    b[i] := a[(i + offset) % a.Length];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_array_product_arrayProduct.dfy", "root", true, "", "", false, "Clover_array_product_arrayProduct.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod arrayProduct(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] * b[i]==c[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod arrayProduct(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] * b[i]==c[i]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant c.Length == a.Length\n    invariant forall j :: 0 <= j < i ==> c[j] == a[j] * b[j]\n  {\n    c[i] := a[i] * b[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Getmini(a:array<int>) returns(mini:nat) \nrequires a.Length > 0\nensures 0 <= mini < a.Length\nensures forall x :: 0 <= x < a.Length ==> a[mini] <= a[x]\nensures forall x :: 0 <= x < mini ==> a[mini] < a[x]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Getmini(a:array<int>) returns(mini:nat) \nrequires a.Length > 0\nensures 0 <= mini < a.Length // mini is an index of a\nensures forall x :: 0 <= x < a.Length ==> a[mini] <= a[x] // a[mini] is the minimum value\nensures forall x :: 0 <= x < mini ==> a[mini] < a[x] // a[mini] is the first min\n// </vc-spec>\n// <vc-code>\n{\n  mini := 0;\n  var i := 1;\n  \n  while i < a.Length\n    invariant 0 <= mini < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> a[mini] <= a[x]\n    invariant forall x :: 0 <= x < mini ==> a[mini] < a[x]\n  {\n    if a[i] < a[mini] {\n      mini := i;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter.dfy", "root", true, "", "", false, "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter.dfy", "// <vc-preamble>\ndatatype Bases = A | C | G | T\n\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n{\n  assume{:axiom} false;\n}\n\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sorter(bases: seq<Bases>) returns (sobases:seq<Bases>)\nrequires 0 < |bases|\nensures |sobases| == |bases|\nensures bordered(sobases)\nensures multiset(bases) == multiset(sobases);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// see pdf 'ex6 & 7 documentation' for excercise question\n\n\ndatatype Bases = A | C | G | T\n\n//swaps two sequence indexes\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n{\n  assume{:axiom} false;\n}\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\n//checks if a sequence is in base order\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}\n\n// <vc-helpers>\nlemma BelowTransitive(x: Bases, y: Bases, z: Bases)\n    requires below(x, y) && below(y, z)\n    ensures below(x, z)\n{\n}\n\nlemma BelowReflexive(x: Bases)\n    ensures below(x, x)\n{\n}\n\nlemma BelowTotal(x: Bases, y: Bases)\n    ensures below(x, y) || below(y, x)\n{\n}\n\nlemma BorderedSlice(s: seq<Bases>, i: nat, j: nat)\n    requires bordered(s)\n    requires 0 <= i <= j <= |s|\n    ensures bordered(s[i..j])\n{\n}\n\nlemma BorderedConcat(s1: seq<Bases>, s2: seq<Bases>)\n    requires bordered(s1) && bordered(s2)\n    requires |s1| == 0 || |s2| == 0 || below(s1[|s1|-1], s2[0])\n    ensures bordered(s1 + s2)\n{\n}\n\nlemma MultisetConcat(s1: seq<Bases>, s2: seq<Bases>)\n    ensures multiset(s1 + s2) == multiset(s1) + multiset(s2)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sorter(bases: seq<Bases>) returns (sobases:seq<Bases>)\nrequires 0 < |bases|\nensures |sobases| == |bases|\nensures bordered(sobases)\nensures multiset(bases) == multiset(sobases);\n// </vc-spec>\n// <vc-code>\n{\n    sobases := bases;\n    var i := 0;\n    \n    while i < |sobases|\n        invariant 0 <= i <= |sobases|\n        invariant |sobases| == |bases|\n        invariant multiset(sobases) == multiset(bases)\n        invariant bordered(sobases[0..i])\n        invariant forall x, y :: 0 <= x < i && i <= y < |sobases| ==> below(sobases[x], sobases[y])\n    {\n        var minIndex := i;\n        var j := i + 1;\n        \n        while j < |sobases|\n            invariant i <= minIndex < |sobases|\n            invariant i <= j <= |sobases|\n            invariant forall k :: i <= k < j ==> below(sobases[minIndex], sobases[k])\n        {\n            if !below(sobases[minIndex], sobases[j]) {\n                minIndex := j;\n            }\n            j := j + 1;\n        }\n        \n        if minIndex != i {\n            sobases := Exchanger(sobases, i, minIndex);\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_799_RotateLeftBits.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_799_RotateLeftBits.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RotateLeftBits(n: bv32, d: int) returns (result: bv32)\n    requires 0 <= d < 32\n    ensures result == ((n << d) | (n >> (32 - d)))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod RotateLeftBits(n: bv32, d: int) returns (result: bv32)\n    requires 0 <= d < 32\n    ensures result == ((n << d) | (n >> (32 - d)))\n// </vc-spec>\n// <vc-code>\n{\n  result := (n << d) | (n >> (32 - d));\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Symmetric(a: array<int>) returns (flag: bool)\nensures flag == true ==> forall x :: 0 <= x < a.Length ==> a[x] == a[a.Length - x - 1]\nensures flag == false ==> exists x :: 0 <= x < a.Length && a[x] != a[a.Length - x - 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Symmetric(a: array<int>) returns (flag: bool)\nensures flag == true ==> forall x :: 0 <= x < a.Length ==> a[x] == a[a.Length - x - 1]\nensures flag == false ==> exists x :: 0 <= x < a.Length && a[x] != a[a.Length - x - 1]\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length == 0 {\n    return true;\n  }\n  \n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall x :: 0 <= x < i ==> a[x] == a[a.Length - x - 1]\n  {\n    if a[i] != a[a.Length - i - 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting.dfy", "// <vc-preamble>\npredicate InsertionSorted(Array: array<int>, left: int, right: int)  \n  requires 0 <= left <= right <= Array.Length       \n  reads Array       \n{           \n  forall i,j :: left <= i < j < right ==> Array[i] <= Array[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sorting(Array: array<int>)\n  requires Array.Length > 1 \n  ensures InsertionSorted(Array, 0, Array.Length) \n  modifies Array\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate InsertionSorted(Array: array<int>, left: int, right: int)  \n  requires 0 <= left <= right <= Array.Length       \n  reads Array       \n{           \n  forall i,j :: left <= i < j < right ==> Array[i] <= Array[j]\n}\n\n// <vc-helpers>\nlemma InsertionSortedExtend(Array: array<int>, left: int, right: int)\n  requires 0 <= left <= right < Array.Length\n  requires InsertionSorted(Array, left, right)\n  requires forall k :: left <= k < right ==> Array[k] <= Array[right]\n  ensures InsertionSorted(Array, left, right + 1)\n{\n}\n\nlemma InsertionSortedShift(Array: array<int>, left: int, right: int, pos: int, val: int)\n  requires 0 <= left <= pos < right <= Array.Length\n  requires InsertionSorted(Array, left, right)\n  requires forall k {:trigger Array[k]} :: left <= k <= pos ==> val <= Array[k]\n  requires forall k {:trigger Array[k]} :: pos < k < right ==> Array[k-1] <= val\n  ensures InsertionSorted(Array, left, right)\n{\n}\n\nlemma InsertionSortedAfterInsert(Array: array<int>, i: int, key: int, j: int)\n  requires 0 <= j + 1 <= i < Array.Length\n  requires InsertionSorted(Array, 0, j + 1)\n  requires forall k :: j + 2 <= k <= i ==> Array[k] >= key\n  requires j >= 0 ==> Array[j] <= key\n  requires Array[j + 1] == key\n  requires forall k :: j + 2 <= k <= i ==> Array[k-1] <= Array[k]\n  ensures InsertionSorted(Array, 0, i + 1)\n{\n  forall x, y | 0 <= x < y < i + 1 ensures Array[x] <= Array[y]\n  {\n    if y == j + 1 {\n      if x <= j {\n        if j >= 0 {\n          assert Array[x] <= Array[j] <= key;\n        } else {\n          assert x == 0 && y == 0;\n          assert false;\n        }\n      }\n    } else if x == j + 1 {\n      assert Array[j + 1] == key;\n      assert Array[y] >= key;\n    } else if x <= j && y > j + 1 {\n      assert Array[x] <= Array[j] <= key <= Array[y];\n    } else if x > j + 1 && y > j + 1 {\n      assert x >= j + 2 && y >= j + 2;\n      assert x - 1 >= j + 1 && y - 1 >= j + 1;\n      assert Array[x-1] <= Array[y-1];\n    } else {\n      assert x < y <= j + 1;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sorting(Array: array<int>)\n  requires Array.Length > 1 \n  ensures InsertionSorted(Array, 0, Array.Length) \n  modifies Array\n// </vc-spec>\n// <vc-code>\n{\n  var i := 1;\n  while i < Array.Length\n    invariant 1 <= i <= Array.Length\n    invariant InsertionSorted(Array, 0, i)\n  {\n    var key := Array[i];\n    var j := i - 1;\n    \n    while j >= 0 && Array[j] > key\n      invariant -1 <= j < i\n      invariant forall k :: j + 2 <= k <= i ==> Array[k] >= key\n      invariant InsertionSorted(Array, 0, j + 1)\n      invariant forall k :: j + 2 <= k <= i ==> Array[k-1] <= Array[k]\n    {\n      Array[j + 1] := Array[j];\n      j := j - 1;\n    }\n    \n    Array[j + 1] := key;\n    \n    assert j >= 0 ==> Array[j] <= key;\n    assert Array[j + 1] == key;\n    assert forall k :: j + 2 <= k <= i ==> Array[k] >= key;\n    assert forall k :: j + 2 <= k <= i ==> Array[k-1] <= Array[k];\n    InsertionSortedAfterInsert(Array, i, key, j);\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_426_FilterOddNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_426_FilterOddNumbers.dfy", "// <vc-preamble>\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FilterOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n\n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n * Filter odd numbers from an array of numbers\n **/\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\n// <vc-helpers>\nlemma InSeqAfterAppend<T>(s: seq<T>, x: T, y: T)\n    ensures y in s ==> y in (s + [x])\n{\n}\n\nlemma InSeqFromAppend<T>(s: seq<T>, x: T, y: T)\n    ensures y in (s + [x]) ==> (y in s || y == x)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FilterOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>\n// <vc-code>\n{\n    oddList := [];\n    var i := 0;\n    \n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant forall j :: 0 <= j < |oddList| ==> IsOdd(oddList[j]) && oddList[j] in arr[..]\n        invariant forall j :: 0 <= j < i && IsOdd(arr[j]) ==> arr[j] in oddList\n    {\n        if IsOdd(arr[i]) {\n            oddList := oddList + [arr[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_170_SumInRange.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_170_SumInRange.dfy", "// <vc-preamble>\nfunction sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n// </vc-spec>\n// <vc-code>\n{\n    sum := 0;\n    var i := start;\n    while i < end\n        invariant start <= i <= end\n        invariant sum == sumTo(a, start, i)\n    {\n        sum := sum + a[i];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_452_CalculateLoss.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_452_CalculateLoss.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CalculateLoss(costPrice: int, sellingPrice: int) returns (loss: int)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) && (costPrice <= sellingPrice ==> loss == 0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CalculateLoss(costPrice: int, sellingPrice: int) returns (loss: int)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) && (costPrice <= sellingPrice ==> loss == 0)\n// </vc-spec>\n// <vc-code>\n{\n  if costPrice > sellingPrice {\n    loss := costPrice - sellingPrice;\n  } else {\n    loss := 0;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_linear_search1_LinearSearch.dfy", "root", true, "", "", false, "Clover_linear_search1_LinearSearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n// </vc-spec>\n// <vc-code>\n{\n  n := 0;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] != e\n  {\n    if a[n] == e {\n      return;\n    }\n    n := n + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_bubble_sort.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_bubble_sort.dfy", "// <vc-preamble>\npredicate sorted(a: array2<int>, l: int, u: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length0 ==> a[i, 1] <= a[j, 1]\n}\n\npredicate partitioned(a: array2<int>, i: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall k, k' :: 0 <= k <= i < k' < a.Length0 ==> a[k, 1] <= a[k', 1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubble_sort(a: array2<int>)\n    modifies a\n    requires a.Length1 == 2\n    ensures sorted(a, 0, a.Length0 - 1)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Clover_triple_Triple.dfy", "root", true, "", "", false, "Clover_triple_Triple.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  r := 3 * x;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative.dfy", "root", true, "", "", false, "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative.dfy", "// <vc-preamble>\nfunction Fibonacci(n: nat): nat {\n  match n {\n    case 0 => 0\n    case 1 => 1\n    case _ => Fibonacci(n - 1) + Fibonacci(n - 2)\n  }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FibonacciIterative(n: nat) returns (f: nat)\n  ensures f == Fibonacci(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// definition of Fibonacci numbers\nfunction Fibonacci(n: nat): nat {\n  match n {\n    case 0 => 0\n    case 1 => 1\n    case _ => Fibonacci(n - 1) + Fibonacci(n - 2)\n  }\n}\n\n// iterative calculation of Fibonacci numbers\n\n// <vc-helpers>\nlemma FibonacciIterativeCorreness(n: nat, a: nat, b: nat, i: nat)\n  requires i <= n\n  requires a == Fibonacci(i)\n  requires b == Fibonacci(i + 1)\n  ensures Fibonacci(n) == FibonacciIterativeHelper(n, a, b, i)\n  decreases n - i\n{\n  if i == n {\n    assert FibonacciIterativeHelper(n, a, b, i) == a;\n    assert a == Fibonacci(i);\n    assert i == n;\n  } else {\n    FibonacciIterativeCorreness(n, b, a + b, i + 1);\n  }\n}\n\nfunction FibonacciIterativeHelper(n: nat, a: nat, b: nat, i: nat): nat\n  requires i <= n\n  decreases n - i\n{\n  if i == n then a\n  else FibonacciIterativeHelper(n, b, a + b, i + 1)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FibonacciIterative(n: nat) returns (f: nat)\n  ensures f == Fibonacci(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    return 0;\n  } else if n == 1 {\n    return 1;\n  } else {\n    var a := 0;\n    var b := 1;\n    var i := 0;\n    \n    while i < n\n      invariant i <= n\n      invariant a == Fibonacci(i)\n      invariant b == Fibonacci(i + 1)\n      decreases n - i\n    {\n      var temp := a + b;\n      a := b;\n      b := temp;\n      i := i + 1;\n    }\n    \n    FibonacciIterativeCorreness(n, a, b, i);\n    return a;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_InsertionSort_InsertionSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_InsertionSort_InsertionSort.dfy", "// <vc-preamble>\npredicate sorted (a:array<int>, start:int, end:int)\n requires a!=null       \n requires 0<=start<=end<=a.Length       \n reads a       \n {           \n   forall j,k:: start<=j<k<end ==> a[j]<=a[k]\n }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertionSort (a:array<int>)\nrequires a!=null && a.Length>1 \nensures sorted(a, 0, a.Length) \nmodifies a\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySum (a : array<int>, b : array<int>) returns (c : array<int>)\n    requires a.Length == b.Length\n    ensures c.Length == a.Length && \n        forall i : int :: 0 <= i < c.Length ==> c[i] == a[i] + b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySum (a : array<int>, b : array<int>) returns (c : array<int>)\n    requires a.Length == b.Length\n    ensures c.Length == a.Length && \n        forall i : int :: 0 <= i < c.Length ==> c[i] == a[i] + b[i] // TODO\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant c.Length == a.Length\n    invariant forall k : int :: 0 <= k < i ==> c[k] == a[k] + b[k]\n  {\n    c[i] := a[i] + b[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "", "", ""], ["llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve.dfy", "root", true, "", "", false, "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve.dfy", "// <vc-preamble>\nfunction IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\n\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\n\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\n\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i]\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\n\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\n\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\n\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i]\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma NoLettersEquivalent(s: string)\n  ensures NoLetters(s, |s|) <==> forall i :: 0 <= i < |s| ==> !IsLetter(s[i])\n{\n}\n\nlemma ToggleCasePreservesLength(s: string)\n  ensures |s| == |seq(|s|, i requires 0 <= i < |s| => ToggleCase(s[i]))|\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s)\n// </vc-spec>\n// <vc-code>\n{\n  if NoLetters(s, |s|) {\n    var s_seq := seq(|s|, i requires 0 <= i < |s| => s[i]);\n    var reversed_seq := Reverse(s_seq);\n    result := reversed_seq;\n  } else {\n    result := seq(|s|, i requires 0 <= i < |s| => if IsLetter(s[i]) then ToggleCase(s[i]) else s[i]);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_234_CubeVolume.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_234_CubeVolume.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CubeVolume(size: int) returns (volume: int)\n    requires size > 0\n    ensures volume == size * size * size\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CubeVolume(size: int) returns (volume: int)\n    requires size > 0\n    ensures volume == size * size * size\n// </vc-spec>\n// <vc-code>\n{\n  volume := size * size * size;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple.dfy", "// <vc-preamble>\npredicate triple(a: array<int>) \nreads a\n{\n    exists i :: 0 <= i < a.Length - 2 && a[i] == a[i + 1] == a[i + 2]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetTriple(a: array<int>) returns (index: int)\nensures 0 <= index < a.Length - 2 || index == a.Length\nensures index == a.Length <==> !triple(a)\nensures 0 <= index < a.Length - 2 <==> triple(a)\nensures 0 <= index < a.Length - 2 ==> a[index] == a[index + 1] == a[index + 2]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate triple(a: array<int>) \nreads a\n{\n    exists i :: 0 <= i < a.Length - 2 && a[i] == a[i + 1] == a[i + 2]\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetTriple(a: array<int>) returns (index: int)\nensures 0 <= index < a.Length - 2 || index == a.Length\nensures index == a.Length <==> !triple(a)\nensures 0 <= index < a.Length - 2 <==> triple(a)\nensures 0 <= index < a.Length - 2 ==> a[index] == a[index + 1] == a[index + 2]\n// </vc-spec>\n// <vc-code>\n{\n    index := 0;\n    while index < a.Length - 2\n        invariant 0 <= index <= a.Length\n        invariant forall j :: 0 <= j < index && j + 2 < a.Length ==> !(a[j] == a[j + 1] == a[j + 2])\n    {\n        if a[index] == a[index + 1] == a[index + 2] {\n            return;\n        }\n        index := index + 1;\n    }\n    index := a.Length;\n}\n// </vc-code>\n\n", "", "", ""], ["se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest.dfy", "root", true, "", "", false, "se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SecondLargest(a:array<int>) returns (seclar:int)\nrequires a.Length > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ex2\n\n// this was me playing around to try and get an ensures for the method \n/*predicate method check(a: array<int>, seclar:int)\nrequires a.Length > 0\nreads a\n{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */\n\n// <vc-helpers>\npredicate IsSecondLargest(a: array<int>, seclar: int)\nreads a\n{\n  exists largest_idx :: 0 <= largest_idx < a.Length &&\n    (forall k :: 0 <= k < a.Length ==> a[k] <= a[largest_idx]) &&\n    (seclar < a[largest_idx]) &&\n    (forall k :: 0 <= k < a.Length && a[k] != a[largest_idx] ==> a[k] <= seclar) &&\n    (exists k :: 0 <= k < a.Length && a[k] == seclar)\n}\n\nlemma FindMaxIndex(a: array<int>) returns (max_idx: int)\nrequires a.Length > 0\nensures 0 <= max_idx < a.Length\nensures forall k :: 0 <= k < a.Length ==> a[k] <= a[max_idx]\n{\n  max_idx := 0;\n  var i := 1;\n  while i < a.Length\n    invariant 0 <= max_idx < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] <= a[max_idx]\n  {\n    if a[i] > a[max_idx] {\n      max_idx := i;\n    }\n    i := i + 1;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SecondLargest(a:array<int>) returns (seclar:int)\nrequires a.Length > 0\n//ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])\n// </vc-spec>\n// <vc-code>\n{\n  var max_val := a[0];\n  var max_idx := 0;\n  var i := 1;\n  \n  while i < a.Length\n    invariant 0 <= max_idx < a.Length\n    invariant 1 <= i <= a.Length\n    invariant max_val == a[max_idx]\n    invariant forall k :: 0 <= k < i ==> a[k] <= max_val\n  {\n    if a[i] > max_val {\n      max_val := a[i];\n      max_idx := i;\n    }\n    i := i + 1;\n  }\n  \n  seclar := a[0];\n  if a[0] == max_val && a.Length > 1 {\n    seclar := a[1];\n  }\n  \n  i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i && a[k] != max_val ==> a[k] <= seclar\n    invariant exists k :: 0 <= k < a.Length && a[k] == seclar\n  {\n    if a[i] != max_val && a[i] > seclar {\n      seclar := a[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DifferenceSumCubesAndSumNumbers(n: int) returns (diff: int)\n    requires n >= 0\n    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nfunction SumOfNumbers(n: int): int\n    requires n >= 0\n{\n    n * (n + 1) / 2\n}\n\nfunction SumOfCubes(n: int): int\n    requires n >= 0\n{\n    var sum := SumOfNumbers(n);\n    sum * sum\n}\n\nlemma SumOfCubesFormula(n: int)\n    requires n >= 0\n    ensures SumOfCubes(n) == (n * n * (n + 1) * (n + 1)) / 4\n{\n    var sum := SumOfNumbers(n);\n    assert sum == n * (n + 1) / 2;\n    assert SumOfCubes(n) == sum * sum;\n    assert sum * sum == (n * (n + 1) / 2) * (n * (n + 1) / 2);\n    MultiplicationExpansionLemma(n);\n    assert (n * (n + 1) / 2) * (n * (n + 1) / 2) == (n * n * (n + 1) * (n + 1)) / 4;\n}\n\nlemma MultiplicationExpansionLemma(n: int)\n    requires n >= 0\n    ensures (n * (n + 1) / 2) * (n * (n + 1) / 2) == (n * n * (n + 1) * (n + 1)) / 4\n{\n    var a := n * (n + 1);\n    var b := 2;\n    SquareExpansionLemma(a, b);\n    calc {\n        (n * (n + 1) / 2) * (n * (n + 1) / 2);\n        == (a / b) * (a / b);\n        == { SquareExpansionLemma(a, b); }\n        (a * a) / (b * b);\n        == (n * (n + 1)) * (n * (n + 1)) / 4;\n        == (n * n * (n + 1) * (n + 1)) / 4;\n    }\n}\n\nlemma SquareExpansionLemma(a: int, b: int)\n    requires b != 0\n    ensures (a / b) * (a / b) == (a * a) / (b * b)\n    decreases if a >= 0 then a else -a, if b >= 0 then b else -b\n{\n    if a >= 0 && b > 0 {\n        var q := a / b;\n        var r := a % b;\n        assert a == q * b + r && 0 <= r < b;\n        assert a * a == (q * b + r) * (q * b + r);\n        assert a * a == q * q * b * b + 2 * q * b * r + r * r;\n        assert (a * a) / (b * b) == (q * q * b * b + 2 * q * b * r + r * r) / (b * b);\n        assert (a * a) / (b * b) == q * q + (2 * q * b * r + r * r) / (b * b);\n        assert 2 * q * b * r + r * r < b * b by {\n            assert r < b;\n            assert r * r < b * b;\n            assert 2 * q * b * r + r * r <= 2 * q * b * (b - 1) + (b - 1) * (b - 1);\n            if q == 0 {\n                assert 2 * q * b * r + r * r == r * r < b * b;\n            } else {\n                calc {\n                    2 * q * b * r + r * r;\n                    <= 2 * q * b * (b - 1) + (b - 1) * (b - 1);\n                    == 2 * q * b * b - 2 * q * b + b * b - 2 * b + 1;\n                    == b * b * (2 * q + 1) - 2 * b * (q + 1) + 1;\n                }\n                if q >= 1 {\n                    assert 2 * q * b * r + r * r < b * b;\n                }\n            }\n        }\n        assert (2 * q * b * r + r * r) / (b * b) == 0;\n        assert (a * a) / (b * b) == q * q;\n        assert q * q == (a / b) * (a / b);\n    } else if a < 0 && b > 0 {\n        SquareExpansionLemma(-a, b);\n        assert ((-a) / b) * ((-a) / b) == ((-a) * (-a)) / (b * b);\n        assert ((-a) * (-a)) == a * a;\n        assert (a / b) * (a / b) == ((-a) / b) * ((-a) / b);\n    } else if a >= 0 && b < 0 {\n        SquareExpansionLemma(a, -b);\n        assert (a / (-b)) * (a / (-b)) == (a * a) / ((-b) * (-b));\n        assert ((-b) * (-b)) == b * b;\n        assert (a / b) * (a / b) == (a / (-b)) * (a / (-b));\n    } else {\n        SquareExpansionLemma(-a, -b);\n        assert ((-a) / (-b)) * ((-a) / (-b)) == ((-a) * (-a)) / ((-b) * (-b));\n        assert ((-a) * (-a)) == a * a;\n        assert ((-b) * (-b)) == b * b;\n        assert (a / b) * (a / b) == ((-a) / (-b)) * ((-a) / (-b));\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DifferenceSumCubesAndSumNumbers(n: int) returns (diff: int)\n    requires n >= 0\n    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2\n// </vc-spec>\n// <vc-code>\n{\n    var sumOfNumbers := n * (n + 1) / 2;\n    var sumOfCubes := sumOfNumbers * sumOfNumbers;\n    \n    SumOfCubesFormula(n);\n    \n    diff := sumOfCubes - sumOfNumbers;\n}\n// </vc-code>\n\n", "", "", ""], ["assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange.dfy", "root", true, "", "", false, "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}\n\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindRange(q: seq<int>, key: int) returns (left: nat, right: nat)\n    requires Sorted(q)\n    ensures left <= right <= |q|\n    ensures forall i :: 0 <= i < left ==> q[i] < key\n    ensures forall i :: left <= i < right ==> q[i] == key\n    ensures forall i :: right <= i < |q| ==> q[i] > key\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}\n\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n    // comparer is '>' or '>='\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma GreaterThanComparerProperties(n1: int, n2: int)\n    ensures (n1 > n2) == !(n1 <= n2)\n    ensures (n1 >= n2) == !(n1 < n2)\n{\n}\n\nlemma SortedTransitivity(q: seq<int>, i: int, j: int, k: int)\n    requires Sorted(q)\n    requires 0 <= i <= j <= k < |q|\n    ensures q[i] <= q[j] <= q[k]\n{\n}\n\nlemma BinarySearchLeftCorrectness(q: seq<int>, key: int)\n    requires Sorted(q)\n    ensures forall i :: 0 <= i < |q| && q[i] < key ==> !(q[i] >= key)\n    ensures forall i :: 0 <= i < |q| && q[i] >= key ==> q[i] >= key\n{\n}\n\nlemma BinarySearchRightCorrectness(q: seq<int>, key: int)\n    requires Sorted(q)\n    ensures forall i :: 0 <= i < |q| && q[i] <= key ==> !(q[i] > key)\n    ensures forall i :: 0 <= i < |q| && q[i] > key ==> q[i] > key\n{\n}\n\nlemma RangeComparerEquivalence(q: seq<int>, key: int, lb: nat, ub: nat)\n    requires 0 <= lb <= ub <= |q|\n    ensures RangeSatisfiesComparer(q, key, lb, ub, (n1, n2) => n1 >= n2) <==> (forall i :: lb <= i < ub ==> q[i] >= key)\n    ensures RangeSatisfiesComparerNegation(q, key, lb, ub, (n1, n2) => n1 >= n2) <==> (forall i :: lb <= i < ub ==> q[i] < key)\n    ensures RangeSatisfiesComparer(q, key, lb, ub, (n1, n2) => n1 > n2) <==> (forall i :: lb <= i < ub ==> q[i] > key)\n    ensures RangeSatisfiesComparerNegation(q, key, lb, ub, (n1, n2) => n1 > n2) <==> (forall i :: lb <= i < ub ==> q[i] <= key)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindRange(q: seq<int>, key: int) returns (left: nat, right: nat)\n    requires Sorted(q)\n    ensures left <= right <= |q|\n    ensures forall i :: 0 <= i < left ==> q[i] < key\n    ensures forall i :: left <= i < right ==> q[i] == key\n    ensures forall i :: right <= i < |q| ==> q[i] > key\n// </vc-spec>\n// <vc-code>\n{\n    BinarySearchLeftCorrectness(q, key);\n    var leftIndex := BinarySearch(q, key, 0, |q|, (n1, n2) => n1 >= n2);\n    \n    BinarySearchRightCorrectness(q, key);\n    var rightIndex := BinarySearch(q, key, leftIndex, |q|, (n1, n2) => n1 > n2);\n    \n    RangeComparerEquivalence(q, key, 0, leftIndex);\n    RangeComparerEquivalence(q, key, leftIndex, |q|);\n    RangeComparerEquivalence(q, key, rightIndex, |q|);\n    \n    return leftIndex, rightIndex;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AreaOfLargestTriangleInSemicircle(radius: int) returns (area: int)\n    requires radius > 0\n    ensures area == radius * radius\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AreaOfLargestTriangleInSemicircle(radius: int) returns (area: int)\n    requires radius > 0\n    ensures area == radius * radius\n// </vc-spec>\n// <vc-code>\n{\n  area := radius * radius;\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength.dfy", "root", true, "", "", false, "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength.dfy", "// <vc-preamble>\npredicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\n// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\npredicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\nlemma EmptyStringIsSubstring(str: string)\n    ensures isSubstringPred(\"\", str)\n{\n    assert isPrefixPred(\"\", str[0..]);\n    assert isSubstringPred(\"\", str);\n}\n\nlemma EmptySubstringExists(str1: string, str2: string)\n    ensures haveCommonKSubstringPred(0, str1, str2)\n{\n    EmptyStringIsSubstring(str2);\n    assert str1[0..0] == \"\";\n    assert isSubstringPred(str1[0..0], str2);\n    assert haveCommonKSubstringPred(0, str1, str2);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n    var k := |str1|;\n    while k > 0\n        invariant 0 <= k <= |str1|\n        invariant forall j :: k < j <= |str1| ==> !haveCommonKSubstringPred(j, str1, str2)\n        decreases k\n    {\n        var result := haveCommonKSubstring(k, str1, str2);\n        if result {\n            return k;\n        }\n        k := k - 1;\n    }\n    \n    EmptySubstringExists(str1, str2);\n    return 0;\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange.dfy", "// <vc-preamble>\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod strange()\nensures 1==2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn \u2208 \u2115 => sqn = 0*0 \u2227 i = 0 \u2227 x=? \u2227 i\u2264n \nn >= 0 => 0 = 0*0 \u2227 i = 0 \u2227 i\u2264n \nn >= 0 => 0 = 0*0 \u2227 0 \u2264 n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n \u2227 i+1 \u2264 n \u2227 sqn = i * i \u21d2 sqn = sqn + x \u2227 i = i + 1 \u2227 x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: \u00ac(i < n) \u2227 i \u2264 n \u2227 sqn = i * i \u21d2 sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 \u2264 n\n2. true, i < n => i + 1 <= n\n3. true, \u00ac(i < n) \u2227 i \u2264 n \u2227 sqn = i * i \u21d2 sqn = n * n since \u00ac(i < n) \u2227 i \u2264 n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod strange()\nensures 1==2\n// </vc-spec>\n// <vc-code>\n{\n  var x:nat := 4; \n  var c := q(x,2*x);\n  assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_457_MinLengthSublist.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_457_MinLengthSublist.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinLengthSublist(s: seq<seq<int>>) returns (minSublist: seq<int>)\n    requires |s| > 0\n    ensures minSublist in s\n    ensures forall sublist :: sublist in s ==> |minSublist| <= |sublist|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinLengthSublist(s: seq<seq<int>>) returns (minSublist: seq<int>)\n    requires |s| > 0\n    ensures minSublist in s\n    ensures forall sublist :: sublist in s ==> |minSublist| <= |sublist|\n// </vc-spec>\n// <vc-code>\n{\n    minSublist := s[0];\n    var i := 1;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant minSublist in s\n        invariant forall j :: 0 <= j < i ==> |minSublist| <= |s[j]|\n    {\n        if |s[i]| < |minSublist| {\n            minSublist := s[i];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch.dfy", "root", true, "", "", false, "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch.dfy", "// <vc-preamble>\npredicate isSorted(a:array<int>)\n  reads a\n{\n  forall i:nat, j:nat :: i <= j < a.Length ==> a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod binSearch(a:array<int>, K:int) returns (b:bool)\n  requires isSorted(a)\n  ensures b == exists i:nat :: i < a.Length && a[i] == K\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "///////////////////\n// Binary search\n///////////////////\n\n\npredicate isSorted(a:array<int>)\n  reads a\n{\n  forall i:nat, j:nat :: i <= j < a.Length ==> a[i] <= a[j]\n}\n\n\n// a[lo] <= a[lo+1] <= ... <= a[hi-2] <= a[hi-1]\n\n/* Note: the following definition of isSorted:\n\n\nalthough equivalent to the one above is not enough for Dafny to be able \nto prove the invariants for the loop in binSearch.\n\nThe given one works because it *explicitly* states that every element \nof the input array is smaller than or equal to all later elements. \nThis fact is implied by the alternative definition of isSorted given \nhere (which only talks about array elements and their successors). \nHowever, it needs to be derived as an auxiliary lemma first, something \nthat Dafny is not currently able to do automatically. \n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod binSearch(a:array<int>, K:int) returns (b:bool)\n  requires isSorted(a)\n  ensures b == exists i:nat :: i < a.Length && a[i] == K\n// </vc-spec>\n// <vc-code>\n{\n  var lo := 0;\n  var hi := a.Length;\n  \n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] < K\n    invariant forall i :: hi <= i < a.Length ==> a[i] > K\n  {\n    var mid := (lo + hi) / 2;\n    \n    if a[mid] < K {\n      lo := mid + 1;\n    } else if a[mid] > K {\n      hi := mid;\n    } else {\n      return true;\n    }\n  }\n  \n  return false;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_absIt_AbsIt.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_absIt_AbsIt.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AbsIt(s: array<int>) \nmodifies s\nensures forall i :: 0 <= i < s.Length ==> if old(s[i]) < 0 then s[i] == -old(s[i]) else s[i] == old(s[i])\nensures s.Length == old(s).Length\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AbsIt(s: array<int>) \nmodifies s\nensures forall i :: 0 <= i < s.Length ==> if old(s[i]) < 0 then s[i] == -old(s[i]) else s[i] == old(s[i])\nensures s.Length == old(s).Length\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> if old(s[j]) < 0 then s[j] == -old(s[j]) else s[j] == old(s[j])\n    invariant forall j :: i <= j < s.Length ==> s[j] == old(s[j])\n  {\n    if s[i] < 0 {\n      s[i] := -s[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems.dfy", "// <vc-preamble>\nfunction SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {\n    SumR(v[c..f])\n  }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumElems(v:array<int>) returns (sum:int)\nensures sum==SumR(v[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {\n    SumR(v[c..f])\n  }\n\n// <vc-helpers>\nlemma SumREquivalence(s: seq<int>)\n  ensures SumR(s) == SumL(s)\n  decreases |s|\n{\n  if s == [] {\n    // Base case: both return 0\n  } else {\n    // Inductive case\n    SumREquivalence(s[1..]);\n    // Now we know SumR(s[1..]) == SumL(s[1..])\n    // We need to show SumR(s) == SumL(s)\n    // SumR(s) = SumR(s[..|s|-1]) + s[|s|-1]\n    // SumL(s) = s[0] + SumL(s[1..])\n    // We need to show SumR(s[..|s|-1]) + s[|s|-1] == s[0] + SumL(s[1..])\n    // Since SumR(s[1..]) == SumL(s[1..]), we need SumR(s[..|s|-1]) + s[|s|-1] == s[0] + SumR(s[1..])\n    SumRShift(s);\n  }\n}\n\nlemma SumRShift(s: seq<int>)\n  requires |s| > 0\n  ensures SumR(s[..|s|-1]) + s[|s|-1] == s[0] + SumR(s[1..])\n  decreases |s|\n{\n  if |s| == 1 {\n    assert s[..|s|-1] == [];\n    assert s[1..] == [];\n    assert SumR([]) == 0;\n  } else {\n    // Inductive case: |s| >= 2\n    var tail := s[1..];\n    assert |tail| == |s| - 1;\n    assert |tail| > 0;\n    \n    // Apply induction hypothesis to tail\n    SumRShift(tail);\n    // This gives us: SumR(tail[..|tail|-1]) + tail[|tail|-1] == tail[0] + SumR(tail[1..])\n    \n    // Now relate the pieces back to s\n    assert tail[..|tail|-1] == s[1..|s|-1];\n    assert tail[|tail|-1] == s[|s|-1];\n    assert tail[0] == s[1];\n    assert tail[1..] == s[2..];\n    \n    // So we have: SumR(s[1..|s|-1]) + s[|s|-1] == s[1] + SumR(s[2..])\n    \n    // We need to show: SumR(s[..|s|-1]) + s[|s|-1] == s[0] + SumR(s[1..])\n    // Note that s[..|s|-1] == [s[0]] + s[1..|s|-1]\n    assert s[..|s|-1] == [s[0]] + s[1..|s|-1];\n    \n    // Apply SumR concatenation property\n    SumRConcatenation([s[0]], s[1..|s|-1]);\n    assert SumR(s[..|s|-1]) == SumR([s[0]]) + SumR(s[1..|s|-1]);\n    assert SumR([s[0]]) == s[0];\n    \n    // So SumR(s[..|s|-1]) == s[0] + SumR(s[1..|s|-1])\n    // And we know SumR(s[1..|s|-1]) + s[|s|-1] == s[1] + SumR(s[2..])\n    // Also, SumR(s[1..]) == s[1] + SumR(s[2..]) by definition\n    \n    // Therefore: SumR(s[..|s|-1]) + s[|s|-1] == s[0] + SumR(s[1..|s|-1]) + s[|s|-1]\n    //                                        == s[0] + (s[1] + SumR(s[2..]))\n    //                                        == s[0] + SumR(s[1..])\n  }\n}\n\nlemma SumLEquivalence(s: seq<int>)\n  ensures SumL(s) == SumR(s)\n  decreases |s|\n{\n  SumREquivalence(s);\n}\n\nlemma SumRIterative(v: array<int>, i: int, acc: int)\n  requires 0 <= i <= v.Length\n  requires acc == SumR(v[..i])\n  ensures acc + SumR(v[i..]) == SumR(v[..])\n{\n  if i == 0 {\n    assert v[..i] == [];\n    assert acc == 0;\n    assert v[i..] == v[..];\n  } else if i == v.Length {\n    assert v[i..] == [];\n    assert SumR(v[i..]) == 0;\n    assert v[..] == v[..i];\n  } else {\n    assert v[..] == v[..i] + v[i..];\n    SumRConcatenation(v[..i], v[i..]);\n  }\n}\n\nlemma SumRConcatenation(s1: seq<int>, s2: seq<int>)\n  ensures SumR(s1 + s2) == SumR(s1) + SumR(s2)\n  decreases |s2|\n{\n  if s2 == [] {\n    assert s1 + s2 == s1;\n  } else if s1 == [] {\n    assert s1 + s2 == s2;\n  } else {\n    var combined := s1 + s2;\n    assert combined[..|combined|-1] == s1 + s2[..|s2|-1];\n    assert combined[|combined|-1] == s2[|s2|-1];\n    SumRConcatenation(s1, s2[..|s2|-1]);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumElems(v:array<int>) returns (sum:int)\n//ensures sum==SumL(v[0..v.Length])\nensures sum==SumR(v[..])\n//ensures sum==SumV(v,0,v.Length)\n// </vc-spec>\n// <vc-code>\n{\n  sum := 0;\n  var i := 0;\n  \n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant sum == SumR(v[..i])\n  {\n    sum := sum + v[i];\n    i := i + 1;\n    \n    assert v[..i-1] + [v[i-1]] == v[..i];\n    SumRConcatenation(v[..i-1], [v[i-1]]);\n    assert SumR([v[i-1]]) == v[i-1];\n  }\n  \n  assert i == v.Length;\n  assert v[..i] == v[..];\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_461_CountUppercase.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_461_CountUppercase.dfy", "// <vc-preamble>\npredicate IsUpperCase(c: char)\n{\n    65 <= c as int <= 90\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountUppercase(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |s| && IsUpperCase(s[i])|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsUpperCase(c: char)\n{\n    65 <= c as int <= 90\n}\n\n// <vc-helpers>\nlemma CountUppercaseHelper(s: string, i: int, currentCount: int, upperSet: set<int>)\n    requires 0 <= i <= |s|\n    requires upperSet == set j: int | 0 <= j < i && IsUpperCase(s[j])\n    requires currentCount == |upperSet|\n    ensures currentCount >= 0\n    ensures currentCount == |set j: int | 0 <= j < i && IsUpperCase(s[j])|\n{\n}\n\nlemma SetCardinalityIncrement(s: string, i: int)\n    requires 0 <= i < |s|\n    requires IsUpperCase(s[i])\n    ensures |set j: int | 0 <= j < i+1 && IsUpperCase(s[j])| == |set j: int | 0 <= j < i && IsUpperCase(s[j])| + 1\n{\n    var oldSet := set j: int | 0 <= j < i && IsUpperCase(s[j]);\n    var newSet := set j: int | 0 <= j < i+1 && IsUpperCase(s[j]);\n    assert newSet == oldSet + {i};\n    assert i !in oldSet;\n}\n\nlemma SetCardinalityNoChange(s: string, i: int)\n    requires 0 <= i < |s|\n    requires !IsUpperCase(s[i])\n    ensures |set j: int | 0 <= j < i+1 && IsUpperCase(s[j])| == |set j: int | 0 <= j < i && IsUpperCase(s[j])|\n{\n    var oldSet := set j: int | 0 <= j < i && IsUpperCase(s[j]);\n    var newSet := set j: int | 0 <= j < i+1 && IsUpperCase(s[j]);\n    assert newSet == oldSet;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountUppercase(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |s| && IsUpperCase(s[i])|\n// </vc-spec>\n// <vc-code>\n{\n    count := 0;\n    var i := 0;\n    \n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant count >= 0\n        invariant count == |set j: int | 0 <= j < i && IsUpperCase(s[j])|\n    {\n        if IsUpperCase(s[i]) {\n            SetCardinalityIncrement(s, i);\n            count := count + 1;\n        } else {\n            SetCardinalityNoChange(s, i);\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_longest_prefix_LongestCommonPrefix.dfy", "root", true, "", "", false, "Clover_longest_prefix_LongestCommonPrefix.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n  ensures |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  ensures |prefix|==|str1| || |prefix|==|str2| || (str1[|prefix|]!=str2[|prefix|])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n  ensures |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  ensures |prefix|==|str1| || |prefix|==|str2| || (str1[|prefix|]!=str2[|prefix|])\n// </vc-spec>\n// <vc-code>\n{\n  prefix := [];\n  var i := 0;\n  while i < |str1| && i < |str2| && str1[i] == str2[i]\n    invariant 0 <= i <= |str1| && 0 <= i <= |str2|\n    invariant prefix == str1[0..i] == str2[0..i]\n    invariant forall j :: 0 <= j < i ==> str1[j] == str2[j]\n  {\n    prefix := prefix + [str1[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_431_HasCommonElement.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_431_HasCommonElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod HasCommonElement(a: array<int>, b: array<int>) returns (result: bool)\n    requires a != null && b != null\n    ensures result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && a[i] == b[j]\n    ensures !result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> a[i] != b[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma CommonElementExists(a: array<int>, b: array<int>, i: int, j: int)\n    requires 0 <= i < a.Length && 0 <= j < b.Length\n    requires a[i] == b[j]\n    ensures exists x, y :: 0 <= x < a.Length && 0 <= y < b.Length && a[x] == b[y]\n{\n}\n\nlemma NoCommonElementForall(a: array<int>, b: array<int>)\n    requires forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> a[i] != b[j]\n    ensures !(exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && a[i] == b[j])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod HasCommonElement(a: array<int>, b: array<int>) returns (result: bool)\n    requires a != null && b != null\n    ensures result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && a[i] == b[j]\n    ensures !result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> a[i] != b[j]\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x, y :: 0 <= x < i && 0 <= y < b.Length ==> a[x] != b[y]\n    {\n        var j := 0;\n        while j < b.Length\n            invariant 0 <= j <= b.Length\n            invariant forall y :: 0 <= y < j ==> a[i] != b[y]\n            invariant forall x, y :: 0 <= x < i && 0 <= y < b.Length ==> a[x] != b[y]\n        {\n            if a[i] == b[j] {\n                CommonElementExists(a, b, i, j);\n                return true;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_ComputeCount.dfy", "root", false, "", "", false, "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_ComputeCount.dfy", "// <vc-preamble>\nghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_588_DifferenceMinMax.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_588_DifferenceMinMax.dfy", "// <vc-preamble>\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DifferenceMinMax(a: array<int>) returns (diff: int)\n    requires a.Length > 0\n    ensures diff == Max(a[..]) - Min(a[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}\n\n// <vc-helpers>\nlemma MinCorrectness(a: seq<int>, minVal: int)\n    requires |a| > 0\n    requires minVal == Min(a)\n    ensures forall i :: 0 <= i < |a| ==> minVal <= a[i]\n    ensures exists i :: 0 <= i < |a| && minVal == a[i]\n{\n    if |a| == 1 {\n        assert minVal == a[0];\n    } else {\n        var minPrefix := Min(a[..|a|-1]);\n        MinCorrectness(a[..|a|-1], minPrefix);\n        if a[|a|-1] <= minPrefix {\n            assert minVal == a[|a|-1];\n        } else {\n            assert minVal == minPrefix;\n            MinCorrectness(a[..|a|-1], minVal);\n        }\n    }\n}\n\nlemma MaxCorrectness(a: seq<int>, maxVal: int)\n    requires |a| > 0\n    requires maxVal == Max(a)\n    ensures forall i :: 0 <= i < |a| ==> maxVal >= a[i]\n    ensures exists i :: 0 <= i < |a| && maxVal == a[i]\n{\n    if |a| == 1 {\n        assert maxVal == a[0];\n    } else {\n        var maxPrefix := Max(a[..|a|-1]);\n        MaxCorrectness(a[..|a|-1], maxPrefix);\n        if a[|a|-1] >= maxPrefix {\n            assert maxVal == a[|a|-1];\n        } else {\n            assert maxVal == maxPrefix;\n            MaxCorrectness(a[..|a|-1], maxVal);\n        }\n    }\n}\n\nlemma MinExtension(a: seq<int>, x: int)\n    requires |a| > 0\n    ensures Min(a + [x]) == if x <= Min(a) then x else Min(a)\n{\n    var extended := a + [x];\n    assert extended[..|extended|-1] == a;\n    assert extended[|extended|-1] == x;\n}\n\nlemma MaxExtension(a: seq<int>, x: int)\n    requires |a| > 0\n    ensures Max(a + [x]) == if x >= Max(a) then x else Max(a)\n{\n    var extended := a + [x];\n    assert extended[..|extended|-1] == a;\n    assert extended[|extended|-1] == x;\n}\n\nlemma ArraySliceExtension(a: array<int>, i: int)\n    requires 0 <= i < a.Length\n    ensures a[..i+1] == a[..i] + [a[i]]\n{\n    assert a[..i+1][..i] == a[..i];\n    assert a[..i+1][i] == a[i];\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DifferenceMinMax(a: array<int>) returns (diff: int)\n    requires a.Length > 0\n    ensures diff == Max(a[..]) - Min(a[..])\n// </vc-spec>\n// <vc-code>\n{\n    var min := a[0];\n    var max := a[0];\n    var i := 1;\n    \n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant min == Min(a[..i])\n        invariant max == Max(a[..i])\n    {\n        ArraySliceExtension(a, i);\n        assert a[..i+1] == a[..i] + [a[i]];\n        \n        MinExtension(a[..i], a[i]);\n        MaxExtension(a[..i], a[i]);\n        \n        if a[i] < min {\n            min := a[i];\n            assert min == Min(a[..i+1]);\n        } else {\n            assert min == Min(a[..i+1]);\n        }\n        \n        if a[i] > max {\n            max := a[i];\n            assert max == Max(a[..i+1]);\n        } else {\n            assert max == Max(a[..i+1]);\n        }\n        \n        i := i + 1;\n    }\n    \n    assert i == a.Length;\n    assert a[..i] == a[..];\n    assert min == Min(a[..]);\n    assert max == Max(a[..]);\n    \n    diff := max - min;\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength.dfy", "root", true, "", "", false, "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength.dfy", "// <vc-preamble>\npredicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n\n{\n\n    if (k > |str1| || k > |str2| ){\n        return false;\n    }\n\n    var i := 0;\n    var temp := false;\n\n    while i <= |str1|-k\n\n    invariant 0 <= i <= (|str1|-k) + 1\n\n    invariant temp ==> 0 <= i <= (|str1| - k) && isSubstringPred(str1[i..i+k], str2)\n\n    invariant !temp ==> (forall m,n :: (0 <= m < i && n == m+k) ==> isNotSubstringPred(str1[m..n], str2))\n\n    decreases |str1| - k - i\n    {\n        assume false;\n\n        temp := isSubstring(str1[i..(i + k)], str2);\n        if  temp == true \n        {\n            return true;\n        }\n        i := i + 1;\n    }\n    return false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n    // Check that both strings are larger than k \n    if (k > |str1| || k > |str2| ){\n        return false;\n    }\n    // Initialize variables\n    var i := 0;\n    var temp := false;\n\n    // Don't want to exceed the bounds of str1 when checking for the element that is k entries away\n    while i <= |str1|-k\n    // Invariant to stay within bounds\n    invariant 0 <= i <= (|str1|-k) + 1\n    // Invariant to show that when temp is true, it is a substring\n    invariant temp ==> 0 <= i <= (|str1| - k) && isSubstringPred(str1[i..i+k], str2)\n    // Invariant to show that when temp is false, it is not a substring\n    invariant !temp ==> (forall m,n :: (0 <= m < i && n == m+k) ==> isNotSubstringPred(str1[m..n], str2))\n    // Telling dafny that i is that value that is increasing\n    decreases |str1| - k - i\n    {\n        assume false;\n\n        // Get an index from the array position were are at to the array position that is k away and check the substring\n        temp := isSubstring(str1[i..(i + k)], str2);\n        if  temp == true \n        {\n            return true;\n        }\n        i := i + 1;\n    }\n    return false;\n}\n\n// <vc-helpers>\nlemma isSubstringEquivalence(sub: string, str: string)\n    requires |sub| <= |str|\n    ensures isSubstring(sub, str) <==> isSubstringPred(sub, str)\n{\n    if isSubstring(sub, str) {\n        var i :| 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub;\n        assert isPrefixPred(sub, str[i..]);\n        assert isSubstringPred(sub, str);\n    }\n    if isSubstringPred(sub, str) {\n        var i :| 0 <= i <= |str| && isPrefixPred(sub, str[i..]);\n        assert |sub| <= |str[i..]|;\n        assert sub == str[i..][..|sub|];\n        assert sub == str[i..i+|sub|];\n        assert isSubstring(sub, str);\n    }\n}\n\nlemma haveCommonKSubstringEquivalence(k: nat, str1: string, str2: string)\n    requires k <= |str1|\n    ensures haveCommonKSubstringPred(k, str1, str2) <==> \n            (exists i :: 0 <= i <= |str1| - k && isSubstring(str1[i..i+k], str2))\n{\n    if haveCommonKSubstringPred(k, str1, str2) {\n        var i1, j1 :| 0 <= i1 <= |str1| - k && j1 == i1 + k && isSubstringPred(str1[i1..j1], str2);\n        if k <= |str2| {\n            isSubstringEquivalence(str1[i1..j1], str2);\n        }\n        assert isSubstring(str1[i1..i1+k], str2);\n    }\n    if exists i :: 0 <= i <= |str1| - k && isSubstring(str1[i..i+k], str2) {\n        var i :| 0 <= i <= |str1| - k && isSubstring(str1[i..i+k], str2);\n        if k <= |str2| {\n            isSubstringEquivalence(str1[i..i+k], str2);\n        }\n        assert isSubstringPred(str1[i..i+k], str2);\n        assert haveCommonKSubstringPred(k, str1, str2);\n    }\n}\n\nlemma emptyStringIsSubstring(str: string)\n    ensures isSubstring([], str)\n    ensures isSubstringPred([], str)\n{\n    assert 0 <= 0 <= |str| - 0;\n    assert str[0..0] == [];\n    assert isSubstring([], str);\n    assert 0 <= 0 <= |str|;\n    var emptySeq: seq<char> := [];\n    assert |emptySeq| <= |str[0..]|;\n    assert emptySeq == str[0..][..0];\n    assert isPrefixPred(emptySeq, str[0..]);\n    assert isSubstringPred(emptySeq, str);\n}\n\nlemma haveCommonZeroSubstring(str1: string, str2: string)\n    ensures haveCommonKSubstringPred(0, str1, str2)\n{\n    emptyStringIsSubstring(str2);\n    if |str1| >= 0 {\n        assert str1[0..0] == [];\n        assert isSubstringPred(str1[0..0], str2);\n        assert haveCommonKSubstringPred(0, str1, str2);\n    }\n}\n\nlemma findSubstringWitness(sub: string, str: string)\n    requires isSubstring(sub, str)\n    ensures exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n{\n    // The witness exists by definition of isSubstring\n}\n\nlemma findSubstringPredWitness(sub: string, str: string)\n    requires isSubstringPred(sub, str)\n    ensures exists i :: 0 <= i <= |str| && isPrefixPred(sub, str[i..])\n{\n    // The witness exists by definition of isSubstringPred\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n    if |str1| == 0 {\n        haveCommonZeroSubstring(str1, str2);\n        return 0;\n    }\n    \n    var k := |str1|;\n    \n    while k > 0\n        invariant 0 <= k <= |str1|\n        invariant forall j :: k < j <= |str1| ==> !haveCommonKSubstringPred(j, str1, str2)\n        decreases k\n    {\n        if k <= |str2| {\n            haveCommonKSubstringEquivalence(k, str1, str2);\n        }\n        var hasCommon := haveCommonKSubstring(k, str1, str2);\n        if hasCommon {\n            return k;\n        }\n        k := k - 1;\n    }\n    \n    haveCommonZeroSubstring(str1, str2);\n    return 0;\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort.dfy", "// <vc-preamble>\npredicate Sorted(a: string, low:int, high:int)\nrequires 0 <= low <= high <= |a|\n{ \n    forall j, k :: low <= j < k < high ==> a[j] <= a[k] \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod String3Sort(a: string) returns (b: string) \nrequires |a| == 3;\nensures Sorted(b, 0, |b|);\nensures |a| == |b|;\nensures multiset{b[0], b[1], b[2]} == multiset{a[0], a[1], a[2]};\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// verifies\n// check that string between indexes low and high-1 are sorted\npredicate Sorted(a: string, low:int, high:int)\nrequires 0 <= low <= high <= |a|\n{ \n    forall j, k :: low <= j < k < high ==> a[j] <= a[k] \n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod String3Sort(a: string) returns (b: string) \nrequires |a| == 3;\nensures Sorted(b, 0, |b|);\nensures |a| == |b|;\nensures multiset{b[0], b[1], b[2]} == multiset{a[0], a[1], a[2]};\n// </vc-spec>\n// <vc-code>\n{\n    var c0 := a[0];\n    var c1 := a[1];\n    var c2 := a[2];\n    \n    if c0 <= c1 && c1 <= c2 {\n        b := a;\n    } else if c0 <= c2 && c2 <= c1 {\n        b := [c0, c2, c1];\n    } else if c1 <= c0 && c0 <= c2 {\n        b := [c1, c0, c2];\n    } else if c1 <= c2 && c2 <= c0 {\n        b := [c1, c2, c0];\n    } else if c2 <= c0 && c0 <= c1 {\n        b := [c2, c0, c1];\n    } else {\n        b := [c2, c1, c0];\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt.dfy", "// <vc-preamble>\npredicate sqrt(x: int, r: int) {\n    r*r <= x && (r+1)*(r+1) > x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mySqrt(x: int) returns (res: int)\nrequires 0 <= x;\nensures sqrt(x, res);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Author: Shaobo He\n\npredicate sqrt(x: int, r: int) {\n    r*r <= x && (r+1)*(r+1) > x\n}\n\n// <vc-helpers>\nlemma SqrtExists(x: int)\n    requires x >= 0\n    ensures exists r: int :: r >= 0 && sqrt(x, r)\n{\n    var r := 0;\n    while r * r <= x\n        invariant r >= 0\n        decreases x - r * r + 1\n    {\n        if (r + 1) * (r + 1) > x {\n            assert sqrt(x, r);\n            return;\n        }\n        r := r + 1;\n    }\n    assert r > 0;\n    assert r * r > x;\n    var prev := r - 1;\n    assert prev >= 0;\n    assert prev * prev <= x;\n    assert (prev + 1) * (prev + 1) > x;\n    assert sqrt(x, prev);\n}\n\nlemma SqrtUnique(x: int, r1: int, r2: int)\n    requires x >= 0\n    requires sqrt(x, r1)\n    requires sqrt(x, r2)\n    ensures r1 == r2\n{\n    if r1 < r2 {\n        assert (r1 + 1) * (r1 + 1) > x;\n        assert r2 * r2 <= x;\n        assert r1 + 1 <= r2;\n        assert (r1 + 1) * (r1 + 1) <= r2 * r2;\n        assert false;\n    } else if r1 > r2 {\n        assert (r2 + 1) * (r2 + 1) > x;\n        assert r1 * r1 <= x;\n        assert r2 + 1 <= r1;\n        assert (r2 + 1) * (r2 + 1) <= r1 * r1;\n        assert false;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mySqrt(x: int) returns (res: int)\nrequires 0 <= x;\nensures sqrt(x, res);\n// </vc-spec>\n// <vc-code>\n{\n    res := 0;\n    while (res + 1) * (res + 1) <= x\n        invariant res >= 0\n        invariant res * res <= x\n        decreases x - res * res\n    {\n        res := res + 1;\n    }\n    assert (res + 1) * (res + 1) > x;\n    assert sqrt(x, res);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_swap_arith_SwapArithmetic.dfy", "root", true, "", "", false, "Clover_swap_arith_SwapArithmetic.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  x := X;\n  y := Y;\n  x := x + y;\n  y := x - y;\n  x := x - y;\n}\n// </vc-code>\n\n", "", "", ""], ["VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple.dfy", "root", true, "", "", false, "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple.dfy", "// <vc-preamble>\npredicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mergeSimple(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires 0 <= start <= end <= b.Length\n  requires |a1| +  |a2| == end - start + 1\n  ensures sorted_slice(b, start, end)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n// <vc-helpers>\nlemma merge_preserves_sortedness(a1: seq<int>, a2: seq<int>, i1: int, i2: int, b: array<int>, pos: int, start: int)\n  requires sorted_seq(a1) && sorted_seq(a2)\n  requires 0 <= i1 <= |a1| && 0 <= i2 <= |a2|\n  requires start <= pos < b.Length\n  requires sorted_slice(b, start, pos)\n  requires pos > start ==> (\n    (i1 > 0 && b[pos-1] == a1[i1-1]) || \n    (i2 > 0 && b[pos-1] == a2[i2-1])\n  )\n  modifies b\n  ensures pos < b.Length && i1 < |a1| && a1[i1] >= (if pos > start then b[pos-1] else a1[i1]) ==> \n    (b[pos] := a1[i1]; sorted_slice(b, start, pos+1))\n  ensures pos < b.Length && i2 < |a2| && a2[i2] >= (if pos > start then b[pos-1] else a2[i2]) ==> \n    (b[pos] := a2[i2]; sorted_slice(b, start, pos+1))\n{\n}\n\nlemma final_elements_maintain_order(a1: seq<int>, a2: seq<int>, i1: int, i2: int, b: array<int>, pos: int, start: int)\n  requires sorted_seq(a1) && sorted_seq(a2)\n  requires 0 <= i1 <= |a1| && 0 <= i2 <= |a2|\n  requires start <= pos < b.Length\n  requires sorted_slice(b, start, pos)\n  requires (i1 == |a1|) ==> (i2 < |a2|)\n  requires (i2 == |a2|) ==> (i1 < |a1|)\n  ensures i1 == |a1| && i2 < |a2| ==> \n    (pos > start ==> a2[i2] >= b[pos-1])\n  ensures i2 == |a2| && i1 < |a1| ==> \n    (pos > start ==> a1[i1] >= b[pos-1])\n{\n}\n\nlemma sorted_slice_extension(b: array<int>, start: int, pos: int, val: int)\n  requires 0 <= start <= pos < b.Length\n  requires sorted_slice(b, start, pos)\n  requires pos > start ==> val >= b[pos-1]\n  modifies b\n  ensures b[pos] == val ==> sorted_slice(b, start, pos+1)\n{\n  if pos == start {\n    assert sorted_slice(b, start, pos+1);\n  } else {\n    assert val >= b[pos-1];\n    assert sorted_slice(b, start, pos+1);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mergeSimple(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires 0 <= start <= end <= b.Length\n  requires |a1| +  |a2| == end - start + 1\n  ensures sorted_slice(b, start, end)\n// </vc-spec>\n// <vc-code>\n{\n  var i1 := 0;\n  var i2 := 0;\n  var pos := start;\n  \n  while pos < end && (i1 < |a1| || i2 < |a2|)\n    invariant start <= pos <= end\n    invariant 0 <= i1 <= |a1|\n    invariant 0 <= i2 <= |a2|\n    invariant i1 + i2 == pos - start\n    invariant sorted_slice(b, start, pos)\n    invariant pos > start ==> (forall k :: start <= k < pos-1 ==> b[k] <= b[k+1])\n    decreases |a1| + |a2| - i1 - i2\n  {\n    if i1 >= |a1| {\n      sorted_slice_extension(b, start, pos, a2[i2]);\n      b[pos] := a2[i2];\n      i2 := i2 + 1;\n    } else if i2 >= |a2| {\n      sorted_slice_extension(b, start, pos, a1[i1]);\n      b[pos] := a1[i1];\n      i1 := i1 + 1;\n    } else if a1[i1] <= a2[i2] {\n      sorted_slice_extension(b, start, pos, a1[i1]);\n      b[pos] := a1[i1];\n      i1 := i1 + 1;\n    } else {\n      sorted_slice_extension(b, start, pos, a2[i2]);\n      b[pos] := a2[i2];\n      i2 := i2 + 1;\n    }\n    pos := pos + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort.dfy", "root", true, "", "", false, "CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort.dfy", "// <vc-preamble>\npredicate sorted(a:array<int>, from:int, to:int)\n  requires a != null;\n  reads a; \n  requires 0 <= from <= to <= a.Length;\n{\n  forall x, y :: from <= x < y < to ==> a[x] <= a[y]\n}\n\npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null;\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall x, y :: 0 <= x < pvt < y < to ==> a[x] <= a[y]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort (a: array<int>)\n    requires a != null && a.Length > 0;\n    modifies a;\n    ensures sorted(a, 0, a.Length);\n    ensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Bubblesort CS 494 submission\n//References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785\n\n\n// predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array\n\npredicate sorted(a:array<int>, from:int, to:int)\n  requires a != null; // requires array to have n amount of elements\n  reads a; \n  requires 0 <= from <= to <= a.Length; // pre condition checks that from is the start of the range and to is the end of the range, requires values to be within 0 - a.Length\n{\n  forall x, y :: from <= x < y < to ==> a[x] <= a[y]\n}\n\n//helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept \npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null; // requires array to have n amount of elements\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall x, y :: 0 <= x < pvt < y < to ==> a[x] <= a[y] // all values within the array should be in ascending order\n}\n\n// Here having the algorithm for the bubblesort\n\n// <vc-helpers>\nlemma SortedPreservation(a: array<int>, from: int, to: int, i: int)\n  requires 0 <= from <= i < to <= a.Length\n  requires sorted(a, from, i+1)\n  requires sorted(a, i, to)\n  requires from < i ==> a[i-1] <= a[i]\n  ensures sorted(a, from, to)\n{\n}\n\nmethod SwapElements(a: array<int>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures a[i] == old(a[j]) && a[j] == old(a[i])\n  ensures forall k :: 0 <= k < a.Length && k != i && k != j ==> a[k] == old(a[k])\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\n\nlemma SortedExtension(a: array<int>, from: int, to: int)\n  requires 0 <= from < to <= a.Length\n  requires sorted(a, from+1, to)\n  requires forall k :: from+1 <= k < to ==> a[from] <= a[k]\n  ensures sorted(a, from, to)\n{\n}\n\nlemma BubbleInnerLoopCorrectness(a: array<int>, n: int, i: int)\n  requires 0 <= i < n - 1\n  requires n == a.Length\n  requires forall k :: 0 <= k < n - 1 - i ==> a[k] <= a[k+1]\n  ensures forall k :: 0 <= k < n - 1 - i ==> a[k] <= a[n - 1 - i]\n{\n  if n - 1 - i > 0 {\n    var j := 0;\n    while j < n - 1 - i\n      invariant 0 <= j <= n - 1 - i\n      invariant forall k :: 0 <= k <= j ==> a[k] <= a[n - 1 - i]\n    {\n      j := j + 1;\n    }\n  }\n}\n\nlemma SwapPreservesMultiset(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\n\nlemma SortedTransitive(a: array<int>, from: int, mid: int, to: int)\n  requires 0 <= from <= mid <= to <= a.Length\n  requires sorted(a, from, mid)\n  requires sorted(a, mid, to)\n  requires from < mid < to ==> a[mid-1] <= a[mid]\n  ensures sorted(a, from, to)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort (a: array<int>)\n    requires a != null && a.Length > 0; // makes sure a is not empty and length is greater than 0\n    modifies a; // as method runs, we are changing a\n    ensures sorted(a, 0, a.Length); // makes sure elements of array a are sorted from 0 - a.Length\n    ensures multiset(a[..]) == multiset(old(a[..])); // Since a is being modified, we deference the heap \n                                                      //and compare the previous elements to current elements.\n// </vc-spec>\n// <vc-code>\n{\n  var n := a.Length;\n  var i := 0;\n  \n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant sorted(a, n - i, n)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall x :: 0 <= x < n - i ==> forall y :: n - i <= y < n ==> a[x] <= a[y]\n  {\n    var j := 0;\n    \n    while j < n - 1 - i\n      invariant 0 <= j <= n - 1 - i\n      invariant sorted(a, n - i, n)\n      invariant multiset(a[..]) == multiset(old(a[..]))\n      invariant forall x :: 0 <= x < n - i ==> forall y :: n - i <= y < n ==> a[x] <= a[y]\n      invariant forall k :: 0 <= k < j ==> a[k] <= a[j]\n      invariant j < n - 1 - i ==> forall k :: j < k < n - 1 - i ==> a[j] <= a[k+1]\n    {\n      if a[j] > a[j+1] {\n        var temp := a[j];\n        a[j] := a[j+1];\n        a[j+1] := temp;\n      }\n      j := j + 1;\n    }\n    \n    assert forall k :: 0 <= k < n - 1 - i ==> a[k] <= a[n - 1 - i];\n    i := i + 1;\n  }\n  \n  assert i == n - 1;\n  assert sorted(a, 1, n);\n  \n  if n > 1 {\n    assert forall k :: 1 <= k < n ==> a[0] <= a[k];\n    SortedExtension(a, 0, n);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_two_sum_twoSum.dfy", "root", true, "", "", false, "Clover_two_sum_twoSum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: array<int>, target: int) returns (i: int, j: int)\n  requires nums.Length > 1\n  requires exists i,j::0 <= i < j < nums.Length &&  nums[i] + nums[j] == target\n  ensures 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length)  ==> nums[ii] + nums[jj] != target\n  ensures forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma ForallPreservation(nums: array<int>, target: int, i: int, j: int)\n  requires 0 <= i < j < nums.Length\n  requires forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length) ==> nums[ii] + nums[jj] != target\n  requires forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length) ==> nums[ii] + nums[jj] != target\n  ensures forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: array<int>, target: int) returns (i: int, j: int)\n  requires nums.Length > 1\n  requires exists i,j::0 <= i < j < nums.Length &&  nums[i] + nums[j] == target\n  ensures 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length)  ==> nums[ii] + nums[jj] != target\n  ensures forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  while i < nums.Length - 1\n    invariant 0 <= i < nums.Length\n    invariant forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length) ==> nums[ii] + nums[jj] != target\n  {\n    j := i + 1;\n    while j < nums.Length\n      invariant i < j <= nums.Length\n      invariant forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n    {\n      if nums[i] + nums[j] == target {\n        return;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_Partition.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_Partition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Partition( m: multiset<int> )\n        returns( pre: multiset<int>, p: int, post: multiset<int> )\n    requires |m| > 0;\n    ensures p in m;\n    ensures m == pre+multiset{p}+post;\n     ensures forall z | z in pre :: z <= p;\n     ensures forall z | z in post :: z >= p;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV.dfy", "root", true, "", "", false, "veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV.dfy", "// <vc-preamble>\nfunction sum(X_val : array<int>, X_crd : array<nat>,\n             v_val : array<int>, v_crd : array<nat>, kX : nat, kV : nat, pX_end : nat, pV_end : nat) : (s : int) \n  reads X_val, X_crd\n  requires X_val.Length == X_crd.Length\n  requires pX_end <= X_crd.Length\n  requires 0 <= kX <= X_crd.Length\n\n  reads v_crd, v_val\n  requires v_val.Length == v_crd.Length\n  requires pV_end <= v_crd.Length\n  requires 0 <= kV <= v_crd.Length\n\n  decreases pX_end + pV_end - (kX + kV)\n  {\n    if pV_end <= kV || pX_end <= kX then \n      0\n    else if X_crd[kX] == v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + v_val[kV] * X_val[kX]\n    else if X_crd[kX] < v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)\n    else sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)\n  }\n\nfunction min(x : nat, y : nat) : nat {\n  if x <= y then x else y\n}\n\npredicate notin(y: nat, x : array<nat>) \n  reads x\n{\n  forall i :: 0 <= i < x.Length ==> y != x[i]\n}\n\npredicate notin_seq(y: nat, x : seq<nat>) \n{\n  forall i :: 0 <= i < |x| ==> y != x[i]\n}\n\nfunction index_seq(x : nat, y: seq<nat>) : (i : nat)\n  ensures i >= |y| ==> notin_seq(x, y)\n  ensures i <  |y| ==> y[i] == x\n{\n  if |y| == 0 then 0 \n  else \n    if y[0] == x then 0 \n    else 1 + index_seq(x, y[1..])\n}\n\nfunction index(x : nat, y: array<nat>) : (i : nat)\n  reads y\n  ensures i >= y.Length ==> notin(x, y)\n  ensures i <  y.Length ==> y[i] == x\n{\n  index_seq(x, y[.. ])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DSpMSpV(X_val : array<int>, X_crd : array<nat>, X_pos : array<nat>,\n                                  X_crd1 : array<nat>, X_len: nat,\n              v_val : array<int>, v_crd : array<nat>) returns (y : array<int>)\n\n  requires X_pos.Length >= 1\n  requires X_val.Length == X_crd.Length\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_pos.Length ==> 0 <= X_pos[i] <= X_val.Length\n\n  requires X_len >= X_crd1.Length\n  requires forall i :: 0 <= i < X_crd1.Length ==> X_crd1[i] < X_len\n\n  requires X_crd1.Length < X_pos.Length\n  requires forall i, j :: 0 <= i < j < X_crd1.Length ==> X_crd1[i] < X_crd1[j]\n\n  requires v_val.Length == v_crd.Length\n\n  ensures y.Length == X_len\n  ensures forall i :: 0 <= i < y.Length ==> \n    y[i] == \n      if index(i, X_crd1) < X_crd1.Length then \n        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)\n      else 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sum(X_val : array<int>, X_crd : array<nat>,\n             v_val : array<int>, v_crd : array<nat>, kX : nat, kV : nat, pX_end : nat, pV_end : nat) : (s : int) \n  reads X_val, X_crd\n  requires X_val.Length == X_crd.Length\n  requires pX_end <= X_crd.Length\n  requires 0 <= kX <= X_crd.Length\n\n  reads v_crd, v_val\n  requires v_val.Length == v_crd.Length\n  requires pV_end <= v_crd.Length\n  requires 0 <= kV <= v_crd.Length\n\n  decreases pX_end + pV_end - (kX + kV)\n  {\n    if pV_end <= kV || pX_end <= kX then \n      0\n    else if X_crd[kX] == v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + v_val[kV] * X_val[kX]\n    else if X_crd[kX] < v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)\n    else sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)\n  }\n\nfunction min(x : nat, y : nat) : nat {\n  if x <= y then x else y\n}\n\npredicate notin(y: nat, x : array<nat>) \n  reads x\n{\n  forall i :: 0 <= i < x.Length ==> y != x[i]\n}\n\npredicate notin_seq(y: nat, x : seq<nat>) \n{\n  forall i :: 0 <= i < |x| ==> y != x[i]\n}\n\nfunction index_seq(x : nat, y: seq<nat>) : (i : nat)\n  ensures i >= |y| ==> notin_seq(x, y)\n  ensures i <  |y| ==> y[i] == x\n{\n  if |y| == 0 then 0 \n  else \n    if y[0] == x then 0 \n    else 1 + index_seq(x, y[1..])\n}\n\nfunction index(x : nat, y: array<nat>) : (i : nat)\n  reads y\n  ensures i >= y.Length ==> notin(x, y)\n  ensures i <  y.Length ==> y[i] == x\n{\n  index_seq(x, y[.. ])\n}\n\n// <vc-helpers>\nlemma index_in_bounds(i: nat, arr: array<nat>)\n  requires i < arr.Length\n  ensures index(i, arr) < arr.Length ==> arr[index(i, arr)] == i\n{\n}\n\nlemma index_out_of_bounds(i: nat, arr: array<nat>)\n  ensures index(i, arr) >= arr.Length ==> notin(i, arr)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DSpMSpV(X_val : array<int>, X_crd : array<nat>, X_pos : array<nat>,\n                                  X_crd1 : array<nat>, X_len: nat,\n              v_val : array<int>, v_crd : array<nat>) returns (y : array<int>)\n  // X requirements \n  requires X_pos.Length >= 1\n  requires X_val.Length == X_crd.Length\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_pos.Length ==> 0 <= X_pos[i] <= X_val.Length\n\n  requires X_len >= X_crd1.Length\n  requires forall i :: 0 <= i < X_crd1.Length ==> X_crd1[i] < X_len\n\n  requires X_crd1.Length < X_pos.Length\n  requires forall i, j :: 0 <= i < j < X_crd1.Length ==> X_crd1[i] < X_crd1[j]\n\n  // v requirements \n  requires v_val.Length == v_crd.Length\n\n  ensures y.Length == X_len\n  ensures forall i :: 0 <= i < y.Length ==> \n    y[i] == \n      if index(i, X_crd1) < X_crd1.Length then \n        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)\n      else 0\n// </vc-spec>\n// <vc-code>\n{\n  y := new int[X_len];\n  \n  var k := 0;\n  while k < X_len\n    invariant 0 <= k <= X_len\n    invariant forall i :: 0 <= i < k ==> \n      y[i] == \n        if index(i, X_crd1) < X_crd1.Length then \n          sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)\n        else 0\n  {\n    var idx := index(k, X_crd1);\n    if idx < X_crd1.Length {\n      y[k] := sum(X_val, X_crd, v_val, v_crd, X_pos[idx], 0, X_pos[idx+1], v_val.Length);\n    } else {\n      y[k] := 0;\n    }\n    k := k + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_284_AllElementsEqual.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_284_AllElementsEqual.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllElementsEqual(a: array<int>, n: int) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> a[i] == n\n    ensures !result ==> exists i :: 0 <= i < a.Length && a[i] != n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllElementsEqual(a: array<int>, n: int) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> a[i] == n\n    ensures !result ==> exists i :: 0 <= i < a.Length && a[i] != n\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 0 {\n        return true;\n    }\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall j :: 0 <= j < i ==> a[j] == n\n    {\n        if a[i] != n {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_2_SharedElements.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_2_SharedElements.dfy", "// <vc-preamble>\npredicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n\n// <vc-helpers>\nlemma InArrayLemma(arr: array<int>, x: int, idx: int)\n    requires 0 <= idx < arr.Length\n    requires arr[idx] == x\n    ensures InArray(arr, x)\n{\n    assert exists i :: 0 <= i < arr.Length && arr[i] == x;\n}\n\npredicate NotInSeq(s: seq<int>, x: int)\n{\n    forall i :: 0 <= i < |s| ==> s[i] != x\n}\n\nlemma NotInSeqAppend(s: seq<int>, x: int)\n    requires NotInSeq(s, x)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n    ensures forall i, j :: 0 <= i < j < |s + [x]| ==> (s + [x])[i] != (s + [x])[j]\n{\n    var newSeq := s + [x];\n    forall i, j | 0 <= i < j < |newSeq|\n        ensures newSeq[i] != newSeq[j]\n    {\n        if j == |newSeq| - 1 {\n            assert newSeq[j] == x;\n            assert newSeq[i] == s[i];\n            assert NotInSeq(s, x);\n            assert s[i] != x;\n        } else {\n            assert newSeq[i] == s[i] && newSeq[j] == s[j];\n            assert i < j < |s|;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n        invariant forall k, j :: 0 <= k < j < |result| ==> result[k] != result[j]\n    {\n        var j := 0;\n        var found := false;\n        \n        while j < b.Length && !found\n            invariant 0 <= j <= b.Length\n            invariant found ==> (j > 0 && b[j-1] == a[i])\n            invariant !found ==> forall k :: 0 <= k < j ==> b[k] != a[i]\n            decreases b.Length - j, if found then 0 else 1\n        {\n            if b[j] == a[i] {\n                found := true;\n            }\n            if !found {\n                j := j + 1;\n            }\n        }\n        \n        if found {\n            var alreadyInResult := false;\n            var k := 0;\n            while k < |result| && !alreadyInResult\n                invariant 0 <= k <= |result|\n                invariant alreadyInResult ==> (k > 0 && result[k-1] == a[i])\n                invariant !alreadyInResult ==> forall m :: 0 <= m < k ==> result[m] != a[i]\n                decreases |result| - k, if alreadyInResult then 0 else 1\n            {\n                if result[k] == a[i] {\n                    alreadyInResult := true;\n                }\n                if !alreadyInResult {\n                    k := k + 1;\n                }\n            }\n            \n            if !alreadyInResult {\n                InArrayLemma(a, a[i], i);\n                InArrayLemma(b, a[i], j-1);\n                assert NotInSeq(result, a[i]);\n                NotInSeqAppend(result, a[i]);\n                result := result + [a[i]];\n            }\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_lol_sort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_lol_sort.dfy", "// <vc-preamble>\npredicate valid_permut(a: seq<int>, b: seq<int>)\n  requires |a| == |b|\n{\n  multiset(a) == multiset(b)\n}\n\nmethod swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[..] == old(a[..]) [i := old(a[j])] [j := old(a[i])]\n  ensures valid_permut(a[..], old(a[..]))\n{\n  assume{:axiom} false;\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i, j | 0 <= i <= j < |a| :: a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod lol_sort(a: array<int>)\n  modifies a\n  ensures valid_permut(a[..], old(a[..]))\n  ensures sorted(a[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_133_SumOfNegatives.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_133_SumOfNegatives.dfy", "// <vc-preamble>\nfunction sumNegativesTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else if a[n-1] < 0 then sumNegativesTo(a, n-1) + a[n-1] else sumNegativesTo(a, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfNegatives(a: array<int>) returns (result: int)\n    ensures result == sumNegativesTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sumNegativesTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else if a[n-1] < 0 then sumNegativesTo(a, n-1) + a[n-1] else sumNegativesTo(a, n-1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfNegatives(a: array<int>) returns (result: int)\n    ensures result == sumNegativesTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  result := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant result == sumNegativesTo(a, i)\n  {\n    if a[i] < 0 {\n      result := result + a[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_min_array_minArray.dfy", "root", true, "", "", false, "Clover_min_array_minArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n// </vc-spec>\n// <vc-code>\n{\n  r := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> r <= a[j]\n    invariant exists j :: 0 <= j < i && r == a[j]\n  {\n    if a[i] < r {\n      r := a[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_743_RotateRight.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_743_RotateRight.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma RotationLemma(l: seq<int>, n: int, effectiveN: int)\n    requires |l| > 0\n    requires n >= 0\n    requires effectiveN == n % |l|\n    ensures forall i {:trigger (l[|l| - effectiveN..] + l[..|l| - effectiveN])[i]} :: 0 <= i < |l| ==> (l[|l| - effectiveN..] + l[..|l| - effectiveN])[i] == l[(i - n + |l|) % |l|]\n{\n    var splitPoint := |l| - effectiveN;\n    var rotated := l[splitPoint..] + l[..splitPoint];\n    \n    assert |rotated| == |l|;\n    \n    forall i | 0 <= i < |l|\n        ensures rotated[i] == l[(i - n + |l|) % |l|]\n    {\n        assert (i - n + |l|) % |l| == (i - effectiveN + |l|) % |l|;\n        \n        if i < effectiveN {\n            assert rotated[i] == l[splitPoint + i];\n            assert splitPoint + i == |l| - effectiveN + i;\n            assert (i - effectiveN + |l|) % |l| == |l| - effectiveN + i;\n        } else {\n            assert rotated[i] == l[i - effectiveN];\n            assert (i - effectiveN + |l|) % |l| == i - effectiveN;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n    if |l| == 0 {\n        r := l;\n    } else {\n        var effectiveN := n % |l|;\n        var splitPoint := |l| - effectiveN;\n        r := l[splitPoint..] + l[..splitPoint];\n        RotationLemma(l, n, effectiveN);\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_FIND.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_FIND.dfy", "// <vc-preamble>\nghost function Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FIND(A: array<int>, N: int, f: int)\n  requires A.Length == N;\n  requires 0 <= f < N;\n  modifies A;\n  ensures forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[q];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo.dfy", "root", true, "", "", false, "vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod torneo(Valores : array?<real>, i : int, j : int, k : int) returns (pos_padre : int, pos_madre : int)\n    requires Valores != null && Valores.Length >= 20 && Valores.Length < 50 && i >= 0 && j >= 0 && k >= 0 \n    requires i < Valores.Length && j < Valores.Length && k < Valores.Length && i != j && j != k && k != i \n    ensures exists p, q, r | p in {i, j, k} && q in {i, j, k} && r in {i, j, k} && p != q && q != r && p != r :: Valores[p] >= Valores[q] >= Valores[r] && pos_padre == p && pos_madre == q\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod torneo(Valores : array?<real>, i : int, j : int, k : int) returns (pos_padre : int, pos_madre : int)\n    requires Valores != null && Valores.Length >= 20 && Valores.Length < 50 && i >= 0 && j >= 0 && k >= 0 \n    requires i < Valores.Length && j < Valores.Length && k < Valores.Length && i != j && j != k && k != i \n    ensures exists p, q, r | p in {i, j, k} && q in {i, j, k} && r in {i, j, k} && p != q && q != r && p != r :: Valores[p] >= Valores[q] >= Valores[r] && pos_padre == p && pos_madre == q // Q\n// </vc-spec>\n// <vc-code>\n{\n  if Valores[i] >= Valores[j] && Valores[j] >= Valores[k] {\n    pos_padre := i;\n    pos_madre := j;\n  } else if Valores[i] >= Valores[k] && Valores[k] >= Valores[j] {\n    pos_padre := i;\n    pos_madre := k;\n  } else if Valores[j] >= Valores[i] && Valores[i] >= Valores[k] {\n    pos_padre := j;\n    pos_madre := i;\n  } else if Valores[j] >= Valores[k] && Valores[k] >= Valores[i] {\n    pos_padre := j;\n    pos_madre := k;\n  } else if Valores[k] >= Valores[i] && Valores[i] >= Valores[j] {\n    pos_padre := k;\n    pos_madre := i;\n  } else {\n    pos_padre := k;\n    pos_madre := j;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index.dfy", "root", true, "", "", false, "software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index.dfy", "// <vc-preamble>\npredicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\n\n// predicate is_permutation(a:seq<int>, b:seq<int>)\n// decreases |a|\n// decreases |b|\n// {\n//     |a| == |b|  && ((|a| == 0 && |b| == 0) ||  exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))\n// }\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n// </vc-spec>\n// <vc-code>\n{\n  min_i := s;\n  var i := s + 1;\n  while i < e\n    invariant s <= min_i < i <= e\n    invariant forall k: int :: s <= k < i ==> a[min_i] <= a[k]\n  {\n    if a[i] < a[min_i] {\n      min_i := i;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring.dfy", "root", true, "", "", false, "dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring.dfy", "// <vc-preamble>\ntype interval = iv: (int, int) | iv.0 <= iv.1 witness (0, 0)\n\nghost function length(iv: interval): int {\n  iv.1 - iv.0\n}\n\nghost predicate valid_interval(s: string, iv: interval) {\n  && (0 <= iv.0 <= iv.1 <= |s|)\n  && (forall i, j | iv.0 <= i < j < iv.1 :: s[i] != s[j])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod lengthOfLongestSubstring(s: string) returns (n: int, ghost best_iv: interval)\n  ensures valid_interval(s, best_iv) && length(best_iv) == n\n  ensures forall iv | valid_interval(s, iv) :: length(iv) <= n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* https://leetcode.com/problems/longest-substring-without-repeating-characters/\nGiven a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n*/\n\n\n// a left-inclusive right-exclusive interval:\ntype interval = iv: (int, int) | iv.0 <= iv.1 witness (0, 0)\n\nghost function length(iv: interval): int {\n  iv.1 - iv.0\n}\n\nghost predicate valid_interval(s: string, iv: interval) {\n  && (0 <= iv.0 <= iv.1 <= |s|)                             // interval is in valid range\n  && (forall i, j | iv.0 <= i < j < iv.1 :: s[i] != s[j])   // no repeating characters in interval\n}\n\n// Below shows an efficient solution using standard \"sliding window\" technique. \n// For verification simplicity, we pretend as if:\n// - `set` were Python set (or even better, a fixed-size array -- if the \"alphabet\" is small)\n//\n// `best_iv` is for verification purpose, not returned by the real program, thus `ghost`.\n\n/* Discussions\n1. The \"sliding window\" technique is the most \"fancy\" part of the solution,\n  ensuring an O(n) time despite the O(n^2) search space.\n  The reason why it works lies in the last two invariants: (A) and (B).\n\n  Invariant (A) is simply a \"partial\" guarantee for the longest valid substring in `s[..hi]`,\n  so once the loop finishes, as `hi == |s|`, this \"partial\" guarantee becomes \"full\".\n\n  Invariant (B) is crucial: it encodes why we can monotonically increase `lo` as we increase `hi`.\n  What's the \"intuition\" behind that? Let me share an \"informal proof\" below:\n\n    Let `sub(i)` be the longest valid substring whose last character is `s[i]`.\n    Apparently, the final answer will be \"the longest among the longests\", i.e.\n    `max(|sub(0)|, |sub(1)|, ..., |sub(|s|-1)|)`.\n\n    Now, notice that the \"starting position\" of `sub(i)` is monotonically increasing regarding `i`!\n    Otherwise, imagine `sub(i+1)` started at `j` while `sub(i)` started at `j+1` (or even worse),\n    then `sub(i)` could be made longer (by starting at `j` instead).\n    This is an obvious contradiction.\n\n    Therefore, when we search for the starting position of `sub(i)` (the `lo`) for each `i` (the `hi`),\n    there's no need to \"look back\".\n\n2. The solution above can be made more efficient, using \"jumping window\" instead of \"sliding window\".\n  Namely, we use a dict (instead of set) to look up the \"position of repetition\",\n  and move `lo` right after that position at once.\n\n  You can even \"early terminate\" (based on `lo`) when all remaining intervals are doomed \"no longer\",\n  resulting in even fewer number of loop iterations.\n  (Time complexity will still be O(n), though.)\n\n  The corresponding verification code is shown below:\n*/\n\n\n// For verification simplicity, we pretend as if:\n// - `map` were Python dict (or even better, a fixed-size array -- if the \"alphabet\" is small)\n\n// Bonus Question:\n//   \"Why can we safely use (C) instead of (D) as the loop condition? Won't `hi` go out-of-bound?\"\n// Can you figure it out?\n\n// <vc-helpers>\nghost predicate validWindow(s: string, lo: int, hi: int, chars: set<char>) {\n  && 0 <= lo <= hi <= |s|\n  && chars == set i | lo <= i < hi :: s[i]\n  && |chars| == hi - lo\n}\n\nlemma validWindowImpliesValidInterval(s: string, lo: int, hi: int, chars: set<char>)\n  requires validWindow(s, lo, hi, chars)\n  ensures valid_interval(s, (lo, hi))\n{\n  var iv := (lo, hi);\n  assert 0 <= iv.0 <= iv.1 <= |s|;\n  \n  forall i, j | iv.0 <= i < j < iv.1\n    ensures s[i] != s[j]\n  {\n    assert s[i] in chars && s[j] in chars;\n    if s[i] == s[j] {\n      assert |chars| < hi - lo;\n      assert false;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod lengthOfLongestSubstring(s: string) returns (n: int, ghost best_iv: interval)\n  ensures valid_interval(s, best_iv) && length(best_iv) == n    /** `best_iv` is valid */\n  ensures forall iv | valid_interval(s, iv) :: length(iv) <= n  /** `best_iv` is longest */\n// </vc-spec>\n// <vc-code>\n{\n  if |s| == 0 {\n    return 0, (0, 0);\n  }\n  \n  var lo := 0;\n  var hi := 0;\n  var chars: set<char> := {};\n  var best_len := 0;\n  ghost var best_interval := (0, 0);\n  \n  while hi < |s|\n    invariant 0 <= lo <= hi <= |s|\n    invariant validWindow(s, lo, hi, chars)\n    invariant valid_interval(s, best_interval)\n    invariant length(best_interval) == best_len\n    invariant forall iv | valid_interval(s, iv) && iv.1 <= hi :: length(iv) <= best_len\n  {\n    if s[hi] in chars {\n      chars := chars - {s[lo]};\n      lo := lo + 1;\n    } else {\n      chars := chars + {s[hi]};\n      hi := hi + 1;\n      \n      if hi - lo > best_len {\n        best_len := hi - lo;\n        best_interval := (lo, hi);\n        validWindowImpliesValidInterval(s, lo, hi, chars);\n      }\n    }\n  }\n  \n  n := best_len;\n  best_iv := best_interval;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin.dfy", "// <vc-preamble>\nfunction min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\n\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n\n  }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\n\n\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n\n  }\n\n// <vc-helpers>\nlemma MinInArray(v: array<int>, i: int)\n  requires 1 <= i <= v.Length\n  ensures min(v, i) in v[0..i]\n{\n  if i == 1 {\n    assert v[0] == min(v, i);\n    assert v[0] in v[0..i];\n  } else {\n    MinInArray(v, i-1);\n    if v[i-1] <= min(v, i-1) {\n      assert min(v, i) == v[i-1];\n      assert v[i-1] in v[0..i];\n    } else {\n      assert min(v, i) == min(v, i-1);\n      assert min(v, i-1) in v[0..i-1];\n      assert v[0..i-1] <= v[0..i];\n    }\n  }\n}\n\nlemma CountMinCorrect(v: array<int>, x: int, i: int, target: int)\n  requires 0 <= i <= v.Length\n  requires target in v[0..i]\n  ensures countMin(v, target, i) > 0\n{\n  if i > 0 {\n    if v[i-1] == target {\n      assert countMin(v, target, i) == 1 + countMin(v, target, i-1);\n    } else {\n      assert target in v[0..i-1];\n      CountMinCorrect(v, x, i-1, target);\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm\n// </vc-spec>\n// <vc-code>\n{\n  var minVal := v[0];\n  var i := 1;\n  \n  while i < v.Length\n    invariant 1 <= i <= v.Length\n    invariant minVal == min(v, i)\n  {\n    if v[i] < minVal {\n      minVal := v[i];\n    }\n    i := i + 1;\n  }\n  \n  c := 0;\n  i := 0;\n  \n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant c == countMin(v, minVal, i)\n  {\n    if v[i] == minVal {\n      c := c + 1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring.dfy", "root", true, "", "", false, "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring.dfy", "// <vc-preamble>\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\nlemma isSubstringCorrectness(sub: string, str: string)\n    ensures isSubstringPred(sub, str) <==> !isNotSubstringPred(sub, str)\n{\n    if isSubstringPred(sub, str) {\n        var i :| 0 <= i <= |str| && isPrefixPred(sub, str[i..]);\n        assert !isNotPrefixPred(sub, str[i..]);\n        assert !isNotSubstringPred(sub, str);\n    } else {\n        assert forall i :: 0 <= i <= |str| ==> !isPrefixPred(sub, str[i..]);\n        assert forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub, str[i..]);\n        assert isNotSubstringPred(sub, str);\n    }\n}\n\nlemma isPrefixCorrectness(pre: string, str: string)\n    ensures isPrefixPred(pre, str) <==> !isNotPrefixPred(pre, str)\n{\n    if isPrefixPred(pre, str) {\n        assert |pre| <= |str| && pre == str[..|pre|];\n        assert !isNotPrefixPred(pre, str);\n    } else {\n        assert |pre| > |str| || pre != str[..|pre|];\n        assert isNotPrefixPred(pre, str);\n    }\n}\n\nlemma emptyStringIsSubstring(str: string)\n    ensures isSubstringPred(\"\", str)\n{\n    assert isPrefixPred(\"\", str[0..]);\n    assert isSubstringPred(\"\", str);\n}\n\nlemma haveCommonKSubstringWhenKIsZero(str1: string, str2: string)\n    ensures haveCommonKSubstringPred(0, str1, str2)\n{\n    emptyStringIsSubstring(str2);\n    assert isSubstringPred(\"\", str2);\n    assert str1[0..0] == \"\";\n    assert isSubstringPred(str1[0..0], str2);\n    assert haveCommonKSubstringPred(0, str1, str2);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>\n// <vc-code>\n{\n    if k == 0 {\n        found := true;\n        haveCommonKSubstringWhenKIsZero(str1, str2);\n        return;\n    }\n    \n    if |str1| < k {\n        found := false;\n        return;\n    }\n    \n    found := false;\n    var i := 0;\n    \n    while i <= |str1| - k\n        invariant 0 <= i <= |str1| - k + 1\n        invariant !found ==> forall i1, j1 :: 0 <= i1 < i && j1 == i1 + k ==> isNotSubstringPred(str1[i1..j1], str2)\n        invariant found ==> haveCommonKSubstringPred(k, str1, str2)\n    {\n        var substring := str1[i..i+k];\n        var isSubResult := isSubstring(substring, str2);\n        \n        if isSubResult {\n            found := true;\n            assert isPrefixPred(substring, str2[0..]) || (exists idx :: 0 < idx <= |str2| && isPrefixPred(substring, str2[idx..]));\n            assert isSubstringPred(substring, str2);\n            assert haveCommonKSubstringPred(k, str1, str2);\n            return;\n        } else {\n            isSubstringCorrectness(substring, str2);\n            assert isNotSubstringPred(substring, str2);\n        }\n        \n        i := i + 1;\n    }\n    \n    assert forall i1, j1 :: 0 <= i1 <= |str1| - k && j1 == i1 + k ==> isNotSubstringPred(str1[i1..j1], str2);\n    assert haveNotCommonKSubstringPred(k, str1, str2);\n    assert !haveCommonKSubstringPred(k, str1, str2);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_262_SplitArray.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_262_SplitArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitArray(arr: array<int>, L: int) returns (firstPart: seq<int>, secondPart: seq<int>)\n    requires 0 <= L <= arr.Length\n    ensures |firstPart| == L\n    ensures |secondPart| == arr.Length - L\n    ensures firstPart + secondPart == arr[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitArray(arr: array<int>, L: int) returns (firstPart: seq<int>, secondPart: seq<int>)\n    requires 0 <= L <= arr.Length\n    ensures |firstPart| == L\n    ensures |secondPart| == arr.Length - L\n    ensures firstPart + secondPart == arr[..]\n// </vc-spec>\n// <vc-code>\n{\n  firstPart := arr[..L];\n  secondPart := arr[L..];\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search.dfy", "// <vc-preamble>\npredicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod search(v:array<int>,elem:int) returns (b:bool)\n requires sorted(v[0..v.Length])\nensures b==(elem in v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma binary_search_correctness(v: array<int>, elem: int, p: int)\n  requires sorted(v[0..v.Length])\n  requires -1 <= p < v.Length\n  requires (forall u :: 0 <= u <= p ==> v[u] <= elem) && (forall w :: p < w < v.Length ==> v[w] > elem)\n  ensures (elem in v[0..v.Length]) <==> (p >= 0 && p < v.Length && v[p] == elem)\n{\n  if elem in v[0..v.Length] {\n    var i :| 0 <= i < v.Length && v[i] == elem;\n    if i <= p {\n      assert v[i] <= elem;\n      assert v[i] == elem;\n    } else {\n      assert v[i] > elem;\n      assert v[i] == elem;\n      assert false;\n    }\n    assert i <= p;\n    assert v[i] <= elem && v[i] == elem;\n    assert p >= 0;\n    \n    if p < v.Length {\n      if v[p] < elem {\n        assert v[p] <= elem && v[p] < elem;\n        var j := p + 1;\n        while j < v.Length && v[j] <= elem\n          invariant p < j <= v.Length\n          invariant forall k :: p < k < j ==> v[k] <= elem\n        {\n          j := j + 1;\n        }\n        if j < v.Length {\n          assert v[j] > elem;\n          assert p < j;\n          assert false;\n        }\n      }\n      assert v[p] >= elem;\n      assert v[p] <= elem;\n      assert v[p] == elem;\n    }\n  }\n  \n  if p >= 0 && p < v.Length && v[p] == elem {\n    assert elem in v[0..v.Length];\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod search(v:array<int>,elem:int) returns (b:bool)\n requires sorted(v[0..v.Length])\nensures b==(elem in v[0..v.Length])\n //Implement by calling binary search function\n// </vc-spec>\n// <vc-code>\n{\n  var pos := binarySearch(v, elem);\n  binary_search_correctness(v, elem, pos);\n  if pos >= 0 && pos < v.Length && v[pos] == elem {\n    b := true;\n  } else {\n    b := false;\n  }\n}\n// </vc-code>\n\n//Recursive binary search", "", "", ""], ["cs245-verification_tmp_tmp0h_nxhqp_power_compute_power.dfy", "root", true, "", "", false, "cs245-verification_tmp_tmp0h_nxhqp_power_compute_power.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nfunction power(a: int, n: int): int\n  requires 0 <= a && 0 <= n;\n  decreases n;{if (n == 0) then 1 else a * power(a, n - 1)}\n\nmethod compute_power(a: int, n: int) returns (s: int)\n  requires n >= 0 && a >= 0;\n  ensures s == power(a,n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//power -- Stephanie Renee McIntyre\n//Based on the code used in the course overheads for Fall 2018\n\n//There is no definition for power, so this function will be used for validating that our imperative program is correct.\n\n/* Proof of implied (a): Follows from definition of the power function. */\n\n/* Proof of implied (b): Details left as exercise, but this is relatively simple. */\n\n/* Proof of implied (c): Simple substitution and uses the fact that i=n. */\n\n/* Proof of termination: the loop guard gives us the expression i<n. This is equivalent to n-i>=0.\n   Prior to the loop, n>=0 and i=0.\n   Each iteration of the loop, i increases by 1 and thus n-i decreases by 1. Thus n-i will eventually reach 0.\n   When the n-i=0, n=i and thus the loop guard ends the loop as it is no longer the case that i<n.\n   Thus the program terminates.\n*/\n\n// <vc-helpers>\nlemma PowerMultiplicative(a: int, i: int, n: int)\n  requires 0 <= a && 0 <= i && i <= n\n  ensures power(a, i) * power(a, n - i) == power(a, n)\n  decreases n - i\n{\n  if i == n {\n    assert power(a, n - i) == power(a, 0) == 1;\n  } else {\n    PowerMultiplicative(a, i + 1, n);\n    assert power(a, i) * power(a, n - i) == power(a, i) * a * power(a, n - i - 1);\n    assert power(a, i) * a * power(a, n - i - 1) == a * (power(a, i) * power(a, n - i - 1));\n    assert a * (power(a, i) * power(a, n - i - 1)) == a * power(a, i + (n - i - 1));\n    assert a * power(a, i + (n - i - 1)) == a * power(a, n - 1);\n    assert a * power(a, n - 1) == power(a, n);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nfunction power(a: int, n: int): int //function for a to the power of n\n  requires 0 <= a && 0 <= n;\n  decreases n;{if (n == 0) then 1 else a * power(a, n - 1)}\n\n//Our code from class\nmethod compute_power(a: int, n: int) returns (s: int)\n/*Pre-Condition*/   requires n >= 0 && a >= 0;\n/*Post-Condition*/  ensures s == power(a,n);\n// </vc-spec>\n// <vc-code>\n{\n  s := 1;\n  var i := 0;\n  \n  while i < n\n    invariant 0 <= i <= n\n    invariant s == power(a, i)\n    decreases n - i\n  {\n    s := s * a;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mroot1(n:int) returns (r:int)\nrequires n>=0\nensures r>=0 && r*r <= n <(r+1)*(r+1)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mroot1(n:int) returns (r:int) //Cost O(root n)\nrequires n>=0\nensures r>=0 && r*r <= n <(r+1)*(r+1)\n// </vc-spec>\n// <vc-code>\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r >= 0\n    invariant r * r <= n\n    decreases n - r * r\n  {\n    r := r + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows.dfy", "root", true, "", "", false, "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows.dfy", "// <vc-preamble>\nfunction bullspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{reccbull(s, u, 0)}\n\nfunction cowspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{recccow(s, u, 0)}\n\nfunction reccbull(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i ==|s| then 0\n    else if s[i] == u[i] then reccbull(s, u, i + 1) + 1\n    else reccbull(s, u, i + 1)\n}\n\nfunction recccow(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i == |s| then 0\n    else if s[i] != u[i] && u[i] in s then recccow(s, u, i + 1) + 1\n    else recccow(s, u, i + 1)\n}\n\npredicate nomultiples(u:seq<nat>) \n{forall j, k :: 0<=j<k<|u| ==> u[j] != u[k]}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BullsCows (s:seq<nat>, u:seq<nat>) returns (b:nat, c:nat) \nrequires 0 < |u| == |s| <= 10\nrequires nomultiples(u) && nomultiples(s);\nensures b >= 0 && c >= 0\nensures b == bullspec(s, u)\nensures c == cowspec(s, u)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// see pdf 'ex6 & 7 documentation' for excercise question\n\nfunction bullspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{reccbull(s, u, 0)}\n\nfunction cowspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{recccow(s, u, 0)}\n\nfunction reccbull(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i ==|s| then 0\n    else if s[i] == u[i] then reccbull(s, u, i + 1) + 1\n    else reccbull(s, u, i + 1)\n}\n\nfunction recccow(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i == |s| then 0\n    else if s[i] != u[i] && u[i] in s then recccow(s, u, i + 1) + 1\n    else recccow(s, u, i + 1)\n}\n\npredicate nomultiples(u:seq<nat>) \n{forall j, k :: 0<=j<k<|u| ==> u[j] != u[k]}\n\n// <vc-helpers>\nlemma BullsLemma(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i <= |s| == |u|\n    ensures reccbull(s, u, 0) - reccbull(s, u, i) == reccbull(s, u, 0) - reccbull(s, u, i)\n{\n}\n\nlemma CowsLemma(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i <= |s| == |u|\n    ensures recccow(s, u, 0) - recccow(s, u, i) >= 0\n    decreases |s| - i\n{\n    if i == |s| {\n        assert recccow(s, u, i) == 0;\n        CowsNonNegative(s, u, 0);\n    } else {\n        CowsLemma(s, u, i + 1);\n        assert recccow(s, u, 0) - recccow(s, u, i + 1) >= 0;\n        if s[i] != u[i] && u[i] in s {\n            assert recccow(s, u, i) == recccow(s, u, i + 1) + 1;\n            assert recccow(s, u, 0) - recccow(s, u, i) == recccow(s, u, 0) - recccow(s, u, i + 1) - 1;\n        } else {\n            assert recccow(s, u, i) == recccow(s, u, i + 1);\n            assert recccow(s, u, 0) - recccow(s, u, i) == recccow(s, u, 0) - recccow(s, u, i + 1);\n        }\n    }\n}\n\nlemma CowsNonNegative(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i <= |s| == |u|\n    ensures recccow(s, u, i) >= 0\n    decreases |s| - i\n{\n    if i == |s| {\n        assert recccow(s, u, i) == 0;\n    } else {\n        CowsNonNegative(s, u, i + 1);\n    }\n}\n\nlemma BullsInvariantLemma(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i < |s| == |u|\n    ensures (if s[i] == u[i] then 1 else 0) == reccbull(s, u, i) - reccbull(s, u, i + 1)\n{\n}\n\nlemma CowsInvariantLemma(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i < |s| == |u|\n    ensures (if s[i] != u[i] && u[i] in s then 1 else 0) == recccow(s, u, i) - recccow(s, u, i + 1)\n{\n}\n\nlemma CowsPreservesInvariant(s: seq<nat>, u: seq<nat>, i: int)\n    requires 0 <= i < |s| == |u|\n    requires recccow(s, u, 0) - recccow(s, u, i) >= 0\n    ensures recccow(s, u, 0) - recccow(s, u, i + 1) >= 0\n{\n    CowsLemma(s, u, i + 1);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BullsCows (s:seq<nat>, u:seq<nat>) returns (b:nat, c:nat) \nrequires 0 < |u| == |s| <= 10\nrequires nomultiples(u) && nomultiples(s);\nensures b >= 0 && c >= 0\nensures b == bullspec(s, u)\nensures c == cowspec(s, u)\n// </vc-spec>\n// <vc-code>\n{\n    b := 0;\n    c := 0;\n    var i := 0;\n    \n    CowsLemma(s, u, 0);\n    \n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant b == reccbull(s, u, 0) - reccbull(s, u, i)\n        invariant c == recccow(s, u, 0) - recccow(s, u, i)\n        invariant recccow(s, u, 0) - recccow(s, u, i) >= 0\n    {\n        CowsPreservesInvariant(s, u, i);\n        if s[i] == u[i] {\n            BullsInvariantLemma(s, u, i);\n            b := b + 1;\n        } else if u[i] in s {\n            CowsInvariantLemma(s, u, i);\n            c := c + 1;\n        } else {\n            BullsInvariantLemma(s, u, i);\n            CowsInvariantLemma(s, u, i);\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_3_IsNonPrime.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_3_IsNonPrime.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma DivisorExists(n: int, k: int)\n    requires n >= 2 && 2 <= k < n && n % k == 0\n    ensures exists d :: 2 <= d < n && n % d == 0\n{\n    assert 2 <= k < n && n % k == 0;\n}\n\nlemma NoDivisorMeansNone(n: int)\n    requires n >= 2\n    requires forall k :: 2 <= k < n ==> n % k != 0\n    ensures !(exists k :: 2 <= k < n && n % k == 0)\n{\n    if exists k :: 2 <= k < n && n % k == 0 {\n        var w :| 2 <= w < n && n % w == 0;\n        assert n % w != 0;\n        assert false;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n// </vc-spec>\n// <vc-code>\n{\n    var i := 2;\n    while i < n\n        invariant 2 <= i <= n\n        invariant forall k :: 2 <= k < i ==> n % k != 0\n    {\n        if n % i == 0 {\n            DivisorExists(n, i);\n            return true;\n        }\n        i := i + 1;\n    }\n    \n    assert forall k :: 2 <= k < n ==> n % k != 0;\n    NoDivisorMeansNone(n);\n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap.dfy", "// <vc-preamble>\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap<T>(a: array<T>, i: int, j: int)\n\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap<T>(a: array<T>, i: int, j: int)\n  // requires a != null\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_cal_ans_CalDiv.dfy", "root", true, "", "", false, "Clover_cal_ans_CalDiv.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n// </vc-spec>\n// <vc-code>\n{\n  x := 191 / 7;\n  y := 191 % 7;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_792_CountLists.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_792_CountLists.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountLists(lists: seq<seq<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |lists|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountLists(lists: seq<seq<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |lists|\n// </vc-spec>\n// <vc-code>\n{\n  count := |lists|;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort.dfy", "root", true, "", "", false, "Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Works by dividing the input list into two parts: sorted and unsorted. At the beginning, \n// the sorted part is empty and the unsorted part contains all the elements.\n\n// <vc-helpers>\nlemma MinIndexCorrect(a: array<int>, start: int, minIndex: int)\n  requires 0 <= start < a.Length\n  requires start <= minIndex < a.Length\n  requires forall k :: start <= k < a.Length ==> a[minIndex] <= a[k]\n  ensures forall k :: start <= k < a.Length ==> a[minIndex] <= a[k]\n{\n}\n\nlemma SwapPreservesMultiset(a: array<int>, i: int, j: int, oldContent: seq<int>)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  requires oldContent == a[..]\n  ensures i == j ==> multiset(a[..]) == multiset(oldContent)\n  ensures i != j && i < j ==> multiset(a[0..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..]) == multiset(oldContent)\n  ensures i != j && j < i ==> multiset(a[0..j] + [a[i]] + a[j+1..i] + [a[j]] + a[i+1..]) == multiset(oldContent)\n{\n  if i == j {\n    return;\n  }\n  if i < j {\n    assert a[..] == a[0..i] + [a[i]] + a[i+1..j] + [a[j]] + a[j+1..];\n    assert multiset(a[0..i] + [a[i]] + a[i+1..j] + [a[j]] + a[j+1..]) == multiset(a[0..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..]);\n  } else {\n    assert a[..] == a[0..j] + [a[j]] + a[j+1..i] + [a[i]] + a[i+1..];\n    assert multiset(a[0..j] + [a[j]] + a[j+1..i] + [a[i]] + a[i+1..]) == multiset(a[0..j] + [a[i]] + a[j+1..i] + [a[j]] + a[i+1..]);\n  }\n}\n\nlemma SortedPartitionPreserved(a: array<int>, sortedEnd: int)\n  requires 0 <= sortedEnd < a.Length\n  requires forall i,j :: 0 <= i < j < sortedEnd ==> a[i] <= a[j]\n  requires forall k :: 0 <= k < sortedEnd ==> a[k] <= a[sortedEnd]\n  ensures forall i,j :: 0 <= i < j <= sortedEnd ==> a[i] <= a[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n  // Ensures the final array is sorted in ascending order\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  // Ensures that the final array has the same elements as the initial array\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var n := a.Length;\n  if n <= 1 {\n    return;\n  }\n  \n  var i := 0;\n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant forall x,y :: 0 <= x < y < i ==> a[x] <= a[y]\n    invariant forall x :: 0 <= x < i ==> forall y :: i <= y < n ==> a[x] <= a[y]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var minIndex := i;\n    var j := i + 1;\n    \n    while j < n\n      invariant i <= minIndex < n\n      invariant i < j <= n\n      invariant forall k :: i <= k < j ==> a[minIndex] <= a[k]\n    {\n      if a[j] < a[minIndex] {\n        minIndex := j;\n      }\n      j := j + 1;\n    }\n    \n    if minIndex != i {\n      var oldContent := a[..];\n      var temp := a[i];\n      a[i] := a[minIndex];\n      a[minIndex] := temp;\n      assert multiset(a[..]) == multiset(oldContent);\n    }\n    \n    if i + 1 < n {\n      SortedPartitionPreserved(a, i);\n    }\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_412_RemoveOddNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_412_RemoveOddNumbers.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n\n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n * Remove odd numbers from an array of numbers\n **/\n\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\n// <vc-helpers>\nlemma InSeqPreservation(s: seq<int>, x: int)\n    requires x in s\n    ensures x in (s + [x])\n{\n}\n\nlemma SeqAppendMembership<T>(s: seq<T>, x: T)\n    ensures x in (s + [x])\n{\n}\n\nlemma SeqAppendPreservesMembership<T>(s: seq<T>, t: seq<T>, x: T)\n    requires x in s\n    ensures x in (s + t)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>\n// <vc-code>\n{\n    evenList := [];\n    var i := 0;\n    \n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant forall j :: 0 <= j < |evenList| ==> IsEven(evenList[j]) && evenList[j] in arr[..]\n        invariant forall j :: 0 <= j < i && IsEven(arr[j]) ==> arr[j] in evenList\n    {\n        if IsEven(arr[i]) {\n            evenList := evenList + [arr[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find.dfy", "root", true, "", "", false, "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find.dfy", "// <vc-preamble>\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next &&\n     path(p[1..], graph))\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| &&\n  start == p[0] && end == p[|p|-1] &&\n  path(p, graph)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> (forall k :: 0 <= k < a.Length ==> a[k] != key)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\n\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> (forall k :: 0 <= k < a.Length ==> a[k] != key)\n// </vc-spec>\n// <vc-code>\n{\n  index := -1;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant index < 0\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      index := i;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_105_CountTrue.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_105_CountTrue.dfy", "// <vc-preamble>\nfunction countTo( a:array<bool>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else countTo(a, n-1) + (if a[n-1] then 1 else 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountTrue(a: array<bool>) returns (result: int)\n    requires a != null\n    ensures result == countTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function countTo( a:array<bool>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else countTo(a, n-1) + (if a[n-1] then 1 else 0)\n}\n\n// <vc-helpers>\nlemma countToIncremental(a: array<bool>, n: int)\n    requires 0 <= n < a.Length\n    ensures countTo(a, n+1) == countTo(a, n) + (if a[n] then 1 else 0)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountTrue(a: array<bool>) returns (result: int)\n    requires a != null\n    ensures result == countTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n    result := 0;\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant result == countTo(a, i)\n    {\n        if a[i] {\n            result := result + 1;\n        }\n        countToIncremental(a, i);\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip.dfy", "root", true, "", "", false, "Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// flips (i.e., reverses) array elements in the range [0..num]\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i <= num / 2\n    invariant 0 <= i <= num / 2 + 1\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[num-k])\n    invariant forall k :: 0 <= k < i ==> a[num-k] == old(a[k])\n    invariant forall k :: num + 1 <= k < a.Length ==> a[k] == old(a[k])\n    invariant forall k :: i <= k <= num - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[num - i];\n    a[num - i] := temp;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_sol_bubbleSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_sol_bubbleSort.dfy", "// <vc-preamble>\npredicate sorted_between (a:array<int>, from:nat, to:nat)\n  reads a;\n  requires a != null;\n  requires from <= to;\n  requires to <= a.Length;\n{\n  forall i,j :: from <= i < j < to && 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\npredicate sorted (a:array<int>)\n  reads a;\n  requires a!=null;\n{\n  sorted_between (a, 0, a.Length)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSort (a: array<int>)\n  modifies a;\n  requires a != null;\n  requires a.Length > 0;\n  ensures sorted(a);\n  ensures multiset(old(a[..])) == multiset(a[..]);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_433_IsGreater.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_433_IsGreater.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsGreater(n: int, a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> n > a[i]\n    ensures !result ==> exists i :: 0 <= i < a.Length && n <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsGreater(n: int, a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> n > a[i]\n    ensures !result ==> exists i :: 0 <= i < a.Length && n <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall j :: 0 <= j < i ==> n > a[j]\n    {\n        if n <= a[i] {\n            return false;\n        }\n        i := i + 1;\n    }\n    return true;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-programs_tmp_tmpnso9eu7u_Algorithms___sorting_bubble-sort_BubbleSort.dfy", "root", false, "", "", false, "Dafny-programs_tmp_tmpnso9eu7u_Algorithms___sorting_bubble-sort_BubbleSort.dfy", "// <vc-preamble>\npredicate sorted_between(A:array<int>, from:int, to:int)\n    reads A\n{\n    forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]\n}\n\npredicate sorted(A:array<int>)\n    reads A\n{\n    sorted_between(A, 0, A.Length-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort(A:array<int>)\n    modifies A\n    ensures sorted(A)\n    ensures multiset(A[..]) == multiset(old(A[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_644_ReverseUptoK.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_644_ReverseUptoK.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReverseUptoK(s: array<int>, k: int)\n    modifies s\n    requires 2 <= k <= s.Length\n    ensures forall i :: 0 <= i < k ==> s[i] == old(s[k - 1 - i])\n    ensures forall i :: k <= i < s.Length ==> s[i] == old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReverseUptoK(s: array<int>, k: int)\n    modifies s\n    requires 2 <= k <= s.Length\n    ensures forall i :: 0 <= i < k ==> s[i] == old(s[k - 1 - i])\n    ensures forall i :: k <= i < s.Length ==> s[i] == old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n    var left := 0;\n    var right := k - 1;\n    \n    while left < right\n        invariant 0 <= left <= right + 1 <= k\n        invariant forall i :: 0 <= i < left ==> s[i] == old(s[k - 1 - i])\n        invariant forall i :: right < i < k ==> s[i] == old(s[k - 1 - i])\n        invariant forall i :: k <= i < s.Length ==> s[i] == old(s[i])\n    {\n        var temp := s[left];\n        s[left] := s[right];\n        s[right] := temp;\n        \n        left := left + 1;\n        right := right - 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_801_CountEqualNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_801_CountEqualNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountEqualNumbers(a: int, b: int, c: int) returns (count: int)\n    ensures count >= 0 && count <= 3\n    ensures (count == 3) <==> (a == b && b == c)\n    ensures (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c))\n    ensures (count == 1) <==> (a != b && b != c && a != c)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountEqualNumbers(a: int, b: int, c: int) returns (count: int)\n    ensures count >= 0 && count <= 3\n    ensures (count == 3) <==> (a == b && b == c)\n    ensures (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c))\n    ensures (count == 1) <==> (a != b && b != c && a != c)\n// </vc-spec>\n// <vc-code>\n{\n  if a == b && b == c {\n    count := 3;\n  } else if (a == b && b != c) || (a != b && b == c) || (a == c && b != c) {\n    count := 2;\n  } else {\n    count := 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse.dfy", "root", true, "", "", false, "FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a.Length == b.Length\nensures forall k :: 0 <= k < a.Length ==> b[k] == a[(a.Length-1) - k];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Write an *iterative* Dafny method Reverse with signature:\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\n//          method Reverse(a: array<char>) returns (b: array<char>)\n\n// which takes an input array of characters 'a' and outputs array 'b' consisting of\n// the elements of the input array in reverse order. The following conditions apply:\n//  - the input array cannot be empty\n//  - the input array is not modified\n//  - you must use iteration\n//  - not permitted is an *executable* (parallel) forall statement\n//  - not permitted are any other predicates, functions or methods\n\n// For the purposes of this practice exercise, I'll include a test method.\n\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a.Length == b.Length\nensures forall k :: 0 <= k < a.Length ==> b[k] == a[(a.Length-1) - k];\n// </vc-spec>\n// <vc-code>\n{\n  b := new char[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant b.Length == a.Length\n    invariant forall k :: 0 <= k < i ==> b[k] == a[(a.Length-1) - k]\n  {\n    b[i] := a[(a.Length-1) - i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n// Notice it compiles and the executable generates output (just to see the arrays printed in reverse).", "", "", ""], ["vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes.dfy", "root", true, "", "", false, "vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes.dfy", "// <vc-preamble>\nfunction suma_aux(V : array?<int>, n : int) : int\n\n  requires V != null\n  requires 0 <= n <= V.Length\n\n  decreases V.Length - n\n\n  reads V\n\n{\n\n  if (n == V.Length) then 0\n                     else V[n] + suma_aux(V, n + 1)\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod suma_componentes(V : array?<int>) returns (suma : int)\n\n  requires V != null\n  ensures  suma == suma_aux(V, 0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function suma_aux(V : array?<int>, n : int) : int\n\n  // suma_aux(V, n) = V[n] + V[n + 1] + ... + V[N - 1]\n\n  requires V != null            // P_0\n  requires 0 <= n <= V.Length       // Q_0\n\n  decreases V.Length - n        // C_0\n\n  reads V\n\n{\n\n  if (n == V.Length) then 0                     // Caso base:      n = N\n                     else V[n] + suma_aux(V, n + 1)     // Caso recursivo: n < N\n\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod suma_componentes(V : array?<int>) returns (suma : int)\n\n  requires V != null\n  ensures  suma == suma_aux(V, 0)   // x = V[0] + V[1] + ... + V[N - 1]\n// </vc-spec>\n// <vc-code>\n{\n  if V.Length == 0 {\n    suma := 0;\n  } else {\n    suma := 0;\n    var i := 0;\n    while i < V.Length\n      invariant 0 <= i <= V.Length\n      invariant suma == suma_aux(V, 0) - suma_aux(V, i)\n    {\n      suma := suma + V[i];\n      i := i + 1;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_798_ArraySum.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_798_ArraySum.dfy", "// <vc-preamble>\nfunction sumTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else sumTo(a, n-1) + a[n-1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySum(a: array<int>) returns (result: int)\n    ensures result == sumTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sumTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else sumTo(a, n-1) + a[n-1]\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySum(a: array<int>) returns (result: int)\n    ensures result == sumTo(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n    result := 0;\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant result == sumTo(a, i)\n    {\n        result := result + a[i];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_637_IsBreakEven.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_637_IsBreakEven.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsBreakEven(costPrice: int, sellingPrice: int) returns (result: bool)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures result <==> costPrice == sellingPrice\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsBreakEven(costPrice: int, sellingPrice: int) returns (result: bool)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures result <==> costPrice == sellingPrice\n// </vc-spec>\n// <vc-code>\n{\n  result := costPrice == sellingPrice;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_803_IsPerfectSquare.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_803_IsPerfectSquare.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPerfectSquare(n: int) returns (result: bool)\n    requires n >= 0\n    ensures result == true ==> (exists i: int :: 0 <= i <= n && i * i == n)\n    ensures result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SquareMonotonic(a: int, b: int)\n    requires 0 <= a <= b\n    ensures a * a <= b * b\n{\n}\n\nlemma SquareGrowth(i: int)\n    requires i >= 0\n    ensures i * i >= i\n{\n}\n\nlemma SquareBounds(i: int, n: int)\n    requires i > 0 && i * i > n\n    ensures forall j: int :: j > i ==> j * j > n\n{\n}\n\nlemma ExistsWitness(i: int, n: int)\n    requires 0 <= i <= n && i * i == n\n    ensures exists j: int :: 0 <= j <= n && j * j == n\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPerfectSquare(n: int) returns (result: bool)\n    requires n >= 0\n    ensures result == true ==> (exists i: int :: 0 <= i <= n && i * i == n)\n    ensures result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        assert 0 <= 0 <= n && 0 * 0 == n;\n        return true;\n    }\n    \n    var i := 0;\n    while i <= n && i * i <= n\n        invariant 0 <= i <= n + 1\n        invariant forall j: int :: 0 <= j < i ==> j * j != n\n        invariant i <= n + 1\n        decreases n - i * i + 1\n    {\n        if i * i == n {\n            assert 0 <= i <= n && i * i == n;\n            ExistsWitness(i, n);\n            return true;\n        }\n        i := i + 1;\n    }\n    \n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_swap.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_swap.dfy", "// <vc-preamble>\npredicate valid_permut(a: seq<int>, b: seq<int>)\n  requires |a| == |b|\n{\n  multiset(a) == multiset(b)\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i, j | 0 <= i <= j < |a| :: a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[..] == old(a[..]) [i := old(a[j])] [j := old(a[i])]\n  ensures valid_permut(a[..], old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Search.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Search.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_399_BitwiseXOR.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_399_BitwiseXOR.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BitwiseXOR(a: seq<bv32>, b: seq<bv32>) returns (result: seq<bv32>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] ^ b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod BitwiseXOR(a: seq<bv32>, b: seq<bv32>) returns (result: seq<bv32>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] ^ b[i]\n// </vc-spec>\n// <vc-code>\n{\n  result := [];\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == a[j] ^ b[j]\n  {\n    result := result + [a[i] ^ b[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_bubblesort_BubbleSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_bubblesort_BubbleSort.dfy", "// <vc-preamble>\nfunction NChoose2(n: int): int\n{\n  n * (n - 1) / 2\n}\n\nfunction SumRange(lo: int, hi: int): int\n  decreases hi - lo\n{\n  if lo >= hi then 0\n  else SumRange(lo, hi - 1) + hi - 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort(a: array<int>) returns (n: nat) \n  modifies a\n  ensures n <= NChoose2(a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_606_DegreesToRadians.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_606_DegreesToRadians.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DegreesToRadians(degrees: real) returns (radians: real)\n    ensures radians == degrees * 3.14159265358979323846 / 180.0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DegreesToRadians(degrees: real) returns (radians: real)\n    ensures radians == degrees * 3.14159265358979323846 / 180.0\n// </vc-spec>\n// <vc-code>\n{\n  radians := degrees * 3.14159265358979323846 / 180.0;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_PercentileNonUniqueAnswer.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_PercentileNonUniqueAnswer.dfy", "// <vc-preamble>\nfunction SumUpto(A: array<real>, end: int): real\n  requires -1 <= end < A.Length\n  reads A\n{\n  if end == -1 then\n    0.0\n  else\n    A[end] + SumUpto(A, end-1)\n}\n\nfunction Sum(A: array<real>): real\n  reads A\n{\n  SumUpto(A, A.Length-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PercentileNonUniqueAnswer() returns (p: real, A: array<real>, total: real, i1: int, i2: int)\n  ensures forall i | 0 <= i < A.Length :: A[i] > 0.0\n  ensures 0.0 <= p <= 100.0\n  ensures total == Sum(A)\n  ensures total > 0.0\n\n  ensures -1 <= i1 < A.Length\n  ensures SumUpto(A, i1) <= (p/100.0) * total\n  ensures i1+1 < A.Length ==> SumUpto(A, i1+1) >= (p/100.0) * total\n\n  ensures -1 <= i2 < A.Length\n  ensures SumUpto(A, i2) <= (p/100.0) * total\n  ensures i2+1 < A.Length ==> SumUpto(A, i2+1) >= (p/100.0) * total\n\n  ensures i1 != i2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPrime (m : int) returns (isPrime : bool)\n    requires m > 0\n    ensures isPrime <==> (m > 1 && forall j : int :: 2 <= j < m ==> m % j != 0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPrime (m : int) returns (isPrime : bool)\n    requires m > 0 // m must be greater than 0\n    ensures isPrime <==> (m > 1 && forall j : int :: 2 <= j < m ==> m % j != 0) \n    // ensures states that \"isPrime is true iff m > 1 && not divisible by [2, m-1)\"\n// </vc-spec>\n// <vc-code>\n{\n    if m <= 1 {\n        isPrime := false;\n        return;\n    }\n    \n    var j := 2;\n    while j < m\n        invariant 2 <= j <= m\n        invariant forall k : int :: 2 <= k < j ==> m % k != 0\n    {\n        if m % j == 0 {\n            isPrime := false;\n            return;\n        }\n        j := j + 1;\n    }\n    \n    isPrime := true;\n}\n// </vc-code>\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven.dfy", "// <vc-preamble>\npredicate positive(s:seq<int>)\n{\n  forall u::0<=u<|s| ==> s[u]>=0\n  }\n\npredicate isEven(i:int)\nrequires i>=0\n{\n  i%2==0\n}\n\nfunction CountEven(s:seq<int>):int\ndecreases s\nrequires positive(s)\n{\n  if s==[] then 0\n  else (if (s[|s|-1]%2==0) then 1 else 0)+CountEven(s[..|s|-1])\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mcountEven(v:array<int>) \nreturns (n:int)\nrequires positive(v[..])\nensures  n==CountEven(v[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate positive(s:seq<int>)\n{\n  forall u::0<=u<|s| ==> s[u]>=0\n  }\n\npredicate isEven(i:int)\nrequires i>=0\n{\n  i%2==0\n}\n\nfunction CountEven(s:seq<int>):int\ndecreases s\nrequires positive(s)\n{\n  if s==[] then 0\n  else (if (s[|s|-1]%2==0) then 1 else 0)+CountEven(s[..|s|-1])\n\n}\n\n// <vc-helpers>\nlemma CountEvenPrefix(s: seq<int>, i: int)\nrequires positive(s)\nrequires 0 <= i <= |s|\nensures CountEven(s[..i]) == CountEven(s[0..i])\n{\n}\n\nlemma CountEvenIncremental(s: seq<int>, i: int)\nrequires positive(s)\nrequires 0 <= i < |s|\nensures CountEven(s[..i+1]) == CountEven(s[..i]) + (if s[i] % 2 == 0 then 1 else 0)\n{\n  if i == 0 {\n    assert s[..1] == [s[0]];\n    assert CountEven(s[..1]) == CountEven([s[0]]);\n  } else {\n    var prefix := s[..i+1];\n    var smallerPrefix := s[..i];\n    assert prefix == smallerPrefix + [s[i]];\n    CountEvenSuffixLemma(smallerPrefix, s[i]);\n  }\n}\n\nlemma CountEvenSuffixLemma(s: seq<int>, x: int)\nrequires positive(s)\nrequires x >= 0\nensures positive(s + [x])\nensures CountEven(s + [x]) == CountEven(s) + (if x % 2 == 0 then 1 else 0)\n{\n  var extended := s + [x];\n  assert extended[|extended|-1] == x;\n  assert extended[..|extended|-1] == s;\n}\n\nlemma CountEvenComplete(s: seq<int>)\nrequires positive(s)\nensures CountEven(s[..|s|]) == CountEven(s)\n{\n  assert s[..|s|] == s;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mcountEven(v:array<int>) \nreturns (n:int)\nrequires positive(v[..])\nensures  n==CountEven(v[..])\n// </vc-spec>\n// <vc-code>\n{\n  n := 0;\n  var i := 0;\n  \n  while i < v.Length\n  invariant 0 <= i <= v.Length\n  invariant n == CountEven(v[..i])\n  {\n    if v[i] % 2 == 0 {\n      n := n + 1;\n    }\n    \n    CountEvenIncremental(v[..], i);\n    i := i + 1;\n  }\n  \n  CountEvenComplete(v[..]);\n}\n// </vc-code>\n\n", "", "", ""], ["formal-verification_tmp_tmpoepcssay_strings3_isPrefix.dfy", "root", true, "", "", false, "formal-verification_tmp_tmpoepcssay_strings3_isPrefix.dfy", "// <vc-preamble>\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n// </vc-spec>\n// <vc-code>\n{\n  if |pre| > |str| {\n    res := false;\n  } else {\n    res := pre == str[..|pre|];\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI.dfy", "// <vc-preamble>\nghost function gcd(x: int, y: int): int\n    requires x > 0 && y > 0\n{\n    if x == y then x\n    else if x > y then gcd(x - y, y)\n    else gcd(x, y - x)\n}\n\nghost function gcd'(x: int, y: int): int\n    requires x > 0 && y > 0\n    decreases if x > y then x else y\n{\n    if x == y then x\n    else if x > y then gcd'(x - y, y)\n    else gcd(y, x)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdI(m: int, n: int) returns (d: int)\nrequires  m > 0 && n > 0 \nensures d == gcd(m, n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\n//a)\nghost function gcd(x: int, y: int): int\n    requires x > 0 && y > 0\n{\n    if x == y then x\n    else if x > y then gcd(x - y, y)\n    else gcd(x, y - x)\n}\n\n//b)\nghost function gcd'(x: int, y: int): int\n    requires x > 0 && y > 0\n    decreases if x > y then x else y\n{\n    if x == y then x\n    else if x > y then gcd'(x - y, y)\n    else gcd(y, x)\n}\n\n// <vc-helpers>\nlemma gcdSymmetric(x: int, y: int)\n    requires x > 0 && y > 0\n    ensures gcd(x, y) == gcd(y, x)\n{\n    if x == y {\n        assert gcd(x, y) == x == y == gcd(y, x);\n    } else if x > y {\n        assert x - y > 0;\n        gcdSymmetric(x - y, y);\n        assert gcd(x, y) == gcd(x - y, y) == gcd(y, x - y) == gcd(y, x);\n    } else {\n        assert y - x > 0;\n        gcdSymmetric(x, y - x);\n        assert gcd(x, y) == gcd(x, y - x) == gcd(y - x, x) == gcd(y, x);\n    }\n}\n\nlemma gcdModInvariant(x: int, y: int, k: int)\n    requires x > 0 && y > 0 && k > 0 && x >= k * y\n    ensures x - k * y > 0 ==> gcd(x, y) == gcd(x - k * y, y)\n    ensures x - k * y == 0 ==> gcd(x, y) == y\n    decreases k\n{\n    if k == 1 {\n        assert x >= y;\n        if x - y == 0 {\n            assert x == y;\n            assert gcd(x, y) == x == y;\n        } else {\n            assert x - y > 0;\n            assert gcd(x, y) == gcd(x - y, y);\n        }\n    } else {\n        assert k >= 2;\n        assert x >= k * y >= 2 * y;\n        assert x - (k - 1) * y >= y > 0;\n        gcdModInvariant(x, y, k - 1);\n        if x - k * y > 0 {\n            assert x - k * y + y == x - (k - 1) * y;\n            assert gcd(x - (k - 1) * y, y) == gcd(x - k * y, y);\n        } else if x - k * y == 0 {\n            if x - (k - 1) * y == y {\n                assert gcd(x, y) == y;\n            }\n        }\n    }\n}\n\nlemma gcdMod(x: int, y: int)\n    requires x > 0 && y > 0\n    ensures x % y > 0 ==> gcd(x, y) == gcd(x % y, y)\n    ensures x % y == 0 ==> gcd(x, y) == y\n{\n    if x < y {\n        assert x % y == x;\n        assert gcd(x, y) == gcd(x % y, y);\n    } else if x == y {\n        assert x % y == 0;\n        assert gcd(x, y) == x == y;\n    } else {\n        var q := x / y;\n        var r := x % y;\n        assert x == q * y + r;\n        assert q > 0;\n        if r == 0 {\n            assert x == q * y;\n            if q == 1 {\n                assert x == y;\n                assert gcd(x, y) == y;\n            } else {\n                gcdModInvariant(x, y, q);\n                assert gcd(x, y) == y;\n            }\n        } else {\n            assert r > 0;\n            assert x - q * y == r > 0;\n            gcdModInvariant(x, y, q);\n            assert gcd(x, y) == gcd(r, y);\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdI(m: int, n: int) returns (d: int)\nrequires  m > 0 && n > 0 \nensures d == gcd(m, n);\n// </vc-spec>\n// <vc-code>\n{\n    var a := m;\n    var b := n;\n    \n    while a != b\n        invariant a > 0 && b > 0\n        invariant gcd(a, b) == gcd(m, n)\n        decreases a + b\n    {\n        if a > b {\n            a := a - b;\n        } else {\n            b := b - a;\n        }\n    }\n    \n    d := a;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_filter_Filter.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_filter_Filter.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Filter(a:seq<char>, b:set<char>) returns(c:set<char>) \nensures forall x :: x in a && x in b <==> x in c\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Filter(a:seq<char>, b:set<char>) returns(c:set<char>) \nensures forall x :: x in a && x in b <==> x in c\n// </vc-spec>\n// <vc-code>\n{\n  c := {};\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant forall x :: x in a[..i] && x in b <==> x in c\n  {\n    if a[i] in b {\n      c := c + {a[i]};\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_576_IsSublist.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_576_IsSublist.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSublist(sub: seq<int>, main: seq<int>) returns (result: bool)\n    ensures true <== (exists i :: 0 <= i <= |main| - |sub| && sub == main[i..i + |sub|])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SublistExists(sub: seq<int>, main: seq<int>, i: int)\n    requires 0 <= i <= |main| - |sub|\n    requires sub == main[i..i + |sub|]\n    ensures exists j {:trigger main[j..j + |sub|]} :: 0 <= j <= |main| - |sub| && sub == main[j..j + |sub|]\n{\n}\n\nlemma SublistMatches(sub: seq<int>, main: seq<int>, i: int)\n    requires 0 <= i <= |main| - |sub|\n    requires forall k :: 0 <= k < |sub| ==> sub[k] == main[i + k]\n    ensures sub == main[i..i + |sub|]\n{\n    if |sub| == 0 {\n        assert sub == main[i..i];\n    } else {\n        assert sub == main[i..i + |sub|];\n    }\n}\n\nlemma LoopInvariantMaintained(sub: seq<int>, main: seq<int>, i: int)\n    requires 0 <= i <= |main| - |sub|\n    requires forall j {:trigger main[j..j + |sub|]} :: 0 <= j < i ==> sub != main[j..j + |sub|]\n    requires sub != main[i..i + |sub|]\n    ensures forall j {:trigger main[j..j + |sub|]} :: 0 <= j < i + 1 ==> sub != main[j..j + |sub|]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSublist(sub: seq<int>, main: seq<int>) returns (result: bool)\n    ensures true <== (exists i :: 0 <= i <= |main| - |sub| && sub == main[i..i + |sub|])\n// </vc-spec>\n// <vc-code>\n{\n    if |sub| > |main| {\n        return false;\n    }\n    \n    var i := 0;\n    while i <= |main| - |sub|\n        invariant 0 <= i <= |main| - |sub| + 1\n        invariant forall j {:trigger main[j..j + |sub|]} :: 0 <= j < i ==> sub != main[j..j + |sub|]\n    {\n        var isMatch := true;\n        var k := 0;\n        while k < |sub| && isMatch\n            invariant 0 <= k <= |sub|\n            invariant isMatch <==> forall m :: 0 <= m < k ==> sub[m] == main[i + m]\n        {\n            if sub[k] != main[i + k] {\n                isMatch := false;\n            }\n            k := k + 1;\n        }\n        \n        if isMatch {\n            SublistMatches(sub, main, i);\n            SublistExists(sub, main, i);\n            return true;\n        }\n        \n        assert sub != main[i..i + |sub|];\n        LoopInvariantMaintained(sub, main, i);\n        i := i + 1;\n    }\n    \n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSortAux.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSortAux.dfy", "// <vc-preamble>\npredicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures lo <= p < hi\n    ensures forall i :: lo <= i < p ==> a[i] < a[p]\n    ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    ensures SwapFrame(a, lo, hi)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod QuickSortAux(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]\n    ensures SwapFrame(a, lo, hi)\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    decreases hi - lo\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Clover_bubble_sort_BubbleSort.dfy", "root", true, "", "", false, "Clover_bubble_sort_BubbleSort.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort(a: array<int>)\n  modifies a\n  ensures forall i,j::0<= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..])==multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nghost predicate IsSorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nghost predicate IsPartiallySort(a: array<int>, pos: int)\n  reads a\n  requires 0 <= pos <= a.Length\n{\n  forall k :: 0 <= k < pos ==> forall l :: k < l < a.Length ==> a[k] <= a[l]\n}\n\nlemma SwapPreservesMultiset(a: array<int>, i: int, j: int, old_seq: seq<int>)\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j\n  requires old_seq == a[..]\n  ensures multiset(a[..]) == multiset(old_seq)\n{\n}\n\nlemma SwapImprovesSorting(a: array<int>, i: int, j: int, old_seq: seq<int>)\n  requires 0 <= i < j < a.Length\n  requires a[i] > a[j]\n  requires old_seq == a[..]\n  ensures multiset(a[..]) == multiset(old_seq)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BubbleSort(a: array<int>)\n  modifies a\n  ensures forall i,j::0<= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..])==multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var n := a.Length;\n  if n <= 1 {\n    return;\n  }\n  \n  var i := 0;\n  \n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant forall k :: 0 <= k < i ==> forall l :: n - 1 - i <= l < n ==> a[k] <= a[l]\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := 0;\n    \n    while j < n - 1 - i\n      invariant 0 <= j <= n - 1 - i\n      invariant forall k :: 0 <= k < i ==> forall l :: n - 1 - i <= l < n ==> a[k] <= a[l]\n      invariant forall k :: 0 <= k <= j ==> forall l :: k < l < n - i ==> a[k] <= a[l]\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      if a[j] > a[j + 1] {\n        a[j], a[j + 1] := a[j + 1], a[j];\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_622_FindMedian.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_622_FindMedian.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMedian(a: array<int>, b: array<int>) returns (median: int)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires a.Length > 0\n    requires forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n    requires forall i :: 0 <= i < b.Length - 1 ==> b[i] <= b[i + 1]\n    ensures median == if (a.Length % 2 == 0) then (a[a.Length / 2 - 1] + b[0]) / 2 else a[a.Length / 2]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nfunction MergedArray(a: array<int>, b: array<int>): seq<int>\n    reads a, b\n{\n    a[..] + b[..]\n}\n\nfunction SortedSeq(s: seq<int>): seq<int>\n{\n    if |s| <= 1 then s\n    else\n        var pivot := s[0];\n        var smaller := seq(x | x in s && x < pivot, x);\n        var equal := seq(x | x in s && x == pivot, x);\n        var larger := seq(x | x in s && x > pivot, x);\n        SortedSeq(smaller) + equal + SortedSeq(larger)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMedian(a: array<int>, b: array<int>) returns (median: int)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires a.Length > 0\n    requires forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n    requires forall i :: 0 <= i < b.Length - 1 ==> b[i] <= b[i + 1]\n    ensures median == if (a.Length % 2 == 0) then (a[a.Length / 2 - 1] + b[0]) / 2 else a[a.Length / 2]\n// </vc-spec>\n// <vc-code>\n{\n    var merged := new int[a.Length + b.Length];\n    var i, j, k := 0, 0, 0;\n    \n    // Merge the two sorted arrays\n    while i < a.Length && j < b.Length\n        invariant 0 <= i <= a.Length\n        invariant 0 <= j <= b.Length\n        invariant k == i + j\n        invariant k <= merged.Length\n    {\n        if a[i] <= b[j] {\n            merged[k] := a[i];\n            i := i + 1;\n        } else {\n            merged[k] := b[j];\n            j := j + 1;\n        }\n        k := k + 1;\n    }\n    \n    // Copy remaining elements from a\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant j == b.Length\n        invariant k == i + j\n        invariant k <= merged.Length\n    {\n        merged[k] := a[i];\n        i := i + 1;\n        k := k + 1;\n    }\n    \n    // Copy remaining elements from b\n    while j < b.Length\n        invariant i == a.Length\n        invariant 0 <= j <= b.Length\n        invariant k == i + j\n        invariant k <= merged.Length\n    {\n        merged[k] := b[j];\n        j := j + 1;\n        k := k + 1;\n    }\n    \n    // Find median\n    var totalLength := a.Length + b.Length;\n    if totalLength % 2 == 0 {\n        median := (merged[totalLength / 2 - 1] + merged[totalLength / 2]) / 2;\n    } else {\n        median := merged[totalLength / 2];\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_230_ReplaceBlanksWithChar.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_230_ReplaceBlanksWithChar.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceBlanksWithChar(s: string, ch: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == ' ' ==> v[i] == ch) && (s[i] != ' ' ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceBlanksWithChar(s: string, ch: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == ' ' ==> v[i] == ch) && (s[i] != ' ' ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n    v := \"\";\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |v| == i\n        invariant forall j :: 0 <= j < i ==> (s[j] == ' ' ==> v[j] == ch) && (s[j] != ' ' ==> v[j] == s[j])\n    {\n        if s[i] == ' ' {\n            v := v + [ch];\n        } else {\n            v := v + [s[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_251_InsertBeforeEach.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_251_InsertBeforeEach.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertBeforeEach(s: seq<string>, x: string) returns (v: seq<string>)\n        ensures |v| == 2 * |s|\n        ensures forall i :: 0 <= i < |s| ==> v[2*i] == x && v[2*i + 1] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertBeforeEach(s: seq<string>, x: string) returns (v: seq<string>)\n        ensures |v| == 2 * |s|\n        ensures forall i :: 0 <= i < |s| ==> v[2*i] == x && v[2*i + 1] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  v := [];\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant |v| == 2 * i\n    invariant forall j :: 0 <= j < i ==> v[2*j] == x && v[2*j + 1] == s[j]\n  {\n    v := v + [x, s[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_476_SumMinMax.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_476_SumMinMax.dfy", "// <vc-preamble>\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumMinMax(a: array<int>) returns (sum: int)\n    requires a.Length > 0\n    ensures sum == Max(a[..]) + Min(a[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}\n\n// <vc-helpers>\nlemma MinCorrectness(a: seq<int>, minSoFar: int, i: int)\n    requires 0 <= i <= |a|\n    requires |a| > 0\n    requires i > 0 ==> minSoFar == Min(a[..i])\n    ensures i == |a| ==> minSoFar == Min(a)\n{\n    if i == |a| {\n        assert a[..i] == a;\n    }\n}\n\nlemma MaxCorrectness(a: seq<int>, maxSoFar: int, i: int)\n    requires 0 <= i <= |a|\n    requires |a| > 0\n    requires i > 0 ==> maxSoFar == Max(a[..i])\n    ensures i == |a| ==> maxSoFar == Max(a)\n{\n    if i == |a| {\n        assert a[..i] == a;\n    }\n}\n\nlemma MinExtension(a: seq<int>, i: int)\n    requires 0 < i < |a|\n    ensures Min(a[..i+1]) == if a[i] <= Min(a[..i]) then a[i] else Min(a[..i])\n{\n    var prefix := a[..i+1];\n    var shorterPrefix := a[..i];\n    assert prefix == shorterPrefix + [a[i]];\n    assert |prefix| == i + 1;\n    assert prefix[|prefix|-1] == a[i];\n    assert prefix[..|prefix|-1] == shorterPrefix;\n}\n\nlemma MaxExtension(a: seq<int>, i: int)\n    requires 0 < i < |a|\n    ensures Max(a[..i+1]) == if a[i] >= Max(a[..i]) then a[i] else Max(a[..i])\n{\n    var prefix := a[..i+1];\n    var shorterPrefix := a[..i];\n    assert prefix == shorterPrefix + [a[i]];\n    assert |prefix| == i + 1;\n    assert prefix[|prefix|-1] == a[i];\n    assert prefix[..|prefix|-1] == shorterPrefix;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumMinMax(a: array<int>) returns (sum: int)\n    requires a.Length > 0\n    ensures sum == Max(a[..]) + Min(a[..])\n// </vc-spec>\n// <vc-code>\n{\n    var minSoFar := a[0];\n    var maxSoFar := a[0];\n    var i := 1;\n    \n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant minSoFar == Min(a[..i])\n        invariant maxSoFar == Max(a[..i])\n    {\n        if a[i] <= minSoFar {\n            minSoFar := a[i];\n        }\n        MinExtension(a[..], i);\n        \n        if a[i] >= maxSoFar {\n            maxSoFar := a[i];\n        }\n        MaxExtension(a[..], i);\n        \n        i := i + 1;\n    }\n    \n    MinCorrectness(a[..], minSoFar, i);\n    MaxCorrectness(a[..], maxSoFar, i);\n    sum := minSoFar + maxSoFar;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower.dfy", "root", true, "", "", false, "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower.dfy", "// <vc-preamble>\nfunction Power(n:nat):nat \n{\n    if n == 0 then 1 else 2 * Power(n-1)\n}\n\nmethod CalcPower(n:nat) returns (p:nat)\n    ensures p == 2*n;\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputePower(n:nat) returns (p:nat)\n    ensures p == Power(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Power(n:nat):nat \n{\n    if n == 0 then 1 else 2 * Power(n-1)\n}\n\nmethod CalcPower(n:nat) returns (p:nat)\n    ensures p == 2*n;\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma PowerUnfold(n: nat)\n    ensures n > 0 ==> Power(n) == 2 * Power(n-1)\n{\n    if n > 0 {\n        assert Power(n) == 2 * Power(n-1);\n    }\n}\n\nlemma PowerIterative(i: nat, acc: nat)\n    requires acc == Power(i)\n    ensures acc * Power(0) == Power(i)\n{\n    assert Power(0) == 1;\n    assert acc * 1 == acc;\n}\n\nlemma PowerCorrectness(n: nat, i: nat, acc: nat)\n    requires i <= n\n    requires acc == Power(i)\n    ensures acc == Power(i)\n    decreases n - i\n{\n    // Base case - this lemma just establishes the loop invariant\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputePower(n:nat) returns (p:nat)\n    ensures p == Power(n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        p := 1;\n    } else {\n        var i := 0;\n        p := 1;\n        \n        while i < n\n            invariant 0 <= i <= n\n            invariant p == Power(i)\n        {\n            PowerUnfold(i + 1);\n            p := 2 * p;\n            i := i + 1;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_574_CylinderSurfaceArea.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_574_CylinderSurfaceArea.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CylinderSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * 3.14159265358979323846 * radius * (radius + height)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CylinderSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * 3.14159265358979323846 * radius * (radius + height)\n// </vc-spec>\n// <vc-code>\n{\n  var pi := 3.14159265358979323846;\n  area := 2.0 * pi * radius * (radius + height);\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI.dfy", "// <vc-preamble>\nfunction fib(n: nat):nat\n{\n    if n < 2 then n else fib(n-2)+fib(n-1)\n}\n\nfunction fact(n:nat):nat\n{if n==0 then 1 else n*fact(n-1)}\n\nfunction gcd(m: nat, n: nat): nat\n    requires m > 0 && n > 0\n{\n    if m == n then m\n    else if m > n then gcd(m - n, n)\n    else gcd(m, n - m)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdI(m: int, n: int) returns (g: int)\n    requires  m > 0 && n > 0 \n    ensures g == gcd(m, n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\nfunction fib(n: nat):nat\n{\n    if n < 2 then n else fib(n-2)+fib(n-1)\n}\n\n//# 2 pts\n\n//Problem02\nfunction fact(n:nat):nat\n{if n==0 then 1 else n*fact(n-1)}\n\n//# 3 pts\n//Problem03\nfunction gcd(m: nat, n: nat): nat\n    requires m > 0 && n > 0\n{\n    if m == n then m\n    else if m > n then gcd(m - n, n)\n    else gcd(m, n - m)\n}\n\n// <vc-helpers>\nlemma gcdPreservation(m: nat, n: nat, m': nat, n': nat)\n    requires m > 0 && n > 0 && m' > 0 && n' > 0\n    requires gcd(m, n) == gcd(m', n')\n    ensures gcd(m, n) == gcd(m', n')\n{\n}\n\nlemma gcdSubtraction(m: nat, n: nat)\n    requires m > 0 && n > 0 && m > n\n    ensures gcd(m, n) == gcd(m - n, n)\n{\n}\n\nlemma gcdSubtractionSymmetric(m: nat, n: nat)\n    requires m > 0 && n > 0 && n > m\n    ensures gcd(m, n) == gcd(m, n - m)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdI(m: int, n: int) returns (g: int)\n    requires  m > 0 && n > 0 \n    ensures g == gcd(m, n);\n// </vc-spec>\n// <vc-code>\n{\n    var a := m;\n    var b := n;\n    \n    while a != b\n        invariant a > 0 && b > 0\n        invariant gcd(a, b) == gcd(m, n)\n        decreases a + b\n    {\n        if a > b {\n            a := a - b;\n        } else {\n            b := b - a;\n        }\n    }\n    \n    g := a;\n}\n// </vc-code>\n\n//# 3 pts\n\n\n// # sum: 9 pts", "", "", ""], ["dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort.dfy", "root", true, "", "", false, "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort.dfy", "// <vc-preamble>\ntwostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionnSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "twostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}\n\n// <vc-helpers>\nlemma PreservedTransitive(a: array<int>, left: nat, right: nat)\n    requires left <= right <= a.Length\n    requires multiset(a[left..right]) == multiset(old(a[left..right]))\n    ensures Preserved(a, left, right)\n{\n}\n\nlemma PreservedSwap(a: array<int>, i: nat, j: nat, left: nat, right: nat, oldA: seq<int>)\n    requires left <= right <= a.Length\n    requires left <= i < right\n    requires left <= j < right\n    requires |oldA| == a.Length\n    requires oldA == old(a[..])\n    requires a[i] == oldA[j] && a[j] == oldA[i]\n    requires forall k :: left <= k < right && k != i && k != j ==> a[k] == oldA[k]\n    ensures multiset(a[left..right]) == multiset(oldA[left..right])\n{\n    assert multiset(a[left..right]) == multiset(oldA[left..right]);\n}\n\nlemma FindMinPreservesOrder(a: array<int>, start: nat, minIndex: nat)\n    requires 0 <= start < a.Length\n    requires start <= minIndex < a.Length\n    requires forall k :: start <= k < a.Length ==> a[minIndex] <= a[k]\n    requires Ordered(a, 0, start)\n    ensures Ordered(a, 0, start)\n{\n}\n\nlemma SwapPreservesPrefix(a: array<int>, i: nat, j: nat, prefix: nat)\n    requires 0 <= prefix <= i\n    requires 0 <= i < a.Length\n    requires 0 <= j < a.Length\n    requires Ordered(a, 0, prefix)\n    ensures Ordered(a, 0, prefix)\n{\n}\n\nlemma SwapMaintainsInvariant(a: array<int>, i: nat, minIndex: nat, oldA: seq<int>)\n    requires 0 <= i < minIndex < a.Length\n    requires |oldA| == a.Length\n    requires Ordered(oldA, 0, i)\n    requires forall x, y :: 0 <= x < i && i <= y < a.Length ==> oldA[x] <= oldA[y]\n    requires forall k :: i <= k < a.Length ==> oldA[minIndex] <= oldA[k]\n    requires a[i] == oldA[minIndex] && a[minIndex] == oldA[i]\n    requires forall k :: 0 <= k < a.Length && k != i && k != minIndex ==> a[k] == oldA[k]\n    ensures Ordered(a, 0, i + 1)\n    ensures forall x, y :: 0 <= x < i + 1 && i + 1 <= y < a.Length ==> a[x] <= a[y]\n{\n}\n\nghost predicate Ordered(s: seq<int>, left: nat, right: nat)\n    requires left <= right <= |s|\n{\n    forall i: nat :: 0 < left <= i < right ==> s[i-1] <= s[i]\n}\n\ntwostate lemma PreservedReflexive(a: array<int>)\n    ensures Preserved(a, 0, a.Length)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionnSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n    var n := a.Length;\n    var i := 0;\n    \n    PreservedReflexive(a);\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant Ordered(a, 0, i)\n        invariant forall x, y :: 0 <= x < i && i <= y < n ==> a[x] <= a[y]\n        invariant Preserved(a, 0, n)\n        modifies a\n    {\n        var minIndex := i;\n        var j := i + 1;\n        \n        while j < n\n            invariant i <= minIndex < n\n            invariant i + 1 <= j <= n\n            invariant forall k :: i <= k < j ==> a[minIndex] <= a[k]\n            invariant Preserved(a, 0, n)\n        {\n            if a[j] < a[minIndex] {\n                minIndex := j;\n            }\n            j := j + 1;\n        }\n        \n        if minIndex != i {\n            var oldA := a[..];\n            var oldI := a[i];\n            var oldMin := a[minIndex];\n            a[i], a[minIndex] := a[minIndex], a[i];\n            \n            SwapMaintainsInvariant(a, i, minIndex, oldA);\n            PreservedSwap(a, i, minIndex, 0, n, oldA);\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstCero(v:array<int>) returns (i:int)\nensures 0 <=i<=v.Length\nensures forall j:: 0<=j<i ==> v[j]!=0 \nensures i!=v.Length ==> v[i]==0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstCero(v:array<int>) returns (i:int)\nensures 0 <=i<=v.Length\nensures forall j:: 0<=j<i ==> v[j]!=0 \nensures i!=v.Length ==> v[i]==0\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant forall j :: 0 <= j < i ==> v[j] != 0\n  {\n    if v[i] == 0 {\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_swap_Swap.dfy", "root", true, "", "", false, "Clover_swap_Swap.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  x := Y;\n  y := X;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero.dfy", "root", true, "", "", false, "Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length == 0 {\n    return -1;\n  }\n  \n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] != 0\n  {\n    if a[i] == 0 {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_804_IsProductEven.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_804_IsProductEven.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsProductEven(a: array<int>) returns (result: bool)\n    ensures result <==> exists i :: 0 <= i < a.Length && IsEven(a[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsProductEven(a: array<int>) returns (result: bool)\n    ensures result <==> exists i :: 0 <= i < a.Length && IsEven(a[i])\n// </vc-spec>\n// <vc-code>\n{\n    result := false;\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant result <==> exists j :: 0 <= j < i && IsEven(a[j])\n    {\n        if IsEven(a[i]) {\n            result := true;\n            return;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring.dfy", "root", true, "", "", false, "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring.dfy", "// <vc-preamble>\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}\n\n// <vc-helpers>\nlemma isPrefixEquivalence(pre: string, str: string)\n  ensures isPrefixPredicate(pre, str) <==> !isNotPrefixPred(pre, str)\n{\n  if isPrefixPredicate(pre, str) {\n    assert |str| >= |pre|;\n    assert pre <= str;\n    assert pre == str[..|pre|];\n    assert !isNotPrefixPred(pre, str);\n  }\n  if !isNotPrefixPred(pre, str) {\n    assert |pre| <= |str|;\n    assert pre == str[..|pre|];\n    assert isPrefixPredicate(pre, str);\n  }\n}\n\nmethod isPrefixImpl(pre: string, str: string) returns (res: bool)\n  ensures res == isPrefixPredicate(pre, str)\n{\n  if |pre| > |str| {\n    res := false;\n  } else {\n    res := (pre == str[..|pre|]);\n  }\n}\n\nmethod isSubstringImpl(sub: string, str: string) returns (res: bool)\n  ensures res == isSubstringPredicate(sub, str)\n{\n  if |sub| > |str| {\n    res := false;\n    return;\n  }\n  \n  var i := 0;\n  while i <= |str| - |sub|\n    invariant 0 <= i <= |str| - |sub| + 1\n    invariant forall j :: 0 <= j < i ==> !isPrefixPredicate(sub, str[j..])\n  {\n    var isPrefix := isPrefixImpl(sub, str[i..]);\n    if isPrefix {\n      res := true;\n      return;\n    }\n    i := i + 1;\n  }\n  res := false;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n// </vc-spec>\n// <vc-code>\n{\n  if |str1| < k || |str2| < k {\n    found := false;\n    return;\n  }\n  \n  var i := 0;\n  while i <= |str1| - k\n    invariant 0 <= i <= |str1| - k + 1\n    invariant forall j :: 0 <= j < i ==> !isSubstringPredicate((str1[j..])[..k], str2)\n  {\n    var substring := (str1[i..])[..k];\n    var isSubstr := isSubstringImpl(substring, str2);\n    if isSubstr {\n      found := true;\n      return;\n    }\n    i := i + 1;\n  }\n  found := false;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_751_IsMinHeap.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_751_IsMinHeap.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsMinHeap(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.Length || a[i] <= a[2*i + 2])\n    ensures !result ==> exists i :: 0 <= i < a.Length / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.Length && a[i] > a[2*i + 2]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsMinHeap(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.Length || a[i] <= a[2*i + 2])\n    ensures !result ==> exists i :: 0 <= i < a.Length / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.Length && a[i] > a[2*i + 2]))\n// </vc-spec>\n// <vc-code>\n{\n    result := true;\n    var i := 0;\n    while i < a.Length / 2\n        invariant 0 <= i <= a.Length / 2\n        invariant result ==> forall j :: 0 <= j < i ==> a[j] <= a[2*j + 1] && (2*j + 2 == a.Length || a[j] <= a[2*j + 2])\n        invariant !result ==> exists j :: 0 <= j < i && (a[j] > a[2*j + 1] || (2*j + 2 != a.Length && a[j] > a[2*j + 2]))\n    {\n        if a[i] > a[2*i + 1] || (2*i + 2 < a.Length && a[i] > a[2*i + 2]) {\n            result := false;\n            return;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_triple2_Triple.dfy", "root", true, "", "", false, "Clover_triple2_Triple.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  r := 3 * x;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop.dfy", "// <vc-preamble>\nfunction sumInts( n: int ): int\n    requires n >= 0;\n{\n    if n == 0 then\n        0\n    else\n        sumInts(n-1)+n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumIntsLoop( n: int ) returns ( s: int )\n    requires n >= 0;\n    ensures s == sumInts(n)\n    ensures s == n*(n+1)/2;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sumInts( n: int ): int\n    requires n >= 0;\n{\n    if n == 0 then\n        0\n    else\n        sumInts(n-1)+n\n}\n\n// <vc-helpers>\nlemma SumIntsFormula(n: int)\n    requires n >= 0\n    ensures sumInts(n) == n * (n + 1) / 2\n{\n    if n == 0 {\n        assert sumInts(0) == 0;\n        assert 0 * (0 + 1) / 2 == 0;\n    } else {\n        SumIntsFormula(n - 1);\n        assert sumInts(n) == sumInts(n - 1) + n;\n        assert sumInts(n - 1) == (n - 1) * n / 2;\n        assert sumInts(n) == (n - 1) * n / 2 + n;\n        assert sumInts(n) == ((n - 1) * n + 2 * n) / 2;\n        assert sumInts(n) == (n * n - n + 2 * n) / 2;\n        assert sumInts(n) == (n * n + n) / 2;\n        assert sumInts(n) == n * (n + 1) / 2;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumIntsLoop( n: int ) returns ( s: int )\n    requires n >= 0;\n    ensures s == sumInts(n)\n    ensures s == n*(n+1)/2;\n// </vc-spec>\n// <vc-code>\n{\n    s := 0;\n    var i := 0;\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant s == sumInts(i)\n    {\n        i := i + 1;\n        s := s + i;\n    }\n    \n    SumIntsFormula(n);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_401_IndexWiseAddition.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_401_IndexWiseAddition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IndexWiseAddition(a: seq<seq<int>>, b: seq<seq<int>>) returns (result: seq<seq<int>>)\n    requires |a| > 0 && |b| > 0\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |a| ==> |a[i]| == |b[i]|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> |result[i]| == |a[i]|\n    ensures forall i :: 0 <= i < |result| ==> forall j :: 0 <= j < |result[i]| ==> result[i][j] == a[i][j] + b[i][j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma AdditionProperties(a: seq<int>, b: seq<int>, i: int)\n    requires |a| == |b|\n    requires 0 <= i < |a|\n    ensures |a| == |b|\n    ensures forall j :: 0 <= j < |a| ==> a[j] + b[j] == a[j] + b[j]\n{\n}\n\nlemma SeqAdditionLength(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] + b[i]\n{\n    result := seq(|a|, i requires 0 <= i < |a| => a[i] + b[i]);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IndexWiseAddition(a: seq<seq<int>>, b: seq<seq<int>>) returns (result: seq<seq<int>>)\n    requires |a| > 0 && |b| > 0\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |a| ==> |a[i]| == |b[i]|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> |result[i]| == |a[i]|\n    ensures forall i :: 0 <= i < |result| ==> forall j :: 0 <= j < |result[i]| ==> result[i][j] == a[i][j] + b[i][j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    while i < |a|\n        invariant 0 <= i <= |a|\n        invariant |result| == i\n        invariant forall k :: 0 <= k < i ==> |result[k]| == |a[k]|\n        invariant forall k :: 0 <= k < i ==> forall j :: 0 <= j < |result[k]| ==> result[k][j] == a[k][j] + b[k][j]\n    {\n        var row := seq(|a[i]|, j requires 0 <= j < |a[i]| => a[i][j] + b[i][j]);\n        result := result + [row];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop.dfy", "// <vc-preamble>\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search2PowLoop( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// <vc-helpers>\nlemma Is2PowPreserved(n: int)\n    requires Is2Pow(n+1)\n    requires n > 0\n    ensures Is2Pow((n-1)/2 + 1)\n{\n    assert n+1 >= 2;\n    assert (n+1) % 2 == 0;\n    assert Is2Pow((n+1)/2);\n    assert (n+1)/2 == (n-1)/2 + 1;\n}\n\nlemma DivisionProperties(n: int)\n    requires Is2Pow(n+1)\n    requires n > 0\n    ensures (n-1)/2 >= 0\n    ensures (n-1)/2 < n\n{\n    assert n+1 >= 2;\n    assert n >= 1;\n}\n\nlemma SizeReduction(size: int)\n    requires Is2Pow(size + 1)\n    requires size > 0\n    ensures Is2Pow((size - 1) / 2 + 1)\n{\n    Is2PowPreserved(size);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search2PowLoop( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n    k := i;\n    var left := i;\n    var right := i + n;\n    var size := n;\n    \n    while size > 0\n        invariant left <= right\n        invariant i <= left <= right <= i + n\n        invariant k == left\n        invariant forall r | i <= r < left :: a[r] < x\n        invariant forall r | right <= r < i + n :: a[r] >= x\n        invariant Is2Pow(size + 1)\n        invariant right - left == size\n        decreases size\n    {\n        var mid := left + (size - 1) / 2;\n        \n        if a[mid] < x {\n            left := mid + 1;\n        } else {\n            right := mid;\n        }\n        \n        if size > 0 {\n            SizeReduction(size);\n        }\n        \n        size := (size - 1) / 2;\n        k := left;\n    }\n}\n// </vc-code>\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs.dfy", "// <vc-preamble>\nfunction Stairs(n: nat): nat {\n  if n <= 1 then 1 else Stairs(n - 2) + Stairs(n - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ClimbStairs(n: nat) returns (r: nat)\n  ensures r == Stairs(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Stairs(n: nat): nat {\n  if n <= 1 then 1 else Stairs(n - 2) + Stairs(n - 1)\n}\n\n// A simple specification\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ClimbStairs(n: nat) returns (r: nat)\n  ensures r == Stairs(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n <= 1 {\n    r := 1;\n  } else {\n    var a := 1;\n    var b := 1;\n    var i := 2;\n    while i <= n\n      invariant 2 <= i <= n + 1\n      invariant a == Stairs(i - 2)\n      invariant b == Stairs(i - 1)\n    {\n      var temp := a + b;\n      a := b;\n      b := temp;\n      i := i + 1;\n    }\n    r := b;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_143_CountArrays.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_143_CountArrays.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountArrays(arrays: seq<array<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |arrays|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountArrays(arrays: seq<array<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |arrays|\n// </vc-spec>\n// <vc-code>\n{\n  count := |arrays|;\n}\n// </vc-code>\n\n", "", "", ""], ["t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete.dfy", "root", true, "", "", false, "t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Delete(line:array<char>, l:nat, at:nat, p:nat)\n  requires l <= line.Length\n  requires at+p <= l\n  modifies line\n  ensures line[..at] == old(line[..at])\n  ensures line[at..l-p] == old(line[at+p..l])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// line cont\u00e9m uma string de tamanho l\n// remover p caracteres a partir da posi\u00e7\u00e3o at\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Delete(line:array<char>, l:nat, at:nat, p:nat)\n  requires l <= line.Length\n  requires at+p <= l\n  modifies line\n  ensures line[..at] == old(line[..at])\n  ensures line[at..l-p] == old(line[at+p..l])\n// </vc-spec>\n// <vc-code>\n{\n  var i := at;\n  while i < l - p\n    invariant at <= i <= l - p\n    invariant line[..at] == old(line[..at])\n    invariant line[at..i] == old(line[at+p..at+p+(i-at)])\n    invariant line[i..] == old(line[i..])\n  {\n    line[i] := line[i + p];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_414_AnyValueExists.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_414_AnyValueExists.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n// </vc-spec>\n// <vc-code>\n{\n  result := false;\n  var i := 0;\n  while i < |seq1|\n    invariant 0 <= i <= |seq1|\n    invariant result <==> (exists j :: 0 <= j < i && seq1[j] in seq2)\n  {\n    if seq1[i] in seq2 {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion.dfy", "root", true, "", "", false, "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion.dfy", "// <vc-preamble>\ndatatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\n\n// <vc-helpers>\nfunction insertFunction(tree: Tree, value: int): Tree\n  requires BinarySearchTree(tree)\n  decreases tree\n{\n  match tree\n  case Empty => Node(Empty, value, Empty)\n  case Node(left, v, right) =>\n    if value < v then\n      Node(insertFunction(left, value), v, right)\n    else if value > v then\n      Node(left, v, insertFunction(right, value))\n    else\n      tree\n}\n\nlemma insertPreservesMinValue(tree: Tree, value: int, x: int)\n  requires BinarySearchTree(tree)\n  requires minValue(tree, x) && x < value\n  decreases tree\n  ensures minValue(insertFunction(tree, value), x)\n{\n  match tree\n  case Empty => {}\n  case Node(left, v, right) =>\n    if value < v {\n      insertPreservesMinValue(left, value, x);\n    } else if value > v {\n      insertPreservesMinValue(right, value, x);\n    }\n}\n\nlemma insertPreservesMaxValue(tree: Tree, value: int, x: int)\n  requires BinarySearchTree(tree)\n  requires maxValue(tree, x) && x > value\n  decreases tree\n  ensures maxValue(insertFunction(tree, value), x)\n{\n  match tree\n  case Empty => {}\n  case Node(left, v, right) =>\n    if value < v {\n      insertPreservesMaxValue(left, value, x);\n    } else if value > v {\n      insertPreservesMaxValue(right, value, x);\n    }\n}\n\nlemma insertPreservesMinValueForRight(tree: Tree, value: int, nodeValue: int)\n  requires BinarySearchTree(tree)\n  requires value < nodeValue\n  decreases tree\n  ensures minValue(insertFunction(tree, value), nodeValue)\n{\n  match tree\n  case Empty => {}\n  case Node(left, v, right) =>\n    if minValue(tree, nodeValue) {\n      insertPreservesMinValue(tree, value, nodeValue);\n    }\n}\n\nlemma insertPreservesMaxValueForLeft(tree: Tree, value: int, nodeValue: int)\n  requires BinarySearchTree(tree)\n  requires value > nodeValue\n  decreases tree\n  ensures maxValue(insertFunction(tree, value), nodeValue)\n{\n  match tree\n  case Empty => {}\n  case Node(left, v, right) =>\n    if maxValue(tree, nodeValue) {\n      insertPreservesMaxValue(tree, value, nodeValue);\n    }\n}\n\nlemma insertPreservesBST(tree: Tree, value: int)\n  requires BinarySearchTree(tree)\n  decreases tree\n  ensures BinarySearchTree(insertFunction(tree, value))\n{\n  match tree\n  case Empty => {}\n  case Node(left, v, right) =>\n    if value < v {\n      insertPreservesBST(left, value);\n      if maxValue(left, v) {\n        insertPreservesMaxValueForLeft(left, value, v);\n      }\n    } else if value > v {\n      insertPreservesBST(right, value);\n      if minValue(right, v) {\n        insertPreservesMinValueForRight(right, value, v);\n      }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n// </vc-spec>\n// <vc-code>\n{\n  res := insertFunction(tree, value);\n  insertPreservesBST(tree, value);\n  \n  forall x | minValue(tree, x) && x < value\n    ensures minValue(res, x)\n  {\n    insertPreservesMinValue(tree, value, x);\n  }\n  \n  forall x | maxValue(tree, x) && x > value\n    ensures maxValue(res, x)\n  {\n    insertPreservesMaxValue(tree, value, x);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge.dfy", "root", true, "", "", false, "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge.dfy", "// <vc-preamble>\npredicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod merge(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires end - start == |a1| + |a2|\n  requires 0 <= start < end < |a1| && end <= |a2| < b.Length\n  requires end < |a1| && end < |a2|\n  ensures sorted_slice(b, start, end)\n  requires b.Length == |a2| + |a1|\n  ensures merged(a1, a2, b, start, end)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n// <vc-helpers>\nlemma multiset_slice_update_helper(old_slice: seq<int>, new_slice: seq<int>, i: int, old_val: int, new_val: int)\n  requires 0 <= i < |old_slice| == |new_slice|\n  requires forall j :: 0 <= j < |old_slice| && j != i ==> old_slice[j] == new_slice[j]\n  requires old_slice[i] == old_val\n  requires new_slice[i] == new_val\n  ensures multiset(new_slice) == multiset(old_slice) - multiset{old_val} + multiset{new_val}\n{\n}\n\nlemma sorted_seq_prefix(s: seq<int>, i: int)\n  requires sorted_seq(s)\n  requires 0 <= i <= |s|\n  ensures sorted_seq(s[..i])\n{\n}\n\nlemma sorted_seq_suffix(s: seq<int>, i: int)\n  requires sorted_seq(s)\n  requires 0 <= i <= |s|\n  ensures sorted_seq(s[i..])\n{\n}\n\nlemma merge_preserves_multiset(a1: seq<int>, a2: seq<int>, i1: int, i2: int, k: int, b: array<int>, start: int)\n  requires 0 <= i1 <= |a1|\n  requires 0 <= i2 <= |a2|\n  requires 0 <= start <= start + i1 + i2 <= b.Length\n  requires k == start + i1 + i2\n  requires multiset(a1[..i1]) + multiset(a2[..i2]) == multiset(b[start..start+i1+i2])\n  ensures multiset(a1[..i1]) + multiset(a2[..i2]) == multiset(b[start..k])\n{\n  assert start + i1 + i2 == k;\n}\n\nlemma final_multiset_preservation(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  requires end - start == |a1| + |a2|\n  requires multiset(a1) + multiset(a2) == multiset(b[start..end])\n  ensures multiset(a1) + multiset(a2) == multiset(b[start..end])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod merge(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires end - start == |a1| + |a2|\n  requires 0 <= start < end < |a1| && end <= |a2| < b.Length\n  requires end < |a1| && end < |a2|\n  ensures sorted_slice(b, start, end)\n  requires b.Length == |a2| + |a1|\n  ensures merged(a1, a2, b, start, end)\n// </vc-spec>\n// <vc-code>\n{\n  var i1 := 0;\n  var i2 := 0;\n  var k := start;\n  \n  while i1 < |a1| || i2 < |a2|\n    invariant 0 <= i1 <= |a1|\n    invariant 0 <= i2 <= |a2|\n    invariant k == start + i1 + i2\n    invariant k <= end\n    invariant sorted_slice(b, start, k)\n    invariant multiset(a1[..i1]) + multiset(a2[..i2]) == multiset(b[start..k])\n    invariant i1 < |a1| ==> (k == start || b[k-1] <= a1[i1])\n    invariant i2 < |a2| ==> (k == start || b[k-1] <= a2[i2])\n    decreases |a1| - i1 + |a2| - i2\n  {\n    var old_k := k;\n    if i2 >= |a2| || (i1 < |a1| && a1[i1] <= a2[i2]) {\n      b[k] := a1[i1];\n      i1 := i1 + 1;\n    } else {\n      b[k] := a2[i2];\n      i2 := i2 + 1;\n    }\n    k := k + 1;\n    assert k == start + i1 + i2;\n  }\n  \n  assert i1 == |a1| && i2 == |a2|;\n  assert k == start + |a1| + |a2| == end;\n  assert a1[..|a1|] == a1;\n  assert a2[..|a2|] == a2;\n  assert multiset(a1) + multiset(a2) == multiset(b[start..end]);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_807_FindFirstOdd.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_807_FindFirstOdd.dfy", "// <vc-preamble>\npredicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n// </vc-spec>\n// <vc-code>\n{\n    found := false;\n    index := 0;\n    \n    while index < a.Length\n        invariant 0 <= index <= a.Length\n        invariant forall i :: 0 <= i < index ==> !IsOdd(a[i])\n        invariant !found\n    {\n        if IsOdd(a[index]) {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IntDiv (m : int, n : int) returns (d : int, r : int)\n    requires n > 0\n    ensures m == n * d + r && 0 <= r < n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IntDiv (m : int, n : int) returns (d : int, r : int)\n    requires n > 0\n    ensures m == n * d + r && 0 <= r < n // TODO\n// </vc-spec>\n// <vc-code>\n{\n  if m >= 0 {\n    d := 0;\n    r := m;\n    while r >= n\n      invariant m == n * d + r\n      invariant r >= 0\n      decreases r\n    {\n      d := d + 1;\n      r := r - n;\n    }\n  } else {\n    d := 0;\n    r := m;\n    while r < 0\n      invariant m == n * d + r\n      invariant r < n\n      decreases -r\n    {\n      d := d - 1;\n      r := r + n;\n    }\n  }\n}\n// </vc-code>\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "", "", ""], ["Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring.dfy", "root", true, "", "", false, "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring.dfy", "// <vc-preamble>\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\nlemma isPrefixCorrectness(pre: string, str: string)\n    ensures isPrefixPred(pre, str) <==> ((|pre| <= |str|) && pre == str[..|pre|])\n    ensures isNotPrefixPred(pre, str) <==> ((|pre| > |str|) || pre != str[..|pre|])\n{\n}\n\nlemma substringEquivalence(sub: string, str: string)\n    ensures isSubstringPred(sub, str) <==> (exists i :: 0 <= i <= |str| && isPrefixPred(sub, str[i..]))\n    ensures isNotSubstringPred(sub, str) <==> (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub, str[i..]))\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n// </vc-spec>\n// <vc-code>\n{\n    if |sub| > |str| {\n        return false;\n    }\n    \n    var i := 0;\n    while i <= |str| - |sub|\n        invariant 0 <= i <= |str| - |sub| + 1\n        invariant forall j :: 0 <= j < i ==> isNotPrefixPred(sub, str[j..])\n    {\n        var prefixRes := isPrefix(sub, str[i..]);\n        if prefixRes {\n            return true;\n        }\n        i := i + 1;\n    }\n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2.dfy", "root", true, "", "", false, "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2.dfy", "// <vc-preamble>\nghost function f2(n: nat): nat {\n    if n == 0 then 0\n    else 5*f2(n/3) + n%4\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mod2(n:nat) returns (a:nat) \nensures a == f2(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function f2(n: nat): nat {\n    if n == 0 then 0\n    else 5*f2(n/3) + n%4\n}\n\n// <vc-helpers>\nlemma f2_recursion_helper(n: nat)\n    requires n > 0\n    ensures f2(n) == 5*f2(n/3) + n%4\n{\n    // This follows directly from the definition of f2\n}\n\nlemma f2_base_case()\n    ensures f2(0) == 0\n{\n    // This follows directly from the definition of f2\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mod2(n:nat) returns (a:nat) \nensures a == f2(n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        a := 0;\n    } else {\n        var sub_result := mod2(n/3);\n        a := 5 * sub_result + n % 4;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition.dfy", "root", true, "", "", false, "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n  requires X.Length>=1 && n == X.Length;\n  ensures b>=n;\n  ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n  ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n  ensures multiset(X[..])==multiset(old(X[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\n\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */\n\n// <vc-helpers>\nlemma MultisetPreservation(X: array<int>, i: int, j: int)\n  requires 0 <= i < X.Length && 0 <= j < X.Length\n  ensures multiset(X[..]) == multiset(old(X[..]))\n{\n}\n\nlemma PartitionInvariant(X: array<int>, n: int, p: int, a: int, k: int)\n  requires 0 <= a <= k <= n <= X.Length\n  requires forall x :: 0 <= x < a ==> X[x] <= p\n  requires forall x :: a <= x < k ==> X[x] > p\n  ensures forall x :: 0 <= x < a ==> X[x] <= p\n  ensures forall x :: a <= x < k ==> X[x] > p\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n// </vc-spec>\n// <vc-code>\n{\n  a := 0;\n  var k := 0;\n  \n  while k < n\n    invariant 0 <= a <= k <= n\n    invariant forall x :: 0 <= x < a ==> X[x] <= p\n    invariant forall x :: a <= x < k ==> X[x] > p\n    invariant multiset(X[..]) == multiset(old(X[..]))\n  {\n    if X[k] <= p {\n      X[a], X[k] := X[k], X[a];\n      a := a + 1;\n    }\n    k := k + 1;\n  }\n  \n  b := n;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_cal_sum_Sum.dfy", "root", true, "", "", false, "Clover_cal_sum_Sum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sum(N:int) returns (s:int)\n  requires N >= 0\n  ensures s == N * (N + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sum(N:int) returns (s:int)\n  requires N >= 0\n  ensures s == N * (N + 1) / 2\n// </vc-spec>\n// <vc-code>\n{\n  s := 0;\n  var i := 0;\n  while i <= N\n    invariant 0 <= i <= N + 1\n    invariant s == i * (i - 1) / 2\n  {\n    s := s + i;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength.dfy", "root", true, "", "", false, "formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength.dfy", "// <vc-preamble>\npredicate isSubstring(sub: string, str: string)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isSubstring(sub: string, str: string)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma NoCommonImpliesNoLonger(k: nat, str1: string, str2: string)\n    requires !haveCommonKSubstringPred(k, str1, str2)\n    ensures forall k' :: k' > k ==> !haveCommonKSubstringPred(k' , str1, str2)\n{\n    forall k' | k' > k \n        ensures !haveCommonKSubstringPred(k', str1, str2)\n    {\n        if haveCommonKSubstringPred(k', str1, str2) {\n            var i1, j1 :| 0 <= i1 <= |str1| - k' && j1 == i1 + k' && isSubstringPred(str1[i1..j1], str2);\n            assert k' > k;\n            assert j1 - i1 == k';\n            var sub_k := str1[i1..i1+k];\n            assert sub_k == str1[i1..j1][..k];\n            assert isPrefixPred(sub_k, str1[i1..j1]);\n            \n            var i2 :| 0 <= i2 <= |str2| && isPrefixPred(str1[i1..j1], str2[i2..]);\n            assert isPrefixPred(sub_k, str2[i2..]);\n            assert isSubstringPred(sub_k, str2);\n            assert 0 <= i1 <= |str1| - k;\n            assert haveCommonKSubstringPred(k, str1, str2);\n            assert false;\n        }\n    }\n}\n\nlemma EmptyStringIsCommonSubstring(str1: string, str2: string)\n    ensures haveCommonKSubstringPred(0, str1, str2)\n{\n    assert 0 <= 0 <= |str1| - 0;\n    assert str1[0..0] == \"\";\n    assert isPrefixPred(\"\", str2[0..]);\n    assert isSubstringPred(\"\", str2);\n    assert haveCommonKSubstringPred(0, str1, str2);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n    if |str1| == 0 {\n        len := 0;\n        EmptyStringIsCommonSubstring(str1, str2);\n        return;\n    }\n    \n    var k := |str1|;\n    while k > 0\n        invariant 0 <= k <= |str1|\n        invariant forall k' :: k < k' <= |str1| ==> !haveCommonKSubstringPred(k', str1, str2)\n    {\n        var found := haveCommonKSubstring(k, str1, str2);\n        if found {\n            len := k;\n            return;\n        } else {\n            NoCommonImpliesNoLonger(k, str1, str2);\n        }\n        k := k - 1;\n    }\n    \n    len := 0;\n    EmptyStringIsCommonSubstring(str1, str2);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_avg_ComputeAvg.dfy", "root", true, "", "", false, "Clover_avg_ComputeAvg.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n// </vc-spec>\n// <vc-code>\n{\n  avg := (a + b) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical_objects_verification_examples_fast_exp_FastExp.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical_objects_verification_examples_fast_exp_FastExp.dfy", "// <vc-preamble>\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nfunction exp(b: nat, n: nat): nat {\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nfunction bits(n: nat): seq<bool>\n  decreases n\n{\n  if n == 0 then []\n  else [if (n % 2 == 0) then false else true] + bits(n/2)\n}\n\nfunction from_bits(s: seq<bool>): nat {\n  if s == [] then 0\n  else (if s[0] then 1 else 0) + 2 * from_bits(s[1..])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FastExp(b: nat, n: nat) returns (r: nat)\n  ensures r == exp(b, n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta.dfy", "// <vc-preamble>\npredicate sorted_seg(a:array<int>, i:int, j:int)\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSorta(a:array<int>, c:int, f:int)\nmodifies a \nrequires 0 <= c <= f <= a.Length\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted_seg(a:array<int>, i:int, j:int) //j excluded\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n\n// <vc-helpers>\nmethod swap_preserves_multiset(a: array<int>, i: int, j: int)\n    requires 0 <= i < a.Length && 0 <= j < a.Length\n    modifies a\n    ensures multiset(a[..]) == old(multiset(a[..])) \n{\n    var old_a := a[..];\n    a[i], a[j] := a[j], a[i];\n    assert a[..] == old_a[i := old_a[j]][j := old_a[i]];\n}\n\nmethod bubble_pass_maintains_multiset(a: array<int>, start: int, end: int)\n    requires 0 <= start < end <= a.Length\n    modifies a\n    ensures multiset(a[start..end]) == old(multiset(a[start..end]))\n    ensures a[..start] == old(a[..start])\n    ensures a[end..] == old(a[end..])\n{\n    var i := start;\n    while i < end - 1\n        invariant start <= i <= end - 1\n        invariant multiset(a[start..end]) == old(multiset(a[start..end]))\n        invariant a[..start] == old(a[..start])\n        invariant a[end..] == old(a[end..])\n        modifies a\n    {\n        if a[i] > a[i + 1] {\n            a[i], a[i + 1] := a[i + 1], a[i];\n        }\n        i := i + 1;\n    }\n}\n\nlemma swap_preserves_sorted_suffix(a: array<int>, j: int, f: int, i: int)\n    requires 0 <= j < a.Length - 1\n    requires f - i <= j + 1 < f <= a.Length\n    requires forall k, l :: f - i <= k < l < f ==> a[k] <= a[l]\n    requires forall k :: f - i <= k < f ==> forall l :: 0 <= l < f - i ==> a[l] <= a[k]\n    requires a[j] > a[j + 1]\n    modifies a\n    ensures forall k, l :: f - i <= k < l < f ==> a[k] <= a[l]\n    ensures forall k :: f - i <= k < f ==> forall l :: 0 <= l < f - i ==> a[l] <= a[k]\n{\n    a[j], a[j + 1] := a[j + 1], a[j];\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSorta(a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n    var n := f - c;\n    var i := 0;\n    var original_multiset := multiset(a[c..f]);\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant multiset(a[c..f]) == original_multiset\n        invariant a[..c] == old(a[..c])\n        invariant a[f..] == old(a[f..])\n        invariant forall k, l :: f - i <= k < l < f ==> a[k] <= a[l]\n        invariant forall k :: f - i <= k < f ==> \n            forall l :: c <= l < f - i ==> a[l] <= a[k]\n        modifies a\n    {\n        var j := c;\n        while j < f - 1 - i\n            invariant c <= j <= f - 1 - i\n            invariant multiset(a[c..f]) == original_multiset\n            invariant a[..c] == old(a[..c])\n            invariant a[f..] == old(a[f..])\n            invariant forall k, l :: f - i <= k < l < f ==> a[k] <= a[l]\n            invariant forall k :: f - i <= k < f ==> \n                forall l :: c <= l < f - i ==> a[l] <= a[k]\n            invariant forall k :: c <= k < j ==> a[k] <= a[j]\n            modifies a\n        {\n            if a[j] > a[j + 1] {\n                a[j], a[j + 1] := a[j + 1], a[j];\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_623_PowerOfListElements.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_623_PowerOfListElements.dfy", "// <vc-preamble>\nfunction Power(base: int, exponent: int): int\n    requires exponent >= 0\n{\n    if exponent == 0 then 1\n    else base * Power(base, exponent-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PowerOfListElements(l: seq<int>, n: int) returns (result: seq<int>)\n    requires n >= 0\n    ensures |result| == |l|\n    ensures forall i :: 0 <= i < |l| ==> result[i] == Power(l[i], n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Power(base: int, exponent: int): int\n    requires exponent >= 0\n{\n    if exponent == 0 then 1\n    else base * Power(base, exponent-1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod PowerOfListElements(l: seq<int>, n: int) returns (result: seq<int>)\n    requires n >= 0\n    ensures |result| == |l|\n    ensures forall i :: 0 <= i < |l| ==> result[i] == Power(l[i], n)\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    while i < |l|\n        invariant 0 <= i <= |l|\n        invariant |result| == i\n        invariant forall j :: 0 <= j < i ==> result[j] == Power(l[j], n)\n    {\n        var power_val := Power(l[i], n);\n        result := result + [power_val];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_573_UniqueProduct.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_573_UniqueProduct.dfy", "// <vc-preamble>\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n\n// <vc-helpers>\nlemma SetProductInsert(s: set<int>, x: int)\n    requires x !in s\n    ensures SetProduct(s + {x}) == x * SetProduct(s)\n{\n    var s' := s + {x};\n    if s' == {} {\n        assert false;\n    } else {\n        forall y | y in s' \n        {\n            if y == x {\n                assert s' - {y} == s;\n            } else {\n                assert y in s;\n                assert s' - {y} == (s - {y}) + {x};\n                SetProductInsert(s - {y}, x);\n                SetProductDistributive(s, y);\n            }\n        }\n    }\n}\n\nlemma SetProductDistributive(s: set<int>, y: int)\n    requires y in s\n    ensures SetProduct(s) == y * SetProduct(s - {y})\n{\n    if s == {} {\n        assert false;\n    } else {\n        forall x | x in s \n        {\n            if x == y {\n                // Direct from definition\n            } else {\n                assert x != y;\n                assert x in s - {y};\n                var s1 := s - {x};\n                assert y in s1;\n                SetProductDistributive(s1, y);\n                assert s1 - {y} == s - {x} - {y};\n                assert s - {x} - {y} == s - {y} - {x};\n                SetProductDistributive(s - {y}, x);\n            }\n        }\n    }\n}\n\nlemma SetProductIdempotent(s: set<int>, x: int)\n    requires x in s\n    ensures SetProduct(s + {x}) == SetProduct(s)\n{\n    assert s + {x} == s;\n}\n\nlemma SetProductEmpty()\n    ensures SetProduct({}) == 1\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n// </vc-spec>\n// <vc-code>\n{\n    product := 1;\n    var processed := {};\n    \n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant processed == set j | 0 <= j < i :: arr[j]\n        invariant product == SetProduct(processed)\n    {\n        var elem := arr[i];\n        if elem !in processed {\n            SetProductInsert(processed, elem);\n            product := product * elem;\n            processed := processed + {elem};\n        } else {\n            SetProductIdempotent(processed, elem);\n            processed := processed + {elem};\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends.dfy", "root", true, "", "", false, "assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\npredicate HasAddends(q: seq<int>, x: int)\n{\n    exists i,j :: 0 <= i < j < |q| && q[i] + q[j] == x\n}\n\npredicate IsValidIndex<T>(q: seq<T>, i: nat)\n{\n    0 <= i < |q|\n}\n\npredicate AreOreredIndices<T>(q: seq<T>, i: nat, j: nat)\n{\n    0 <= i < j < |q|\n}\n\npredicate AreAddendsIndices(q: seq<int>, x: int, i: nat, j: nat)\n    requires IsValidIndex(q, i) && IsValidIndex(q, j)\n{\n    q[i] + q[j] == x\n}\n\npredicate HasAddendsInIndicesRange(q: seq<int>, x: int, i: nat, j: nat)\n    requires AreOreredIndices(q, i, j)\n{\n    HasAddends(q[i..(j + 1)], x)\n}\n\npredicate LoopInv(q: seq<int>, x: int, i: nat, j: nat, sum: int)\n{\n    AreOreredIndices(q, i, j) &&\n    HasAddendsInIndicesRange(q, x, i, j) &&\n    AreAddendsIndices(q, sum, i, j)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindAddends(q: seq<int>, x: int) returns (i: nat, j: nat)\n    requires Sorted(q) && HasAddends(q, x)\n    ensures i < j < |q| && q[i]+q[j] == x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\npredicate HasAddends(q: seq<int>, x: int)\n{\n    exists i,j :: 0 <= i < j < |q| && q[i] + q[j] == x\n}\n\npredicate IsValidIndex<T>(q: seq<T>, i: nat)\n{\n    0 <= i < |q|\n}\n\npredicate AreOreredIndices<T>(q: seq<T>, i: nat, j: nat)\n{\n    0 <= i < j < |q|\n}\n\npredicate AreAddendsIndices(q: seq<int>, x: int, i: nat, j: nat)\n    requires IsValidIndex(q, i) && IsValidIndex(q, j)\n{\n    q[i] + q[j] == x\n}\n\npredicate HasAddendsInIndicesRange(q: seq<int>, x: int, i: nat, j: nat)\n    requires AreOreredIndices(q, i, j)\n{\n    HasAddends(q[i..(j + 1)], x)\n}\n\npredicate LoopInv(q: seq<int>, x: int, i: nat, j: nat, sum: int)\n{\n    AreOreredIndices(q, i, j) &&\n    HasAddendsInIndicesRange(q, x, i, j) &&\n    AreAddendsIndices(q, sum, i, j)\n}\n\n// <vc-helpers>\nlemma SortedSliceProperty(q: seq<int>, i: nat, j: nat, k: nat, l: nat)\n    requires Sorted(q)\n    requires 0 <= i <= k <= l <= j < |q|\n    ensures q[i] <= q[k] <= q[l] <= q[j]\n{\n}\n\nlemma HasAddendsPreservation(q: seq<int>, x: int, left: nat, right: nat)\n    requires Sorted(q)\n    requires 0 <= left < right < |q|\n    requires HasAddends(q[left..(right + 1)], x)\n    requires left + 1 < right\n    requires q[left] + q[right] < x\n    ensures HasAddends(q[(left + 1)..(right + 1)], x)\n{\n    assert exists i, j {:trigger q[left..(right + 1)][i], q[left..(right + 1)][j]} :: 0 <= i < j < |q[left..(right + 1)]| && q[left..(right + 1)][i] + q[left..(right + 1)][j] == x;\n    var i, j :| 0 <= i < j < |q[left..(right + 1)]| && q[left..(right + 1)][i] + q[left..(right + 1)][j] == x;\n    \n    if i == 0 {\n        assert q[left..(right + 1)][i] == q[left];\n        assert q[left..(right + 1)][j] == q[left + j];\n        assert q[left] + q[left + j] == x;\n        assert q[left] + q[right] < x;\n        assert j < right - left;\n        assert left + j < right;\n        SortedSliceProperty(q, left, right, left + j, right);\n        assert q[left + j] <= q[right];\n        assert q[left] + q[left + j] <= q[left] + q[right] < x;\n        assert false;\n    }\n    \n    assert i > 0;\n    assert q[(left + 1)..(right + 1)][i - 1] + q[(left + 1)..(right + 1)][j - 1] == x;\n    assert 0 <= i - 1 < j - 1 < |q[(left + 1)..(right + 1)]|;\n}\n\nlemma HasAddendsPreservationRight(q: seq<int>, x: int, left: nat, right: nat)\n    requires Sorted(q)\n    requires 0 <= left < right < |q|\n    requires HasAddends(q[left..(right + 1)], x)\n    requires left < right - 1\n    requires q[left] + q[right] > x\n    ensures HasAddends(q[left..right], x)\n{\n    assert exists i, j {:trigger q[left..(right + 1)][i], q[left..(right + 1)][j]} :: 0 <= i < j < |q[left..(right + 1)]| && q[left..(right + 1)][i] + q[left..(right + 1)][j] == x;\n    var i, j :| 0 <= i < j < |q[left..(right + 1)]| && q[left..(right + 1)][i] + q[left..(right + 1)][j] == x;\n    \n    if j == right - left {\n        assert q[left..(right + 1)][j] == q[right];\n        assert q[left..(right + 1)][i] == q[left + i];\n        assert q[left + i] + q[right] == x;\n        assert q[left] + q[right] > x;\n        assert i > 0;\n        assert left + i > left;\n        SortedSliceProperty(q, left, right, left, left + i);\n        assert q[left] <= q[left + i];\n        assert q[left] + q[right] <= q[left + i] + q[right] == x;\n        assert false;\n    }\n    \n    assert j < right - left;\n    assert q[left..right][i] + q[left..right][j] == x;\n    assert 0 <= i < j < |q[left..right]|;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindAddends(q: seq<int>, x: int) returns (i: nat, j: nat)\n    requires Sorted(q) && HasAddends(q, x)\n    ensures i < j < |q| && q[i]+q[j] == x\n// </vc-spec>\n// <vc-code>\n{\n    var left: nat := 0;\n    var right: nat := |q| - 1;\n    \n    while left < right\n        invariant 0 <= left < right < |q|\n        invariant HasAddends(q[left..(right + 1)], x)\n    {\n        var sum := q[left] + q[right];\n        if sum == x {\n            return left, right;\n        } else if sum < x {\n            HasAddendsPreservation(q, x, left, right);\n            left := left + 1;\n        } else {\n            HasAddendsPreservationRight(q, x, left, right);\n            right := right - 1;\n        }\n    }\n    \n    assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query.dfy", "root", true, "", "", false, "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query.dfy", "// <vc-preamble>\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod query (a:array<int>, i:int, j:int) returns (s:int)\nrequires 0 <= i <= j <= a.Length\nensures s == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Exercicio 1.a)\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\n//Exercicio 1.b)\n\n//Exercicio 1.c)\n\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\n///Exercicio 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod query (a:array<int>, i:int, j:int) returns (s:int)\nrequires 0 <= i <= j <= a.Length\nensures s == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  s := 0;\n  var k := i;\n  while k < j\n    invariant i <= k <= j\n    invariant s == sum(a, i, k)\n    decreases j - k\n  {\n    s := s + a[k];\n    k := k + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_double_quadruple_DoubleQuadruple.dfy", "root", true, "", "", false, "Clover_double_quadruple_DoubleQuadruple.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n// </vc-spec>\n// <vc-code>\n{\n  a := 2 * x;\n  b := 4 * x;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mid( p: int, q: int) returns ( m: int )\n\n    requires p <= q;\n    ensures p<= m <= q;\n    ensures m-p <= q-m;\n    ensures 0 <= (q-m)-(m-p) <= 1;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mid( p: int, q: int) returns ( m: int )\n    // | ... | ??? | ... |\n    //        p m   q\n    requires p <= q;\n    ensures p<= m <= q;\n    ensures m-p <= q-m;\n    ensures 0 <= (q-m)-(m-p) <= 1;\n// </vc-spec>\n// <vc-code>\n{\n  m := p + (q - p) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1.dfy", "// <vc-preamble>\npredicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mallEqual1(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\n\n//All equal to first\n\n// <vc-helpers>\nlemma allEqualImpliesEqualToFirst(s: seq<int>, i: int)\n  requires allEqual(s)\n  requires 0 <= i < |s|\n  requires |s| > 0\n  ensures s[i] == s[0]\n{\n}\n\nlemma equalToFirstImpliesAllEqual(s: seq<int>)\n  requires |s| > 0\n  requires forall k :: 0 <= k < |s| ==> s[k] == s[0]\n  ensures allEqual(s)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mallEqual1(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])\n// </vc-spec>\n// <vc-code>\n{\n  if v.Length == 0 {\n    return true;\n  }\n  \n  var i := 1;\n  while i < v.Length\n    invariant 1 <= i <= v.Length\n    invariant forall k :: 0 <= k < i ==> v[k] == v[0]\n  {\n    if v[i] != v[0] {\n      return false;\n    }\n    i := i + 1;\n  }\n  \n  equalToFirstImpliesAllEqual(v[0..v.Length]);\n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_591_SwapFirstAndLast.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_591_SwapFirstAndLast.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a != null && a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1]) && a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a != null && a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1]) && a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 1 {\n        return;\n    }\n    \n    var temp := a[0];\n    a[0] := a[a.Length - 1];\n    a[a.Length - 1] := temp;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_MatrixMultiplication_multiply.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_MatrixMultiplication_multiply.dfy", "// <vc-preamble>\nfunction RowColumnProduct(m1: array2<int>, m2: array2<int>, row: nat, column: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n{\n    RowColumnProductFrom(m1, m2, row, column, 0)\n}\n\nfunction RowColumnProductFrom(m1: array2<int>, m2: array2<int>, row: nat, column: nat, k: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && k <= m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n    decreases m1.Length1 - k\n{\n    if k == m1.Length1 then\n        0\n    else\n        m1[row,k]*m2[k,column] + RowColumnProductFrom(m1, m2, row, column, k+1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod multiply(m1: array2<int>, m2: array2<int>) returns (m3: array2<int>)\n    requires m1 != null && m2 != null\n    requires m1.Length1 == m2.Length0\n    ensures m3 != null && m3.Length0 == m1.Length0 && m3.Length1 == m2.Length1\n    ensures forall i, j | 0 <= i < m3.Length0 && 0 <= j < m3.Length1 ::\n        m3[i, j] == RowColumnProduct(m1, m2, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Sort.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Sort.dfy", "// <vc-preamble>\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_460_GetFirstElements.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_460_GetFirstElements.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetFirstElements(lst: seq<seq<int>>) returns (result: seq<int>)\n    requires forall i :: 0 <= i < |lst| ==> |lst[i]| > 0\n    ensures |result| == |lst|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == lst[i][0]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetFirstElements(lst: seq<seq<int>>) returns (result: seq<int>)\n    requires forall i :: 0 <= i < |lst| ==> |lst[i]| > 0\n    ensures |result| == |lst|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == lst[i][0]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    while i < |lst|\n        invariant 0 <= i <= |lst|\n        invariant |result| == i\n        invariant forall j :: 0 <= j < i ==> result[j] == lst[j][0]\n    {\n        result := result + [lst[i][0]];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1.dfy", "root", true, "", "", false, "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1.dfy", "// <vc-preamble>\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SqrSum1(n: int) returns (s: int)\n    requires n >= 0\n    ensures s == SqrSumRec(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat p\u00e2n\u0103 acum)\n        adnot\u0103ri care s\u0103 ajute \u00een procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SqrSum1(n: int) returns (s: int)\n    requires n >= 0\n    ensures s == SqrSumRec(n)  // s = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\n// </vc-spec>\n// <vc-code>\n{\n    s := 0;\n    var i := 0;\n    while i <= n\n        invariant 0 <= i <= n + 1\n        invariant if i > 0 then s == SqrSumRec(i - 1) else s == 0\n    {\n        s := s + i * i;\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSorted(Array: array<int>) \n  modifies Array\n  ensures multiset(old(Array[..])) == multiset(Array[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma MultisetPreservation(a: array<int>, i: int, j: int, old_seq: seq<int>, new_seq: seq<int>)\n  requires 0 <= i < |old_seq|\n  requires 0 <= j < |old_seq|\n  requires |old_seq| == |new_seq|\n  requires forall k :: 0 <= k < |old_seq| && k != i && k != j ==> old_seq[k] == new_seq[k]\n  requires old_seq[i] == new_seq[j]\n  requires old_seq[j] == new_seq[i]\n  ensures multiset(old_seq) == multiset(new_seq)\n{\n  if i == j {\n    assert old_seq == new_seq;\n  } else {\n    assert multiset(old_seq) == multiset(new_seq);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSorted(Array: array<int>) \n  modifies Array\n  ensures multiset(old(Array[..])) == multiset(Array[..])\n// </vc-spec>\n// <vc-code>\n{\n  if Array.Length <= 1 {\n    return;\n  }\n  \n  ghost var original := Array[..];\n  \n  var i := 0;\n  while i < Array.Length - 1\n    invariant 0 <= i <= Array.Length - 1\n    invariant multiset(original) == multiset(Array[..])\n  {\n    var minIndex := i;\n    var j := i + 1;\n    \n    while j < Array.Length\n      invariant i <= minIndex < Array.Length\n      invariant i + 1 <= j <= Array.Length\n      invariant forall k :: i <= k < j ==> Array[minIndex] <= Array[k]\n      invariant multiset(original) == multiset(Array[..])\n    {\n      if Array[j] < Array[minIndex] {\n        minIndex := j;\n      }\n      j := j + 1;\n    }\n    \n    if minIndex != i {\n      ghost var pre_swap := Array[..];\n      Array[i], Array[minIndex] := Array[minIndex], Array[i];\n      ghost var post_swap := Array[..];\n      \n      MultisetPreservation(Array, i, minIndex, pre_swap, post_swap);\n      assert multiset(pre_swap) == multiset(post_swap);\n      assert multiset(original) == multiset(Array[..]);\n    }\n    \n    i := i + 1;\n  }\n  \n  assert multiset(original) == multiset(Array[..]);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum.dfy", "// <vc-preamble>\nfunction Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxSegSum(a: seq<int>) returns (k: int, m: int)\n  ensures 0 <= k <= m <= |a|\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) <= Sum(a, k, m)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}\n\n// <vc-helpers>\nlemma SumAdditive(a: seq<int>, s: int, t: int, u: int)\n  requires 0 <= s <= t <= u <= |a|\n  ensures Sum(a, s, u) == Sum(a, s, t) + Sum(a, t, u)\n{\n  if t == u {\n    assert Sum(a, t, u) == 0;\n  } else {\n    SumAdditive(a, s, t, u-1);\n    assert Sum(a, s, u) == Sum(a, s, u-1) + a[u-1];\n    assert Sum(a, s, u-1) == Sum(a, s, t) + Sum(a, t, u-1);\n    assert Sum(a, t, u) == Sum(a, t, u-1) + a[u-1];\n  }\n}\n\nlemma SumExtend(a: seq<int>, s: int, t: int)\n  requires 0 <= s <= t < |a|\n  ensures Sum(a, s, t+1) == Sum(a, s, t) + a[t]\n{\n}\n\nlemma SumEmpty(a: seq<int>, s: int)\n  requires 0 <= s <= |a|\n  ensures Sum(a, s, s) == 0\n{\n}\n\nlemma SumBounds(a: seq<int>, p: int, q: int)\n  requires 0 <= p <= q <= |a|\n  ensures Sum(a, p, q) >= Sum(a, p, p)\n{\n  SumEmpty(a, p);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxSegSum(a: seq<int>) returns (k: int, m: int)\n  ensures 0 <= k <= m <= |a|\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) <= Sum(a, k, m)\n// </vc-spec>\n// <vc-code>\n{\n  k, m := 0, 0;\n  var maxSum := 0;\n  \n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant 0 <= k <= m <= |a|\n    invariant maxSum == Sum(a, k, m)\n    invariant maxSum >= 0\n    invariant forall p, q :: 0 <= p <= q <= |a| && p < i ==> Sum(a, p, q) <= maxSum\n  {\n    var j := i;\n    while j < |a|\n      invariant i <= j <= |a|\n      invariant 0 <= k <= m <= |a|\n      invariant maxSum == Sum(a, k, m)\n      invariant maxSum >= 0\n      invariant forall p, q :: 0 <= p <= q <= |a| && p < i ==> Sum(a, p, q) <= maxSum\n      invariant forall q :: i <= q <= j ==> Sum(a, i, q) <= maxSum\n    {\n      j := j + 1;\n      var currentSum := Sum(a, i, j);\n      if currentSum > maxSum {\n        k, m := i, j;\n        maxSum := currentSum;\n      }\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_integer_square_root_SquareRoot.dfy", "root", true, "", "", false, "Clover_integer_square_root_SquareRoot.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SquareRootProperties(r: nat, N: nat)\n  requires r * r <= N\n  requires N < (r + 1) * (r + 1)\n  ensures r * r <= N < (r + 1) * (r + 1)\n{\n}\n\nlemma MonotonicityLemma(i: nat, j: nat)\n  requires i <= j\n  ensures i * i <= j * j\n{\n}\n\nlemma SquareGrowthLemma(r: nat)\n  ensures r * r < (r + 1) * (r + 1)\n{\n  calc {\n    (r + 1) * (r + 1);\n    ==\n    r * r + 2 * r + 1;\n    >\n    r * r;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n// </vc-spec>\n// <vc-code>\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= N\n    invariant r * r <= N\n    decreases N - r * r\n  {\n    r := r + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_432_MedianLength.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_432_MedianLength.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MedianLength(a: int, b: int) returns (median: int)\n    requires a > 0 && b > 0\n    ensures median == (a + b) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MedianLength(a: int, b: int) returns (median: int)\n    requires a > 0 && b > 0\n    ensures median == (a + b) / 2\n// </vc-spec>\n// <vc-code>\n{\n  median := (a + b) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-duck_tmp_tmplawbgxjo_ex3_BadSort.dfy", "root", true, "", "", false, "dafny-duck_tmp_tmplawbgxjo_ex3_BadSort.dfy", "// <vc-preamble>\npredicate sortedbad(s: string)\n{\n\n  forall i, j :: 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b' ==> i < j &&\n\n  forall i, j :: 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd' ==> i < j\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall i :: 0<=i<|a| ==> a[i] in {'b', 'a', 'd'}\nensures sortedbad(b)\nensures multiset(b[..]) == multiset(a[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// program verifies\n\npredicate sortedbad(s: string)\n{\n  // no b's after non-b's\n  forall i, j :: 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b' ==> i < j &&\n  // only non-d's before d's\n  forall i, j :: 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd' ==> i < j\n}\n\n// <vc-helpers>\nlemma MultisetPreservation(s: string, i: int, j: int)\n  requires 0 <= i < |s| && 0 <= j < |s|\n  ensures multiset(s[i := s[j]][j := s[i]][..]) == multiset(s[..])\n{\n  var s1 := s[i := s[j]];\n  var s2 := s1[j := s[i]];\n  \n  if i == j {\n    assert s2 == s;\n  } else {\n    assert multiset(s2[..]) == multiset(s[..]);\n  }\n}\n\nlemma SortedBadCharacterOrder(s: string)\n  requires sortedbad(s)\n  requires forall i :: 0 <= i < |s| ==> s[i] in {'a', 'b', 'd'}\n  ensures forall i, j :: 0 <= i < j < |s| && s[i] == 'b' ==> s[j] != 'a' && s[j] != 'd'\n  ensures forall i, j :: 0 <= i < j < |s| && s[i] == 'a' ==> s[j] != 'b'\n  ensures forall i, j :: 0 <= i < j < |s| && s[j] == 'd' ==> s[i] != 'a' && s[i] != 'b'\n{\n  forall i, j | 0 <= i < j < |s| && s[i] == 'b'\n    ensures s[j] != 'a' && s[j] != 'd'\n  {\n    if s[j] == 'a' {\n      assert s[i] == 'b' && s[j] != 'b';\n      assert 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b';\n      assert sortedbad(s);\n      assert i < j;\n      assert false;\n    }\n    if s[j] == 'd' {\n      assert s[i] == 'b' && s[j] != 'b';\n      assert 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b';\n      assert sortedbad(s);\n      assert i < j;\n      assert false;\n    }\n  }\n  \n  forall i, j | 0 <= i < j < |s| && s[i] == 'a'\n    ensures s[j] != 'b'\n  {\n    if s[j] == 'b' {\n      assert s[i] != 'd' && s[j] == 'd';\n      assert 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd';\n      assert sortedbad(s);\n      assert i < j;\n      assert false;\n    }\n  }\n  \n  forall i, j | 0 <= i < j < |s| && s[j] == 'd'\n    ensures s[i] != 'a' && s[i] != 'b'\n  {\n    if s[i] == 'a' || s[i] == 'b' {\n      assert s[i] != 'd' && s[j] == 'd';\n      assert 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd';\n      assert sortedbad(s);\n      assert i < j;\n      assert false;\n    }\n  }\n}\n\npredicate IsSorted(s: string, start: int)\n  requires 0 <= start <= |s|\n{\n  sortedbad(s[start..])\n}\n\nlemma SortedImpliesOrder(s: string)\n  requires sortedbad(s)\n  requires forall i :: 0 <= i < |s| ==> s[i] in {'a', 'b', 'd'}\n  ensures forall i, j :: 0 <= i < j < |s| && s[i] == 'b' ==> s[j] != 'a' && s[j] != 'd'\n  ensures forall i, j :: 0 <= i < j < |s| && s[i] == 'a' ==> s[j] != 'b'\n  ensures forall i, j :: 0 <= i < j < |s| && s[j] == 'd' ==> s[i] != 'a' && s[i] != 'b'\n{\n  SortedBadCharacterOrder(s);\n}\n\nlemma CountCardinality(a: string, i: int, c: char)\n  requires 0 <= i <= |a|\n  ensures |set j | 0 <= j < i && a[j] == c| <= i\n{\n}\n\nlemma MultisetCountProperty(a: string, aCount: int, bCount: int, dCount: int)\n  requires forall i :: 0 <= i < |a| ==> a[i] in {'a', 'b', 'd'}\n  requires aCount == |set j | 0 <= j < |a| && a[j] == 'a'|\n  requires bCount == |set j | 0 <= j < |a| && a[j] == 'b'|\n  requires dCount == |set j | 0 <= j < |a| && a[j] == 'd'|\n  ensures multiset(seq(aCount, _ => 'a') + seq(bCount, _ => 'b') + seq(dCount, _ => 'd')) == multiset(a[..])\n{\n  var aPart := seq(aCount, _ => 'a');\n  var bPart := seq(bCount, _ => 'b');\n  var dPart := seq(dCount, _ => 'd');\n  var result := aPart + bPart + dPart;\n  \n  var msA := multiset(a[..]);\n  var msResult := multiset(result);\n  \n  assert msA['a'] == |set j | 0 <= j < |a| && a[j] == 'a'| == aCount;\n  assert msA['b'] == |set j | 0 <= j < |a| && a[j] == 'b'| == bCount;\n  assert msA['d'] == |set j | 0 <= j < |a| && a[j] == 'd'| == dCount;\n  \n  assert msResult['a'] == aCount;\n  assert msResult['b'] == bCount;\n  assert msResult['d'] == dCount;\n  \n  forall x | x !in {'a', 'b', 'd'}\n    ensures msA[x] == 0 && msResult[x] == 0\n  {\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall i :: 0<=i<|a| ==> a[i] in {'b', 'a', 'd'}\nensures sortedbad(b)\nensures multiset(b[..]) == multiset(a[..])\n// </vc-spec>\n// <vc-code>\n{\n  var aCount := 0;\n  var bCount := 0;\n  var dCount := 0;\n  \n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant aCount + bCount + dCount == i\n    invariant aCount <= |multiset(a[..i])['a']|\n    invariant bCount <= |multiset(a[..i])['b']|\n    invariant dCount <= |multiset(a[..i])['d']|\n    invariant forall j :: 0 <= j < i ==> a[j] in {'a', 'b', 'd'}\n    invariant forall j :: 0 <= j < i && a[j] == 'a' ==> aCount >= 1\n    invariant forall j :: 0 <= j < i && a[j] == 'b' ==> bCount >= 1\n    invariant forall j :: 0 <= j < i && a[j] == 'd' ==> dCount >= 1\n  {\n    CountCardinality(a, i, a[i]);\n    if a[i] == 'a' {\n      aCount := aCount + 1;\n    } else if a[i] == 'b' {\n      bCount := bCount + 1;\n    } else {\n      dCount := dCount + 1;\n    }\n    i := i + 1;\n  }\n  \n  b := seq(aCount, _ => 'a') + seq(bCount, _ => 'b') + seq(dCount, _ => 'd');\n  \n  MultisetCountProperty(a, aCount, bCount, dCount);\n  \n  assert forall i, j :: 0 <= i < j < |b| ==> \n    (b[i] == 'a' ==> b[j] in {'a', 'b', 'd'}) &&\n    (b[i] == 'b' ==> b[j] in {'b', 'd'}) &&\n    (b[i] == 'd' ==> b[j] == 'd');\n    \n  SortedImpliesOrder(b);\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_relativeOrder_FindEvenNumbers.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_relativeOrder_FindEvenNumbers.dfy", "// <vc-preamble>\npredicate IsEven (n: int)\n{\n  n % 2 == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindEvenNumbers (arr: array<int>)\n  returns (evenNumbers: array<int>)\n  ensures forall x :: x in arr[..] && IsEven(x) ==> x in evenNumbers[..];\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n    ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n    exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort.dfy", "// <vc-preamble>\npredicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}\n\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod insertionSort (a: array<int>)\n\n    modifies a\n    ensures sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}\n\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma sortedAPreservation(a: array<int>, i: int)\n    requires 0 <= i <= a.Length\n    requires sortedA(a, i)\n    ensures sortedA(a, i)\n{\n}\n\nlemma sortedAExtension(a: array<int>, i: int)\n    requires 0 < i <= a.Length\n    requires sortedA(a, i-1)\n    requires i == 1 || a[i-2] <= a[i-1]\n    ensures sortedA(a, i)\n{\n}\n\nlemma insertPreservesOrder(a: array<int>, pos: int, val: int, i: int)\n    requires 0 <= pos < i <= a.Length\n    requires sortedA(a, pos)\n    requires pos == 0 || a[pos-1] <= val\n    requires val <= a[pos]\n{\n}\n\nlemma shiftPreservesRelativeOrder(a: array<int>, start: int, end: int)\n    requires 0 <= start <= end < a.Length\n    requires sortedA(a, start)\n{\n}\n\nlemma sortedAAfterInsertion(a: array<int>, pos: int, key: int, i: int)\n    requires 0 <= pos <= i < a.Length\n    requires sortedA(a, pos)\n    requires pos == 0 || a[pos-1] <= key\n    requires forall k :: pos < k <= i ==> a[k] > key\n    ensures sortedA(a, pos + 1)\n{\n    if pos + 1 <= 1 {\n        return;\n    }\n    \n    forall k | 0 < k < pos + 1\n        ensures a[k-1] <= a[k]\n    {\n        if k <= pos {\n            assert sortedA(a, pos);\n            assert a[k-1] <= a[k];\n        }\n    }\n}\n\nlemma sortedAInsertionMaintenance(a: array<int>, j: int, key: int, i: int)\n    requires 0 <= j + 1 <= i < a.Length\n    requires (j == -1) || (j >= 0 && a[j] <= key)\n    requires forall k :: j + 1 < k <= i ==> a[k] > key\n    requires sortedA(a, j + 1)\n    requires a[j + 1] == key\n    ensures sortedA(a, i + 1)\n{\n    if i + 1 <= 1 {\n        return;\n    }\n    \n    forall k | 0 < k < i + 1\n        ensures a[k-1] <= a[k]\n    {\n        if k <= j + 1 {\n            assert sortedA(a, j + 1);\n            if k <= j + 1 && j + 1 > 0 {\n                assert a[k-1] <= a[k];\n            }\n        } else if k == j + 2 && j + 2 <= i {\n            if j >= 0 {\n                assert a[j] <= key;\n                assert a[j+1] == key;\n                assert a[k] > key;\n                assert a[j+1] <= a[k];\n            }\n        } else if k > j + 2 {\n            assert j + 2 < k <= i;\n            assert a[k-1] > key && a[k] > key;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod insertionSort (a: array<int>)\n\n    modifies a\n    ensures sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length <= 1 {\n        return;\n    }\n    \n    var i := 1;\n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant sortedA(a, i)\n    {\n        var key := a[i];\n        var j := i - 1;\n        \n        ghost var oldA := a[..];\n        \n        while j >= 0 && a[j] > key\n            invariant -1 <= j < i\n            invariant sortedA(a, j + 1)\n            invariant forall k :: j < k < i ==> a[k] > key\n            invariant forall k :: i < k < a.Length ==> a[k] == oldA[k]\n            invariant forall k :: 0 <= k <= j ==> a[k] == oldA[k]\n            invariant j + 1 < i ==> a[j + 1] > key\n        {\n            a[j + 1] := a[j];\n            j := j - 1;\n        }\n        \n        a[j + 1] := key;\n        \n        assert a[j + 1] == key;\n        assert (j == -1) || (j >= 0 && a[j] <= key);\n        assert forall k :: j + 1 < k <= i ==> a[k] > key;\n        \n        sortedAInsertionMaintenance(a, j, key, i);\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_741_AllCharactersSame.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_741_AllCharactersSame.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllCharactersSame(s: string) returns (result: bool)\n    ensures result ==> forall i, j :: 0 <= i < |s| && 0 <= j < |s| ==> s[i] == s[j]\n    ensures !result ==> (|s| > 1) && (exists i, j :: 0 <= i < |s| && 0 <= j < |s| && i != j && s[i] != s[j])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AllCharactersSame(s: string) returns (result: bool)\n    ensures result ==> forall i, j :: 0 <= i < |s| && 0 <= j < |s| ==> s[i] == s[j]\n    ensures !result ==> (|s| > 1) && (exists i, j :: 0 <= i < |s| && 0 <= j < |s| && i != j && s[i] != s[j])\n// </vc-spec>\n// <vc-code>\n{\n    if |s| <= 1 {\n        return true;\n    }\n    \n    var i := 1;\n    while i < |s|\n        invariant 1 <= i <= |s|\n        invariant forall k :: 0 <= k < i ==> s[k] == s[0]\n    {\n        if s[i] != s[0] {\n            return false;\n        }\n        i := i + 1;\n    }\n    \n    return true;\n}\n// </vc-code>\n\n", "", "", ""], ["software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort.dfy", "root", true, "", "", false, "software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort.dfy", "// <vc-preamble>\nmethod find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n{\n  assume{:axiom} false;\n}\n\npredicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod selection_sort(ns: array<int>) \nrequires ns.Length >= 0\nensures is_sorted(ns[..])\nensures is_permutation2(old(ns[..]), ns[..])\nmodifies ns\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "method find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\n\n// predicate is_permutation(a:seq<int>, b:seq<int>)\n// decreases |a|\n// decreases |b|\n// {\n//     |a| == |b|  && ((|a| == 0 && |b| == 0) ||  exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))\n// }\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}\n\n// <vc-helpers>\nlemma find_min_index_correct(a: array<int>, s: int, e: int, min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\nrequires min_i >= s && min_i < e\nrequires forall k: int :: s <= k < e ==> a[min_i] <= a[k]\nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n{\n}\n\nlemma swap_preserves_permutation(a: seq<int>, i: int, j: int, new_a: seq<int>)\nrequires 0 <= i < |a|\nrequires 0 <= j < |a|\nrequires |new_a| == |a|\nrequires forall k :: 0 <= k < |a| && k != i && k != j ==> new_a[k] == a[k]\nrequires new_a[i] == a[j]\nrequires new_a[j] == a[i]\nensures multiset(a) == multiset(new_a)\n{\n    if i == j {\n        assert a == new_a;\n    } else {\n        var ma := multiset(a);\n        var mb := multiset(new_a);\n        \n        forall x | x in ma || x in mb\n        ensures ma[x] == mb[x]\n        {\n            if x != a[i] && x != a[j] {\n                // Count unchanged elements\n                var count_a := |set k | 0 <= k < |a| && a[k] == x|;\n                var count_b := |set k | 0 <= k < |new_a| && new_a[k] == x|;\n                assert count_a == count_b;\n            } else if x == a[i] && x == a[j] {\n                // When both swapped elements are equal\n                assert ma[x] == mb[x];\n            } else if x == a[i] {\n                // Element at position i moves to position j\n                assert ma[x] == mb[x];\n            } else if x == a[j] {\n                // Element at position j moves to position i  \n                assert ma[x] == mb[x];\n            }\n        }\n    }\n}\n\nlemma sorted_prefix_extends(a: array<int>, i: int)\nrequires 0 <= i < a.Length\nrequires forall k, l :: 0 <= k <= l < i ==> a[k] <= a[l]\nrequires forall k :: i <= k < a.Length ==> a[i] <= a[k]\nensures forall k, l :: 0 <= k <= l < i + 1 ==> a[k] <= a[l]\n{\n    forall k, l | 0 <= k <= l < i + 1\n    ensures a[k] <= a[l]\n    {\n        if l < i {\n            assert a[k] <= a[l];\n        } else if k < i && l == i {\n            assert a[k] <= a[i];\n        } else if k == i && l == i {\n            assert a[k] <= a[l];\n        }\n    }\n}\n\nlemma no_change_preserves_multiset(a: seq<int>, b: seq<int>)\nrequires a == b\nensures multiset(a) == multiset(b)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod selection_sort(ns: array<int>) \nrequires ns.Length >= 0\nensures is_sorted(ns[..])\nensures is_permutation2(old(ns[..]), ns[..])\nmodifies ns\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  \n  while i < ns.Length - 1\n  invariant 0 <= i <= ns.Length\n  invariant forall k, l :: 0 <= k <= l < i ==> ns[k] <= ns[l]\n  invariant forall k, l :: 0 <= k < i && i <= l < ns.Length ==> ns[k] <= ns[l]\n  invariant multiset(old(ns[..])) == multiset(ns[..])\n  {\n    var min_idx := find_min_index(ns, i, ns.Length);\n    \n    // Establish that min_idx gives us the minimum element\n    assert forall k :: i <= k < ns.Length ==> ns[min_idx] <= ns[k];\n    \n    if min_idx != i {\n      var old_seq := ns[..];\n      ns[i], ns[min_idx] := ns[min_idx], ns[i];\n      swap_preserves_permutation(old_seq, i, min_idx, ns[..]);\n    } else {\n      var old_seq := ns[..];\n      no_change_preserves_multiset(old_seq, ns[..]);\n    }\n    \n    // After the swap/no-change, establish the preconditions for sorted_prefix_extends\n    assert forall k :: i <= k < ns.Length ==> ns[i] <= ns[k];\n    \n    sorted_prefix_extends(ns, i);\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_594_FirstEvenOddDifference.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_594_FirstEvenOddDifference.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\n// <vc-helpers>\nmethod ComputeFirstEven(a: array<int>) returns (firstEven: int)\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    ensures 0 <= firstEven < a.Length\n    ensures IsEven(a[firstEven])\n    ensures forall k :: 0 <= k < firstEven ==> IsOdd(a[k])\n{\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> IsOdd(a[k])\n    {\n        if IsEven(a[i]) {\n            firstEven := i;\n            return;\n        }\n        i := i + 1;\n    }\n}\n\nmethod ComputeFirstOdd(a: array<int>) returns (firstOdd: int)\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures 0 <= firstOdd < a.Length\n    ensures IsOdd(a[firstOdd])\n    ensures forall k :: 0 <= k < firstOdd ==> IsEven(a[k])\n{\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> IsEven(a[k])\n    {\n        if IsOdd(a[i]) {\n            firstOdd := i;\n            return;\n        }\n        i := i + 1;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n// </vc-spec>\n// <vc-code>\n{\n    var firstEven := ComputeFirstEven(a);\n    var firstOdd := ComputeFirstOdd(a);\n    diff := a[firstEven] - a[firstOdd];\n}\n// </vc-code>\n\n", "", "", ""], ["BinaryAddition_BinaryAddition.dfy", "root", true, "", "", false, "BinaryAddition_BinaryAddition.dfy", "// <vc-preamble>\nfunction ArrayToBv10(arr: array<bool>): bv10\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>)\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n{\n  assume{:axiom} false;\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction Bv10ToSeq(x: bv10): seq<bool>\n    ensures |Bv10ToSeq(x)| == 10\n    ensures forall i: nat :: 0 <= i < 10 ==> Bv10ToSeq(x)[i] == isBitSet(x, i)\n{\n    var result := [isBitSet(x, 0), isBitSet(x, 1), isBitSet(x, 2), isBitSet(x, 3),\n    isBitSet(x, 4), isBitSet(x, 5), isBitSet(x, 6), isBitSet(x, 7),\n    isBitSet(x, 8), isBitSet(x, 9)];\n    assert result[0] == isBitSet(x, 0);\n    assert result[1] == isBitSet(x, 1);\n    assert result[2] == isBitSet(x, 2);\n    assert result[3] == isBitSet(x, 3);\n    assert result[4] == isBitSet(x, 4);\n    assert result[5] == isBitSet(x, 5);\n    assert result[6] == isBitSet(x, 6);\n    assert result[7] == isBitSet(x, 7);\n    assert result[8] == isBitSet(x, 8);\n    assert result[9] == isBitSet(x, 9);\n    assert forall i: nat :: 0 <= i < 10 ==> result[i] == isBitSet(x, i);\n    result\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}\n\nfunction BitAddition(s: array<bool>, t: array<bool>): seq<bool>\n    reads s\n    reads t\n    requires s.Length == 10 && t.Length == 10\n{\n    var a: bv10 := ArrayToBv10(s);\n    var b: bv10 := ArrayToBv10(t);\n    var c: bv10 := a + b;\n    Bv10ToSeq(c)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinaryAddition(s: array<bool>, t: array<bool>) returns (sresult: seq<bool>)\n    requires s.Length == 10 && t.Length == 10\n    ensures |sresult| == 10\n    ensures BitAddition(s, t) == sresult\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \nMIPS 0\nWe implement the following with bitvectors in Dafny.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\nfunction ArrayToBv10(arr: array<bool>): bv10 // Converts boolean array to bitvector\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n    ensures forall i :: 0 <= i < index ==> ((ArrayToBv10Helper(arr, i) >> i) & 1) == (if arr\n        [i] then 1 else 0)\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>) // Converts boolean array to boolean sequence\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n{\n  assume{:axiom} false;\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction Bv10ToSeq(x: bv10): seq<bool> // Converts bitvector to boolean sequence\n    ensures |Bv10ToSeq(x)| == 10\n    ensures forall i: nat :: 0 <= i < 10 ==> Bv10ToSeq(x)[i] == isBitSet(x, i)\n{\n    [isBitSet(x, 0), isBitSet(x, 1), isBitSet(x, 2), isBitSet(x, 3),\n    isBitSet(x, 4), isBitSet(x, 5), isBitSet(x, 6), isBitSet(x, 7),\n    isBitSet(x, 8), isBitSet(x, 9)]\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}\n\nfunction BitAddition(s: array<bool>, t: array<bool>): seq<bool> // Performs traditional bit addition\n    reads s\n    reads t\n    requires s.Length == 10 && t.Length == 10\n{\n    var a: bv10 := ArrayToBv10(s);\n    var b: bv10 := ArrayToBv10(t);\n    var c: bv10 := a + b;\n    Bv10ToSeq(c)\n}\n\n// <vc-helpers>\nlemma ArrayToBv10Correctness(arr: array<bool>)\n    requires arr.Length == 10\n    ensures forall i :: 0 <= i < 10 ==> isBitSet(ArrayToBv10(arr), i) == arr[i]\n{\n    assert ArrayToBv10(arr) == ArrayToBv10Helper(arr, 9);\n    forall i | 0 <= i < 10\n        ensures isBitSet(ArrayToBv10(arr), i) == arr[i]\n    {\n        ArrayToBv10HelperCorrectness(arr, 9, i);\n    }\n}\n\nlemma {:vcs_split_on_every_assert} ArrayToBv10HelperCorrectness(arr: array<bool>, index: nat, bitPos: nat)\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    requires 0 <= bitPos <= index\n    ensures isBitSet(ArrayToBv10Helper(arr, index), bitPos) == arr[bitPos]\n    decreases index\n{\n    if index == 0 {\n        // Base case\n    } else if bitPos == index {\n        // Current bit case\n    } else {\n        // Inductive case\n        ArrayToBv10HelperCorrectness(arr, index - 1, bitPos);\n    }\n}\n\nlemma BitAdditionCorrectness(s: array<bool>, t: array<bool>)\n    requires s.Length == 10 && t.Length == 10\n    ensures BitAddition(s, t) == Bv10ToSeq(ArrayToBv10(s) + ArrayToBv10(t))\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinaryAddition(s: array<bool>, t: array<bool>) returns (sresult: seq<bool>) // Generated program for bit addition\n    requires s.Length == 10 && t.Length == 10\n    ensures |sresult| == 10\n    ensures BitAddition(s, t) == sresult // Verification of correctness\n// </vc-spec>\n// <vc-code>\n{\n    var a := ArrayToBv10(s);\n    var b := ArrayToBv10(t);\n    var c := a + b;\n    sresult := Bv10ToSeq(c);\n    \n    BitAdditionCorrectness(s, t);\n}\n// </vc-code>\n\n", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse (a : array<int>) returns (aRev : array<int>)\n    ensures aRev.Length == a.Length\n    ensures forall i : int :: 0 <= i < a.Length ==> a[i] == aRev[aRev.Length-i-1]\n    ensures fresh(aRev)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse (a : array<int>) returns (aRev : array<int>)\n    ensures aRev.Length == a.Length\n    ensures forall i : int :: 0 <= i < a.Length ==> a[i] == aRev[aRev.Length-i-1]\n    ensures fresh(aRev) // Indicates returned object is newly created in method body\n// </vc-spec>\n// <vc-code>\n{\n    aRev := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant aRev.Length == a.Length\n        invariant forall k : int :: 0 <= k < i ==> a[k] == aRev[aRev.Length-k-1]\n    {\n        aRev[a.Length-i-1] := a[i];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "", "", ""], ["Clover_double_array_elements_double_array_elements.dfy", "root", true, "", "", false, "Clover_double_array_elements_double_array_elements.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod double_array_elements(s: array<int>)\n  modifies s\n  ensures forall i :: 0 <= i < s.Length ==> s[i] == 2 * old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod double_array_elements(s: array<int>)\n  modifies s\n  ensures forall i :: 0 <= i < s.Length ==> s[i] == 2 * old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> s[j] == 2 * old(s[j])\n    invariant forall j :: i <= j < s.Length ==> s[j] == old(s[j])\n  {\n    s[i] := 2 * s[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_tmp_tmp49a6ihvk_m4_DutchFlag.dfy", "root", true, "", "", false, "dafny_tmp_tmp49a6ihvk_m4_DutchFlag.dfy", "// <vc-preamble>\ndatatype Color = Red | White | Blue\n\npredicate Below(c: Color, d: Color)\n{\n    c == Red || c == d || d == Blue\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DutchFlag(a: array<Color>)\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> Below(a[i], a[j])\n    ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Color = Red | White | Blue\n\npredicate Below(c: Color, d: Color)\n{\n    c == Red || c == d || d == Blue\n}\n\n// <vc-helpers>\nlemma BelowTransitive(a: Color, b: Color, c: Color)\n    requires Below(a, b) && Below(b, c)\n    ensures Below(a, c)\n{\n}\n\nlemma BelowReflexive(a: Color)\n    ensures Below(a, a)\n{\n}\n\nlemma RedBelowAll(c: Color)\n    ensures Below(Red, c)\n{\n}\n\nlemma AllBelowBlue(c: Color)\n    ensures Below(c, Blue)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DutchFlag(a: array<Color>)\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> Below(a[i], a[j])\n    ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length <= 1 { return; }\n    \n    var red := 0;\n    var white := 0;\n    var blue := a.Length;\n    \n    while white < blue\n        invariant 0 <= red <= white <= blue <= a.Length\n        invariant forall i :: 0 <= i < red ==> a[i] == Red\n        invariant forall i :: red <= i < white ==> a[i] == White\n        invariant forall i :: blue <= i < a.Length ==> a[i] == Blue\n        invariant multiset(a[..]) == multiset(old(a[..]))\n        decreases blue - white\n    {\n        if a[white] == White {\n            white := white + 1;\n        } else if a[white] == Red {\n            a[red], a[white] := a[white], a[red];\n            red := red + 1;\n            white := white + 1;\n        } else {\n            blue := blue - 1;\n            a[white], a[blue] := a[blue], a[white];\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_binary_search_BinarySearch.dfy", "root", true, "", "", false, "Clover_binary_search_BinarySearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  ensures 0<= n <=a.Length\n  ensures forall i :: 0<= i < n ==> a[i] < key\n  ensures n == a.Length ==> forall i :: 0 <= i < a.Length ==> a[i] < key\n  ensures forall i :: n<= i < a.Length ==> a[i]>=key\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  ensures 0<= n <=a.Length\n  ensures forall i :: 0<= i < n ==> a[i] < key\n  ensures n == a.Length ==> forall i :: 0 <= i < a.Length ==> a[i] < key\n  ensures forall i :: n<= i < a.Length ==> a[i]>=key\n// </vc-spec>\n// <vc-code>\n{\n  var low := 0;\n  var high := a.Length;\n  \n  while low < high\n    invariant 0 <= low <= high <= a.Length\n    invariant forall i :: 0 <= i < low ==> a[i] < key\n    invariant forall i :: high <= i < a.Length ==> a[i] >= key\n  {\n    var mid := (low + high) / 2;\n    if a[mid] < key {\n      low := mid + 1;\n    } else {\n      high := mid;\n    }\n  }\n  \n  n := low;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_242_CountCharacters.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_242_CountCharacters.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountCharacters(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == |s|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountCharacters(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == |s|\n// </vc-spec>\n// <vc-code>\n{\n  count := |s|;\n}\n// </vc-code>\n\n", "", "", ""], ["dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum.dfy", "root", true, "", "", false, "dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum.dfy", "// <vc-preamble>\nghost predicate correct_pair(pair: (int, int), nums: seq<int>, target: int) {\n  var (i, j) := pair;\n  && 0 <= i < |nums|\n  && 0 <= j < |nums|\n  && i != j\n  && nums[i] + nums[j] == target\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (int, int))\n  requires exists i, j :: correct_pair((i, j), nums, target)\n  ensures correct_pair(pair, nums, target)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* https://leetcode.com/problems/two-sum/\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n*/\n\n\nghost predicate correct_pair(pair: (int, int), nums: seq<int>, target: int) {\n  var (i, j) := pair;\n  && 0 <= i < |nums|\n  && 0 <= j < |nums|\n  && i != j  // \"you may not use the same element twice\"\n  && nums[i] + nums[j] == target\n}\n\n// We actually make a weaker pre-condition: there exists at least one solution.\n// For verification simplicity, we pretend as if:\n// - `seq` were Python list\n// - `map` were Python dict\n\n/* Discussions\n1. It may be tempting to append `&& e_to_i[nums[i']] == i'` to the invariant (formula A),\n  but this is wrong, because `nums` may contain redundant elements.\n  Redundant elements will share the same key in `e_to_i`, the newer overwriting the older.\n\n2. Tip: Generally, we often need invariants when copying data from a container to another.\n  To specify a set/map, we often need \"back and forth\" assertions, namely:\n  (a) What elements are in the map/set (like in formula A)\n  (b) What do elements in the set/map satisfy (like in formula B)\n*/\n\n// <vc-helpers>\nlemma exists_correct_pair_lemma(nums: seq<int>, target: int)\n  requires exists i, j :: correct_pair((i, j), nums, target)\n  ensures exists i, j :: 0 <= i < |nums| && 0 <= j < |nums| && i != j && nums[i] + nums[j] == target\n{\n}\n\nghost predicate valid_map(e_to_i: map<int, int>, nums: seq<int>, k: int)\n  requires 0 <= k <= |nums|\n{\n  forall i :: 0 <= i < k ==> nums[i] in e_to_i\n}\n\nghost predicate map_indices_valid(e_to_i: map<int, int>, nums: seq<int>)\n{\n  forall e :: e in e_to_i ==> 0 <= e_to_i[e] < |nums| && nums[e_to_i[e]] == e\n}\n\nghost predicate map_indices_less_than(e_to_i: map<int, int>, k: int)\n{\n  forall e :: e in e_to_i ==> e_to_i[e] < k\n}\n\nghost predicate no_early_solution(nums: seq<int>, target: int, k: int)\n  requires 0 <= k <= |nums|\n{\n  forall i, j :: 0 <= i < k && 0 <= j < k && i != j ==> nums[i] + nums[j] != target\n}\n\nlemma solution_exists_implies_future_solution(nums: seq<int>, target: int, k: int)\n  requires 0 <= k < |nums|\n  requires exists i, j :: correct_pair((i, j), nums, target)\n  requires no_early_solution(nums, target, k)\n  ensures exists i, j :: k <= i < |nums| && 0 <= j < |nums| && i != j && nums[i] + nums[j] == target\n{\n  assert exists i, j :: 0 <= i < |nums| && 0 <= j < |nums| && i != j && nums[i] + nums[j] == target;\n  \n  var wit_i, wit_j :| 0 <= wit_i < |nums| && 0 <= wit_j < |nums| && wit_i != wit_j && nums[wit_i] + nums[wit_j] == target;\n  \n  if wit_i >= k {\n    assert k <= wit_i < |nums| && 0 <= wit_j < |nums| && wit_i != wit_j && nums[wit_i] + nums[wit_j] == target;\n  } else if wit_j >= k {\n    assert k <= wit_j < |nums| && 0 <= wit_i < |nums| && wit_j != wit_i && nums[wit_j] + nums[wit_i] == target;\n  } else {\n    assert 0 <= wit_i < k && 0 <= wit_j < k && wit_i != wit_j;\n    assert nums[wit_i] + nums[wit_j] == target;\n    assert false;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (int, int))\n  requires exists i, j :: correct_pair((i, j), nums, target)\n  ensures correct_pair(pair, nums, target)\n// </vc-spec>\n// <vc-code>\n{\n  var e_to_i: map<int, int> := map[];\n  \n  for i := 0 to |nums|\n    invariant 0 <= i <= |nums|\n    invariant valid_map(e_to_i, nums, i)\n    invariant map_indices_valid(e_to_i, nums)\n    invariant map_indices_less_than(e_to_i, i)\n    invariant no_early_solution(nums, target, i)\n  {\n    var complement := target - nums[i];\n    if complement in e_to_i {\n      var j := e_to_i[complement];\n      assert nums[j] == complement;\n      assert nums[i] + nums[j] == target;\n      assert j < i;\n      assert i != j;\n      return (j, i);\n    }\n    e_to_i := e_to_i[nums[i] := i];\n  }\n  \n  solution_exists_implies_future_solution(nums, target, |nums|);\n  assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch.dfy", "// <vc-preamble>\npredicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod otherbSearch(v:array<int>, elem:int) returns (b:bool,p:int)\n requires sorted(v[0..v.Length])\n ensures 0<=p<=v.Length\n ensures b == (elem in v[0..v.Length])\n ensures b ==> p<v.Length && v[p]==elem\n ensures !b ==> (forall u::0<=u<p ==> v[u]<elem) && \n               (forall w::p<=w<v.Length ==> v[w]>elem)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}\n\n\n\n\n\n\n//Recursive binary search\n\n// <vc-helpers>\nmethod binarySearchRec(v:array<int>, elem:int, lo:int, hi:int) returns (b:bool, p:int)\n requires sorted(v[0..v.Length])\n requires 0 <= lo <= hi <= v.Length\n ensures lo <= p <= hi\n ensures b == (elem in v[lo..hi])\n ensures b ==> p < v.Length && v[p] == elem\n ensures !b ==> ((forall u :: lo <= u < p ==> v[u] < elem) && \n                (forall w :: p <= w < hi ==> v[w] > elem))\n decreases hi - lo\n{\n  if lo == hi {\n    return false, lo;\n  }\n  \n  var mid := lo + (hi - lo) / 2;\n  \n  if v[mid] == elem {\n    return true, mid;\n  } else if v[mid] < elem {\n    b, p := binarySearchRec(v, elem, mid + 1, hi);\n  } else {\n    b, p := binarySearchRec(v, elem, lo, mid);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod otherbSearch(v:array<int>, elem:int) returns (b:bool,p:int)\n requires sorted(v[0..v.Length])\n ensures 0<=p<=v.Length\n ensures b == (elem in v[0..v.Length])\n ensures b ==> p<v.Length && v[p]==elem\n ensures !b ==> (forall u::0<=u<p ==> v[u]<elem) && \n               (forall w::p<=w<v.Length ==> v[w]>elem)\n //Implement and verify\n// </vc-spec>\n// <vc-code>\n{\n  b, p := binarySearchRec(v, elem, 0, v.Length);\n}\n// </vc-code>\n\n", "", "", ""], ["BelowZero_BelowZero.dfy", "root", true, "", "", false, "BelowZero_BelowZero.dfy", "// <vc-preamble>\nfunction sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BelowZero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \nHumanEvalX 3\nYou're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. \nYour task is to detect if at any point the balance of account falls below zero, and at that point function \nshould return True. Otherwise it should return False.\n*/\n\nfunction sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}\n\n// <vc-helpers>\nlemma SumProperty(s: seq<int>, n: nat)\n    requires n <= |s|\n    ensures sum(s, n) == if n == 0 then 0 else sum(s, n-1) + s[n-1]\n{\n    if n == 0 {\n        assert sum(s, n) == 0;\n    } else if |s| == 0 {\n        assert sum(s, n) == 0;\n    } else {\n        calc {\n            sum(s, n);\n            s[0] + sum(s[1..], n-1);\n            {\n                if n == 1 {\n                    assert sum(s[1..], n-1) == 0;\n                    assert s[0] == s[n-1];\n                } else {\n                    SumProperty(s[1..], n-1);\n                    assert sum(s[1..], n-1) == sum(s[1..], n-2) + s[1..][n-2];\n                    assert s[1..][n-2] == s[n-1];\n                }\n            }\n            sum(s, n-1) + s[n-1];\n        }\n    }\n}\n\nlemma SumIncremental(s: seq<int>, n: nat)\n    requires n < |s|\n    ensures sum(s, n+1) == sum(s, n) + s[n]\n{\n    SumProperty(s, n+1);\n}\n\nlemma SumNonNegativeBase(s: seq<int>)\n    ensures sum(s, 0) >= 0\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BelowZero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>\n// <vc-code>\n{\n    result := false;\n    var balance := 0;\n    var i := 0;\n    \n    SumNonNegativeBase(ops);\n    \n    while i < |ops|\n        invariant 0 <= i <= |ops|\n        invariant balance == sum(ops, i)\n        invariant !result ==> forall k: nat :: k <= i ==> sum(ops, k) >= 0\n        invariant result ==> exists k: nat :: k <= i && sum(ops, k) < 0\n    {\n        balance := balance + ops[i];\n        i := i + 1;\n        \n        SumIncremental(ops, i-1);\n        assert balance == sum(ops, i);\n        \n        if balance < 0 {\n            result := true;\n            assert sum(ops, i) < 0;\n            return;\n        }\n    }\n    \n    assert i == |ops|;\n    assert balance == sum(ops, |ops|);\n    assert forall k: nat :: k <= |ops| ==> sum(ops, k) >= 0;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchRecursive.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchRecursive.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SearchRecursive( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42.dfy", "root", true, "", "", false, "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Allow42(x:int, y:int) returns (z: int, err:bool) \nensures y != 42 ==> z == x/(42-y) && err == false;\nensures y == 42 ==> z == 0 && err == true;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\n    i)  Write a verified method with signature\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Allow42(x:int, y:int) returns (z: int, err:bool) \nensures y != 42 ==> z == x/(42-y) && err == false;\nensures y == 42 ==> z == 0 && err == true;\n// </vc-spec>\n// <vc-code>\n{\n  if y == 42 {\n    z := 0;\n    err := true;\n  } else {\n    z := x / (42 - y);\n    err := false;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_reverse_Reverse.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_reverse_Reverse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a == old(a)\nensures b.Length == a.Length\nensures forall i :: 0 <= i < a.Length ==> b[i] == a[a.Length - i - 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a == old(a)\nensures b.Length == a.Length\nensures forall i :: 0 <= i < a.Length ==> b[i] == a[a.Length - i - 1]\n// </vc-spec>\n// <vc-code>\n{\n  b := new char[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant b.Length == a.Length\n    invariant forall j :: 0 <= j < i ==> b[j] == a[a.Length - j - 1]\n  {\n    b[i] := a[a.Length - i - 1];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_290_MaxLengthList.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_290_MaxLengthList.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxLengthList(lists: seq<seq<int>>) returns (maxList: seq<int>)\n    requires |lists| > 0\n    ensures forall l :: l in lists ==> |l| <= |maxList|\n    ensures maxList in lists\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxLengthList(lists: seq<seq<int>>) returns (maxList: seq<int>)\n    requires |lists| > 0\n    ensures forall l :: l in lists ==> |l| <= |maxList|\n    ensures maxList in lists\n// </vc-spec>\n// <vc-code>\n{\n    maxList := lists[0];\n    var i := 1;\n    while i < |lists|\n        invariant 0 <= i <= |lists|\n        invariant maxList in lists\n        invariant forall j :: 0 <= j < i ==> |lists[j]| <= |maxList|\n    {\n        if |lists[i]| > |maxList| {\n            maxList := lists[i];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_min_of_two_Min.dfy", "root", true, "", "", false, "Clover_min_of_two_Min.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n// </vc-spec>\n// <vc-code>\n{\n  if x <= y {\n    z := x;\n  } else {\n    z := y;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_610_RemoveElement.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_610_RemoveElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElement(s: array<int>, k: int) returns (v: array<int>)\n    requires 0 <= k < s.Length\n    ensures v.Length == s.Length - 1\n    ensures forall i :: 0 <= i < k ==> v[i] == s[i]\n    ensures forall i :: k <= i < v.Length ==> v[i] == s[i + 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElement(s: array<int>, k: int) returns (v: array<int>)\n    requires 0 <= k < s.Length\n    ensures v.Length == s.Length - 1\n    ensures forall i :: 0 <= i < k ==> v[i] == s[i]\n    ensures forall i :: k <= i < v.Length ==> v[i] == s[i + 1]\n// </vc-spec>\n// <vc-code>\n{\n    v := new int[s.Length - 1];\n    \n    var i := 0;\n    while i < k\n        invariant 0 <= i <= k\n        invariant forall j :: 0 <= j < i ==> v[j] == s[j]\n    {\n        v[i] := s[i];\n        i := i + 1;\n    }\n    \n    while i < v.Length\n        invariant k <= i <= v.Length\n        invariant forall j :: 0 <= j < k ==> v[j] == s[j]\n        invariant forall j :: k <= j < i ==> v[j] == s[j + 1]\n    {\n        v[i] := s[i + 1];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElement(nums: array<int>, val: int) returns (newLength: int)\n    modifies nums\n    ensures 0 <= newLength <= nums.Length\n    ensures forall x :: x in nums[..newLength] ==> x != val\n    ensures multiset(nums[..newLength]) == multiset(old(nums[..]))[val := 0]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma MultisetRemoveProperty<T>(s: multiset<T>, x: T, count: nat)\n    requires count <= s[x]\n    ensures (s[x := s[x] - count])[x] == s[x] - count\n    ensures forall y :: y != x ==> (s[x := s[x] - count])[y] == s[y]\n{\n}\n\nlemma MultisetSliceShift(arr: array<int>, i: int, j: int)\n    requires 0 <= i < j <= arr.Length\n    ensures multiset(old(arr[..i]) + old(arr[j..])) == multiset(arr[..i] + arr[j..])\n{\n}\n\nghost function CountVal(s: seq<int>, val: int): nat\n{\n    if |s| == 0 then 0\n    else if s[0] == val then 1 + CountVal(s[1..], val)\n    else CountVal(s[1..], val)\n}\n\nlemma CountValProperty(s: seq<int>, val: int)\n    ensures CountVal(s, val) == multiset(s)[val]\n{\n    if |s| == 0 {\n    } else {\n        CountValProperty(s[1..], val);\n    }\n}\n\nlemma CountValSplit(s1: seq<int>, s2: seq<int>, val: int)\n    ensures CountVal(s1 + s2, val) == CountVal(s1, val) + CountVal(s2, val)\n{\n    if |s1| == 0 {\n    } else {\n        CountValSplit(s1[1..], s2, val);\n    }\n}\n\nlemma CountValPrefix(s: seq<int>, i: int, val: int)\n    requires 0 <= i <= |s|\n    ensures CountVal(s[..i], val) + CountVal(s[i..], val) == CountVal(s, val)\n{\n    if i == 0 {\n        CountValProperty(s, val);\n    } else if i == |s| {\n        CountValProperty(s, val);\n    } else {\n        assert s == s[..i] + s[i..];\n        CountValSplit(s[..i], s[i..], val);\n    }\n}\n\nlemma MultisetZeroUpdate(s: multiset<int>, val: int)\n    ensures s[val := 0] == multiset{}[val := 0] + (s - multiset{val}[val := s[val]])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElement(nums: array<int>, val: int) returns (newLength: int)\n    modifies nums\n    ensures 0 <= newLength <= nums.Length\n    ensures forall x :: x in nums[..newLength] ==> x != val\n    ensures multiset(nums[..newLength]) == multiset(old(nums[..]))[val := 0]\n// </vc-spec>\n// <vc-code>\n{\n    newLength := 0;\n    var i := 0;\n    ghost var originalNums := nums[..];\n    \n    while i < nums.Length\n        invariant 0 <= i <= nums.Length\n        invariant 0 <= newLength <= i\n        invariant forall x :: x in nums[..newLength] ==> x != val\n        invariant multiset(nums[..newLength]) + multiset(originalNums[..i])[val := 0] == multiset(originalNums[..i])\n        invariant multiset(nums[newLength..]) == multiset(originalNums[newLength..])\n        invariant forall k :: newLength <= k < nums.Length ==> nums[k] == originalNums[k]\n    {\n        if nums[i] != val {\n            if newLength < i {\n                nums[newLength] := nums[i];\n            }\n            newLength := newLength + 1;\n        }\n        i := i + 1;\n    }\n    \n    CountValProperty(originalNums, val);\n    CountValProperty(nums[..newLength], val);\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_FindPivotIndex_FindPivotIndex.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_FindPivotIndex_FindPivotIndex.dfy", "// <vc-preamble>\nfunction sum(nums: seq<int>): int {\n\n    if |nums| == 0 then 0 else sum(nums[0..(|nums|-1)])+nums[|nums|-1]\n}\n\nfunction sumUp(nums: seq<int>): int {\n    if |nums| == 0 then 0 else nums[0]+sumUp(nums[1..])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod  FindPivotIndex(nums: seq<int>) returns (index: int)\n    requires |nums| > 0\n    ensures index == -1 ==> forall k: nat :: k < |nums| ==> sum(nums[0..k]) != sum(nums[(k+1)..])\n    ensures 0 <= index < |nums| ==> sum(nums[0..index]) == sum(nums[(index+1)..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_455_MonthHas31Days.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_455_MonthHas31Days.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MonthHas31Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month in {1, 3, 5, 7, 8, 10, 12}\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MonthHas31Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month in {1, 3, 5, 7, 8, 10, 12}\n// </vc-spec>\n// <vc-code>\n{\n  result := month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12;\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Counting_Bits_counting_bits_counting_bits.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Counting_Bits_counting_bits_counting_bits.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod counting_bits(n: int) returns (result: array<int>)\n    requires 0 <= n <= 100000\n    ensures result.Length == n + 1\n    ensures forall i :: 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Clover_find_Find.dfy", "root", true, "", "", false, "Clover_find_Find.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n// </vc-spec>\n// <vc-code>\n{\n  index := -1;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant index == -1\n    invariant forall j :: 0 <= j < i ==> a[j] != key\n  {\n    if a[i] == key {\n      index := i;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: 0<=l<i ==> v[i]>v[l]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mfirstMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: 0<=l<i ==> v[i]>v[l]\n//Algorithm: from left to right\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  var j := 1;\n  while j < v.Length\n    invariant 0 <= i < v.Length\n    invariant 1 <= j <= v.Length\n    invariant forall k :: 0 <= k < j ==> v[i] >= v[k]\n    invariant forall l :: 0 <= l < i ==> v[i] > v[l]\n  {\n    if v[j] > v[i] {\n      i := j;\n    }\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n//Algorithm : from left to right\n//Algorithm : from right to left", "", "", ""], ["dafny-synthesis_task_id_441_CubeSurfaceArea.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_441_CubeSurfaceArea.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CubeSurfaceArea(size: int) returns (area: int)\n    requires size > 0\n    ensures area == 6 * size * size\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CubeSurfaceArea(size: int) returns (area: int)\n    requires size > 0\n    ensures area == 6 * size * size\n// </vc-spec>\n// <vc-code>\n{\n  area := 6 * size * size;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_95_SmallestListLength.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_95_SmallestListLength.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SmallestListLength(s: seq<seq<int>>) returns (v: int)\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> v <= |s[i]|\n    ensures exists i :: 0 <= i < |s| && v == |s[i]|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SmallestListLength(s: seq<seq<int>>) returns (v: int)\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> v <= |s[i]|\n    ensures exists i :: 0 <= i < |s| && v == |s[i]|\n// </vc-spec>\n// <vc-code>\n{\n    v := |s[0]|;\n    var i := 1;\n    while i < |s|\n        invariant 1 <= i <= |s|\n        invariant forall j :: 0 <= j < i ==> v <= |s[j]|\n        invariant exists j :: 0 <= j < i && v == |s[j]|\n    {\n        if |s[i]| < v {\n            v := |s[i]|;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero.dfy", "root", true, "", "", false, "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero.dfy", "// <vc-preamble>\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next &&\n     path(p[1..], graph))\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| &&\n  start == p[0] && end == p[|p|-1] &&\n  path(p, graph)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n  requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n  ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n  ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}\n\n// <vc-helpers>\nlemma NoZeroBetween(a: array<int>, i: int)\n  requires forall j :: 0 <= j < a.Length ==> 0 <= a[j]\n  requires forall j :: 0 < j < a.Length ==> a[j-1]-1 <= a[j]\n  requires 0 <= i < a.Length\n  requires a[i] > i\n  ensures forall k :: i < k < a.Length && k < a[i] ==> a[k] != 0\n{\n  if a[i] <= i + 1 {\n    return;\n  }\n  \n  var j := i + 1;\n  while j < a.Length && j < a[i]\n    invariant i < j <= a[i]\n    invariant j <= a.Length\n    invariant forall k :: i < k < j ==> a[k] != 0\n    invariant forall k :: i <= k < j ==> a[k] >= k\n  {\n    assert i < j;\n    assert a[i] >= i;\n    assert a[i] > i;\n    \n    if j > i + 1 {\n      var m := i;\n      while m < j - 1\n        invariant i <= m <= j - 1\n        invariant a[m] >= m\n      {\n        assert m + 1 < j;\n        assert 0 < m + 1 < a.Length;\n        assert a[m] - 1 <= a[m + 1];\n        assert a[m + 1] >= a[m] - 1 >= m - 1;\n        assert a[m + 1] >= m + 1 - 2;\n        m := m + 1;\n      }\n    }\n    \n    if j > 0 && j - 1 >= i {\n      assert a[j-1] >= j-1;\n    }\n    \n    if j < a.Length {\n      assert a[j] >= a[j-1] - 1;\n      assert a[j] >= (j-1) - 1;\n      assert a[j] >= j - 2;\n      \n      if a[j] == 0 {\n        assert 0 >= j - 2;\n        assert j <= 2;\n        assert j >= i + 1;\n        assert i <= 1;\n        \n        if i == 0 {\n          assert j == 1 || j == 2;\n          if j == 1 {\n            assert a[1] >= a[0] - 1 > 0 - 1;\n            assert false;\n          }\n        } else if i == 1 {\n          assert j == 2;\n          assert a[2] >= a[1] - 1 > 1 - 1;\n          assert false;\n        }\n      }\n    }\n    j := j + 1;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n  requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n  ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n  ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != 0\n  {\n    if a[i] == 0 {\n      return i;\n    } else if a[i] > i {\n      NoZeroBetween(a, i);\n      var next_i := a[i];\n      if next_i <= a.Length {\n        i := next_i;\n      } else {\n        i := i + 1;\n      }\n    } else {\n      i := i + 1;\n    }\n  }\n  return -1;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_quotient_Quotient.dfy", "root", true, "", "", false, "Clover_quotient_Quotient.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Quotient(x: nat, y:nat) returns (r:int, q:int)\n  requires y != 0\n  ensures q * y + r == x && 0 <= r < y && 0 <= q\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Quotient(x: nat, y:nat) returns (r:int, q:int)\n  requires y != 0\n  ensures q * y + r == x && 0 <= r < y && 0 <= q\n// </vc-spec>\n// <vc-code>\n{\n  q := 0;\n  r := x;\n  while r >= y\n    invariant q * y + r == x\n    invariant r >= 0\n    invariant q >= 0\n    decreases r\n  {\n    q := q + 1;\n    r := r - y;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent.dfy", "root", true, "", "", false, "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent.dfy", "// <vc-preamble>\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Tangent(r: array<int>, x: array<int>)\n  returns (found: bool)\n  requires forall i:: 1 <= i < x.Length ==> \n           x[i-1] < x[i]\n  requires forall i, j ::\n           0 <= i < j < x.Length ==>\n           x[i] < x[j]\n  ensures !found ==>\n          forall i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length ==>\n          r[i] != x[j]\n  ensures found ==>\n          exists i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length &&\n          r[i] == x[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma BinarySearchCorrectness(a: array<int>, target: int, result: int)\n  requires forall i :: 1 <= i < a.Length ==> a[i-1] < a[i]\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] < a[j]\n  requires 0 <= result <= a.Length\n  requires forall i :: 0 <= i < result ==> a[i] < target\n  requires forall i :: result <= i < a.Length ==> target <= a[i]\n  ensures result == a.Length || a[result] >= target\n  ensures result == 0 || a[result-1] < target\n{\n}\n\nlemma ArraySearchProperty(r: array<int>, x: array<int>, found: bool, witness_i: int, witness_j: int)\n  requires found ==> (0 <= witness_i < r.Length && 0 <= witness_j < x.Length && r[witness_i] == x[witness_j])\n  requires !found ==> forall i,j :: 0 <= i < r.Length && 0 <= j < x.Length ==> r[i] != x[j]\n  ensures found <==> exists i,j :: 0 <= i < r.Length && 0 <= j < x.Length && r[i] == x[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Tangent(r: array<int>, x: array<int>)\n  returns (found: bool)\n  requires forall i:: 1 <= i < x.Length ==> \n           x[i-1] < x[i]\n  requires forall i, j ::\n           0 <= i < j < x.Length ==>\n           x[i] < x[j]\n  ensures !found ==>\n          forall i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length ==>\n          r[i] != x[j]\n  ensures found ==>\n          exists i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length &&\n          r[i] == x[j]\n// </vc-spec>\n// <vc-code>\n{\n  found := false;\n  var i := 0;\n  \n  while i < r.Length && !found\n    invariant 0 <= i <= r.Length\n    invariant !found ==> forall k,j :: 0 <= k < i && 0 <= j < x.Length ==> r[k] != x[j]\n    invariant found ==> exists k,j :: 0 <= k < r.Length && 0 <= j < x.Length && r[k] == x[j]\n  {\n    var result := BinarySearch(x, r[i]);\n    \n    if result < x.Length && x[result] == r[i] {\n      found := true;\n    }\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch.dfy", "root", true, "", "", false, "Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch.dfy", "// <vc-preamble>\npredicate sorted(a: array?<int>, l: int, u: int)\n    reads a\n    requires a != null\n    {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array?<int>, key: int)\n    returns (index: int)\n    requires a != null && sorted(a,0,a.Length-1);\n    ensures index >= 0 ==> index < a.Length && a[index] == key;\n    ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(a: array?<int>, l: int, u: int)\n    reads a\n    requires a != null\n    {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n    }\n\n// <vc-helpers>\nlemma SortedProperty(a: array<int>, l: int, u: int, i: int, j: int)\n    requires sorted(a, l, u)\n    requires 0 <= l <= i <= j <= u < a.Length\n    ensures a[i] <= a[j]\n{\n    // This lemma is automatically proven by the definition of sorted\n}\n\nlemma SortedSubrange(a: array<int>, l: int, u: int, l': int, u': int)\n    requires sorted(a, l, u)\n    requires 0 <= l <= l' <= u' <= u < a.Length\n    ensures sorted(a, l', u')\n{\n    // This lemma is automatically proven by the definition of sorted\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array?<int>, key: int)\n    returns (index: int)\n    requires a != null && sorted(a,0,a.Length-1);\n    ensures index >= 0 ==> index < a.Length && a[index] == key;\n    ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 0 {\n        return -1;\n    }\n    \n    var low := 0;\n    var high := a.Length - 1;\n    \n    while low <= high\n        invariant 0 <= low <= a.Length\n        invariant -1 <= high < a.Length\n        invariant forall i :: 0 <= i < low ==> a[i] < key\n        invariant forall i :: high < i < a.Length ==> a[i] > key\n        decreases high - low\n    {\n        var mid := (low + high) / 2;\n        \n        if a[mid] == key {\n            return mid;\n        } else if a[mid] < key {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n    \n    return -1;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_477_ToLowercase.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_477_ToLowercase.dfy", "// <vc-preamble>\npredicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToLowercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}\n\n// <vc-helpers>\nlemma ShiftCorrectness(c: char)\n    requires IsUpperCase(c)\n    ensures IsUpperLowerPair(c, Shift32(c))\n{\n    assert 65 <= c as int <= 90;\n    assert c as int + 32 <= 122;\n    assert c as int + 32 < 128;\n    assert (c as int + 32) % 128 == c as int + 32;\n    assert Shift32(c) as int == c as int + 32;\n    assert IsUpperLowerPair(c, Shift32(c));\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToLowercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n    v := \"\";\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |v| == i\n        invariant forall j :: 0 <= j < i ==> if IsUpperCase(s[j]) then IsUpperLowerPair(s[j], v[j]) else v[j] == s[j]\n    {\n        if IsUpperCase(s[i]) {\n            ShiftCorrectness(s[i]);\n            v := v + [Shift32(s[i])];\n        } else {\n            v := v + [s[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum.dfy", "// <vc-preamble>\nfunction Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod segMaxSum(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum(v,k,i+1) &&  SumMaxToRight(v,i,s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\n//Now do the same but with a loop from right to left\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}\n\n// <vc-helpers>\nlemma SumEquivalence(v:array<int>, i:int, j:int)\nrequires 0<=i<=j<=v.Length\nensures Sum(v,i,j) == Sum2(v,i,j)\ndecreases j-i\n{\n    if i == j {\n        // Base case: both sums are 0\n    } else {\n        // Inductive case\n        SumEquivalence(v, i+1, j);\n        // Sum(v,i,j) = v[i] + Sum(v,i+1,j) = v[i] + Sum2(v,i+1,j) = Sum2(v,i,j)\n    }\n}\n\nlemma SumSingleElement(v:array<int>, i:int)\nrequires 0<=i<v.Length\nensures Sum(v,i,i+1) == v[i]\n{\n    // Sum(v,i,i+1) = Sum(v,i,i) + v[i] = 0 + v[i] = v[i]\n}\n\nlemma SumExtendLeft(v:array<int>, i:int, j:int)\nrequires 0<=i<j<=v.Length\nensures Sum(v,i,j) == v[i] + Sum(v,i+1,j)\n{\n    if i+1 == j {\n        SumSingleElement(v, i);\n    } else {\n        calc {\n            Sum(v,i,j);\n            Sum(v,i,j-1) + v[j-1];\n            { SumExtendLeft(v, i, j-1); }\n            v[i] + Sum(v,i+1,j-1) + v[j-1];\n            v[i] + (Sum(v,i+1,j-1) + v[j-1]);\n            v[i] + Sum(v,i+1,j);\n        }\n    }\n}\n\nlemma SumMonotonic(v:array<int>, i1:int, i2:int, j:int, maxSum:int)\nrequires 0<=i1<=i2<j<=v.Length\nrequires Sum(v,i2,j) <= maxSum\nrequires forall l::i1<=l<=i2-1 ==> v[l] >= 0\nensures Sum(v,i1,j) <= maxSum ==> true\ndecreases i2-i1\n{\n    if i1 == i2 {\n        // Base case\n    } else {\n        SumExtendLeft(v, i1, j);\n        SumMonotonic(v, i1+1, i2, j, maxSum);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod segMaxSum(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum(v,k,i+1) &&  SumMaxToRight(v,i,s)\n// </vc-spec>\n// <vc-code>\n{\n    s := v[i];\n    k := i;\n    var l := i;\n    \n    while l > 0\n    invariant 0 <= l <= i\n    invariant l <= k <= i\n    invariant s == Sum(v,k,i+1)\n    invariant forall m {:trigger Sum(v,m,i+1)} :: l <= m <= i ==> Sum(v,m,i+1) <= s\n    decreases l\n    {\n        l := l - 1;\n        var tempSum := Sum(v,l,i+1);\n        \n        assert tempSum == v[l] + Sum(v,l+1,i+1) by {\n            SumExtendLeft(v, l, i+1);\n        }\n        \n        if tempSum > s {\n            s := tempSum;\n            k := l;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_modify_2d_array_modify_array_element.dfy", "root", true, "", "", false, "Clover_modify_2d_array_modify_array_element.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall i: nat :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n  ensures forall i: nat, j: nat :: 0 <= i < arr.Length && 0 <= j < arr[i].Length && (i != index1 || j != index2) ==> arr[i][j] == old(arr[i][j])\n  ensures  arr[index1][index2] == val\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall i: nat :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n  ensures forall i: nat, j: nat :: 0 <= i < arr.Length && 0 <= j < arr[i].Length && (i != index1 || j != index2) ==> arr[i][j] == old(arr[i][j])\n  ensures  arr[index1][index2] == val\n// </vc-spec>\n// <vc-code>\n{\n  arr[index1][index2] := val;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mmaximum1(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Algorithm 1: From left to right return the first\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod mmaximum1(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  var j := 1;\n  while j < v.Length\n    invariant 0 <= i < v.Length\n    invariant 1 <= j <= v.Length\n    invariant forall k :: 0 <= k < j ==> v[i] >= v[k]\n  {\n    if v[j] > v[i] {\n      i := j;\n    }\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n//Algorithm 2: From right to left return the last\n\n\n\n\n//Algorithm : from left to right\n//Algorithm : from right to left", "", "", ""], ["Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring.dfy", "root", true, "", "", false, "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring.dfy", "// <vc-preamble>\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\nlemma isSubstringEquivalence(sub: string, str: string)\n    ensures isSubstringPred(sub, str) <==> !isNotSubstringPred(sub, str)\n{\n    if isSubstringPred(sub, str) {\n        var i :| 0 <= i <= |str| && isPrefixPred(sub, str[i..]);\n        assert !isNotPrefixPred(sub, str[i..]);\n        assert !isNotSubstringPred(sub, str);\n    } else {\n        assert forall i :: 0 <= i <= |str| ==> !isPrefixPred(sub, str[i..]);\n        assert forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub, str[i..]);\n        assert isNotSubstringPred(sub, str);\n    }\n}\n\nlemma haveCommonKSubstringEquivalence(k: nat, str1: string, str2: string)\n    ensures haveCommonKSubstringPred(k, str1, str2) <==> !haveNotCommonKSubstringPred(k, str1, str2)\n{\n    if haveCommonKSubstringPred(k, str1, str2) {\n        var i1, j1 :| 0 <= i1 <= |str1| - k && j1 == i1 + k && isSubstringPred(str1[i1..j1], str2);\n        assert !isNotSubstringPred(str1[i1..j1], str2) by {\n            isSubstringEquivalence(str1[i1..j1], str2);\n        }\n        assert !haveNotCommonKSubstringPred(k, str1, str2);\n    } else {\n        assert forall i1, j1 :: 0 <= i1 <= |str1| - k && j1 == i1 + k ==> !isSubstringPred(str1[i1..j1], str2);\n        forall i1, j1 | 0 <= i1 <= |str1| - k && j1 == i1 + k\n            ensures isNotSubstringPred(str1[i1..j1], str2)\n        {\n            isSubstringEquivalence(str1[i1..j1], str2);\n        }\n        assert haveNotCommonKSubstringPred(k, str1, str2);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>\n// <vc-code>\n{\n    if k == 0 {\n        found := true;\n        return;\n    }\n    \n    if |str1| < k {\n        found := false;\n        return;\n    }\n    \n    var i1 := 0;\n    found := false;\n    \n    while i1 <= |str1| - k && !found\n        decreases |str1| - k + 1 - i1\n        invariant 0 <= i1 <= |str1| - k + 1\n        invariant !found ==> forall idx {:trigger str1[idx..idx+k]} :: 0 <= idx < i1 ==> isNotSubstringPred(str1[idx..idx+k], str2)\n        invariant found ==> exists idx {:trigger str1[idx..idx+k]} :: 0 <= idx < i1 && isSubstringPred(str1[idx..idx+k], str2)\n    {\n        var substring := str1[i1..i1+k];\n        var isSubstr := isSubstring(substring, str2);\n        \n        if isSubstr {\n            found := true;\n            assert isSubstringPred(str1[i1..i1+k], str2);\n        } else {\n            assert isNotSubstringPred(str1[i1..i1+k], str2) by {\n                isSubstringEquivalence(str1[i1..i1+k], str2);\n            }\n        }\n        i1 := i1 + 1;\n    }\n    \n    if found {\n        var idx :| 0 <= idx < i1 && isSubstringPred(str1[idx..idx+k], str2);\n        assert haveCommonKSubstringPred(k, str1, str2);\n    } else {\n        assert i1 > |str1| - k;\n        assert forall idx {:trigger str1[idx..idx+k]} :: 0 <= idx <= |str1| - k ==> 0 <= idx < i1;\n        assert forall idx {:trigger str1[idx..idx+k]} :: 0 <= idx <= |str1| - k ==> isNotSubstringPred(str1[idx..idx+k], str2);\n        assert haveNotCommonKSubstringPred(k, str1, str2);\n        haveCommonKSubstringEquivalence(k, str1, str2);\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch.dfy", "// <vc-preamble>\nmethod PrintArray<A>(a: array?<A>)\n{\n  assume{:axiom} false;\n}\n\ntype lowercase = ch | 'a' <= ch <= 'z' witness 'd'\n\nmethod DiagMatrix<A>(rows: int, cols: int, zero: A, one: A)\n    returns (a: array2<A>)\n    requires rows >= 0 && cols >= 0\n{\n  assume{:axiom} false;\n}\n\nmethod PrintMatrix<A>(m: array2<A>)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod PrintArray<A>(a: array?<A>)\n{\n  assume{:axiom} false;\n}\n\n\ntype lowercase = ch | 'a' <= ch <= 'z' witness 'd'\n\n\n\nmethod DiagMatrix<A>(rows: int, cols: int, zero: A, one: A)\n    returns (a: array2<A>)\n    requires rows >= 0 && cols >= 0\n{\n  assume{:axiom} false;\n}\n\nmethod PrintMatrix<A>(m: array2<A>)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n// </vc-spec>\n// <vc-code>\n{\n  n := 0;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] != key\n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort.dfy", "root", true, "", "", false, "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n{\n  assume{:axiom} false;\n}\n\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MergeSort(a: array<int>) returns (b: array<int>)\n    ensures b.Length == a.Length && Sorted(b[..]) && multiset(a[..]) == multiset(b[..])\n    decreases a.Length\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n{\n  assume{:axiom} false;\n}\n\n\n//This is a method that replace the loop body\n\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.\n\n// <vc-helpers>\nlemma MultisetSliceProperty<T>(s: seq<T>, i: nat, j: nat)\n    requires i <= j <= |s|\n    ensures multiset(s[..i]) + multiset(s[i..j]) == multiset(s[..j])\n{\n    if i == j {\n        assert s[..i] == s[..j];\n        assert s[i..j] == [];\n        assert multiset(s[i..j]) == multiset{};\n    } else {\n        assert s[..j] == s[..i] + s[i..j];\n    }\n}\n\nlemma SortedConcatenation(s1: seq<int>, s2: seq<int>, x: int)\n    requires Sorted(s1) && Sorted(s2) && |s1| > 0 && |s2| > 0\n    requires s1[|s1|-1] <= x <= s2[0]\n    ensures Sorted(s1 + [x] + s2)\n{\n}\n\nlemma MultisetPreservation<T>(a: seq<T>, left: seq<T>, right: seq<T>, mid: nat)\n    requires mid <= |a|\n    requires left == a[..mid]\n    requires right == a[mid..]\n    ensures multiset(a[..]) == multiset(left) + multiset(right)\n{\n    assert a[..] == a[..mid] + a[mid..];\n    assert a[..] == left + right;\n}\n\nlemma PointwiseToSliceEquality<T>(arr: array<T>, s: seq<T>, n: nat)\n    requires n <= arr.Length\n    requires n == |s|\n    requires forall k :: 0 <= k < n ==> arr[k] == s[k]\n    ensures arr[..n] == s\n{\n}\n\nlemma ArraySliceEquality<T>(arr: array<T>, s: seq<T>)\n    requires arr.Length == |s|\n    requires forall k :: 0 <= k < arr.Length ==> arr[k] == s[k]\n    ensures arr[..] == s\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MergeSort(a: array<int>) returns (b: array<int>)\n    ensures b.Length == a.Length && Sorted(b[..]) && multiset(a[..]) == multiset(b[..])\n    decreases a.Length\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length <= 1 {\n        b := new int[a.Length];\n        if a.Length == 1 {\n            b[0] := a[0];\n        }\n        return;\n    }\n    \n    var mid := a.Length / 2;\n    var left := new int[mid];\n    var right := new int[a.Length - mid];\n    \n    var i := 0;\n    while i < mid\n        invariant 0 <= i <= mid\n        invariant forall k :: 0 <= k < i ==> left[k] == a[k]\n    {\n        left[i] := a[i];\n        i := i + 1;\n    }\n    \n    assert forall k :: 0 <= k < mid ==> left[k] == a[k];\n    assert left.Length == mid;\n    assert |a[..mid]| == mid;\n    ArraySliceEquality(left, a[..mid]);\n    \n    i := 0;\n    while i < a.Length - mid\n        invariant 0 <= i <= a.Length - mid\n        invariant forall k :: 0 <= k < i ==> right[k] == a[mid + k]\n    {\n        right[i] := a[mid + i];\n        i := i + 1;\n    }\n    \n    assert forall k :: 0 <= k < a.Length - mid ==> right[k] == a[mid + k];\n    assert right.Length == a.Length - mid;\n    assert |a[mid..]| == a.Length - mid;\n    ArraySliceEquality(right, a[mid..]);\n    \n    assert left[..] == a[..mid];\n    assert right[..] == a[mid..];\n    MultisetPreservation(a[..], left[..], right[..], mid);\n    assert multiset(a[..]) == multiset(left[..]) + multiset(right[..]);\n    \n    var sortedLeft := MergeSort(left);\n    var sortedRight := MergeSort(right);\n    \n    assert multiset(sortedLeft[..]) == multiset(left[..]);\n    assert multiset(sortedRight[..]) == multiset(right[..]);\n    assert multiset(a[..]) == multiset(sortedLeft[..]) + multiset(sortedRight[..]);\n    \n    b := new int[a.Length];\n    Merge(b, sortedLeft, sortedRight);\n    \n    assert multiset(b[..]) == multiset(sortedLeft[..]) + multiset(sortedRight[..]);\n    assert multiset(b[..]) == multiset(a[..]);\n}\n// </vc-code>\n\n", "", "", ""], ["Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod.dfy", "root", true, "", "", false, "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod.dfy", "// <vc-preamble>\nghost function f(n: nat): nat {\n    if n == 0 then 1 \n    else if n%2 == 0 then 1 + 2*f(n/2)\n    else 2*f(n/2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mod(n:nat) returns (a:nat) \nensures a == f(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function f(n: nat): nat {\n    if n == 0 then 1 \n    else if n%2 == 0 then 1 + 2*f(n/2)\n    else 2*f(n/2)\n}\n\n// <vc-helpers>\nlemma f_positive(n: nat)\nensures f(n) > 0\n{\n    if n == 0 {\n    } else if n % 2 == 0 {\n        f_positive(n/2);\n    } else {\n        f_positive(n/2);\n    }\n}\n\nlemma f_even_decomp(n: nat)\nrequires n > 0 && n % 2 == 0\nensures f(n) == 1 + 2 * f(n/2)\n{\n}\n\nlemma f_odd_decomp(n: nat) \nrequires n > 0 && n % 2 == 1\nensures f(n) == 2 * f(n/2)\n{\n}\n\nlemma f_bounds(n: nat)\nensures f(n) >= 1\n{\n    f_positive(n);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mod(n:nat) returns (a:nat) \nensures a == f(n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        return 1;\n    }\n    \n    var result := 0;\n    var current := n;\n    var power := 1;\n    \n    while current > 0\n    invariant current >= 0\n    invariant result + power * f(current) == f(n)\n    invariant power > 0\n    invariant result >= 0\n    decreases current\n    {\n        if current % 2 == 0 {\n            result := result + power;\n            power := power * 2;\n            current := current / 2;\n        } else {\n            power := power * 2;\n            current := current / 2;\n        }\n    }\n    \n    // When current == 0, we have result + power * f(0) == f(n)\n    // Since f(0) == 1, we have result + power == f(n)\n    result := result + power;\n    \n    return result;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_Percentile.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_Percentile.dfy", "// <vc-preamble>\nfunction SumUpto(A: array<real>, end: int): real\n  requires -1 <= end < A.Length\n  reads A\n{\n  if end == -1 then\n    0.0\n  else\n    A[end] + SumUpto(A, end-1)\n}\n\nfunction Sum(A: array<real>): real\n  reads A\n{\n  SumUpto(A, A.Length-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Percentile(p: real, A: array<real>, total: real) returns (i: int)\n  requires forall i | 0 <= i < A.Length :: A[i] > 0.0\n  requires 0.0 <= p <= 100.0\n  requires total == Sum(A)\n  requires total > 0.0\n  ensures -1 <= i < A.Length\n  ensures SumUpto(A, i) <= (p/100.0) * total\n  ensures i+1 < A.Length ==> SumUpto(A, i+1) > (p/100.0) * total\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort.dfy", "// <vc-preamble>\npredicate IsSorted( s: seq<int> )\n{\n    forall p,q | 0<=p<q<|s| :: s[p]<=s[q]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertionSort( s: seq<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == multiset(s);\n    ensures IsSorted(r);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Insertion sort.\n//\n// Author: Snorri Agnarsson, snorri@hi.is\n\n\npredicate IsSorted( s: seq<int> )\n{\n    forall p,q | 0<=p<q<|s| :: s[p]<=s[q]\n}\n\n// <vc-helpers>\nlemma InsertPreservesMultiset(s: seq<int>, x: int, pos: int)\n    requires 0 <= pos <= |s|\n    ensures multiset(s[..pos] + [x] + s[pos..]) == multiset(s) + multiset{x}\n{\n    assert s[..pos] + s[pos..] == s;\n    assert multiset(s[..pos] + s[pos..]) == multiset(s);\n    assert multiset(s[..pos] + [x] + s[pos..]) == multiset(s[..pos]) + multiset([x]) + multiset(s[pos..]);\n    assert multiset([x]) == multiset{x};\n}\n\nlemma InsertMaintainsSorted(s: seq<int>, x: int, pos: int)\n    requires IsSorted(s)\n    requires 0 <= pos <= |s|\n    requires forall i | 0 <= i < pos :: s[i] <= x\n    requires forall i | pos <= i < |s| :: x <= s[i]\n    ensures IsSorted(s[..pos] + [x] + s[pos..])\n{\n    var result := s[..pos] + [x] + s[pos..];\n    forall p, q | 0 <= p < q < |result|\n        ensures result[p] <= result[q]\n    {\n        if p < pos && q == pos {\n            assert result[p] == s[p];\n            assert result[q] == x;\n            assert s[p] <= x;\n        } else if p == pos && q > pos {\n            assert result[p] == x;\n            assert result[q] == s[q-1];\n            assert x <= s[q-1];\n        } else if p < pos && q > pos {\n            assert result[p] == s[p];\n            assert result[q] == s[q-1];\n            assert s[p] <= x <= s[q-1];\n        } else if p < pos && q < pos {\n            assert result[p] == s[p];\n            assert result[q] == s[q];\n            assert s[p] <= s[q];\n        } else if p > pos && q > pos {\n            assert result[p] == s[p-1];\n            assert result[q] == s[q-1];\n            assert s[p-1] <= s[q-1];\n        }\n    }\n}\n\nmethod FindInsertPosition(s: seq<int>, x: int) returns (pos: int)\n    requires IsSorted(s)\n    ensures 0 <= pos <= |s|\n    ensures forall i | 0 <= i < pos :: s[i] <= x\n    ensures forall i | pos <= i < |s| :: x <= s[i]\n{\n    pos := 0;\n    while pos < |s| && s[pos] <= x\n        invariant 0 <= pos <= |s|\n        invariant forall i | 0 <= i < pos :: s[i] <= x\n    {\n        pos := pos + 1;\n    }\n}\n\nlemma MultisetSubsequence(s: seq<int>, i: int)\n    requires 0 <= i < |s|\n    ensures multiset(s[..i]) + multiset{s[i]} == multiset(s[..i+1])\n{\n    assert s[..i+1] == s[..i] + [s[i]];\n    assert multiset(s[..i] + [s[i]]) == multiset(s[..i]) + multiset([s[i]]);\n    assert multiset([s[i]]) == multiset{s[i]};\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertionSort( s: seq<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == multiset(s);\n    ensures IsSorted(r);\n// </vc-spec>\n// <vc-code>\n{\n    r := [];\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant multiset(r) == multiset(s[..i])\n        invariant IsSorted(r)\n    {\n        var pos := FindInsertPosition(r, s[i]);\n        InsertPreservesMultiset(r, s[i], pos);\n        InsertMaintainsSorted(r, s[i], pos);\n        var old_r := r;\n        r := r[..pos] + [s[i]] + r[pos..];\n        \n        assert multiset(r) == multiset(old_r) + multiset{s[i]};\n        assert multiset(old_r) == multiset(s[..i]);\n        MultisetSubsequence(s, i);\n        assert multiset(s[..i]) + multiset{s[i]} == multiset(s[..i+1]);\n        assert multiset(r) == multiset(s[..i+1]);\n        \n        i := i + 1;\n    }\n    assert i == |s|;\n    assert s[..|s|] == s;\n    assert multiset(r) == multiset(s[..i]) == multiset(s[..|s|]) == multiset(s);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_selectionsort_SelectionSort.dfy", "root", true, "", "", false, "Clover_selectionsort_SelectionSort.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma MultisetPreservation(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  ensures multiset(a[..][i := a[j]][j := a[i]]) == multiset(a[..])\n{\n  var original := a[..];\n  var swapped := original[i := a[j]][j := a[i]];\n  \n  if i == j {\n    assert swapped == original;\n  } else {\n    assert multiset(swapped) == multiset(original);\n  }\n}\n\nlemma SortedPrefix(a: array<int>, k: int)\n  requires 0 <= k <= a.Length\n  requires forall i,j :: 0 <= i < j < k ==> a[i] <= a[j]\n  requires forall i,j :: 0 <= i < k && k <= j < a.Length ==> a[i] <= a[j]\n  ensures forall i,j :: 0 <= i < j < a.Length && j < k ==> a[i] <= a[j]\n{}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var n := a.Length;\n  var i := 0;\n  \n  while i < n\n    invariant 0 <= i <= n\n    invariant forall x,y :: 0 <= x < y < i ==> a[x] <= a[y]\n    invariant forall x,y :: 0 <= x < i && i <= y < n ==> a[x] <= a[y]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var minIndex := i;\n    var j := i + 1;\n    \n    while j < n\n      invariant i <= minIndex < n\n      invariant i <= j <= n\n      invariant forall k :: i <= k < j ==> a[minIndex] <= a[k]\n      invariant multiset(a[..]) == old(multiset(a[..]))\n    {\n      if a[j] < a[minIndex] {\n        minIndex := j;\n      }\n      j := j + 1;\n    }\n    \n    if minIndex != i {\n      MultisetPreservation(a, i, minIndex);\n      var temp := a[i];\n      a[i] := a[minIndex];\n      a[minIndex] := temp;\n    }\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_array_concat_concat.dfy", "root", true, "", "", false, "Clover_array_concat_concat.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length + b.Length];\n  \n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> c[k] == a[k]\n  {\n    c[i] := a[i];\n    i := i + 1;\n  }\n  \n  var j := 0;\n  while j < b.Length\n    invariant 0 <= j <= b.Length\n    invariant forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n    invariant forall k :: 0 <= k < j ==> c[k + a.Length] == b[k]\n  {\n    c[j + a.Length] := b[j];\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_69_ContainsSequence.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_69_ContainsSequence.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ContainsSequence(list: seq<seq<int>>, sub: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |list| && sub == list[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ContainsSequence(list: seq<seq<int>>, sub: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |list| && sub == list[i])\n// </vc-spec>\n// <vc-code>\n{\n  result := false;\n  var i := 0;\n  while i < |list|\n    invariant 0 <= i <= |list|\n    invariant result <==> (exists j :: 0 <= j < i && sub == list[j])\n  {\n    if sub == list[i] {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ZapNegatives(a: array<int>) \nmodifies a\nensures forall i :: 0 <= i < a.Length ==> if old(a[i]) < 0 then a[i] == 0 \n                                            else a[i] == old(a[i])\nensures a.Length == old(a).Length\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ZapNegatives(a: array<int>) \nmodifies a\nensures forall i :: 0 <= i < a.Length ==> if old(a[i]) < 0 then a[i] == 0 \n                                            else a[i] == old(a[i])\nensures a.Length == old(a).Length\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> if old(a[j]) < 0 then a[j] == 0 else a[j] == old(a[j])\n    invariant forall j :: i <= j < a.Length ==> a[j] == old(a[j])\n  {\n    if a[i] < 0 {\n      a[i] := 0;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_632_swap.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_632_swap.dfy", "// <vc-preamble>\nfunction count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n// </vc-spec>\n// <vc-code>\n{\n    var temp := arr[i];\n    arr[i] := arr[j];\n    arr[j] := temp;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select.dfy", "// <vc-preamble>\ntype T\nfunction f(a: T) : bool\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Select(s1: seq<T>) returns (r: seq<T>)\n  ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])\n  ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])\n\nmethod Main(s1: seq<T>)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\ntype T\nfunction f(a: T) : bool\n\n// <vc-helpers>\nlemma FilterPreservesMultiset(s: seq<T>, r: seq<T>)\n  requires r == FilterSeq(s)\n  ensures forall e: T :: f(e) ==> multiset(s)[e] == multiset(r)[e]\n  ensures forall e: T :: !f(e) ==> multiset(r)[e] == 0\n{\n  if |s| == 0 {\n    assert r == [];\n  } else {\n    var head := s[0];\n    var tail := s[1..];\n    var filteredTail := FilterSeq(tail);\n    \n    if f(head) {\n      assert r == [head] + filteredTail;\n      FilterPreservesMultiset(tail, filteredTail);\n    } else {\n      assert r == filteredTail;\n      FilterPreservesMultiset(tail, filteredTail);\n    }\n  }\n}\n\nfunction FilterSeq(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else if f(s[0]) then [s[0]] + FilterSeq(s[1..])\n  else FilterSeq(s[1..])\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Select(s1: seq<T>) returns (r: seq<T>)\n  ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])\n  ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])\n\nmethod Main(s1: seq<T>)\n// </vc-spec>\n// <vc-code>\n{\n  var result := FilterSeq(s1);\n  FilterPreservesMultiset(s1, result);\n  return result;\n}\n// </vc-code>\n\n", "", "", ""], ["dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome.dfy", "root", true, "", "", false, "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome.dfy", "// <vc-preamble>\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)\n    && i + j == i0 + j0\n    :: j - i <= hi - lo\n{\n  assume{:axiom} false;\n}\n\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestPalindrome(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]\n  ensures palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)  // Among all palindromes\n    && i + j == i0 + j0                                             // sharing the same center,\n    :: j - i <= hi - lo                                             // `s[lo..hi]` is longest.\n{\n  assume{:axiom} false;\n}\n\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.\n\n// <vc-helpers>\nlemma palindromic_single_char(s: string, i: int)\n  requires 0 <= i < |s|\n  ensures palindromic(s, i, i+1)\n{\n}\n\nlemma palindromic_empty(s: string, i: int)\n  requires 0 <= i <= |s|\n  ensures palindromic(s, i, i)\n{\n}\n\nlemma palindromic_substring_property(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  requires palindromic(s, i, j)\n  ensures s[i..j] == s[i..j]\n{\n}\n\nlemma center_covers_all_palindromes(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  ensures exists c | 0 <= c < 2 * |s| - 1 :: i + j == c\n{\n  var c := i + j;\n  assert c == i + j;\n  assert 0 <= i + j <= 2 * |s|;\n  if i + j < 2 * |s| - 1 {\n    assert 0 <= c < 2 * |s| - 1;\n  } else {\n    assert i + j >= 2 * |s| - 1;\n    assert i <= |s| && j <= |s|;\n    assert i + j <= 2 * |s|;\n    assert i + j == 2 * |s| || i + j == 2 * |s| - 1;\n    if i + j == 2 * |s| {\n      assert i == |s| && j == |s|;\n      assert i == j;\n      var c' := 2 * |s| - 2;\n      assert 0 <= c' < 2 * |s| - 1;\n      assert i + j - 1 == c';\n    } else {\n      var c' := 2 * |s| - 2;\n      assert 0 <= c' < 2 * |s| - 1;\n      assert i + j == c';\n    }\n  }\n}\n\nlemma all_palindromes_have_centers(s: string)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: \n    exists c | 0 <= c < 2 * |s| - 1 :: i + j == c\n{\n  forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)\n    ensures exists c {:trigger i + j} | 0 <= c < 2 * |s| - 1 :: i + j == c\n  {\n    center_covers_all_palindromes(s, i, j);\n  }\n}\n\nlemma center_invariant_maintained(s: string, center: int, best_lo: int, best_hi: int, lo: int, hi: int)\n  requires 0 <= center < 2 * |s| - 1\n  requires 0 <= best_lo <= best_hi <= |s|\n  requires 0 <= lo <= hi <= |s|\n  requires palindromic(s, lo, hi)\n  requires forall c | 0 <= c < center ::\n    (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == c :: j - i <= best_hi - best_lo)\n  requires forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == center :: j - i <= hi - lo\n  ensures forall c | 0 <= c < center + 1 ::\n    (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == c :: \n      j - i <= (if hi - lo > best_hi - best_lo then hi - lo else best_hi - best_lo))\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod longestPalindrome(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]  // `ans` is indeed a substring in `s`\n  ensures palindromic(s, lo, hi)  // `ans` is palindromic\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo  // `ans` is longest\n// </vc-spec>\n// <vc-code>\n{\n  if |s| == 0 {\n    return \"\", 0, 0;\n  }\n  \n  var best_lo := 0;\n  var best_hi := 1;\n  palindromic_single_char(s, 0);\n  \n  // Check all possible centers\n  var center := 0;\n  while center < 2 * |s| - 1\n    invariant 0 <= center <= 2 * |s| - 1\n    invariant 0 <= best_lo <= best_hi <= |s|\n    invariant palindromic(s, best_lo, best_hi)\n    invariant forall c {:trigger c} | 0 <= c < center ::\n      (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == c :: j - i <= best_hi - best_lo)\n  {\n    var i0, j0;\n    \n    if center % 2 == 0 {\n      // Odd-length palindromes (center on character)\n      var char_idx := center / 2;\n      i0 := char_idx;\n      j0 := char_idx + 1;\n      palindromic_single_char(s, char_idx);\n    } else {\n      // Even-length palindromes (center between characters)\n      var char_idx := center / 2;\n      i0 := char_idx + 1;\n      j0 := char_idx + 1;\n      palindromic_empty(s, char_idx + 1);\n    }\n    \n    var lo, hi := expand_from_center(s, i0, j0);\n    \n    assert i0 + j0 == center;\n    \n    center_invariant_maintained(s, center, best_lo, best_hi, lo, hi);\n    \n    if hi - lo > best_hi - best_lo {\n      best_lo := lo;\n      best_hi := hi;\n    }\n    \n    center := center + 1;\n  }\n  \n  // Prove final postcondition\n  all_palindromes_have_centers(s);\n  \n  return s[best_lo..best_hi], best_lo, best_hi;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc.dfy", "root", true, "", "", false, "Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc.dfy", "// <vc-preamble>\nfunction gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdCalc(m: nat, n: nat) returns (res: nat)\nrequires m>0 && n>0;\nensures res == gcd(m,n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod gcdCalc(m: nat, n: nat) returns (res: nat)\nrequires m>0 && n>0;\nensures res == gcd(m,n);\n// </vc-spec>\n// <vc-code>\n{\n    var a := m;\n    var b := n;\n    while a != b\n    invariant a > 0 && b > 0\n    invariant gcd(a, b) == gcd(m, n)\n    decreases a + b\n    {\n        if a > b {\n            a := a - b;\n        } else {\n            b := b - a;\n        }\n    }\n    res := a;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_triple4_Triple.dfy", "root", true, "", "", false, "Clover_triple4_Triple.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  r := 3 * x;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort.dfy", "root", true, "", "", false, "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort.dfy", "// <vc-preamble>\ntwostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "twostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}\n\n// <vc-helpers>\nlemma PreservedCombine(a: array<int>, left: nat, mid: nat, right: nat)\n    requires left <= mid <= right <= a.Length\n    ensures (multiset(a[left..mid]) == multiset(old(a[left..mid])) && \n             multiset(a[mid..right]) == multiset(old(a[mid..right]))) ==>\n            multiset(a[left..right]) == multiset(old(a[left..right]))\n{\n    if multiset(a[left..mid]) == multiset(old(a[left..mid])) && \n       multiset(a[mid..right]) == multiset(old(a[mid..right])) {\n        assert a[left..right] == a[left..mid] + a[mid..right];\n        assert old(a[left..right]) == old(a[left..mid]) + old(a[mid..right]);\n    }\n}\n\nlemma PreservedSwapProperty(old_seq: seq<int>, new_seq: seq<int>, i: nat, j: nat)\n    requires |old_seq| == |new_seq|\n    requires i < |old_seq| && j < |old_seq|\n    requires forall k :: 0 <= k < |old_seq| && k != i && k != j ==> old_seq[k] == new_seq[k]\n    requires new_seq[i] == old_seq[j]\n    requires new_seq[j] == old_seq[i]\n    ensures multiset(old_seq) == multiset(new_seq)\n{\n}\n\nlemma OrderedExtend(a: array<int>, left: nat, right: nat, minVal: int)\n    requires left < right <= a.Length\n    requires Ordered(a, left+1, right)\n    requires a[left] == minVal\n    requires forall k :: left < k < right ==> minVal <= a[k]\n    ensures Ordered(a, left, right)\n{\n    forall i: nat | left < i < right\n        ensures a[i-1] <= a[i]\n    {\n        if i == left + 1 {\n            assert a[left] == minVal;\n            assert minVal <= a[i];\n            assert a[i-1] <= a[i];\n        } else {\n            assert left + 1 < i < right;\n            assert Ordered(a, left+1, right);\n            assert a[i-1] <= a[i];\n        }\n    }\n}\n\nghost predicate PreservedRange(a: array<int>, left: nat, right: nat, old_a: seq<int>)\n    reads a\n    requires left <= right <= a.Length\n    requires |old_a| == a.Length\n{\n    multiset(a[left..right]) == multiset(old_a[left..right])\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>\n// <vc-code>\n{\n    var n := a.Length;\n    var i := 0;\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant Ordered(a, 0, i)\n        invariant Preserved(a, 0, n)\n        invariant forall p, q :: 0 <= p < i <= q < n ==> a[p] <= a[q]\n    {\n        var minIndex := i;\n        var j := i + 1;\n        \n        while j < n\n            invariant i < j <= n\n            invariant i <= minIndex < j\n            invariant forall k :: i <= k < j ==> a[minIndex] <= a[k]\n            invariant Preserved(a, 0, n)\n        {\n            if a[j] < a[minIndex] {\n                minIndex := j;\n            }\n            j := j + 1;\n        }\n        \n        if minIndex != i {\n            var temp := a[i];\n            a[i] := a[minIndex];\n            a[minIndex] := temp;\n        }\n        \n        assert forall k :: i < k < n ==> a[i] <= a[k];\n        \n        if i + 1 <= n {\n            if i + 1 < n {\n                assert Ordered(a, i+1, i+1);\n                OrderedExtend(a, i, i+1, a[i]);\n            }\n            assert Ordered(a, 0, i+1);\n        }\n        \n        i := i + 1;\n    }\n    \n    assert i == n;\n    assert Ordered(a, 0, n);\n    assert Preserved(a, 0, n);\n}\n// </vc-code>\n\n", "", "", ""], ["MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC.dfy", "root", true, "", "", false, "MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC.dfy", "// <vc-preamble>\nfunction C(n: nat): nat \n    decreases n\n{\n    if n == 0 then 1 else (4 * n - 2) * C(n-1) / (n + 1) \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod calcC(n: nat) returns (res: nat)\n    ensures res == C(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function C(n: nat): nat \n    decreases n\n{\n    if n == 0 then 1 else (4 * n - 2) * C(n-1) / (n + 1) \n}\n\n// <vc-helpers>\nlemma CPositive(n: nat)\n    ensures C(n) > 0\n{\n    if n == 0 {\n        assert C(0) == 1;\n    } else {\n        CPositive(n-1);\n        assert C(n-1) > 0;\n        assert C(n) == (4 * n - 2) * C(n-1) / (n + 1);\n        assert 4 * n - 2 > 0;\n        assert n + 1 > 0;\n    }\n}\n\nlemma CDivisibility(n: nat)\n    requires n > 0\n    ensures (4 * n - 2) * C(n-1) % (n + 1) == 0\n    decreases n\n{\n    if n == 1 {\n        assert C(0) == 1;\n        assert (4 * 1 - 2) * C(0) == 2;\n        assert 2 % 2 == 0;\n    } else {\n        CatalansAreDivisible(n);\n    }\n}\n\nlemma CatalansAreDivisible(n: nat)\n    requires n >= 2\n    ensures (4 * n - 2) * C(n-1) % (n + 1) == 0\n    decreases n\n{\n    if n == 2 {\n        assert C(1) == 1;\n        assert (4 * 2 - 2) * C(1) == 6;\n        assert 6 % 3 == 0;\n    } else if n == 3 {\n        assert C(2) == 2;\n        assert (4 * 3 - 2) * C(2) == 20;\n        assert 20 % 4 == 0;\n    } else {\n        CDivisibility(n-1);\n        var k := (4 * (n-1) - 2) * C(n-2) / n;\n        assert C(n-1) == k;\n        assert (4 * n - 2) * k % (n + 1) == 0 by {\n            ModularArithmetic(n, k);\n        }\n    }\n}\n\nlemma BinomialDivisibility(n: nat, k: nat)\n    requires n >= 2\n    ensures 2 * (2 * n - 1) * k % (n + 1) == 0\n{\n    ModularArithmetic(n, k);\n}\n\nlemma ModularArithmetic(n: nat, k: nat)\n    requires n >= 2\n    ensures 2 * (2 * n - 1) * k % (n + 1) == 0\n{\n    if n == 2 {\n        assert 2 * (2 * 2 - 1) == 6;\n        assert 6 % 3 == 0;\n    } else if n == 3 {\n        assert 2 * (2 * 3 - 1) == 10;\n        assert 10 == 2 * 4 + 2;\n        assert 10 % 4 == 2;\n        assert (10 * k) % 4 == (2 * k) % 4;\n    } else {\n        assert 2 * (2 * n - 1) == 4 * n - 2;\n        DivisibilityByInduction(n);\n    }\n}\n\nlemma DivisibilityByInduction(n: nat)\n    requires n >= 2\n    ensures {:trigger 4 * n - 2} exists m: int :: 2 * (2 * n - 1) == m * (n + 1)\n{\n    assert 2 * (2 * n - 1) == 4 * n - 2;\n    var m := 4 - 6 / (n + 1);\n    if n >= 2 {\n        calc {\n            4 * n - 2;\n            == 4 * (n + 1) - 6;\n        }\n        assert 4 * n - 2 == 4 * (n + 1) - 6;\n    }\n}\n\nlemma SmallCaseDivisibility(n: nat)\n    requires 2 <= n < 5\n    ensures {:trigger 4 * n - 2} exists m: int :: 4 * n - 2 == m * (n + 1)\n{\n    if n == 2 {\n        assert 4 * 2 - 2 == 6;\n        assert 2 + 1 == 3;\n        assert 6 == 2 * 3;\n        var m := 2;\n        assert 4 * n - 2 == m * (n + 1);\n    } else if n == 3 {\n        assert 4 * 3 - 2 == 10;\n        assert 3 + 1 == 4;\n        var m := 2;\n        assert 4 * 3 - 2 == 10;\n        assert 2 * 4 + 2 == 10;\n    } else if n == 4 {\n        assert 4 * 4 - 2 == 14;\n        assert 4 + 1 == 5;\n        var m := 2;\n        assert 2 * 5 + 4 == 14;\n    }\n}\n\nlemma CatalanSpecialCase3()\n    ensures (4 * 3 - 2) * C(2) % 4 == 0\n{\n    assert C(0) == 1;\n    assert C(1) == 2 * 1 / 2 == 1;\n    assert C(2) == 6 * 1 / 3 == 2;\n    assert (4 * 3 - 2) * C(2) == 10 * 2 == 20;\n    assert 20 % 4 == 0;\n}\n\nlemma CatalanSpecialCase4()\n    ensures (4 * 4 - 2) * C(3) % 5 == 0\n{\n    assert C(3) == 10 * 2 / 4 == 5;\n    assert (4 * 4 - 2) * C(3) == 14 * 5 == 70;\n    assert 70 % 5 == 0;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod calcC(n: nat) returns (res: nat)\n    ensures res == C(n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        res := 1;\n    } else {\n        var prev := calcC(n-1);\n        CPositive(n-1);\n        CDivisibility(n);\n        res := (4 * n - 2) * prev / (n + 1);\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount.dfy", "root", true, "", "", false, "assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount.dfy", "// <vc-preamble>\nfunction RecursivePositiveProduct(q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 1\n    else if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n    else q[0] * RecursivePositiveProduct(q[1..])\n}\n\nfunction RecursiveCount(key: int, q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 0\n    else if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])\n    else RecursiveCount(key, q[..|q|-1])\n}\n\nfunction county(elem: int, key: int): int{\n    if elem==key then 1 else 0\n}\n\nfunction prody(elem: int): int{\n    if elem <= 0 then 1 else elem\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ProdAndCount(q: seq<int>, key: int) returns (prod: int, count: nat)\n    ensures prod == RecursivePositiveProduct(q)\n    ensures count == RecursiveCount(key, q)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function RecursivePositiveProduct(q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 1\n    else if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n    else q[0] * RecursivePositiveProduct(q[1..])\n}\n\nfunction RecursiveCount(key: int, q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 0\n    else if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])\n    else RecursiveCount(key, q[..|q|-1])\n}\n\nfunction county(elem: int, key: int): int{\n    if elem==key then 1 else 0\n}\n\nfunction prody(elem: int): int{\n    if elem <= 0 then 1 else elem\n}\n\n// <vc-helpers>\nlemma RecursivePositiveProductFoldRight(q: seq<int>)\n    ensures RecursivePositiveProduct(q) == FoldRightInt(prody, q, 1)\n    decreases |q|\n{\n    if q == [] {\n        assert RecursivePositiveProduct(q) == 1;\n        assert FoldRightInt(prody, q, 1) == 1;\n    } else {\n        RecursivePositiveProductFoldRight(q[1..]);\n        if q[0] <= 0 {\n            assert RecursivePositiveProduct(q) == RecursivePositiveProduct(q[1..]);\n            assert prody(q[0]) == 1;\n            assert FoldRightInt(prody, q, 1) == prody(q[0]) * FoldRightInt(prody, q[1..], 1);\n            assert FoldRightInt(prody, q, 1) == 1 * FoldRightInt(prody, q[1..], 1);\n            assert FoldRightInt(prody, q, 1) == FoldRightInt(prody, q[1..], 1);\n        } else {\n            assert RecursivePositiveProduct(q) == q[0] * RecursivePositiveProduct(q[1..]);\n            assert prody(q[0]) == q[0];\n            assert FoldRightInt(prody, q, 1) == prody(q[0]) * FoldRightInt(prody, q[1..], 1);\n            assert FoldRightInt(prody, q, 1) == q[0] * FoldRightInt(prody, q[1..], 1);\n        }\n    }\n}\n\nfunction FoldLeftIntCount(f: int -> int, xs: seq<int>, init: int): int\n    decreases |xs|\n{\n    if xs == [] then init\n    else FoldLeftIntCount(f, xs[..|xs|-1], init) + f(xs[|xs|-1])\n}\n\nlemma RecursiveCountFoldLeft(key: int, q: seq<int>)\n    ensures RecursiveCount(key, q) == FoldLeftIntCount((elem: int) => county(elem, key), q, 0)\n    decreases |q|\n{\n    if q == [] {\n        assert RecursiveCount(key, q) == 0;\n        assert FoldLeftIntCount((elem: int) => county(elem, key), q, 0) == 0;\n    } else {\n        RecursiveCountFoldLeft(key, q[..|q|-1]);\n        if q[|q|-1] == key {\n            assert RecursiveCount(key, q) == 1 + RecursiveCount(key, q[..|q|-1]);\n            assert county(q[|q|-1], key) == 1;\n            assert FoldLeftIntCount((elem: int) => county(elem, key), q, 0) == \n                   FoldLeftIntCount((elem: int) => county(elem, key), q[..|q|-1], 0) + county(q[|q|-1], key);\n        } else {\n            assert RecursiveCount(key, q) == RecursiveCount(key, q[..|q|-1]);\n            assert county(q[|q|-1], key) == 0;\n            assert FoldLeftIntCount((elem: int) => county(elem, key), q, 0) == \n                   FoldLeftIntCount((elem: int) => county(elem, key), q[..|q|-1], 0) + county(q[|q|-1], key);\n        }\n    }\n}\n\nlemma RecursiveCountFoldLeftOriginal(key: int, q: seq<int>)\n    ensures RecursiveCount(key, q) == FoldLeftInt((elem: int) => county(elem, key), q, 0)\n{\n    RecursiveCountFoldLeft(key, q);\n    FoldLeftEquivalence((elem: int) => county(elem, key), q, 0);\n}\n\nlemma FoldLeftEquivalence(f: int -> int, xs: seq<int>, init: int)\n    ensures FoldLeftInt(f, xs, init) == FoldLeftIntCount(f, xs, init)\n    decreases |xs|\n{\n    if xs == [] {\n        assert FoldLeftInt(f, xs, init) == init;\n        assert FoldLeftIntCount(f, xs, init) == init;\n    } else {\n        assert FoldLeftInt(f, xs, init) == FoldLeftInt(f, xs[1..], init + f(xs[0]));\n        assert FoldLeftIntCount(f, xs, init) == FoldLeftIntCount(f, xs[..|xs|-1], init) + f(xs[|xs|-1]);\n        \n        FoldLeftCountToRegular(f, xs, init);\n    }\n}\n\nlemma FoldLeftCountToRegular(f: int -> int, xs: seq<int>, init: int)\n    requires |xs| > 0\n    ensures FoldLeftIntCount(f, xs, init) == FoldLeftInt(f, xs[1..], init + f(xs[0]))\n    decreases |xs|\n{\n    if |xs| == 1 {\n        assert xs == [xs[0]];\n        assert xs[1..] == [];\n        assert xs[..|xs|-1] == [];\n        assert FoldLeftIntCount(f, xs, init) == FoldLeftIntCount(f, [], init) + f(xs[0]) == init + f(xs[0]);\n        assert FoldLeftInt(f, xs[1..], init + f(xs[0])) == FoldLeftInt(f, [], init + f(xs[0])) == init + f(xs[0]);\n    } else {\n        var n := |xs|;\n        assert xs[..|xs|-1] == xs[..n-1];\n        assert xs[1..] == xs[1..n];\n        \n        // Key insight: relate the two different decompositions\n        FoldLeftEquivalence(f, xs[1..], init + f(xs[0]));\n        \n        // Show that FoldLeftIntCount(f, xs, init) equals FoldLeftIntCount(f, xs[1..], init + f(xs[0]))\n        assert xs[..|xs|-1][1..] == xs[1..|xs|-1];\n        FoldLeftCountShift(f, xs, init);\n    }\n}\n\nlemma FoldLeftCountShift(f: int -> int, xs: seq<int>, init: int)\n    requires |xs| > 1\n    ensures FoldLeftIntCount(f, xs, init) == FoldLeftIntCount(f, xs[1..], init + f(xs[0]))\n    decreases |xs|\n{\n    var n := |xs|;\n    if n == 2 {\n        assert xs == [xs[0], xs[1]];\n        assert xs[1..] == [xs[1]];\n        assert xs[..|xs|-1] == [xs[0]];\n        assert FoldLeftIntCount(f, xs, init) == FoldLeftIntCount(f, [xs[0]], init) + f(xs[1]);\n        assert FoldLeftIntCount(f, [xs[0]], init) == init + f(xs[0]);\n        assert FoldLeftIntCount(f, xs, init) == init + f(xs[0]) + f(xs[1]);\n        assert FoldLeftIntCount(f, xs[1..], init + f(xs[0])) == FoldLeftIntCount(f, [], init + f(xs[0])) + f(xs[1]);\n        assert FoldLeftIntCount(f, xs[1..], init + f(xs[0])) == init + f(xs[0]) + f(xs[1]);\n    } else {\n        assert xs[..|xs|-1][1..] == xs[1..|xs|-1];\n        FoldLeftCountShift(f, xs[..|xs|-1], init);\n        assert FoldLeftIntCount(f, xs[..|xs|-1], init) == FoldLeftIntCount(f, xs[1..|xs|-1], init + f(xs[0]));\n        assert FoldLeftIntCount(f, xs, init) == FoldLeftIntCount(f, xs[..|xs|-1], init) + f(xs[|xs|-1]);\n        assert FoldLeftIntCount(f, xs[1..], init + f(xs[0])) == FoldLeftIntCount(f, xs[1..|xs|-1], init + f(xs[0])) + f(xs[|xs|-1]);\n    }\n}\n\nlemma RecursivePositiveProductAppend(q: seq<int>, i: int)\n    requires 0 <= i < |q|\n    ensures RecursivePositiveProduct(q[..i+1]) == \n            (if q[i] <= 0 then RecursivePositiveProduct(q[..i]) else RecursivePositiveProduct(q[..i]) * q[i])\n{\n    assert q[..i+1] == q[..i] + [q[i]];\n    RecursivePositiveProductConcat(q[..i], [q[i]]);\n}\n\nlemma RecursivePositiveProductConcat(q1: seq<int>, q2: seq<int>)\n    ensures RecursivePositiveProduct(q1 + q2) == RecursivePositiveProduct(q1) * RecursivePositiveProduct(q2)\n    decreases |q1|\n{\n    if q1 == [] {\n        assert q1 + q2 == q2;\n        assert RecursivePositiveProduct(q1) == 1;\n    } else {\n        assert q1 + q2 == [q1[0]] + (q1[1..] + q2);\n        RecursivePositiveProductConcat(q1[1..], q2);\n        if q1[0] <= 0 {\n            assert RecursivePositiveProduct(q1 + q2) == RecursivePositiveProduct(q1[1..] + q2);\n            assert RecursivePositiveProduct(q1) == RecursivePositiveProduct(q1[1..]);\n        } else {\n            assert RecursivePositiveProduct(q1 + q2) == q1[0] * RecursivePositiveProduct(q1[1..] + q2);\n            assert RecursivePositiveProduct(q1) == q1[0] * RecursivePositiveProduct(q1[1..]);\n        }\n    }\n}\n\nlemma RecursiveCountAppend(key: int, q: seq<int>, i: int)\n    requires 0 <= i < |q|\n    ensures RecursiveCount(key, q[..i+1]) == \n            RecursiveCount(key, q[..i]) + (if q[i] == key then 1 else 0)\n{\n    assert q[..i+1] == q[..i] + [q[i]];\n    RecursiveCountConcat(key, q[..i], [q[i]]);\n}\n\nlemma RecursiveCountConcat(key: int, q1: seq<int>, q2: seq<int>)\n    ensures RecursiveCount(key, q1 + q2) == RecursiveCount(key, q1) + RecursiveCount(key, q2)\n    decreases |q2|\n{\n    if q2 == [] {\n        assert q1 + q2 == q1;\n        assert RecursiveCount(key, q2) == 0;\n    } else {\n        var combined := q1 + q2;\n        assert combined[..|combined|-1] == q1 + q2[..|q2|-1];\n        RecursiveCountConcat(key, q1, q2[..|q2|-1]);\n        if q2[|q2|-1] == key {\n            assert RecursiveCount(key, combined) == 1 + RecursiveCount(key, combined[..|combined|-1]);\n            assert RecursiveCount(key, q2) == 1 + RecursiveCount(key, q2[..|q2|-1]);\n        } else {\n            assert RecursiveCount(key, combined) == RecursiveCount(key, combined[..|combined|-1]);\n            assert RecursiveCount(key, q2) == RecursiveCount(key, q2[..|q2|-1]);\n        }\n    }\n}\n\nfunction FoldLeftInt(f: int -> int, xs: seq<int>, init: int): int\n    decreases |xs|\n{\n    if xs == [] then init\n    else FoldLeftInt(f, xs[1..], init + f(xs[0]))\n}\n\nfunction FoldRightInt(f: int -> int, xs: seq<int>, init: int): int\n    decreases |xs|\n{\n    if xs == [] then init\n    else f(xs[0]) * FoldRightInt(f, xs[1..], init)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ProdAndCount(q: seq<int>, key: int) returns (prod: int, count: nat)\n    ensures prod == RecursivePositiveProduct(q)\n    ensures count == RecursiveCount(key, q)\n// </vc-spec>\n// <vc-code>\n{\n    prod := 1;\n    count := 0;\n    \n    var i := 0;\n    while i < |q|\n        invariant 0 <= i <= |q|\n        invariant prod == RecursivePositiveProduct(q[..i])\n        invariant count == RecursiveCount(key, q[..i])\n        decreases |q| - i\n    {\n        RecursivePositiveProductAppend(q, i);\n        RecursiveCountAppend(key, q, i);\n        \n        if q[i] > 0 {\n            prod := prod * q[i];\n        }\n        if q[i] == key {\n            count := count + 1;\n        }\n        i := i + 1;\n    }\n    \n    assert q[..|q|] == q;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_online_max_onlineMax.dfy", "root", true, "", "", false, "Clover_online_max_onlineMax.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nfunction MaxExists(a: array<int>, x: int): (int, int)\n  requires a.Length > 0\n  requires 0 <= x < a.Length\n  reads a\n{\n  var m := a[0];\n  var idx := 0;\n  var j := 1;\n  while j < x\n    invariant 1 <= j <= x\n    invariant 0 <= idx < j\n    invariant a[idx] == m\n    invariant forall i :: 0 <= i < j ==> a[i] <= m\n    decreases x - j\n  {\n    if a[j] > m {\n      m := a[j];\n      idx := j;\n    }\n    j := j + 1;\n  }\n  (m, idx)\n}\n\nlemma MaxExistsCorrect(a: array<int>, x: int)\n  requires a.Length > 0\n  requires 0 <= x < a.Length\n  ensures var (m, idx) := MaxExists(a, x); 0 <= idx < x && a[idx] == m && forall i :: 0 <= i < x ==> a[i] <= m\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n// </vc-spec>\n// <vc-code>\n{\n  var (maxVal, maxIdx) := MaxExists(a, x);\n  m := maxVal;\n  \n  p := x;\n  while p < a.Length - 1\n    invariant x <= p < a.Length\n    invariant forall i :: 0 <= i < x ==> a[i] <= m\n    invariant exists i :: 0 <= i < x && a[i] == m\n    invariant forall i :: x <= i < p ==> a[i] <= m\n    decreases a.Length - 1 - p\n  {\n    if a[p] > m {\n      break;\n    }\n    \n    var found := false;\n    var j := p + 1;\n    while j < a.Length && !found\n      invariant p + 1 <= j <= a.Length\n      invariant !found ==> forall k :: p + 1 <= k < j ==> a[k] <= a[p]\n      decreases a.Length - j\n    {\n      if a[j] > a[p] {\n        found := true;\n        p := j;\n      } else {\n        j := j + 1;\n      }\n    }\n    \n    if !found {\n      p := a.Length - 1;\n      break;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch.dfy", "root", true, "", "", false, "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs\n\n// <vc-helpers>\nlemma ArrayStrictlyIncreasing(a: array<int>, i: int, j: int)\n  requires forall k :: 1 <= k < a.Length ==> a[k-1] < a[k]\n  requires 0 <= i < j < a.Length\n  ensures a[i] < a[j]\n{\n  if i + 1 == j {\n    // Base case: adjacent elements\n  } else {\n    // Inductive case\n    ArrayStrictlyIncreasing(a, i, j-1);\n    assert a[i] < a[j-1];\n    assert a[j-1] < a[j];\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  var low := 0;\n  var high := a.Length;\n  \n  while low < high\n    invariant 0 <= low <= high <= a.Length\n    invariant forall i :: 0 <= i < low ==> a[i] < circle\n    invariant forall i :: high <= i < a.Length ==> circle <= a[i]\n    decreases high - low\n  {\n    var mid := (low + high) / 2;\n    \n    if a[mid] < circle {\n      low := mid + 1;\n    } else {\n      high := mid;\n    }\n  }\n  \n  n := low;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_PreCompute.dfy", "root", false, "", "", false, "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_PreCompute.dfy", "// <vc-preamble>\nghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n\nmethod ComputeCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PreCompute(a:array<int>,b:array<int>)returns(p:nat)\n    requires a.Length == b.Length \n    modifies b\n    ensures (b.Length == 0 || (a.Length == b.Length && 1 <= b.Length <= a.Length)) &&\n    forall p::p == Count(b.Length,a[..]) ==> p==Count(b.Length,a[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse.dfy", "root", true, "", "", false, "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse.dfy", "// <vc-preamble>\nfunction fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxArrayReverse(arr : array<int>) returns (max: int)\n  requires arr.Length > 0\n  ensures forall i: int :: 0 <= i < arr.Length ==> arr[i] <= max\n  ensures exists x::0 <= x < arr.Length && arr[x] == max\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxArrayReverse(arr : array<int>) returns (max: int)\n  requires arr.Length > 0\n  ensures forall i: int :: 0 <= i < arr.Length ==> arr[i] <= max\n  ensures exists x::0 <= x < arr.Length && arr[x] == max\n// </vc-spec>\n// <vc-code>\n{\n  max := arr[arr.Length - 1];\n  var i := arr.Length - 2;\n  \n  while i >= 0\n    invariant -1 <= i < arr.Length\n    invariant forall j: int :: i < j < arr.Length ==> arr[j] <= max\n    invariant exists x: int :: i < x < arr.Length && arr[x] == max\n  {\n    if arr[i] > max {\n      max := arr[i];\n    }\n    i := i - 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_605_IsPrime.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_605_IsPrime.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (forall k :: 2 <= k < n ==> n % k != 0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (forall k :: 2 <= k < n ==> n % k != 0)\n// </vc-spec>\n// <vc-code>\n{\n  var i := 2;\n  result := true;\n  \n  while i < n\n    invariant 2 <= i <= n\n    invariant result <==> (forall k :: 2 <= k < i ==> n % k != 0)\n  {\n    if n % i == 0 {\n      result := false;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_776_CountVowelNeighbors.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_776_CountVowelNeighbors.dfy", "// <vc-preamble>\npredicate IsVowel(c: char)\n{\n    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountVowelNeighbors(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]) |\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsVowel(c: char)\n{\n    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n}\n\n// <vc-helpers>\nlemma SetCardinalityHelper(s: string)\n    ensures | set i: int {:trigger} | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]) | <= |s|\n{\n    var validIndices := set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]);\n    var allIndices := set i: int | 1 <= i < |s|-1;\n    assert validIndices <= allIndices;\n    if |s| <= 2 {\n        assert allIndices == {};\n        assert validIndices == {};\n    } else {\n        assert forall i :: i in allIndices <==> 1 <= i <= |s|-2;\n        assert |allIndices| == |s| - 2;\n        assert |allIndices| <= |s|;\n    }\n}\n\nlemma CountingCorrectness(s: string, count: int)\n    requires count == |set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1])|\n    ensures count == |set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1])|\n{\n}\n\nlemma LoopInvariantMaintained(s: string, i: int, count: int)\n    requires 1 <= i < |s| - 1\n    requires count == |set j: int | 1 <= j < i && IsVowel(s[j-1]) && IsVowel(s[j+1])|\n    ensures if IsVowel(s[i-1]) && IsVowel(s[i+1]) then\n        count + 1 == |set j: int | 1 <= j < i + 1 && IsVowel(s[j-1]) && IsVowel(s[j+1])|\n    else\n        count == |set j: int | 1 <= j < i + 1 && IsVowel(s[j-1]) && IsVowel(s[j+1])|\n{\n    var setBeforeI := set j: int | 1 <= j < i && IsVowel(s[j-1]) && IsVowel(s[j+1]);\n    var setAfterI := set j: int | 1 <= j < i + 1 && IsVowel(s[j-1]) && IsVowel(s[j+1]);\n    \n    if IsVowel(s[i-1]) && IsVowel(s[i+1]) {\n        assert i in setAfterI;\n        assert setAfterI == setBeforeI + {i};\n        assert |setAfterI| == |setBeforeI| + 1;\n    } else {\n        assert i !in setAfterI;\n        assert setAfterI == setBeforeI;\n    }\n}\n\nlemma FinalCorrectnessHelper(s: string, count: int, finalIndex: int)\n    requires finalIndex == |s| - 1\n    requires count == |set j: int | 1 <= j < finalIndex && IsVowel(s[j-1]) && IsVowel(s[j+1])|\n    ensures count == |set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1])|\n{\n    var setFromLoop := set j: int | 1 <= j < finalIndex && IsVowel(s[j-1]) && IsVowel(s[j+1]);\n    var targetSet := set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]);\n    assert finalIndex == |s| - 1;\n    assert setFromLoop == targetSet;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountVowelNeighbors(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]) |\n// </vc-spec>\n// <vc-code>\n{\n    if |s| <= 2 {\n        count := 0;\n        SetCardinalityHelper(s);\n        return;\n    }\n    \n    count := 0;\n    var i := 1;\n    \n    while i < |s| - 1\n        invariant 1 <= i <= |s| - 1\n        invariant count >= 0\n        invariant count == |set j: int | 1 <= j < i && IsVowel(s[j-1]) && IsVowel(s[j+1])|\n    {\n        LoopInvariantMaintained(s, i, count);\n        if IsVowel(s[i-1]) && IsVowel(s[i+1]) {\n            count := count + 1;\n        }\n        i := i + 1;\n    }\n    \n    FinalCorrectnessHelper(s, count, i);\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold.dfy", "// <vc-preamble>\npredicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}\n\n// <vc-helpers>\nlemma multiset_append_element<T>(s: seq<T>, x: T)\n  ensures multiset(s + [x]) == multiset(s) + multiset([x])\n{\n}\n\nlemma multiset_slice_extension<T>(s: seq<T>, i: int)\n  requires 0 <= i < |s|\n  ensures multiset(s[0..i+1]) == multiset(s[0..i]) + multiset([s[i]])\n{\n  assert s[0..i+1] == s[0..i] + [s[i]];\n  multiset_append_element(s[0..i], s[i]);\n}\n\nlemma multiset_full_slice<T>(s: seq<T>)\n  ensures multiset(s[0..|s|]) == multiset(s)\n{\n  assert s[0..|s|] == s;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n// </vc-spec>\n// <vc-code>\n{\n  Seq_1 := [];\n  Seq_2 := [];\n  \n  var i := 0;\n  while i < |Seq|\n    invariant 0 <= i <= |Seq|\n    invariant forall x | x in Seq_1 :: x <= thres\n    invariant forall x | x in Seq_2 :: x >= thres\n    invariant |Seq_1| + |Seq_2| == i\n    invariant multiset(Seq_1) + multiset(Seq_2) == multiset(Seq[0..i])\n  {\n    multiset_slice_extension(Seq, i);\n    if Seq[i] <= thres {\n      multiset_append_element(Seq_1, Seq[i]);\n      Seq_1 := Seq_1 + [Seq[i]];\n    } else {\n      multiset_append_element(Seq_2, Seq[i]);\n      Seq_2 := Seq_2 + [Seq[i]];\n    }\n    i := i + 1;\n  }\n  \n  multiset_full_slice(Seq);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum.dfy", "// <vc-preamble>\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\n\n// <vc-helpers>\nlemma InMapEmpty(m: map<int, int>, t: int)\n  ensures InMap([], m, t)\n{\n}\n\nlemma InMapExtend(nums: seq<int>, m: map<int, int>, t: int, x: int)\n  requires InMap(nums, m, t)\n  requires t - x in m\n  ensures InMap(nums + [x], m, t)\n{\n}\n\nlemma InMapPrefix(nums: seq<int>, m: map<int, int>, t: int, k: int)\n  requires InMap(nums, m, t)\n  requires 0 <= k <= |nums|\n  ensures InMap(nums[..k], m, t)\n{\n}\n\nlemma MapUpdatePreservesLookup(m: map<int, int>, k: int, v: int, idx: int, nums: array<int>)\n  requires 0 <= idx < nums.Length\n  requires forall j :: 0 <= j < idx ==> nums[j] in m && m[nums[j]] == j\n  requires k == nums[idx]\n  requires v == idx\n  ensures forall j :: 0 <= j < idx ==> nums[j] in m[k := v] && m[k := v][nums[j]] == j\n{\n  forall j | 0 <= j < idx\n    ensures nums[j] in m[k := v] && m[k := v][nums[j]] == j\n  {\n    assert nums[j] in m && m[nums[j]] == j;\n    if nums[j] == k {\n      assert m[nums[j]] == j;\n      assert k == nums[idx];\n      assert nums[j] == nums[idx];\n      assert j < idx;\n      assert m[nums[j]] == j;\n      assert m[k := v][nums[j]] == v;\n      assert v == idx;\n      assert m[k := v][nums[j]] == idx;\n      // The map will now point to the later occurrence (idx), but we need it to point to j\n      // This means our invariant needs to be adjusted to handle the most recent occurrence\n      assert m[k := v][nums[j]] == idx;\n      assert j < idx;\n      // We need to ensure that when we update, we maintain the property correctly\n      // The issue is that we're overwriting the mapping, so we need a different approach\n    } else {\n      assert nums[j] != k;\n      assert m[k := v][nums[j]] == m[nums[j]];\n      assert m[k := v][nums[j]] == j;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n// </vc-spec>\n// <vc-code>\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  \n  while i < nums.Length\n    invariant 0 <= i <= nums.Length\n    invariant forall k :: k in m <==> exists idx :: 0 <= idx < i && nums[idx] == k\n    invariant forall k :: k in m ==> 0 <= m[k] < i && nums[m[k]] == k\n    invariant forall x, y :: 0 <= x < y < i ==> nums[x] + nums[y] != target\n  {\n    var complement := target - nums[i];\n    \n    if complement in m {\n      var j := m[complement];\n      assert nums[j] + nums[i] == target;\n      assert 0 <= j < i;\n      return (j, i);\n    }\n    \n    m := m[nums[i] := i];\n    i := i + 1;\n  }\n  \n  return (-1, -1);\n}\n// </vc-code>\n\n", "", "", ""], ["MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition.dfy", "root", true, "", "", false, "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition.dfy", "// <vc-preamble>\ntype T = int\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod partition(a: array<T>) returns(pivotPos: int) \n    requires a.Length > 0\n    ensures 0 <= pivotPos < a.Length\n    ensures forall i :: 0 <= i < pivotPos ==> a[i] < a[pivotPos]\n    ensures forall i :: pivotPos < i < a.Length ==> a[i] >= a[pivotPos]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    modifies a\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "type T = int // example\n\n // Partitions a nonempty array 'a', by reordering the elements in the array,\n// so that elements smaller than a chosen pivot are placed to the left of the\n// pivot, and values greater or equal than the pivot are placed to the right of \n// the pivot. Returns the pivot position.\n\n// <vc-helpers>\nlemma MultisetSwap(a: array<T>, i: int, j: int, oldSeq: seq<T>)\n    requires 0 <= i < a.Length\n    requires 0 <= j < a.Length\n    requires oldSeq == a[..]\n    ensures multiset(a[..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..]) == multiset(oldSeq)\n{\n    if i == j {\n        assert a[..] == oldSeq;\n        assert a[..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..] == a[..i] + [a[i]] + a[i+1..i] + [a[i]] + a[i+1..];\n        assert a[..i] + [a[i]] + a[i+1..i] + [a[i]] + a[i+1..] == a[..i] + [a[i]] + [] + [a[i]] + a[i+1..];\n        assert a[..i] + [a[i]] + [] + [a[i]] + a[i+1..] == a[..i] + [a[i]] + [a[i]] + a[i+1..];\n        assert a[..i] + [a[i]] + [a[i]] + a[i+1..] == a[..i] + [a[i], a[i]] + a[i+1..];\n        assert multiset(a[..i] + [a[i], a[i]] + a[i+1..]) == multiset(a[..i] + [a[i]] + a[i+1..]);\n        assert a[..i] + [a[i]] + a[i+1..] == a[..];\n    } else if i < j {\n        assert a[..] == a[..i] + [a[i]] + a[i+1..j] + [a[j]] + a[j+1..];\n        assert multiset(a[..i] + [a[i]] + a[i+1..j] + [a[j]] + a[j+1..]) == multiset(a[..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..]);\n    } else {\n        assert j < i;\n        assert a[..] == a[..j] + [a[j]] + a[j+1..i] + [a[i]] + a[i+1..];\n        assert multiset(a[..j] + [a[j]] + a[j+1..i] + [a[i]] + a[i+1..]) == multiset(a[..j] + [a[i]] + a[j+1..i] + [a[j]] + a[i+1..]);\n        assert a[..i] + [a[j]] + a[i+1..j] + [a[i]] + a[j+1..] == a[..j] + [a[i]] + a[j+1..i] + [a[j]] + a[i+1..];\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod partition(a: array<T>) returns(pivotPos: int) \n    requires a.Length > 0\n    ensures 0 <= pivotPos < a.Length\n    ensures forall i :: 0 <= i < pivotPos ==> a[i] < a[pivotPos]\n    ensures forall i :: pivotPos < i < a.Length ==> a[i] >= a[pivotPos]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    modifies a\n// </vc-spec>\n// <vc-code>\n{\n    var pivot := a[0];\n    var left := 1;\n    var right := a.Length - 1;\n    ghost var originalSeq := a[..];\n    \n    while left <= right\n        invariant 0 <= left <= a.Length\n        invariant -1 <= right < a.Length\n        invariant forall i :: 1 <= i < left ==> a[i] < pivot\n        invariant forall i :: right < i < a.Length ==> a[i] >= pivot\n        invariant a[0] == pivot\n        invariant multiset(a[..]) == multiset(originalSeq)\n    {\n        if a[left] < pivot {\n            left := left + 1;\n        } else if a[right] >= pivot {\n            right := right - 1;\n        } else {\n            ghost var oldSeq := a[..];\n            a[left], a[right] := a[right], a[left];\n            assert oldSeq == a[..left] + [oldSeq[left]] + a[left+1..right] + [oldSeq[right]] + a[right+1..];\n            assert a[..] == a[..left] + [oldSeq[right]] + a[left+1..right] + [oldSeq[left]] + a[right+1..];\n            assert multiset(a[..]) == multiset(oldSeq);\n            left := left + 1;\n            right := right - 1;\n        }\n    }\n    \n    if right >= 0 {\n        ghost var oldSeq := a[..];\n        a[0], a[right] := a[right], a[0];\n        assert oldSeq == a[..0] + [oldSeq[0]] + a[1..right] + [oldSeq[right]] + a[right+1..];\n        assert a[..] == a[..0] + [oldSeq[right]] + a[1..right] + [oldSeq[0]] + a[right+1..];\n        assert multiset(a[..]) == multiset(oldSeq);\n        pivotPos := right;\n    } else {\n        pivotPos := 0;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod M(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a.Length == N && (forall k :: 0 <= k && k < N ==> 0 <= a[k]);\n  ensures sum <= N * max;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove\n// that 'sum <= N * max'.\n// Rustan Leino, 18 August 2010.\n//\n// The problem statement gave the pseudo-code for the method, but did not ask to prove\n// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The\n// given assumption that the array's elements are non-negative is not needed to establish\n// the requested postcondition.\n\n// <vc-helpers>\nfunction Sum(a: array<int>, start: int, end: int): int\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  if start == end then 0\n  else Sum(a, start, end-1) + a[end-1]\n}\n\nlemma SumProperty(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  ensures Sum(a, start, end) == (if start == end then 0 else Sum(a, start, end-1) + a[end-1])\n{\n}\n\nlemma SumBound(a: array<int>, start: int, end: int, max: int)\n  requires 0 <= start <= end <= a.Length\n  requires forall k :: start <= k < end ==> a[k] <= max\n  ensures Sum(a, start, end) <= (end - start) * max\n{\n  if start == end {\n  } else {\n    SumBound(a, start, end-1, max);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod M(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a.Length == N && (forall k :: 0 <= k && k < N ==> 0 <= a[k]);\n  ensures sum <= N * max;\n// </vc-spec>\n// <vc-code>\n{\n  if N == 0 {\n    sum := 0;\n    max := 0;\n    return;\n  }\n  \n  sum := 0;\n  max := a[0];\n  var i := 0;\n  \n  while i < N\n    invariant 0 <= i <= N\n    invariant sum == Sum(a, 0, i)\n    invariant i > 0 ==> forall k :: 0 <= k < i ==> a[k] <= max\n    invariant i == 0 ==> max == a[0]\n    invariant sum <= i * max\n  {\n    sum := sum + a[i];\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast.dfy", "root", true, "", "", false, "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast.dfy", "// <vc-preamble>\nfunction sum(a: array<int>, i: int, j: int) : int\n  requires 0 <= i <= j <= a.Length\n  reads a\n  decreases j\n{\n  if i == j then 0\n  else a[j-1] + sum(a, i, j-1)\n}\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n  reads c, a\n{\n  a.Length + 1 == c.Length && forall i: int :: 0 <= i <= a.Length ==> c[i] == sum(a, 0, i)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n  requires 0 <= i <= j <= a.Length\n  requires is_prefix_sum_for(a,c)\n  ensures r == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// 1 a)\n\n// [ai, aj[\nfunction sum(a: array<int>, i: int, j: int) : int\n  requires 0 <= i <= j <= a.Length\n  reads a\n  decreases j\n{\n  if i == j then 0\n  else a[j-1] + sum(a, i, j-1)\n}\n\n// 1 b)\n\n// 1 c)\n// a -> [1, 10, 3, \u22124, 5]\n// c -> [0, 1, 11, 14, 10, 15]\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n  reads c, a\n{\n  a.Length + 1 == c.Length && forall i: int :: 0 <= i <= a.Length ==> c[i] == sum(a, 0, i)\n}\n\n// <vc-helpers>\nlemma sum_split(a: array<int>, i: int, k: int, j: int)\n  requires 0 <= i <= k <= j <= a.Length\n  ensures sum(a, i, j) == sum(a, i, k) + sum(a, k, j)\n{\n  if k == j {\n    assert sum(a, k, j) == 0;\n    assert sum(a, i, j) == sum(a, i, k);\n  } else {\n    sum_split(a, i, k, j-1);\n    assert sum(a, i, j) == a[j-1] + sum(a, i, j-1);\n    assert sum(a, i, j-1) == sum(a, i, k) + sum(a, k, j-1);\n    assert sum(a, k, j) == a[j-1] + sum(a, k, j-1);\n  }\n}\n\nlemma prefix_sum_property(a: array<int>, c: array<int>, i: int, j: int)\n  requires 0 <= i <= j <= a.Length\n  requires is_prefix_sum_for(a, c)\n  ensures sum(a, i, j) == c[j] - c[i]\n{\n  sum_split(a, 0, i, j);\n  assert sum(a, 0, j) == sum(a, 0, i) + sum(a, i, j);\n  assert c[j] == sum(a, 0, j);\n  assert c[i] == sum(a, 0, i);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n  requires 0 <= i <= j <= a.Length\n  requires is_prefix_sum_for(a,c)\n  ensures r == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  prefix_sum_property(a, c, i, j);\n  r := c[j] - c[i];\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_is_even_ComputeIsEven.dfy", "root", true, "", "", false, "Clover_is_even_ComputeIsEven.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n// </vc-spec>\n// <vc-code>\n{\n  is_even := x % 2 == 0;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_142_CountIdenticalPositions.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_142_CountIdenticalPositions.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountIdenticalPositions(a: seq<int>, b: seq<int>, c: seq<int>) returns (count: int)\n    requires |a| == |b| && |b| == |c|\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |a| && a[i] == b[i] && b[i] == c[i]|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SetSizeIncrement(a: seq<int>, b: seq<int>, c: seq<int>, i: int)\n    requires 0 <= i < |a| && |a| == |b| && |b| == |c|\n    requires a[i] == b[i] && b[i] == c[i]\n    ensures | set j: int | 0 <= j < i+1 && a[j] == b[j] && b[j] == c[j]| == \n            | set j: int | 0 <= j < i && a[j] == b[j] && b[j] == c[j]| + 1\n{\n    var S1 := set j: int | 0 <= j < i && a[j] == b[j] && b[j] == c[j];\n    var S2 := set j: int | 0 <= j < i+1 && a[j] == b[j] && b[j] == c[j];\n    \n    assert S2 == S1 + {i};\n    assert i !in S1;\n}\n\nlemma SetSizeNoChange(a: seq<int>, b: seq<int>, c: seq<int>, i: int)\n    requires 0 <= i < |a| && |a| == |b| && |b| == |c|\n    requires !(a[i] == b[i] && b[i] == c[i])\n    ensures | set j: int | 0 <= j < i+1 && a[j] == b[j] && b[j] == c[j]| == \n            | set j: int | 0 <= j < i && a[j] == b[j] && b[j] == c[j]|\n{\n    var S1 := set j: int | 0 <= j < i && a[j] == b[j] && b[j] == c[j];\n    var S2 := set j: int | 0 <= j < i+1 && a[j] == b[j] && b[j] == c[j];\n    \n    assert S2 == S1;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountIdenticalPositions(a: seq<int>, b: seq<int>, c: seq<int>) returns (count: int)\n    requires |a| == |b| && |b| == |c|\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |a| && a[i] == b[i] && b[i] == c[i]|\n// </vc-spec>\n// <vc-code>\n{\n  count := 0;\n  var i := 0;\n  \n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant count >= 0\n    invariant count == | set j: int | 0 <= j < i && a[j] == b[j] && b[j] == c[j]|\n  {\n    if a[i] == b[i] && b[i] == c[i] {\n      SetSizeIncrement(a, b, c, i);\n      count := count + 1;\n    } else {\n      SetSizeNoChange(a, b, c, i);\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center.dfy", "root", true, "", "", false, "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center.dfy", "// <vc-preamble>\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\nmethod longestPalindrome'(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]\n  ensures palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo\n{\n  assume{:axiom} false;\n}\n\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)\n    && i + j == i0 + j0\n    :: j - i <= hi - lo\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\nmethod longestPalindrome'(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]\n  ensures palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo\n{\n  assume{:axiom} false;\n}\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.\n\n// <vc-helpers>\nlemma palindromic_expand(s: string, i: int, j: int)\n  requires 0 < i <= j < |s|\n  requires palindromic(s, i, j)\n  requires s[i-1] == s[j]\n  ensures palindromic(s, i-1, j+1)\n{\n  if j+1 - (i-1) < 2 {\n    // trivially palindromic\n  } else {\n    assert s[i-1] == s[j];\n    assert palindromic(s, i, j);\n  }\n}\n\nlemma palindromic_same_center_monotonic(s: string, i1: int, j1: int, i2: int, j2: int)\n  requires 0 <= i1 <= j1 <= |s|\n  requires 0 <= i2 <= j2 <= |s|\n  requires palindromic(s, i1, j1)\n  requires palindromic(s, i2, j2)\n  requires i1 + j1 == i2 + j2\n  requires i1 >= i2 && j1 <= j2\n  ensures j1 - i1 <= j2 - i2\n{\n  // follows from arithmetic\n}\n\nlemma palindromic_maximal_property(s: string, lo: int, hi: int, center: int)\n  requires 0 <= lo <= hi <= |s|\n  requires palindromic(s, lo, hi)\n  requires lo + hi == 2 * center\n  requires lo == 0 || hi == |s| || s[lo-1] != s[hi]\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == 2 * center :: j - i <= hi - lo\n{\n  forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == 2 * center\n    ensures j - i <= hi - lo\n  {\n    if j - i > hi - lo {\n      assert i < lo || j > hi;\n      if i < lo {\n        assert j > hi;\n        if i >= 0 && j <= |s| {\n          if j - i >= 2 && palindromic(s, i, j) {\n            if lo > 0 && hi < |s| {\n              assert s[lo-1] != s[hi];\n              assert i <= lo - 1 && j >= hi + 1;\n              if i == lo - 1 && j == hi + 1 {\n                assert s[i] != s[j-1];\n                assert !palindromic(s, i, j);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nlemma same_center_sum_preserved(i0: int, j0: int, lo: int, hi: int)\n  requires lo + hi == i0 + j0\n  ensures i0 + j0 == 2 * ((i0 + j0) / 2) || i0 + j0 == 2 * ((i0 + j0) / 2) + 1\n  ensures lo + hi == 2 * ((i0 + j0) / 2) || lo + hi == 2 * ((i0 + j0) / 2) + 1\n{\n  // Arithmetic fact about integer division\n}\n\nlemma palindromic_maximal_for_odd_center(s: string, lo: int, hi: int, sum: int)\n  requires 0 <= lo <= hi <= |s|\n  requires palindromic(s, lo, hi)\n  requires lo + hi == sum\n  requires sum % 2 == 1\n  requires lo == 0 || hi == |s| || s[lo-1] != s[hi]\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == sum :: j - i <= hi - lo\n{\n  forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == sum\n    ensures j - i <= hi - lo\n  {\n    if j - i > hi - lo {\n      assert i < lo || j > hi;\n      if i < lo && j > hi {\n        if lo > 0 && hi < |s| {\n          assert s[lo-1] != s[hi];\n          assert i <= lo - 1 && j >= hi + 1;\n          if i == lo - 1 && j == hi + 1 {\n            assert s[i] == s[lo-1] && s[j-1] == s[hi];\n            assert s[i] != s[j-1];\n            if j - i >= 2 {\n              assert !palindromic(s, i, j);\n            }\n          } else {\n            // For other cases where the palindrome would need to extend even further\n            assert j - i > (hi + 1) - (lo - 1);\n            assert j - i > hi - lo + 2;\n            if palindromic(s, i, j) && j - i >= 2 {\n              // This would contradict the fact that we couldn't extend further\n              assert i <= lo - 1 < lo;\n              assert hi < hi + 1 <= j;\n              assert s[lo-1] != s[hi];\n              // The palindrome s[i..j] would need s[lo-1] == s[hi] to be valid\n              assert false;\n            }\n          }\n        } else if lo == 0 {\n          assert i < 0;\n          assert false;\n        } else if hi == |s| {\n          assert j > |s|;\n          assert false;\n        }\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)  // Among all palindromes\n    && i + j == i0 + j0                                             // sharing the same center,\n    :: j - i <= hi - lo                                             // `s[lo..hi]` is longest.\n// </vc-spec>\n// <vc-code>\n{\n  lo, hi := i0, j0;\n  \n  while lo > 0 && hi < |s| && s[lo-1] == s[hi]\n    invariant 0 <= lo <= hi <= |s|\n    invariant palindromic(s, lo, hi)\n    invariant lo + hi == i0 + j0\n    decreases lo + (|s| - hi)\n  {\n    palindromic_expand(s, lo, hi);\n    lo := lo - 1;\n    hi := hi + 1;\n  }\n  \n  assert lo == 0 || hi == |s| || s[lo-1] != s[hi];\n  same_center_sum_preserved(i0, j0, lo, hi);\n  \n  if (i0 + j0) % 2 == 0 {\n    palindromic_maximal_property(s, lo, hi, (i0 + j0) / 2);\n  } else {\n    palindromic_maximal_for_odd_center(s, lo, hi, i0 + j0);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_tmp_tmp59p638nn_examples_realExponent_pow.dfy", "root", true, "", "", false, "dafny_tmp_tmp59p638nn_examples_realExponent_pow.dfy", "// <vc-preamble>\nghost function power(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures power(n, alpha) > 0.0\n\nghost function log(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures log(n, alpha) > 0.0\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod pow(n: nat, alpha: real) returns (product: real)\n    requires n > 0\n    requires alpha > 0.0\n    ensures product == power(n as real, alpha)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function power(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures power(n, alpha) > 0.0\n\nghost function log(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures log(n, alpha) > 0.0\n\n// <vc-helpers>\nghost function power(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures power(n, alpha) > 0.0\n\nghost function log(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures log(n, alpha) > 0.0\n\nlemma PowerPositive(n: real, alpha: real)\n    requires n > 0.0 && alpha > 0.0\n    ensures power(n, alpha) > 0.0\n{\n}\n\nlemma PowerOfNat(n: nat, alpha: real)\n    requires n > 0 && alpha > 0.0\n    ensures power(n as real, alpha) > 0.0\n{\n    PowerPositive(n as real, alpha);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod pow(n: nat, alpha: real) returns (product: real)\n    requires n > 0\n    requires alpha > 0.0\n    ensures product == power(n as real, alpha)\n// </vc-spec>\n// <vc-code>\n{\n    product := power(n as real, alpha);\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSort.dfy", "// <vc-preamble>\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    modifies a\n    ensures lo <= p < hi\n{\n  assume{:axiom} false;\n}\n\npredicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n\nmethod QuickSortAux(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]\n    ensures SwapFrame(a, lo, hi)\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    decreases hi - lo\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod QuickSort(a: array<int>)\n    modifies a\n    ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_624_ToUppercase.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_624_ToUppercase.dfy", "// <vc-preamble>\npredicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToUppercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}\n\n// <vc-helpers>\nlemma ShiftMinus32Correct(c: char)\n    requires IsLowerCase(c)\n    ensures IsLowerUpperPair(c, ShiftMinus32(c))\n{\n    assert 97 <= c as int <= 122;\n    assert c as int - 32 >= 65;\n    assert c as int - 32 <= 90;\n    assert (c as int - 32) % 128 == c as int - 32;\n    assert ShiftMinus32(c) as int == c as int - 32;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ToUppercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n    v := \"\";\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |v| == i\n        invariant forall j :: 0 <= j < i ==> if IsLowerCase(s[j]) then IsLowerUpperPair(s[j], v[j]) else v[j] == s[j]\n    {\n        if IsLowerCase(s[i]) {\n            ShiftMinus32Correct(s[i]);\n            v := v + [ShiftMinus32(s[i])];\n        } else {\n            v := v + [s[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort.dfy", "// <vc-preamble>\npredicate sorted_seg(a:array<int>, i:int, j:int)\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod selSort (a:array<int>, c:int, f:int)\nmodifies a \nrequires 0 <= c <= f <= a.Length\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted_seg(a:array<int>, i:int, j:int) //j not included\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}\n\n// <vc-helpers>\nlemma sorted_seg_extend(a: array<int>, i: int, j: int, k: int)\nrequires 0 <= i <= j <= k <= a.Length\nrequires sorted_seg(a, i, j)\nrequires sorted_seg(a, j, k)\nrequires j > i && k > j ==> a[j-1] <= a[j]\nensures sorted_seg(a, i, k)\n{\n}\n\nlemma sorted_seg_single(a: array<int>, i: int)\nrequires 0 <= i < a.Length\nensures sorted_seg(a, i, i+1)\n{\n}\n\nlemma multiset_swap_lemma(a: array<int>, i: int, j: int, c: int, f: int)\nrequires 0 <= c <= i < f <= a.Length\nrequires 0 <= c <= j < f <= a.Length\nrequires i != j\nensures multiset(a[c..f]) == old(multiset(a[c..f]))\n{\n}\n\nlemma sorted_seg_preserve_after_swap(a: array<int>, c: int, i: int, minPos: int)\nrequires 0 <= c <= i < a.Length\nrequires 0 <= c <= minPos < a.Length\nrequires sorted_seg(a, c, i)\nrequires forall k :: i <= k < a.Length ==> a[minPos] <= a[k]\nrequires forall k :: c <= k < i ==> a[k] <= a[minPos]\nensures sorted_seg(a, c, i+1)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod selSort (a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>\n// <vc-code>\n{\n  var i := c;\n  while i < f\n    invariant c <= i <= f\n    invariant sorted_seg(a, c, i)\n    invariant multiset(a[c..f]) == old(multiset(a[c..f]))\n    invariant a[..c] == old(a[..c]) && a[f..] == old(a[f..])\n    invariant forall k1, k2 :: c <= k1 < i && i <= k2 < f ==> a[k1] <= a[k2]\n  {\n    var minPos := i;\n    var j := i + 1;\n    \n    while j < f\n      invariant i < j <= f\n      invariant i <= minPos < f\n      invariant forall k :: i <= k < j ==> a[minPos] <= a[k]\n    {\n      if a[j] < a[minPos] {\n        minPos := j;\n      }\n      j := j + 1;\n    }\n    \n    if minPos != i {\n      var temp := a[i];\n      a[i] := a[minPos];\n      a[minPos] := temp;\n    }\n    \n    assert forall k :: i+1 <= k < f ==> a[i] <= a[k];\n    assert forall k1, k2 :: c <= k1 < i+1 && i+1 <= k2 < f ==> a[k1] <= a[k2];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb.dfy", "root", true, "", "", false, "DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb.dfy", "// <vc-preamble>\nfunction comb(n: nat, k: nat): nat \n  requires 0 <= k <= n\n{\n  if k == 0 || k == n then 1 else comb(n-1, k) + comb(n-1, k-1)  \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Comb(n: nat, k: nat) returns (res: nat)\n  requires 0 <= k <= n\n  ensures res == comb(n, k)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal specification and verification of a dynamic programming algorithm for calculating C(n, k).\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial recursive definition of C(n, k), based on the Pascal equality.\nfunction comb(n: nat, k: nat): nat \n  requires 0 <= k <= n\n{\n  if k == 0 || k == n then 1 else comb(n-1, k) + comb(n-1, k-1)  \n}\n\n// <vc-helpers>\nlemma CombCorrectness(n: nat, k: nat, table: array2<nat>)\n  requires 0 <= k <= n\n  requires table.Length0 == n + 1 && table.Length1 == n + 1\n  requires forall i, j :: 0 <= i <= n && 0 <= j <= i ==> table[i, j] == comb(i, j)\n  ensures table[n, k] == comb(n, k)\n{\n}\n\nlemma CombBaseCase(i: nat, table: array2<nat>)\n  requires table.Length0 >= i + 1 && table.Length1 >= i + 1\n  requires i >= 0\n  ensures comb(i, 0) == 1\n  ensures comb(i, i) == 1\n{\n}\n\nlemma CombRecursive(i: nat, j: nat)\n  requires 0 < j < i\n  ensures comb(i, j) == comb(i-1, j) + comb(i-1, j-1)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Comb(n: nat, k: nat) returns (res: nat)\n  requires 0 <= k <= n\n  ensures res == comb(n, k)\n// </vc-spec>\n// <vc-code>\n{\n  var table := new nat[n+1, n+1];\n  \n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant forall row :: 0 <= row < i ==> forall col :: 0 <= col <= row ==> table[row, col] == comb(row, col)\n  {\n    var j := 0;\n    while j <= i\n      invariant 0 <= j <= i + 1\n      invariant forall row :: 0 <= row < i ==> forall col :: 0 <= col <= row ==> table[row, col] == comb(row, col)\n      invariant forall col :: 0 <= col < j ==> table[i, col] == comb(i, col)\n    {\n      if j == 0 || j == i {\n        table[i, j] := 1;\n        CombBaseCase(i, table);\n      } else {\n        table[i, j] := table[i-1, j] + table[i-1, j-1];\n        CombRecursive(i, j);\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  \n  res := table[n, k];\n  CombCorrectness(n, k, table);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax.dfy", "root", true, "", "", false, "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  var j := 1;\n  while j < a.Length\n    invariant 0 <= i < a.Length\n    invariant 1 <= j <= a.Length\n    invariant forall k :: 0 <= k < j ==> a[k] <= a[i]\n  {\n    if a[j] > a[i] {\n      i := j;\n    }\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse.dfy", "root", true, "", "", false, "llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod intersperse(numbers: seq<int>, delimiter: int) returns (interspersed: seq<int>)\n    ensures |interspersed| == if |numbers| > 0 then 2 * |numbers| - 1 else 0\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 0 ==> \n                interspersed[i] == numbers[i / 2]\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 1 ==>\n                interspersed[i] == delimiter\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod intersperse(numbers: seq<int>, delimiter: int) returns (interspersed: seq<int>)\n    ensures |interspersed| == if |numbers| > 0 then 2 * |numbers| - 1 else 0\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 0 ==> \n                interspersed[i] == numbers[i / 2]\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 1 ==>\n                interspersed[i] == delimiter\n// </vc-spec>\n// <vc-code>\n{\n    if |numbers| == 0 {\n        interspersed := [];\n    } else {\n        interspersed := [numbers[0]];\n        var i := 1;\n        while i < |numbers|\n            invariant 1 <= i <= |numbers|\n            invariant |interspersed| == 2 * i - 1\n            invariant forall j :: 0 <= j < |interspersed| ==> j % 2 == 0 ==> \n                        interspersed[j] == numbers[j / 2]\n            invariant forall j :: 0 <= j < |interspersed| ==> j % 2 == 1 ==>\n                        interspersed[j] == delimiter\n        {\n            interspersed := interspersed + [delimiter, numbers[i]];\n            i := i + 1;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted.dfy", "root", true, "", "", false, "BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted.dfy", "// <vc-preamble>\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\nghost predicate SortedSeq(a: seq<int>)\n\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n{\n  assume{:axiom} false;\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\n\n/*\n*/\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\n\n\n*/\n\n// TODO play with this for keys==Contents\n\n\nghost predicate SortedSeq(a: seq<int>)\n  //sequence is sorted from left to right\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n  // get index so that array stays sorted\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n{\n  assume{:axiom} false;\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\n/*\nmethod InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])\n{\n  assume{:axiom} false;\n}\n*/\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds\n\n// <vc-helpers>\nlemma InsertPreservesElements(a: seq<int>, key: int, idx: int)\n    requires 0 <= idx <= |a|\n    requires key !in a\n    ensures forall x :: x in a ==> x in a[..idx] + [key] + a[idx..]\n    ensures forall x :: x in a[..idx] + [key] + a[idx..] && x != key ==> x in a\n{\n}\n\nlemma InsertMaintainsSorted(a: seq<int>, key: int, idx: int)\n    requires sorted(a)\n    requires 0 <= idx <= |a|\n    requires idx > 0 ==> a[idx-1] < key\n    requires idx < |a| ==> key < a[idx]\n    ensures sorted(a[..idx] + [key] + a[idx..])\n{\n    var result := a[..idx] + [key] + a[idx..];\n    forall i, j | 0 <= i < j < |result|\n        ensures result[i] < result[j]\n    {\n        if i < idx && j < idx {\n            assert result[i] == a[i] && result[j] == a[j];\n        } else if i < idx && j == idx {\n            assert result[i] == a[i] && result[j] == key;\n        } else if i < idx && j > idx {\n            assert result[i] == a[i] && result[j] == a[j-1];\n        } else if i == idx && j > idx {\n            assert result[i] == key && result[j] == a[j-1];\n        } else if i > idx && j > idx {\n            assert result[i] == a[i-1] && result[j] == a[j-1];\n        }\n    }\n}\n\nlemma ElementsInResult(a: array<int>, b: array<int>, limit: int, idx: int)\n    requires 0 <= idx <= limit < a.Length\n    requires b.Length == a.Length\n    requires forall k :: 0 <= k < idx && k < b.Length ==> b[k] == a[k]\n    requires idx < b.Length ==> b[idx] > 0\n    requires forall k :: idx + 1 <= k <= limit && k < b.Length ==> b[k] == a[k-1]\n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n{\n    forall i | 0 <= i < limit\n        ensures a[i] in b[..]\n    {\n        if i < idx {\n            assert b[i] == a[i];\n            assert a[i] in b[..];\n        } else {\n            assert i >= idx;\n            assert i + 1 <= limit;\n            assert b[i+1] == a[i];\n            assert a[i] in b[..];\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n// </vc-spec>\n// <vc-code>\n{\n    var idx := GetInsertIndex(a, limit, key);\n    b := new int[a.Length];\n    \n    var i := 0;\n    while i < idx\n        invariant 0 <= i <= idx\n        invariant forall k :: 0 <= k < i ==> b[k] == a[k]\n    {\n        b[i] := a[i];\n        i := i + 1;\n    }\n    \n    b[idx] := key;\n    \n    i := idx + 1;\n    while i <= limit\n        invariant idx + 1 <= i <= limit + 1\n        invariant forall k :: 0 <= k < idx ==> b[k] == a[k]\n        invariant b[idx] == key\n        invariant forall k :: idx + 1 <= k < i ==> b[k] == a[k-1]\n    {\n        b[i] := a[i-1];\n        i := i + 1;\n    }\n    \n    i := limit + 1;\n    while i < a.Length\n        invariant limit + 1 <= i <= a.Length\n        invariant forall k :: 0 <= k < idx ==> b[k] == a[k]\n        invariant b[idx] == key\n        invariant forall k :: idx + 1 <= k <= limit ==> b[k] == a[k-1]\n        invariant forall k :: limit + 1 <= k < i ==> b[k] == 0\n    {\n        b[i] := 0;\n        i := i + 1;\n    }\n    \n    assert b[..limit+1] == a[..idx] + [key] + a[idx..limit];\n    InsertMaintainsSorted(a[..limit], key, idx);\n    InsertPreservesElements(a[..limit], key, idx);\n    ElementsInResult(a, b, limit, idx);\n}\n// </vc-code>\n\n", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NoDups (a : array<int>) returns (noDups : bool)\n    requires forall j : int :: 0 < j < a.Length ==> a[j-1] <= a[j]\n    ensures noDups <==> forall j : int :: 1 <= j < a.Length ==> a[j-1] != a[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod NoDups (a : array<int>) returns (noDups : bool)\n    requires forall j : int :: 0 < j < a.Length ==> a[j-1] <= a[j] // a sorted\n    ensures noDups <==> forall j : int :: 1 <= j < a.Length ==> a[j-1] != a[j]\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  \n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k : int :: 1 <= k < i ==> a[k-1] != a[k]\n  {\n    if a[i-1] == a[i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  \n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_435_LastDigit.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_435_LastDigit.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LastDigit(n: int) returns (d: int)\n    requires n >= 0\n    ensures 0 <= d < 10\n    ensures n % 10 == d\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LastDigit(n: int) returns (d: int)\n    requires n >= 0\n    ensures 0 <= d < 10\n    ensures n % 10 == d\n// </vc-spec>\n// <vc-code>\n{\n  d := n % 10;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_424_ExtractRearChars.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_424_ExtractRearChars.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n// </vc-spec>\n// <vc-code>\n{\n  r := [];\n  var i := 0;\n  while i < |l|\n    invariant 0 <= i <= |l|\n    invariant |r| == i\n    invariant forall j :: 0 <= j < i ==> r[j] == l[j][|l[j]| - 1]\n  {\n    r := r + [l[i][|l[i]| - 1]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_762_IsMonthWith30Days.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_762_IsMonthWith30Days.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsMonthWith30Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month == 4 || month == 6 || month == 9 || month == 11\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsMonthWith30Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month == 4 || month == 6 || month == 9 || month == 11\n// </vc-spec>\n// <vc-code>\n{\n    result := month == 4 || month == 6 || month == 9 || month == 11;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_784_ProductEvenOdd.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_784_ProductEvenOdd.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}\n\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ProductEvenOdd(lst: seq<int>) returns (product : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures exists i, j :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst) && \n                           0 <= j < |lst| && IsOdd(lst[j])  && IsFirstOdd(j, lst) && product == lst[i] * lst[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}\n\n\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n    // This is the postcondition that ensures that it's the first, not just any\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma FirstEvenOddIndicesCorrect(lst: seq<int>, evenIndex: int, oddIndex: int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    requires 0 <= evenIndex < |lst|\n    requires 0 <= oddIndex < |lst|\n    requires IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    requires IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n    ensures exists i, j :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst) && \n                           0 <= j < |lst| && IsOdd(lst[j]) && IsFirstOdd(j, lst) && lst[evenIndex] * lst[oddIndex] == lst[i] * lst[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ProductEvenOdd(lst: seq<int>) returns (product : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures exists i, j :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst) && \n                           0 <= j < |lst| && IsOdd(lst[j])  && IsFirstOdd(j, lst) && product == lst[i] * lst[j]\n// </vc-spec>\n// <vc-code>\n{\n    var evenIdx, oddIdx := FirstEvenOddIndices(lst);\n    product := lst[evenIdx] * lst[oddIdx];\n    FirstEvenOddIndicesCorrect(lst, evenIdx, oddIdx);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_618_ElementWiseDivide.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_618_ElementWiseDivide.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseDivide(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseDivide(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>\n// <vc-code>\n{\n  result := [];\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == a[j] / b[j]\n  {\n    result := result + [a[i] / b[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_convert_map_key_convert_map_key.dfy", "root", true, "", "", false, "Clover_convert_map_key_convert_map_key.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod convert_map_key(inputs: map<nat, bool>, f: nat->nat) returns(r:map<nat, bool>)\n  requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)\n  ensures forall k :: k in inputs <==> f(k) in r\n  ensures forall k :: k in inputs ==> r[f(k)] == inputs[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod convert_map_key(inputs: map<nat, bool>, f: nat->nat) returns(r:map<nat, bool>)\n  requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)\n  ensures forall k :: k in inputs <==> f(k) in r\n  ensures forall k :: k in inputs ==> r[f(k)] == inputs[k]\n// </vc-spec>\n// <vc-code>\n{\n  r := map[];\n  var keys := inputs.Keys;\n  while keys != {}\n    invariant forall k :: k in inputs.Keys - keys ==> f(k) in r\n    invariant forall k :: k in inputs.Keys - keys ==> r[f(k)] == inputs[k]\n    invariant forall k :: k in r ==> exists k' :: k' in inputs.Keys - keys && k == f(k')\n    invariant keys <= inputs.Keys\n    decreases |keys|\n  {\n    var k :| k in keys;\n    assert k in inputs.Keys;\n    assert k in inputs;\n    r := r[f(k) := inputs[k]];\n    keys := keys - {k};\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_127_Multiply.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_127_Multiply.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Multiply(a: int, b: int) returns (result: int)\n  ensures result == a * b\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Multiply(a: int, b: int) returns (result: int)\n  ensures result == a * b\n// </vc-spec>\n// <vc-code>\n{\n  if b == 0 {\n    result := 0;\n  } else if b > 0 {\n    result := 0;\n    var i := 0;\n    while i < b\n      invariant 0 <= i <= b\n      invariant result == a * i\n    {\n      result := result + a;\n      i := i + 1;\n    }\n  } else {\n    result := 0;\n    var i := 0;\n    while i < -b\n      invariant 0 <= i <= -b\n      invariant result == a * i\n    {\n      result := result + a;\n      i := i + 1;\n    }\n    result := -result;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_577_FactorialOfLastDigit.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_577_FactorialOfLastDigit.dfy", "// <vc-preamble>\nfunction Factorial(n: int): int\n    requires n >= 0\n    ensures 0 <= Factorial(n)\n    {\n        if n == 0 then 1\n        else n * Factorial(n-1)\n    }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FactorialOfLastDigit(n: int) returns (fact: int)\n    requires n >= 0\n    ensures fact == Factorial(n % 10)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Factorial(n: int): int\n    requires n >= 0\n    ensures 0 <= Factorial(n)\n    {\n        if n == 0 then 1\n        else n * Factorial(n-1)\n    }\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod FactorialOfLastDigit(n: int) returns (fact: int)\n    requires n >= 0\n    ensures fact == Factorial(n % 10)\n// </vc-spec>\n// <vc-code>\n{\n  var lastDigit := n % 10;\n  fact := Factorial(lastDigit);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count.dfy", "root", true, "", "", false, "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count.dfy", "// <vc-preamble>\nfunction has_count(v: int, a: array<int>, n: int): int\n    reads a\n    requires n >= 0 && n <= a.Length\n{\n    if n == 0 then 0 else\n    (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod count (v: int, a: array<int>, n: int) returns (r: int)\n    requires n >= 0 && n <= a.Length;\n    ensures has_count(v, a, n) == r;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function has_count(v: int, a: array<int>, n: int): int\n    reads a  // This allows the function to read from array 'a'\n    requires n >= 0 && n <= a.Length\n{\n    if n == 0 then 0 else\n    (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n}\n\n// <vc-helpers>\nlemma has_count_step(v: int, a: array<int>, n: int)\n    requires n >= 0 && n <= a.Length\n    ensures n > 0 ==> has_count(v, a, n) == (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n{\n    if n > 0 {\n        // follows from definition\n    }\n}\n\nlemma has_count_base(v: int, a: array<int>)\n    ensures has_count(v, a, 0) == 0\n{\n    // follows from definition\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod count (v: int, a: array<int>, n: int) returns (r: int)\n    requires n >= 0 && n <= a.Length;\n    ensures has_count(v, a, n) == r;\n// </vc-spec>\n// <vc-code>\n{\n    r := 0;\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant r == has_count(v, a, i)\n    {\n        if a[i] == v {\n            r := r + 1;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_641_NthNonagonalNumber.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_641_NthNonagonalNumber.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NthNonagonalNumber(n: int) returns (number: int)\n    requires n >= 0\n    ensures number == n * (7 * n - 5) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod NthNonagonalNumber(n: int) returns (number: int)\n    requires n >= 0\n    ensures number == n * (7 * n - 5) / 2\n// </vc-spec>\n// <vc-code>\n{\n  number := n * (7 * n - 5) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect.dfy", "root", true, "", "", false, "Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect.dfy", "// <vc-preamble>\ndatatype Exp = Const(int) | Var(string) | Plus(Exp, Exp) |  Mult(Exp, Exp)\n\nfunction eval(e:Exp, store:map<string, int>):int\n{\n    match(e)\n        case Const(n) => n\n        case Var(s) => if(s in store) then store[s] else -1\n        case Plus(e1, e2) => eval(e1, store) + eval(e2, store)\n        case Mult(e1, e2) => eval(e1, store) * eval(e2, store)\n}\n\nfunction optimize(e:Exp):Exp\n{\n    match e\n    case Mult(Const(0), e) => Const(0)\n    case Mult(e, Const(0)) => Const(0)\n    case Mult(Const(1), e) => e\n    case Mult(e, Const(1)) => e\n    case Mult(Const(n1), Const(n2)) => Const(n1*n2)\n    case Plus(Const(0), e) => e\n    case Plus(e, Const(0)) => e\n    case Plus(Const(n1), Const(n2)) => Const(n1+ n2)\n    case e => e\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod optimizeCorrect(e:Exp, s:map<string, int>)\nensures eval(e,s) == eval(optimize(e), s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Exp = Const(int) | Var(string) | Plus(Exp, Exp) |  Mult(Exp, Exp)\n\nfunction eval(e:Exp, store:map<string, int>):int\n{\n    match(e)\n        case Const(n) => n\n        case Var(s) => if(s in store) then store[s] else -1\n        case Plus(e1, e2) => eval(e1, store) + eval(e2, store)\n        case Mult(e1, e2) => eval(e1, store) * eval(e2, store)\n}\n\n//fill this function in to make optimizeFeatures work\nfunction optimize(e:Exp):Exp\n{\n    match e\n    case Mult(Const(0), e) => Const(0)\n    case Mult(e, Const(0)) => Const(0)\n    case Mult(Const(1), e) => e\n    case Mult(e, Const(1)) => e\n    case Mult(Const(n1), Const(n2)) => Const(n1*n2)\n    case Plus(Const(0), e) => e\n    case Plus(e, Const(0)) => e\n    case Plus(Const(n1), Const(n2)) => Const(n1+ n2)\n    case e => e\n\n} \n\n//as you write optimize this will become unproved\n//you must write proof code so that Dafny can prove this\n\n// <vc-helpers>\nlemma optimizePreservesEval(e: Exp, s: map<string, int>)\n    ensures eval(e, s) == eval(optimize(e), s)\n{\n    match e {\n        case Const(n) => \n            assert optimize(e) == e;\n        case Var(name) => \n            assert optimize(e) == e;\n        case Plus(e1, e2) =>\n            match e {\n                case Plus(Const(0), e2) => \n                    assert eval(e, s) == 0 + eval(e2, s) == eval(e2, s);\n                    assert optimize(e) == e2;\n                case Plus(e1, Const(0)) => \n                    assert eval(e, s) == eval(e1, s) + 0 == eval(e1, s);\n                    assert optimize(e) == e1;\n                case Plus(Const(n1), Const(n2)) => \n                    assert eval(e, s) == n1 + n2;\n                    assert optimize(e) == Const(n1 + n2);\n                    assert eval(optimize(e), s) == n1 + n2;\n                case _ => \n                    assert optimize(e) == e;\n            }\n        case Mult(e1, e2) =>\n            match e {\n                case Mult(Const(0), e2) => \n                    assert eval(e, s) == 0 * eval(e2, s) == 0;\n                    assert optimize(e) == Const(0);\n                    assert eval(optimize(e), s) == 0;\n                case Mult(e1, Const(0)) => \n                    assert eval(e, s) == eval(e1, s) * 0 == 0;\n                    assert optimize(e) == Const(0);\n                    assert eval(optimize(e), s) == 0;\n                case Mult(Const(1), e2) => \n                    assert eval(e, s) == 1 * eval(e2, s) == eval(e2, s);\n                    assert optimize(e) == e2;\n                case Mult(e1, Const(1)) => \n                    assert eval(e, s) == eval(e1, s) * 1 == eval(e1, s);\n                    assert optimize(e) == e1;\n                case Mult(Const(n1), Const(n2)) => \n                    assert eval(e, s) == n1 * n2;\n                    assert optimize(e) == Const(n1 * n2);\n                    assert eval(optimize(e), s) == n1 * n2;\n                case _ => \n                    assert optimize(e) == e;\n            }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod optimizeCorrect(e:Exp, s:map<string, int>)\nensures eval(e,s) == eval(optimize(e), s)\n// </vc-spec>\n// <vc-code>\n{\n    optimizePreservesEval(e, s);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetEven(s: array<nat>) modifies s\nensures forall i :: 0 <= i < s.Length ==> \n                                if old(s[i]) % 2 == 1 then s[i] == old(s[i]) + 1\n                                else s[i] == old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetEven(s: array<nat>) modifies s\nensures forall i :: 0 <= i < s.Length ==> \n                                if old(s[i]) % 2 == 1 then s[i] == old(s[i]) + 1\n                                else s[i] == old(s[i])\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> \n                         if old(s[j]) % 2 == 1 then s[j] == old(s[j]) + 1\n                         else s[j] == old(s[j])\n    invariant forall j :: i <= j < s.Length ==> s[j] == old(s[j])\n  {\n    if s[i] % 2 == 1 {\n      s[i] := s[i] + 1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Longest_Increasing_Subsequence_longest_increasing_subsequence_longest_increasing_subsequence.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Longest_Increasing_Subsequence_longest_increasing_subsequence_longest_increasing_subsequence.dfy", "// <vc-preamble>\nfunction find_max(x: int, y: int): int\n{\n    if x > y then x\n    else y\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod longest_increasing_subsequence(nums: array<int>) returns (max: int)\n    requires 1 <= nums.Length <= 2500\n    requires forall i :: 0 <= i < nums.Length ==> -10000 <= nums[i] <= 10000\n\n    ensures max >= 1\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_769_Difference.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_769_Difference.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\npredicate IsDistinct(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n}\n\nlemma DistinctPreservation(s: seq<int>, x: int)\n    requires IsDistinct(s)\n    requires x !in s\n    ensures IsDistinct(s + [x])\n{\n    var result := s + [x];\n    forall i, j | 0 <= i < j < |result|\n        ensures result[i] != result[j]\n    {\n        if j == |s| {\n            assert result[j] == x;\n            assert result[i] == s[i];\n            assert x !in s;\n            assert result[i] != result[j];\n        } else {\n            assert result[i] == s[i];\n            assert result[j] == s[j];\n            assert s[i] != s[j];\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n// </vc-spec>\n// <vc-code>\n{\n    diff := [];\n    var i := 0;\n    while i < |a|\n        invariant 0 <= i <= |a|\n        invariant forall x :: x in diff <==> (x in a[..i] && x !in b)\n        invariant IsDistinct(diff)\n    {\n        if a[i] in b {\n            i := i + 1;\n        } else if a[i] in diff {\n            i := i + 1;\n        } else {\n            DistinctPreservation(diff, a[i]);\n            diff := diff + [a[i]];\n            i := i + 1;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained.dfy", "// <vc-preamble>\npredicate strictSorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate strictSorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\n\n// <vc-helpers>\nlemma strictSortedImpliesNoDuplicates(s: seq<int>)\n    requires strictSorted(s)\n    ensures forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n{\n}\n\nlemma strictSortedSlice(s: seq<int>, start: int, end: int)\n    requires strictSorted(s)\n    requires 0 <= start <= end <= |s|\n    ensures strictSorted(s[start..end])\n{\n}\n\nlemma searchInStrictSorted(arr: array<int>, target: int, left: int, right: int) returns (found: bool, index: int)\n    requires strictSorted(arr[..])\n    requires 0 <= left <= right <= arr.Length\n    ensures found ==> left <= index < right && arr[index] == target\n    ensures !found ==> forall k :: left <= k < right ==> arr[k] != target\n    ensures found ==> target in arr[left..right]\n    ensures !found ==> target !in arr[left..right]\n{\n    var i := left;\n    found := false;\n    index := -1;\n    \n    while i < right\n        invariant left <= i <= right\n        invariant !found ==> forall k :: left <= k < i ==> arr[k] != target\n        invariant found ==> left <= index < i && arr[index] == target\n    {\n        if arr[i] == target {\n            found := true;\n            index := i;\n            return;\n        } else if arr[i] > target {\n            return;\n        }\n        i := i + 1;\n    }\n}\n\nlemma strictSortedImpliesOrdering(s: seq<int>, i: int, j: int)\n    requires strictSorted(s)\n    requires 0 <= i < j < |s|\n    ensures s[i] < s[j]\n{\n}\n\nlemma containmentHelper(v: array<int>, w: array<int>, n: int, m: int, i: int, j: int)\n    requires strictSorted(v[..])\n    requires strictSorted(w[..])\n    requires v.Length >= n && w.Length >= m\n    requires 0 <= i <= n && 0 <= j <= m\n    requires forall k :: 0 <= k < i ==> v[k] in w[..m]\n    requires i < n\n    requires forall x :: 0 <= x < j ==> w[x] < v[i]\n    ensures v[i] in w[..m] ==> exists y :: j <= y < m && w[y] == v[i]\n{\n    if v[i] in w[..m] {\n        assert exists y :: 0 <= y < m && w[y] == v[i];\n        var y :| 0 <= y < m && w[y] == v[i];\n        if y < j {\n            assert w[y] < v[i] && w[y] == v[i];\n            assert false;\n        }\n        assert j <= y < m && w[y] == v[i];\n    }\n}\n\nlemma notFoundLemma(v: array<int>, w: array<int>, n: int, m: int, i: int, j: int)\n    requires strictSorted(v[..])\n    requires strictSorted(w[..])\n    requires v.Length >= n && w.Length >= m\n    requires 0 <= i < n && 0 <= j <= m\n    requires forall x :: 0 <= x < j ==> (i == 0 || w[x] < v[i])\n    requires j == m\n    requires i > 0\n    ensures v[i] !in w[..m]\n{\n    if v[i] in w[..m] {\n        var y :| 0 <= y < m && w[y] == v[i];\n        assert w[y] < v[i];\n        assert false;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    var j := 0;\n    b := true;\n    \n    while i < n && j < m && b\n        invariant 0 <= i <= n && 0 <= j <= m\n        invariant b ==> forall k :: 0 <= k < i ==> v[k] in w[..m]\n        invariant !b ==> exists k :: 0 <= k < i && v[k] !in w[..m]\n        invariant i > 0 ==> forall x :: 0 <= x < j ==> w[x] < v[i]\n        decreases if b then n - i else 0\n    {\n        if v[i] == w[j] {\n            i := i + 1;\n            j := j + 1;\n        } else if v[i] < w[j] {\n            b := false;\n        } else {\n            j := j + 1;\n        }\n    }\n    \n    if i < n && b {\n        if j == m && i > 0 {\n            notFoundLemma(v, w, n, m, i, j);\n        }\n        b := false;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-duck_tmp_tmplawbgxjo_p1_SumArray.dfy", "root", true, "", "", false, "dafny-duck_tmp_tmplawbgxjo_p1_SumArray.dfy", "// <vc-preamble>\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Given an array of integers, it returns the sum. [1,3,3,2]->9\n\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\n\n// <vc-helpers>\nlemma SumIncremental(xs: seq<int>, i: int)\n    requires 0 <= i < |xs|\n    ensures Sum(xs[..i+1]) == Sum(xs[..i]) + xs[i]\n{\n    if i == 0 {\n        assert xs[..1] == [xs[0]];\n        assert Sum(xs[..1]) == Sum([xs[0]]) == xs[0];\n        assert xs[..0] == [];\n        assert Sum(xs[..0]) == 0;\n    } else {\n        var prefix := xs[..i+1];\n        assert prefix == xs[..i] + [xs[i]];\n        assert |prefix| == i + 1;\n        assert prefix[..|prefix|-1] == xs[..i];\n        assert prefix[|prefix|-1] == xs[i];\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n// </vc-spec>\n// <vc-code>\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\n        invariant 0 <= i <= xs.Length\n        invariant s == Sum(xs[..i])\n    {\n        SumIncremental(xs[..], i);\n        s := s + xs[i];\n        i := i + 1;\n    }\n    assert i == xs.Length;\n    assert xs[..i] == xs[..];\n}\n// </vc-code>\n\n", "", "", ""], ["Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max.dfy", "root", true, "", "", false, "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a:array<int>) returns(max:int)\n    requires a != null;\n    ensures forall j :: j >= 0 && j < a.Length ==> max >= a[j];\n    ensures a.Length > 0 ==> exists j :: j >= 0 && j < a.Length && max == a[j];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// http://verifythus.cost-ic0701.org/common-example/arraymax-in-dafny\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a:array<int>) returns(max:int)\n    requires a != null;\n    ensures forall j :: j >= 0 && j < a.Length ==> max >= a[j]; //max is larger then anything in the array\n    ensures a.Length > 0 ==> exists j :: j >= 0 && j < a.Length && max == a[j]; //max is an element in the array\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length == 0 {\n    max := 0;\n  } else {\n    max := a[0];\n    var i := 1;\n    while i < a.Length\n      invariant 1 <= i <= a.Length\n      invariant forall k :: 0 <= k < i ==> max >= a[k]\n      invariant exists k :: 0 <= k < i && max == a[k]\n    {\n      if a[i] > max {\n        max := a[i];\n      }\n      i := i + 1;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_swap_bitvector_SwapBitvectors.dfy", "root", true, "", "", false, "Clover_swap_bitvector_SwapBitvectors.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  x := Y;\n  y := X;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_abs_Abs.dfy", "root", true, "", "", false, "Clover_abs_Abs.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n// </vc-spec>\n// <vc-code>\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_233_CylinderLateralSurfaceArea.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_233_CylinderLateralSurfaceArea.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CylinderLateralSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * (radius * height) * 3.14\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod CylinderLateralSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * (radius * height) * 3.14\n// </vc-spec>\n// <vc-code>\n{\n  area := 2.0 * (radius * height) * 3.14;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_625_SwapFirstAndLast.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_625_SwapFirstAndLast.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1])\n    ensures a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1])\n    ensures a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length == 1 {\n    return;\n  }\n  var temp := a[0];\n  a[0] := a[a.Length - 1];\n  a[a.Length - 1] := temp;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_809_IsSmaller.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_809_IsSmaller.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSmaller(a: seq<int>, b: seq<int>) returns (result: bool)\n    requires |a| == |b|\n    ensures result <==> forall i :: 0 <= i < |a| ==> a[i] > b[i]\n    ensures !result <==> exists i :: 0 <= i < |a| && a[i] <= b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma ExistsNotForall(a: seq<int>, b: seq<int>)\n    requires |a| == |b|\n    ensures (exists i :: 0 <= i < |a| && a[i] <= b[i]) <==> !(forall i :: 0 <= i < |a| ==> a[i] > b[i])\n{\n    if exists i :: 0 <= i < |a| && a[i] <= b[i] {\n        var j :| 0 <= j < |a| && a[j] <= b[j];\n        assert !(forall i :: 0 <= i < |a| ==> a[i] > b[i]);\n    }\n    \n    if !(forall i :: 0 <= i < |a| ==> a[i] > b[i]) {\n        assert exists i :: 0 <= i < |a| && a[i] <= b[i];\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsSmaller(a: seq<int>, b: seq<int>) returns (result: bool)\n    requires |a| == |b|\n    ensures result <==> forall i :: 0 <= i < |a| ==> a[i] > b[i]\n    ensures !result <==> exists i :: 0 <= i < |a| && a[i] <= b[i]\n// </vc-spec>\n// <vc-code>\n{\n    result := true;\n    var i := 0;\n    \n    while i < |a|\n        invariant 0 <= i <= |a|\n        invariant result <==> forall j :: 0 <= j < i ==> a[j] > b[j]\n    {\n        if a[i] <= b[i] {\n            result := false;\n            break;\n        }\n        i := i + 1;\n    }\n    \n    ExistsNotForall(a, b);\n}\n// </vc-code>\n\n", "", "", ""], ["Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards.dfy", "root", true, "", "", false, "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards.dfy", "// <vc-preamble>\nfunction fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumBackwards(n: nat) returns (r: nat)\n  ensures r == sum(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}\n\n// <vc-helpers>\nlemma SumProperty(n: nat)\n  ensures sum(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sum(0) == 0;\n    assert 0 * 1 / 2 == 0;\n  } else {\n    SumProperty(n - 1);\n    assert sum(n) == n + sum(n - 1);\n    assert sum(n - 1) == (n - 1) * n / 2;\n    assert sum(n) == n + (n - 1) * n / 2;\n    assert sum(n) == (2 * n + (n - 1) * n) / 2;\n    assert sum(n) == (2 * n + n * n - n) / 2;\n    assert sum(n) == (n + n * n) / 2;\n    assert sum(n) == n * (1 + n) / 2;\n    assert sum(n) == n * (n + 1) / 2;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sumBackwards(n: nat) returns (r: nat)\n  ensures r == sum(n)\n// </vc-spec>\n// <vc-code>\n{\n  r := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant r == i * (i + 1) / 2\n  {\n    i := i + 1;\n    r := r + i;\n  }\n  SumProperty(n);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_replace_replace.dfy", "root", true, "", "", false, "Clover_replace_replace.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod replace(arr: array<int>, k: int)\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) > k ==> arr[i] == -1\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) <= k ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod replace(arr: array<int>, k: int)\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) > k ==> arr[i] == -1\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) <= k ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant forall j :: 0 <= j < i ==> old(arr[j]) > k ==> arr[j] == -1\n    invariant forall j :: 0 <= j < i ==> old(arr[j]) <= k ==> arr[j] == old(arr[j])\n    invariant forall j :: i <= j < arr.Length ==> arr[j] == old(arr[j])\n  {\n    if arr[i] > k {\n      arr[i] := -1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_SelectionSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_SelectionSort.dfy", "// <vc-preamble>\npredicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SelectionSort(a: array<int>)\n    modifies a\n    ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin.dfy", "root", true, "", "", false, "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin.dfy", "// <vc-preamble>\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal verification of the selection sort algorithm with Dafny.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a miminum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n// </vc-spec>\n// <vc-code>\n{\n  index := from;\n  var i := from + 1;\n  while i < to\n    invariant from <= index < to\n    invariant from < i <= to\n    invariant forall k :: from <= k < i ==> a[k] >= a[index]\n  {\n    if a[i] < a[index] {\n      index := i;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_586_SplitAndAppend.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_586_SplitAndAppend.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitAndAppend(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0 && n < |l|\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i + n) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitAndAppend(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0 && n < |l|\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i + n) % |l|]\n// </vc-spec>\n// <vc-code>\n{\n  r := l[n..] + l[..n];\n}\n// </vc-code>\n\n", "", "", ""], ["BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert.dfy", "root", true, "", "", false, "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert.dfy", "// <vc-preamble>\ndatatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\n\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod insert(tree: Tree, value : int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures BinarySearchTree(res)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\n\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma insertRecursionPreservesOrder(tree: Tree, value: int, res: Tree)\n  requires BinarySearchTree(tree)\n  requires res == insertRecursionImpl(tree, value)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n{\n  match tree\n  case Empty => \n    assert res == Node(Empty, value, Empty);\n  case Node(left, v, right) =>\n    if value < v {\n      insertRecursionPreservesOrder(left, value, insertRecursionImpl(left, value));\n    } else if value > v {\n      insertRecursionPreservesOrder(right, value, insertRecursionImpl(right, value));\n    }\n}\n\nfunction insertRecursionImpl(tree: Tree, value: int): Tree\n  requires BinarySearchTree(tree)\n  decreases tree\n{\n  match tree\n  case Empty => Node(Empty, value, Empty)\n  case Node(left, v, right) =>\n    if value < v then\n      Node(insertRecursionImpl(left, value), v, right)\n    else if value > v then\n      Node(left, v, insertRecursionImpl(right, value))\n    else\n      tree\n}\n\nlemma insertRecursionCorrect(tree: Tree, value: int)\n  requires BinarySearchTree(tree)\n  ensures var res := insertRecursionImpl(tree, value); \n          res != Empty && BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(insertRecursionImpl(tree, value), x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(insertRecursionImpl(tree, value), x)\n{\n  var res := insertRecursionImpl(tree, value);\n  match tree\n  case Empty => \n    assert res == Node(Empty, value, Empty);\n    assert BinarySearchTree(res);\n  case Node(left, v, right) =>\n    if value < v {\n      insertRecursionCorrect(left, value);\n    } else if value > v {\n      insertRecursionCorrect(right, value);\n    }\n}\n\nmethod insertRecursionCorrectImpl(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  ensures res != Empty && BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n  decreases tree\n{\n  res := insertRecursionImpl(tree, value);\n  insertRecursionCorrect(tree, value);\n  insertRecursionPreservesOrder(tree, value, res);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod insert(tree: Tree, value : int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures BinarySearchTree(res)\n// </vc-spec>\n// <vc-code>\n{\n  res := insertRecursionCorrectImpl(tree, value);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum.dfy", "root", true, "", "", false, "Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum.dfy", "// <vc-preamble>\npredicate summingPair(i: nat, j: nat, nums: seq<int>, target: int)\n    requires i < |nums|\n    requires j < |nums|\n{\n    i != j &&  nums[i] + nums[j] == target\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))\n    requires exists i:nat,j:nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)\n    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate summingPair(i: nat, j: nat, nums: seq<int>, target: int)\n    requires i < |nums|\n    requires j < |nums|\n{\n    i != j &&  nums[i] + nums[j] == target\n}\n\n// <vc-helpers>\nlemma SummingPairSymmetric(i: nat, j: nat, nums: seq<int>, target: int)\n    requires i < |nums| && j < |nums|\n    ensures summingPair(i, j, nums, target) <==> summingPair(j, i, nums, target)\n{\n}\n\nlemma UniquePairExists(nums: seq<int>, target: int, i: nat, j: nat)\n    requires i < j < |nums|\n    requires summingPair(i, j, nums, target)\n    requires forall l: nat, m: nat :: l < m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)\n    ensures forall k: nat, l: nat :: k < |nums| && l < |nums| && summingPair(k, l, nums, target) ==> (k == i && l == j) || (k == j && l == i)\n{\n    forall k: nat, l: nat | k < |nums| && l < |nums| && summingPair(k, l, nums, target)\n        ensures (k == i && l == j) || (k == j && l == i)\n    {\n        if (k == i && l == j) || (k == j && l == i) {\n            // Already satisfied\n        } else {\n            // Must derive contradiction\n            if k < l {\n                // For ordered pair (k,l) with k < l\n                if k == i {\n                    // k == i, l != j, k < l means i < l\n                    if l < j {\n                        assert i < l < j < |nums| && i != i && l != j;\n                        assert false;\n                    } else {\n                        assert i < j < l < |nums| && i != i && l != j;\n                        assert false;\n                    }\n                } else if l == j {\n                    // l == j, k != i, k < l means k < j\n                    assert k < j < |nums| && k != i && j != j;\n                    assert false;\n                } else {\n                    // k != i && l != j\n                    assert k < l < |nums| && k != i && l != j;\n                    assert !summingPair(k, l, nums, target);\n                    assert false;\n                }\n            } else if l < k {\n                // For ordered pair (l,k) with l < k, use symmetry\n                SummingPairSymmetric(k, l, nums, target);\n                assert summingPair(l, k, nums, target);\n                if l == i {\n                    // l == i, k != j, l < k means i < k\n                    if k < j {\n                        assert i < k < j < |nums| && i != i && k != j;\n                        assert false;\n                    } else {\n                        assert i < j < k < |nums| && i != i && k != j;\n                        assert false;\n                    }\n                } else if k == j {\n                    // k == j, l != i, l < k means l < j\n                    assert l < j < |nums| && l != i && j != j;\n                    assert false;\n                } else {\n                    // l != i && k != j\n                    assert l < k < |nums| && l != i && k != j;\n                    assert !summingPair(l, k, nums, target);\n                    assert false;\n                }\n            } else {\n                // k == l, but summingPair requires k != l\n                assert k == l;\n                assert !summingPair(k, l, nums, target);\n                assert false;\n            }\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))\n    requires exists i:nat,j:nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)\n    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target)\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    while i < |nums|\n        invariant 0 <= i <= |nums|\n        invariant forall k: nat, l: nat :: k < l < |nums| && k < i ==> !summingPair(k, l, nums, target)\n    {\n        var j := i + 1;\n        while j < |nums|\n            invariant i + 1 <= j <= |nums|\n            invariant forall l: nat :: i < l < j ==> !summingPair(i, l, nums, target)\n        {\n            if nums[i] + nums[j] == target {\n                assert summingPair(i, j, nums, target);\n                return (i, j);\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation.dfy", "root", true, "", "", false, "Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation.dfy", "// <vc-preamble>\ndatatype Valve = ON | OFF\n\nclass Pipe{\n   var v1: Valve;\n   var v2: Valve;\n   var v3: Valve;\n   var in_flowv1: int;\n   var in_flowv2: int;\n   var in_flowv3: int;\n\n   constructor()\n   {\n       this.v1:= OFF;\n       this.v2:= ON;\n   }\n\n}\nclass Tank\n{\n   var pipe: Pipe;\n   var height: int;\n    constructor()\n    {\n        pipe := new Pipe();\n    }\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod checkRegulation(tank: Tank)\n\nensures (tank.height>10 && tank.pipe.v1==OFF && tank.pipe.v3==ON && tank.pipe.v2==old(tank.pipe.v2)) \n|| (tank.height <8 && tank.pipe.v1== OFF && tank.pipe.v2== ON && tank.pipe.v3==old(tank.pipe.v3))\n|| ((tank.pipe.in_flowv3 >5 || tank.pipe.in_flowv1 >5 ) && tank.pipe.v2==OFF && tank.pipe.v3==old(tank.pipe.v3) && tank.pipe.v1==old(tank.pipe.v1))\nmodifies tank.pipe;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "datatype Valve = ON | OFF\n\nclass Pipe{\n   var v1: Valve; //outlet valve \n   var v2: Valve; //inlet Valve\n   var v3: Valve; //outlet valve\n   var in_flowv1: int; //flow in valve v1\n   var in_flowv2: int; //flow in vave v2\n   var in_flowv3: int; //flow in valve v3\n\n   constructor()\n   {\n       this.v1:= OFF;\n       this.v2:= ON;\n   }\n\n}\nclass Tank\n{\n   var pipe: Pipe;\n   var height: int;\n    constructor()\n    {\n        pipe := new Pipe();\n    }\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod checkRegulation(tank: Tank)\n //requires tank.pipe.v1==OFF && tank.pipe.v2==ON && (tank.pipe.v3==OFF || tank.pipe.v2==ON) \nensures (tank.height>10 && tank.pipe.v1==OFF && tank.pipe.v3==ON && tank.pipe.v2==old(tank.pipe.v2)) \n|| (tank.height <8 && tank.pipe.v1== OFF && tank.pipe.v2== ON && tank.pipe.v3==old(tank.pipe.v3))\n|| ((tank.pipe.in_flowv3 >5 || tank.pipe.in_flowv1 >5 ) && tank.pipe.v2==OFF && tank.pipe.v3==old(tank.pipe.v3) && tank.pipe.v1==old(tank.pipe.v1))\nmodifies tank.pipe;\n// </vc-spec>\n// <vc-code>\n{\n    if tank.height > 10 {\n        tank.pipe.v1 := OFF;\n        tank.pipe.v3 := ON;\n    } else if tank.height < 8 {\n        tank.pipe.v1 := OFF;\n        tank.pipe.v2 := ON;\n    } else if tank.pipe.in_flowv3 > 5 || tank.pipe.in_flowv1 > 5 {\n        tank.pipe.v2 := OFF;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_has_close_elements_has_close_elements.dfy", "root", true, "", "", false, "Clover_has_close_elements_has_close_elements.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  requires threshold >= 0.0\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nfunction abs(x: real): real\n{\n  if x >= 0.0 then x else -x\n}\n\nlemma abs_properties(x: real, y: real)\n  ensures abs(x - y) == abs(y - x)\n  ensures abs(x - y) >= 0.0\n{\n}\n\nlemma abs_definition(x: real, y: real)\n  ensures abs(x - y) == (if x - y < 0.0 then y - x else x - y)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  requires threshold >= 0.0\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < |numbers|\n    invariant 0 <= i <= |numbers|\n    invariant forall p: int, q: int :: 0 <= p < i && 0 <= q < |numbers| && p != q ==> abs(numbers[p] - numbers[q]) >= threshold\n  {\n    var j := 0;\n    while j < |numbers|\n      invariant 0 <= j <= |numbers|\n      invariant forall q: int :: 0 <= q < j && i != q ==> abs(numbers[i] - numbers[q]) >= threshold\n    {\n      if i != j {\n        abs_definition(numbers[i], numbers[j]);\n        var distance := if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j];\n        if distance < threshold {\n          return true;\n        }\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_demo_Partition.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_demo_Partition.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Partition(a: array<int>) returns (lo: int, hi: int)\n  modifies a\n  ensures 0 <= lo <= hi <= a.Length\n  ensures forall x | 0 <= x < lo :: a[x] < 0\n  ensures forall x | lo <= x < hi :: a[x] == 0\n  ensures forall x | hi <= x < a.Length :: a[x] > 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_565_SplitStringIntoChars.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_565_SplitStringIntoChars.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitStringIntoChars(s: string) returns (v: seq<char>)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SplitStringIntoChars(s: string) returns (v: seq<char>)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> v[i] == s[i]\n// </vc-spec>\n// <vc-code>\n{\n  v := [];\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant |v| == i\n    invariant forall j :: 0 <= j < i ==> v[j] == s[j]\n  {\n    v := v + [s[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive.dfy", "// <vc-preamble>\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search2PowRecursive( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    decreases n;\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// <vc-helpers>\nlemma Is2PowDivision(n: int)\n    requires n > 1 && Is2Pow(n)\n    ensures Is2Pow((n-1)/2 + 1)\n    decreases n\n{\n    if n == 2 {\n        assert (n-1)/2 + 1 == 1;\n        assert Is2Pow(1);\n    } else {\n        assert n % 2 == 0;\n        assert Is2Pow(n/2);\n        assert (n-1)/2 == n/2 - 1;\n        assert (n-1)/2 + 1 == n/2;\n        assert Is2Pow(n/2);\n    }\n}\n\nlemma ArrayBounds(a: array<int>, i: int, n: int)\n    requires 0 <= i <= i+n <= a.Length\n    requires n >= 1\n    ensures n >= 1 ==> 0 <= i + (n-1)/2 < a.Length\n    ensures n >= 1 ==> 0 <= i <= i + (n-1)/2 <= a.Length\n    ensures n >= 1 ==> 0 <= i + (n-1)/2 + 1 <= i + (n-1)/2 + 1 + (n-1)/2 <= a.Length\n{\n    if n >= 1 {\n        var mid := i + (n-1)/2;\n        assert mid < i + n;\n        assert mid + 1 + (n-1)/2 <= i + n;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search2PowRecursive( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    decreases n;\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n    if n == 1 {\n        if a[i] < x {\n            k := i + 1;\n        } else {\n            k := i;\n        }\n    } else {\n        ArrayBounds(a, i, n);\n        var mid := i + (n-1)/2;\n        if n > 1 {\n            Is2PowDivision(n+1);\n        }\n        if a[mid] < x {\n            k := Search2PowRecursive(a, mid + 1, (n-1)/2, x);\n        } else {\n            k := Search2PowRecursive(a, i, (n-1)/2, x);\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry.dfy", "root", true, "", "", false, "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry.dfy", "// <vc-preamble>\nmethod random(a: int, b: int) returns (r: int)\n  ensures a <= b ==> a <= r <= b\n\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: seq<T>) returns (e: T)\n  requires m_workList.Length > 0\n  ensures set_of_seq(avoidSet) < set_of_seq(m_workList[..]) ==> e !in avoidSet\n  ensures avoidSet < m_workList[..] ==> e in m_workList[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "method random(a: int, b: int) returns (r: int)\n//  requires a <= b\n  ensures a <= b ==> a <= r <= b\n\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\n\n// <vc-helpers>\nlemma proper_subset_exists<T>(s1: set<T>, s2: set<T>)\n  requires s1 < s2\n  ensures exists x :: x in s2 && x !in s1\n{\n}\n\nlemma seq_to_set_membership<T>(s: seq<T>, x: T)\n  ensures x in s ==> x in set_of_seq(s)\n  ensures x in set_of_seq(s) ==> x in s\n{\n}\n\nlemma array_element_in_set<T>(arr: array<T>, i: int)\n  requires 0 <= i < arr.Length\n  ensures arr[i] in set_of_seq(arr[..])\n{\n  assert arr[i] == arr[..][i];\n  assert arr[i] in arr[..];\n}\n\nlemma proper_subset_guarantees_element<T>(avoidSet: seq<T>, m_workList: array<T>)\n  requires set_of_seq(avoidSet) < set_of_seq(m_workList[..])\n  requires m_workList.Length > 0\n  ensures exists i :: 0 <= i < m_workList.Length && m_workList[i] !in avoidSet\n{\n  proper_subset_exists(set_of_seq(avoidSet), set_of_seq(m_workList[..]));\n  assert exists x :: x in set_of_seq(m_workList[..]) && x !in set_of_seq(avoidSet);\n  var x :| x in set_of_seq(m_workList[..]) && x !in set_of_seq(avoidSet);\n  seq_to_set_membership(m_workList[..], x);\n  assert x in m_workList[..];\n  seq_to_set_membership(avoidSet, x);\n  assert x !in avoidSet;\n  var i :| 0 <= i < m_workList.Length && m_workList[..][i] == x;\n  assert m_workList[i] == x;\n}\n\nlemma avoid_set_element_membership<T>(avoidSet: seq<T>, x: T)\n  ensures x in avoidSet ==> x in set_of_seq(avoidSet)\n  ensures x !in avoidSet ==> x !in set_of_seq(avoidSet)\n{\n  seq_to_set_membership(avoidSet, x);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: seq<T>) returns (e: T)\n  requires m_workList.Length > 0\n  ensures set_of_seq(avoidSet) < set_of_seq(m_workList[..]) ==> e !in avoidSet\n  ensures avoidSet < m_workList[..] ==> e in m_workList[..]\n// </vc-spec>\n// <vc-code>\n{\n  if set_of_seq(avoidSet) < set_of_seq(m_workList[..]) {\n    proper_subset_guarantees_element(avoidSet, m_workList);\n    var i := 0;\n    while i < m_workList.Length\n      invariant 0 <= i <= m_workList.Length\n      invariant exists j :: i <= j < m_workList.Length && m_workList[j] !in avoidSet\n    {\n      if m_workList[i] !in avoidSet {\n        array_element_in_set(m_workList, i);\n        avoid_set_element_membership(avoidSet, m_workList[i]);\n        return m_workList[i];\n      }\n      i := i + 1;\n    }\n    assert false;\n  } else {\n    array_element_in_set(m_workList, 0);\n    return m_workList[0];\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch.dfy", "root", true, "", "", false, "630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch.dfy", "// <vc-preamble>\nfunction sorted(a: array<int>) : bool\n    reads a\n{\n   forall i,j : int :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, x: int) returns (index: int)\n    requires sorted(a)\n    ensures 0 <= index < a.Length ==> a[index] == x\n    ensures index == -1 ==> forall i : int :: 0 <= i < a.Length ==> a[i] != x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sorted(a: array<int>) : bool\n    reads a\n{\n   forall i,j : int :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n// <vc-helpers>\nlemma SortedProperty(a: array<int>, low: int, high: int, x: int)\n    requires sorted(a)\n    requires 0 <= low <= high < a.Length\n    requires a[low] > x\n    ensures forall i :: low <= i < a.Length ==> a[i] > x\n{\n    forall i | low <= i < a.Length\n        ensures a[i] > x\n    {\n        if i > low {\n            assert a[low] <= a[i];\n            assert a[low] > x;\n        } else {\n            assert i == low;\n            assert a[i] > x;\n        }\n    }\n}\n\nlemma SortedPropertyUpper(a: array<int>, low: int, high: int, x: int)\n    requires sorted(a)\n    requires 0 <= low <= high < a.Length\n    requires a[high] < x\n    ensures forall i :: 0 <= i <= high ==> a[i] < x\n{\n    forall i | 0 <= i <= high\n        ensures a[i] < x\n    {\n        if i < high {\n            assert a[i] <= a[high];\n            assert a[high] < x;\n        } else {\n            assert i == high;\n            assert a[i] < x;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, x: int) returns (index: int)\n    requires sorted(a)\n    ensures 0 <= index < a.Length ==> a[index] == x\n    ensures index == -1 ==> forall i : int :: 0 <= i < a.Length ==> a[i] != x\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 0 {\n        return -1;\n    }\n    \n    var low := 0;\n    var high := a.Length - 1;\n    \n    while low <= high\n        invariant 0 <= low <= a.Length\n        invariant -1 <= high < a.Length\n        invariant low > high ==> forall i :: 0 <= i < a.Length ==> a[i] != x\n        invariant forall i :: 0 <= i < low ==> a[i] < x\n        invariant forall i :: high < i < a.Length ==> a[i] > x\n        decreases high - low + 1\n    {\n        var mid := (low + high) / 2;\n        \n        if a[mid] == x {\n            return mid;\n        } else if a[mid] < x {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n            SortedProperty(a, mid, high + 1, x);\n        }\n    }\n    \n    return -1;\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness.dfy", "root", true, "", "", false, "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness.dfy", "// <vc-preamble>\nghost predicate prime(n: nat)\n\n{ n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }\n\ndatatype Answer = Yes | No | Unknown\n\nclass {:autocontracts} PrimeMap{\n\n  var database: map<nat, bool>; \n\n  ghost predicate Valid()\n    reads this\n  {\n    forall i | i in database.Keys :: (database[i] == true <==> prime(i)) \n  }\n\n  constructor()\n    ensures database == map[]\n  {\n    database := map[];\n  }\n\nmethod IsPrime?(n: nat) returns (answer: Answer) \n      ensures database.Keys == old(database.Keys)\n      ensures (n in database) && prime(n) <==> answer == Yes \n      ensures (n in database) && !prime(n) <==> answer == No \n      ensures !(n in database) <==> answer == Unknown\n{\n  assume{:axiom} false;\n}\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod testPrimeness(n: nat) returns (result: bool) \n      requires n >= 0\n      ensures result <==> prime(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//predicate for primeness\nghost predicate prime(n: nat)\n\n{ n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }\n\ndatatype Answer = Yes | No | Unknown\n\n//the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number\n//is not in the database it returns Unknown\nclass {:autocontracts} PrimeMap{\n\n  var database: map<nat, bool>; \n\n//the valid invariant of the class\n  ghost predicate Valid()\n    reads this\n  {\n    forall i | i in database.Keys :: (database[i] == true <==> prime(i)) \n  }\n\n//the constructor\n  constructor()\n    ensures database == map[]\n  {\n    database := map[];\n  }\n\n\n  // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,\n  // or with Unknown when it's not in the databse\nmethod IsPrime?(n: nat) returns (answer: Answer) \n      ensures database.Keys == old(database.Keys)\n      ensures (n in database) && prime(n) <==> answer == Yes \n      ensures (n in database) && !prime(n) <==> answer == No \n      ensures !(n in database) <==> answer == Unknown\n{\n  assume{:axiom} false;\n}\n\n  // method to test whether a number is prime, returns bool\n\n}\n\n// <vc-helpers>\nlemma PrimeCharacterization(n: nat)\n  ensures prime(n) <==> (n > 1 && (forall k | 2 <= k < n :: n % k != 0))\n{\n  if n <= 1 {\n    assert !prime(n);\n  } else {\n    assert prime(n) <==> (forall nr | 1 < nr < n :: n % nr != 0);\n    assert (forall nr | 1 < nr < n :: n % nr != 0) <==> (forall k | 2 <= k < n :: n % k != 0);\n  }\n}\n\nlemma SmallPrimes()\n  ensures prime(2)\n  ensures prime(3)\n  ensures !prime(0)\n  ensures !prime(1)\n  ensures !prime(4)\n{\n  assert 2 > 1 && (forall nr | 1 < nr < 2 :: 2 % nr != 0);\n  assert 3 > 1 && (forall nr | 1 < nr < 3 :: 3 % nr != 0);\n  assert 4 % 2 == 0;\n}\n\nlemma PrimeByTrialDivision(n: nat)\n  requires n > 1\n  requires n % 2 != 0 || n == 2\n  requires forall k | 2 <= k * k <= n :: n % k != 0\n  ensures prime(n)\n{\n  PrimeCharacterization(n);\n  assert forall k | 2 <= k < n :: n % k != 0 by {\n    forall k | 2 <= k < n\n      ensures n % k != 0\n    {\n      if k * k <= n {\n        assert n % k != 0;\n      } else {\n        if n % k == 0 {\n          var q := n / k;\n          assert n == k * q;\n          assert q >= 1;\n          if q == 1 {\n            assert n == k;\n            assert k < n;\n            assert false;\n          } else {\n            assert q >= 2;\n            assert q * k == n;\n            assert q < k by {\n              if q >= k {\n                assert q * k >= k * k > n;\n                assert false;\n              }\n            }\n            assert 2 <= q <= q * k <= n;\n            assert q * q <= q * k == n;\n            assert n % q == 0;\n            assert false;\n          }\n        }\n      }\n    }\n  };\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod testPrimeness(n: nat) returns (result: bool) \n      requires n >= 0\n      ensures result <==> prime(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n <= 1 {\n    return false;\n  }\n  if n == 2 {\n    SmallPrimes();\n    return true;\n  }\n  if n % 2 == 0 {\n    PrimeCharacterization(n);\n    return false;\n  }\n  \n  var i := 3;\n  while i * i <= n\n    invariant i >= 3\n    invariant i % 2 == 1\n    invariant forall k | 2 <= k < i :: n % k != 0\n    decreases n - i * i + 1\n  {\n    if n % i == 0 {\n      PrimeCharacterization(n);\n      return false;\n    }\n    i := i + 2;\n  }\n  \n  assert forall k | 2 <= k * k <= n :: n % k != 0;\n  PrimeByTrialDivision(n);\n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex.dfy", "root", true, "", "", false, "BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex.dfy", "// <vc-preamble>\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\nghost predicate SortedSeq(a: seq<int>)\n\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\n\n/*\n*/\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\n\n\n*/\n\n// TODO play with this for keys==Contents\n\n\nghost predicate SortedSeq(a: seq<int>)\n  //sequence is sorted from left to right\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\n/*\nmethod InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])\n{\n  assume{:axiom} false;\n}\n*/\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma SortedSeqTransitive(a: seq<int>, i: int, j: int, k: int)\n  requires SortedSeq(a)\n  requires 0 <= i < j < k < |a|\n  ensures a[i] < a[k]\n{\n}\n\nlemma SortedSeqProperty(a: seq<int>, i: int, j: int)\n  requires SortedSeq(a)\n  requires 0 <= i <= j < |a|\n  ensures i < j ==> a[i] < a[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n  // get index so that array stays sorted\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n// </vc-spec>\n// <vc-code>\n{\n  idx := 0;\n  while idx < limit && a[idx] < x\n    invariant 0 <= idx <= limit\n    invariant SortedSeq(a[..limit])\n    invariant forall k :: 0 <= k < idx ==> a[k] < x\n    invariant idx < limit ==> forall k :: idx <= k < limit ==> a[idx] <= a[k]\n    decreases limit - idx\n  {\n    idx := idx + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton.dfy", "root", true, "", "", false, "DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton.dfy", "// <vc-preamble>\nclass Automaton {\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ExecuteAutomaton(init: seq<bool>, rule: (bool, bool, bool) -> bool, steps: nat)\n  returns (table: seq<seq<bool>>)\n\n  requires |init| >= 2\n\n  ensures |table| == 1 + steps\n\n  ensures table[0] == init;\n\n  ensures forall i | 0 <= i < |table| :: |table[i]| == |init|\n\n  ensures forall i | 0 <= i < |table| - 1 ::\n            forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])\n\n  ensures forall i | 0 <= i < |table| - 1 ::\n            table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\nConsider cellular automata: a row of cells is repeatedly updated according to a rule. In this exercise I dabbled with,\neach cell has the value either false or true. Each cell's next state depends only on the immediate neighbours, in the \ncase where the cell is at the edges of the row, the inexistent neighbours are replaced by \"false\". The automaton table \nwill contain the initial row, plus a row for each number of steps.\n */\nclass Automaton {\n\n/**\nThis method computes the automaton.\nProvide the initial row: init, the rule and the desired number of steps\n */\n\n}\n\n// <vc-helpers>\nlemma TablePropertiesPreserved(table: seq<seq<bool>>, newRow: seq<bool>, init: seq<bool>)\n  requires |table| >= 1\n  requires table[0] == init\n  requires |init| >= 2\n  requires forall i | 0 <= i < |table| :: |table[i]| == |init|\n  requires |newRow| == |init|\n  ensures |table + [newRow]| == |table| + 1\n  ensures (table + [newRow])[0] == init\n  ensures forall i | 0 <= i < |table + [newRow]| :: |(table + [newRow])[i]| == |init|\n{\n}\n\nlemma RuleApplicationCorrect(prevRow: seq<bool>, newRow: seq<bool>, rule: (bool, bool, bool) -> bool)\n  requires |prevRow| >= 2\n  requires |newRow| == |prevRow|\n  requires newRow[0] == rule(false, prevRow[0], prevRow[1])\n  requires newRow[|prevRow| - 1] == rule(prevRow[|prevRow| - 2], prevRow[|prevRow| - 1], false)\n  requires forall j | 1 <= j <= |prevRow| - 2 :: newRow[j] == rule(prevRow[j - 1], prevRow[j], prevRow[j + 1])\n  ensures forall j | 1 <= j <= |newRow| - 2 :: newRow[j] == rule(prevRow[j - 1], prevRow[j], prevRow[j + 1])\n  ensures newRow[0] == rule(false, prevRow[0], prevRow[1]) && newRow[|prevRow| - 1] == rule(prevRow[|prevRow| - 2], prevRow[|prevRow| - 1], false)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ExecuteAutomaton(init: seq<bool>, rule: (bool, bool, bool) -> bool, steps: nat)\n  returns (table: seq<seq<bool>>)\n  // we need the initial row to have the length bigger or equal to two\n  requires |init| >= 2\n  // after computation the automaton is made of the initial row plus a row for each of the steps\n  ensures |table| == 1 + steps\n  // the automaton must have the initial row at the top\n  ensures table[0] == init;\n  // all rows in the automaton must be the same length\n  ensures forall i | 0 <= i < |table| :: |table[i]| == |init|\n  // all the middle row elements (with existing neighbours) after a step, will be equal to the rule applied on the element in the previous state\n  // and its neigbours\n  ensures forall i | 0 <= i < |table| - 1 ::\n            forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])\n  // the corner row elements (with non-existing neighbours) after a step, will be equal to the rule applied on the element in the previous state,\n  // its neighbour and false\n  ensures forall i | 0 <= i < |table| - 1 ::\n            table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)\n// </vc-spec>\n// <vc-code>\n{\n  table := [init];\n  \n  var step := 0;\n  while step < steps\n    invariant 0 <= step <= steps\n    invariant |table| == 1 + step\n    invariant table[0] == init\n    invariant forall i | 0 <= i < |table| :: |table[i]| == |init|\n    invariant forall i | 0 <= i < |table| - 1 ::\n                forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])\n    invariant forall i | 0 <= i < |table| - 1 ::\n                table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)\n  {\n    var prevRow := table[|table| - 1];\n    var newRow := new bool[|init|];\n    \n    newRow[0] := rule(false, prevRow[0], prevRow[1]);\n    newRow[|init| - 1] := rule(prevRow[|init| - 2], prevRow[|init| - 1], false);\n    \n    var j := 1;\n    while j <= |init| - 2\n      invariant 1 <= j <= |init| - 1\n      invariant newRow[0] == rule(false, prevRow[0], prevRow[1])\n      invariant newRow[|init| - 1] == rule(prevRow[|init| - 2], prevRow[|init| - 1], false)\n      invariant forall k | 1 <= k < j :: newRow[k] == rule(prevRow[k - 1], prevRow[k], prevRow[k + 1])\n    {\n      newRow[j] := rule(prevRow[j - 1], prevRow[j], prevRow[j + 1]);\n      j := j + 1;\n    }\n    \n    var newRowSeq := newRow[..];\n    TablePropertiesPreserved(table, newRowSeq, init);\n    RuleApplicationCorrect(prevRow, newRowSeq, rule);\n    table := table + [newRowSeq];\n    step := step + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["CVS-handout1_tmp_tmptm52no3k_1_query.dfy", "root", true, "", "", false, "CVS-handout1_tmp_tmptm52no3k_1_query.dfy", "// <vc-preamble>\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod query(a: array<int>, i: int, j: int) returns (res:int)\n    requires 0 <= i <= j <= a.Length\n    ensures res == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\n\n\n//(b)\n\n//(c)\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}\n\n// <vc-helpers>\nlemma sum_slice_property(a: array<int>, i: int, j: int, k: int)\n    requires 0 <= i <= k <= j <= a.Length\n    ensures sum(a, i, j) == sum(a, i, k) + sum(a, k, j)\n    decreases j - i\n{\n    if i == k {\n        assert sum(a, i, k) == 0;\n    } else if k == j {\n        assert sum(a, k, j) == 0;\n    } else {\n        sum_slice_property(a, i+1, j, k);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod query(a: array<int>, i: int, j: int) returns (res:int)\n    requires 0 <= i <= j <= a.Length\n    ensures res == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n    if i == j {\n        res := 0;\n    } else {\n        var partial := query(a, i+1, j);\n        res := a[i] + partial;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter.dfy", "root", true, "", "", false, "MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter.dfy", "// <vc-preamble>\nfunction power(x: real, n: nat) : real\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerIter(b: real, n: nat) returns (p : real)\n    ensures p == power(b, n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, M.EIC, MFS, 2021/22.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).\n\n// <vc-helpers>\nlemma PowerAccumulator(x: real, n: nat, acc: real)\n    ensures acc * power(x, n) == power(x, n) * acc\n{\n    // Commutativity of multiplication\n}\n\nlemma PowerIterativeInvariant(x: real, i: nat, n: nat, acc: real)\n    requires i <= n\n    ensures acc * power(x, n - i) == acc * power(x, n - i)\n{\n    // Tautology to help with invariant reasoning\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerIter(b: real, n: nat) returns (p : real)\n    ensures p == power(b, n)\n// </vc-spec>\n// <vc-code>\n{\n    p := 1.0;\n    var i := 0;\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant p * power(b, n - i) == power(b, n)\n        decreases n - i\n    {\n        p := p * b;\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n// Recursive version, imperative, with time and space complexity O(log n).\n\n// A simple test case to make sure the specification is adequate.", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod replace(v:array<int>, x:int, y:int)\nmodifies v\nensures forall k::0<=k<old(v.Length) && old(v[k])==x ==> v[k]==y\nensures forall k::0<=k<old(v.Length) && old(v[k])!=x ==> v[k]==old(v[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod replace(v:array<int>, x:int, y:int)\nmodifies v\nensures forall k::0<=k<old(v.Length) && old(v[k])==x ==> v[k]==y\nensures forall k::0<=k<old(v.Length) && old(v[k])!=x ==> v[k]==old(v[k])\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < v.Length\n    invariant 0 <= i <= v.Length\n    invariant forall k :: 0 <= k < i && old(v[k]) == x ==> v[k] == y\n    invariant forall k :: 0 <= k < i && old(v[k]) != x ==> v[k] == old(v[k])\n    invariant forall k :: i <= k < v.Length ==> v[k] == old(v[k])\n  {\n    if v[i] == x {\n      v[i] := y;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_436_FindNegativeNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_436_FindNegativeNumbers.dfy", "// <vc-preamble>\npredicate IsNegative(n: int)\n{\n    n < 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindNegativeNumbers(arr: array<int>) returns (negativeList: seq<int>)\n\n    ensures forall i :: 0 <= i < |negativeList| ==> IsNegative(negativeList[i]) && negativeList[i] in arr[..]\n\n    ensures forall i :: 0 <= i < arr.Length && IsNegative(arr[i]) ==> arr[i] in negativeList\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n * Find negative numbers from an array of numbers\n **/\n\npredicate IsNegative(n: int)\n{\n    n < 0\n}\n\n// <vc-helpers>\nlemma SeqAppendPreservesProperty(s: seq<int>, x: int)\n    requires forall i :: 0 <= i < |s| ==> IsNegative(s[i])\n    requires IsNegative(x)\n    ensures forall i :: 0 <= i < |s + [x]| ==> IsNegative((s + [x])[i])\n{\n}\n\nlemma SeqAppendPreservesInArray(s: seq<int>, x: int, arr: array<int>)\n    requires forall i :: 0 <= i < |s| ==> s[i] in arr[..]\n    requires x in arr[..]\n    ensures forall i :: 0 <= i < |s + [x]| ==> (s + [x])[i] in arr[..]\n{\n}\n\nlemma SeqAppendPreservesAllNegatives(s: seq<int>, x: int, arr: array<int>, j: int)\n    requires 0 <= j < arr.Length\n    requires forall i :: 0 <= i < j && IsNegative(arr[i]) ==> arr[i] in s\n    requires IsNegative(arr[j])\n    ensures forall i :: 0 <= i <= j && IsNegative(arr[i]) ==> arr[i] in (s + [arr[j]])\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindNegativeNumbers(arr: array<int>) returns (negativeList: seq<int>)\n    // All numbers in the output are negative and exist in the input \n    ensures forall i :: 0 <= i < |negativeList| ==> IsNegative(negativeList[i]) && negativeList[i] in arr[..]\n    // All negative numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsNegative(arr[i]) ==> arr[i] in negativeList\n// </vc-spec>\n// <vc-code>\n{\n    negativeList := [];\n    var i := 0;\n    \n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant forall k :: 0 <= k < |negativeList| ==> IsNegative(negativeList[k]) && negativeList[k] in arr[..]\n        invariant forall k :: 0 <= k < i && IsNegative(arr[k]) ==> arr[k] in negativeList\n    {\n        if IsNegative(arr[i]) {\n            SeqAppendPreservesProperty(negativeList, arr[i]);\n            SeqAppendPreservesInArray(negativeList, arr[i], arr);\n            SeqAppendPreservesAllNegatives(negativeList, arr[i], arr, i);\n            negativeList := negativeList + [arr[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_array_append_append.dfy", "root", true, "", "", false, "Clover_array_append_append.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length + 1];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant c[..i] == a[..i]\n  {\n    c[i] := a[i];\n    i := i + 1;\n  }\n  c[a.Length] := b;\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n\nmethod strange()\nensures 1==2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn \u2208 \u2115 => sqn = 0*0 \u2227 i = 0 \u2227 x=? \u2227 i\u2264n \nn >= 0 => 0 = 0*0 \u2227 i = 0 \u2227 i\u2264n \nn >= 0 => 0 = 0*0 \u2227 0 \u2264 n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n \u2227 i+1 \u2264 n \u2227 sqn = i * i \u21d2 sqn = sqn + x \u2227 i = i + 1 \u2227 x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: \u00ac(i < n) \u2227 i \u2264 n \u2227 sqn = i * i \u21d2 sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 \u2264 n\n2. true, i < n => i + 1 <= n\n3. true, \u00ac(i < n) \u2227 i \u2264 n \u2227 sqn = i * i \u21d2 sqn = n * n since \u00ac(i < n) \u2227 i \u2264 n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n\nmethod strange()\nensures 1==2\n// </vc-spec>\n// <vc-code>\n{\n  var x:nat := 4; \n  var c := q(x, 2*x);\n  assert false;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_swap_sim_SwapSimultaneous.dfy", "root", true, "", "", false, "Clover_swap_sim_SwapSimultaneous.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>\n// <vc-code>\n{\n  x := Y;\n  y := X;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_array_sum_arraySum.dfy", "root", true, "", "", false, "Clover_array_sum_arraySum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length];\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant c.Length == a.Length\n    invariant forall j :: 0 <= j < i ==> c[j] == a[j] + b[j]\n  {\n    c[i] := a[i] + b[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_test_array_TestArrayElements.dfy", "root", true, "", "", false, "Clover_test_array_TestArrayElements.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod TestArrayElements(a:array<int>, j: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n  ensures forall k :: 0 <= k < a.Length && k != j ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod TestArrayElements(a:array<int>, j: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n  ensures forall k :: 0 <= k < a.Length && k != j ==> a[k] == old(a[k])\n// </vc-spec>\n// <vc-code>\n{\n  a[j] := 60;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_count_lessthan_CountLessThan.dfy", "root", true, "", "", false, "Clover_count_lessthan_CountLessThan.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SetComprehensionCardinality<T>(s: set<T>, p: T -> bool)\n  ensures |set x | x in s && p(x)| <= |s|\n{\n  var subset := set x | x in s && p(x);\n  assert subset <= s;\n}\n\nlemma SetComprehensionEquality(numbers: set<int>, threshold: int, filtered: set<int>)\n  requires filtered == set i | i in numbers && i < threshold\n  ensures |filtered| == |set i | i in numbers && i < threshold|\n{\n  assert filtered == set i | i in numbers && i < threshold;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n// </vc-spec>\n// <vc-code>\n{\n  count := 0;\n  var remaining := numbers;\n  var filtered := {};\n  \n  while remaining != {}\n    invariant filtered == set i | i in (numbers - remaining) && i < threshold\n    invariant count == |filtered|\n    invariant remaining <= numbers\n    invariant filtered <= numbers\n    decreases |remaining|\n  {\n    var x :| x in remaining;\n    remaining := remaining - {x};\n    \n    if x < threshold {\n      filtered := filtered + {x};\n      count := count + 1;\n    }\n  }\n  \n  assert remaining == {};\n  assert numbers - remaining == numbers;\n  assert filtered == set i | i in numbers && i < threshold;\n  SetComprehensionEquality(numbers, threshold, filtered);\n  assert count == |filtered|;\n  assert count == |set i | i in numbers && i < threshold|;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_reverse_reverse.dfy", "root", true, "", "", false, "Clover_reverse_reverse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n// </vc-spec>\n// <vc-code>\n{\n  var left := 0;\n  var right := a.Length - 1;\n  \n  while left < right\n    invariant 0 <= left <= right + 1 <= a.Length\n    invariant forall i :: 0 <= i < left ==> a[i] == old(a[a.Length - 1 - i])\n    invariant forall i :: right < i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n    invariant forall i {:trigger a[i]} :: left <= i <= right ==> a[i] == old(a[i])\n    invariant forall i :: 0 <= i < a.Length ==> (i < left || i > right) ==> a[a.Length - 1 - i] == old(a[a.Length - 1 - i])\n  {\n    var temp := a[left];\n    a[left] := a[right];\n    a[right] := temp;\n    left := left + 1;\n    right := right - 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_616_ElementWiseModulo.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_616_ElementWiseModulo.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseModulo(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires forall i :: 0 <= i < b.Length ==> b[i] != 0\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] % b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseModulo(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires forall i :: 0 <= i < b.Length ==> b[i] != 0\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] % b[i]\n// </vc-spec>\n// <vc-code>\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant result.Length == a.Length\n        invariant forall j :: 0 <= j < i ==> result[j] == a[j] % b[j]\n    {\n        result[i] := a[i] % b[i];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter.dfy", "root", true, "", "", false, "MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter.dfy", "// <vc-preamble>\nfunction power(x: real, n: nat) : real\n  decreases n\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerIter(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n  decreases n\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).\n\n// <vc-helpers>\nlemma powerIterInvariant(x: real, i: nat, n: nat, p: real)\n  requires i <= n\n  requires p == power(x, i)\n  ensures p * power(x, n - i) == power(x, n)\n  decreases n - i\n{\n  if i == n {\n    assert power(x, n - i) == power(x, 0) == 1.0;\n  } else {\n    assert power(x, n - i) == x * power(x, n - i - 1);\n    powerIterInvariant(x, i + 1, n, p * x);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod powerIter(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>\n// <vc-code>\n{\n  p := 1.0;\n  var i := 0;\n  \n  while i < n\n    invariant 0 <= i <= n\n    invariant p == power(x, i)\n    decreases n - i\n  {\n    p := p * x;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n// Recursive version, imperative, with time and space complexity O(log n).\n\n// States the property x^a * x^b = x^(a+b), that powerOpt takes advantage of. \n// The annotation {:induction a} guides Dafny to prove the property\n// by automatic induction on 'a'.\n\n// A simple test case to make sure the specification is adequate.", "", "", ""], ["dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates.dfy", "root", true, "", "", false, "dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveDuplicates(nums: array<int>) returns (num_length: int)\n  modifies nums\n  requires forall i, j | 0 <= i < j < nums.Length :: nums[i] <= nums[j]\n  ensures nums.Length == old(nums).Length\n  ensures 0 <= num_length <= nums.Length\n  ensures forall i, j | 0 <= i < j < num_length :: nums[i] != nums[j]\n  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..])\n  ensures forall i | 0 <= i < nums.Length :: old(nums[i]) in nums[..num_length]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma PreservesNonDuplicateProperty(nums: array<int>, k: int, i: int)\n  requires 0 <= k <= i < nums.Length\n  requires forall x, y | 0 <= x < y < k :: nums[x] != nums[y]\n  requires forall x | 0 <= x < k :: nums[x] != nums[i]\n  ensures forall x, y | 0 <= x < y < k + 1 :: nums[x] != nums[y]\n{\n}\n\nlemma ArraySliceContainment(nums: array<int>, old_nums: seq<int>, k: int)\n  requires nums.Length == |old_nums|\n  requires 0 <= k <= nums.Length\n  requires forall i | 0 <= i < k :: nums[i] in old_nums\n  ensures forall i | 0 <= i < k :: nums[i] in nums[..k]\n{\n}\n\nlemma SortedPreservation(nums: array<int>, k: int, i: int, val: int)\n  requires 0 <= k < i < nums.Length\n  requires forall x, y | 0 <= x < y < nums.Length :: nums[x] <= nums[y]\n  requires val == nums[i]\n  ensures forall x, y | 0 <= x < y < nums.Length :: nums[x] <= nums[y]\n{\n}\n\nlemma ContainmentAfterAssignment(nums: array<int>, old_nums: seq<int>, k: int, i: int)\n  requires 0 <= k < nums.Length && i < nums.Length\n  requires nums.Length == |old_nums|\n  requires forall x | 0 <= x < k :: nums[x] in old_nums\n  requires nums[i] in old_nums\n  ensures nums[i] in old_nums\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveDuplicates(nums: array<int>) returns (num_length: int)\n  modifies nums\n  requires forall i, j | 0 <= i < j < nums.Length :: nums[i] <= nums[j]\n  ensures nums.Length == old(nums).Length\n  ensures 0 <= num_length <= nums.Length\n  ensures forall i, j | 0 <= i < j < num_length :: nums[i] != nums[j]\n  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..])\n  ensures forall i | 0 <= i < nums.Length :: old(nums[i]) in nums[..num_length]\n// </vc-spec>\n// <vc-code>\n{\n  if nums.Length == 0 {\n    return 0;\n  }\n  \n  ghost var old_nums := nums[..];\n  var k := 1;\n  var i := 1;\n  \n  while i < nums.Length\n    invariant 1 <= k <= i <= nums.Length\n    invariant forall x, y | 0 <= x < y < k :: nums[x] != nums[y]\n    invariant forall x | 0 <= x < k :: nums[x] in old_nums\n    invariant forall x | 0 <= x < |old_nums| :: old_nums[x] in nums[..k] + nums[i..]\n    invariant forall x, y | 0 <= x < y < k :: nums[x] <= nums[y]\n    invariant forall x | k <= x < nums.Length :: nums[k-1] <= nums[x]\n  {\n    if nums[k-1] != nums[i] {\n      assert nums[i] in old_nums;\n      ContainmentAfterAssignment(nums, old_nums, k, i);\n      nums[k] := nums[i];\n      PreservesNonDuplicateProperty(nums, k, i);\n      k := k + 1;\n    }\n    i := i + 1;\n  }\n  \n  return k;\n}\n// </vc-code>\n\n", "", "", ""], ["llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero.dfy", "root", true, "", "", false, "llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero.dfy", "// <vc-preamble>\nfunction sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod below_zero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}\n\n// <vc-helpers>\nlemma sum_prefix_property(s: seq<int>, i: nat, j: nat)\n    requires i <= j <= |s|\n    ensures sum(s, j) == sum(s, i) + sum(s[i..], j - i)\n{\n    if i == 0 {\n        assert sum(s, j) == sum(s[0..], j);\n        assert s[0..] == s;\n    } else if i == j {\n        assert sum(s, i) == sum(s, j);\n        assert sum(s[i..], 0) == 0;\n    } else {\n        sum_prefix_property(s[1..], i-1, j-1);\n    }\n}\n\nlemma sum_monotonic(s: seq<int>, n: nat, m: nat)\n    requires n <= m <= |s|\n    ensures sum(s, m) == sum(s, n) + sum(s[n..], m - n)\n{\n    sum_prefix_property(s, n, m);\n}\n\nlemma sum_step(s: seq<int>, i: nat)\n    requires i < |s|\n    ensures sum(s, i + 1) == sum(s, i) + s[i]\n{\n    if i == 0 {\n        assert sum(s, 1) == s[0] + sum(s[1..], 0);\n        assert sum(s[1..], 0) == 0;\n        assert sum(s, 0) == 0;\n    } else {\n        sum_step(s[1..], i - 1);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod below_zero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>\n// <vc-code>\n{\n    result := false;\n    var balance := 0;\n    var i := 0;\n    \n    while i < |ops|\n        invariant 0 <= i <= |ops|\n        invariant balance == sum(ops, i)\n        invariant result ==> exists n: nat :: n <= i && sum(ops, n) < 0\n        invariant !result ==> forall n: nat :: n <= i ==> sum(ops, n) >= 0\n    {\n        if balance < 0 {\n            result := true;\n            break;\n        }\n        balance := balance + ops[i];\n        i := i + 1;\n        sum_step(ops, i - 1);\n        if balance < 0 {\n            result := true;\n            break;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-programs_tmp_tmpcwodh6qh_src_expt_expt.dfy", "root", true, "", "", false, "dafny-programs_tmp_tmpcwodh6qh_src_expt_expt.dfy", "// <vc-preamble>\nghost function Expt(b: int, n: nat): int\n  requires n >= 0\n{\n  if n == 0 then 1 else b * Expt(b, n - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod expt(b: int, n: nat) returns (res: int) \n  ensures res == Expt(b, n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Expt(b: int, n: nat): int\n  requires n >= 0\n{\n  if n == 0 then 1 else b * Expt(b, n - 1)\n}\n\n// <vc-helpers>\nlemma ExptMult(b: int, n: nat, m: nat)\n  ensures Expt(b, n + m) == Expt(b, n) * Expt(b, m)\n{\n  if n == 0 {\n    assert Expt(b, 0 + m) == Expt(b, m);\n    assert Expt(b, 0) == 1;\n    assert Expt(b, 0) * Expt(b, m) == 1 * Expt(b, m) == Expt(b, m);\n  } else {\n    ExptMult(b, n - 1, m);\n    assert Expt(b, n + m) == b * Expt(b, (n - 1) + m);\n    assert Expt(b, (n - 1) + m) == Expt(b, n - 1) * Expt(b, m);\n    assert Expt(b, n + m) == b * Expt(b, n - 1) * Expt(b, m);\n    assert Expt(b, n) == b * Expt(b, n - 1);\n    assert Expt(b, n) * Expt(b, m) == b * Expt(b, n - 1) * Expt(b, m);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod expt(b: int, n: nat) returns (res: int) \n  ensures res == Expt(b, n)\n// </vc-spec>\n// <vc-code>\n{\n  res := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant res == Expt(b, i)\n  {\n    res := res * b;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_Sort.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_Sort.dfy", "// <vc-preamble>\nmethod MinOfMultiset( m: multiset<int> ) returns( min: int )\n    ensures min in m;\n    ensures forall z | z in m :: min <= z;\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sort( m: multiset<int> ) returns ( s: seq<int> )\n\n    ensures multiset(s) == m;\n    ensures forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit.dfy", "root", true, "", "", false, "Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySplit (a : array<int>) returns (b : array<int>, c : array<int>)\n  ensures fresh(b)\n  ensures fresh(c)\n  ensures a[..] == b[..] + c[..]\n  ensures a.Length == b.Length + c.Length\n  ensures a.Length > 1 ==> a.Length > b.Length\n  ensures a.Length > 1 ==> a.Length > c.Length\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ArraySplit (a : array<int>) returns (b : array<int>, c : array<int>)\n  ensures fresh(b)\n  ensures fresh(c)\n  ensures a[..] == b[..] + c[..]\n  ensures a.Length == b.Length + c.Length\n  ensures a.Length > 1 ==> a.Length > b.Length\n  ensures a.Length > 1 ==> a.Length > c.Length\n// </vc-spec>\n// <vc-code>\n{\n  var splitPoint := a.Length / 2;\n  b := new int[splitPoint];\n  c := new int[a.Length - splitPoint];\n  \n  var i := 0;\n  while i < splitPoint\n    invariant 0 <= i <= splitPoint\n    invariant forall j :: 0 <= j < i ==> b[j] == a[j]\n  {\n    b[i] := a[i];\n    i := i + 1;\n  }\n  \n  assert i == splitPoint;\n  assert forall j :: 0 <= j < splitPoint ==> b[j] == a[j];\n  \n  i := 0;\n  while i < a.Length - splitPoint\n    invariant 0 <= i <= a.Length - splitPoint\n    invariant forall j :: 0 <= j < i ==> c[j] == a[splitPoint + j]\n  {\n    c[i] := a[splitPoint + i];\n    i := i + 1;\n  }\n  \n  assert b.Length == splitPoint;\n  assert c.Length == a.Length - splitPoint;\n  assert forall j :: 0 <= j < b.Length ==> b[j] == a[j];\n  assert forall j :: 0 <= j < c.Length ==> c[j] == a[splitPoint + j];\n  assert b[..] == a[..splitPoint];\n  assert c[..] == a[splitPoint..];\n  assert a[..] == a[..splitPoint] + a[splitPoint..];\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2.dfy", "// <vc-preamble>\nfunction Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod segSumaMaxima2(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum2(v,k,i+1) &&  SumMaxToRight2(v,0,i,s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\n\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\n//Now do the same but with a loop from right to left\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}\n\n// <vc-helpers>\nlemma Sum2Property(v:array<int>, i:int, j:int)\nrequires 0<=i<=j<=v.Length\nensures Sum2(v,i,j) == Sum2(v,i,i) + Sum2(v,i,j)\n{\n}\n\nlemma Sum2Extended(v:array<int>, i:int, j:int)\nrequires 0<=i<j<=v.Length\nensures Sum2(v,i,j) == v[i] + Sum2(v,i+1,j)\n{\n}\n\nlemma SumMaxToRight2Property(v:array<int>, j:int, i:int, s:int, newS:int, newK:int)\nrequires 0<=j<=i<v.Length\nrequires j+1 <= i ==> SumMaxToRight2(v,j+1,i,s)\nrequires 0<=newK<=i<v.Length\nrequires newS == Sum2(v,newK,i+1)\nrequires j<=newK<=i\nrequires newS >= s\nrequires newS >= Sum2(v,j,i+1)\nensures SumMaxToRight2(v,j,i,newS)\n{\n}\n\nlemma EstablishSumMaxToRight2Base(v:array<int>, i:int, s:int)\nrequires 0<=i<v.Length\nrequires s == Sum2(v,i,i+1)\nensures SumMaxToRight2(v,i,i,s)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod segSumaMaxima2(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum2(v,k,i+1) &&  SumMaxToRight2(v,0,i,s)\n//Implement and verify\n// </vc-spec>\n// <vc-code>\n{\n  s := v[i];\n  k := i;\n  \n  var j := i - 1;\n  \n  while j >= 0\n  invariant -1 <= j <= i - 1\n  invariant 0 <= k <= i\n  invariant s == Sum2(v, k, i + 1)\n  invariant j == i - 1 ==> SumMaxToRight2(v, i, i, s)\n  invariant j < i - 1 ==> SumMaxToRight2(v, j + 1, i, s)\n  decreases j + 1\n  {\n    var currentSum := Sum2(v, j, i + 1);\n    \n    if currentSum > s {\n      s := currentSum;\n      k := j;\n    }\n    \n    j := j - 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort.dfy", "// <vc-preamble>\npredicate sorted_seg(a:array<int>, i:int, j:int)\nrequires 0 <= i <= j+1 <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k <= j ==> a[l] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertionSort(a: array<int>)\n  modifies a;\n  ensures sorted_seg(a,0,a.Length-1) \n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted_seg(a:array<int>, i:int, j:int) //i and j included\nrequires 0 <= i <= j+1 <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k <= j ==> a[l] <= a[k]\n}\n\n// <vc-helpers>\nlemma SortedSegExtend(a: array<int>, i: int, j: int, k: int)\n  requires 0 <= i <= j < k < a.Length\n  requires sorted_seg(a, i, j)\n  requires forall l :: i <= l <= j ==> a[l] <= a[k]\n  ensures sorted_seg(a, i, k)\n{\n  assert forall l, m :: i <= l <= m <= k ==> \n    if m <= j then a[l] <= a[m]\n    else if l <= j then a[l] <= a[k] \n    else a[l] <= a[m];\n}\n\nlemma SortedSegPreserved(a: array<int>, i: int, j: int, pos: int, val: int)\n  requires 0 <= i <= j < a.Length\n  requires 0 <= pos < a.Length\n  requires pos < i || pos > j\n  requires sorted_seg(a, i, j)\n  ensures sorted_seg(a, i, j)\n{\n}\n\nlemma MultisetShift(a: array<int>, i: int)\n  requires 0 <= i < a.Length - 1\n  ensures multiset(a[..]) == old(multiset(a[..])) + multiset{a[i+1]} - multiset{old(a[i+1])} + multiset{a[i]} - multiset{old(a[i])}\n{\n}\n\nlemma SortedSegCombine(a: array<int>, i: int, j: int, k: int)\n  requires 0 <= i <= j+1 <= k+1 <= a.Length\n  requires sorted_seg(a, i, j)\n  requires sorted_seg(a, j+1, k)\n  requires j >= i-1 && j+1 < a.Length ==> forall l :: i <= l <= j ==> a[l] <= a[j+1]\n  ensures sorted_seg(a, i, k)\n{\n  if i <= j && j+1 <= k {\n    assert forall l, m :: i <= l <= m <= k ==>\n      if m <= j then a[l] <= a[m]\n      else if l <= j then a[l] <= a[j+1] && a[j+1] <= a[m]\n      else a[l] <= a[m];\n  }\n}\n\nlemma SortedSegEmpty(a: array<int>, i: int)\n  requires 0 <= i < a.Length\n  ensures sorted_seg(a, i, i-1)\n{\n}\n\nlemma SortedSegSingle(a: array<int>, i: int)\n  requires 0 <= i < a.Length\n  ensures sorted_seg(a, i, i)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod InsertionSort(a: array<int>)\n  modifies a;\n  ensures sorted_seg(a,0,a.Length-1) \n  ensures multiset(a[..]) == old(multiset(a[..])) //Add and prove this\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length <= 1 {\n    return;\n  }\n  \n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant sorted_seg(a, 0, i-1)\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var key := a[i];\n    var j := i - 1;\n    ghost var oldArray := a[..];\n    \n    while j >= 0 && a[j] > key\n      invariant -1 <= j < i\n      invariant sorted_seg(a, 0, j)\n      invariant j+1 < i ==> a[j+1] == key\n      invariant j+2 <= i ==> sorted_seg(a, j+2, i)\n      invariant forall l :: j+2 <= l <= i ==> a[l] >= key\n      invariant multiset(a[..]) == multiset(oldArray)\n      invariant a[j+1..i+1] == [key] + oldArray[j+1..i]\n    {\n      a[j+1] := a[j];\n      j := j - 1;\n    }\n    \n    a[j+1] := key;\n    \n    assert sorted_seg(a, 0, j);\n    assert j+1 < a.Length && a[j+1] == key;\n    assert j+2 <= i ==> sorted_seg(a, j+2, i);\n    assert forall l :: 0 <= l <= j ==> a[l] <= key;\n    assert forall l :: j+2 <= l <= i ==> a[l] >= key;\n    assert sorted_seg(a, 0, i);\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_603_LucidNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_603_LucidNumbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n// </vc-spec>\n// <vc-code>\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\n        invariant 0 <= i <= n + 1\n        invariant forall k :: 0 <= k < |lucid| ==> lucid[k] % 3 == 0\n        invariant forall k :: 0 <= k < |lucid| ==> lucid[k] <= n\n        invariant forall k, j :: 0 <= k < j < |lucid| ==> lucid[k] < lucid[j]\n        invariant forall k :: 0 <= k < |lucid| ==> lucid[k] < i\n        invariant forall m :: 0 <= m < i && m % 3 == 0 ==> m in lucid\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum.dfy", "// <vc-preamble>\nfunction sumcheck(s: array<int>, i: int): int\nrequires 0 <= i <= s.Length\nreads s\n{\n    if i == 0 then 0\n    else s[i - 1] + sumcheck(s, i - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sum(s: array<int>) returns (a:int)\nrequires s.Length > 0\nensures sumcheck(s, s.Length) == a\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// sums from index 0 -> i - 1\nfunction sumcheck(s: array<int>, i: int): int\nrequires 0 <= i <= s.Length\nreads s\n{\n    if i == 0 then 0\n    else s[i - 1] + sumcheck(s, i - 1)\n}\n\n// returns sum of array\n\n// <vc-helpers>\nlemma sumcheck_loop_invariant(s: array<int>, i: int, current_sum: int)\nrequires 0 <= i <= s.Length\nrequires current_sum == sumcheck(s, i)\nensures current_sum == sumcheck(s, i)\n{\n}\n\nlemma sumcheck_step(s: array<int>, i: int)\nrequires 0 <= i < s.Length\nensures sumcheck(s, i + 1) == s[i] + sumcheck(s, i)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sum(s: array<int>) returns (a:int)\nrequires s.Length > 0\nensures sumcheck(s, s.Length) == a\n// </vc-spec>\n// <vc-code>\n{\n  a := 0;\n  var i := 0;\n  \n  while i < s.Length\n  invariant 0 <= i <= s.Length\n  invariant a == sumcheck(s, i)\n  {\n    sumcheck_step(s, i);\n    a := a + s[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod barrier(v:array<int>,p:int) returns (b:bool)\nrequires v.Length > 0\nrequires 0<=p<v.Length\nensures b==forall k,l::0<=k<=p && p<l<v.Length ==> v[k]<v[l]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Method barrier below receives an array and an integer p\n//and returns a boolean b which is true if and only if \n//all the positions to the left of p and including also position p contain elements \n//that are strictly smaller than all the elements contained in the positions to the right of p \n\n//Examples:\n// If v=[7,2,5,8] and p=0 or p=1 then the method must return false, \n// but for p=2 the method should return true\n//1.Specify the method\n//2.Implement an O(v.size()) method\n//3.Verify the method\n\n// <vc-helpers>\nlemma MaxLeftLemma(v: array<int>, p: int, maxLeft: int)\n  requires v.Length > 0\n  requires 0 <= p < v.Length\n  requires forall j :: 0 <= j <= p ==> maxLeft >= v[j]\n  requires exists j :: 0 <= j <= p && maxLeft == v[j]\n  ensures forall k :: 0 <= k <= p ==> maxLeft >= v[k]\n{\n}\n\nlemma MinRightLemma(v: array<int>, p: int, minRight: int)\n  requires v.Length > 0\n  requires 0 <= p < v.Length\n  requires p + 1 < v.Length\n  requires forall j :: p + 1 <= j < v.Length ==> minRight <= v[j]\n  requires exists j :: p + 1 <= j < v.Length && minRight == v[j]\n  ensures forall l :: p < l < v.Length ==> minRight <= v[l]\n{\n}\n\nlemma BarrierCorrectness(v: array<int>, p: int, maxLeft: int, minRight: int)\n  requires v.Length > 0\n  requires 0 <= p < v.Length\n  requires forall k :: 0 <= k <= p ==> maxLeft >= v[k]\n  requires p + 1 < v.Length ==> forall l :: p < l < v.Length ==> minRight <= v[l]\n  requires p + 1 < v.Length ==> maxLeft < minRight\n  ensures p + 1 >= v.Length || forall k,l :: 0 <= k <= p && p < l < v.Length ==> v[k] < v[l]\n{\n  if p + 1 < v.Length {\n    forall k,l | 0 <= k <= p && p < l < v.Length\n      ensures v[k] < v[l]\n    {\n      assert maxLeft >= v[k];\n      assert minRight <= v[l];\n      assert maxLeft < minRight;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod barrier(v:array<int>,p:int) returns (b:bool)\n//Give the precondition\n//Give the postcondition\n//{Implement and verify}\nrequires v.Length > 0\nrequires 0<=p<v.Length\nensures b==forall k,l::0<=k<=p && p<l<v.Length ==> v[k]<v[l]\n// </vc-spec>\n// <vc-code>\n{\n  if p + 1 >= v.Length {\n    b := true;\n    return;\n  }\n  \n  var maxLeft := v[0];\n  var i := 1;\n  while i <= p\n    invariant 1 <= i <= p + 1\n    invariant forall j :: 0 <= j < i && j <= p ==> maxLeft >= v[j]\n    invariant exists j :: 0 <= j < i && j <= p && maxLeft == v[j]\n  {\n    if v[i] > maxLeft {\n      maxLeft := v[i];\n    }\n    i := i + 1;\n  }\n  \n  MaxLeftLemma(v, p, maxLeft);\n  \n  var minRight := v[p + 1];\n  i := p + 2;\n  while i < v.Length\n    invariant p + 2 <= i <= v.Length\n    invariant forall j :: p + 1 <= j < i ==> minRight <= v[j]\n    invariant exists j :: p + 1 <= j < i && minRight == v[j]\n  {\n    if v[i] < minRight {\n      minRight := v[i];\n    }\n    i := i + 1;\n  }\n  \n  MinRightLemma(v, p, minRight);\n  \n  b := maxLeft < minRight;\n  \n  if b {\n    BarrierCorrectness(v, p, maxLeft, minRight);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin.dfy", "// <vc-preamble>\npredicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n// </vc-spec>\n// <vc-code>\n{\n    m := i;\n    var j := i + 1;\n    while j < a.Length\n        invariant i <= m < a.Length\n        invariant i <= j <= a.Length\n        invariant forall k :: i <= k < j ==> a[k] >= a[m]\n    {\n        if a[j] < a[m] {\n            m := j;\n        }\n        j := j + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Remove_Duplicates_from_Sorted_Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Remove_Duplicates_from_Sorted_Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array.dfy", "// <vc-preamble>\npredicate is_sorted(nums: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] <= nums[j]\n}\n\npredicate is_sorted_and_distinct(nums: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] < nums[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod remove_duplicates_from_sorted_array(nums: seq<int>) returns (result: seq<int>) \n    requires is_sorted(nums)\n    requires 1 <= |nums| <= 30000\n    requires forall i :: 0 <= i < |nums| ==> -100 <= nums[i] <= 100\n    ensures is_sorted_and_distinct(result)\n    ensures forall i :: i in nums <==> i in result\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial.dfy", "root", true, "", "", false, "dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial.dfy", "// <vc-preamble>\nfunction fact(n: nat): nat \n    ensures fact(n) >= 1\n{\n    if n == 0 then 1 else n * fact(n - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod factorial(n: nat) returns (res: nat)\n    ensures res == fact(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function fact(n: nat): nat \n    ensures fact(n) >= 1\n{\n    if n == 0 then 1 else n * fact(n - 1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod factorial(n: nat) returns (res: nat)\n    ensures res == fact(n)\n// </vc-spec>\n// <vc-code>\n{\n    if n == 0 {\n        res := 1;\n    } else {\n        var i := 1;\n        res := 1;\n        while i <= n\n            invariant 1 <= i <= n + 1\n            invariant res == fact(i - 1)\n        {\n            res := res * i;\n            i := i + 1;\n        }\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial.dfy", "// <vc-preamble>\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeFactorial(n: int) returns (u: int)\n  requires 1 <= n;\n  ensures u == Factorial(n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeFactorial(n: int) returns (u: int)\n  requires 1 <= n;\n  ensures u == Factorial(n);\n// </vc-spec>\n// <vc-code>\n{\n  u := 1;\n  var i := 1;\n  while i <= n\n    invariant 1 <= i <= n + 1\n    invariant u == Factorial(i - 1)\n  {\n    u := u * i;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_update_array_UpdateElements.dfy", "root", true, "", "", false, "Clover_update_array_UpdateElements.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod UpdateElements(a: array<int>)\n  requires a.Length >= 8\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[7]==516\n  ensures forall i::0 <= i<a.Length ==> i != 7 && i != 4 ==> a[i] == old(a[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod UpdateElements(a: array<int>)\n  requires a.Length >= 8\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[7]==516\n  ensures forall i::0 <= i<a.Length ==> i != 7 && i != 4 ==> a[i] == old(a[i])\n// </vc-spec>\n// <vc-code>\n{\n  a[4] := a[4] + 3;\n  a[7] := 516;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_629_FindEvenNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_629_FindEvenNumbers.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindEvenNumbers(arr: array<int>) returns (evenList: seq<int>)\n\n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\n// <vc-helpers>\nlemma InSeqAfterAppend<T>(s: seq<T>, x: T, y: T)\n    requires x in s\n    ensures x in s + [y]\n{\n}\n\nlemma InArrayImpliesInSlice(arr: array<int>, i: int)\n    requires 0 <= i < arr.Length\n    ensures arr[i] in arr[..]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindEvenNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>\n// <vc-code>\n{\n    evenList := [];\n    var i := 0;\n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant forall j :: 0 <= j < |evenList| ==> IsEven(evenList[j]) && evenList[j] in arr[..]\n        invariant forall j :: 0 <= j < i && IsEven(arr[j]) ==> arr[j] in evenList\n    {\n        if IsEven(arr[i]) {\n            InArrayImpliesInSlice(arr, i);\n            evenList := evenList + [arr[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod.dfy", "root", true, "", "", false, "AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod.dfy", "// <vc-preamble>\ndatatype Unary = Zero | Suc(pred: Unary)\n\nghost function UnaryToNat(x: Unary): nat {\n  match x\n  case Zero => 0\n  case Suc(x') => 1 + UnaryToNat(x')\n}\n\nghost function NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Suc(NatToUnary(n-1))\n}\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\npredicate LessAlt(x: Unary, y: Unary) {\n  y != Zero && (x == Zero || Less(x.pred, y.pred))\n}\n\nfunction Add(x: Unary, y: Unary): Unary {\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nfunction Mul(x: Unary, y: Unary): Unary {\n  match x\n  case Zero => Zero\n  case Suc(x') => Add(Mul(x', y), y)\n}\n\nmethod IterativeDivMod'(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IterativeDivMod(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n// definitions borrowed from Rustan Leino's Program Proofs Chapter 7\n// (https://program-proofs.com/code.html example code in Dafny; source file 7-Unary.dfy)\ndatatype Unary = Zero | Suc(pred: Unary)\n\nghost function UnaryToNat(x: Unary): nat {\n  match x\n  case Zero => 0\n  case Suc(x') => 1 + UnaryToNat(x')\n}\n\nghost function NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Suc(NatToUnary(n-1))\n}\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\npredicate LessAlt(x: Unary, y: Unary) {\n  y != Zero && (x == Zero || Less(x.pred, y.pred))\n}\n\nfunction Add(x: Unary, y: Unary): Unary {\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nfunction Mul(x: Unary, y: Unary): Unary {\n  match x\n  case Zero => Zero\n  case Suc(x') => Add(Mul(x', y), y)\n}\n\n/*\nGoal: implement correcly and clearly, using iterative code (no recursion), documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n\n- DO NOT modify the specification or any of the definitions given in this file\n- Not all definitions above are relevant, some are simply included as examples\n- Feel free to use existing non-ghost functions/predicates in your code, and existing lemmas (for the proof) in your annotations\n- New functions/predicates may be added ONLY as ghost\n- If it helps you in any way, a recursive implementation + proof can be found in the book and the downloadable source file\n  [https://program-proofs.com/code.html example code in Dafny, source file 7-Unary.dfy]\n*/\n\nmethod IterativeDivMod'(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma LessIrreflexive(x: Unary)\n  ensures !Less(x, x)\n{\n  match x\n  case Zero => \n  case Suc(x') => LessIrreflexive(x');\n}\n\nlemma LessTransitive(x: Unary, y: Unary, z: Unary)\n  requires Less(x, y) && Less(y, z)\n  ensures Less(x, z)\n{\n  match z\n  case Zero => \n  case Suc(z') =>\n    match y\n    case Zero => \n    case Suc(y') =>\n      if x.Suc? {\n        LessTransitive(x.pred, y', z');\n      }\n}\n\nlemma SubPreservesLess(x: Unary, y: Unary, z: Unary)\n  requires !Less(x, y) && Less(z, y)\n  ensures !Less(Sub(x, z), y)\n{\n  match x\n  case Zero =>\n    match z\n    case Zero =>\n    case Suc(z') =>\n      assert false;\n  case Suc(x') =>\n    match z\n    case Zero => \n    case Suc(z') =>\n      SubPreservesLess(x', y, z');\n}\n\nlemma AddSubCancel(x: Unary, y: Unary)\n  requires !Less(x, y)\n  ensures Add(y, Sub(x, y)) == x\n{\n  match y\n  case Zero => \n  case Suc(y') =>\n    assert x.Suc?;\n    AddSubCancel(x.pred, y');\n}\n\nlemma MulDistributesOverAdd(x: Unary, y: Unary, z: Unary)\n  ensures Mul(Add(x, y), z) == Add(Mul(x, z), Mul(y, z))\n{\n  match x\n  case Zero => \n  case Suc(x') =>\n    MulDistributesOverAdd(x', y, z);\n    AddAssociative(Mul(x', z), Mul(y, z), z);\n}\n\nlemma AddAssociative(x: Unary, y: Unary, z: Unary)\n  ensures Add(Add(x, y), z) == Add(x, Add(y, z))\n{\n  match z\n  case Zero => \n  case Suc(z') =>\n    AddAssociative(x, y, z');\n}\n\nlemma AddCommutative(x: Unary, y: Unary)\n  ensures Add(x, y) == Add(y, x)\n{\n  match y\n  case Zero =>\n    AddZeroRight(x);\n  case Suc(y') =>\n    AddCommutative(x, y');\n    AddSuccRight(y', x);\n}\n\nlemma AddZeroRight(x: Unary)\n  ensures Add(x, Zero) == x\n{\n}\n\nlemma AddSuccRight(x: Unary, y: Unary)\n  ensures Add(x, Suc(y)) == Suc(Add(x, y))\n{\n  match x\n  case Zero => \n  case Suc(x') =>\n    AddSuccRight(x', y);\n}\n\nlemma SubDecreasesFirst(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures Less(Sub(x, y), x)\n{\n  match y\n  case Zero =>\n  case Suc(y') =>\n    match x\n    case Zero =>\n    case Suc(x') =>\n      if y' == Zero {\n        LessSucc(x');\n      } else {\n        SubDecreasesFirst(x', y');\n        LessSuccMono(Sub(x', y'), x');\n      }\n}\n\nlemma LessSucc(x: Unary)\n  ensures Less(x, Suc(x))\n{\n  match x\n  case Zero =>\n  case Suc(x') =>\n    LessSucc(x');\n}\n\nlemma LessSuccMono(x: Unary, y: Unary)\n  requires Less(x, y)\n  ensures Less(x, Suc(y))\n{\n  match y\n  case Zero =>\n  case Suc(y') =>\n    if x.Suc? {\n      LessSuccMono(x.pred, y');\n    }\n}\n\nlemma InvariantPreservation(d: Unary, m: Unary, y: Unary, x: Unary)\n  requires Add(Mul(d, y), m) == x && !Less(m, y) && y != Zero\n  ensures Add(Mul(Suc(d), y), Sub(m, y)) == x\n{\n  calc {\n    Add(Mul(Suc(d), y), Sub(m, y));\n    Add(Add(Mul(d, y), y), Sub(m, y));\n    { AddAssociative(Mul(d, y), y, Sub(m, y)); }\n    Add(Mul(d, y), Add(y, Sub(m, y)));\n    { AddCommutative(y, Sub(m, y)); }\n    Add(Mul(d, y), Add(Sub(m, y), y));\n    { AddSubCancel(m, y); }\n    Add(Mul(d, y), m);\n    x;\n  }\n}\n\nlemma NotLessImpliesTotalOrder(x: Unary, y: Unary)\n  requires !Less(x, y) && y != Zero\n  ensures x.Suc? && !Less(x.pred, y.pred)\n{\n  match x\n  case Zero =>\n    match y\n    case Zero =>\n    case Suc(y') =>\n      assert Less(Zero, Suc(y'));\n      assert false;\n  case Suc(x') =>\n    match y\n    case Zero =>\n    case Suc(y') =>\n      assert !Less(x.pred, y.pred);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IterativeDivMod(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n// </vc-spec>\n// <vc-code>\n{\n  d := Zero;\n  m := x;\n  \n  while !Less(m, y)\n    invariant Add(Mul(d, y), m) == x\n    decreases m\n  {\n    assert !Less(m, y);\n    assert y != Zero;\n    \n    NotLessImpliesTotalOrder(m, y);\n    assert m.Suc?;\n    assert !Less(m.pred, y.pred);\n    \n    SubDecreasesFirst(m, y);\n    assert Less(Sub(m, y), m);\n    \n    InvariantPreservation(d, m, y, x);\n    \n    d := Suc(d);\n    m := Sub(m, y);\n  }\n  \n  assert Less(m, y);\n}\n// </vc-code>\n\n", "", "", ""], ["formal-verification_tmp_tmpoepcssay_strings3_isSubstring.dfy", "root", true, "", "", false, "formal-verification_tmp_tmpoepcssay_strings3_isSubstring.dfy", "// <vc-preamble>\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\n// <vc-helpers>\nlemma isPrefixEquivalence(pre: string, str: string)\n    ensures isPrefixPred(pre, str) <==> ((|pre| <= |str|) && pre == str[..|pre|])\n    ensures isNotPrefixPred(pre, str) <==> ((|pre| > |str|) || pre != str[..|pre|])\n{\n}\n\nlemma isSubstringEquivalence(sub: string, str: string)\n    ensures isSubstringPred(sub, str) <==> (exists i :: 0 <= i <= |str| && isPrefixPred(sub, str[i..]))\n    ensures isNotSubstringPred(sub, str) <==> (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub, str[i..]))\n{\n}\n\nlemma notSubstringEquivalence(sub: string, str: string)\n    ensures isNotSubstringPred(sub, str) <==> !isSubstringPred(sub, str)\n{\n    if isSubstringPred(sub, str) {\n        var i :| 0 <= i <= |str| && isPrefixPred(sub, str[i..]);\n        assert !isNotPrefixPred(sub, str[i..]);\n        assert !isNotSubstringPred(sub, str);\n    }\n    if isNotSubstringPred(sub, str) {\n        if isSubstringPred(sub, str) {\n            var i :| 0 <= i <= |str| && isPrefixPred(sub, str[i..]);\n            assert isNotPrefixPred(sub, str[i..]);\n            assert !isPrefixPred(sub, str[i..]);\n            assert false;\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n    // ensures  !res ==> !isSubstringPred(sub, str)\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    while i <= |str|\n        invariant 0 <= i <= |str| + 1\n        invariant forall j :: 0 <= j < i ==> isNotPrefixPred(sub, str[j..])\n    {\n        var prefixResult := isPrefix(sub, str[i..]);\n        if prefixResult {\n            assert isPrefixPred(sub, str[i..]);\n            assert isSubstringPred(sub, str);\n            return true;\n        }\n        assert isNotPrefixPred(sub, str[i..]);\n        i := i + 1;\n    }\n    assert forall j :: 0 <= j <= |str| ==> isNotPrefixPred(sub, str[j..]);\n    assert isNotSubstringPred(sub, str);\n    notSubstringEquivalence(sub, str);\n    return false;\n}\n// </vc-code>\n\n", "", "", ""], ["bbfny_tmp_tmpw4m0jvl0_enjoying_Find.dfy", "root", true, "", "", false, "bbfny_tmp_tmpw4m0jvl0_enjoying_Find.dfy", "// <vc-preamble>\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// shenanigans going through the dafny tutorial\n\n\n\n\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n// </vc-spec>\n// <vc-code>\n{\n  index := -1;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant index < 0\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      index := i;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_below_zero_below_zero.dfy", "root", true, "", "", false, "Clover_below_zero_below_zero.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n// </vc-spec>\n// <vc-code>\n{\n  s := new int[|operations| + 1];\n  s[0] := 0;\n  result := false;\n  \n  var i := 0;\n  while i < |operations|\n    invariant 0 <= i <= |operations|\n    invariant s.Length == |operations| + 1\n    invariant s[0] == 0\n    invariant forall j :: 0 <= j < i ==> s[j+1] == s[j] + operations[j]\n    invariant result == true ==> (exists j :: 1 <= j <= i && s[j] < 0)\n    invariant result == false ==> forall j :: 0 <= j <= i ==> s[j] >= 0\n  {\n    s[i+1] := s[i] + operations[i];\n    if s[i+1] < 0 {\n      result := true;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n// </vc-spec>\n// <vc-code>\n{\n    result := false;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant !result ==> forall j :: 0 <= j < i ==> !(s[j] == '.' && |s| - j - 1 == 2)\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            return;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast.dfy", "root", true, "", "", false, "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast.dfy", "// <vc-preamble>\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast (a:array<int>, c:array<int>, i:int, j:int) returns (r:int)\nrequires is_prefix_sum_for(a,c) && 0 <= i <= j <= a.Length < c.Length\nensures r == sum(a, i,j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Exercicio 1.a)\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\n//Exercicio 1.b)\n\n//Exercicio 1.c)\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\n///Exercicio 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}\n\n// <vc-helpers>\nlemma sum_prefix_property(a: array<int>, c: array<int>, i: int, j: int)\nrequires is_prefix_sum_for(a, c)\nrequires 0 <= i <= j <= a.Length\nensures sum(a, i, j) == c[j] - c[i]\ndecreases j - i\n{\n    if i == j {\n        assert sum(a, i, j) == 0;\n        assert c[i] == sum(a, 0, i);\n        assert c[j] == sum(a, 0, j);\n        assert c[j] - c[i] == 0;\n    } else {\n        sum_prefix_property(a, c, i, j-1);\n        assert sum(a, i, j-1) == c[j-1] - c[i];\n        assert sum(a, i, j) == a[j-1] + sum(a, i, j-1);\n        assert sum(a, i, j) == a[j-1] + c[j-1] - c[i];\n        assert c[j] == sum(a, 0, j);\n        assert c[j-1] == sum(a, 0, j-1);\n        sum_split_property(a, 0, j-1, j);\n        assert sum(a, 0, j) == sum(a, 0, j-1) + a[j-1];\n        assert c[j] == c[j-1] + a[j-1];\n        assert a[j-1] + c[j-1] - c[i] == c[j] - c[i];\n    }\n}\n\nlemma sum_split_property(a: array<int>, i: int, k: int, j: int)\nrequires 0 <= i <= k <= j <= a.Length\nensures sum(a, i, j) == sum(a, i, k) + sum(a, k, j)\ndecreases j - k\n{\n    if k == j {\n        assert sum(a, k, j) == 0;\n    } else {\n        sum_split_property(a, i, k, j-1);\n        assert sum(a, i, j-1) == sum(a, i, k) + sum(a, k, j-1);\n        assert sum(a, i, j) == a[j-1] + sum(a, i, j-1);\n        assert sum(a, k, j) == a[j-1] + sum(a, k, j-1);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast (a:array<int>, c:array<int>, i:int, j:int) returns (r:int)\nrequires is_prefix_sum_for(a,c) && 0 <= i <= j <= a.Length < c.Length\nensures r == sum(a, i,j)\n// </vc-spec>\n// <vc-code>\n{\n    sum_prefix_property(a, c, i, j);\n    r := c[j] - c[i];\n}\n// </vc-code>\n\n", "", "", ""], ["AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge.dfy", "root", true, "", "", false, "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n        {\n\n            i,j := i0,j0;\n\n                if(i == c.Length || (j< d.Length && d[j] < c[i])){\n\n                assert InvSorted(b[..][i+j:=d[j]],c[..],d[..],i,j+1);\n                b[i+j] := d[j];\n\n                assert InvSubSet(b[..],c[..],d[..],i,j+1);\n                assert InvSorted(b[..],c[..],d[..],i,j+1);\n                j := j + 1;\n            }\n            else{\n                assert j == d.Length || (i < c.Length && c[i] <= d[j]);\n\n                assert InvSorted(b[..][i+j:=c[i]],c[..],d[..],i+1,j);\n\n                b[i+j] := c[i];\n\n                assert InvSubSet(b[..],c[..],d[..],i+1,j);\n                assert InvSorted(b[..],c[..],d[..],i+1,j);\n                i := i + 1;\n            }\n\n        }\n\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n//This is a method that replace the loop body\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n        //decreases ensures\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n        {\n\n            i,j := i0,j0;\n\n                if(i == c.Length || (j< d.Length && d[j] < c[i])){\n                    // in this case we take the next value from d\n                assert InvSorted(b[..][i+j:=d[j]],c[..],d[..],i,j+1);\n                b[i+j] := d[j];\n\n                assert InvSubSet(b[..],c[..],d[..],i,j+1);\n                assert InvSorted(b[..],c[..],d[..],i,j+1);\n                j := j + 1;\n            }\n            else{\n                assert j == d.Length || (i < c.Length && c[i] <= d[j]);\n                    // in this case we take the next value from c\n                assert InvSorted(b[..][i+j:=c[i]],c[..],d[..],i+1,j);\n\n                b[i+j] := c[i];\n\n                assert InvSubSet(b[..],c[..],d[..],i+1,j);\n                assert InvSorted(b[..],c[..],d[..],i+1,j);\n                i := i + 1;\n            }\n\n\n        }\n\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.\n\n// <vc-helpers>\nlemma MergeLoopTermination(c: array<int>, d: array<int>, i: nat, j: nat)\n    requires i <= c.Length && j <= d.Length\n    ensures c.Length - i >= 0 && d.Length - j >= 0\n{\n}\n\nlemma MultisetSliceProperties(s: seq<int>, i: nat)\n    requires i < |s|\n    ensures multiset(s[..i+1]) == multiset(s[..i]) + multiset([s[i]])\n{\n}\n\nlemma SequenceUpdateProperties(b: seq<int>, pos: nat, val: int)\n    requires pos < |b|\n    ensures b[pos := val][..pos+1] == b[..pos] + [val]\n    ensures multiset(b[pos := val][..pos+1]) == multiset(b[..pos]) + multiset([val])\n{\n}\n\nlemma InvPreservation(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat)\n    requires i <= |c| && j <= |d| && i + j < |b|\n    requires InvSubSet(b, c, d, i, j)\n    requires InvSorted(b, c, d, i, j)\n    requires Sorted(c) && Sorted(d)\n    ensures (i == |c| || (j < |d| && d[j] < c[i])) ==> \n            (j < |d| && InvSubSet(b[i+j := d[j]], c, d, i, j+1) && \n             InvSorted(b[i+j := d[j]], c, d, i, j+1))\n    ensures (j == |d| || (i < |c| && c[i] <= d[j])) ==> \n            (i < |c| && InvSubSet(b[i+j := c[i]], c, d, i+1, j) && \n             InvSorted(b[i+j := c[i]], c, d, i+1, j))\n{\n    if i == |c| || (j < |d| && d[j] < c[i]) {\n        // We must take from d\n        assert i == |c| ==> j < |d|; // If c is exhausted, d cannot be exhausted\n        assert j < |d| && d[j] < c[i] ==> j < |d|; // Obvious case\n        assert j < |d|;\n        \n        var b' := b[i+j := d[j]];\n        SequenceUpdateProperties(b, i+j, d[j]);\n        assert multiset(b'[..i+j+1]) == multiset(b[..i+j]) + multiset([d[j]]);\n        \n        MultisetSliceProperties(d, j);\n        assert multiset(d[..j+1]) == multiset(d[..j]) + multiset([d[j]]);\n        assert multiset(c[..i]) + multiset(d[..j+1]) == multiset(c[..i]) + multiset(d[..j]) + multiset([d[j]]);\n        \n        assert InvSubSet(b', c, d, i, j+1);\n        assert InvSorted(b', c, d, i, j+1);\n    } else {\n        // We must take from c\n        assert j == |d| ==> i < |c|; // If d is exhausted, c cannot be exhausted\n        assert i < |c| && c[i] <= d[j] ==> i < |c|; // Obvious case\n        assert i < |c|;\n        \n        var b' := b[i+j := c[i]];\n        SequenceUpdateProperties(b, i+j, c[i]);\n        assert multiset(b'[..i+j+1]) == multiset(b[..i+j]) + multiset([c[i]]);\n        \n        MultisetSliceProperties(c, i);\n        assert multiset(c[..i+1]) == multiset(c[..i]) + multiset([c[i]]);\n        assert multiset(c[..i+1]) + multiset(d[..j]) == multiset(c[..i]) + multiset([c[i]]) + multiset(d[..j]);\n        \n        assert InvSubSet(b', c, d, i+1, j);\n        assert InvSorted(b', c, d, i+1, j);\n    }\n}\n\nlemma PostconditionLemma(b: array<int>, c: array<int>, d: array<int>, i: nat, j: nat)\n    requires i <= c.Length && j <= d.Length && i + j == b.Length\n    requires b.Length == c.Length + d.Length\n    requires InvSubSet(b[..], c[..], d[..], i, j)\n    requires InvSorted(b[..], c[..], d[..], i, j)\n    ensures i == c.Length && j == d.Length\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..]) + multiset(d[..])\n{\n    assert i + j == b.Length == c.Length + d.Length;\n    assert i <= c.Length && j <= d.Length;\n    assert i == c.Length && j == d.Length;\n    \n    assert b[..] == b[..i+j];\n    assert c[..] == c[..i];\n    assert d[..] == d[..j];\n    \n    assert multiset(b[..]) == multiset(c[..]) + multiset(d[..]);\n    assert Sorted(b[..]);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n// </vc-spec>\n// <vc-code>\n{\n    var i: nat := 0;\n    var j: nat := 0;\n    \n    while i + j < b.Length\n        invariant i <= c.Length && j <= d.Length && i + j <= b.Length\n        invariant InvSubSet(b[..], c[..], d[..], i, j)\n        invariant InvSorted(b[..], c[..], d[..], i, j)\n        decreases c.Length - i, d.Length - j\n    {\n        InvPreservation(b[..], c[..], d[..], i, j);\n        var old_i, old_j := i, j;\n        i, j := MergeLoop(b, c, d, i, j);\n        assert i + j == b.Length;\n    }\n    \n    PostconditionLemma(b, c, d, i, j);\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod incrementArray(a:array<int>)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1\n  modifies a\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod incrementArray(a:array<int>)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1\n  modifies a\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] == old(a[j]) + 1\n    invariant forall j :: i <= j < a.Length ==> a[j] == old(a[j])\n  {\n    a[i] := a[i] + 1;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_579_DissimilarElements.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_579_DissimilarElements.dfy", "// <vc-preamble>\npredicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n\n// <vc-helpers>\nlemma InSeqImpliesExists(s: seq<int>, x: int)\n    requires x in s\n    ensures exists i :: 0 <= i < |s| && s[i] == x\n{\n}\n\nlemma NotInSeqImpliesForall(s: seq<int>, x: int)\n    requires x !in s\n    ensures forall i :: 0 <= i < |s| ==> s[i] != x\n{\n}\n\nlemma SeqNoDupsPreserved(s: seq<int>, x: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n    requires x !in s\n    ensures forall i, j :: 0 <= i < j < |s + [x]| ==> (s + [x])[i] != (s + [x])[j]\n{\n    var newSeq := s + [x];\n    forall i, j | 0 <= i < j < |newSeq|\n        ensures newSeq[i] != newSeq[j]\n    {\n        if j == |s| {\n            assert newSeq[j] == x;\n            assert newSeq[i] == s[i];\n            assert x !in s;\n            NotInSeqImpliesForall(s, x);\n            assert s[i] != x;\n        } else {\n            assert newSeq[i] == s[i] && newSeq[j] == s[j];\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n        invariant forall k, l :: 0 <= k < l < |result| ==> result[k] != result[l]\n    {\n        var inB := false;\n        var j := 0;\n        while j < b.Length\n            invariant 0 <= j <= b.Length\n            invariant inB <==> exists k :: 0 <= k < j && b[k] == a[i]\n        {\n            if b[j] == a[i] {\n                inB := true;\n            }\n            j := j + 1;\n        }\n        \n        if !inB && a[i] !in result {\n            SeqNoDupsPreserved(result, a[i]);\n            result := result + [a[i]];\n        }\n        i := i + 1;\n    }\n    \n    i := 0;\n    while i < b.Length\n        invariant 0 <= i <= b.Length\n        invariant forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n        invariant forall k, l :: 0 <= k < l < |result| ==> result[k] != result[l]\n    {\n        var inA := false;\n        var j := 0;\n        while j < a.Length\n            invariant 0 <= j <= a.Length\n            invariant inA <==> exists k :: 0 <= k < j && a[k] == b[i]\n        {\n            if a[j] == b[i] {\n                inA := true;\n            }\n            j := j + 1;\n        }\n        \n        if !inA && b[i] !in result {\n            SeqNoDupsPreserved(result, b[i]);\n            result := result + [b[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_vector_Sum.dfy", "root", false, "", "", false, "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_vector_Sum.dfy", "// <vc-preamble>\nfunction sum(v: seq<int>): int \ndecreases v\n{\n    if v==[] then 0\n    else if |v|==1 then v[0]\n    else v[0]+sum(v[1..])\n}\n\nfunction reverse<T> (s:seq<T>):seq<T> \n{\n    if s==[] then []\n    else reverse(s[1..])+[s[0]]\n}\n\nfunction seq2set<T> (s:seq<T>): set<T>\n{\n    if s==[] then {}\n    else {s[0]}+seq2set(s[1..])\n}\n\nfunction scalar_product (v1:seq<int>, v2:seq<int>):int\nrequires |v1| == |v2|\n{\n    if v1 == [] then 0 else v1[0]*v2[0] + scalar_product(v1[1..],v2[1..])\n}\n\nmethod multiplicity_examples<T> ()\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod vector_Sum(v:seq<int>) returns (x:int)\nensures x == sum(v)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers.dfy", "root", true, "", "", false, "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod add_small_numbers (a: array<int>, n: int, max: int) returns (r: int)\n    requires n > 0;\n    requires n <= a.Length;\n    requires (forall i: int :: 0 <= i && i < n ==> a[i] <= max);\n    ensures r <= max * n;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma sum_bound(a: array<int>, n: int, max: int, current_sum: int, i: int)\n    requires 0 <= i <= n <= a.Length\n    requires forall j :: 0 <= j < n ==> a[j] <= max\n    requires current_sum == sum_range(a, 0, i)\n    ensures current_sum + sum_range(a, i, n) <= max * n\n    decreases n - i\n{\n    if i == n {\n        assert sum_range(a, i, n) == 0;\n        sum_range_bounded(a, 0, i, max);\n        assert current_sum <= max * i;\n        assert i <= n;\n        assert max * i <= max * n;\n    } else {\n        assert sum_range(a, i, n) == a[i] + sum_range(a, i + 1, n);\n        assert a[i] <= max;\n        assert current_sum + a[i] == sum_range(a, 0, i + 1) by {\n            sum_range_additive(a, 0, i, i + 1);\n        }\n        sum_bound(a, n, max, current_sum + a[i], i + 1);\n    }\n}\n\nlemma sum_range_bounded(a: array<int>, start: int, end: int, max: int)\n    requires 0 <= start <= end <= a.Length\n    requires forall j :: start <= j < end ==> a[j] <= max\n    ensures sum_range(a, start, end) <= max * (end - start)\n    decreases end - start\n{\n    if start == end {\n        assert sum_range(a, start, end) == 0;\n        assert max * (end - start) == 0;\n    } else {\n        assert a[start] <= max;\n        sum_range_bounded(a, start + 1, end, max);\n        assert sum_range(a, start + 1, end) <= max * (end - start - 1);\n        assert sum_range(a, start, end) == a[start] + sum_range(a, start + 1, end);\n        assert a[start] + sum_range(a, start + 1, end) <= max + max * (end - start - 1);\n        assert max + max * (end - start - 1) == max * (end - start);\n    }\n}\n\nfunction sum_range(a: array<int>, start: int, end: int): int\n    requires 0 <= start <= end <= a.Length\n    reads a\n    decreases end - start\n{\n    if start == end then 0\n    else a[start] + sum_range(a, start + 1, end)\n}\n\nlemma sum_range_additive(a: array<int>, i: int, j: int, k: int)\n    requires 0 <= i <= j <= k <= a.Length\n    ensures sum_range(a, i, k) == sum_range(a, i, j) + sum_range(a, j, k)\n    decreases j - i\n{\n    if i == j {\n        assert sum_range(a, i, j) == 0;\n    } else {\n        sum_range_additive(a, i + 1, j, k);\n    }\n}\n\nlemma sum_range_step(a: array<int>, start: int, end: int)\n    requires 0 <= start < end <= a.Length\n    ensures sum_range(a, start, end) == sum_range(a, start, end - 1) + a[end - 1]\n    decreases end - start\n{\n    if start == end - 1 {\n        assert sum_range(a, start, end - 1) == 0;\n    } else {\n        sum_range_step(a, start + 1, end);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod add_small_numbers (a: array<int>, n: int, max: int) returns (r: int)\n    requires n > 0;\n    requires n <= a.Length;\n    requires (forall i: int :: 0 <= i && i < n ==> a[i] <= max);\n    ensures r <= max * n;\n// </vc-spec>\n// <vc-code>\n{\n    r := 0;\n    var i := 0;\n    \n    while i < n\n        invariant 0 <= i <= n\n        invariant r == sum_range(a, 0, i)\n        invariant r <= max * i\n    {\n        assert a[i] <= max;\n        assert r + a[i] <= max * i + max;\n        assert max * i + max == max * (i + 1);\n        \n        r := r + a[i];\n        i := i + 1;\n        \n        sum_range_step(a, 0, i);\n    }\n    \n    assert i == n;\n    assert r == sum_range(a, 0, n);\n    assert r <= max * n;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_784_FirstEvenOddIndices.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_784_FirstEvenOddIndices.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}\n\n// <vc-helpers>\nlemma ExistsImpliesMinExists(lst: seq<int>, P: int -> bool)\n    requires |lst| > 0\n    requires exists i :: 0 <= i < |lst| && P(lst[i])\n    ensures exists i :: 0 <= i < |lst| && P(lst[i]) && (forall j :: 0 <= j < i ==> !P(lst[j]))\n{\n    var witness := FindWitness(lst, P);\n    var min := FindMin(lst, P, witness);\n    assert P(lst[min]) && (forall j :: 0 <= j < min ==> !P(lst[j]));\n}\n\nfunction FindWitness(lst: seq<int>, P: int -> bool): int\n    requires |lst| > 0\n    requires exists i :: 0 <= i < |lst| && P(lst[i])\n    ensures 0 <= FindWitness(lst, P) < |lst|\n    ensures P(lst[FindWitness(lst, P)])\n{\n    if P(lst[0]) then 0 else 1 + FindWitness(lst[1..], (x: int) => P(x))\n}\n\nfunction FindMin(lst: seq<int>, P: int -> bool, w: int): int\n    requires 0 <= w < |lst|\n    requires P(lst[w])\n    ensures 0 <= FindMin(lst, P, w) < |lst|\n    ensures P(lst[FindMin(lst, P, w)])\n    ensures forall j :: 0 <= j < FindMin(lst, P, w) ==> !P(lst[j])\n{\n    if w == 0 then\n        w\n    else if P(lst[0]) then\n        0\n    else\n        1 + FindMin(lst[1..], (x: int) => P(x), w - 1)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n    // This is the postcondition that ensures that it's the first, not just any\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n// </vc-spec>\n// <vc-code>\n{\n    evenIndex := 0;\n    while evenIndex < |lst| && IsOdd(lst[evenIndex])\n        invariant 0 <= evenIndex <= |lst|\n        invariant forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n        invariant exists i :: evenIndex <= i < |lst| && IsEven(lst[i])\n    {\n        evenIndex := evenIndex + 1;\n    }\n    \n    oddIndex := 0;\n    while oddIndex < |lst| && IsEven(lst[oddIndex])\n        invariant 0 <= oddIndex <= |lst|\n        invariant forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n        invariant exists i :: oddIndex <= i < |lst| && IsOdd(lst[i])\n    {\n        oddIndex := oddIndex + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin.dfy", "root", true, "", "", false, "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin.dfy", "// <vc-preamble>\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Problem01\n//a)\n\n//b)\n//Problem04\n\n//Problem02\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n\n\n\n//Problem03\n\n// <vc-helpers>\nlemma MinIndexCorrectness(a: array<int>, lo: nat, minIdx: nat, currentMin: int)\n    requires a.Length > 0 && lo < a.Length\n    requires lo <= minIdx < a.Length\n    requires a[minIdx] == currentMin\n    requires forall x :: lo <= x <= minIdx ==> currentMin <= a[x]\n    ensures forall x :: lo <= x <= minIdx ==> a[minIdx] <= a[x]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n// </vc-spec>\n// <vc-code>\n{\n    minIdx := lo;\n    var i := lo + 1;\n    \n    while i < a.Length\n        invariant lo <= minIdx < a.Length\n        invariant lo <= i <= a.Length\n        invariant forall x :: lo <= x < i ==> a[minIdx] <= a[x]\n    {\n        if a[i] < a[minIdx] {\n            minIdx := i;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch.dfy", "root", true, "", "", false, "MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch.dfy", "// <vc-preamble>\npredicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearch(a: array<int>, x: int) returns (index: int) \n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures if index != -1 then a[index] == x \n        else x !in a[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Checks if array 'a' is sorted.\npredicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n// Finds a value 'x' in a sorted array 'a', and returns its index,\n// or -1 if not found.\n\n// Simple test cases to check the post-condition.\n\n/*\na) Identify adequate pre and post-conditions for this method, \nand encode them as \u201crequires\u201d and \u201censures\u201d clauses in Dafny. \nYou can use the predicate below if needed.\n\nb) Identify an adequate loop variant and loop invariant, and encode them \nas \u201cdecreases\u201d and \u201cinvariant\u201d clauses in Dafny.\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearch(a: array<int>, x: int) returns (index: int) \n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures if index != -1 then a[index] == x \n        else x !in a[..] //forall i :: 0 <= i < a.Length ==> a[i] != x\n// </vc-spec>\n// <vc-code>\n{\n    var low := 0;\n    var high := a.Length;\n    \n    while low < high\n        invariant 0 <= low <= high <= a.Length\n        invariant forall i :: 0 <= i < low ==> a[i] < x\n        invariant forall i :: high <= i < a.Length ==> a[i] > x\n        decreases high - low\n    {\n        var mid := (low + high) / 2;\n        \n        if a[mid] < x {\n            low := mid + 1;\n        } else if a[mid] > x {\n            high := mid;\n        } else {\n            index := mid;\n            return;\n        }\n    }\n    \n    index := -1;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_728_AddLists.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_728_AddLists.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AddLists(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] + b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AddLists(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] + b[i]\n// </vc-spec>\n// <vc-code>\n{\n  result := [];\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == a[j] + b[j]\n  {\n    result := result + [a[i] + b[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Practice_tmp_tmphnmt4ovh_Pattern_Matching_FindAllOccurrences.dfy", "root", false, "", "", false, "Dafny-Practice_tmp_tmphnmt4ovh_Pattern_Matching_FindAllOccurrences.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindAllOccurrences(text: string, pattern: string) returns (offsets: set<nat>)\n  ensures forall i:nat :: i in offsets ==> i + |pattern| <= |text|\n  ensures forall i:nat :: 0 <= i <= |text| - |pattern|\n                       ==> (text[i..i+|pattern|] == pattern <==> i in offsets)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_240_ReplaceLastElement.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_240_ReplaceLastElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceLastElement(first: seq<int>, second: seq<int>) returns (result: seq<int>)\n    requires |first| > 0\n    ensures |result| == |first| - 1 + |second|\n    ensures forall i :: 0 <= i < |first| - 1 ==> result[i] == first[i]\n    ensures forall i :: |first| - 1 <= i < |result| ==> result[i] == second[i - |first| + 1]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceLastElement(first: seq<int>, second: seq<int>) returns (result: seq<int>)\n    requires |first| > 0\n    ensures |result| == |first| - 1 + |second|\n    ensures forall i :: 0 <= i < |first| - 1 ==> result[i] == first[i]\n    ensures forall i :: |first| - 1 <= i < |result| ==> result[i] == second[i - |first| + 1]\n// </vc-spec>\n// <vc-code>\n{\n  result := first[..|first|-1] + second;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_is_palindrome_IsPalindrome.dfy", "root", true, "", "", false, "Clover_is_palindrome_IsPalindrome.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n// </vc-spec>\n// <vc-code>\n{\n  var n := |x|;\n  var i := 0;\n  \n  while i < n / 2\n    invariant 0 <= i <= n / 2\n    invariant forall j :: 0 <= j < i ==> x[j] == x[n - j - 1]\n  {\n    if x[i] != x[n - i - 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  \n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax.dfy", "root", true, "", "", false, "Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod findMax (a : array<int>, n : int) returns (r:int)\nrequires a.Length > 0\nrequires 0 < n <= a.Length\nensures 0 <= r < n <= a.Length;\nensures forall k :: 0 <= k < n <= a.Length ==> a[r] >= a[k];\nensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// returns an index of the largest element of array 'a' in the range [0..n)\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod findMax (a : array<int>, n : int) returns (r:int)\nrequires a.Length > 0\nrequires 0 < n <= a.Length\nensures 0 <= r < n <= a.Length;\nensures forall k :: 0 <= k < n <= a.Length ==> a[r] >= a[k];\nensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>\n// <vc-code>\n{\n  r := 0;\n  var i := 1;\n  while i < n\n    invariant 0 <= r < i <= n\n    invariant forall k :: 0 <= k < i ==> a[r] >= a[k]\n  {\n    if a[i] > a[r] {\n      r := i;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_linear_search2_LinearSearch.dfy", "root", true, "", "", false, "Clover_linear_search2_LinearSearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n// </vc-spec>\n// <vc-code>\n{\n  n := 0;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall k :: 0 <= k < n ==> a[k] != e\n  {\n    if a[n] == e {\n      return;\n    }\n    n := n + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_755_SecondSmallest.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_755_SecondSmallest.dfy", "// <vc-preamble>\nfunction MinPair(s: seq<int>) : (r: int)\n    requires |s| == 2\n    ensures s[0] <= s[1] <==> r == s[0]\n    ensures s[0] > s[1] ==> r == s[1] \n{\n    if s[0] <= s[1] then s[0] else s[1]\n}\n\nfunction min(s: seq<int>) : (r: int)\n    requires |s| >= 2\n    ensures forall i :: 0 <= i < |s| ==> r <= s[i]\n{\n    if |s| == 2 then MinPair(s)\n    else MinPair([s[0], min(s[1..])])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SecondSmallest(s: array<int>) returns (secondSmallest: int)\n    requires s.Length >= 2\n\n    requires exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] != s[i]\n    ensures exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] == secondSmallest \n    ensures forall k ::  0 <= k < s.Length && s[k] != min(s[..])  ==>  s[k] >= secondSmallest\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function MinPair(s: seq<int>) : (r: int)\n    requires |s| == 2\n    ensures s[0] <= s[1] <==> r == s[0]\n    ensures s[0] > s[1] ==> r == s[1] \n{\n    if s[0] <= s[1] then s[0] else s[1]\n}\n\n\nfunction min(s: seq<int>) : (r: int)\n    requires |s| >= 2\n    ensures forall i :: 0 <= i < |s| ==> r <= s[i]\n{\n    if |s| == 2 then MinPair(s)\n    else MinPair([s[0], min(s[1..])])\n}\n\n// <vc-helpers>\nlemma MinInArray(s: array<int>)\n    requires s.Length >= 2\n    ensures exists i :: 0 <= i < s.Length && s[i] == min(s[..])\n{\n    MinExistsInSeq(s[..]);\n}\n\nlemma MinExistsInSeq(s: seq<int>)\n    requires |s| >= 2\n    ensures exists i :: 0 <= i < |s| && s[i] == min(s)\n    decreases |s|\n{\n    if |s| == 2 {\n        var minVal := MinPair(s);\n        if s[0] <= s[1] {\n            assert minVal == s[0];\n            assert exists i :: 0 <= i < |s| && s[i] == minVal;\n        } else {\n            assert minVal == s[1];\n            assert exists i :: 0 <= i < |s| && s[i] == minVal;\n        }\n    } else {\n        var tailMin := min(s[1..]);\n        MinExistsInSeq(s[1..]);\n        assert exists j :: 0 <= j < |s[1..]| && s[1..][j] == tailMin;\n        var minVal := min(s);\n        var pairMin := MinPair([s[0], tailMin]);\n        assert minVal == pairMin;\n        \n        if s[0] <= tailMin {\n            assert minVal == s[0];\n            assert exists i :: 0 <= i < |s| && s[i] == minVal;\n        } else {\n            assert minVal == tailMin;\n            var j :| 0 <= j < |s[1..]| && s[1..][j] == tailMin;\n            assert s[j+1] == tailMin;\n            assert exists i :: 0 <= i < |s| && s[i] == minVal;\n        }\n    }\n}\n\nlemma MinIsSmallest(s: seq<int>, minVal: int)\n    requires |s| >= 2\n    requires minVal == min(s)\n    ensures forall i :: 0 <= i < |s| ==> minVal <= s[i]\n{\n}\n\nlemma ArraySliceProperty(s: array<int>)\n    requires s.Length >= 2\n    ensures s[..] == s[0..s.Length]\n    ensures |s[..]| == s.Length\n    ensures forall i :: 0 <= i < s.Length ==> s[..][i] == s[i]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SecondSmallest(s: array<int>) returns (secondSmallest: int)\n    requires s.Length >= 2\n    // There must be at least 2 different values, a minimum and another one\n    requires exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] != s[i]\n    ensures exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] == secondSmallest \n    ensures forall k ::  0 <= k < s.Length && s[k] != min(s[..])  ==>  s[k] >= secondSmallest\n// </vc-spec>\n// <vc-code>\n{\n    var minVal := min(s[..]);\n    MinInArray(s);\n    assert exists i :: 0 <= i < s.Length && s[i] == minVal;\n    \n    var secondMin := s[0];\n    var foundSecond := false;\n    \n    // Find the first element that's not the minimum\n    var i := 0;\n    while i < s.Length\n        invariant 0 <= i <= s.Length\n        invariant !foundSecond ==> forall k :: 0 <= k < i ==> s[k] == minVal\n    {\n        if s[i] != minVal {\n            secondMin := s[i];\n            foundSecond := true;\n            break;\n        }\n        i := i + 1;\n    }\n    \n    // Find the actual second smallest among non-minimum elements\n    i := 0;\n    while i < s.Length\n        invariant 0 <= i <= s.Length\n        invariant foundSecond\n        invariant exists j :: 0 <= j < s.Length && s[j] == secondMin && s[j] != minVal\n        invariant forall k :: 0 <= k < i && s[k] != minVal ==> s[k] >= secondMin\n    {\n        if s[i] != minVal && s[i] < secondMin {\n            secondMin := s[i];\n        }\n        i := i + 1;\n    }\n    \n    return secondMin;\n}\n// </vc-code>\n\n", "", "", ""], ["dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find.dfy", "root", true, "", "", false, "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (i: int)\n   requires a != null;\n\n   ensures 0 <= i ==> (\n                       i < a.Length && \n\n                       a[i] == key && \n\n                       forall k :: 0 <= k < i ==> a[k] != key\n                      );\n\n   ensures i < 0 ==> \n\n           forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (i: int)\n   requires a != null;\n   // if i is non-negative then \n   ensures 0 <= i ==> (// (1) i is smaller than the length of a\n                       i < a.Length && \n                       // (2) key is at position i in a\n                       a[i] == key && \n                       // (3) i is the smallest position where key appears\n                       forall k :: 0 <= k < i ==> a[k] != key\n                      );\n   // if index is negative then\n   ensures i < 0 ==> \n           // a does not contain key\n           forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return;\n    }\n    i := i + 1;\n  }\n  i := -1;\n}\n// </vc-code>\n\n", "", "", ""], ["formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1.dfy", "root", true, "", "", false, "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1.dfy", "// <vc-preamble>\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod1(a: int, b: int) returns (q: int, r: int)\nrequires b > 0 && a >= 0\nensures a == b*q + r && 0 <= r < b\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat p\u00e2n\u0103 acum)\n        adnot\u0103ri care s\u0103 ajute \u00een procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod1(a: int, b: int) returns (q: int, r: int)\nrequires b > 0 && a >= 0\nensures a == b*q + r && 0 <= r < b\n//decreases *\n// </vc-spec>\n// <vc-code>\n{\n  q := 0;\n  r := a;\n  while (r >= b)\n    invariant a == b*q + r && r >= 0\n    decreases r\n  {\n    q := q + 1;\n    r := r - b;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg.dfy", "// <vc-preamble>\nfunction verifyNeg(a: array<int>, idx: int) : nat\nreads a\nrequires 0 <= idx <= a.Length\n{\n    if idx == 0 then 0 \n    else verifyNeg(a, idx - 1) + (if a[idx - 1] < 0 then 1 else 0)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountNeg(a: array<int>) returns (cnt: nat) \nensures cnt == verifyNeg(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function verifyNeg(a: array<int>, idx: int) : nat\nreads a\nrequires 0 <= idx <= a.Length\n{\n    if idx == 0 then 0 \n    else verifyNeg(a, idx - 1) + (if a[idx - 1] < 0 then 1 else 0)\n}\n\n// <vc-helpers>\nlemma VerifyNegIncremental(a: array<int>, idx: int)\n  requires 0 <= idx < a.Length\n  ensures verifyNeg(a, idx + 1) == verifyNeg(a, idx) + (if a[idx] < 0 then 1 else 0)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountNeg(a: array<int>) returns (cnt: nat) \nensures cnt == verifyNeg(a, a.Length)\n// </vc-spec>\n// <vc-code>\n{\n  cnt := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant cnt == verifyNeg(a, i)\n  {\n    if a[i] < 0 {\n      cnt := cnt + 1;\n    }\n    VerifyNegIncremental(a, i);\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_578_Interleave.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_578_Interleave.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Interleave(s1: seq<int>, s2: seq<int>, s3: seq<int>) returns (r: seq<int>)\n    requires |s1| == |s2| && |s2| == |s3|\n    ensures |r| == 3 * |s1|\n    ensures forall i :: 0 <= i < |s1| ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Interleave(s1: seq<int>, s2: seq<int>, s3: seq<int>) returns (r: seq<int>)\n    requires |s1| == |s2| && |s2| == |s3|\n    ensures |r| == 3 * |s1|\n    ensures forall i :: 0 <= i < |s1| ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i]\n// </vc-spec>\n// <vc-code>\n{\n    r := [];\n    var i := 0;\n    while i < |s1|\n        invariant 0 <= i <= |s1|\n        invariant |r| == 3 * i\n        invariant forall j :: 0 <= j < i ==> r[3*j] == s1[j] && r[3*j + 1] == s2[j] && r[3*j + 2] == s3[j]\n    {\n        r := r + [s1[i], s2[i], s3[i]];\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_602_FindFirstRepeatedChar.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_602_FindFirstRepeatedChar.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstRepeatedChar(s: string) returns (found: bool, c: char)\n    ensures found ==> exists i, j :: 0 <= i < j < |s| && s[i] == s[j] && s[i] == c && (forall k, l :: 0 <= k < l < j && s[k] == s[l] ==> k >= i)\n    ensures !found ==> (forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma NoRepeatsUpTo(s: string, limit: int)\n    requires 0 <= limit <= |s|\n    requires forall i, j :: 0 <= i < j < limit ==> s[i] != s[j]\n    ensures forall i, j :: 0 <= i < j < limit ==> s[i] != s[j]\n{\n}\n\nlemma FirstRepeatProperty(s: string, pos: int, c: char)\n    requires 0 <= pos < |s|\n    requires s[pos] == c\n    requires exists earlier :: 0 <= earlier < pos && s[earlier] == c\n    requires forall i, j :: 0 <= i < j < pos ==> s[i] != s[j]\n    ensures exists i, j :: 0 <= i < j < |s| && s[i] == s[j] && s[i] == c && (forall k, l :: 0 <= k < l < j && s[k] == s[l] ==> k >= i)\n{\n    var earlier :| 0 <= earlier < pos && s[earlier] == c;\n    assert s[earlier] == s[pos] && earlier < pos;\n    assert forall k, l :: 0 <= k < l < pos && s[k] == s[l] ==> k >= earlier;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstRepeatedChar(s: string) returns (found: bool, c: char)\n    ensures found ==> exists i, j :: 0 <= i < j < |s| && s[i] == s[j] && s[i] == c && (forall k, l :: 0 <= k < l < j && s[k] == s[l] ==> k >= i)\n    ensures !found ==> (forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j])\n// </vc-spec>\n// <vc-code>\n{\n    found := false;\n    c := if |s| > 0 then s[0] else 'a';\n    \n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant forall x, y :: 0 <= x < y < i ==> s[x] != s[y]\n        invariant !found\n    {\n        var j := 0;\n        while j < i\n            invariant 0 <= j <= i\n            invariant forall k :: 0 <= k < j ==> s[k] != s[i]\n            invariant forall x, y :: 0 <= x < y < i ==> s[x] != s[y]\n        {\n            if s[j] == s[i] {\n                found := true;\n                c := s[i];\n                FirstRepeatProperty(s, i, c);\n                return;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-exercise_tmp_tmpouftptir_appendArray_appendArray.dfy", "root", true, "", "", false, "dafny-exercise_tmp_tmpouftptir_appendArray_appendArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length + b.Length];\n  \n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> c[j] == a[j]\n  {\n    c[i] := a[i];\n    i := i + 1;\n  }\n  \n  var j := 0;\n  while j < b.Length\n    invariant 0 <= j <= b.Length\n    invariant forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n    invariant forall k :: 0 <= k < j ==> c[a.Length + k] == b[k]\n  {\n    c[a.Length + j] := b[j];\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["CVS-handout1_tmp_tmptm52no3k_1_queryFast.dfy", "root", true, "", "", false, "CVS-handout1_tmp_tmptm52no3k_1_queryFast.dfy", "// <vc-preamble>\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n    requires a.Length + 1 == c.Length && c[0] == 0\n    requires 0 <= i <= j <= a.Length\n    requires is_prefix_sum_for(a,c)  \n    ensures r == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\n\n\n//(b)\n\n\n\n\n//(c)\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}\n\n// <vc-helpers>\nlemma prefix_sum_property(a: array<int>, c: array<int>, i: int, j: int)\n    requires a.Length + 1 == c.Length && c[0] == 0\n    requires 0 <= i <= j <= a.Length\n    requires is_prefix_sum_for(a, c)\n    ensures c[j] - c[i] == sum(a, i, j)\n    decreases j - i\n{\n    if i == j {\n        assert sum(a, i, j) == 0;\n        assert c[j] - c[i] == 0;\n    } else {\n        prefix_sum_property(a, c, i+1, j);\n        assert c[j] - c[i+1] == sum(a, i+1, j);\n        assert c[i+1] == c[i] + a[i];\n        assert c[j] - c[i] == c[j] - c[i+1] + c[i+1] - c[i];\n        assert c[j] - c[i] == sum(a, i+1, j) + a[i];\n        assert sum(a, i, j) == a[i] + sum(a, i+1, j);\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n    requires a.Length + 1 == c.Length && c[0] == 0\n    requires 0 <= i <= j <= a.Length\n    requires is_prefix_sum_for(a,c)  \n    ensures r == sum(a, i, j)\n// </vc-spec>\n// <vc-code>\n{\n    prefix_sum_property(a, c, i, j);\n    r := c[j] - c[i];\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_273_SubtractSequences.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_273_SubtractSequences.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SubtractSequences(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] - b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SubtractSequences(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] - b[i]\n// </vc-spec>\n// <vc-code>\n{\n  result := [];\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == a[j] - b[j]\n  {\n    result := result + [a[i] - b[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_733_FindFirstOccurrence.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_733_FindFirstOccurrence.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOccurrence(arr: array<int>, target: int) returns (index: int)\n    requires arr != null\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures 0 <= index < arr.Length ==> arr[index] == target\n    ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma BinarySearchCorrectness(arr: array<int>, target: int, left: int, right: int, mid: int)\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    requires 0 <= left <= right <= arr.Length\n    requires left <= mid < right\n    requires arr[mid] >= target\n    ensures forall i :: left <= i < mid ==> arr[i] < target\n{\n    if mid > left {\n        assert forall i :: left <= i < mid ==> arr[i] <= arr[mid-1];\n        assert arr[mid-1] <= arr[mid];\n        if arr[mid-1] >= target {\n            assert arr[mid-1] >= target && arr[mid] >= target;\n            assert arr[mid-1] <= arr[mid];\n        }\n    }\n}\n\nlemma SortedArrayProperty(arr: array<int>, i: int, j: int)\n    requires forall x, y :: 0 <= x < y < arr.Length ==> arr[x] <= arr[y]\n    requires 0 <= i <= j < arr.Length\n    ensures arr[i] <= arr[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindFirstOccurrence(arr: array<int>, target: int) returns (index: int)\n    requires arr != null\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures 0 <= index < arr.Length ==> arr[index] == target\n    ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>\n// <vc-code>\n{\n    if arr.Length == 0 {\n        return -1;\n    }\n    \n    var left := 0;\n    var right := arr.Length;\n    \n    while left < right\n        invariant 0 <= left <= right <= arr.Length\n        invariant forall i :: 0 <= i < left ==> arr[i] < target\n        invariant forall i :: right <= i < arr.Length ==> arr[i] >= target\n        invariant forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n    {\n        var mid := left + (right - left) / 2;\n        \n        if arr[mid] < target {\n            left := mid + 1;\n        } else {\n            right := mid;\n        }\n    }\n    \n    if left < arr.Length && arr[left] == target {\n        return left;\n    } else {\n        return -1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger.dfy", "root", true, "", "", false, "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger.dfy", "// <vc-preamble>\ndatatype Bases = A | C | G | T\n\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// see pdf 'ex6 & 7 documentation' for excercise question\n\n\ndatatype Bases = A | C | G | T\n\n//swaps two sequence indexes\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\n//checks if a sequence is in base order\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n// </vc-spec>\n// <vc-code>\n{\n  t := s[x := s[y]][y := s[x]];\n}\n// </vc-code>\n\n", "", "", ""], ["dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial.dfy", "root", true, "", "", false, "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial.dfy", "// <vc-preamble>\nfunction Factorial(n: nat): nat {\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IterativeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// recursive definition of factorial\nfunction Factorial(n: nat): nat {\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\n// iterative implementation of factorial\n\n// <vc-helpers>\nlemma FactorialIterativeInvariant(i: nat, n: nat, acc: nat)\n  requires i <= n\n  requires acc == Factorial(i)\n  ensures acc * Factorial(n - i) == Factorial(n)\n  decreases n - i\n{\n  if i == n {\n    assert acc * Factorial(n - i) == acc * Factorial(0) == acc * 1 == acc == Factorial(i) == Factorial(n);\n  } else {\n    assert Factorial(n - i) == Factorial((n - i));\n    assert (n - i) > 0;\n    assert Factorial(n - i) == (n - i) * Factorial((n - i) - 1);\n    assert (n - i) - 1 == n - (i + 1);\n    assert Factorial(n - i) == (n - i) * Factorial(n - (i + 1));\n    \n    calc {\n      acc * Factorial(n - i);\n      acc * (n - i) * Factorial(n - (i + 1));\n      { assert acc == Factorial(i) && Factorial(i + 1) == (i + 1) * Factorial(i); \n        assert acc * (i + 1) == Factorial(i) * (i + 1) == Factorial(i + 1); }\n      (acc * (i + 1)) * Factorial(n - (i + 1));\n    }\n    \n    FactorialIterativeInvariant(i + 1, n, acc * (i + 1));\n  }\n}\n\nlemma FactorialRecursiveProperty(k: nat)\n  requires k > 0\n  ensures Factorial(k) == k * Factorial(k - 1)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod IterativeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n// </vc-spec>\n// <vc-code>\n{\n  result := 1;\n  var i := 0;\n  \n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    FactorialRecursiveProperty(i);\n    result := result * i;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3.dfy", "root", true, "", "", false, "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap3(a: array<int>, h: int, i: int, j: int)\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n  ensures a[h] == old(a[i]);\n  ensures a[j] == old(a[h]);\n  ensures a[i] == old(a[j]);\n  ensures forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap3(a: array<int>, h: int, i: int, j: int)\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n  ensures a[h] == old(a[i]);\n  ensures a[j] == old(a[h]);\n  ensures a[i] == old(a[j]);\n  ensures forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]);\n// </vc-spec>\n// <vc-code>\n{\n  var temp_h := a[h];\n  var temp_i := a[i];\n  var temp_j := a[j];\n  \n  a[h] := temp_i;\n  a[i] := temp_j;\n  a[j] := temp_h;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_match_Match.dfy", "root", true, "", "", false, "Clover_match_Match.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Match(s: string, p: string) returns (b: bool)\n  requires |s| == |p|\n  ensures b <==> forall n :: 0 <= n < |s| ==> s[n] == p[n] || p[n] == '?'\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Match(s: string, p: string) returns (b: bool)\n  requires |s| == |p|\n  ensures b <==> forall n :: 0 <= n < |s| ==> s[n] == p[n] || p[n] == '?'\n// </vc-spec>\n// <vc-code>\n{\n  b := true;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant b <==> forall n :: 0 <= n < i ==> s[n] == p[n] || p[n] == '?'\n  {\n    if s[i] != p[i] && p[i] != '?' {\n      b := false;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchLoop.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchLoop.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SearchLoop( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["FlexWeek_tmp_tmpc_tfdj_3_ex4_join.dfy", "root", true, "", "", false, "FlexWeek_tmp_tmpc_tfdj_3_ex4_join.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod join(a:array<int>,b:array<int>) returns (c:array<int>)\nensures a[..] + b[..] == c[..]\nensures multiset(a[..] + b[..]) == multiset(c[..])\nensures multiset(a[..]) + multiset(b[..]) == multiset(c[..])\nensures a.Length+b.Length == c.Length\n\nensures forall i :: 0<=i<a.Length ==> c[i] == a[i]\nensures forall i_2,j_2::\n    a.Length <= i_2 < c.Length &&\n    0<=j_2< b.Length && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma multiset_concatenation_property<T>(s1: seq<T>, s2: seq<T>)\n  ensures multiset(s1 + s2) == multiset(s1) + multiset(s2)\n{\n}\n\nlemma array_copy_preserves_sequence(src: array<int>, dest: array<int>, src_start: int, dest_start: int, length: int)\n  requires 0 <= src_start <= src_start + length <= src.Length\n  requires 0 <= dest_start <= dest_start + length <= dest.Length\n  requires forall i :: 0 <= i < length ==> dest[dest_start + i] == src[src_start + i]\n  ensures dest[dest_start..dest_start + length] == src[src_start..src_start + length]\n{\n}\n\nlemma sequence_concatenation_property(a: seq<int>, b: seq<int>, c: seq<int>)\n  requires c == a + b\n  ensures c[..] == a + b\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod join(a:array<int>,b:array<int>) returns (c:array<int>)\nensures a[..] + b[..] == c[..]\nensures multiset(a[..] + b[..]) == multiset(c[..])\nensures multiset(a[..]) + multiset(b[..]) == multiset(c[..])\nensures a.Length+b.Length == c.Length\n\n// Forall\n\nensures forall i :: 0<=i<a.Length ==> c[i] == a[i]\nensures forall i_2,j_2::\n    a.Length <= i_2 < c.Length &&\n    0<=j_2< b.Length && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2]\n// </vc-spec>\n// <vc-code>\n{\n  c := new int[a.Length + b.Length];\n  \n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> c[k] == a[k]\n  {\n    c[i] := a[i];\n    i := i + 1;\n  }\n  \n  var j := 0;\n  while j < b.Length\n    invariant 0 <= j <= b.Length\n    invariant forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n    invariant forall k :: 0 <= k < j ==> c[a.Length + k] == b[k]\n  {\n    c[a.Length + j] := b[j];\n    j := j + 1;\n  }\n  \n  assert forall k :: 0 <= k < a.Length ==> c[k] == a[k];\n  assert forall k :: 0 <= k < b.Length ==> c[a.Length + k] == b[k];\n  \n  assert c[..a.Length] == a[..];\n  assert c[a.Length..] == b[..];\n  assert c[..] == c[..a.Length] + c[a.Length..];\n  \n  multiset_concatenation_property(a[..], b[..]);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max.dfy", "root", true, "", "", false, "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max.dfy", "// <vc-preamble>\nfunction contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\n\n// <vc-helpers>\nlemma max_element_exists(a: array<int>, n: int)\n  requires 0 < n <= a.Length\n  ensures exists m :: is_max(m, a, n)\n{\n  var candidate := a[0];\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall j :: 0 <= j < i ==> a[j] <= candidate\n    invariant exists k :: 0 <= k < i && a[k] == candidate\n  {\n    if a[i] > candidate {\n      candidate := a[i];\n    }\n    i := i + 1;\n  }\n  assert is_max(candidate, a, n);\n}\n\nlemma update_max_correct(old_max: int, new_val: int, a: array<int>, i: int)\n  requires 0 <= i < a.Length\n  requires a[i] == new_val\n  requires forall j :: 0 <= j < i ==> a[j] <= old_max\n  ensures new_val > old_max ==> \n    (forall j :: 0 <= j <= i ==> a[j] <= new_val) &&\n    (exists k :: 0 <= k <= i && a[k] == new_val)\n{\n  if new_val > old_max {\n    assert a[i] == new_val;\n    assert exists k :: 0 <= k <= i && a[k] == new_val;\n    \n    forall j | 0 <= j <= i \n      ensures a[j] <= new_val\n    {\n      if j < i {\n        assert a[j] <= old_max;\n        assert old_max < new_val;\n        assert a[j] <= new_val;\n      } else {\n        assert j == i;\n        assert a[j] == new_val;\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n// </vc-spec>\n// <vc-code>\n{\n  max := a[0];\n  var i := 1;\n  \n  while i < n\n    invariant 1 <= i <= n\n    invariant forall j :: 0 <= j < i ==> a[j] <= max\n    invariant exists k :: 0 <= k < i && a[k] == max\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n  \n  assert forall j :: 0 <= j < n ==> a[j] <= max;\n  assert exists k :: 0 <= k < n && a[k] == max;\n  assert contains(max, a, n);\n  assert upper_bound(max, a, n);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement.dfy", "root", true, "", "", false, "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindPositionOfElement(a:array<int>,Element:nat,n1:nat,s1:seq<int>) returns (Position:int,Count:nat)\n        requires n1 == |s1| && 0 <= n1 <= a.Length\n        requires forall i:: 0<= i < |s1| ==> a[i] == s1[i]\n        ensures Position == -1 || Position >= 1\n        ensures |s1| != 0 && Position >= 1 ==> exists i:: 0 <= i < |s1| && s1[i] == Element\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma ElementFoundImpliesExists(s: seq<int>, element: int, pos: int)\n    requires 0 <= pos < |s|\n    requires s[pos] == element\n    ensures exists i :: 0 <= i < |s| && s[i] == element\n{\n    // The witness is pos itself\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindPositionOfElement(a:array<int>,Element:nat,n1:nat,s1:seq<int>) returns (Position:int,Count:nat)\n        requires n1 == |s1| && 0 <= n1 <= a.Length\n        requires forall i:: 0<= i < |s1| ==> a[i] == s1[i]\n        ensures Position == -1 || Position >= 1\n        ensures |s1| != 0 && Position >= 1 ==> exists i:: 0 <= i < |s1| && s1[i] == Element\n// </vc-spec>\n// <vc-code>\n{\n    Position := -1;\n    Count := 0;\n    \n    if n1 == 0 {\n        return;\n    }\n    \n    var i := 0;\n    while i < n1\n        invariant 0 <= i <= n1\n        invariant Position == -1 || Position >= 1\n        invariant Position >= 1 ==> exists j :: 0 <= j < |s1| && s1[j] == Element\n    {\n        if a[i] == Element {\n            Position := i + 1;\n            ElementFoundImpliesExists(s1, Element, i);\n            Count := Count + 1;\n        } else {\n            Count := Count + 1;\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify.dfy", "root", true, "", "", false, "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PalVerify(a: array<char>) returns (yn: bool)\nensures yn == true ==> forall i :: 0 <= i < a.Length/2 ==> a[i] == a[a.Length - i -1]\nensures yn == false ==> exists i :: 0 <= i < a.Length/2 && a[i] != a[a.Length - i -1]\nensures forall j :: 0<=j<a.Length ==> a[j] == old(a[j])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ex3errors.dfy in Assignment 1\n// verify that an array of characters is a Palindrome\n/*\nA Palindrome is a word that is the same when written forwards and when written backwards. \nFor example, the word \u201drefer\u201d is a Palindrome.\nThe method PalVerify is supposed to verify whether a word is a Palindrome, \nwhere the word is represented as an array of characters. \nThe method was written by a novice software engineer, and contains many errors.\n\n   i) Without changing the signature or the code in the while loop, \n      fix the method so that it veriifes the code. Do not add any Dafny predicates or functions: \n      keep the changes to a minimum.\n\n   ii) Write a tester method (you may call it anything you like) that verifies that the \n      testcases refer, z and the empty string are Palindromes, and xy and 123421 are not. \n      The tester should not generate any output.\n*/\n\n// <vc-helpers>\nlemma PalindromeProperty(a: array<char>)\n  requires forall i :: 0 <= i < a.Length/2 ==> a[i] == a[a.Length - i - 1]\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == a[a.Length - i - 1]\n{\n  forall i | 0 <= i < a.Length\n    ensures a[i] == a[a.Length - i - 1]\n  {\n    if i < a.Length/2 {\n      // Direct from precondition\n    } else if i >= a.Length/2 {\n      var j := a.Length - i - 1;\n      if j < a.Length/2 {\n        assert a[j] == a[a.Length - j - 1];\n        assert a.Length - j - 1 == i;\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod PalVerify(a: array<char>) returns (yn: bool)\nensures yn == true ==> forall i :: 0 <= i < a.Length/2 ==> a[i] == a[a.Length - i -1]\nensures yn == false ==> exists i :: 0 <= i < a.Length/2 && a[i] != a[a.Length - i -1]\nensures forall j :: 0<=j<a.Length ==> a[j] == old(a[j])\n// </vc-spec>\n// <vc-code>\n{\n  if a.Length == 0 {\n    return true;\n  }\n  \n  var i := 0;\n  while i < a.Length/2\n    invariant 0 <= i <= a.Length/2\n    invariant forall k :: 0 <= k < i ==> a[k] == a[a.Length - k - 1]\n    invariant forall j :: 0 <= j < a.Length ==> a[j] == old(a[j])\n  {\n    if a[i] != a[a.Length - i - 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_599_SumAndAverage.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_599_SumAndAverage.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumAndAverage(n: int) returns (sum: int, average: real)\n    requires n > 0\n    ensures sum == n * (n + 1) / 2\n    ensures average == sum as real / n as real\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumAndAverage(n: int) returns (sum: int, average: real)\n    requires n > 0\n    ensures sum == n * (n + 1) / 2\n    ensures average == sum as real / n as real\n// </vc-spec>\n// <vc-code>\n{\n  sum := n * (n + 1) / 2;\n  average := sum as real / n as real;\n}\n// </vc-code>\n\n", "", "", ""], ["Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort.dfy", "root", true, "", "", false, "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort.dfy", "// <vc-preamble>\npredicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}\n\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod quickSort(Seq: seq<int>) returns (Seq': seq<int>)\n  ensures multiset(Seq) == multiset(Seq')\n  decreases |Seq|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}\n\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma QuickSortCorrectness(Seq: seq<int>, Seq': seq<int>)\n  requires multiset(Seq) == multiset(Seq')\n  requires quickSorted(Seq')\n  ensures quickSorted(Seq')\n{\n}\n\nlemma ConcatPreservesMultiset<T>(s1: seq<T>, s2: seq<T>)\n  ensures multiset(s1 + s2) == multiset(s1) + multiset(s2)\n{\n}\n\nlemma SingletonSorted(x: int)\n  ensures quickSorted([x])\n{\n}\n\nlemma EmptySorted()\n  ensures quickSorted([])\n{\n}\n\nlemma MultisetMembership<T>(s1: seq<T>, s2: seq<T>, x: T)\n  requires multiset(s1) == multiset(s2)\n  requires x in s1\n  ensures x in s2\n{\n}\n\nlemma ConcatSorted(s1: seq<int>, pivot: int, s2: seq<int>)\n  requires quickSorted(s1)\n  requires quickSorted(s2)\n  requires forall x | x in s1 :: x <= pivot\n  requires forall x | x in s2 :: x >= pivot\n  ensures quickSorted(s1 + [pivot] + s2)\n{\n  var result := s1 + [pivot] + s2;\n  forall i, j | 0 <= i < j < |result|\n    ensures result[i] <= result[j]\n  {\n    if i < |s1| && j < |s1| {\n      assert result[i] == s1[i] && result[j] == s1[j];\n      assert quickSorted(s1);\n    } else if i < |s1| && j == |s1| {\n      assert result[i] == s1[i] && result[j] == pivot;\n      assert s1[i] in s1;\n      assert s1[i] <= pivot;\n    } else if i < |s1| && j > |s1| {\n      assert result[i] == s1[i] && result[j] == s2[j - |s1| - 1];\n      assert s1[i] in s1;\n      assert s1[i] <= pivot;\n      assert j - |s1| - 1 >= 0;\n      assert j - |s1| - 1 < |s2|;\n      assert s2[j - |s1| - 1] in s2;\n      assert s2[j - |s1| - 1] >= pivot;\n    } else if i == |s1| && j > |s1| {\n      assert result[i] == pivot && result[j] == s2[j - |s1| - 1];\n      assert j - |s1| - 1 >= 0;\n      assert j - |s1| - 1 < |s2|;\n      assert s2[j - |s1| - 1] in s2;\n      assert s2[j - |s1| - 1] >= pivot;\n    } else if i > |s1| && j > |s1| {\n      assert result[i] == s2[i - |s1| - 1] && result[j] == s2[j - |s1| - 1];\n      assert quickSorted(s2);\n      assert i - |s1| - 1 < j - |s1| - 1;\n    }\n  }\n}\n\nlemma QuickSortSorted(Seq: seq<int>, result: seq<int>)\n  requires multiset(Seq) == multiset(result)\n  requires |Seq| <= 1 ==> quickSorted(result)\n  requires |Seq| > 1 ==> (\n    var pivot := Seq[0];\n    var rest := Seq[1..];\n    exists smaller: seq<int>, larger: seq<int>, sortedSmaller: seq<int>, sortedLarger: seq<int> ::\n      (forall x | x in smaller :: x <= pivot) &&\n      (forall x | x in larger :: x >= pivot) &&\n      multiset(smaller) + multiset(larger) == multiset(rest) &&\n      multiset(sortedSmaller) == multiset(smaller) &&\n      multiset(sortedLarger) == multiset(larger) &&\n      quickSorted(sortedSmaller) &&\n      quickSorted(sortedLarger) &&\n      result == sortedSmaller + [pivot] + sortedLarger\n  )\n  ensures quickSorted(result)\n{\n  if |Seq| <= 1 {\n  } else {\n    var pivot := Seq[0];\n    var rest := Seq[1..];\n    var smaller: seq<int>, larger: seq<int>, sortedSmaller: seq<int>, sortedLarger: seq<int> :|\n      (forall x | x in smaller :: x <= pivot) &&\n      (forall x | x in larger :: x >= pivot) &&\n      multiset(smaller) + multiset(larger) == multiset(rest) &&\n      multiset(sortedSmaller) == multiset(smaller) &&\n      multiset(sortedLarger) == multiset(larger) &&\n      quickSorted(sortedSmaller) &&\n      quickSorted(sortedLarger) &&\n      result == sortedSmaller + [pivot] + sortedLarger;\n    \n    assert forall x | x in sortedSmaller :: x <= pivot by {\n      forall x | x in sortedSmaller\n        ensures x <= pivot\n      {\n        MultisetMembership(sortedSmaller, smaller, x);\n        assert x in smaller;\n      }\n    }\n    \n    assert forall x | x in sortedLarger :: x >= pivot by {\n      forall x | x in sortedLarger\n        ensures x >= pivot\n      {\n        MultisetMembership(sortedLarger, larger, x);\n        assert x in larger;\n      }\n    }\n    \n    ConcatSorted(sortedSmaller, pivot, sortedLarger);\n  }\n}\n\nlemma MultisetIncludesPivot(pivot: int, rest: seq<int>, smaller: seq<int>, larger: seq<int>)\n  requires multiset(smaller) + multiset(larger) == multiset(rest)\n  ensures multiset([pivot]) + multiset(rest) == multiset([pivot]) + multiset(smaller) + multiset(larger)\n{\n}\n\nlemma SliceMultisetProperty(Seq: seq<int>)\n  requires |Seq| > 0\n  ensures multiset([Seq[0]]) + multiset(Seq[1..]) == multiset(Seq)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod quickSort(Seq: seq<int>) returns (Seq': seq<int>)\n  ensures multiset(Seq) == multiset(Seq')\n  decreases |Seq|\n// </vc-spec>\n// <vc-code>\n{\n  if |Seq| <= 1 {\n    if |Seq| == 0 {\n      EmptySorted();\n      return Seq;\n    } else {\n      SingletonSorted(Seq[0]);\n      return Seq;\n    }\n  }\n  \n  var pivot := Seq[0];\n  var rest := Seq[1..];\n  \n  var smaller, larger := threshold(pivot, rest);\n  \n  var sortedSmaller := quickSort(smaller);\n  var sortedLarger := quickSort(larger);\n  \n  assert forall x | x in sortedSmaller :: x <= pivot by {\n    forall x | x in sortedSmaller\n      ensures x <= pivot\n    {\n      MultisetMembership(sortedSmaller, smaller, x);\n    }\n  }\n  assert forall x | x in sortedLarger :: x >= pivot by {\n    forall x | x in sortedLarger\n      ensures x >= pivot\n    {\n      MultisetMembership(sortedLarger, larger, x);\n    }\n  }\n  \n  var result := sortedSmaller + [pivot] + sortedLarger;\n  \n  ConcatPreservesMultiset(sortedSmaller, [pivot] + sortedLarger);\n  ConcatPreservesMultiset([pivot], sortedLarger);\n  ConcatSorted(sortedSmaller, pivot, sortedLarger);\n  \n  MultisetIncludesPivot(pivot, rest, smaller, larger);\n  SliceMultisetProperty(Seq);\n  \n  assert multiset(result) == multiset(sortedSmaller) + multiset([pivot]) + multiset(sortedLarger);\n  assert multiset(result) == multiset(smaller) + multiset([pivot]) + multiset(larger);\n  assert multiset(result) == multiset(rest) + multiset([pivot]);\n  assert multiset(result) == multiset(Seq[1..]) + multiset([Seq[0]]);\n  assert multiset(result) == multiset(Seq);\n  \n  return result;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_bubbleSort.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_bubbleSort.dfy", "// <vc-preamble>\npredicate sorted(a:array<int>, from:int, to:int)\n  requires a != null;\n  reads a;\n  requires 0 <= from <= to <= a.Length;\n{\n  forall u, v :: from <= u < v < to ==> a[u] <= a[v]\n}\n\npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null;\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall u, v :: 0 <= u < pvt < v < to ==> a[u] <= a[v]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod bubbleSort (a: array<int>)\n  requires a != null && a.Length > 0;\n  modifies a;\n  ensures sorted(a, 0, a.Length);\n  ensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_644_Reverse.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_644_Reverse.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse(a: array<int>)\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length-1) - k]);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Reverse(a: array<int>)\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length-1) - k]);\n// </vc-spec>\n// <vc-code>\n{\n    var i := 0;\n    var j := a.Length - 1;\n    \n    while i < j\n        invariant 0 <= i <= j + 1 <= a.Length\n        invariant forall k :: 0 <= k < i ==> a[k] == old(a[(a.Length-1) - k])\n        invariant forall k :: j < k < a.Length ==> a[k] == old(a[(a.Length-1) - k])\n        invariant forall k :: i <= k <= j ==> a[k] == old(a[k])\n        invariant forall k :: i <= k <= j ==> a[(a.Length-1) - k] == old(a[(a.Length-1) - k])\n    {\n        var temp := a[i];\n        a[i] := a[j];\n        a[j] := temp;\n        i := i + 1;\n        j := j - 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_554_FindOddNumbers.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_554_FindOddNumbers.dfy", "// <vc-preamble>\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n\n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n * Find odd numbers from an array of numbers\n **/\n\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\n\n// <vc-helpers>\nlemma OddPreserved(x: int)\n    requires IsOdd(x)\n    ensures IsOdd(x)\n{\n}\n\nlemma InArrayPreserved(x: int, arr: array<int>, i: int)\n    requires 0 <= i < arr.Length\n    requires arr[i] == x\n    ensures x in arr[..]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>\n// <vc-code>\n{\n    oddList := [];\n    var i := 0;\n    \n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant forall j :: 0 <= j < |oddList| ==> IsOdd(oddList[j]) && oddList[j] in arr[..]\n        invariant forall j :: 0 <= j < i && IsOdd(arr[j]) ==> arr[j] in oddList\n    {\n        if IsOdd(arr[i]) {\n            oddList := oddList + [arr[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchRecursive.dfy", "root", false, "", "", false, "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchRecursive.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SearchRecursive( a: seq<real>, i: int, j: int, x: real ) returns ( k: int )\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    requires forall p, q :: i <= p < q < j ==> a[p] >= a[q];\n    ensures i <= k <= j\n    ensures forall r | i <= r < k :: a[r] >= x;\n    ensures forall r | k <= r < j :: a[r] < x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_572_RemoveDuplicates.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_572_RemoveDuplicates.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveDuplicates(a: array<int>) returns (result: seq<int>)\n    requires a != null\n    ensures forall x :: x in result <==> exists i :: 0 <= i < a.Length && a[i] == x\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma InSeqImpliesInArray(a: array<int>, s: seq<int>, x: int, bound: int)\n    requires 0 <= bound <= a.Length\n    requires forall y :: y in s <==> exists i :: 0 <= i < bound && a[i] == y\n    requires x in s\n    ensures exists i :: 0 <= i < bound && a[i] == x\n{\n}\n\nlemma InArrayAndNotInSeqImpliesCanAdd(a: array<int>, s: seq<int>, x: int, bound: int, idx: int)\n    requires 0 <= bound <= a.Length\n    requires 0 <= idx < bound\n    requires a[idx] == x\n    requires x !in s\n    requires forall y :: y in s ==> exists i :: 0 <= i < bound && a[i] == y\n    ensures forall y :: y in s + [x] ==> exists i :: 0 <= i < bound && a[i] == y\n{\n}\n\nlemma NoDuplicatesPreserved(s: seq<int>, x: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n    requires x !in s\n    ensures forall i, j :: 0 <= i < j < |s + [x]| ==> (s + [x])[i] != (s + [x])[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveDuplicates(a: array<int>) returns (result: seq<int>)\n    requires a != null\n    ensures forall x :: x in result <==> exists i :: 0 <= i < a.Length && a[i] == x\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    \n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x :: x in result <==> exists j :: 0 <= j < i && a[j] == x\n        invariant forall k, l :: 0 <= k < l < |result| ==> result[k] != result[l]\n    {\n        if a[i] !in result {\n            InArrayAndNotInSeqImpliesCanAdd(a, result, a[i], i + 1, i);\n            NoDuplicatesPreserved(result, a[i]);\n            result := result + [a[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch.dfy", "// <vc-preamble>\npredicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\n// <vc-helpers>\nlemma sortedSliceProperty(v: array<int>, low: int, high: int, mid: int)\n  requires 0 <= low <= mid < high <= v.Length\n  requires sorted(v[0..v.Length])\n  ensures sorted(v[low..high])\n  ensures forall i :: low <= i < mid ==> v[i] <= v[mid]\n  ensures forall i :: mid < i < high ==> v[mid] <= v[i]\n{\n}\n\nlemma binarySearchInvariant(v: array<int>, elem: int, low: int, high: int)\n  requires 0 <= low <= high <= v.Length\n  requires sorted(v[0..v.Length])\n  requires forall u :: 0 <= u < low ==> v[u] <= elem\n  requires forall w :: high <= w < v.Length ==> v[w] > elem\n  ensures forall u :: 0 <= u < low ==> v[u] <= elem\n  ensures forall w :: high <= w < v.Length ==> v[w] > elem\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>\n// <vc-code>\n{\n  var low := 0;\n  var high := v.Length;\n  \n  while low < high\n    invariant 0 <= low <= high <= v.Length\n    invariant forall u :: 0 <= u < low ==> v[u] <= elem\n    invariant forall w :: high <= w < v.Length ==> v[w] > elem\n    decreases high - low\n  {\n    var mid := (low + high) / 2;\n    \n    if v[mid] <= elem {\n      low := mid + 1;\n    } else {\n      high := mid;\n    }\n  }\n  \n  p := low - 1;\n}\n// </vc-code>\n\n//Recursive binary search", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_non_overlapping_intervals.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_non_overlapping_intervals.dfy", "// <vc-preamble>\nmethod bubble_sort(a: array2<int>)\n    modifies a\n    requires a.Length1 == 2\n    ensures sorted(a, 0, a.Length0 - 1)\n{\n  assume{:axiom} false;\n}\n\npredicate sorted(a: array2<int>, l: int, u: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length0 ==> a[i, 1] <= a[j, 1]\n}\n\npredicate partitioned(a: array2<int>, i: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall k, k' :: 0 <= k <= i < k' < a.Length0 ==> a[k, 1] <= a[k', 1]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod non_overlapping_intervals(intervals: array2<int>) returns (count: int)\n    modifies intervals\n    requires 1 <= intervals.Length0 <= 100000\n    requires intervals.Length1 == 2\n    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000\n    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000\n\n    ensures count >= 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Clover_swap_in_array_swap.dfy", "root", true, "", "", false, "Clover_swap_in_array_swap.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n// </vc-spec>\n// <vc-code>\n{\n  var temp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := temp;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_171_PentagonPerimeter.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_171_PentagonPerimeter.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod PentagonPerimeter(side: int) returns (perimeter: int)\n    requires side > 0\n    ensures perimeter == 5 * side\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod PentagonPerimeter(side: int) returns (perimeter: int)\n    requires side > 0\n    ensures perimeter == 5 * side\n// </vc-spec>\n// <vc-code>\n{\n  perimeter := 5 * side;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_430_ParabolaDirectrix.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_430_ParabolaDirectrix.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ParabolaDirectrix(a: real, h: real, k: real) returns (directrix: real)\n    requires a != 0.0\n    ensures directrix == k - 1.0 / (4.0 * a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ParabolaDirectrix(a: real, h: real, k: real) returns (directrix: real)\n    requires a != 0.0\n    ensures directrix == k - 1.0 / (4.0 * a)\n// </vc-spec>\n// <vc-code>\n{\n  directrix := k - 1.0 / (4.0 * a);\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_145_MaxDifference.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_145_MaxDifference.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma MaxMinDifferenceIsMaximal(a: array<int>, max_val: int, min_val: int)\n    requires a.Length > 0\n    requires forall i :: 0 <= i < a.Length ==> a[i] <= max_val\n    requires forall i :: 0 <= i < a.Length ==> a[i] >= min_val\n    requires exists i :: 0 <= i < a.Length && a[i] == max_val\n    requires exists i :: 0 <= i < a.Length && a[i] == min_val\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= max_val - min_val\n{\n    forall i, j | 0 <= i < a.Length && 0 <= j < a.Length\n        ensures a[i] - a[j] <= max_val - min_val\n    {\n        assert a[i] <= max_val;\n        assert a[j] >= min_val;\n        assert a[i] - a[j] <= max_val - min_val;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n// </vc-spec>\n// <vc-code>\n{\n    var max_val := a[0];\n    var min_val := a[0];\n    \n    var i := 1;\n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> a[k] <= max_val\n        invariant forall k :: 0 <= k < i ==> a[k] >= min_val\n        invariant exists k :: 0 <= k < i && a[k] == max_val\n        invariant exists k :: 0 <= k < i && a[k] == min_val\n    {\n        if a[i] > max_val {\n            max_val := a[i];\n        }\n        if a[i] < min_val {\n            min_val := a[i];\n        }\n        i := i + 1;\n    }\n    \n    MaxMinDifferenceIsMaximal(a, max_val, min_val);\n    diff := max_val - min_val;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_750_AddTupleToList.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_750_AddTupleToList.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AddTupleToList(l: seq<(int, int)>, t: (int, int)) returns (r: seq<(int, int)>)\n    ensures |r| == |l| + 1\n    ensures r[|r| - 1] == t\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AddTupleToList(l: seq<(int, int)>, t: (int, int)) returns (r: seq<(int, int)>)\n    ensures |r| == |l| + 1\n    ensures r[|r| - 1] == t\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i]\n// </vc-spec>\n// <vc-code>\n{\n  r := l + [t];\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_474_ReplaceChars.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_474_ReplaceChars.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n  v := \"\";\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant |v| == i\n    invariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> v[j] == newChar) && (s[j] != oldChar ==> v[j] == s[j])\n  {\n    if s[i] == oldChar {\n      v := v + [newChar];\n    } else {\n      v := v + [s[i]];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_249_Intersection.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_249_Intersection.dfy", "// <vc-preamble>\npredicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Intersection(a: array<int>, b: array<int>) returns (result: seq<int>)\n\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n\n// <vc-helpers>\nlemma InArrayExists(arr: array<int>, x: int, idx: int)\n    requires 0 <= idx < arr.Length\n    requires arr[idx] == x\n    ensures InArray(arr, x)\n{\n}\n\npredicate SeqContains(s: seq<int>, x: int)\n{\n    exists i :: 0 <= i < |s| && s[i] == x\n}\n\nlemma SeqContainsAppend(s: seq<int>, x: int)\n    requires !SeqContains(s, x)\n    ensures SeqContains(s + [x], x)\n    ensures forall y :: y != x ==> (SeqContains(s + [x], y) <==> SeqContains(s, y))\n{\n    // Prove that x is in s + [x] at the last position\n    assert (s + [x])[|s|] == x;\n    assert |s + [x]| == |s| + 1;\n    assert 0 <= |s| < |s + [x]|;\n    \n    // Prove SeqContains(s + [x], x)\n    assert exists i :: 0 <= i < |s + [x]| && (s + [x])[i] == x;\n    \n    // Prove the equivalence for other elements\n    forall y | y != x\n        ensures SeqContains(s + [x], y) <==> SeqContains(s, y)\n    {\n        if SeqContains(s, y) {\n            var i :| 0 <= i < |s| && s[i] == y;\n            assert (s + [x])[i] == s[i] == y;\n            assert 0 <= i < |s + [x]|;\n        }\n        \n        if SeqContains(s + [x], y) {\n            var i :| 0 <= i < |s + [x]| && (s + [x])[i] == y;\n            if i < |s| {\n                assert s[i] == (s + [x])[i] == y;\n            } else {\n                assert i == |s|;\n                assert (s + [x])[i] == x;\n                assert y == x;\n                assert false;\n            }\n        }\n    }\n}\n\nlemma SeqDistinctPreserved(s: seq<int>, x: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n    requires !SeqContains(s, x)\n    ensures forall i, j :: 0 <= i < j < |s + [x]| ==> (s + [x])[i] != (s + [x])[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Intersection(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    \n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n        invariant forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n    {\n        var j := 0;\n        var found := false;\n        \n        while j < b.Length && !found\n            invariant 0 <= j <= b.Length\n            invariant found ==> (j > 0 && b[j-1] == a[i])\n            invariant !found ==> forall k :: 0 <= k < j ==> b[k] != a[i]\n        {\n            if b[j] == a[i] {\n                found := true;\n                InArrayExists(b, a[i], j);\n            }\n            j := j + 1;\n        }\n        \n        if found && a[i] !in result {\n            InArrayExists(a, a[i], i);\n            SeqContainsAppend(result, a[i]);\n            SeqDistinctPreserved(result, a[i]);\n            result := result + [a[i]];\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_227_MinOfThree.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_227_MinOfThree.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinOfThree(a: int, b: int, c: int) returns (min: int)\n    ensures min <= a && min <= b && min <= c\n    ensures (min == a) || (min == b) || (min == c)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinOfThree(a: int, b: int, c: int) returns (min: int)\n    ensures min <= a && min <= b && min <= c\n    ensures (min == a) || (min == b) || (min == c)\n// </vc-spec>\n// <vc-code>\n{\n  if a <= b && a <= c {\n    min := a;\n  } else if b <= c {\n    min := b;\n  } else {\n    min := c;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max.dfy", "root", true, "", "", false, "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a: array<int>, b: array<int>, i: int, j: int)\n  returns (m: int)\n  requires 0 <= i < a.Length\n  requires 0 <= j < b.Length\n  ensures  a[i] > b[j] ==> m == a[i]\n  ensures  a[i] <= b[j] ==> m == b[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod max(a: array<int>, b: array<int>, i: int, j: int)\n  returns (m: int)\n  requires 0 <= i < a.Length\n  requires 0 <= j < b.Length\n  ensures  a[i] > b[j] ==> m == a[i]\n  ensures  a[i] <= b[j] ==> m == b[j]\n// </vc-spec>\n// <vc-code>\n{\n  if a[i] > b[j] {\n    m := a[i];\n  } else {\n    m := b[j];\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray.dfy", "root", true, "", "", false, "DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod InvertArray(a: array<int>)\n  modifies a\n  ensures forall i | 0 <= i < a.Length :: a[i] == old(a[a.Length-1-i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/**\n  Inverts an array of ints.\n */\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod InvertArray(a: array<int>)\n  modifies a\n  ensures forall i | 0 <= i < a.Length :: a[i] == old(a[a.Length-1-i])\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k | 0 <= k < i :: a[k] == old(a[a.Length-1-k])\n    invariant forall k | a.Length - i <= k < a.Length :: a[k] == old(a[a.Length-1-k])\n    invariant forall k | i <= k < a.Length - i :: a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_94_MinSecondValueFirst.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_94_MinSecondValueFirst.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma MinExistsLemma(s: array<seq<int>>) \n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minIndex := 0;\n    var k := 1;\n    \n    while k < s.Length\n        invariant 1 <= k <= s.Length\n        invariant 0 <= minIndex < s.Length\n        invariant forall j :: 0 <= j < k ==> s[minIndex][1] <= s[j][1]\n    {\n        if s[k][1] < s[minIndex][1] {\n            minIndex := k;\n        }\n        k := k + 1;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n// </vc-spec>\n// <vc-code>\n{\n    MinExistsLemma(s);\n    \n    var minIndex := 0;\n    var i := 1;\n    \n    while i < s.Length\n        invariant 1 <= i <= s.Length\n        invariant 0 <= minIndex < s.Length\n        invariant forall j :: 0 <= j < i ==> s[minIndex][1] <= s[j][1]\n    {\n        if s[i][1] < s[minIndex][1] {\n            minIndex := i;\n        }\n        i := i + 1;\n    }\n    \n    firstOfMinSecond := s[minIndex][0];\n}\n// </vc-code>\n\n", "", "", ""], ["feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort.dfy", "root", true, "", "", false, "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort.dfy", "// <vc-preamble>\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSort(a: array<real>)\n  modifies a\n  ensures isSorted(a, 0, a.Length) \n  ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/* \n* Formal verification of the selection sort algorithm with Dafny.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a miminum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n{\n  assume{:axiom} false;\n}\n\n// <vc-helpers>\nlemma sortedExtension(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to < a.Length\n  requires isSorted(a, from, to)\n  requires forall k :: from <= k <= to ==> a[to] <= a[k]\n  ensures isSorted(a, from, to + 1)\n{\n  forall i, j | from <= i < j < to + 1\n    ensures a[i] <= a[j]\n  {\n    if j < to {\n      assert isSorted(a, from, to);\n      assert from <= i < j < to;\n      assert a[i] <= a[j];\n    } else {\n      assert j == to;\n      if i < to {\n        assert from <= i < to;\n        assert forall k :: from <= k <= to ==> a[to] <= a[k];\n        assert a[to] <= a[i];\n        assert isSorted(a, from, to);\n        assert a[i] <= a[to];\n      }\n    }\n  }\n}\n\nlemma sortedPreservation(a: array<real>, from: nat, to: nat, pos: nat)\n  requires 0 <= from <= pos < to <= a.Length\n  requires isSorted(a, from, pos)\n  requires forall k :: pos <= k < to ==> a[pos] <= a[k]\n  ensures isSorted(a, from, pos + 1)\n{\n  forall i, j | from <= i < j < pos + 1\n    ensures a[i] <= a[j]\n  {\n    if j < pos {\n      assert from <= i < j < pos;\n      assert isSorted(a, from, pos);\n      assert a[i] <= a[j];\n    } else {\n      assert j == pos;\n      if i < pos {\n        assert from <= i < pos;\n        assert isSorted(a, from, pos);\n        assert forall k :: pos <= k < to ==> a[pos] <= a[k];\n        assert a[i] <= a[pos];\n        assert a[i] <= a[j];\n      }\n    }\n  }\n}\n\nlemma multisetSwapLemma(oldSeq: seq<real>, newSeq: seq<real>, i: nat, j: nat)\n  requires 0 <= i < |oldSeq| && 0 <= j < |oldSeq|\n  requires |newSeq| == |oldSeq|\n  requires newSeq[i] == oldSeq[j]\n  requires newSeq[j] == oldSeq[i]\n  requires forall k :: 0 <= k < |oldSeq| && k != i && k != j ==> newSeq[k] == oldSeq[k]\n  ensures multiset(newSeq) == multiset(oldSeq)\n{\n  if i == j {\n    assert newSeq == oldSeq;\n  } else {\n    var m1 := multiset(oldSeq);\n    var m2 := multiset(newSeq);\n    \n    forall x\n      ensures m1[x] == m2[x]\n    {\n      if x == oldSeq[i] && x == oldSeq[j] {\n        assert m1[x] == m2[x];\n      } else if x == oldSeq[i] && x != oldSeq[j] {\n        assert m1[x] == m2[x];\n      } else if x == oldSeq[j] && x != oldSeq[i] {\n        assert m1[x] == m2[x];\n      } else {\n        assert m1[x] == m2[x];\n      }\n    }\n  }\n}\n\nlemma swapPreservesOrderInvariant(a: array<real>, i: nat, minIndex: nat)\n  requires 0 <= i < minIndex < a.Length\n  requires forall p, q :: 0 <= p < i <= q < a.Length ==> a[p] <= a[q]\n  requires forall k :: i <= k < a.Length ==> a[k] >= a[minIndex]\n  modifies a\n  ensures forall p, q :: 0 <= p < i + 1 <= q < a.Length ==> old(a)[p] <= old(a)[q] || (p == i && old(a)[p] <= old(a)[minIndex]) || (q == minIndex && old(a)[i] <= old(a)[q])\n{\n}\n\nlemma swapPreservesSorted(a: array<real>, i: nat, minIndex: nat, oldA: seq<real>)\n  requires 0 <= i < minIndex < a.Length\n  requires oldA == old(a[..])\n  requires isSorted(a, 0, i)\n  requires forall k :: i <= k < a.Length ==> oldA[k] >= oldA[minIndex]\n  requires a[i] == oldA[minIndex]\n  requires a[minIndex] == oldA[i]\n  requires forall k :: 0 <= k < a.Length && k != i && k != minIndex ==> a[k] == oldA[k]\n  ensures isSorted(a, 0, i + 1)\n  ensures forall p, q :: 0 <= p < i + 1 <= q < a.Length ==> a[p] <= a[q]\n{\n  assert forall k :: 0 <= k < i ==> a[k] == oldA[k];\n  assert a[i] == oldA[minIndex];\n  \n  forall p, q | 0 <= p < i + 1 && i + 1 <= q < a.Length\n    ensures a[p] <= a[q]\n  {\n    if p < i {\n      if q == minIndex {\n        assert a[q] == oldA[i];\n        assert oldA[p] <= oldA[i];\n        assert a[p] == oldA[p];\n        assert a[p] <= a[q];\n      } else {\n        assert a[q] == oldA[q];\n        assert oldA[p] <= oldA[q];\n        assert a[p] == oldA[p];\n        assert a[p] <= a[q];\n      }\n    } else {\n      assert p == i;\n      assert a[p] == oldA[minIndex];\n      if q == minIndex {\n        assert a[q] == oldA[i];\n        assert oldA[minIndex] <= oldA[i];\n        assert a[p] <= a[q];\n      } else {\n        assert a[q] == oldA[q];\n        assert oldA[minIndex] <= oldA[q];\n        assert a[p] <= a[q];\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod selectionSort(a: array<real>)\n  modifies a\n  ensures isSorted(a, 0, a.Length) \n  ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>\n// <vc-code>\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant isSorted(a, 0, i)\n    invariant forall p, q :: 0 <= p < i <= q < a.Length ==> a[p] <= a[q]\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if i < a.Length - 1 {\n      var minIndex := findMin(a, i, a.Length);\n      if minIndex != i {\n        var oldSeq := a[..];\n        var temp := a[i];\n        a[i] := a[minIndex];\n        a[minIndex] := temp;\n        var newSeq := a[..];\n        multisetSwapLemma(oldSeq, newSeq, i, minIndex);\n        swapPreservesSorted(a, i, minIndex, oldSeq);\n      } else {\n        assert forall k :: i <= k < a.Length ==> a[k] >= a[i];\n        sortedPreservation(a, 0, a.Length, i);\n      }\n    } else {\n      assert i == a.Length - 1;\n      assert forall k :: i <= k < a.Length ==> k == i;\n      sortedPreservation(a, 0, a.Length, i);\n    }\n    \n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_598_IsArmstrong.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_598_IsArmstrong.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsArmstrong(n: int) returns (result: bool)\n    requires 100 <= n < 1000\n    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsArmstrong(n: int) returns (result: bool)\n    requires 100 <= n < 1000\n    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))\n// </vc-spec>\n// <vc-code>\n{\n    var hundreds := n / 100;\n    var tens := (n / 10) % 10;\n    var ones := n % 10;\n    \n    var sum := hundreds * hundreds * hundreds + tens * tens * tens + ones * ones * ones;\n    \n    result := (n == sum);\n}\n// </vc-code>\n\n", "", "", ""], ["llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max.dfy", "root", true, "", "", false, "llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max.dfy", "// <vc-preamble>\nfunction isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod rolling_max(numbers: seq<int>) returns (result: seq<int>)\nrequires numbers != []\nensures |result| == |numbers|\nensures forall i :: 0 < i < |result| ==> isMax(result[i], numbers[0..(i+1)])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}\n\n// <vc-helpers>\nlemma isMaxPreservation(m: int, s: seq<int>, x: int)\nrequires isMax(m, s)\nrequires x <= m\nensures isMax(m, s + [x])\n{\n    assert m in s + [x];\n    assert forall i :: 0 <= i < |s + [x]| ==> (s + [x])[i] <= m;\n}\n\nlemma isMaxNewElement(x: int, s: seq<int>)\nrequires forall y :: y in s ==> y <= x\nensures isMax(x, s + [x])\n{\n    assert x in s + [x];\n    forall i | 0 <= i < |s|\n    ensures s[i] <= x\n    {\n        assert s[i] in s;\n    }\n    assert forall i {:trigger (s + [x])[i]} :: 0 <= i < |s| ==> (s + [x])[i] == s[i] <= x;\n    assert (s + [x])[|s|] == x;\n}\n\nlemma maxExists(s: seq<int>)\nrequires s != []\nensures exists m :: isMax(m, s)\n{\n    var m := s[0];\n    var i := 1;\n    while i < |s|\n    invariant 1 <= i <= |s|\n    invariant forall j :: 0 <= j < i ==> s[j] <= m\n    invariant m in s[0..i]\n    {\n        if s[i] > m {\n            m := s[i];\n        }\n        i := i + 1;\n    }\n    assert isMax(m, s);\n}\n\nlemma seqSliceEquivalence(numbers: seq<int>, i: int, j: int)\nrequires 0 < i <= |numbers|\nrequires 0 <= j < i\nensures numbers[0..i][j] == numbers[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod rolling_max(numbers: seq<int>) returns (result: seq<int>)\nrequires numbers != []\nensures |result| == |numbers|\nensures forall i :: 0 < i < |result| ==> isMax(result[i], numbers[0..(i+1)])\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    var i := 0;\n    \n    while i < |numbers|\n    invariant 0 <= i <= |numbers|\n    invariant |result| == i\n    invariant forall j :: 0 < j < i ==> isMax(result[j], numbers[0..(j+1)])\n    {\n        var currentMax := numbers[0];\n        var k := 1;\n        \n        while k <= i\n        invariant 1 <= k <= i + 1\n        invariant currentMax in numbers[0..(i+1)]\n        invariant forall j :: 0 <= j < k ==> numbers[j] <= currentMax\n        {\n            if numbers[k] > currentMax {\n                currentMax := numbers[k];\n            }\n            k := k + 1;\n        }\n        \n        assert currentMax in numbers[0..(i+1)];\n        assert forall j :: 0 <= j <= i ==> numbers[j] <= currentMax;\n        forall j {:trigger numbers[0..(i+1)][j]} | 0 <= j < |numbers[0..(i+1)]|\n        ensures numbers[0..(i+1)][j] <= currentMax\n        {\n            seqSliceEquivalence(numbers, i+1, j);\n            assert numbers[0..(i+1)][j] == numbers[j];\n            assert numbers[j] <= currentMax;\n        }\n        assert isMax(currentMax, numbers[0..(i+1)]);\n        \n        result := result + [currentMax];\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000.dfy", "root", true, "", "", false, "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000.dfy", "// <vc-preamble>\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search1000( a: array<int>, x: int ) returns ( k: int )\n    requires a.Length >= 1000;\n    requires forall p,q | 0 <= p < q < 1000 :: a[p] <= a[q];\n    ensures 0 <= k <= 1000;\n    ensures forall r | 0 <= r < k :: a[r] < x;\n    ensures forall r | k <= r < 1000 :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Search1000( a: array<int>, x: int ) returns ( k: int )\n    requires a.Length >= 1000;\n    requires forall p,q | 0 <= p < q < 1000 :: a[p] <= a[q];\n    ensures 0 <= k <= 1000;\n    ensures forall r | 0 <= r < k :: a[r] < x;\n    ensures forall r | k <= r < 1000 :: a[r] >= x;\n// </vc-spec>\n// <vc-code>\n{\n    var left := 0;\n    var right := 1000;\n    \n    while left < right\n        invariant 0 <= left <= right <= 1000\n        invariant forall r | 0 <= r < left :: a[r] < x\n        invariant forall r | right <= r < 1000 :: a[r] >= x\n        decreases right - left\n    {\n        var mid := (left + right) / 2;\n        if a[mid] < x {\n            left := mid + 1;\n        } else {\n            right := mid;\n        }\n    }\n    \n    k := left;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1.dfy", "// <vc-preamble>\nfunction fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod fibonacci1(n:nat) returns (f:nat)\nensures f==fib(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}\n\n// <vc-helpers>\nlemma FibCorrectness(a: nat, b: nat, i: nat, n: nat)\n  requires i <= n\n  requires a == fib(i)\n  requires b == fib(i + 1)\n  ensures fib(n) == FibHelper(a, b, i, n)\n  decreases n - i\n{\n  if i == n {\n    assert fib(n) == a;\n  } else {\n    FibCorrectness(b, a + b, i + 1, n);\n  }\n}\n\nfunction FibHelper(a: nat, b: nat, i: nat, n: nat): nat\n  requires i <= n\n  decreases n - i\n{\n  if i == n then a\n  else FibHelper(b, a + b, i + 1, n)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod fibonacci1(n:nat) returns (f:nat)\nensures f==fib(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    return 0;\n  } else if n == 1 {\n    return 1;\n  } else {\n    var a := 0;\n    var b := 1;\n    var i := 0;\n    \n    while i < n\n      invariant i <= n\n      invariant a == fib(i)\n      invariant b == fib(i + 1)\n      decreases n - i\n    {\n      var temp := a + b;\n      a := b;\n      b := temp;\n      i := i + 1;\n    }\n    \n    return a;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_lc-remove-element_removeElement.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_lc-remove-element_removeElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod removeElement(nums: array<int>, val: int) returns (i: int)\n    ensures forall k :: 0 < k < i < nums.Length ==> nums[k] != val\n    modifies nums\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_732_ReplaceWithColon.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_732_ReplaceWithColon.dfy", "// <vc-preamble>\npredicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n// </vc-spec>\n// <vc-code>\n{\n    v := \"\";\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |v| == i\n        invariant forall j :: 0 <= j < i ==> (IsSpaceCommaDot(s[j]) ==> v[j] == ':') && (!IsSpaceCommaDot(s[j]) ==> v[j] == s[j])\n    {\n        if IsSpaceCommaDot(s[i]) {\n            v := v + \":\";\n        } else {\n            v := v + [s[i]];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_775_IsOddAtIndexOdd.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_775_IsOddAtIndexOdd.dfy", "// <vc-preamble>\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsOddAtIndexOdd(a: array<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsOddAtIndexOdd(a: array<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))\n// </vc-spec>\n// <vc-code>\n{\n  result := true;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant result <==> forall j :: 0 <= j < i ==> (IsOdd(j) ==> IsOdd(a[j]))\n  {\n    if IsOdd(i) && !IsOdd(a[i]) {\n      result := false;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray.dfy", "root", true, "", "", false, "dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray.dfy", "// <vc-preamble>\nconst vowels: set<char> := {'a', 'e', 'i', 'o', 'u'}\n\nfunction FilterVowels(xs: seq<char>): seq<char>\n{\n    if |xs| == 0 then []\n    else if xs[|xs|-1] in vowels then FilterVowels(xs[..|xs|-1]) + [xs[|xs|-1]]\n    else FilterVowels(xs[..|xs|-1])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FilterVowelsArray(xs: array<char>) returns (ys: array<char>)\n    ensures fresh(ys)\n    ensures FilterVowels(xs[..]) == ys[..]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "//Given an array of characters, it filters all the vowels. [\u2018d\u2019,\u2019e\u2019,\u2019l\u2019,\u2019i\u2019,\u2019g\u2019,\u2019h\u2019,\u2019t\u2019]-> [\u2019e\u2019,\u2019i\u2019]\nconst vowels: set<char> := {'a', 'e', 'i', 'o', 'u'}\n\nfunction FilterVowels(xs: seq<char>): seq<char>\n{\n    if |xs| == 0 then []\n    else if xs[|xs|-1] in vowels then FilterVowels(xs[..|xs|-1]) + [xs[|xs|-1]]\n    else FilterVowels(xs[..|xs|-1])\n}\n\n// <vc-helpers>\nlemma FilterVowelsLength(xs: seq<char>)\n    ensures |FilterVowels(xs)| <= |xs|\n{\n    if |xs| == 0 {\n    } else if xs[|xs|-1] in vowels {\n        FilterVowelsLength(xs[..|xs|-1]);\n    } else {\n        FilterVowelsLength(xs[..|xs|-1]);\n    }\n}\n\nlemma FilterVowelsPreservesVowels(xs: seq<char>)\n    ensures forall i :: 0 <= i < |FilterVowels(xs)| ==> FilterVowels(xs)[i] in vowels\n{\n    if |xs| == 0 {\n    } else if xs[|xs|-1] in vowels {\n        FilterVowelsPreservesVowels(xs[..|xs|-1]);\n    } else {\n        FilterVowelsPreservesVowels(xs[..|xs|-1]);\n    }\n}\n\nlemma FilterVowelsIncrementalVowel(xs: seq<char>, i: int)\n    requires 0 <= i < |xs|\n    requires xs[i] in vowels\n    ensures FilterVowels(xs[..i+1]) == FilterVowels(xs[..i]) + [xs[i]]\n{\n    if i == 0 {\n        assert xs[..i+1] == [xs[0]];\n        assert xs[..i] == [];\n    } else {\n        var prefix := xs[..i];\n        var extended := xs[..i+1];\n        assert extended == prefix + [xs[i]];\n        assert extended[|extended|-1] == xs[i];\n        assert extended[|extended|-1] in vowels;\n        assert FilterVowels(extended) == FilterVowels(extended[..|extended|-1]) + [extended[|extended|-1]];\n        assert extended[..|extended|-1] == prefix;\n        if xs[i-1] in vowels {\n            FilterVowelsIncrementalVowel(xs, i-1);\n        } else {\n            FilterVowelsIncrementalNonVowel(xs, i-1);\n        }\n    }\n}\n\nlemma FilterVowelsIncrementalNonVowel(xs: seq<char>, i: int)\n    requires 0 <= i < |xs|\n    requires xs[i] !in vowels\n    ensures FilterVowels(xs[..i+1]) == FilterVowels(xs[..i])\n{\n    if i == 0 {\n        assert xs[..i+1] == [xs[0]];\n        assert xs[..i] == [];\n    } else {\n        var prefix := xs[..i];\n        var extended := xs[..i+1];\n        assert extended == prefix + [xs[i]];\n        assert extended[|extended|-1] == xs[i];\n        assert extended[|extended|-1] !in vowels;\n        assert FilterVowels(extended) == FilterVowels(extended[..|extended|-1]);\n        assert extended[..|extended|-1] == prefix;\n        if xs[i-1] in vowels {\n            FilterVowelsIncrementalVowel(xs, i-1);\n        } else {\n            FilterVowelsIncrementalNonVowel(xs, i-1);\n        }\n    }\n}\n\nlemma FilterVowelsIncrementalLength(xs: seq<char>, i: int)\n    requires 0 <= i < |xs|\n    ensures xs[i] in vowels ==> |FilterVowels(xs[..i+1])| == |FilterVowels(xs[..i])| + 1\n    ensures xs[i] !in vowels ==> |FilterVowels(xs[..i+1])| == |FilterVowels(xs[..i])|\n{\n    if xs[i] in vowels {\n        FilterVowelsIncrementalVowel(xs, i);\n    } else {\n        FilterVowelsIncrementalNonVowel(xs, i);\n    }\n}\n\nlemma FilterVowelsStrictlyIncreasing(xs: seq<char>, i: int)\n    requires 0 <= i < |xs|\n    requires xs[i] in vowels\n    ensures |FilterVowels(xs[..i])| < |FilterVowels(xs[..])|\n{\n    FilterVowelsIncrementalVowel(xs, i);\n    assert |FilterVowels(xs[..i+1])| == |FilterVowels(xs[..i])| + 1;\n    FilterVowelsLength(xs[i+1..]);\n    assert |FilterVowels(xs)| >= |FilterVowels(xs[..i+1])|;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod FilterVowelsArray(xs: array<char>) returns (ys: array<char>)\n    ensures fresh(ys)\n    ensures FilterVowels(xs[..]) == ys[..]\n// </vc-spec>\n// <vc-code>\n{\n    FilterVowelsLength(xs[..]);\n    var result := new char[|FilterVowels(xs[..])|];\n    var i := 0;\n    var j := 0;\n    \n    while i < xs.Length\n        invariant 0 <= i <= xs.Length\n        invariant 0 <= j <= result.Length\n        invariant FilterVowels(xs[..i]) == result[..j]\n        invariant j == |FilterVowels(xs[..i])|\n    {\n        if xs[i] in vowels {\n            FilterVowelsIncrementalLength(xs[..], i);\n            FilterVowelsIncrementalVowel(xs[..], i);\n            FilterVowelsStrictlyIncreasing(xs[..], i);\n            assert j < result.Length;\n            result[j] := xs[i];\n            j := j + 1;\n        } else {\n            FilterVowelsIncrementalNonVowel(xs[..], i);\n        }\n        i := i + 1;\n    }\n    \n    assert i == xs.Length;\n    assert xs[..i] == xs[..];\n    assert FilterVowels(xs[..]) == result[..j];\n    assert j == result.Length;\n    assert result[..j] == result[..];\n    \n    return result;\n}\n// </vc-code>\n\n", "", "", ""], ["veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV.dfy", "root", true, "", "", false, "veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV.dfy", "// <vc-preamble>\nfunction sum(X_val: array<int>, X_crd: array<nat>, v : array<int>, b : int, k : int) : (s : int)\n  reads X_val, X_crd, v\n  requires X_val.Length >= b >= 0\n  requires k <= X_val.Length\n  requires X_val.Length == X_crd.Length\n  requires forall i :: 0 <= i < X_crd.Length ==> 0 <= X_crd[i] < v.Length\n  decreases k - b\n  {\n    if k <= b then \n      0\n    else  sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b]]\n  }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SpMV(X_val: array<int>, X_crd: array<nat>, X_pos: array<nat>, v : array<int>) returns (y : array<int>)\n  requires X_crd.Length >= 1 \n  requires X_crd.Length == X_val.Length;\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_crd.Length ==> X_crd[i] < v.Length\n  requires forall i :: 0 <= i < X_pos.Length ==> X_pos[i] <= X_val.Length\n  requires X_pos.Length >= 1\n  ensures y.Length + 1 == X_pos.Length\n  ensures forall i :: 0 <= i < y.Length ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function sum(X_val: array<int>, X_crd: array<nat>, v : array<int>, b : int, k : int) : (s : int)\n  reads X_val, X_crd, v\n  requires X_val.Length >= b >= 0\n  requires k <= X_val.Length\n  requires X_val.Length == X_crd.Length\n  requires forall i :: 0 <= i < X_crd.Length ==> 0 <= X_crd[i] < v.Length\n  decreases k - b\n  {\n    if k <= b then \n      0\n    else  sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b]]\n  }\n\n// <vc-helpers>\nlemma sum_bound_lemma(X_val: array<int>, X_crd: array<nat>, v : array<int>, b : int, k : int)\n  requires X_val.Length >= b >= 0\n  requires k <= X_val.Length\n  requires X_val.Length == X_crd.Length\n  requires forall i :: 0 <= i < X_crd.Length ==> 0 <= X_crd[i] < v.Length\n  ensures b <= k || k <= b\n{\n}\n\nlemma sum_equal_lemma(X_val: array<int>, X_crd: array<nat>, v : array<int>, b : int, k : int)\n  requires X_val.Length >= b >= 0\n  requires k <= X_val.Length\n  requires X_val.Length == X_crd.Length\n  requires forall i :: 0 <= i < X_crd.Length ==> 0 <= X_crd[i] < v.Length\n  ensures sum(X_val, X_crd, v, b, k) == sum(X_val, X_crd, v, b, k)\n{\n}\n\nlemma pos_ordering_lemma(X_pos: array<nat>, i: int)\n  requires forall j, k :: 0 <= j < k < X_pos.Length ==> X_pos[j] <= X_pos[k]\n  requires 0 <= i < X_pos.Length - 1\n  ensures X_pos[i] <= X_pos[i + 1]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SpMV(X_val: array<int>, X_crd: array<nat>, X_pos: array<nat>, v : array<int>) returns (y : array<int>)\n  requires X_crd.Length >= 1 \n  requires X_crd.Length == X_val.Length;\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_crd.Length ==> X_crd[i] < v.Length\n  requires forall i :: 0 <= i < X_pos.Length ==> X_pos[i] <= X_val.Length\n  requires X_pos.Length >= 1\n  ensures y.Length + 1 == X_pos.Length\n  ensures forall i :: 0 <= i < y.Length ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])\n// </vc-spec>\n// <vc-code>\n{\n  y := new int[X_pos.Length - 1];\n  \n  var i := 0;\n  while i < y.Length\n    invariant 0 <= i <= y.Length\n    invariant forall j :: 0 <= j < i ==> y[j] == sum(X_val, X_crd, v, X_pos[j], X_pos[j + 1])\n  {\n    pos_ordering_lemma(X_pos, i);\n    y[i] := sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1]);\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n// 0 0 0 0 0 0 1 0\n// 0 0 0 0 0 0 0 0\n// 0 0 0 0 1 0 0 0\n// 0 0 0 0 0 0 0 0\n// 0 0 1 0 0 0 0 0\n// 0 0 0 0 0 0 0 0\n// 1 0 0 0 0 0 0 0\n// 0 0 0 0 0 0 0 0", "", "", ""], ["Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec.dfy", "root", true, "", "", false, "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec.dfy", "// <vc-preamble>\npredicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearchRec(v:array<int>, elem:int, c:int, f:int) returns (p:int)\n requires sorted(v[0..v.Length])\n requires 0<=c<=f+1<=v.Length\n requires forall k::0<=k<c ==> v[k]<=elem\n requires forall k::f<k<v.Length ==> v[k]>elem\n decreases f-c\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\n\n\n\n\n\n\n//Recursive binary search\n\n// <vc-helpers>\nlemma sortedSliceProperty(v: array<int>, i: int, j: int, k: int)\n  requires sorted(v[0..v.Length])\n  requires 0 <= i <= k < j <= v.Length\n  ensures v[i] <= v[k] <= v[j-1]\n{\n}\n\nlemma sortedTransitivity(v: array<int>, i: int, j: int)\n  requires sorted(v[0..v.Length])\n  requires 0 <= i < j < v.Length\n  ensures v[i] <= v[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod binarySearchRec(v:array<int>, elem:int, c:int, f:int) returns (p:int)\n requires sorted(v[0..v.Length])\n requires 0<=c<=f+1<=v.Length//0<=c<=v.Length && -1<=f<v.Length && c<=f+1\n requires forall k::0<=k<c ==> v[k]<=elem\n requires forall k::f<k<v.Length ==> v[k]>elem\n decreases f-c\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>\n// <vc-code>\n{\n  if c > f {\n    p := f;\n    return;\n  }\n  \n  var mid := (c + f) / 2;\n  \n  if v[mid] <= elem {\n    p := binarySearchRec(v, elem, mid + 1, f);\n  } else {\n    p := binarySearchRec(v, elem, c, mid - 1);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib.dfy", "root", true, "", "", false, "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib.dfy", "// <vc-preamble>\nfunction fib(n: nat): nat\n  decreases n;\n{\n  if n == 0 then 0 \n  else if n == 1 then 1 \n  else fib(n - 1) + fib(n - 2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == fib(n);\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/\n\n\n//      n = 0, 1, 2, 3, 4, 5, 6,  7,  8, ...\n// fib(n) = 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\nfunction fib(n: nat): nat\n  decreases n;\n{\n  if n == 0 then 0 \n  else if n == 1 then 1 \n  else fib(n - 1) + fib(n - 2)\n}\n\n// <vc-helpers>\nlemma FibIterativeCorrectness(n: nat, a: nat, b: nat, i: nat)\n  requires i <= n\n  requires a == fib(i)\n  requires b == fib(i + 1)\n  ensures var (final_a, final_b) := FibIterative(n - i, a, b); final_a == fib(n)\n  decreases n - i\n{\n  if i < n {\n    FibIterativeCorrectness(n, b, a + b, i + 1);\n  }\n}\n\nfunction FibIterative(steps: nat, a: nat, b: nat): (nat, nat)\n  decreases steps\n{\n  if steps == 0 then (a, b)\n  else FibIterative(steps - 1, b, a + b)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == fib(n);\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    return 0;\n  } else if n == 1 {\n    return 1;\n  } else {\n    var a := 0;\n    var b := 1;\n    var i := 1;\n    \n    while i < n\n      invariant 1 <= i <= n\n      invariant a == fib(i - 1)\n      invariant b == fib(i)\n      decreases n - i\n    {\n      var temp := a + b;\n      a := b;\n      b := temp;\n      i := i + 1;\n    }\n    \n    return b;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_261_ElementWiseDivision.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_261_ElementWiseDivision.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseDivision(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ElementWiseDivision(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>\n// <vc-code>\n{\n  result := [];\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant |result| == i\n    invariant forall j :: 0 <= j < i ==> result[j] == a[j] / b[j]\n  {\n    result := result + [a[i] / b[i]];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_max_array_maxArray.dfy", "root", true, "", "", false, "Clover_max_array_maxArray.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n// </vc-spec>\n// <vc-code>\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort.dfy", "root", true, "", "", false, "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n  requires n>=0;            \n  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n\n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\n\n// <vc-helpers>\nlemma SortedArrayProperty(A: array<int>, n: int)\n  requires n == A.Length\n  requires n >= 0\n  requires forall i,j:: 0<=i<=j<n ==> A[i]<=A[j]\n  ensures forall k:: 0 <= k < n-1 ==> A[k] <= A[k+1]\n{\n}\n\nlemma SingleElementSorted(A: array<int>)\n  requires A.Length <= 1\n  ensures forall i,j:: 0<=i<=j<A.Length ==> A[i]<=A[j]\n{\n}\n\nlemma BubbleProperty(A: array<int>, start: int, end: int)\n  requires 0 <= start < end < A.Length\n  requires forall k:: start <= k < end ==> A[k] <= A[end]\n  ensures A[start] <= A[end]\n{\n}\n\nlemma BubbleInvariantPreservation(A: array<int>, i: int, j: int, n: int)\n  requires 0 <= i < n - 1\n  requires 0 <= j < n - 1 - i\n  requires n == A.Length\n  requires forall x,y:: 0 <= x <= y < i ==> A[x] <= A[y]\n  requires forall x:: 0 <= x < i ==> forall y:: i <= y < n ==> A[x] <= A[y]\n  requires forall x:: i <= x < i + j && i + j < n ==> A[x] <= A[i + j]\n  requires i + j + 1 < n && A[i + j] <= A[i + j + 1]\n  ensures forall x:: i <= x < i + j + 1 && i + j + 1 < n ==> A[x] <= A[i + j + 1]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n// </vc-spec>\n// <vc-code>\n{\n  if n <= 1 {\n    return;\n  }\n  \n  // Simple bubble sort implementation\n  var i := 0;\n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant forall x,y:: 0 <= x <= y < i ==> A[x] <= A[y]\n    invariant forall x:: 0 <= x < i ==> forall y:: i <= y < n ==> A[x] <= A[y]\n  {\n    var j := 0;\n    while j < n - 1 - i\n      invariant 0 <= j <= n - 1 - i\n      invariant forall x,y:: 0 <= x <= y < i ==> A[x] <= A[y]\n      invariant forall x:: 0 <= x < i ==> forall y:: i <= y < n ==> A[x] <= A[y]\n      invariant forall x:: i <= x < i + j ==> A[x] <= A[n - 1 - i]\n      invariant forall x:: i <= x < i + j && x + 1 < n ==> A[x] <= A[x + 1]\n    {\n      if A[i + j] > A[i + j + 1] {\n        var temp := A[i + j];\n        A[i + j] := A[i + j + 1];\n        A[i + j + 1] := temp;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax.dfy", "root", true, "", "", false, "bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax.dfy", "// <vc-preamble>\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n  requires a.Length >= 1 \n  ensures 0 <= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// shenanigans going through the dafny tutorial\n\n\n\n\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n  requires a.Length >= 1 \n  ensures 0 <= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>\n// <vc-code>\n{\n  i := 0;\n  var j := 1;\n  while j < a.Length\n    invariant 0 <= i < a.Length\n    invariant 1 <= j <= a.Length\n    invariant forall k :: 0 <= k < j ==> a[k] <= a[i]\n  {\n    if a[j] > a[i] {\n      i := j;\n    }\n    j := j + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_632_MoveZeroesToEnd.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_632_MoveZeroesToEnd.dfy", "// <vc-preamble>\nmethod swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n{\n  assume{:axiom} false;\n}\n\nfunction count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MoveZeroesToEnd(arr: array<int>)\n    requires arr.Length >= 2\n    modifies arr\n\n    ensures arr.Length == old(arr.Length)\n\n    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0\n\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n\n    ensures forall n, m :: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> \n            exists k, l :: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "method swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n{\n  assume{:axiom} false;\n}\n\nfunction count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}\n\n// <vc-helpers>\nlemma MultisetPreservedAfterSwap(arr: array<int>, i: int, j: int)\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    ensures multiset(arr[..][i := arr[j]][j := arr[i]]) == multiset(arr[..])\n{\n    var original := arr[..];\n    var after_swap := original[i := arr[j]][j := arr[i]];\n    \n    if i == j {\n        assert after_swap == original;\n    } else {\n        assert multiset(after_swap) == multiset(original);\n    }\n}\n\nlemma ArraySlicePreservation(arr: array<int>, writeIndex: int, readIndex: int)\n    requires 0 <= writeIndex <= readIndex < arr.Length\n    requires forall k :: writeIndex <= k < readIndex ==> arr[k] != 0\n    ensures forall k :: 0 <= k < writeIndex ==> arr[k] != 0\n{\n}\n\nlemma ZeroClusterProperty(arr: array<int>)\n    requires forall i :: 0 <= i < arr.Length && arr[i] == 0 ==> \n             forall j :: i < j < arr.Length ==> arr[j] == 0\n    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0\n{\n}\n\nlemma NonZeroOrderPreservation(oldArr: seq<int>, newArr: seq<int>, nonZeroPositions: seq<int>)\n    requires |oldArr| == |newArr|\n    requires forall i :: 0 <= i < |nonZeroPositions| ==> \n             0 <= nonZeroPositions[i] < |newArr| && newArr[nonZeroPositions[i]] != 0\n    requires forall i :: 0 <= i < |nonZeroPositions| - 1 ==> nonZeroPositions[i] < nonZeroPositions[i+1]\n    ensures forall n, m :: 0 <= n < m < |oldArr| && oldArr[n] != 0 && oldArr[m] != 0 ==>\n            exists k, l :: 0 <= k < l < |newArr| && newArr[k] == oldArr[n] && newArr[l] == oldArr[m]\n{\n}\n\nlemma OrderPreservationHelper(arr: array<int>, originalArray: seq<int>, writeIndex: int, readIndex: int)\n    requires 0 <= writeIndex <= readIndex <= arr.Length\n    requires |originalArray| == arr.Length\n    requires forall n, m :: (0 <= n < m < readIndex && originalArray[n] != 0 && originalArray[m] != 0) ==>\n             (exists k, l :: 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m])\n    ensures forall n, m :: (0 <= n < m < arr.Length && originalArray[n] != 0 && originalArray[m] != 0) ==>\n            (exists k, l :: 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m])\n{\n}\n\nlemma OrderPreservationAfterLoop(arr: array<int>, originalArray: seq<int>, writeIndex: int)\n    requires writeIndex <= arr.Length\n    requires |originalArray| == arr.Length\n    requires forall k :: 0 <= k < writeIndex ==> arr[k] != 0\n    requires forall n, m :: (0 <= n < m < arr.Length && originalArray[n] != 0 && originalArray[m] != 0) ==>\n             (exists k, l :: 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m])\n    ensures forall n, m :: 0 <= n < m < arr.Length && originalArray[n] != 0 && originalArray[m] != 0 ==> \n            exists k, l :: 0 <= k < l < arr.Length && arr[k] == originalArray[n] && arr[l] == originalArray[m]\n{\n    forall n, m | 0 <= n < m < arr.Length && originalArray[n] != 0 && originalArray[m] != 0\n    ensures exists k, l :: 0 <= k < l < arr.Length && arr[k] == originalArray[n] && arr[l] == originalArray[m]\n    {\n        assert exists k, l :: 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m];\n        var k, l :| 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m];\n        assert 0 <= k < l < arr.Length && arr[k] == originalArray[n] && arr[l] == originalArray[m];\n    }\n}\n\nlemma ZeroClusterAfterSecondLoop(arr: array<int>, writeIndex: int)\n    requires writeIndex <= arr.Length\n    requires forall k :: 0 <= k < writeIndex ==> arr[k] != 0\n    requires forall k :: writeIndex <= k < arr.Length ==> arr[k] == 0\n    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0\n{\n    forall i, j | 0 <= i < j < arr.Length && arr[i] == 0\n    ensures arr[j] == 0\n    {\n        assert i >= writeIndex;\n        assert j >= writeIndex;\n        assert arr[j] == 0;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MoveZeroesToEnd(arr: array<int>)\n    requires arr.Length >= 2\n    modifies arr\n    // Same size\n    ensures arr.Length == old(arr.Length)\n    // Zeros to the right of the first zero\n    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0\n    // The final array is a permutation of the original one\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n    // Relative order of non-zero elements is preserved\n    ensures forall n, m /* on old array */:: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> \n            exists k, l /* on new array */:: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])\n    //ensures IsOrderPreserved(arr[..], old(arr[..]))\n    // Number of zeros is preserved\n// </vc-spec>\n// <vc-code>\n{\n    var writeIndex := 0;\n    var readIndex := 0;\n    \n    ghost var originalArray := arr[..];\n    \n    while readIndex < arr.Length\n        invariant 0 <= writeIndex <= readIndex <= arr.Length\n        invariant forall k :: 0 <= k < writeIndex ==> arr[k] != 0\n        invariant multiset(arr[..]) == multiset(originalArray)\n        invariant forall n, m :: (0 <= n < m < readIndex && originalArray[n] != 0 && originalArray[m] != 0) ==>\n                  (exists k, l :: 0 <= k < l < writeIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m])\n    {\n        if arr[readIndex] != 0 {\n            if writeIndex != readIndex {\n                swap(arr, writeIndex, readIndex);\n            }\n            writeIndex := writeIndex + 1;\n        }\n        readIndex := readIndex + 1;\n    }\n    \n    var finalWriteIndex := writeIndex;\n    \n    while writeIndex < arr.Length\n        invariant finalWriteIndex <= writeIndex <= arr.Length\n        invariant forall k :: 0 <= k < finalWriteIndex ==> arr[k] != 0\n        invariant forall k :: finalWriteIndex <= k < writeIndex ==> arr[k] == 0\n        invariant multiset(arr[..]) == multiset(originalArray)\n        invariant forall n, m :: (0 <= n < m < arr.Length && originalArray[n] != 0 && originalArray[m] != 0) ==>\n                  (exists k, l :: 0 <= k < l < finalWriteIndex && arr[k] == originalArray[n] && arr[l] == originalArray[m])\n    {\n        arr[writeIndex] := 0;\n        writeIndex := writeIndex + 1;\n    }\n    \n    OrderPreservationAfterLoop(arr, originalArray, finalWriteIndex);\n    ZeroClusterAfterSecondLoop(arr, finalWriteIndex);\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_insert_insert.dfy", "root", true, "", "", false, "Clover_insert_insert.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nmethod CopyBackwardsPreservesElements(line: array<char>, start: int, end: int, offset: int)\n  requires 0 <= start <= end <= line.Length\n  requires 0 <= start + offset <= end + offset <= line.Length\n  requires offset > 0\n  modifies line\n  ensures forall i :: start <= i < end ==> line[i + offset] == old(line[i])\n  ensures forall i :: 0 <= i < start ==> line[i] == old(line[i])\n  ensures forall i :: end + offset <= i < line.Length ==> line[i] == old(line[i])\n{\n  var j := end - 1;\n  while j >= start\n    invariant start - 1 <= j < end\n    invariant forall i :: j + 1 <= i < end ==> line[i + offset] == old(line[i])\n    invariant forall i :: 0 <= i < start ==> line[i] == old(line[i])\n    invariant forall i :: end + offset <= i < line.Length ==> line[i] == old(line[i])\n    invariant forall i :: start <= i <= j ==> line[i] == old(line[i])\n  {\n    line[j + offset] := line[j];\n    j := j - 1;\n  }\n}\n\nmethod CopyForwardPreservesElements(src: array<char>, dst: array<char>, srcStart: int, count: int, dstStart: int)\n  requires 0 <= srcStart <= srcStart + count <= src.Length\n  requires 0 <= dstStart <= dstStart + count <= dst.Length\n  modifies dst\n  ensures forall i {:trigger dst[dstStart + i]} :: 0 <= i < count ==> dst[dstStart + i] == src[srcStart + i]\n  ensures forall i :: 0 <= i < dstStart ==> dst[i] == old(dst[i])\n  ensures forall i :: dstStart + count <= i < dst.Length ==> dst[i] == old(dst[i])\n{\n  var j := 0;\n  while j < count\n    invariant 0 <= j <= count\n    invariant forall i {:trigger dst[dstStart + i]} :: 0 <= i < j ==> dst[dstStart + i] == src[srcStart + i]\n    invariant forall i :: 0 <= i < dstStart ==> dst[i] == old(dst[i])\n    invariant forall i :: dstStart + count <= i < dst.Length ==> dst[i] == old(dst[i])\n    invariant forall i :: dstStart + j <= i < dstStart + count ==> dst[i] == old(dst[i])\n  {\n    dst[dstStart + j] := src[srcStart + j];\n    j := j + 1;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n// </vc-spec>\n// <vc-code>\n{\n  var i := l - 1;\n  while i >= at\n    invariant at - 1 <= i < l\n    invariant forall j :: i + 1 <= j < l ==> line[j + p] == old(line[j])\n    invariant forall j :: 0 <= j <= i ==> line[j] == old(line[j])\n    invariant forall j :: l + p <= j < line.Length ==> line[j] == old(line[j])\n  {\n    line[i + p] := line[i];\n    i := i - 1;\n  }\n  \n  i := 0;\n  while i < p\n    invariant 0 <= i <= p\n    invariant forall j :: 0 <= j < i ==> line[at + j] == nl[j]\n    invariant forall j :: 0 <= j < at ==> line[j] == old(line[j])\n    invariant forall j :: at + p <= j < l + p ==> line[j] == old(line[j - p])\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Valid_Palindrome_valid_panlindrome_isPalindrome.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Valid_Palindrome_valid_panlindrome_isPalindrome.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod isPalindrome(s: array<char>) returns (result: bool)\n    requires 1<= s.Length <= 200000\n    ensures result <==> (forall i:: 0 <= i < s.Length / 2 ==> s[i] == s[s.Length - 1 - i])\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Clover_slope_search_SlopeSearch.dfy", "root", true, "", "", false, "Clover_slope_search_SlopeSearch.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SlopeSearch(a: array2<int>, key: int) returns (m:int, n:int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures 0<=m<a.Length0 && 0<=n<a.Length1\n  ensures a[m,n]==key\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma KeyExists(a: array2<int>, key: int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n{\n}\n\nlemma MonotonicityLemma(a: array2<int>, i: int, j: int)\n  requires 0<=i<a.Length0 && 0<=j<a.Length1\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  ensures forall i',j' :: 0<=i'<=i && j<=j'<a.Length1 ==> a[i',j]<=a[i,j']\n  ensures forall i',j' :: i<=i'<a.Length0 && 0<=j'<=j ==> a[i,j']<=a[i',j']\n{\n  forall i',j' | 0<=i'<=i && j<=j'<a.Length1\n    ensures a[i',j]<=a[i,j']\n  {\n    if i' == i {\n      assert a[i',j] <= a[i,j'];\n    } else {\n      assert i' < i;\n      assert a[i',j] <= a[i,j];\n      assert a[i,j] <= a[i,j'];\n      assert a[i',j] <= a[i,j'];\n    }\n  }\n  \n  forall i',j' | i<=i'<a.Length0 && 0<=j'<=j\n    ensures a[i,j']<=a[i',j']\n  {\n    if j' == j {\n      assert a[i,j'] <= a[i',j'];\n    } else {\n      assert j' < j;\n      assert a[i,j'] <= a[i,j];\n      assert a[i,j] <= a[i',j];\n      assert a[i,j'] <= a[i',j'];\n    }\n  }\n}\n\nlemma MonotonicityForInvariant(a: array2<int>, key: int, m: int, n: int, old_m: int, old_n: int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires 0 <= old_m < a.Length0 && 0 <= old_n < a.Length1\n  requires 0 <= m <= a.Length0 && -1 <= n < a.Length1\n  requires forall i,j :: 0<=i<old_m && 0<=j<a.Length1 ==> a[i,j] < key\n  requires forall i,j :: 0<=i<a.Length0 && old_n<j<a.Length1 ==> a[i,j] > key\n  requires exists i,j :: old_m<=i<a.Length0 && 0<=j<=old_n && a[i,j]==key\n  requires (m == old_m + 1 && n == old_n && a[old_m, old_n] < key) || \n           (m == old_m && n == old_n - 1 && a[old_m, old_n] > key)\n  ensures forall i,j :: 0<=i<m && 0<=j<a.Length1 ==> a[i,j] < key\n  ensures forall i,j :: 0<=i<a.Length0 && n<j<a.Length1 ==> a[i,j] > key\n  ensures exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key\n{\n  if m == old_m + 1 && n == old_n && a[old_m, old_n] < key {\n    forall i,j | 0<=i<m && 0<=j<a.Length1 \n      ensures a[i,j] < key\n    {\n      if i < old_m {\n        assert a[i,j] < key;\n      } else {\n        assert i == old_m;\n        assert a[old_m, old_n] < key;\n        if j <= old_n {\n          assert a[i,j] <= a[old_m, old_n] < key;\n        } else {\n          assert j > old_n;\n          assert a[old_m, old_n] <= a[old_m, j];\n          assert a[old_m, old_n] < key;\n          if a[old_m, j] >= key {\n            assert a[old_m, old_n] < key <= a[old_m, j];\n            assert false;\n          }\n          assert a[old_m, j] < key;\n        }\n      }\n    }\n    \n    var key_i, key_j :| old_m<=key_i<a.Length0 && 0<=key_j<=old_n && a[key_i,key_j]==key;\n    if key_i == old_m {\n      assert false; // contradiction: a[old_m,key_j] == key but a[old_m,old_n] < key and key_j <= old_n\n    } else {\n      assert m <= key_i < a.Length0 && 0 <= key_j <= n;\n      assert exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key;\n    }\n  } else if m == old_m && n == old_n - 1 && a[old_m, old_n] > key {\n    forall i,j | 0<=i<a.Length0 && n<j<a.Length1\n      ensures a[i,j] > key\n    {\n      if j > old_n {\n        assert a[i,j] > key;\n      } else {\n        assert j == old_n;\n        assert a[old_m, old_n] > key;\n        if i >= old_m {\n          assert a[old_m, old_n] <= a[i,j];\n          assert a[i,j] >= a[old_m, old_n] > key;\n        } else {\n          assert i < old_m;\n          assert a[i, old_n] <= a[old_m, old_n];\n          assert a[old_m, old_n] > key;\n          if a[i, old_n] <= key {\n            assert a[i, old_n] <= key < a[old_m, old_n];\n            assert false;\n          }\n          assert a[i, old_n] > key;\n        }\n      }\n    }\n    \n    var key_i, key_j :| old_m<=key_i<a.Length0 && 0<=key_j<=old_n && a[key_i,key_j]==key;\n    if key_j == old_n {\n      assert false; // contradiction: a[key_i,old_n] == key but a[old_m,old_n] > key and key_i >= old_m\n    } else {\n      assert m <= key_i < a.Length0 && 0 <= key_j <= n;\n      assert exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SlopeSearch(a: array2<int>, key: int) returns (m:int, n:int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures 0<=m<a.Length0 && 0<=n<a.Length1\n  ensures a[m,n]==key\n// </vc-spec>\n// <vc-code>\n{\n  m := 0;\n  n := a.Length1 - 1;\n  \n  while m < a.Length0 && n >= 0 && a[m,n] != key\n    invariant 0 <= m <= a.Length0\n    invariant -1 <= n < a.Length1\n    invariant forall i,j :: 0<=i<m && 0<=j<a.Length1 ==> a[i,j] < key\n    invariant forall i,j :: 0<=i<a.Length0 && n<j<a.Length1 ==> a[i,j] > key\n    invariant exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key\n    decreases a.Length0 - m + n + 1\n  {\n    var old_m := m;\n    var old_n := n;\n    \n    if a[m,n] < key {\n      m := m + 1;\n      MonotonicityForInvariant(a, key, m, n, old_m, old_n);\n    } else {\n      n := n - 1;\n      MonotonicityForInvariant(a, key, m, n, old_m, old_n);\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR.dfy", "root", true, "", "", false, "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR.dfy", "// <vc-preamble>\nfunction R(n: nat): nat {\n    if n == 0 then 0 else if R(n-1) > n then R(n-1) - n else R(n-1) + n\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod calcR(n: nat) returns (r: nat)\n    ensures r == R(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function R(n: nat): nat {\n    if n == 0 then 0 else if R(n-1) > n then R(n-1) - n else R(n-1) + n\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod calcR(n: nat) returns (r: nat)\n    ensures r == R(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    r := 0;\n  } else {\n    var i := 1;\n    r := 0;\n    while i <= n\n      invariant 0 <= i <= n + 1\n      invariant r == R(i - 1)\n    {\n      if r > i {\n        r := r - i;\n      } else {\n        r := r + i;\n      }\n      i := i + 1;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_238_CountNonEmptySubstrings.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_238_CountNonEmptySubstrings.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountNonEmptySubstrings(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == (|s| * (|s| + 1)) / 2\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nlemma SubstringCountFormula(n: nat)\n    ensures n * (n + 1) / 2 == if n == 0 then 0 else n + (n - 1) * n / 2\n{\n    if n == 0 {\n        assert n * (n + 1) / 2 == 0;\n    } else {\n        calc {\n            n * (n + 1) / 2;\n            ==\n            (n * n + n) / 2;\n            == { assert n * n + n == n + n * n; }\n            (n + n * n) / 2;\n        }\n    }\n}\n\nlemma CountInvariant(s: string, i: nat, currentCount: int)\n    requires i <= |s|\n    requires currentCount == i * (i + 1) / 2\n    ensures currentCount + (|s| - i) == (|s| - i) + i * (i + 1) / 2\n{\n}\n\nlemma LoopInvariantMaintained(i: nat)\n    ensures (i * (i + 1) / 2) + (i + 1) == (i + 1) * (i + 2) / 2\n{\n    calc {\n        (i * (i + 1) / 2) + (i + 1);\n        ==\n        (i * (i + 1) + 2 * (i + 1)) / 2;\n        ==\n        ((i + 2) * (i + 1)) / 2;\n        ==\n        (i + 1) * (i + 2) / 2;\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CountNonEmptySubstrings(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == (|s| * (|s| + 1)) / 2 // Formula for the number of non-empty substrings of a string\n// </vc-spec>\n// <vc-code>\n{\n    count := 0;\n    var i := 0;\n    \n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant count == i * (i + 1) / 2\n    {\n        count := count + (i + 1);\n        i := i + 1;\n        \n        LoopInvariantMaintained(i - 1);\n        assert count == i * (i + 1) / 2;\n    }\n    \n    assert i == |s|;\n    assert count == |s| * (|s| + 1) / 2;\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_Partition.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_Partition.dfy", "// <vc-preamble>\npredicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures lo <= p < hi\n    ensures forall i :: lo <= i < p ==> a[i] < a[p]\n    ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    ensures SwapFrame(a, lo, hi)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["dafny-synthesis_task_id_760_HasOnlyOneDistinctElement.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_760_HasOnlyOneDistinctElement.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod HasOnlyOneDistinctElement(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] == a[j]\n    ensures !result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && a[i] != a[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod HasOnlyOneDistinctElement(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] == a[j]\n    ensures !result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && a[i] != a[j]\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length <= 1 {\n        return true;\n    }\n    \n    var i := 1;\n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant forall k :: 0 <= k < i ==> a[k] == a[0]\n    {\n        if a[i] != a[0] {\n            return false;\n        }\n        i := i + 1;\n    }\n    \n    return true;\n}\n// </vc-code>\n\n", "", "", ""], ["Clover_triple3_Triple.dfy", "root", true, "", "", false, "Clover_triple3_Triple.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>\n// <vc-code>\n{\n  r := 3 * x;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_113_IsInteger.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_113_IsInteger.dfy", "// <vc-preamble>\npredicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n// </vc-spec>\n// <vc-code>\n{\n  if |s| == 0 {\n    result := false;\n    return;\n  }\n  \n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall j :: 0 <= j < i ==> IsDigit(s[j])\n  {\n    if !IsDigit(s[i]) {\n      result := false;\n      return;\n    }\n    i := i + 1;\n  }\n  \n  result := true;\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch.dfy", "root", true, "", "", false, "Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch.dfy", "// <vc-preamble>\npredicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\n\n// <vc-helpers>\nlemma SortedSlice(a: array<int>, low: int, high: int)\n    requires sorted(a)\n    requires 0 <= low <= high <= a.Length\n    ensures forall j, k :: low <= j < k < high ==> a[j] <= a[k]\n{\n}\n\nlemma SortedImpliesOrder(a: array<int>, i: int, j: int)\n    requires sorted(a)\n    requires 0 <= i < j < a.Length\n    ensures a[i] <= a[j]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n// </vc-spec>\n// <vc-code>\n{\n    if a.Length == 0 {\n        return -1;\n    }\n    \n    var low := 0;\n    var high := a.Length;\n    \n    while low < high\n        invariant 0 <= low <= high <= a.Length\n        invariant forall k :: 0 <= k < low ==> a[k] < value\n        invariant forall k :: high <= k < a.Length ==> a[k] > value\n    {\n        var mid := low + (high - low) / 2;\n        \n        if a[mid] < value {\n            low := mid + 1;\n        } else if a[mid] > value {\n            high := mid;\n        } else {\n            return mid;\n        }\n    }\n    \n    return -1;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_161_RemoveElements.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_161_RemoveElements.dfy", "// <vc-preamble>\npredicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n\n    ensures forall x :: x in result ==> InArray(a, x) && !InArray(b, x)\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\n\n// <vc-helpers>\nlemma InArrayMembership(a: array<int>, x: int)\n    ensures InArray(a, x) <==> exists i :: 0 <= i < a.Length && a[i] == x\n{\n}\n\nlemma NotInArrayMembership(a: array<int>, x: int)\n    ensures !InArray(a, x) <==> forall i :: 0 <= i < a.Length ==> a[i] != x\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod RemoveElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in a and not in b\n    ensures forall x :: x in result ==> InArray(a, x) && !InArray(b, x)\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>\n// <vc-code>\n{\n    result := [];\n    \n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall x :: x in result ==> InArray(a, x) && !InArray(b, x)\n        invariant forall j, k :: 0 <= j < k < |result| ==> result[j] != result[k]\n    {\n        var shouldAdd := true;\n        \n        // Check if a[i] is in b\n        var j := 0;\n        while j < b.Length && shouldAdd\n            invariant 0 <= j <= b.Length\n            invariant shouldAdd ==> forall k :: 0 <= k < j ==> b[k] != a[i]\n        {\n            if b[j] == a[i] {\n                shouldAdd := false;\n            }\n            j := j + 1;\n        }\n        \n        // Check if a[i] is already in result\n        if shouldAdd {\n            var k := 0;\n            while k < |result| && shouldAdd\n                invariant 0 <= k <= |result|\n                invariant shouldAdd ==> forall m :: 0 <= m < k ==> result[m] != a[i]\n            {\n                if result[k] == a[i] {\n                    shouldAdd := false;\n                }\n                k := k + 1;\n            }\n        }\n        \n        if shouldAdd {\n            result := result + [a[i]];\n        }\n        \n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid.dfy", "root", true, "", "", false, "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Euclid (m : int, n : int) returns (gcd : int)\n    requires m > 1 && n > 1 && m >= n\n    ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n// <vc-helpers>\npredicate Divides(a: int, b: int)\n{\n  a > 0 && b % a == 0\n}\n\nghost predicate IsGCD(g: int, m: int, n: int)\n{\n  g > 0 && Divides(g, m) && Divides(g, n) &&\n  forall d :: d > 0 && Divides(d, m) && Divides(d, n) ==> d <= g\n}\n\nlemma GCDPreservation(a: int, b: int, m: int, n: int)\n  requires a > 0 && b >= 0 && m > 0 && n > 0\n  ensures IsGCD(if b == 0 then a else EuclidGCD(b, a % b), m, n) <==> IsGCD(EuclidGCD(a, b), m, n)\n{\n  // This is an axiom - proof omitted\n}\n\nfunction EuclidGCD(a: int, b: int): int\n  requires a > 0 && b >= 0\n  decreases b\n{\n  if b == 0 then a else EuclidGCD(b, a % b)\n}\n\nlemma EuclidGCDCorrect(m: int, n: int)\n  requires m > 0 && n > 0\n  ensures var g := EuclidGCD(m, n); g > 0 && m % g == 0 && n % g == 0\n{\n  var g := EuclidGCD(m, n);\n  if n == 0 {\n    assert g == m;\n  } else {\n    EuclidGCDCorrect(n, m % n);\n    assert g == EuclidGCD(n, m % n);\n  }\n}\n\nlemma EuclidGCDBounds(m: int, n: int)\n  requires m > 0 && n > 0\n  ensures var g := EuclidGCD(m, n); g <= m && g <= n\n{\n  var g := EuclidGCD(m, n);\n  if n == 0 {\n    assert g == m;\n  } else {\n    EuclidGCDBounds(n, m % n);\n    assert g == EuclidGCD(n, m % n);\n    assert g <= n;\n    assert g <= m % n || g <= n;\n    if g <= m % n {\n      assert m % n < n;\n      assert g <= m % n < n <= m;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Euclid (m : int, n : int) returns (gcd : int)\n    requires m > 1 && n > 1 && m >= n  // TODO\n    ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0 // TODO\n// </vc-spec>\n// <vc-code>\n{\n  var a := m;\n  var b := n;\n  \n  while b != 0\n    invariant a > 0 && b >= 0\n    invariant EuclidGCD(a, b) == EuclidGCD(m, n)\n    decreases b\n  {\n    var temp := a % b;\n    a := b;\n    b := temp;\n  }\n  \n  gcd := a;\n  \n  EuclidGCDCorrect(m, n);\n  EuclidGCDBounds(m, n);\n}\n// </vc-code>\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "", "", ""], ["dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum.dfy", "root", true, "", "", false, "dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file shows how to specify and implement a function to compute the\n// largest element of a list. The function is fully specified by two\n// preconditions, as proved by the MaximumIsUnique lemma below.\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n// </vc-spec>\n// <vc-code>\n{\n  max := values[0];\n  var i := 1;\n  while i < |values|\n    invariant 1 <= i <= |values|\n    invariant max in values\n    invariant forall j | 0 <= j < i :: values[j] <= max\n  {\n    if values[i] > max {\n      max := values[i];\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_126_SumOfCommonDivisors.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_126_SumOfCommonDivisors.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfCommonDivisors(a: int, b: int) returns (sum: int)\n    requires a > 0 && b > 0\n    ensures sum >= 0\n    ensures forall d :: 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\nfunction CommonDivisors(a: int, b: int): set<int>\n    requires a > 0 && b > 0\n{\n    set d | 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0\n}\n\nfunction SumSet(s: set<int>): int\n{\n    if s == {} then 0\n    else \n        var x := FindElement(s);\n        x + SumSet(s - {x})\n}\n\nfunction FindElement(s: set<int>): int\n    requires s != {}\n{\n    var min := MinElement(s);\n    min\n}\n\nfunction MinElement(s: set<int>): int\n    requires s != {}\n    ensures MinElement(s) in s\n{\n    if |s| == 1 then\n        var x :| x in s; x\n    else\n        var x :| x in s;\n        var rest := s - {x};\n        if rest == {} then x\n        else \n            var min_rest := MinElement(rest);\n            if x <= min_rest then x else min_rest\n}\n\nlemma SumSetNonNegative(s: set<int>)\n    requires forall x :: x in s ==> x >= 0\n    ensures SumSet(s) >= 0\n{\n    if s == {} {\n    } else {\n        var x := FindElement(s);\n        SumSetNonNegative(s - {x});\n    }\n}\n\nlemma SumSetContainsElement(s: set<int>, x: int)\n    requires x in s\n    requires forall y :: y in s ==> y >= 0\n    ensures SumSet(s) >= x\n{\n    if s == {} {\n    } else {\n        var y := FindElement(s);\n        if x == y {\n            SumSetNonNegative(s - {y});\n        } else {\n            SumSetContainsElement(s - {y}, x);\n        }\n    }\n}\n\nlemma CommonDivisorsProperties(a: int, b: int)\n    requires a > 0 && b > 0\n    ensures forall d :: d in CommonDivisors(a, b) ==> d >= 1\n    ensures 1 in CommonDivisors(a, b)\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod SumOfCommonDivisors(a: int, b: int) returns (sum: int)\n    requires a > 0 && b > 0\n    ensures sum >= 0\n    ensures forall d :: 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d\n// </vc-spec>\n// <vc-code>\n{\n    var divisors := CommonDivisors(a, b);\n    sum := SumSet(divisors);\n    \n    CommonDivisorsProperties(a, b);\n    SumSetNonNegative(divisors);\n    \n    forall d | 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0\n        ensures sum >= d\n    {\n        assert d in divisors;\n        SumSetContainsElement(divisors, d);\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_106_AppendArrayToSeq.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_106_AppendArrayToSeq.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n// </vc-spec>\n// <vc-code>\n{\n    r := s + a[..];\n}\n// </vc-code>\n\n", "", "", ""], ["Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_isAnagram.dfy", "root", false, "", "", false, "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_isAnagram.dfy", "// <vc-preamble>\nmethod toMultiset(s: string) returns (mset: multiset<char>)\n    ensures multiset(s) == mset\n{\n  assume{:axiom} false;\n}\n\nmethod msetEqual(s: multiset<char>, t: multiset<char>) returns (equal: bool)\n    ensures s == t <==> equal\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod isAnagram(s: string, t: string) returns (equal: bool)\n    ensures (multiset(s) == multiset(t)) == equal\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop.dfy", "root", true, "", "", false, "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n\n//This is a method that replace the loop body\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.\n\n// <vc-helpers>\nlemma MergeLoopHelper(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat, val: int)\n    requires i <= |c| && j <= |d| && i + j < |b|\n    requires InvSubSet(b, c, d, i, j)\n    requires (i < |c| && val == c[i]) || (j < |d| && val == d[j])\n    ensures multiset(b[..i+j+1]) == multiset(b[..i+j]) + multiset([val])\n{\n    assert b[..i+j+1] == b[..i+j] + [b[i+j]];\n}\n\nlemma SortedExtension(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat, val: int)\n    requires i <= |c| && j <= |d| && i + j < |b|\n    requires InvSorted(b, c, d, i, j)\n    requires Sorted(c) && Sorted(d)\n    requires (i < |c| && val == c[i] && (j >= |d| || c[i] <= d[j])) ||\n             (j < |d| && val == d[j] && (i >= |c| || d[j] <= c[i]))\n    ensures val >= (if i + j > 0 then b[i + j - 1] else val)\n{\n    if i + j > 0 {\n        if i < |c| && val == c[i] {\n            if i > 0 && j == 0 {\n                assert Sorted(c) && 0 <= i-1 < i;\n                assert i < |c|;\n                assert c[i-1] <= c[i];\n            } else if j > 0 && i == 0 {\n                assert Sorted(d) && 0 <= j-1 < j;\n                assert j < |d|;\n                assert d[j-1] <= d[j];\n            } else if i > 0 && j > 0 {\n                assert Sorted(c) && 0 <= i-1 < i;\n                assert i < |c|;\n                assert c[i-1] <= c[i];\n                if j < |d| {\n                    assert Sorted(d) && 0 <= j-1 < j;\n                    assert d[j-1] <= d[j];\n                }\n            }\n        } else if j < |d| && val == d[j] {\n            if j > 0 && i == 0 {\n                assert Sorted(d) && 0 <= j-1 < j;\n                assert j < |d|;\n                assert d[j-1] <= d[j];\n            } else if i > 0 && j == 0 {\n                assert Sorted(c) && 0 <= i-1 < i;\n                assert i < |c|;\n                assert c[i-1] <= c[i];\n            } else if i > 0 && j > 0 {\n                assert Sorted(d) && 0 <= j-1 < j;\n                assert j < |d|;\n                assert d[j-1] <= d[j];\n                if i < |c| {\n                    assert Sorted(c) && 0 <= i-1 < i;\n                    assert c[i-1] <= c[i];\n                }\n            }\n        }\n    }\n}\n\nlemma MultisetHelper(b_old: seq<int>, b_new: seq<int>, c: seq<int>, d: seq<int>, i_old: nat, j_old: nat, i_new: nat, j_new: nat, val: int)\n    requires i_old <= |c| && j_old <= |d| && i_old + j_old < |b_old|\n    requires i_new <= |c| && j_new <= |d| && i_new + j_new <= |b_new|\n    requires |b_old| == |b_new|\n    requires b_new == b_old[i_old + j_old := val]\n    requires ((i_new == i_old + 1 && j_new == j_old && i_old < |c| && val == c[i_old]) ||\n              (i_new == i_old && j_new == j_old + 1 && j_old < |d| && val == d[j_old]))\n    requires multiset(b_old[..i_old+j_old]) == multiset(c[..i_old]) + multiset(d[..j_old])\n    ensures multiset(b_new[..i_new+j_new]) == multiset(c[..i_new]) + multiset(d[..j_new])\n{\n    if i_new == i_old + 1 && j_new == j_old {\n        assert b_new[..i_new+j_new] == b_old[..i_old+j_old] + [val];\n        assert c[..i_new] == c[..i_old] + [c[i_old]];\n        assert multiset(c[..i_new]) == multiset(c[..i_old]) + multiset([c[i_old]]);\n        assert val == c[i_old];\n    } else {\n        assert b_new[..i_new+j_new] == b_old[..i_old+j_old] + [val];\n        assert d[..j_new] == d[..j_old] + [d[j_old]];\n        assert multiset(d[..j_new]) == multiset(d[..j_old]) + multiset([d[j_old]]);\n        assert val == d[j_old];\n    }\n}\n\nlemma MultisetPostcondition(b_old: seq<int>, b_new: seq<int>, i: nat, j: nat, val: int)\n    requires i + j < |b_old|\n    requires |b_old| == |b_new|\n    requires b_new == b_old[i + j := val]\n    ensures multiset(b_new[..i+j+1]) == multiset(b_old[..i+j]) + multiset([val])\n    ensures b_new[i+j] == val\n{\n    assert b_new[..i+j+1] == b_old[..i+j] + [val];\n}\n\nlemma SortedMaintenanceLemma(b_old: seq<int>, b_new: seq<int>, c: seq<int>, d: seq<int>, i_old: nat, j_old: nat, i_new: nat, j_new: nat, val: int)\n    requires i_old <= |c| && j_old <= |d| && i_old + j_old < |b_old|\n    requires i_new <= |c| && j_new <= |d| && i_new + j_new <= |b_new|\n    requires |b_old| == |b_new|\n    requires b_new == b_old[i_old + j_old := val]\n    requires ((i_new == i_old + 1 && j_new == j_old && i_old < |c| && val == c[i_old]) ||\n              (i_new == i_old && j_new == j_old + 1 && j_old < |d| && val == d[j_old]))\n    requires InvSorted(b_old, c, d, i_old, j_old)\n    requires Sorted(c) && Sorted(d)\n    requires (i_old < |c| && val == c[i_old] && (j_old >= |d| || c[i_old] <= d[j_old])) ||\n             (j_old < |d| && val == d[j_old] && (i_old >= |c| || d[j_old] <= c[i_old]))\n    ensures InvSorted(b_new, c, d, i_new, j_new)\n{\n    assert val >= (if i_old + j_old > 0 then b_old[i_old + j_old - 1] else val);\n    assert Sorted(b_new[..i_new+j_new]);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n        //decreases ensures\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n// </vc-spec>\n// <vc-code>\n{\n    i := i0;\n    j := j0;\n    \n    ghost var old_b := b[..];\n    var val: int;\n    \n    if i >= c.Length {\n        val := d[j];\n        b[i + j] := val;\n        ghost var new_b := b[..];\n        MultisetPostcondition(old_b, new_b, i, j, val);\n        MultisetHelper(old_b, new_b, c[..], d[..], i, j, i, j + 1, val);\n        SortedMaintenanceLemma(old_b, new_b, c[..], d[..], i, j, i, j + 1, val);\n        j := j + 1;\n    } else if j >= d.Length {\n        val := c[i];\n        b[i + j] := val;\n        ghost var new_b := b[..];\n        MultisetPostcondition(old_b, new_b, i, j, val);\n        MultisetHelper(old_b, new_b, c[..], d[..], i, j, i + 1, j, val);\n        SortedMaintenanceLemma(old_b, new_b, c[..], d[..], i, j, i + 1, j, val);\n        i := i + 1;\n    } else if c[i] <= d[j] {\n        val := c[i];\n        b[i + j] := val;\n        ghost var new_b := b[..];\n        SortedExtension(old_b, c[..], d[..], i, j, val);\n        MultisetPostcondition(old_b, new_b, i, j, val);\n        MultisetHelper(old_b, new_b, c[..], d[..], i, j, i + 1, j, val);\n        SortedMaintenanceLemma(old_b, new_b, c[..], d[..], i, j, i + 1, j, val);\n        i := i + 1;\n    } else {\n        val := d[j];\n        b[i + j] := val;\n        ghost var new_b := b[..];\n        SortedExtension(old_b, c[..], d[..], i, j, val);\n        MultisetPostcondition(old_b, new_b, i, j, val);\n        MultisetHelper(old_b, new_b, c[..], d[..], i, j, i, j + 1, val);\n        SortedMaintenanceLemma(old_b, new_b, c[..], d[..], i, j, i, j + 1, val);\n        j := j + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""], ["cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1.dfy", "root", true, "", "", false, "cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1.dfy", "// <vc-preamble>\nfunction power(a: int, n: int): int\n  requires 0 <= n;\n  decreases n;\n  {\n    if (n == 0) then 1 else a * power(a, n - 1)\n  }\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod A8Q1(y0: int, x: int) returns (z: int)\nrequires y0 >= 0\nensures z==power(x,y0)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// A8Q1 \u2014 Steph Renee McIntyre\n// Following the solutions from Carmen Bruni\n\n// There is no definition for power, so this function will be used for validating that our imperative program is correct. This is just for Dafny.\nfunction power(a: int, n: int): int //function for a to the power of n\n  requires 0 <= n;\n  decreases n;\n  {\n    if (n == 0) then 1 else a * power(a, n - 1)\n  }\n\n/* Proof of implieds can be seen on LEARN.\n    Note: If you are unconvinced, putting asserts for each condition will demonstrate the correctness of the statements. \n*/\n\n// <vc-helpers>\nlemma PowerAdditive(a: int, m: int, n: int)\n  requires m >= 0 && n >= 0\n  ensures power(a, m + n) == power(a, m) * power(a, n)\n  decreases m\n{\n  if m == 0 {\n    assert power(a, 0 + n) == power(a, n);\n    assert power(a, 0) * power(a, n) == 1 * power(a, n) == power(a, n);\n  } else {\n    PowerAdditive(a, m - 1, n);\n    assert power(a, m + n) == power(a, (m - 1) + 1 + n) == power(a, (m - 1) + (1 + n));\n    assert power(a, (m - 1) + (1 + n)) == power(a, m - 1) * power(a, 1 + n);\n    assert power(a, 1 + n) == a * power(a, n);\n    assert power(a, m - 1) * power(a, 1 + n) == power(a, m - 1) * a * power(a, n);\n    assert power(a, m) == a * power(a, m - 1);\n    assert power(a, m) * power(a, n) == a * power(a, m - 1) * power(a, n);\n  }\n}\n\nlemma PowerStep(a: int, n: int)\n  requires n >= 0\n  ensures a * power(a, n) == power(a, n + 1)\n{\n  assert power(a, n + 1) == a * power(a, n);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod A8Q1(y0: int, x: int) returns (z: int)\nrequires y0 >= 0\nensures z==power(x,y0)\n// </vc-spec>\n// <vc-code>\n{\n  var y := y0;\n  z := 1;\n  \n  while y > 0\n    invariant y >= 0\n    invariant z * power(x, y) == power(x, y0)\n    decreases y\n  {\n    PowerStep(x, y - 1);\n    z := z * x;\n    y := y - 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_FooCount.dfy", "root", false, "", "", false, "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_\u526f\u672c_FooCount.dfy", "// <vc-preamble>\nghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod FooCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch.dfy", "root", true, "", "", false, "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch.dfy", "// <vc-preamble>\npredicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}\n\n// <vc-helpers>\nlemma ComparerTransitivity(q: seq<int>, key: int, comparer: (int, int) -> bool)\n    requires Sorted(q)\n    requires (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n             (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n    ensures forall i, j :: 0 <= i <= j < |q| && comparer(q[i], key) ==> comparer(q[j], key)\n{\n    forall i, j | 0 <= i <= j < |q| && comparer(q[i], key)\n        ensures comparer(q[j], key)\n    {\n        assert q[i] <= q[j];\n        if forall n1, n2 :: comparer(n1, n2) == (n1 > n2) {\n            if q[i] > key {\n                assert q[j] >= q[i] > key;\n                assert q[j] > key;\n            }\n        } else {\n            assert forall n1, n2 :: comparer(n1, n2) == (n1 >= n2);\n            if q[i] >= key {\n                assert q[j] >= q[i] >= key;\n                assert q[j] >= key;\n            }\n        }\n    }\n}\n\nlemma ComparerNegationTransitivity(q: seq<int>, key: int, comparer: (int, int) -> bool)\n    requires Sorted(q)\n    requires (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n             (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n    ensures forall i, j :: 0 <= i <= j < |q| && !comparer(q[j], key) ==> !comparer(q[i], key)\n{\n    forall i, j | 0 <= i <= j < |q| && !comparer(q[j], key)\n        ensures !comparer(q[i], key)\n    {\n        assert q[i] <= q[j];\n        if forall n1, n2 :: comparer(n1, n2) == (n1 > n2) {\n            if q[j] <= key {\n                assert q[i] <= q[j] <= key;\n                assert q[i] <= key;\n                assert !(q[i] > key);\n            }\n        } else {\n            assert forall n1, n2 :: comparer(n1, n2) == (n1 >= n2);\n            if q[j] < key {\n                assert q[i] <= q[j] < key;\n                assert q[i] < key;\n                assert !(q[i] >= key);\n            }\n        }\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n    // comparer is '>' or '>='\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n// </vc-spec>\n// <vc-code>\n{\n    var low := lowerBound;\n    var high := upperBound;\n    \n    while low < high\n        invariant lowerBound <= low <= high <= upperBound\n        invariant RangeSatisfiesComparerNegation(q, key, 0, low, comparer)\n        invariant RangeSatisfiesComparer(q, key, high, |q|, comparer)\n        decreases high - low\n    {\n        var mid := (low + high) / 2;\n        assert low <= mid < high;\n        \n        if comparer(q[mid], key) {\n            ComparerTransitivity(q, key, comparer);\n            assert forall i :: mid <= i < |q| ==> comparer(q[i], key);\n            high := mid;\n        } else {\n            ComparerNegationTransitivity(q, key, comparer);\n            assert forall i :: 0 <= i <= mid ==> !comparer(q[i], key);\n            low := mid + 1;\n        }\n    }\n    \n    index := low;\n}\n// </vc-code>\n\n", "", "", ""], ["Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength.dfy", "root", true, "", "", false, "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength.dfy", "// <vc-preamble>\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n{\n  assume{:axiom} false;\n}\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\nensures len <= |str1| && len <= |str2|\nensures len >= 0\nensures maxCommonSubstringPredicate(str1, str2, len)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n{\n  assume{:axiom} false;\n}\n\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}\n\n// <vc-helpers>\nlemma maxCommonSubstringLemma(str1: string, str2: string, len: nat)\n  requires len <= |str1| && len <= |str2|\n  ensures len == |str1| ==> maxCommonSubstringPredicate(str1, str2, len)\n  ensures len == |str2| ==> maxCommonSubstringPredicate(str1, str2, len)\n{\n  if len == |str1| {\n    forall k | len < k <= |str1|\n      ensures !haveCommonKSubstringPredicate(k, str1, str2)\n    {\n      assert k > |str1|;\n    }\n  }\n  if len == |str2| {\n    forall k | len < k <= |str1|\n      ensures !haveCommonKSubstringPredicate(k, str1, str2)\n    {\n      if k <= |str1| {\n        assert k > |str2|;\n        assert !haveCommonKSubstringPredicate(k, str1, str2);\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\nensures len <= |str1| && len <= |str2|\nensures len >= 0\nensures maxCommonSubstringPredicate(str1, str2, len)\n// </vc-spec>\n// <vc-code>\n{\n  len := if |str1| <= |str2| then |str1| else |str2|;\n  maxCommonSubstringLemma(str1, str2, len);\n}\n// </vc-code>\n\n", "", "", ""], ["Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower.dfy", "root", true, "", "", false, "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower.dfy", "// <vc-preamble>\nfunction Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    p := 1;\n  } else {\n    var temp := ComputePower(n - 1);\n    p := 2 * temp;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap.dfy", "root", true, "", "", false, "SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod StringSwap(s: string, i:nat, j:nat) returns (t: string)\nrequires i >= 0 && j >= 0 && |s| >= 0;\nrequires |s| > 0 ==> i < |s| && j < |s|;\nensures multiset(s[..]) == multiset(t[..]);\nensures |s| == |t|;\nensures |s| > 0 ==> forall k:nat :: k != i && k != j && k < |s| ==> t[k] == s[k]\nensures |s| > 0 ==> t[i] == s[j] && t[j] == s[i];\nensures |s| == 0 ==> t == s;\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// method verifies\n\n// <vc-helpers>\nlemma MultisetSwapPreservation(s: string, i: nat, j: nat, t: string)\nrequires i < |s| && j < |s|\nrequires |s| == |t|\nrequires forall k: nat :: k < |s| && k != i && k != j ==> t[k] == s[k]\nrequires t[i] == s[j] && t[j] == s[i]\nensures multiset(s[..]) == multiset(t[..])\n{\n    if |s| <= 1 {\n        return;\n    }\n    \n    var ms := multiset(s[..]);\n    var mt := multiset(t[..]);\n    \n    assert s[..] == s;\n    assert t[..] == t;\n    \n    if i == j {\n        assert t == s;\n        return;\n    }\n    \n    // When characters are the same\n    if s[i] == s[j] {\n        // All characters at positions other than i,j remain the same\n        forall c | c !in {s[i]} \n        ensures ms[c] == mt[c]\n        {\n            var s_count := |set k | 0 <= k < |s| && s[k] == c|;\n            var t_count := |set k | 0 <= k < |t| && t[k] == c|;\n            assert s_count == t_count;\n        }\n        // Character at positions i and j stays the same count\n        var same_char := s[i];\n        var s_same_count := |set k | 0 <= k < |s| && s[k] == same_char|;\n        var t_same_count := |set k | 0 <= k < |t| && t[k] == same_char|;\n        assert s_same_count == t_same_count;\n        assert mt[same_char] == ms[same_char];\n    } else {\n        // When characters are different\n        // Characters other than s[i] and s[j] have same counts\n        forall c | c !in {s[i], s[j]}\n        ensures ms[c] == mt[c]\n        {\n            var s_positions := set k | 0 <= k < |s| && s[k] == c;\n            var t_positions := set k | 0 <= k < |t| && t[k] == c;\n            assert s_positions == t_positions;\n        }\n        \n        // s[i] appears where s[j] was, plus all other original positions\n        var s_i_char := s[i];\n        var s_j_char := s[j];\n        \n        var s_i_positions := set k | 0 <= k < |s| && s[k] == s_i_char;\n        var t_i_positions := set k | 0 <= k < |t| && t[k] == s_i_char;\n        var s_j_positions := set k | 0 <= k < |s| && s[k] == s_j_char;\n        var t_j_positions := set k | 0 <= k < |t| && t[k] == s_j_char;\n        \n        // After swap: s[i] appears at j and all its original positions except i\n        // s[j] appears at i and all its original positions except j\n        assert t_i_positions == (s_i_positions - {i}) + {j};\n        assert t_j_positions == (s_j_positions - {j}) + {i};\n        assert |t_i_positions| == |s_i_positions|;\n        assert |t_j_positions| == |s_j_positions|;\n        assert mt[s_i_char] == ms[s_i_char];\n        assert mt[s_j_char] == ms[s_j_char];\n    }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod StringSwap(s: string, i:nat, j:nat) returns (t: string)\nrequires i >= 0 && j >= 0 && |s| >= 0;\nrequires |s| > 0 ==> i < |s| && j < |s|;\nensures multiset(s[..]) == multiset(t[..]);\nensures |s| == |t|;\nensures |s| > 0 ==> forall k:nat :: k != i && k != j && k < |s| ==> t[k] == s[k]\nensures |s| > 0 ==> t[i] == s[j] && t[j] == s[i];\nensures |s| == 0 ==> t == s;\n// </vc-spec>\n// <vc-code>\n{\n    if |s| == 0 {\n        return s;\n    }\n    \n    var result := s;\n    var temp := s[i];\n    result := result[i := s[j]];\n    result := result[j := temp];\n    \n    assert |s| == |result|;\n    assert forall k: nat :: k < |s| && k != i && k != j ==> result[k] == s[k];\n    assert result[i] == s[j] && result[j] == s[i];\n    \n    MultisetSwapPreservation(s, i, j, result);\n    \n    return result;\n}\n// </vc-code>\n\n// string == seq<Char>\n//give se2011 ass2 ex1.dfy", "", "", ""], ["Clover_multi_return_MultipleReturns.dfy", "root", true, "", "", false, "Clover_multi_return_MultipleReturns.dfy", "// <vc-preamble>\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n// </vc-spec>\n// <vc-code>\n{\n  more := x + y;\n  less := x - y;\n}\n// </vc-code>\n\n", "", "", ""], ["dafny-synthesis_task_id_790_IsEvenAtIndexEven.dfy", "root", true, "", "", false, "dafny-synthesis_task_id_790_IsEvenAtIndexEven.dfy", "// <vc-preamble>\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsEvenAtIndexEven(lst: seq<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < |lst| ==> (IsEven(i) ==> IsEven(lst[i]))\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod IsEvenAtIndexEven(lst: seq<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < |lst| ==> (IsEven(i) ==> IsEven(lst[i]))\n// </vc-spec>\n// <vc-code>\n{\n  result := true;\n  var i := 0;\n  while i < |lst|\n    invariant 0 <= i <= |lst|\n    invariant result <==> forall j :: 0 <= j < i ==> (IsEven(j) ==> IsEven(lst[j]))\n  {\n    if IsEven(i) && !IsEven(lst[i]) {\n      result := false;\n      return;\n    }\n    i := i + 1;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["Software-Verification_tmp_tmpv4ueky2d_Contains_Duplicate_contains_duplicate_contains_duplicate.dfy", "root", false, "", "", false, "Software-Verification_tmp_tmpv4ueky2d_Contains_Duplicate_contains_duplicate_contains_duplicate.dfy", "// <vc-preamble>\npredicate distinct(nums: seq<int>) {\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] != nums[j]\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod contains_duplicate(nums: seq<int>) returns (result: bool)\n    requires 1 <= |nums| <= 100000\n    requires forall i :: 0 <= i < |nums| ==> -1000000000 <= nums[i] <= 1000000000\n    ensures result <==> distinct(nums)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["Dafny_tmp_tmpv_d3qi10_2_min_minArray.dfy", "root", true, "", "", false, "Dafny_tmp_tmpv_d3qi10_2_min_minArray.dfy", "// <vc-preamble>\nfunction min(a: int, b: int): int\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a || min(a, b) == b\n{\n    if a < b then a else b\n}\n\nghost function minFunction(a: int, b: int): int\n    ensures minFunction(a, b) <= a && minFunction(a, b) <= b\n    ensures minFunction(a, b) == a || minFunction(a, b) == b\n{\n    if a < b then a else b\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod minArray(a: array<int>) returns (m: int)\n    requires a!= null  && a.Length > 0 \n    ensures forall k | 0 <= k < a.Length :: m <= a[k]\n    ensures exists k | 0 <= k < a.Length :: m == a[k]\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "function min(a: int, b: int): int\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a || min(a, b) == b\n{\n    if a < b then a else b\n}\n\n\nghost function minFunction(a: int, b: int): int\n    ensures minFunction(a, b) <= a && minFunction(a, b) <= b\n    ensures minFunction(a, b) == a || minFunction(a, b) == b\n{\n    if a < b then a else b\n}\n\n\n// Return a minimum of a.\n\n// <vc-helpers>\nlemma MinArrayLoop(a: array<int>, i: int, m: int)\n    requires a.Length > 0\n    requires 0 <= i <= a.Length\n    requires m == a[0]\n    requires forall k | 0 <= k < i :: m <= a[k]\n    ensures forall k | 0 <= k < i :: m <= a[k]\n{\n}\n\nlemma MinArrayLoopInvariant(a: array<int>, i: int, m: int)\n    requires a.Length > 0\n    requires 0 <= i <= a.Length\n    requires forall k | 0 <= k < i :: m <= a[k]\n    requires exists k | 0 <= k < i :: m == a[k]\n    ensures forall k | 0 <= k < i :: m <= a[k]\n    ensures exists k | 0 <= k < i :: m == a[k]\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod minArray(a: array<int>) returns (m: int)\n    requires a!= null  && a.Length > 0 \n    ensures forall k | 0 <= k < a.Length :: m <= a[k]\n    ensures exists k | 0 <= k < a.Length :: m == a[k]\n// </vc-spec>\n// <vc-code>\n{\n    m := a[0];\n    var i := 1;\n    \n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant forall k | 0 <= k < i :: m <= a[k]\n        invariant exists k | 0 <= k < i :: m == a[k]\n    {\n        if a[i] < m {\n            m := a[i];\n        }\n        i := i + 1;\n    }\n}\n// </vc-code>\n\n", "", "", ""]]}