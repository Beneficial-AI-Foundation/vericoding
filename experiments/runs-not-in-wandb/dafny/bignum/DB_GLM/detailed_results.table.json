{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["bignum_ModExp_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_NormalizeBitString.dfy", "root", true, "", "", false, "bignum_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction {:inline} AllZeros(s: string): bool\n  requires ValidBitString(s)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nlemma RemoveLeadingZero(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  requires s[0] == '0'\n  ensures Str2Int(s) == Str2Int(s[1..])\n  decreases |s|\n{\n  if |s| == 1 {\n    assert s == \"0\";\n    assert s[1..] == \"\";\n    assert Str2Int(s) == 0;\n    assert Str2Int(s[1..]) == 0;\n  } else {\n    calc {\n      Str2Int(s);\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1]=='1' then 1 else 0);\n      { \n        RemoveLeadingZero(s[0..|s|-1]);\n        assert Str2Int(s[0..|s|-1]) == Str2Int(s[0..|s|-1][1..]);\n      }\n      2 * Str2Int(s[1..|s|-1]) + (if s[|s|-1]=='1' then 1 else 0);\n      {\n        assert s[1..] == s[1..|s|-1] + [s[|s|-1]];\n      }\n      Str2Int(s[1..]);\n    }\n  }\n}\n\nlemma StripLeadingZerosPreservesValue(s: string, n: nat)\n  requires ValidBitString(s)\n  requires n <= |s|\n  requires AllZeros(s[0..n])\n  ensures Str2Int(s) == Str2Int(s[n..])\n  decreases n\n{\n  if n == 0 {\n  } else {\n    RemoveLeadingZero(s);\n    StripLeadingZerosPreservesValue(s[1..], n-1);\n  }\n}\n\nlemma AllZerosImpliesZero(s: string)\n  requires ValidBitString(s)\n  requires AllZeros(s)\n  ensures Str2Int(s) == 0\n  decreases |s|\n{\n  if |s| == 0 {\n  } else {\n    calc {\n      Str2Int(s);\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1]=='1' then 1 else 0);\n      { \n        AllZerosImpliesZero(s[0..|s|-1]);\n        assert Str2Int(s[0..|s|-1]) == 0;\n      }\n      2 * 0 + 0;\n      0;\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  if !ValidBitString(s) {\n    return \"0\";\n  }\n  var n := 0;\n  while n < |s| && s[n] == '0'\n    invariant 0 <= n <= |s|\n    invariant forall i | 0 <= i < n :: s[i] == '0'\n    decreases |s| - n\n  {\n    n := n + 1;\n  }\n  if n == |s| {\n    assert AllZeros(s);\n    AllZerosImpliesZero(s);\n    return \"0\";\n  } else {\n    assert n < |s|;\n    assert AllZeros(s[0..n]);\n    var t := s[n..];\n    StripLeadingZerosPreservesValue(s, n);\n    return t;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Mul_Add.dfy", "root", false, "", "", false, "bignum_Mul_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul.dfy", "root", true, "", "", false, "bignum_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction {:opaque} Add(s1: string, s2: string): string\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(Add(s1, s2))\n  ensures Str2Int(Add(s1, s2)) == Str2Int(s1) + Str2Int(s2)\n{\n  if |s1| == 0 then s2\n  else if |s2| == 0 then s1\n  else\n    var last1 := s1[|s1|-1];\n    var last2 := s2[|s2|-1];\n    var s_first := if |s1| == 1 then \"\" else s1[0..|s1|-1];\n    var s_second := if |s2| == 1 then \"\" else s2[0..|s2|-1];\n    var sum_rest := Add(s_first, s_second);\n    var carry := (last1 == '1' && last2 == '1') || (last1 == '1' && sum_rest != \"\" && sum_rest[|sum_rest|-1] == '1') || (last2 == '1' && sum_rest != \"\" && sum_rest[|sum_rest|-1] == '1');\n    var least := if last1 == '1' then (if last2 == '1' then '0' else '1') else (if last2 == '1' then '1' else '0');\n    if carry then Add(sum_rest, \"1\") + least.toString() else sum_rest + least.toString()\n}\n\nlemma {:fuel FixAddLemma,0} lemma_Add_zero(s: string)\n  requires ValidBitString(s)\n  ensures Add(s, \"0\") == s && Add(\"0\", s) == s\n{\n  if |s| == 0 {\n    calc {\n      Add(s, \"0\");\n      \"0\";\n      s;\n    }\n  } else {\n    calc {\n      Add(\"0\", s);\n      { assert s[0..|s|-1] == \"\";\n        assert Add(\"\", s[0..|s|-1]) == s[0..|s|-1];\n      }\n      Add(s[0..|s|-1], \"\") + (if '0' == '1' then (if s[|s|-1] == '1' then '0' else '1') else s[|s|-1]).toString();\n      s[0..|s|-1] + s[|s|-1].toString();\n      s;\n    }\n    calc {\n      Add(s, \"0\");\n      { assert s[0..|s|-1] == \"\";\n        assert Add(s[0..|s|-1], \"\") == s[0..|s|-1];\n      }\n      Add(s[0..|s|-1], \"\") + (if s[|s|-1] == '1' then (if '0' == '1' then '0' else '1') else '0').toString();\n      s[0..|s|-1] + (if s[|s|-1] == '1' then '1' else '0').toString();\n      s[0..|s|-1] + s[|s|-1].toString();\n      s;\n    }\n  }\n}\n\nlemma {:fuel FixAddLemma,0} lemma_Add_associative(s1: string, s2: string, s3: string)\n  requires ValidBitString(s1) && ValidBitString(s2) && ValidBitString(s3)\n  ensures Add(Add(s1, s2), s3) == Add(s1, Add(s2, s3))\n{\n  if |s1| == 0 {\n    calc {\n      Add(Add(s1, s2), s3);\n      Add(s2, s3);\n      Add(s1, Add(s2, s3));\n    }\n  } else if |s2| == 0 {\n    calc {\n      Add(Add(s1, s2), s3);\n      Add(s1, s3);\n      Add(s1, Add(s2, s3));\n    }\n  } else if |s3| == 0 {\n    calc {\n      Add(Add(s1, s2), s3);\n      Add(s1, s2);\n      Add(s1, Add(s2, s3));\n    }\n  } else {\n    var last1 := s1[|s1|-1];\n    var last2 := s2[|s2|-1];\n    var last3 := s3[|s3|-1];\n    var s_first1 := if |s1| == 1 then \"\" else s1[0..|s1|-1];\n    var s_first2 := if |s2| == 1 then \"\" else s2[0..|s2|-1];\n    var s_first3 := if |s3| == 1 then \"\" else s3[0..|s3|-1];\n    \n    lemma_Add_associative(s_first1, s_first2, s_first3);\n    lemma_Add_associative(s_first1, s_first2, \"1\");\n    lemma_Add_associative(Add(s_first1, s_first2), s_first3, \"1\");\n    lemma_Add_associative(s_first1, Add(s_first2, s_first3), \"1\");\n    \n    var sum12 := Add(s_first1, s_first2);\n    var sum23 := Add(s_first2, s_first3);\n    var sum_rest123 := Add(Add(s_first1, s_first2), s_first3);\n    var sum_rest132 := Add(s_first1, Add(s_first2, s_first3));\n    \n    calc {\n      Add(Add(s1, s2), s3);\n      Add(sum_rest123 + (if last1 == '1' then (if last2 == '1' then '0' else '1') else (if last2 == '1' then '1' else '0')).toString(), s3);\n      { assert Add(sum_rest123, s_first3) == sum_rest123; }\n      Add(sum_rest123 + (if last1 == '1' then (if last2 == '1' then '0' else '1') else (if last2 == '1' then '1' else '0')).toString(), s3);\n      s1;\n    }\n  }\n}\n\nfunction {:fuel ShiftLeft,0} ShiftLeft(s: string, n: nat): string\n  requires ValidBitString(s)\n  ensures ValidBitString(ShiftLeft(s, n))\n  ensures Str2Int(ShiftLeft(s, n)) == Str2Int(s) * (2^n)\n{\n  if n == 0 then s else ShiftLeft(s + \"0\", n - 1)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  if |s1| == 0 || |s2| == 0 then\n    \"0\"\n  else if s2 == \"1\" then\n    s1\n  else\n    var half := |s2| / 2;\n    var s2_low := s2[0..half];\n    var s2_high := s2[half..];\n    var low_prod := Mul(s1, s2_low);\n    var high_prod := Mul(s1, s2_high);\n    var high_shifted := ShiftLeft(high_prod, |s2| - half);\n    Add(high_shifted, low_prod)\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2.dfy", "root", true, "", "", false, "bignum_ModExpPow2.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n{\n  var s := if n == 0 then \"\" else Int2Str(n/2) + (if n%2==0 then \"0\" else \"1\");\n  if s == \"\" then \"0\" else s\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  var x := Str2Int(sx);\n  var y := Str2Int(sy);\n  var z := Str2Int(sz);\n\n  if y == 0 \n  {\n    calc {\n      Exp_int(x, y) % z;\n      Exp_int(x, 0) % z;\n      1 % z;\n    }\n    assert Exp_int(x, y) % z == 1 % z;\n    return Int2Str(1 % z);\n  }\n  else \n  {\n    var res_int := x % z;\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant res_int == Exp_int(x, Exp_int(2, i)) % z\n    {\n      calc {\n        Exp_int(x, Exp_int(2, i+1)) % z;\n        Exp_int(x, 2 * Exp_int(2, i)) % z;\n        Exp_int(Exp_int(x, Exp_int(2, i)), 2) % z;\n        (Exp_int(x, Exp_int(2, i)) * Exp_int(x, Exp_int(2, i))) % z;\n        ( (Exp_int(x, Exp_int(2, i)) % z) * (Exp_int(x, Exp_int(2, i)) % z) ) % z;\n        (res_int * res_int) % z;\n      }\n      res_int := (res_int * res_int) % z;\n      i := i + 1;\n    }\n    calc {\n      Exp_int(x, y) % z;\n      Exp_int(x, Exp_int(2, n)) % z;\n    }\n    assert Exp_int(x, y) % z == Exp_int(x, Exp_int(2, n)) % z;\n    assert Exp_int(x, y) % z == res_int;\n    return Int2Str(res_int);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare.dfy", "root", true, "", "", false, "bignum_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function Power(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1 else base * Power(base, exp-1)\n}\n\nlemma {:autocontracts} Str2Int_Eq(s: string, i: int)\n  requires 0 <= i <= |s|\n  requires ValidBitString(s)\n  ensures Str2Int(s) == 2 * Str2Int(s[0..i]) + Str2Int(s[i..])\n{\n  if i == 0 {\n    calc {\n      Str2Int(s);\n      == { assert s[0..] == s; }\n      Str2Int(s[0..]);\n    }\n  } else if i == |s| {\n    calc {\n      Str2Int(s);\n      == { assert s[i..] == \"\"; }\n      2 * Str2Int(s[0..i]) + Str2Int(\"\");\n      == 2 * Str2Int(s[0..i]) + 0;\n      == 2 * Str2Int(s[0..]);\n    }\n  } else {\n    assert s == s[0..i] + s[i..] by {\n      reveal ValidBitString();\n      assert |s[0..i] + s[i..]| == |s|;\n      assert forall k | 0 <= k < |s| :: (s[0..i] + s[i..])[k] == s[k];\n    }\n    calc {\n      Str2Int(s);\n      == { assert s == s[0..i] + s[i..]; }\n      Str2Int(s[0..i] + s[i..]);\n      == { reveal Str2Int(); }\n      2 * Str2Int(s[0..i] + s[i..][0..|s[i..]|-1]) + (if s[i..][|s[i..]|-1] == '1' then 1 else 0);\n      == 2 * Str2Int(s[0..i] + s[i..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n      == { assert s[0..i] + s[i..|s|-1] == s[0..|s|-1]; }\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n      == { reveal Str2Int(); }\n      Str2Int(s);\n    }\n    calc {\n      Str2Int(s);\n      == { Str2Int_Eq(s[0..i] + s[i..], |s[0..i]|); }\n      2 * Str2Int(s[0..i]) + Str2Int(s[i..]);\n    }\n  }\n}\n\nlemma Str2Int_PrefixEq(s: string, i: int)\n  requires 0 <= i <= |s|\n  requires ValidBitString(s)\n  ensures Str2Int(s[0..i]) == Str2Int(s) / Power(2, |s| - i)\n{\n  if i == |s| {\n    calc {\n      Str2Int(s[0..i]);\n      == Str2Int(s);\n      == Str2Int(s) / 1;\n      == Str2Int(s) / Power(2, |s| - i);\n    }\n  } else {\n    calc {\n      Str2Int(s);\n      == { Str2Int_Eq(s, i); }\n      2 * Str2Int(s[0..i]) + Str2Int(s[i..]);\n      == { assert Str2Int(s[i..]) < Power(2, |s| - i); }\n      2 * Str2Int(s[0..i]) + Str2Int(s[i..]);\n    }\n    calc {\n      Str2Int(s) / Power(2, |s| - i);\n      == (2 * Str2Int(s[0..i]) + Str2Int(s[i..])) / Power(2, |s| - i);\n      == Str2Int(s[0..i]) / Power(2, |s| - i - 1) + Str2Int(s[i..]) / Power(2, |s| - i);\n      == Str2Int(s[0..i]) / Power(2, |s| - i - 1);\n      == Str2Int(s[0..i]);\n    }\n  }\n}\n\nlemma Str2Int_Ge_Power(s: string, n: nat)\n  requires ValidBitString(s)\n  requires |s| == n\n  ensures Str2Int(s) < Power(2, n)\n{\n  if n == 0 {\n  } else {\n    calc {\n      Power(2, n);\n      == 2 * Power(2, n-1);\n      > Str2Int(s);\n      == { Str2Int_Eq(s, n-1); }\n      2 * Str2Int(s[0..n-1]) + (if s[n-1] == '1' then 1 else 0);\n    }\n    Str2Int_Ge_Power(s[0..n-1], n-1);\n  }\n}\n\nlemma Str2Int_ForLongerString(s: string, t: string)\n  requires ValidBitString(s)\n  requires ValidBitString(t)\n  requires |s| > |t|\n  ensures Str2Int(s) > Str2Int(t)\n{\n  calc {\n    Str2Int(s);\n    >= Power(2, |s|-1);\n    > Power(2, |s|-1) - 1;\n    >= Power(2, |t|);\n    > Str2Int(t);\n  }\n  Str2Int_Ge_Power(s, |s|);\n  Str2Int_Ge_Power(t, |t|);\n}\n\nlemma Str2Int_CompareLemma(s1: string, s2: string)\n  requires ValidBitString(s1)\n  requires ValidBitString(s2)\n  ensures var cmp := Compare(s1, s2);\n    (cmp == -1 ==> Str2Int(s1) < Str2Int(s2)) &&\n    (cmp == 0 ==> Str2Int(s1) == Str2Int(s2)) &&\n    (cmp == 1 ==> Str2Int(s1) > Str2Int(s2))\n{\n  var cmp := Compare(s1, s2);\n  if |s1| == 0 && |s2| == 0 {\n    assert cmp == 0;\n  } else if |s1| == 0 {\n    assert cmp == -1;\n  } else if |s2| == 0 {\n    assert cmp == 1;\n  } else if |s1| > |s2| {\n    var longer_prefix := s1[0..|s2|];\n    var prefix_compare := Compare(longer_prefix, s2);\n    if prefix_compare != 0 {\n      assert cmp == prefix_compare;\n    } else {\n      cmp;\n      assert |s1| > |s2|;\n      Str2Int_ForLongerString(s1, s2);\n      assert cmp == 1;\n    }\n  } else if |s2| > |s1| {\n    var longer_prefix := s2[0..|s1|];\n    var prefix_compare := Compare(s1, longer_prefix);\n    if prefix_compare != 0 {\n      assert cmp == prefix_compare;\n    } else {\n      cmp;\n      assert |s2| > |s1|;\n      Str2Int_ForLongerString(s2, s1);\n      assert cmp == -1;\n    }\n  } else {\n    var last_pos1 := |s1| - 1;\n    var last_pos2 := |s2| - 1;\n    var last_char1 := s1[last_pos1];\n    var last_char2 := s2[last_pos2];\n    var last_bit1 := if last_char1 == '1' then 1 else 0;\n    var last_bit2 := if last_char2 == '1' then 1 else 0;\n\n    if last_bit1 < last_bit2 {\n      assert cmp == -1;\n    } else if last_bit1 > last_bit2 {\n      assert cmp == 1;\n    } else {\n      var prefix1 := s1[0..last_pos1];\n      var prefix2 := s2[0..last_pos2];\n      var prefix_compare := Compare(prefix1, prefix2);\n      \n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + last_bit1 by {\n        Str2Int_Eq(s1, last_pos1);\n      }\n      assert Str2Int(s2) == 2 * Str2Int(prefix2) + last_bit2 by {\n        Str2Int_Eq(s2, last_pos2);\n      }\n\n      assert cmp == prefix_compare;\n    }\n  }\n}\n\nlemma Str2Int_Monotonic(s: string, i: int)\n  requires 0 <= i < |s|\n  requires ValidBitString(s)\n  ensures Str2Int(s[0..i]) <= Str2Int(s[0..i+1])\n{\n  var last_char := s[i];\n  var last_bit := if last_char == '1' then 1 else 0;\n  calc {\n    Str2Int(s[0..i+1]);\n    == { Str2Int_Eq(s[0..i+1], i); }\n    2 * Str2Int(s[0..i]) + Str2Int(s[i..i+1]);\n    == 2 * Str2Int(s[0..i]) + last_bit;\n    >= Str2Int(s[0..i]);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  if |s1| == 0 && |s2| == 0 {\n    return 0;\n  } else if |s1| == 0 {\n    return -1;\n  } else if |s2| == 0 {\n    return 1;\n  } else if |s1| > |s2| {\n    var longer_prefix := s1[0..|s2|];\n    var prefix_compare := Compare(longer_prefix, s2);\n    if prefix_compare != 0 {\n      return prefix_compare;\n    } else {\n      return 1;\n    }\n  } else if |s2| > |s1| {\n    var longer_prefix := s2[0..|s1|];\n    var prefix_compare := Compare(s1, longer_prefix);\n    if prefix_compare != 0 {\n      return prefix_compare;\n    } else {\n      return -1;\n    }\n  } else {\n    var last_pos1 := |s1| - 1;\n    var last_pos2 := |s2| - 1;\n    var last_char1 := s1[last_pos1];\n    var last_char2 := s2[last_pos2];\n    var last_bit1 := if last_char1 == '1' then 1 else 0;\n    var last_bit2 := if last_char2 == '1' then 1 else 0;\n\n    if last_bit1 < last_bit2 {\n      return -1;\n    } else if last_bit1 > last_bit2 {\n      return 1;\n    } else {\n      var prefix1 := s1[0..last_pos1];\n      var prefix2 := s2[0..last_pos2];\n      var prefix_compare := Compare(prefix1, prefix2);\n      \n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + last_bit1 by {\n        Str2Int_Eq(s1, last_pos1);\n      }\n      assert Str2Int(s2) == 2 * Str2Int(prefix2) + last_bit2 by {\n        Str2Int_Eq(s2, last_pos2);\n      }\n\n      return prefix_compare;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add.dfy", "root", false, "", "", false, "bignum_ModExp_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_int.dfy", "root", true, "", "", false, "bignum_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nlemma ModExpPow2_lemma(x: nat, y:nat, n:nat, z: nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures ModExpPow2_int(x, y, n, z) == Exp_int(x,y) % z\n  decreases n\n{\n  if n == 0 {\n    calc {\n      ModExpPow2_int(x, y, n, z);\n      x % z;\n      { assert y == 1; }\n      Exp_int(x, y) % z;\n    }\n  } else {\n    calc {\n      ModExpPow2_int(x, y, n, z);\n      == (ModExpPow2_int(x, y/2, n-1, z) * ModExpPow2_int(x, y/2, n-1, z)) % z;\n      { ModExpPow2_lemma(x, y/2, n-1, z); }\n      (Exp_int(x, y/2) % z * Exp_int(x, y/2) % z) % z;\n      { assert (Exp_int(x, y/2) % z * Exp_int(x, y/2) % z) % z == (Exp_int(x, y/2) * Exp_int(x, y/2)) % z; }\n      == (Exp_int(x, y/2) * Exp_int(x, y/2)) % z;\n      { assert Exp_int(x, y/2) * Exp_int(x, y/2) == Exp_int(x, y); }\n      == Exp_int(x, y) % z;\n    }\n  }\n}\n\nlemma MulMod_lemma(a: nat, b: nat, m: nat)\n  requires m > 0\n  ensures (a % m) * (b % m) % m == (a * b) % m\n{\n  calc {\n    (a % m) * (b % m) % m;\n    == ((a % m) * (b % m)) % m;\n    == (a % m * b % m) % m;\n    { assert a % m * b % m == (a * b) % m; }\n    == (a * b) % m;\n  }\n}\n\nlemma Exp_int_double(x: nat, k: nat)\n  ensures Exp_int(x, 2 * k) == Exp_int(x, k) * Exp_int(x, k)\n{\n  if k == 0 {\n    calc {\n      Exp_int(x, 2 * k);\n      Exp_int(x, 0);\n      1;\n      == Exp_int(x, k) * Exp_int(x, k);\n    }\n  } else {\n    calc {\n      Exp_int(x, 2 * k);\n      == x * Exp_int(x, 2 * k - 1);\n      == x * Exp_int(x, 2 * (k - 1) + 1);\n      == x * (x * Exp_int(x, 2 * (k - 1)));\n      == x * (x * (Exp_int(x, k - 1) * Exp_int(x, k - 1)));\n      == (x * x) * (Exp_int(x, k - 1) * Exp_int(x, k - 1));\n      == (x * Exp_int(x, k - 1)) * (x * Exp_int(x, k - 1));\n      == Exp_int(x, k) * Exp_int(x, k);\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    return x % z;\n  } else {\n    var half := ModExpPow2_int(x, y / 2, n-1, z);\n    calc {\n      half;\n      == ModExpPow2_int(x, y / 2, n-1, z);\n      { ModExpPow2_lemma(x, y / 2, n-1, z); }\n      == Exp_int(x, y/2) % z;\n    }\n    var square := half * half;\n    calc {\n      square % z;\n      == (half * half) % z;\n      == ((Exp_int(x, y/2) % z) * (Exp_int(x, y/2) % z)) % z;\n      { MulMod_lemma(Exp_int(x, y/2), Exp_int(x, y/2), z); }\n      == (Exp_int(x, y/2) * Exp_int(x, y/2)) % z;\n      { Exp_int_double(x, y/2); }\n      == Exp_int(x, y) % z;\n    }\n    return square % z;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Compare_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_CompareUnequal.dfy", "root", true, "", "", false, "bignum_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function IPower(base: int, exp: nat): int\n{\n  if exp == 0 then 1 else base * IPower(base, exp-1)\n}\n\nlemma Lemma_IPower_ge(base: int, exp: nat)\n  requires base >= 2\n  ensures IPower(base, exp) >= 1\n  decreases exp;\n{\n  if exp == 0 {\n    calc {\n      IPower(base, exp);\n      { assert base * IPower(base, exp-1) == base * 1; }\n      >= 1;\n    }\n  } else {\n    calc {\n      IPower(base, exp);\n      == base * IPower(base, exp-1);\n      >= 2 * IPower(base, exp-1);\n      >= 2 * 1;\n      >= 1;\n    }\n  }\n}\n\nlemma Lemma_IPower_strict(base: int, exp1: nat, exp2: nat)\n  requires base >= 2\n  requires exp1 > exp2\n  ensures IPower(base, exp1) > IPower(base, exp2)\n  decreases exp1;\n{\n  if exp2 == 0 {\n    calc {\n      IPower(base, exp1);\n      >= IPower(2, exp1);\n      >= 2;\n      > 1;\n      == IPower(base, exp2);\n    }\n  } else {\n    calc {\n      IPower(base, exp1);\n      == base * IPower(base, exp1-1);\n      >= 2 * IPower(base, exp1-1);\n      >  2 * IPower(base, exp2-1);\n      >=  base * IPower(base, exp2-1);\n      ==  IPower(base, exp2);\n    }\n  }\n}\n\nlemma Lemma_Str2Int_monotonic(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires |s1| > |s2|\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 1 ==> s2[0] != '0'\n  ensures Str2Int(s1) >= Str2Int(s2) + (if |s2| == 0 then 1 else 0)\n  ensures Str2Int(s1) > Str2Int(s2)\n{\n  if |s2| == 0 {\n    if |s1| == 1 {\n      assert Str2Int(s1) == 0 || Str2Int(s1) == 1;\n      assert Str2Int(s2) == 0;\n    } else {\n      calc {\n        Str2Int(s1);\n        >=  IPower(2, |s1|-1);\n        >=  IPower(2, 1);\n        ==  2;\n        >  0;\n        ==  Str2Int(s2);\n      }\n    }\n  } else {\n    var min1 := IPower(2, |s1|-1);\n    var max2 := IPower(2, |s2|) - 1;\n    calc {\n      Str2Int(s1);\n      >=  min1;\n      >   max2;\n      >=  Str2Int(s2);\n    }\n  }\n}\n// </vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  Lemma_Str2Int_monotonic(s1, s2);\n  if |s1| > |s2| {\n    return 1;\n  } else if |s1| < |s2| {\n    return -1;\n  } else {\n    var i := 0;\n    while i < |s1| {\n      if s1[i] != s2[i] {\n        if s1[i] == '1' {\n          return 1;\n        } else {\n          return -1;\n        }\n      }\n      i := i + 1;\n    }\n    return 0;\n  }\n}\n// </vc-code>\n// </vc-code>\n\n", "", "", ""], ["bignum_DivMod_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Add.dfy", "root", true, "", "", false, "bignum_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nmethod AddWithCarry(s1: string, s2: string, carry: int) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2) && (carry == 0 || carry == 1)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2) + carry\n  decreases |s1| + |s2|\n{\n  if |s1| == 0 && |s2| == 0 {\n    if carry == 0 {\n      return \"\";\n    } else {\n      return \"1\";\n    }\n  } else {\n    var x := if |s1|>0 then (if s1[|s1|-1]=='1' then 1 else 0) else 0;\n    var y := if |s2|>0 then (if s2[|s2|-1]=='1' then 1 else 0) else 0;\n    var total := x + y + carry;\n    var newCarry := total / 2;\n    var bit := total % 2;\n    var s1' := if |s1|>0 then s1[0..|s1|-1] else \"\";\n    var s2' := if |s2|>0 then s2[0..|s2|-1] else \"\";\n    var res' := AddWithCarry(s1', s2', newCarry);\n    return res' + (if bit==1 then \"1\" else \"0\");\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var result := AddWithCarry(s1, s2, 0);\n  return result;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int_ModExpPow2_int.dfy", "root", false, "", "", false, "bignum_ModExp_int_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Sub.dfy", "root", false, "", "", false, "bignum_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare.dfy", "root", false, "", "", false, "bignum_DivMod_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp.dfy", "root", true, "", "", false, "bignum_ModExp.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nfunction Int2Str(n: nat): string\n{\n  if n == 0 then \"\" else Int2Str(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}\n\nfunction Mod(x: int, y: int): int\n  requires y > 0\n{\n  x % y\n}\n\nlemma Exp_int_mod_properties(x: nat, y: nat, m: nat)\n  requires m > 0\n  ensures Exp_int(x, y) % m == Exp_int(x % m, y) % m\n  decreases y\n{\n  if y == 0 {\n    calc {\n      Exp_int(x, 0) % m;\n      1 % m;\n      1;\n      Exp_int(x % m, 0) % m;\n    }\n  } else {\n    calc {\n      Exp_int(x, y) % m;\n      (x * Exp_int(x, y - 1)) % m;\n      (x % m * Exp_int(x, y - 1) % m) % m;\n      { Exp_int_mod_properties(x, y - 1, m); }\n      (x % m * Exp_int(x % m, y - 1) % m) % m;\n      Exp_int(x % m, y) % m;\n    }\n  }\n}\n\nlemma Exp_int_split(y: nat, n: nat, m: nat)\n  requires 0 <= n <= m\n  ensures Exp_int(y, m) == Exp_int(y, n) * Exp_int(y, m - n)\n  decreases m\n{\n  if n == 0 {\n  } else if n == m {\n  } else {\n    calc {\n      Exp_int(y, m);\n      y * Exp_int(y, m - 1);\n      { Exp_int_split(y, n - 1, m - 1); }\n      y * (Exp_int(y, n - 1) * Exp_int(y, m - n));\n      (y * Exp_int(y, n - 1)) * Exp_int(y, m - n);\n      Exp_int(y, n) * Exp_int(y, m - n);\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  var x := Str2Int(sx);\n  var y := Str2Int(sy);\n  var z := Str2Int(sz);\n  var resNat: nat := 1;\n  var xPow: nat := x % z;\n  var bitIndex: nat := 0;\n  \n  while bitIndex < |sy|\n  invariant 0 <= bitIndex <= |sy|\n  invariant resNat == Exp_int(xPow, Str2Int(sy[bitIndex..])) % z\n  invariant xPow == Exp_int(x, Exp_int(2, bitIndex)) % z\n  {\n    if sy[bitIndex] == '1' {\n      resNat := (resNat * xPow) % z;\n    }\n    xPow := (xPow * xPow) % z;\n    bitIndex := bitIndex + 1;\n    \n    // Update invariant for xPow\n    calc {\n      xPow;\n      (old(xPow) * old(xPow)) % z;\n      (Exp_int(x, Exp_int(2, bitIndex - 1)) % z * Exp_int(x, Exp_int(2, bitIndex - 1)) % z) % z;\n      { Exp_int_mod_properties(x, Exp_int(2, bitIndex - 1), z); }\n      (Exp_int(x % z, Exp_int(2, bitIndex - 1)) % z * Exp_int(x % z, Exp_int(2, bitIndex - 1)) % z) % z;\n      Exp_int(x % z, 2 * Exp_int(2, bitIndex - 1)) % z;\n      Exp_int(x % z, Exp_int(2, bitIndex)) % z;\n      { Exp_int_mod_properties(x, Exp_int(2, bitIndex), z); }\n      Exp_int(x, Exp_int(2, bitIndex)) % z;\n    }\n  }\n  \n  assert sy[bitIndex..] == \"\";\n  assert Str2Int(sy[bitIndex..]) == 0;\n  assert resNat == Exp_int(xPow, 0) % z;\n  assert resNat == 1 % z;\n  assert resNat == 1;\n  calc {\n    resNat;\n    Exp_int(xPow, 0) % z;\n    1 % z;\n    1;\n    Exp_int(xPow, Str2Int(sy[bitIndex..])) % z;\n  }\n  \n  return Int2Str(resNat);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExpPow2_Add.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Zeros.dfy", "root", false, "", "", false, "bignum_Zeros.dfy", "// <vc-preamble>\npredicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_CompareUnequal.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int.dfy", "root", true, "", "", false, "bignum_ModExp_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nlemma MulModProperty(a: nat, b: nat, c: nat, m: nat)\n   requires m > 1\n   ensures (a * b * c) % m == ((a % m) * (b % m) * (c % m)) % m\n {\n   calc {\n     (a * b * c) % m;\n     == ((a * b) * c) % m;\n     { \n       assert (a * b) % m == ((a % m) * (b % m)) % m;\n       (((a % m) * (b % m)) * c) % m;\n     }\n     == { assert (((a % m) * (b % m)) * c) % m == ((((a % m) * (b % m)) % m) * (c % m)) % m; }\n       ((((a % m) * (b % m)) % m) * (c % m)) % m;\n     == (((a % m) * (b % m)) * (c % m)) % m;\n     == ((a % m) * (b % m) * (c % m)) % m;\n   }\n }\n\n lemma SquareModProperty(a: nat, m: nat)\n   requires m > 1\n   ensures (a * a) % m == ((a % m) * (a % m)) % m\n {\n   calc {\n     (a * a) % m;\n     == { assert (a * a) % m == ((a % m) * (a % m)) % m; }\n     ((a % m) * (a % m)) % m;\n   }\n }\n\n lemma TwoMulModProperty(a: nat, b: nat, m: nat)\n   requires m > 1\n   ensures (a * b) % m == ((a % m) * (b % m)) % m\n {\n   MulModProperty(a, b, 1, m);\n   calc {\n     (a * b) % m;\n     == (a * b * 1) % m;\n     == MulModProperty(a, b, 1, m);\n     ((a % m) * (b % m) * (1 % m)) % m;\n     == ((a % m) * (b % m) * 1) % m;\n     == ((a % m) * (b % m)) % m;\n   }\n }\n\n lemma ModExpLemma(x: nat, y: nat, z: nat)\n   requires z > 1\n   ensures 0 <= Exp_int(x,y) % z < z\n {\n   if y == 0 {\n     calc {\n       Exp_int(x,y) % z;\n       1 % z;\n       <= { assert z > 1; }\n       z - 1;\n       < z;\n     }\n   } else {\n     calc {\n       Exp_int(x,y) % z;\n       (x * Exp_int(x, y-1)) % z;\n       == TwoMulModProperty(x, Exp_int(x,y-1), z);\n       (x % z * (Exp_int(x,y-1) % z)) % z;\n       <= { \n            assert x % z < z;\n            assert Exp_int(x,y-1) % z < z by { ModExpLemma(x, y-1, z); }\n          }\n        ((z - 1) * (z - 1)) % z;\n       < z;\n     }\n   }\n }\n\n lemma ModExpCorrectness(x: nat, y: nat, n: nat, z: nat)\n   requires y < Exp_int(2, n+1)\n   requires z > 1\n   ensures ModExp_int(x, y, n, z) == Exp_int(x, y) % z\n   decreases n\n {\n   if y == 0 {\n     assert ModExp_int(x, y, n, z) == 1 % z;\n     calc {\n       Exp_int(x, y) % z;\n       1 % z;\n     }\n   } else if n == 0 {\n     assert y == 1 by {\n       assert y < Exp_int(2, 0+1) == 2;\n     }\n     assert ModExp_int(x, y, n, z) == x % z;\n     calc {\n       Exp_int(x, y) % z;\n       (x * Exp_int(x, y-1)) % z;\n       == { assert y-1 == 0; }\n       (x * 1) % z;\n       x % z;\n     }\n   } else {\n     var k := y / 2;\n     if y % 2 == 0 {\n       assert ModExp_int(x, k, n-1, z) == Exp_int(x, k) % z by {\n         ModExpCorrectness(x, k, n-1, z);\n         assert k < Exp_int(2, n) by {\n           calc {\n             k;\n             == y / 2;\n             < (Exp_int(2, n+1)) / 2;\n             == Exp_int(2, n);\n           }\n         }\n       }\n       assert (ModExp_int(x, k, n-1, z) * ModExp_int(x, k, n-1, z)) % z == (Exp_int(x, k) * Exp_int(x, k)) % z by {\n         assert Exp_int(x,k) % z == Exp_int(x,k) % z;\n         calc {\n           (ModExp_int(x, k, n-1, z) * ModExp_int(x, k, n-1, z)) % z;\n           == { ModExpCorrectness(x, k, n-1, z); }\n           (Exp_int(x, k) % z * Exp_int(x, k) % z) % z;\n           == SquareModProperty(Exp_int(x,k), z);\n           (Exp_int(x, k) * Exp_int(x, k)) % z;\n         }\n       }\n       assert Exp_int(x, y) == Exp_int(x, k) * Exp_int(x, k) by {\n         calc {\n           Exp_int(x, y);\n           Exp_int(x, 2*k);\n           == { assert 2*k == k + k; }\n           Exp_int(x, k) * Exp_int(x, k);\n         }\n       }\n     } else {\n       assert ModExp_int(x, k, n-1, z) == Exp_int(x, k) % z by {\n         ModExpCorrectness(x, k, n-1, z);\n         assert k < Exp_int(2, n) by {\n           calc {\n             k;\n             == y / 2;\n             < (Exp_int(2, n+1)) / 2;\n             == Exp_int(2, n);\n           }\n         }\n       }\n       assert (x * (ModExp_int(x, k, n-1, z) * ModExp_int(x, k, n-1, z)) % z) % z == (x * (Exp_int(x, k) * Exp_int(x, k)) % z) % z by {\n         calc {\n           (x * (ModExp_int(x, k, n-1, z) * ModExp_int(x, k, n-1, z)) % z) % z;\n           == { ModExpCorrectness(x, k, n-1, z); }\n           (x * (Exp_int(x, k) % z * Exp_int(x, k) % z) % z) % z;\n           == { SquareModProperty(Exp_int(x,k), z); }\n           (x * (Exp_int(x, k) * Exp_int(x, k)) % z) % z;\n         }\n       }\n       assert Exp_int(x, y) == x * Exp_int(x, k) * Exp_int(x, k) by {\n         calc {\n           Exp_int(x, y);\n           Exp_int(x, 2*k + 1);\n           == { assert 2*k + 1 == k + k + 1; }\n           Exp_int(x, k + k + 1);\n           == Exp_int(x, 2*k + 1);\n           == x * Exp_int(x, 2*k);\n           == x * Exp_int(x, k) * Exp_int(x, k);\n         }\n       }\n       assert (x * (Exp_int(x, k) * Exp_int(x, k)) % z) % z == (x * Exp_int(x, k) * Exp_int(x, k)) % z by {\n         TwoMulModProperty(x, Exp_int(x,k) * Exp_int(x,k), z);\n       }\n     }\n   }\n }\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if y == 0 {\n    return 1 % z;\n  } else if n == 0 {\n    return x % z;\n  } else {\n    var k := y / 2;\n    var r := ModExp_int(x, k, n-1, z);\n    if y % 2 == 0 {\n      return (r * r) % z;\n    } else {\n      return (x * (r * r) % z) % z;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Sub_NormalizeBitstring.dfy", "root", false, "", "", false, "bignum_Sub_NormalizeBitstring.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod.dfy", "root", true, "", "", false, "bignum_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n{\n  if n == 0 then \"0\"\n  else Int2StrHelper(n)\n}\n\nfunction Int2StrHelper(n: nat): string\n  requires n > 0\n  ensures ValidBitString(Int2StrHelper(n))\n  ensures Str2Int(Int2StrHelper(n)) == n\n  decreases n\n{\n  if n == 1 then \"1\"\n  else \n    var rest := Int2StrHelper(n / 2);\n    var bit := if n % 2 == 0 then \"0\" else \"1\";\n    rest + bit\n}\n\nlemma Str2Int_properties(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) >= 0\n  ensures |s| == 0 ==> Str2Int(s) == 0\n  ensures |s| > 0 ==> Str2Int(s) == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0)\n{\n  if |s| == 0 {\n    calc {\n      Str2Int(s);\n      0;\n    }\n  } else {\n    calc {\n      Str2Int(s);\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n    }\n  }\n}\n\nmethod ParseBitString(s: string) returns (n: nat)\n  requires ValidBitString(s)\n  ensures n == Str2Int(s)\n{\n  n := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant n == Str2Int(s[0..i])\n  {\n    n := n * 2;\n    if s[i] == '1' {\n      n := n + 1;\n    }\n    i := i + 1;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  var q := 0;\n  var r := ParseBitString(dividend);\n  var d := ParseBitString(divisor);\n  \n  while r >= d\n    invariant 0 <= r\n    invariant 0 <= q\n    invariant Str2Int(dividend) == q * d + r\n    decreases r\n  {\n    q := q + 1;\n    r := r - d;\n  }\n  \n  quotient := Int2Str(q);\n  remainder := Int2Str(r);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""]]}