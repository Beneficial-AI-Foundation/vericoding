{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\nlemma Str2Int_LeadingZero(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(\"0\" + s) == Str2Int(s)\n  decreases |s|\n{\n  if |s| > 0 {\n    Str2Int_LeadingZero(s[0..|s|-1]);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  if !ValidBitString(s) {\n    t := \"0\";\n    return;\n  }\n\n  var i := 0;\n  while i < |s| && s[i] == '0'\n    invariant 0 <= i <= |s|\n    invariant Str2Int(s) == Str2Int(s[i..])\n    decreases |s| - i\n  {\n    Str2Int_LeadingZero(s[i+1..]);\n    i := i + 1;\n  }\n\n  if i == |s| {\n    t := \"0\";\n  } else {\n    t := s[i..];\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExpPow2.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare.dfy", "root", false, "", "", false, "bignum_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul.dfy", "root", false, "", "", false, "bignum_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\nfunction Int2Str(n: nat): (res: string)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == n\n  decreases n\n{\n  if n == 0 then \"0\"\n  else\n    var s_rec := Int2Str(n / 2);\n    var suffix := if n % 2 == 1 then \"1\" else \"0\";\n    if s_rec == \"0\" then suffix\n    else s_rec + suffix\n}\n\nlemma Int2StrEnsures(n: nat)\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n  decreases n\n{\n  if n > 0 {\n    Int2StrEnsures(n/2);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var val1 := Str2Int(s1);\n  var val2 := Str2Int(s2);\n  var prod := val1 * val2;\n  Int2StrEnsures(prod);\n  res := Int2Str(prod);\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_CompareUnequal.dfy", "root", false, "", "", false, "bignum_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_int.dfy", "root", false, "", "", false, "bignum_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\nlemma Lemma_ModMul(a: nat, b: nat, z: nat)\n  requires z > 0\n  ensures (a * b) % z == ((a % z) * (b % z)) % z\n{\n}\n\nlemma Lemma_Exp_int_Sum(base: nat, m: nat, n: nat)\n  ensures Exp_int(base, m + n) == Exp_int(base, m) * Exp_int(base, n)\n  decreases n\n{\n  if n > 0 {\n    Lemma_Exp_int_Sum(base, m, n - 1);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    res := x % z;\n  } else {\n    var y_rec := Exp_int(2, n-1);\n    var res_rec := ModExpPow2_int(x, y_rec, n-1, z); // res_rec == Exp_int(x, y_rec) % z\n\n    Lemma_ModMul(Exp_int(x, y_rec), Exp_int(x, y_rec), z);\n    Lemma_Exp_int_Sum(x, y_rec, y_rec);\n\n    res := (res_rec * res_rec) % z;\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_Add.dfy", "root", false, "", "", false, "bignum_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", true, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_ModExp.dfy", "root", false, "", "", false, "bignum_ModExp.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_ModExp_int.dfy", "root", false, "", "", false, "bignum_ModExp_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod.dfy", "root", false, "", "", false, "bignum_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""], ["bignum_DivMod[Compare]_impl.dfy", "root", false, "", "", false, "", "", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  if Str2Int(dividend) < Str2Int(divisor) {\n    quotient := \"0\";\n    remainder := if dividend == \"\" then \"0\" else dividend;\n    return;\n  }\n\n  var q_prefix, r_prefix := DivMod(dividend[0..|dividend|-1], divisor);\n\n  var temp_rem := r_prefix + dividend[|dividend|-1..];\n\n  if Str2Int(temp_rem) < Str2Int(divisor) {\n    quotient := q_prefix + \"0\";\n    remainder := temp_rem;\n  } else {\n    var q', r' := DivMod(temp_rem, divisor);\n    assert Str2Int(q') == 1;\n    quotient := q_prefix + \"1\";\n    remainder := r';\n  }\n}\n// </vc-code>\n", "", "", ""]]}