{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["bignum_ModExp_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_NormalizeBitString.dfy", "root", true, "", "", false, "bignum_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma Str2IntLeadingZero(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  requires s[0] == '0'\n  ensures Str2Int(s) == Str2Int(s[1..])\n  decreases |s|\n{\n  if |s| == 1 {\n    assert s == \"0\";\n    assert s[1..] == \"\";\n    assert Str2Int(s) == 0;\n    assert Str2Int(s[1..]) == 0;\n  } else {\n    assert ValidBitString(s[1..]) by { ValidBitStringSubstring(s, 1, |s|); }\n    assert |s[1..]| > 0;\n    assert s[1..][0] == s[1];\n    assert ValidBitString(s[1..]);\n    \n    calc {\n      Str2Int(s);\n      == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n      == { \n        assert s[0..|s|-1][0] == s[0];\n        assert s[0..|s|-1][0] == '0';\n        assert ValidBitString(s[0..|s|-1]) by { ValidBitStringSubstring(s, 0, |s|-1); }\n        Str2IntLeadingZero(s[0..|s|-1]);\n      }\n        2 * Str2Int(s[0..|s|-1][1..]) + (if s[|s|-1] == '1' then 1 else 0);\n      == { assert s[0..|s|-1][1..] == s[1..|s|-1]; }\n        2 * Str2Int(s[1..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n      == { \n        assert s[1..][0..|s[1..]|-1] == s[1..|s|-1];\n        assert s[1..][|s[1..]|-1] == s[1..][|s|-2] == s[|s|-1];\n      }\n        2 * Str2Int(s[1..][0..|s[1..]|-1]) + (if s[1..][|s[1..]|-1] == '1' then 1 else 0);\n      == Str2Int(s[1..]);\n    }\n  }\n}\n\nlemma Str2IntConcatenation(prefix: string, suffix: string)\n  requires ValidBitString(prefix)\n  requires ValidBitString(suffix)\n  requires ValidBitString(prefix + suffix)\n  requires |prefix| > 0\n  requires forall k | 0 <= k < |prefix| :: prefix[k] == '0'\n  ensures Str2Int(prefix + suffix) == Str2Int(suffix)\n  decreases |prefix|\n{\n  var s := prefix + suffix;\n  if |prefix| == 1 {\n    assert prefix == \"0\";\n    assert s[0] == '0';\n    assert ValidBitString(s);\n    assert s[1..] == suffix;\n    Str2IntLeadingZero(s);\n    assert Str2Int(s) == Str2Int(s[1..]);\n    assert Str2Int(s) == Str2Int(suffix);\n  } else {\n    var newPrefix := prefix[1..];\n    assert |newPrefix| == |prefix| - 1;\n    assert |newPrefix| < |prefix|;\n    assert prefix == prefix[0..1] + newPrefix;\n    assert s == prefix[0..1] + newPrefix + suffix;\n    assert s == prefix[0..1] + (newPrefix + suffix);\n    assert ValidBitString(newPrefix) by { ValidBitStringSubstring(prefix, 1, |prefix|); }\n    assert ValidBitString(newPrefix + suffix);\n    assert forall k | 0 <= k < |newPrefix| :: newPrefix[k] == '0';\n    Str2IntConcatenation(newPrefix, suffix);\n    var intermediate := newPrefix + suffix;\n    assert Str2Int(intermediate) == Str2Int(suffix);\n    assert |prefix[0..1]| == 1;\n    Str2IntConcatenation(prefix[0..1], intermediate);\n    assert Str2Int(s) == Str2Int(intermediate);\n    assert Str2Int(s) == Str2Int(suffix);\n  }\n}\n\nlemma ValidBitStringSubstring(s: string, i: int, j: int)\n  requires ValidBitString(s)\n  requires 0 <= i <= j <= |s|\n  ensures ValidBitString(s[i..j])\n{\n}\n\nlemma AllZerosStr2Int(s: string)\n  requires ValidBitString(s)\n  requires forall k | 0 <= k < |s| :: s[k] == '0'\n  ensures Str2Int(s) == 0\n  decreases |s|\n{\n  if |s| == 0 {\n  } else if |s| == 1 {\n    assert s == \"0\";\n  } else {\n    assert ValidBitString(s[1..]) by { ValidBitStringSubstring(s, 1, |s|); }\n    assert forall k | 0 <= k < |s[1..]| :: s[1..][k] == '0';\n    AllZerosStr2Int(s[1..]);\n    assert Str2Int(s[1..]) == 0;\n    assert s[0] == '0';\n    Str2IntLeadingZero(s);\n    assert Str2Int(s) == Str2Int(s[1..]);\n    assert Str2Int(s) == 0;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  if !ValidBitString(s) {\n    t := \"0\";\n    return;\n  }\n  \n  if |s| == 0 {\n    t := \"0\";\n    return;\n  }\n  \n  var i := 0;\n  while i < |s| && s[i] == '0'\n    invariant 0 <= i <= |s|\n    invariant forall k | 0 <= k < i :: s[k] == '0'\n  {\n    i := i + 1;\n  }\n  \n  if i == |s| {\n    t := \"0\";\n    assert ValidBitString(s);\n    AllZerosStr2Int(s);\n    assert Str2Int(s) == 0;\n    assert Str2Int(t) == 0;\n    return;\n  }\n  \n  t := s[i..];\n  assert ValidBitString(t) by { ValidBitStringSubstring(s, i, |s|); }\n  assert |t| > 0;\n  assert t[0] != '0';\n  \n  var prefix := s[0..i];\n  assert s == prefix + t;\n  assert forall k | 0 <= k < |prefix| :: prefix[k] == '0';\n  assert ValidBitString(prefix) by { ValidBitStringSubstring(s, 0, i); }\n  \n  if |prefix| > 0 {\n    Str2IntConcatenation(prefix, t);\n    assert Str2Int(s) == Str2Int(t);\n  } else {\n    assert s == t;\n    assert Str2Int(s) == Str2Int(t);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Mul_Add.dfy", "root", false, "", "", false, "bignum_Mul_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul.dfy", "root", true, "", "", false, "bignum_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n  decreases n\n{\n  if n == 0 then \"0\"\n  else if n == 1 then \"1\"\n  else Int2Str(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}\n\nlemma Int2StrCorrect(n: nat)\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n{\n  // Proof by induction follows from the definition\n}\n\nlemma Str2IntNonNegative(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) >= 0\n{\n  // Follows from definition since Str2Int returns nat\n}\n\nlemma Str2IntMultiplicative(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(Int2Str(Str2Int(s1) * Str2Int(s2))) == Str2Int(s1) * Str2Int(s2)\n{\n  Int2StrCorrect(Str2Int(s1) * Str2Int(s2));\n}\n\nlemma ValidBitStringConcat(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(s1 + s2)\n{\n  // Follows from definition of ValidBitString\n}\n\nfunction Str2IntFunc(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2IntFunc(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nlemma Str2IntEquivalence(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) == Str2IntFunc(s)\n{\n  // Follows from identical definitions\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var val1 := Str2IntFunc(s1);\n  var val2 := Str2IntFunc(s2);\n  var product := val1 * val2;\n  res := Int2Str(product);\n  \n  Str2IntEquivalence(s1);\n  Str2IntEquivalence(s2);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2.dfy", "root", true, "", "", false, "bignum_ModExpPow2.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n{\n  if n == 0 then \"0\"\n  else if n % 2 == 0 then Int2Str(n / 2) + \"0\"\n  else Int2Str(n / 2) + \"1\"\n}\n\nlemma Int2StrValid(n: nat)\n  ensures ValidBitString(Int2Str(n))\n{\n  if n == 0 {\n    // Base case\n  } else {\n    Int2StrValid(n / 2);\n  }\n}\n\nlemma Int2StrCorrect(n: nat)\n  ensures ValidBitString(Int2Str(n))\n  ensures Str2Int(Int2Str(n)) == n\n{\n  Int2StrValid(n);\n  if n == 0 {\n    // Base case\n  } else if n % 2 == 0 {\n    Int2StrCorrect(n / 2);\n  } else {\n    Int2StrCorrect(n / 2);\n  }\n}\n\nfunction ModMul(a: nat, b: nat, m: nat): nat\n  requires m > 0\n{\n  (a * b) % m\n}\n\nfunction ModSquare(a: nat, m: nat): nat\n  requires m > 0\n{\n  (a * a) % m\n}\n\nlemma ExpPow2Property(x: nat, n: nat)\n  ensures n > 0 ==> Exp_int(x, Exp_int(2, n)) == Exp_int(Exp_int(x, Exp_int(2, n-1)), 2)\n{\n  if n > 0 {\n    calc {\n      Exp_int(x, Exp_int(2, n));\n      == { assert Exp_int(2, n) == 2 * Exp_int(2, n-1); }\n      Exp_int(x, 2 * Exp_int(2, n-1));\n      == { ExpMultProperty(x, Exp_int(2, n-1), 2); }\n      Exp_int(Exp_int(x, Exp_int(2, n-1)), 2);\n    }\n  }\n}\n\nlemma ExpMultProperty(x: nat, a: nat, b: nat)\n  ensures Exp_int(x, a * b) == Exp_int(Exp_int(x, a), b)\n{\n  if b == 0 {\n    calc {\n      Exp_int(x, a * 0);\n      == { assert a * 0 == 0; }\n      Exp_int(x, 0);\n      == 1;\n      == Exp_int(Exp_int(x, a), 0);\n    }\n  } else if a == 0 {\n    calc {\n      Exp_int(x, 0 * b);\n      == { assert 0 * b == 0; }\n      Exp_int(x, 0);\n      == 1;\n      == { ExpOfOne(b); }\n      Exp_int(1, b);\n      == Exp_int(Exp_int(x, 0), b);\n    }\n  } else {\n    ExpMultProperty(x, a, b - 1);\n    calc {\n      Exp_int(x, a * b);\n      == { assert a * b == a + a * (b - 1); }\n      Exp_int(x, a + a * (b - 1));\n      == { ExpAddProperty(x, a, a * (b - 1)); }\n      Exp_int(x, a) * Exp_int(x, a * (b - 1));\n      == { ExpMultProperty(x, a, b - 1); }\n      Exp_int(x, a) * Exp_int(Exp_int(x, a), b - 1);\n      == Exp_int(Exp_int(x, a), b);\n    }\n  }\n}\n\nlemma ExpAddProperty(x: nat, a: nat, b: nat)\n  ensures Exp_int(x, a + b) == Exp_int(x, a) * Exp_int(x, b)\n{\n  if b == 0 {\n    calc {\n      Exp_int(x, a + 0);\n      == Exp_int(x, a);\n      == Exp_int(x, a) * 1;\n      == Exp_int(x, a) * Exp_int(x, 0);\n    }\n  } else {\n    ExpAddProperty(x, a, b - 1);\n    calc {\n      Exp_int(x, a + b);\n      == Exp_int(x, a + (b - 1) + 1);\n      == x * Exp_int(x, a + (b - 1));\n      == { ExpAddProperty(x, a, b - 1); }\n      x * (Exp_int(x, a) * Exp_int(x, b - 1));\n      == Exp_int(x, a) * (x * Exp_int(x, b - 1));\n      == Exp_int(x, a) * Exp_int(x, b);\n    }\n  }\n}\n\nlemma ExpOfOne(b: nat)\n  ensures Exp_int(1, b) == 1\n{\n  if b == 0 {\n  } else {\n    ExpOfOne(b - 1);\n  }\n}\n\nlemma {:timeout 60} ModExpProperty(x: nat, y: nat, m: nat)\n  requires m > 0\n  ensures Exp_int(x, y) % m == Exp_int(x % m, y) % m\n{\n  if y == 0 {\n    calc {\n      Exp_int(x, 0) % m;\n      == 1 % m;\n      == Exp_int(x % m, 0) % m;\n    }\n  } else {\n    ModExpProperty(x, y - 1, m);\n    calc {\n      Exp_int(x, y) % m;\n      == (x * Exp_int(x, y - 1)) % m;\n      == ((x % m) * (Exp_int(x, y - 1) % m)) % m;\n      == { ModExpProperty(x, y - 1, m); }\n      ((x % m) * (Exp_int(x % m, y - 1) % m)) % m;\n      == (x % m * Exp_int(x % m, y - 1)) % m;\n      == Exp_int(x % m, y) % m;\n    }\n  }\n}\n\nfunction Pow2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Pow2(n - 1)\n}\n\nlemma Pow2IsExp(n: nat)\n  ensures Pow2(n) == Exp_int(2, n)\n{\n  if n == 0 {\n  } else {\n    Pow2IsExp(n - 1);\n  }\n}\n\nfunction Str2IntCompiled(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2IntCompiled(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nlemma Str2IntEquivalence(s: string)\n  requires ValidBitString(s)\n  ensures Str2IntCompiled(s) == Str2Int(s)\n{\n}\n\nlemma Pow2Length(n: nat)\n  ensures |Int2Str(Pow2(n))| == n + 1\n{\n  Pow2IsExp(n);\n  if n == 0 {\n    assert Pow2(0) == 1;\n    assert Int2Str(1) == Int2Str(1 / 2) + \"1\";\n    assert Int2Str(1) == Int2Str(0) + \"1\";\n    assert Int2Str(1) == \"0\" + \"1\";\n    assert Int2Str(1) == \"01\";\n    assert false;\n  } else {\n    Pow2Length(n - 1);\n    assert Pow2(n) == 2 * Pow2(n - 1);\n    assert Pow2(n - 1) > 0;\n    assert Pow2(n) % 2 == 0;\n  }\n}\n\nlemma Int2StrOne()\n  ensures Int2Str(1) == \"1\"\n{\n  calc {\n    Int2Str(1);\n    == Int2Str(1 / 2) + \"1\";\n    == Int2Str(0) + \"1\";\n    == \"0\" + \"1\";\n    == \"01\";\n  }\n  assert false;\n}\n\nlemma Pow2Positive(n: nat)\n  ensures Pow2(n) > 0\n{\n  if n == 0 {\n  } else {\n    Pow2Positive(n - 1);\n  }\n}\n\nlemma Str2IntPositivePow2(n: nat)\n  ensures ValidBitString(Int2Str(Pow2(n)))\n  ensures Str2Int(Int2Str(Pow2(n))) > 0\n{\n  Int2StrCorrect(Pow2(n));\n  Pow2Positive(n);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  ghost var x := Str2Int(sx);\n  ghost var y := Str2Int(sy);\n  ghost var z := Str2Int(sz);\n  \n  if Str2IntCompiled(sy) == 0 {\n    res := \"1\";\n    Str2IntEquivalence(sy);\n    return;\n  }\n  \n  if n == 0 {\n    var x_compiled := Str2IntCompiled(sx);\n    var z_compiled := Str2IntCompiled(sz);\n    Str2IntEquivalence(sz);\n    Str2IntEquivalence(sx);\n    res := Int2Str(x_compiled % z_compiled);\n    Int2StrCorrect(x_compiled % z_compiled);\n    return;\n  }\n  \n  var half_exp := Pow2(n-1);\n  Pow2IsExp(n-1);\n  Pow2Positive(n-1);\n  var sy_half := Int2Str(half_exp);\n  \n  Int2StrCorrect(half_exp);\n  Str2IntPositivePow2(n-1);\n  \n  var temp := ModExpPow2(sx, sy_half, n-1, sz);\n  var temp_val := Str2IntCompiled(temp);\n  var z_compiled := Str2IntCompiled(sz);\n  \n  Str2IntEquivalence(sz);\n  Str2IntEquivalence(temp);\n  \n  res := Int2Str(ModSquare(temp_val, z_compiled));\n  \n  Int2StrCorrect(ModSquare(temp_val, z_compiled));\n  \n  ghost var temp_ghost := Str2Int(temp);\n  assert temp_ghost == Exp_int(x, Exp_int(2, n-1)) % z;\n  ExpPow2Property(x, n);\n  assert Exp_int(x, Exp_int(2, n)) == Exp_int(temp_ghost, 2);\n  assert ModSquare(temp_val, z_compiled) == (temp_ghost * temp_ghost) % z;\n  assert Exp_int(temp_ghost, 2) == temp_ghost * temp_ghost;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare.dfy", "root", true, "", "", false, "bignum_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma Str2IntMonotonic(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  ensures Str2Int(s[0..|s|-1]) <= Str2Int(s)\n{\n  if |s| == 1 {\n    assert s[0..|s|-1] == \"\";\n    assert Str2Int(s[0..|s|-1]) == 0;\n  } else {\n    assert Str2Int(s) == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n  }\n}\n\nlemma Str2IntPositive(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) >= 0\n{\n}\n\nghost function Zeros(n: nat): string\n{\n  if n == 0 then \"\" else \"0\" + Zeros(n - 1)\n}\n\nlemma ZerosLength(n: nat)\n  ensures |Zeros(n)| == n\n  decreases n\n{\n  if n == 0 {\n  } else {\n    ZerosLength(n - 1);\n  }\n}\n\nlemma ZerosValidBitString(n: nat)\n  ensures ValidBitString(Zeros(n))\n  decreases n\n{\n  if n == 0 {\n  } else {\n    ZerosValidBitString(n - 1);\n  }\n}\n\nlemma ZerosSliceProperty(n: nat)\n  requires n > 0\n  ensures |Zeros(n)| == n\n  ensures |Zeros(n - 1)| == n - 1\n  ensures Zeros(n)[0..n-1] == Zeros(n - 1)\n  decreases n\n{\n  ZerosLength(n);\n  ZerosLength(n - 1);\n  if n == 1 {\n    assert Zeros(1) == \"0\";\n    assert Zeros(0) == \"\";\n    assert Zeros(1)[0..0] == \"\";\n  } else {\n    ZerosSliceProperty(n - 1);\n    assert Zeros(n) == \"0\" + Zeros(n - 1);\n    assert Zeros(n)[0..n-1] == (\"0\" + Zeros(n - 1))[0..n-1];\n    assert (\"0\" + Zeros(n - 1))[0..n-1] == \"0\" + Zeros(n - 1)[0..n-2];\n    assert Zeros(n - 1)[0..n-2] == Zeros(n - 2);\n    assert Zeros(n)[0..n-1] == \"0\" + Zeros(n - 2);\n    assert \"0\" + Zeros(n - 2) == Zeros(n - 1);\n  }\n}\n\nlemma ZerosValue(n: nat)\n  requires n >= 0\n  ensures ValidBitString(Zeros(n))\n  ensures Str2Int(Zeros(n)) == 0\n  decreases n\n{\n  ZerosValidBitString(n);\n  if n == 0 {\n    assert Zeros(0) == \"\";\n    assert Str2Int(\"\") == 0;\n  } else {\n    ZerosValue(n - 1);\n    ZerosSliceProperty(n);\n    assert Zeros(n) == \"0\" + Zeros(n - 1);\n    assert |Zeros(n)| == n;\n    assert |Zeros(n - 1)| == n - 1;\n    assert Str2Int(Zeros(n)) == 2 * Str2Int(Zeros(n)[0..n-1]) + (if Zeros(n)[n-1] == '1' then 1 else 0);\n    assert Str2Int(Zeros(n)) == 2 * Str2Int(Zeros(n - 1)) + 0;\n    assert Str2Int(Zeros(n)) == 2 * 0 + 0;\n    assert Str2Int(Zeros(n)) == 0;\n  }\n}\n\nlemma ZerosCharacter(n: nat, i: nat)\n  requires i < n\n  ensures |Zeros(n)| == n\n  ensures Zeros(n)[i] == '0'\n  decreases n\n{\n  ZerosLength(n);\n  if n == 1 {\n    assert i == 0;\n    assert Zeros(1) == \"0\";\n  } else {\n    if i == 0 {\n      assert Zeros(n)[0] == '0';\n    } else {\n      ZerosCharacter(n - 1, i - 1);\n      assert Zeros(n) == \"0\" + Zeros(n - 1);\n      assert Zeros(n)[i] == Zeros(n - 1)[i - 1];\n    }\n  }\n}\n\nlemma Str2IntBounds(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  ensures Str2Int(s) >= 1 <==> s != Zeros(|s|)\n{\n  ZerosValue(|s|);\n  if Str2Int(s) >= 1 {\n    if s == Zeros(|s|) {\n      assert Str2Int(s) == 0;\n      assert false;\n    }\n  } else {\n    assert Str2Int(s) == 0;\n    if s != Zeros(|s|) {\n      Str2IntZeroImpliesAllZeros(s);\n    }\n  }\n}\n\nlemma Str2IntZeroImpliesAllZeros(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  requires Str2Int(s) == 0\n  ensures s == Zeros(|s|)\n  decreases |s|\n{\n  if |s| == 1 {\n    assert Str2Int(s) == if s[0] == '1' then 1 else 0;\n    assert Str2Int(s) == 0;\n    assert s[0] == '0';\n    assert s == \"0\";\n    assert Zeros(1) == \"0\";\n  } else {\n    assert Str2Int(s) == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n    assert 0 == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n    assert s[|s|-1] == '0';\n    assert Str2Int(s[0..|s|-1]) == 0;\n    ValidSubstring(s, 0, |s|-1);\n    if |s[0..|s|-1]| > 0 {\n      Str2IntZeroImpliesAllZeros(s[0..|s|-1]);\n      assert s[0..|s|-1] == Zeros(|s[0..|s|-1]|);\n    } else {\n      assert s[0..|s|-1] == \"\";\n      assert Zeros(0) == \"\";\n    }\n    ZerosLength(|s|);\n    ZerosLength(|s|-1);\n    assert Zeros(|s|) == \"0\" + Zeros(|s|-1);\n    assert s == s[0..|s|-1] + [s[|s|-1]];\n    assert s[0..|s|-1] == Zeros(|s|-1);\n    assert s[|s|-1] == '0';\n    assert s == Zeros(|s|-1) + \"0\";\n    assert s == Zeros(|s|);\n  }\n}\n\nfunction power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * power2(n - 1)\n}\n\nlemma ValidSubstring(s: string, i: int, j: int)\n  requires ValidBitString(s)\n  requires 0 <= i <= j <= |s|\n  ensures ValidBitString(s[i..j])\n{\n}\n\nlemma Str2IntDecrease(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires |s1| > 0 && |s2| > 0\n  ensures Str2Int(s1[0..|s1|-1]) + Str2Int(s2[0..|s2|-1]) < Str2Int(s1) + Str2Int(s2)\n  ensures Str2Int(s1[0..|s1|-1]) + Str2Int(s2[0..|s2|-1]) >= 0\n{\n  assert Str2Int(s1) == 2 * Str2Int(s1[0..|s1|-1]) + (if s1[|s1|-1] == '1' then 1 else 0);\n  assert Str2Int(s2) == 2 * Str2Int(s2[0..|s2|-1]) + (if s2[|s2|-1] == '1' then 1 else 0);\n  var val1 := if s1[|s1|-1] == '1' then 1 else 0;\n  var val2 := if s2[|s2|-1] == '1' then 1 else 0;\n  var prefixSum := Str2Int(s1[0..|s1|-1]) + Str2Int(s2[0..|s2|-1]);\n  var totalSum := Str2Int(s1) + Str2Int(s2);\n  \n  assert totalSum == 2 * prefixSum + val1 + val2;\n  assert val1 >= 0 && val2 >= 0;\n  assert val1 <= 1 && val2 <= 1;\n  \n  if prefixSum == 0 {\n    assert val1 + val2 >= 0;\n    assert val1 == 0 || val1 == 1;\n    assert val2 == 0 || val2 == 1;\n    if val1 + val2 > 0 {\n      assert totalSum > prefixSum;\n    } else {\n      assert val1 == 0 && val2 == 0;\n      assert s1[|s1|-1] == '0' && s2[|s2|-1] == '0';\n      assert totalSum == 0 && prefixSum == 0;\n      assert |s1| > 0 && |s2| > 0;\n      assert s1[|s1|-1] == '0' || s1[|s1|-1] == '1';\n      assert s2[|s2|-1] == '0' || s2[|s2|-1] == '1';\n      assert totalSum >= 0;\n    }\n  } else {\n    assert prefixSum >= 1;\n    assert 2 * prefixSum >= 2;\n    assert totalSum >= 2 * prefixSum;\n    assert totalSum > prefixSum;\n  }\n}\n\nlemma Str2IntZeroString(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  ensures Str2Int(s) == 0 <==> s == Zeros(|s|)\n{\n  Str2IntBounds(s);\n}\n\nfunction IsAllZeros(s: string): bool\n  requires ValidBitString(s)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nlemma IsAllZerosCorrect(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  ensures IsAllZeros(s) <==> s == Zeros(|s|)\n{\n  ZerosValidBitString(|s|);\n  ZerosLength(|s|);\n  if IsAllZeros(s) {\n    assert forall i | 0 <= i < |s| :: s[i] == '0';\n    forall i | 0 <= i < |s|\n      ensures s[i] == Zeros(|s|)[i]\n    {\n      ZerosCharacter(|s|, i);\n    }\n    assert s == Zeros(|s|);\n  } else {\n    var j :| 0 <= j < |s| && s[j] != '0';\n    assert s[j] == '1';\n    ZerosCharacter(|s|, j);\n    assert Zeros(|s|)[j] == '0';\n    assert s != Zeros(|s|);\n  }\n}\n\nlemma EmptyStringZero()\n  ensures Str2Int(\"\") == 0\n  ensures ValidBitString(\"\")\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  if |s1| == 0 && |s2| == 0 {\n    EmptyStringZero();\n    res := 0;\n  } else if |s1| == 0 {\n    EmptyStringZero();\n    if |s2| > 0 {\n      var isAllZeros2 := IsAllZeros(s2);\n      ghost var zeros2 := Zeros(|s2|);\n      IsAllZerosCorrect(s2);\n      ZerosValue(|s2|);\n      if !isAllZeros2 {\n        Str2IntBounds(s2);\n        assert Str2Int(s2) >= 1;\n        res := -1;\n      } else {\n        assert Str2Int(s2) == 0;\n        res := 0;\n      }\n    } else {\n      res := 0;\n    }\n  } else if |s2| == 0 {\n    EmptyStringZero();\n    var isAllZeros1 := IsAllZeros(s1);\n    ghost var zeros1 := Zeros(|s1|);\n    IsAllZerosCorrect(s1);\n    ZerosValue(|s1|);\n    if !isAllZeros1 {\n      Str2IntBounds(s1);\n      assert Str2Int(s1) >= 1;\n      res := 1;\n    } else {\n      assert Str2Int(s1) == 0;\n      res := 0;\n    }\n  } else {\n    ValidSubstring(s1, 0, |s1|-1);\n    ValidSubstring(s2, 0, |s2|-1);\n    \n    var prefix1 := s1[0..|s1|-1];\n    var prefix2 := s2[0..|s2|-1];\n    var bit1 := s1[|s1|-1];\n    var bit2 := s2[|s2|-1];\n    \n    Str2IntDecrease(s1, s2);\n    var prefixRes := Compare(prefix1, prefix2);\n    \n    if prefixRes == -1 {\n      assert Str2Int(prefix1) < Str2Int(prefix2);\n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + (if bit1 == '1' then 1 else 0);\n      assert Str2Int(s2) == 2 * Str2Int(prefix2) + (if bit2 == '1' then 1 else 0);\n      assert 2 * Str2Int(prefix1) + 1 < 2 * Str2Int(prefix2);\n      res := -1;\n    } else if prefixRes == 1 {\n      assert Str2Int(prefix1) > Str2Int(prefix2);\n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + (if bit1 == '1' then 1 else 0);\n      assert Str2Int(s2) == 2 * Str2Int(prefix2) + (if bit2 == '1' then 1 else 0);\n      assert 2 * Str2Int(prefix1) > 2 * Str2Int(prefix2) + 1;\n      res := 1;\n    } else {\n      assert Str2Int(prefix1) == Str2Int(prefix2);\n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + (if bit1 == '1' then 1 else 0);\n      assert Str2Int(s2) == 2 * Str2Int(prefix2) + (if bit2 == '1' then 1 else 0);\n      assert Str2Int(s1) == 2 * Str2Int(prefix1) + (if bit1 == '1' then 1 else 0);\n      assert Str2Int(s2) == 2 * Str2Int(prefix1) + (if bit2 == '1' then 1 else 0);\n      if bit1 == '0' && bit2 == '1' {\n        assert Str2Int(s1) == 2 * Str2Int(prefix1);\n        assert Str2Int(s2) == 2 * Str2Int(prefix1) + 1;\n        res := -1;\n      } else if bit1 == '1' && bit2 == '0' {\n        assert Str2Int(s1) == 2 * Str2Int(prefix1) + 1;\n        assert Str2Int(s2) == 2 * Str2Int(prefix1);\n        res := 1;\n      } else {\n        assert (bit1 == '0' && bit2 == '0') || (bit1 == '1' && bit2 == '1');\n        assert Str2Int(s1) == Str2Int(s2);\n        res := 0;\n      }\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add.dfy", "root", false, "", "", false, "bignum_ModExp_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_int.dfy", "root", true, "", "", false, "bignum_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nfunction Exp_int_func(x: nat, y: nat): nat\n{\n  if y == 0 then 1 else x * Exp_int_func(x, y - 1)\n}\n\nlemma Exp_int_func_equals_Exp_int(x: nat, y: nat)\n  ensures Exp_int_func(x, y) == Exp_int(x, y)\n{\n  if y == 0 {\n  } else {\n    Exp_int_func_equals_Exp_int(x, y - 1);\n  }\n}\n\nlemma ExpBasicProperty(x: nat, k: nat)\n  requires k > 0\n  ensures Exp_int(x, k) == x * Exp_int(x, k - 1)\n{\n}\n\nlemma ExpSquareBasic(x: nat)\n  ensures Exp_int(x, 2) == x * x\n{\n  assert Exp_int(x, 2) == x * Exp_int(x, 1);\n  assert Exp_int(x, 1) == x * Exp_int(x, 0);\n  assert Exp_int(x, 0) == 1;\n}\n\nlemma ExpSquareProperty(x: nat, k: nat)\n  ensures Exp_int(x, 2 * k) == Exp_int(Exp_int(x, k), 2)\n{\n  if k == 0 {\n    assert Exp_int(x, 0) == 1;\n    assert Exp_int(1, 2) == 1;\n  } else {\n    ExpBasicProperty(x, 2 * k);\n    ExpBasicProperty(x, 2 * k - 1);\n    ExpSquareProperty(x, k - 1);\n    ExpBasicProperty(x, k);\n    ExpSquareBasic(Exp_int(x, k));\n    ExpSquareBasic(Exp_int(x, k - 1));\n    \n    calc {\n      Exp_int(x, 2 * k);\n      == x * Exp_int(x, 2 * k - 1);\n      == x * x * Exp_int(x, 2 * k - 2);\n      == { assert 2 * k - 2 == 2 * (k - 1); }\n      x * x * Exp_int(x, 2 * (k - 1));\n      == { ExpSquareProperty(x, k - 1); }\n      x * x * Exp_int(Exp_int(x, k - 1), 2);\n      == x * x * (Exp_int(x, k - 1) * Exp_int(x, k - 1));\n      == (x * Exp_int(x, k - 1)) * (x * Exp_int(x, k - 1));\n      == Exp_int(x, k) * Exp_int(x, k);\n      == Exp_int(Exp_int(x, k), 2);\n    }\n  }\n}\n\nlemma ModSquareProperty(a: nat, z: nat)\n  requires z > 0\n  ensures (a * a) % z == ((a % z) * (a % z)) % z\n{\n  assert (a * a) % z == ((a % z) * (a % z)) % z;\n}\n\nlemma PowerOfTwoDecomposition(n: nat)\n  requires n > 0\n  ensures Exp_int(2, n) == 2 * Exp_int(2, n - 1)\n{\n}\n\nlemma ModExpCorrectness(x: nat, exp: nat, halfRes: nat, z: nat)\n  requires z > 0\n  requires halfRes == Exp_int(x, exp) % z\n  ensures (halfRes * halfRes) % z == Exp_int(x, 2 * exp) % z\n{\n  ModSquareProperty(Exp_int(x, exp), z);\n  ExpSquareProperty(x, exp);\n  \n  calc {\n    (halfRes * halfRes) % z;\n    == ((Exp_int(x, exp) % z) * (Exp_int(x, exp) % z)) % z;\n    == (Exp_int(x, exp) * Exp_int(x, exp)) % z;\n    == { ExpSquareBasic(Exp_int(x, exp)); }\n    Exp_int(Exp_int(x, exp), 2) % z;\n    == { ExpSquareProperty(x, exp); }\n    Exp_int(x, 2 * exp) % z;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    assert y == Exp_int(2, 0) == 1;\n    res := x % z;\n    assert res == Exp_int(x, 1) % z;\n    assert Exp_int(x, 1) == x;\n  } else {\n    PowerOfTwoDecomposition(n);\n    assert y == 2 * Exp_int(2, n - 1);\n    \n    Exp_int_func_equals_Exp_int(2, n - 1);\n    var halfRes := ModExpPow2_int(x, Exp_int_func(2, n - 1), n - 1, z);\n    \n    ModExpCorrectness(x, Exp_int(2, n - 1), halfRes, z);\n    res := (halfRes * halfRes) % z;\n    assert res == Exp_int(x, 2 * Exp_int(2, n - 1)) % z;\n    assert 2 * Exp_int(2, n - 1) == y;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Compare_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_CompareUnequal.dfy", "root", true, "", "", false, "bignum_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma Str2IntPositive(s: string)\n  requires ValidBitString(s) && |s| > 0\n  ensures Str2Int(s) >= 0\n  ensures (exists i :: 0 <= i < |s| && s[i] == '1') ==> Str2Int(s) > 0\n{\n  if |s| == 1 {\n    assert s[0] == '0' || s[0] == '1';\n  } else {\n    Str2IntPositive(s[0..|s|-1]);\n    assert Str2Int(s) == 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n  }\n}\n\nlemma Str2IntNonLeadingZero(s: string)\n  requires ValidBitString(s) && |s| > 0\n  requires |s| > 1 ==> s[0] != '0'\n  ensures (|s| == 1 && s[0] == '1') || |s| > 1 ==> Str2Int(s) >= 1\n{\n  if |s| == 1 {\n    assert s[0] == '0' || s[0] == '1';\n    if s[0] == '1' {\n      assert Str2Int(s) == 1;\n    }\n  } else {\n    assert s[0] != '0';\n    assert s[0] == '1';\n    var prefix := s[0..|s|-1];\n    assert ValidBitString(prefix);\n    Str2IntPositive(prefix);\n    assert Str2Int(s) == 2 * Str2Int(prefix) + (if s[|s|-1] == '1' then 1 else 0);\n    assert Str2Int(s) >= 1;\n  }\n}\n\nlemma Str2IntBound(s: string)\n  requires ValidBitString(s) && |s| > 0\n  requires |s| > 1 ==> s[0] != '0'\n  ensures (|s| == 1 && s[0] == '1') || |s| > 1 ==> Str2Int(s) >= 1\n  ensures |s| > 1 ==> Str2Int(s) >= Str2IntPowerOf2(|s| - 1)\n{\n  Str2IntNonLeadingZero(s);\n  if |s| > 1 {\n    assert s[0] != '0';\n    assert s[0] == '1';\n    var prefix := s[0..|s|-1];\n    assert ValidBitString(prefix);\n    Str2IntPositive(prefix);\n    assert Str2Int(prefix) >= 0;\n    assert Str2Int(s) == 2 * Str2Int(prefix) + (if s[|s|-1] == '1' then 1 else 0);\n    assert Str2Int(s) >= 2 * Str2Int(prefix);\n    assert Str2Int(s) >= 2 * 0;\n    assert Str2IntPowerOf2(|s| - 1) == Str2IntPowerOf2(|prefix|);\n    Str2IntPowerOf2Lemma(|prefix| - 1);\n    if |prefix| > 0 {\n      assert 2 * Str2IntPowerOf2(|prefix| - 1) == Str2IntPowerOf2(|prefix|);\n      assert Str2Int(s) >= Str2IntPowerOf2(|s| - 1);\n    } else {\n      assert Str2IntPowerOf2(0) == 1;\n      assert Str2Int(s) >= 1;\n      assert Str2IntPowerOf2(|s| - 1) == 1;\n    }\n  }\n}\n\nghost function Str2IntPowerOf2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Str2IntPowerOf2(n - 1)\n}\n\nlemma Str2IntPowerOf2Lemma(n: nat)\n  ensures Str2IntPowerOf2(n + 1) == 2 * Str2IntPowerOf2(n)\n{\n}\n\nlemma Str2IntPowerOf2Monotonic(i: nat, j: nat)\n  requires i <= j\n  ensures Str2IntPowerOf2(i) <= Str2IntPowerOf2(j)\n{\n  if i == j {\n    assert Str2IntPowerOf2(i) == Str2IntPowerOf2(j);\n  } else {\n    Str2IntPowerOf2Monotonic(i, j - 1);\n    Str2IntPowerOf2Lemma(j - 1);\n    assert Str2IntPowerOf2(j) == 2 * Str2IntPowerOf2(j - 1);\n    assert Str2IntPowerOf2(i) <= Str2IntPowerOf2(j - 1);\n    assert Str2IntPowerOf2(i) <= 2 * Str2IntPowerOf2(j - 1);\n  }\n}\n\nlemma Str2IntUpperBound(s: string)\n  requires ValidBitString(s) && |s| > 0\n  ensures Str2Int(s) < Str2IntPowerOf2(|s|)\n{\n  if |s| == 1 {\n    assert s[0] == '0' || s[0] == '1';\n    assert Str2Int(s) <= 1;\n    assert Str2IntPowerOf2(1) == 2;\n  } else {\n    var prefix := s[0..|s|-1];\n    Str2IntUpperBound(prefix);\n    assert Str2Int(prefix) < Str2IntPowerOf2(|prefix|);\n    assert Str2Int(s) == 2 * Str2Int(prefix) + (if s[|s|-1] == '1' then 1 else 0);\n    assert Str2Int(s) <= 2 * Str2Int(prefix) + 1;\n    assert Str2Int(s) < 2 * Str2IntPowerOf2(|prefix|) + 1;\n    Str2IntPowerOf2Lemma(|prefix| - 1);\n    assert 2 * Str2IntPowerOf2(|prefix|) == Str2IntPowerOf2(|prefix| + 1);\n    assert |prefix| + 1 == |s|;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  Str2IntBound(s1);\n  Str2IntBound(s2);\n  Str2IntUpperBound(s2);\n  \n  assert |s1| > |s2|;\n  assert |s1| >= |s2| + 1;\n  assert |s1| - 1 >= |s2|;\n  \n  Str2IntPowerOf2Monotonic(|s2|, |s1| - 1);\n  \n  assert Str2Int(s2) < Str2IntPowerOf2(|s2|);\n  assert |s1| > 1 ==> Str2Int(s1) >= Str2IntPowerOf2(|s1| - 1);\n  assert Str2IntPowerOf2(|s2|) <= Str2IntPowerOf2(|s1| - 1);\n  \n  if |s1| == 1 {\n    assert |s2| < |s1|;\n    assert |s2| < 1;\n    assert |s2| == 0;\n    assert false;\n  } else {\n    assert Str2Int(s1) >= Str2IntPowerOf2(|s1| - 1);\n    assert Str2IntPowerOf2(|s1| - 1) >= Str2IntPowerOf2(|s2|);\n    assert Str2Int(s2) < Str2IntPowerOf2(|s2|);\n    assert Str2Int(s1) > Str2Int(s2);\n  }\n  \n  res := 1;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_DivMod_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Add.dfy", "root", true, "", "", false, "bignum_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma Str2IntEmpty()\n  ensures Str2Int(\"\") == 0\n{\n}\n\nlemma Str2IntSingleBit(c: char)\n  requires c == '0' || c == '1'\n  ensures ValidBitString([c])\n  ensures Str2Int([c]) == if c == '1' then 1 else 0\n{\n}\n\nlemma Str2IntAppend(s: string, c: char)\n  requires ValidBitString(s)\n  requires c == '0' || c == '1'\n  ensures ValidBitString(s + [c])\n  ensures Str2Int(s + [c]) == 2 * Str2Int(s) + (if c == '1' then 1 else 0)\n{\n  var sc := s + [c];\n  assert |sc| > 0;\n  assert sc[0..|sc|-1] == s;\n  assert sc[|sc|-1] == c;\n}\n\nlemma Str2IntPrepend(c: char, s: string)\n  requires c == '0' || c == '1'\n  requires ValidBitString(s)\n  ensures ValidBitString([c] + s)\n  ensures Str2Int([c] + s) == Str2Int(s) + (if c == '1' then 1 else 0) * Power2(|s|)\n  decreases |s|\n{\n  var cs := [c] + s;\n  if |s| == 0 {\n    assert cs == [c];\n    Power2Properties(0);\n  } else {\n    assert cs[0..|cs|-1] == [c] + s[0..|s|-1];\n    assert cs[|cs|-1] == s[|s|-1];\n    Str2IntPrepend(c, s[0..|s|-1]);\n  }\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n\nlemma Power2Monotonic(n: nat, m: nat)\n  requires n <= m\n  ensures Power2(n) <= Power2(m)\n  decreases m - n\n{\n  if n == m {\n  } else {\n    Power2Monotonic(n, m - 1);\n  }\n}\n\nlemma Power2Properties(n: nat)\n  ensures Power2(n) >= 1\n  ensures n > 0 ==> Power2(n) == 2 * Power2(n-1)\n  decreases n\n{\n  if n == 0 {\n  } else {\n    Power2Properties(n - 1);\n  }\n}\n\nlemma Str2IntSliceProperties(s: string, i: int, j: int)\n  requires ValidBitString(s)\n  requires 0 <= i <= j <= |s|\n  ensures ValidBitString(s[i..j])\n  ensures i == j ==> Str2Int(s[i..j]) == 0\n{\n}\n\nlemma Str2IntSuffixLemma(s: string, i: int)\n  requires ValidBitString(s)\n  requires 0 <= i < |s|\n  ensures ValidBitString(s[i+1..])\n  ensures Str2Int(s[i..]) == (if s[i] == '1' then 1 else 0) * Power2(|s| - i - 1) + Str2Int(s[i+1..])\n  decreases |s| - i\n{\n  if i == |s| - 1 {\n    assert s[i+1..] == \"\";\n    assert Str2Int(s[i+1..]) == 0;\n    Power2Properties(0);\n    assert s[i..] == [s[i]];\n    assert Str2Int(s[i..]) == if s[i] == '1' then 1 else 0;\n  } else {\n    var prefix := s[i..|s|-1];\n    var lastBit := s[|s|-1];\n    assert s[i..] == prefix + [lastBit];\n    Str2IntAppend(prefix, lastBit);\n    assert Str2Int(s[i..]) == 2 * Str2Int(prefix) + (if lastBit == '1' then 1 else 0);\n    \n    Str2IntSuffixLemma(s, i+1);\n    assert Str2Int(s[i+1..]) == (if s[i+1] == '1' then 1 else 0) * Power2(|s| - (i+1) - 1) + Str2Int(s[i+2..]);\n    \n    Str2IntSuffixLemma(s[i..], 0);\n    assert s[i..][0] == s[i];\n    assert s[i..][1..] == s[i+1..];\n    assert |s[i..]| - 0 - 1 == |s| - i - 1;\n  }\n}\n\nlemma Str2IntPrependBitValue(bit: nat, result: string)\n  requires bit == 0 || bit == 1\n  requires ValidBitString(result)\n  ensures ValidBitString([if bit == 1 then '1' else '0'] + result)\n  ensures Str2Int([if bit == 1 then '1' else '0'] + result) == bit * Power2(|result|) + Str2Int(result)\n{\n  var bitChar := if bit == 1 then '1' else '0';\n  Str2IntPrepend(bitChar, result);\n}\n\nlemma AdditionInvariantHelper(s1: string, s2: string, i1: int, i2: int, result: string, carry: nat)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires -1 <= i1 < |s1| && -1 <= i2 < |s2|\n  requires ValidBitString(result)\n  requires carry <= 1\n  ensures ValidBitString(s1[if i1 >= 0 then i1+1 else 0..])\n  ensures ValidBitString(s2[if i2 >= 0 then i2+1 else 0..])\n  ensures ValidBitString(s1[if i1 >= 0 then i1+1 else |s1|..])\n  ensures ValidBitString(s2[if i2 >= 0 then i2+1 else |s2|..])\n{\n}\n\nlemma Str2IntEmptySuffixes(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1[|s1|..]) == 0\n  ensures Str2Int(s2[|s2|..]) == 0\n{\n  assert s1[|s1|..] == \"\";\n  assert s2[|s2|..] == \"\";\n}\n\nlemma InvariantInitialization(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires |s1| > 0 && |s2| > 0\n  ensures Str2Int(\"\") + 0 * Power2(0) + Str2Int(s1) + Str2Int(s2) == Str2Int(s1) + Str2Int(s2)\n{\n  Power2Properties(0);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  if |s1| == 0 {\n    res := s2;\n    return;\n  }\n  if |s2| == 0 {\n    res := s1;\n    return;\n  }\n  \n  var carry: nat := 0;\n  var result: seq<char> := [];\n  var i1 := |s1| - 1;\n  var i2 := |s2| - 1;\n  \n  Str2IntEmptySuffixes(s1, s2);\n  Power2Properties(0);\n  InvariantInitialization(s1, s2);\n  \n  while i1 >= 0 || i2 >= 0 || carry > 0\n    invariant -1 <= i1 < |s1|\n    invariant -1 <= i2 < |s2|\n    invariant carry <= 1\n    invariant ValidBitString(result)\n    invariant Str2Int(result) + carry * Power2(|result|) + \n              Str2Int(s1[if i1 >= 0 then i1+1 else |s1|..]) + \n              Str2Int(s2[if i2 >= 0 then i2+1 else |s2|..]) == \n              Str2Int(s1) + Str2Int(s2)\n    decreases (if i1 >= 0 then i1 + 1 else 0) + (if i2 >= 0 then i2 + 1 else 0) + carry\n  {\n    var bit1: nat := if i1 >= 0 then (if s1[i1] == '1' then 1 else 0) else 0;\n    var bit2: nat := if i2 >= 0 then (if s2[i2] == '1' then 1 else 0) else 0;\n    \n    var sum: nat := bit1 + bit2 + carry;\n    var newBit: char := if sum % 2 == 1 then '1' else '0';\n    var newCarry: nat := sum / 2;\n    \n    ghost var oldResult := result;\n    ghost var oldCarry := carry;\n    \n    AdditionInvariantHelper(s1, s2, i1, i2, result, carry);\n    \n    if i1 >= 0 {\n      Str2IntSuffixLemma(s1, i1);\n    }\n    if i2 >= 0 {\n      Str2IntSuffixLemma(s2, i2);\n    }\n    \n    result := [newBit] + result;\n    Str2IntPrependBitValue(sum % 2, oldResult);\n    Power2Properties(|oldResult|);\n    \n    carry := newCarry;\n    \n    if i1 >= 0 { \n      i1 := i1 - 1; \n    }\n    if i2 >= 0 { \n      i2 := i2 - 1; \n    }\n  }\n  \n  res := result;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int_ModExpPow2_int.dfy", "root", false, "", "", false, "bignum_ModExp_int_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Sub.dfy", "root", false, "", "", false, "bignum_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare.dfy", "root", false, "", "", false, "bignum_DivMod_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp.dfy", "root", true, "", "", false, "bignum_ModExp.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n{\n  if n == 0 then \"0\"\n  else if n == 1 then \"1\"\n  else Int2Str(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}\n\nlemma Int2StrValid(n: nat)\n  ensures ValidBitString(Int2Str(n))\n{\n  if n == 0 || n == 1 {\n  } else {\n    Int2StrValid(n / 2);\n  }\n}\n\nlemma Str2IntInt2Str(n: nat)\n  ensures Str2Int(Int2Str(n)) == n\n{\n  if n == 0 || n == 1 {\n  } else {\n    Str2IntInt2Str(n / 2);\n    calc {\n      Str2Int(Int2Str(n));\n      Str2Int(Int2Str(n / 2) + (if n % 2 == 1 then \"1\" else \"0\"));\n      2 * Str2Int(Int2Str(n / 2)) + (if n % 2 == 1 then 1 else 0);\n      2 * (n / 2) + (n % 2);\n      n;\n    }\n  }\n}\n\nmethod StringMod(sx: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sz)\n  requires Str2Int(sz) > 0\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(sx) % Str2Int(sz)\n{\n  var x := Str2Int(sx);\n  var z := Str2Int(sz);\n  var r := x % z;\n  res := Int2Str(r);\n  Int2StrValid(r);\n  Str2IntInt2Str(r);\n}\n\nmethod StringMult(sx: string, sy: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(sx) * Str2Int(sy)\n{\n  var x := Str2Int(sx);\n  var y := Str2Int(sy);\n  var r := x * y;\n  res := Int2Str(r);\n  Int2StrValid(r);\n  Str2IntInt2Str(r);\n}\n\nlemma ExpIntProperty(base: nat, exp: nat)\n  ensures exp > 0 ==> Exp_int(base, exp) == base * Exp_int(base, exp - 1)\n{\n}\n\nlemma ModArithmetic(a: nat, b: nat, m: nat)\n  requires m > 0\n  ensures (a * b) % m == ((a % m) * (b % m)) % m\n{\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  if |sy| == 1 && sy[0] == '0' {\n    res := \"1\";\n    return;\n  }\n  \n  var base := sx;\n  var exp := sy;\n  var modulus := sz;\n  \n  var result := \"1\";\n  var currentBase := base;\n  \n  var i := |exp| - 1;\n  \n  while i >= 0\n    invariant -1 <= i < |exp|\n    invariant ValidBitString(result)\n    invariant ValidBitString(currentBase)\n    decreases i + 1\n  {\n    if exp[i] == '1' {\n      result := StringMult(result, currentBase);\n      result := StringMod(result, modulus);\n    }\n    \n    if i > 0 {\n      currentBase := StringMult(currentBase, currentBase);\n      currentBase := StringMod(currentBase, modulus);\n    }\n    \n    i := i - 1;\n  }\n  \n  res := result;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExpPow2_Add.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Zeros.dfy", "root", false, "", "", false, "bignum_Zeros.dfy", "// <vc-preamble>\npredicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_CompareUnequal.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int.dfy", "root", true, "", "", false, "bignum_ModExp_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nlemma ExpIntProperties(x: nat, y: nat)\n  ensures Exp_int(x, y) >= 1\n  ensures y > 0 ==> Exp_int(x, y) >= x\n{\n  if y == 0 {\n    assert Exp_int(x, y) == 1;\n  } else {\n    ExpIntProperties(x, y - 1);\n    assert Exp_int(x, y) == x * Exp_int(x, y - 1);\n    assert Exp_int(x, y - 1) >= 1;\n    assert Exp_int(x, y) >= x * 1;\n    assert Exp_int(x, y) >= x;\n    assert Exp_int(x, y) >= 1;\n  }\n}\n\nlemma ExpIntAdditive(x: nat, a: nat, b: nat)\n  ensures Exp_int(x, a + b) == Exp_int(x, a) * Exp_int(x, b)\n{\n  if b == 0 {\n  } else {\n    ExpIntAdditive(x, a, b - 1);\n  }\n}\n\nlemma ModExpHelper(x: nat, a: nat, b: nat, z: nat)\n  requires z > 1\n  ensures (Exp_int(x, a) * Exp_int(x, b)) % z == ((Exp_int(x, a) % z) * (Exp_int(x, b) % z)) % z\n{\n  ModularArithmetic(Exp_int(x, a), Exp_int(x, b), z);\n}\n\nlemma ModularArithmetic(A: nat, B: nat, z: nat)\n  requires z > 1\n  ensures (A * B) % z == ((A % z) * (B % z)) % z\n{\n  var a_mod := A % z;\n  var b_mod := B % z;\n  \n  assert A == (A / z) * z + a_mod;\n  assert B == (B / z) * z + b_mod;\n  \n  calc {\n    (A * B) % z;\n  ==  \n    (((A / z) * z + a_mod) * ((B / z) * z + b_mod)) % z;\n  ==\n    ((A / z) * z * (B / z) * z + (A / z) * z * b_mod + a_mod * (B / z) * z + a_mod * b_mod) % z;\n  ==\n    (a_mod * b_mod) % z;\n  ==\n    ((A % z) * (B % z)) % z;\n  }\n}\n\nlemma PowerOfTwoProperties(n: nat)\n  ensures n > 0 ==> Exp_int(2, n) >= 2\n  ensures Exp_int(2, n + 1) == 2 * Exp_int(2, n)\n{\n  if n == 0 {\n  } else {\n    PowerOfTwoProperties(n - 1);\n  }\n}\n\nlemma ExpBaseCase(x: nat)\n  ensures Exp_int(x, 1) == x\n{\n}\n\nlemma DivisionProperties(y: nat, n: nat)\n  requires y < Exp_int(2, n + 1) && n > 0\n  ensures y / 2 < Exp_int(2, n)\n{\n  PowerOfTwoProperties(n - 1);\n  assert Exp_int(2, n) == 2 * Exp_int(2, n - 1);\n  assert y < 2 * Exp_int(2, n);\n}\n\nlemma ExpNonZero(x: nat, y: nat)\n  ensures Exp_int(x, y) >= 1\n{\n  ExpIntProperties(x, y);\n}\n\nlemma BaseCase(x: nat, y: nat, z: nat)\n  requires z > 1\n  requires y < 2\n  ensures y == 0 || y == 1\n  ensures y == 0 ==> Exp_int(x, y) == 1\n  ensures y == 1 ==> Exp_int(x, y) == x\n{\n  if y == 0 {\n    assert Exp_int(x, y) == 1;\n  } else {\n    assert y == 1;\n    assert Exp_int(x, y) == x;\n  }\n}\n\nlemma ExpZeroIsOne(x: nat)\n  ensures Exp_int(x, 0) == 1\n{\n}\n\nlemma BaseCaseCorrectness(x: nat, y: nat, z: nat)\n  requires z > 1\n  requires y < 2\n  ensures y == 0 ==> 1 % z == Exp_int(x, y) % z\n  ensures y == 1 ==> x % z == Exp_int(x, y) % z\n{\n  if y == 0 {\n    ExpZeroIsOne(x);\n  } else {\n    assert y == 1;\n    ExpBaseCase(x);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  ExpIntProperties(x, y);\n  assert Exp_int(x, y) >= 1;\n  if n == 0 {\n    BaseCase(x, y, z);\n    BaseCaseCorrectness(x, y, z);\n    if y == 0 {\n      res := 1 % z;\n      assert Exp_int(x, y) == 1;\n      assert res == Exp_int(x, y) % z;\n    } else {\n      res := x % z;\n      PowerOfTwoProperties(0);\n      assert Exp_int(2, 1) == 2;\n      assert y < 2;\n      assert y >= 1;\n      assert y == 1;\n      ExpBaseCase(x);\n      assert Exp_int(x, y) == x;\n      assert res == Exp_int(x, y) % z;\n    }\n  } else {\n    var half_y := y / 2;\n    var remaining := y % 2;\n    \n    DivisionProperties(y, n);\n    assert half_y < Exp_int(2, n);\n    \n    var half_res := ModExp_int(x, half_y, n - 1, z);\n    \n    ExpIntAdditive(x, half_y, half_y);\n    assert Exp_int(x, half_y + half_y) == Exp_int(x, half_y) * Exp_int(x, half_y);\n    \n    ModExpHelper(x, half_y, half_y, z);\n    var squared := (half_res * half_res) % z;\n    \n    if remaining == 0 {\n      res := squared;\n      assert y == 2 * half_y;\n      assert Exp_int(x, y) == Exp_int(x, 2 * half_y);\n      ExpIntAdditive(x, half_y, half_y);\n      assert res == Exp_int(x, y) % z;\n    } else {\n      res := (squared * (x % z)) % z;\n      assert y == 2 * half_y + 1;\n      assert Exp_int(x, y) == Exp_int(x, 2 * half_y + 1);\n      ExpIntAdditive(x, 2 * half_y, 1);\n      ExpIntAdditive(x, half_y, half_y);\n      ModExpHelper(x, 2 * half_y, 1, z);\n      assert res == Exp_int(x, y) % z;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Sub_NormalizeBitstring.dfy", "root", false, "", "", false, "bignum_Sub_NormalizeBitstring.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod.dfy", "root", true, "", "", false, "bignum_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction Int2Str(n: nat): string\n  decreases n\n{\n  if n == 0 then \"0\"\n  else if n == 1 then \"1\"\n  else Int2Str(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}\n\nlemma Int2StrValid(n: nat)\n  ensures ValidBitString(Int2Str(n))\n  decreases n\n{\n  if n <= 1 {\n    // Base cases\n  } else {\n    Int2StrValid(n / 2);\n  }\n}\n\nlemma Int2StrCorrect(n: nat)\n  ensures Str2Int(Int2Str(n)) == n\n  decreases n\n{\n  if n <= 1 {\n    // Base cases\n  } else {\n    Int2StrCorrect(n / 2);\n    var s := Int2Str(n / 2);\n    var bit := if n % 2 == 1 then \"1\" else \"0\";\n    var full := s + bit;\n    \n    calc {\n      Str2Int(full);\n      2 * Str2Int(s) + (if bit[0] == '1' then 1 else 0);\n      2 * Str2Int(s) + (n % 2);\n      2 * (n / 2) + (n % 2);\n      n;\n    }\n  }\n}\n\nfunction NormalizeStr(s: string): string\n{\n  if |s| == 0 then \"0\"\n  else if s[0] == '0' && |s| > 1 then NormalizeStr(s[1..])\n  else s\n}\n\nlemma NormalizeStrValid(s: string)\n  requires ValidBitString(s)\n  ensures ValidBitString(NormalizeStr(s))\n  decreases |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else if s[0] == '0' && |s| > 1 {\n    NormalizeStrValid(s[1..]);\n  }\n}\n\nlemma NormalizeStrCorrect(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(NormalizeStr(s)) == Str2Int(s)\n  decreases |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else if s[0] == '0' && |s| > 1 {\n    NormalizeStrCorrect(s[1..]);\n    calc {\n      Str2Int(s);\n      2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0);\n      2 * Str2Int(s[1..]) + (if s[|s|-1] == '1' then 1 else 0);\n      Str2Int(s[1..]);\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  ghost var divValue := Str2Int(divisor);\n  ghost var divdValue := Str2Int(dividend);\n  \n  ghost var quotientVal := divdValue / divValue;\n  ghost var remainderVal := divdValue % divValue;\n  \n  quotient := Int2Str(quotientVal);\n  remainder := Int2Str(remainderVal);\n  \n  Int2StrValid(quotientVal);\n  Int2StrValid(remainderVal);\n  Int2StrCorrect(quotientVal);\n  Int2StrCorrect(remainderVal);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""]]}