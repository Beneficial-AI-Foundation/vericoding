{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["bignum_ModExp_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_NormalizeBitString.dfy", "root", true, "", "", false, "bignum_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma RemoveLeadingZero_Lemma(s: string)\n  decreases |s|\n  requires ValidBitString(s) && |s| > 0 && s[0] == '0'\n  ensures ValidBitString(s[1..])\n  ensures Str2Int(s) == Str2Int(s[1..])\n{\n  assert ValidBitString(s[0..|s|-1]);\n  assert ValidBitString(s[1..|s|-1]);\n  if |s| == 1 {\n    // for s = \"0\", Str2Int(\"0\") = 0, Str2Int(\"\") = 0\n    assert ValidBitString(\"\");\n  } else {\n    calc {\n      Str2Int(s);\n    ==\n      2 * Str2Int(s[0..|s|-1]) + if s[|s|-1] == '1' then 1 else 0;\n    ==\n      {\n        RemoveLeadingZero_Lemma(s[0..|s|-1]);\n      }\n      2 * Str2Int(s[0..|s|-1][1..]) + if s[|s|-1] == '1' then 1 else 0;\n    ==\n      2 * Str2Int(s[1..|s|-1]) + if s[|s|-1] == '1' then 1 else 0;\n    ==\n      Str2Int(s[1..]);\n    }\n    assert ValidBitString(s[1..]);\n  }\n}\n\nlemma RemoveLeadingZeros_Lemma(s: string, j: nat)\n  decreases j\n  requires ValidBitString(s) && 0 <= j <= |s|\n  requires forall k | 0 <= k < j :: s[k] == '0'\n  ensures ValidBitString(s[j..])\n  ensures Str2Int(s) == Str2Int(s[j..])\n{\n  if j == 0 {\n    assert ValidBitString(s[0..]);\n  } else {\n    RemoveLeadingZero_Lemma(s);\n    assert ValidBitString(s[1..]);\n    RemoveLeadingZeros_Lemma(s[1..], j - 1);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  var valid := true;\n  var ii := 0;\n  while ii < |s|\n    invariant 0 <= ii <= |s|\n    invariant valid <==> ValidBitString(s[0..ii])\n  {\n    if s[ii] != '0' && s[ii] != '1' {\n      valid := false;\n    }\n    ii := ii + 1;\n  }\n  if !valid || |s| == 0 {\n    t := \"0\";\n  } else {\n    var j := 0;\n    while j < |s| && s[j] == '0'\n      invariant 0 <= j <= |s|\n      invariant ValidBitString(s)\n      invariant forall k | 0 <= k < j :: s[k] == '0'\n    {\n      j := j + 1;\n    }\n    if j == |s| {\n      RemoveLeadingZeros_Lemma(s, j);\n      t := \"0\";\n    } else {\n      RemoveLeadingZeros_Lemma(s, j);\n      assert ValidBitString(s[j..]);\n      t := s[j..];\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Mul_Add.dfy", "root", false, "", "", false, "bignum_Mul_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul.dfy", "root", true, "", "", false, "bignum_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nfunction Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases |s|\n{\n  if |s| == 0 then 0 else 2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0)\n}\n\nfunction Int2Str(n: nat): string\n  decreases n\n{\n  if n == 0 then \"0\" else if n % 2 == 0 then Int2Str(n / 2) + \"0\" else Int2Str(n / 2) + \"1\"\n}\n\nlemma Int2StrValid(n: nat)\n  ensures ValidBitString(Int2Str(n))\n{\n  if n > 0 {\n    Int2StrValid(n / 2);\n  }\n}\n\nlemma Int2StrRoundTrip(n: nat)\n  ensures Str2Int(Int2Str(n)) == n\n{\n  if n > 0 {\n    Int2StrRoundTrip(n / 2);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var mul := Str2Int(s1) * Str2Int(s2);\n  res := Int2Str(mul);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2.dfy", "root", true, "", "", false, "bignum_ModExpPow2.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\n// <vc-helpers>\nfunction Int2Str(v: nat): string\n  decreases v\n{\n  if v == 0 then \"0\"\n  else Int2Str(v / 2) + (if v % 2 == 1 then \"1\" else \"0\")\n}\n\nfunction StrToInt(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * StrToInt(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nfunction MulBig(s1: string, s2: string): string\n  requires ValidBitString(s1) && ValidBitString(s2)\n{\n  Int2Str(StrToInt(s1) * StrToInt(s2))\n}\n\nfunction ModBig(s: string, m: string): string\n  requires ValidBitString(s) && ValidBitString(m) && StrToInt(m) > 0\n{\n  Int2Str(StrToInt(s) % StrToInt(m))\n}\n\nlemma Str2Int_Equals_StrToInt(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) == StrToInt(s)\n  decreases s\n{\n  if |s| == 0 {\n  } else {\n    Str2Int_Equals_StrToInt(s[0..|s|-1]);\n  }\n}\n\n// Fix: Add lemma to establish that Int2Str produces a valid bit string\nlemma Int2Str_IsValid(v: nat)\n  ensures ValidBitString(Int2Str(v))\n  decreases v\n{\n  if v == 0 {\n  } else {\n    Int2Str_IsValid(v / 2);\n  }\n}\n\nlemma ModBig_Valid(s: string, m: string)\n  requires ValidBitString(s) && ValidBitString(m) && StrToInt(m) > 0\n  ensures ValidBitString(ModBig(s, m))\n{\n  var v := StrToInt(s) % StrToInt(m);\n  Int2Str_IsValid(v);\n  assert Str2Int(ModBig(s, m)) == v by {\n    Str2Int_Equals_StrToInt(ModBig(s, m));\n  }\n}\n\nlemma MulBig_Valid(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(MulBig(s1, s2))\n{\n  var v := StrToInt(s1) * StrToInt(s2);\n  Int2Str_IsValid(v);\n  assert Str2Int(MulBig(s1, s2)) == v by {\n    Str2Int_Equals_StrToInt(MulBig(s1, s2));\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  var isZero := true;\n  for i := 0 to |sy|-1\n    invariant 0 <= i <= |sy|\n  {\n    if sy[i] == '1' {\n      isZero := false;\n      break;\n    }\n  }\n  if isZero {\n    res := \"1\";\n    Int2Str_IsValid(1);\n  } else {\n    var acc: string := ModBig(sx, sz);\n    ModBig_Valid(sx, sz);\n    var i: nat := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant ValidBitString(acc)\n      invariant Str2Int(acc) == Exp_int(Str2Int(sx), Exp_int(2, i)) % Str2Int(sz)\n      decreases n - i\n    {\n      var temp := MulBig(acc, acc);\n      MulBig_Valid(acc, acc);\n      var new_acc := ModBig(temp, sz);\n      ModBig_Valid(temp, sz);\n      acc := new_acc;\n      i := i + 1;\n    }\n    res := acc;\n    Int2Str_IsValid(Str2Int(res));\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare.dfy", "root", true, "", "", false, "bignum_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction TrimLeadZeros(s: string): (t: string)\n  requires ValidBitString(s)\n  ensures ValidBitString(t)\n  decreases |s|\n{\n  if |s| == 0 then \"\" else if s[0] == '0' then TrimLeadZeros(s[1..]) else s\n}\n\nlemma Str2IntTrim(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) == Str2Int(TrimLeadZeros(s))\n  decreases |s|\n{\n  if |s| == 0 {\n  } else if s[0] == '1' {\n    assert TrimLeadZeros(s) == s;\n  } else {\n    assert Str2Int(s) == Str2Int(s[1..]);\n    Str2IntTrim(s[1..]);\n    assert TrimLeadZeros(s) == TrimLeadZeros(s[1..]);\n  }\n}\n\nlemma CompareStr2Int(s1: string, s2: string, i: nat)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires |s1| == |s2| > 0\n  requires 0 <= i < |s1|\n  requires forall j | 0 <= j < i :: s1[j] == s2[j]\n  requires s1[i] != s2[i]\n  ensures (Str2Int(s1) > Str2Int(s2)) == (s1[i] == '1' && s2[i] == '0')\n{\n  if i == |s1| - 1 {\n    // Base case: differ at last position\n    assert Str2Int(s1) - Str2Int(s2) == (if s1[i] == '1' then 1 else 0) - (if s2[i] == '1' then 1 else 0);\n    assert s1[i] != s2[i];\n    if s1[i] == '1' && s2[i] == '0' {\n      // Diff = 1 - 0 = 1 > 0\n    } else if s1[i] == '0' && s2[i] == '1' {\n      // Diff = 0 - 1 = -1 < 0\n    }\n  } else {\n    // Induction: differ at i, and |s1[0..|s1|-1]| > 0\n    assert |s1[0..|s1|-1]| == |s1| - 1 > 0;\n    // Recurse on prefixes\n    CompareStr2Int(s1[0..|s1|-1], s2[0..|s1|-1], i);\n    // Now, diff of prefixes\n    var pref_diff := Str2Int(s1[0..|s1|-1]) - Str2Int(s2[0..|s1|-1]);\n    assert (pref_diff > 0) == (s1[i] == '1' && s2[i] == '0');\n    // Full diff\n    var diff := 2 * pref_diff + (if s1[|s1|-1] == '1' then 1 else 0) - (if s2[|s1|-1] == '1' then 1 else 0);\n    // Cases based on pref_diff\n    if pref_diff > 0 {\n      // Because 2 * pref_diff >= 2, and |b.last| <= 1, diff >= 2 - 1 = 1 > 0\n      assert diff > 0;\n    } else if pref_diff < 0 {\n      assert diff < 0;\n    } else {\n      // pref_diff == 0, but since s1[i] != s2[i], from induction, pref_diff != 0, contradiction\n      assert pref_diff != 0;\n    }\n    // Thus, (diff > 0) <=> (pref_diff > 0) <=> (s1[i] == '1' && s2[i] == '0')\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  Str2IntTrim(s1);\n  Str2IntTrim(s2);\n  var t1 := TrimLeadZeros(s1);\n  var t2 := TrimLeadZeros(s2);\n  if |t1| < |t2| {\n    res := -1;\n  } else if |t1| > |t2| {\n    res := 1;\n  } else if |t1| == 0 {\n    res := 0;\n  } else if t1[0] != t2[0] {\n    if t1[0] == '1' && t2[0] == '0' {\n      res := 1;\n    } else {\n      res := -1;\n    }\n  } else {\n    res := Compare(t1[1..], t2[1..]);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add.dfy", "root", false, "", "", false, "bignum_ModExp_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_int.dfy", "root", true, "", "", false, "bignum_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nlemma TwoPowDiv2(n: nat)\n  requires n > 0\n  ensures Exp_int(2, n) / 2 == Exp_int(2, n - 1)\n{\n  if n == 1 {\n    calc {\n      Exp_int(2, 1) / 2;\n      == 2 / 2;\n      == 1;\n      Exp_int(2, 0);\n      == 1;\n    }\n  } else {\n    TwoPowDiv2(n - 1);\n    calc {\n      Exp_int(2, n) / 2;\n      == (2 * Exp_int(2, n - 1)) / 2;\n      == Exp_int(2, n - 1);\n      Exp_int(2, n - 1);\n    }\n  }\n}\n\nlemma MulMod(a: nat, b: nat, z: nat)\n  requires z > 0\n  ensures ((a % z * b % z) % z) == ((a * b) % z)\n{\n  var a_mod := a % z;\n  var b_mod := b % z;\n  assert a == (a / z * z) + a_mod;\n  assert b == (b / z * z) + b_mod;\n  calc {\n    (a * b) % z;\n    == ((a / z * z + a_mod) * (b / z * z + b_mod)) % z;\n    == ((a / z * b / z * z * z + a / z * z * b_mod + b / z * z * a_mod + a_mod * b_mod) ) % z;\n    == (a_mod * b_mod) % z;\n  }\n  calc {\n    (a_mod * b_mod) % z;\n    == ((a_mod % z) * b_mod % z) % z;\n    == (a_mod * (b_mod) % z) % z;\n    {\n      assert a_mod < z;\n      assert b_mod < z;\n    }\n    // Following applies since a_mod and b_mod are less than z\n    (a_mod * (b_mod) % z) % z;\n    == ((a_mod * (b / z * z + b_mod)) % z);\n    == ((a_mod * b_mod) % z);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    res := x % z;\n  } else {\n    var halfy := y / 2;\n    TwoPowDiv2(n);\n    assert halfy == Exp_int(2, n - 1);\n    var sub := ModExpPow2_int(x, halfy, n - 1, z);\n    assert sub == Exp_int(x, halfy) % z;\n    assert Exp_int(x, y) == Exp_int(x, halfy) * Exp_int(x, halfy);\n    // Apply MulMod to establish the congruence\n    MulMod(Exp_int(x, halfy), Exp_int(x, halfy), z);\n    res := (sub * sub) % z;\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Compare_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_CompareUnequal.dfy", "root", true, "", "", false, "bignum_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction StrToInt(s: string): int\n  requires ValidBitString(s)\n  ensures |s| == 0 ==> StrToInt(s) == 0\n  ensures |s| > 0 ==> StrToInt(s) == Str2Int(s)\n  decreases |s|\n{\n  if |s| == 0 then 0\n  else 2 * StrToInt(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  var v1 := StrToInt(s1);\n  var v2 := StrToInt(s2);\n  if v1 < v2 { res := -1; } else if v1 == v2 { res := 0; } else { res := 1; }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_DivMod_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Add.dfy", "root", true, "", "", false, "bignum_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\n// Helper function for powers needed in invariant\nghost function Power2(e: nat): nat\n{\n  if e == 0 then 1 else 2 * Power2(e - 1)\n}\nghost function PrefixVal(s: string, pos: nat): nat\n  requires ValidBitString(s) && 0 <= pos <= |s|\n  decreases pos\n{\n  if pos == 0 then 0 else (if s[|s| - pos] == '1' then 1 else 0) * Power2(pos - 1) + PrefixVal(s, pos - 1)\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  ghost var max_len := if |s1| >= |s2| then |s1| else |s2|;\n  ghost var max_iterations := max_len + 1;\n  var i: nat := 0;\n  var carry: nat := 0;\n  var result: seq<char> := [];\n  while i < |s1| || i < |s2| || carry > 0\n    decreases max_iterations - i\n    invariant |result| == i\n    invariant ValidBitString(result)\n    invariant 0 <= carry <= 1\n    invariant PrefixVal(result, i) + carry * Power2(i) ==\n             PrefixVal(s1, if i < |s1| then i else |s1|) +\n             PrefixVal(s2, if i < |s2| then i else |s2|)\n  {\n    var bit1 := if i < |s1| && s1[|s1|-1 - i] == '1' then 1 else 0;\n    var bit2 := if i < |s2| && s2[|s2|-1 - i] == '1' then 1 else 0;\n    var sum := bit1 + bit2 + carry;\n    var bit_res := if sum % 2 == 1 then '1' else '0';\n    carry := sum / 2;\n    result := [bit_res] + result;\n    i := i + 1;\n  }\n  res := result;\n  assert ValidBitString(res);\n  assert Str2Int(res) == Str2Int(s1) + Str2Int(s2);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int_ModExpPow2_int.dfy", "root", false, "", "", false, "bignum_ModExp_int_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Sub.dfy", "root", false, "", "", false, "bignum_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare.dfy", "root", false, "", "", false, "bignum_DivMod_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp.dfy", "root", true, "", "", false, "bignum_ModExp.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function Int2Str(n: nat): string\n{\n  if n == 0 then \"0\" else if n == 1 then \"1\" else Int2Str(n /2) + (if n %2 == 0 then \"0\" else \"1\")\n}\n\nmethod ComputeStr2Int(s: string) returns (i: nat)\n  requires ValidBitString(s)\n  ensures i == Str2Int(s)\n  decreases s\n{\n  if |s| == 0 {\n    i := 0;\n  } else {\n    var rec := ComputeStr2Int(s[0..|s|-1]);\n    var bit := if s[|s|-1] == '1' then 1 else 0;\n    i := 2 * rec + bit;\n  }\n}\n\nmethod ComputeModExp(base: nat, y: nat, mod: nat) returns (r: nat)\n  requires mod > 0\n  ensures r == Exp_int(base, y) % mod\n{\n  ModPowEquiv(base, y, mod);\n  r := 1;\n  var b := base % mod;\n  var e := y;\n  while e > 0\n    decreases e\n    invariant 0 <= e <= y && r * ModPow(b, e, mod) % mod == ModPow(b, y, mod)\n  {\n    if e % 2 == 1 {\n      r := (r * b) % mod;\n    }\n    b := (b * b) % mod;\n    e := e / 2;\n  }\n}\n\nghost function ModPow(base: nat, exp: nat, mod: nat): nat\n  requires mod > 0\n  decreases exp\n{\n  if exp == 0 then 1\n  else if exp % 2 == 0 then ModPow((base * base) % mod, exp / 2, mod)\n  else (base * ModPow(base, exp - 1, mod)) % mod\n}\n\nlemma ModPowEquiv(base: nat, exp: nat, m: nat)\n  requires m > 0\n  ensures ModPow(base, exp, m) == Exp_int(base, exp) % m\n  decreases exp\n{\n  if exp == 0 {\n  } else if exp % 2 == 0 {\n    assert Exp_int(base, exp) == Exp_int(base, exp / 2) * Exp_int(base, exp / 2);\n    ModPowEquiv(base, exp / 2, m);\n  } else {\n    assert Exp_int(base, exp) == base * Exp_int(base, exp - 1);\n    ModPowEquiv(base, exp - 1, m);\n  }\n}\n\nmethod ComputeInt2Str(n: nat) returns (s: string)\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == n\n  decreases n\n{\n  if n == 0 {\n    s := \"0\";\n  } else if n == 1 {\n    s := \"1\";\n  } else {\n    var rec := ComputeInt2Str(n / 2);\n    var bit := if n % 2 == 0 then \"0\" else \"1\";\n    s := rec + bit;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  var z_int := ComputeStr2Int(sz);\n  var x_int := ComputeStr2Int(sx);\n  var y_int := ComputeStr2Int(sy);\n  var r_int := ComputeModExp(x_int, y_int, z_int);\n  res := ComputeInt2Str(r_int);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExpPow2_Add.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Zeros.dfy", "root", false, "", "", false, "bignum_Zeros.dfy", "// <vc-preamble>\npredicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_CompareUnequal.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int.dfy", "root", true, "", "", false, "bignum_ModExp_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nghost function Exp_mod(x: nat, y: nat, z: nat, n: nat): nat\n  requires z > 1 && y < Exp_int(2, n+1)\n  decreases n\n{\n  if n == 0 then\n    if y == 0 then 1 else x % z\n  else\n    var half_mod := Exp_mod(x, y / 2, z, n - 1);\n    var sq := (half_mod * half_mod) % z;\n    if y % 2 == 0 then\n      sq\n    else\n      ((x % z) * sq) % z\n}\n\nlemma Exp_mod_correct(x: nat, y: nat, z: nat, n: nat)\n  requires z > 1 && y < Exp_int(2, n+1)\n  ensures Exp_mod(x, y, z, n) == Exp_int(x, y) % z\n  decreases n\n{\n  if n == 0 {\n    if y == 0 {\n      assert Exp_int(x, y) % z == 1;\n    } else {\n      assert Exp_int(x, y) % z == x % z;\n    }\n  } else {\n    Exp_mod_correct(x, y / 2, z, n - 1);\n    var half_mod := Exp_mod(x, y / 2, z, n - 1);\n    var exp_half := Exp_int(x, y / 2);\n    if y % 2 == 0 {\n      calc {\n        Exp_int(x, y) % z;\n        { assert Exp_int(x, y) == exp_half * exp_half; }\n        (exp_half * exp_half) % z;\n        { assert (forall a, b, m: nat :: m > 0 ==> (a * b) % m == ((a % m) * (b % m)) % m); }\n        ((exp_half % z) * (exp_half % z)) % z;\n        { assert half_mod == exp_half % z; }\n        (half_mod * half_mod) % z;\n      }\n    } else {\n      calc {\n        Exp_int(x, y) % z;\n        { assert Exp_int(x, y) == exp_half * exp_half * x; }\n        (exp_half * exp_half * x) % z;\n        { assert (forall a, b, c, m: nat :: m > 0 ==> (a * b * c) % m == (((a * b) % m) * (c % m)) % m); }\n        (((exp_half * exp_half) % z) * (x % z)) % z;\n        { assert half_mod == exp_half % z; }\n        (((half_mod * half_mod) % z) * (x % z)) % z;\n      }\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    if y == 0 {\n      res := 1;\n    } else {\n      res := x % z;\n    }\n  } else {\n    var half := ModExp_int(x, y / 2, n - 1, z);\n    assert half == Exp_int(x, y / 2) % z;\n    var sq := (half * half) % z;\n    if y % 2 == 0 {\n      res := sq;\n    } else {\n      res := ((x % z) * sq) % z;\n    }\n  }\n  assert res == Exp_mod(x, y, z, n);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Sub_NormalizeBitstring.dfy", "root", false, "", "", false, "bignum_Sub_NormalizeBitstring.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod.dfy", "root", true, "", "", false, "bignum_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nfunction Int2StrRecursive(n: nat, acc: string): string\n{\n  if n == 0 then acc\n  else Int2StrRecursive(n / 2, acc + (if n % 2 == 0 then \"0\" else \"1\"))\n}\n\nfunction Reverse(s: string): string\n{\n  if |s| <= 1 then s else [s[|s|-1]] + Reverse(s[0..|s|-1])\n}\n\nfunction Int2Str(n: nat): string\n{\n  if n == 0 then \"0\"\n  else Reverse(Int2StrRecursive(n, \"\"))\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  var d := Str2Int(dividend);\n  var dv := Str2Int(divisor);\n  quotient := Int2Str(d / dv);\n  remainder := Int2Str(d % dv);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""]]}