{"columns": ["file_name", "subfolder", "success", "output_file", "error_message", "has_bypass", "file_path", "original_spec", "final_output", "debug_files", "generate_prompt", "fix_prompts"], "data": [["bignum_ModExp_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_NormalizeBitString.dfy", "root", true, "", "", false, "bignum_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction pow2(k: nat): nat\n  decreases k\n{\n  if k == 0 then 1 else 2 * pow2(k - 1)\n}\n\nlemma Pow2Succ(k: nat)\n  ensures pow2(k + 1) == 2 * pow2(k)\n{\n  if k == 0 {\n    assert pow2(1) == 2;\n    assert pow2(0) == 1;\n  } else {\n    assert pow2(k + 1) == 2 * pow2(k);\n  }\n}\n\nlemma RemoveSingleLast(x: string, tail: string)\n  requires |tail| == 1\n  ensures (x + tail)[0..|x + tail| - 1] == x\n{\n  assert |x + tail| == |x| + 1;\n  assert |x + tail| - 1 == |x|;\n  assert (x + tail)[0..|x|] == x;\n}\n\nlemma SubstringValid(s: string, lo: int, hi: int)\n  requires ValidBitString(s)\n  requires 0 <= lo <= hi <= |s|\n  ensures ValidBitString(s[lo..hi])\n{\n  var sub := s[lo..hi];\n  assert |sub| == hi - lo;\n  // sub[i] corresponds to s[lo + i], and s has only '0'/'1'\n  assert forall i {:trigger sub[i]} | 0 <= i < |sub| :: sub[i] == s[lo + i];\n  assert forall i {:trigger s[lo + i]} | 0 <= i < |sub| :: s[lo + i] == '0' || s[lo + i] == '1';\n}\n\nlemma ValidConcat(x: string, y: string)\n  requires ValidBitString(x) && ValidBitString(y)\n  ensures ValidBitString(x + y)\n{\n  var xy := x + y;\n  assert |xy| == |x| + |y|;\n  assert forall i {:trigger xy[i]} | 0 <= i < |xy| ::\n    if i < |x| then xy[i] == x[i] && (x[i] == '0' || x[i] == '1')\n    else xy[i] == y[i - |x|] && (y[i - |x|] == '0' || y[i - |x|] == '1');\n}\n\nlemma Str2IntSnoc(x: string, last: string)\n  requires ValidBitString(x) && ValidBitString(last) && |last| == 1\n  ensures Str2Int(x + last) == 2 * Str2Int(x) + (if last[0] == '1' then 1 else 0)\n{\n  // (x + last) has last char last[0] and prefix x\n  assert |x + last| == |x| + 1;\n  RemoveSingleLast(x, last);\n  assert (x + last)[0..|x|] == x;\n  assert (x + last)[|x + last| - 1] == last[0];\n  // unfold Str2Int on x + last\n  assert Str2Int(x + last) == 2 * Str2Int((x + last)[0..|x + last| - 1]) + (if (x + last)[|x + last| - 1] == '1' then 1 else 0);\n  assert Str2Int(x + last) == 2 * Str2Int(x) + (if last[0] == '1' then 1 else 0);\n}\n\nlemma Str2IntConcat(a: string, b: string)\n  requires ValidBitString(a) && ValidBitString(b)\n  ensures Str2Int(a + b) == pow2(|b|) * Str2Int(a) + Str2Int(b)\n  decreases |b|\n{\n  if |b| == 0 {\n    assert a + b == a;\n    assert Str2Int(a + b) == Str2Int(a);\n    assert pow2(0) * Str2Int(a) + Str2Int(b) == Str2Int(a);\n  } else {\n    var bpref := b[0..|b| - 1];\n    var last := b[|b| - 1 .. |b|];\n    assert b == bpref + last;\n    // show substrings and concatenations are valid\n    SubstringValid(b, 0, |b| - 1);\n    SubstringValid(b, |b| - 1, |b|);\n    ValidConcat(a, bpref);\n    // Use snoc lemma on a+bpref and on bpref\n    Str2IntSnoc(a + bpref, last);\n    Str2IntConcat(a, bpref);\n    Str2IntSnoc(bpref, last);\n    // assemble equalities\n    assert Str2Int(a + b) == 2 * Str2Int(a + bpref) + (if last[0] == '1' then 1 else 0);\n    assert Str2Int(b) == 2 * Str2Int(bpref) + (if last[0] == '1' then 1 else 0);\n    assert Str2Int(a + bpref) == pow2(|bpref|) * Str2Int(a) + Str2Int(bpref);\n    // relate pow2 lengths\n    assert |b| == |bpref| + 1;\n    Pow2Succ(|bpref|);\n    assert pow2(|b|) == 2 * pow2(|bpref|);\n    // combine algebraically\n    assert Str2Int(a + b)\n           == 2 * (pow2(|bpref|) * Str2Int(a) + Str2Int(bpref)) + (if last[0] == '1' then 1 else 0);\n    assert Str2Int(a + b)\n           == (2 * pow2(|bpref|)) * Str2Int(a) + (2 * Str2Int(bpref) + (if last[0] == '1' then 1 else 0));\n    assert 2 * Str2Int(bpref) + (if last[0] == '1' then 1 else 0) == Str2Int(b);\n    assert Str2Int(a + b) == pow2(|b|) * Str2Int(a) + Str2Int(b);\n  }\n}\n\nlemma RemoveLeadingZero(x: string)\n  requires ValidBitString(x)\n  ensures Str2Int(\"0\" + x) == Str2Int(x)\n  decreases |x|\n{\n  Str2IntConcat(\"0\", x);\n  assert Str2Int(\"\") == 0;\n  assert Str2Int(\"0\") == 2 * Str2Int(\"\") + (if \"0\"[0] == '1' then 1 else 0);\n  assert Str2Int(\"0\") == 0;\n  assert pow2(|x|) * Str2Int(\"0\") == 0;\n  assert Str2Int(\"0\" + x) == pow2(|x|) * Str2Int(\"0\") + Str2Int(x);\n  assert Str2Int(\"0\" + x) == Str2Int(x);\n}\n\nlemma RemoveLeadingZerosN(s: string, i: nat)\n  requires ValidBitString(s)\n  requires 0 <= i <= |s|\n  requires forall k | 0 <= k < i :: s[k] == '0'\n  ensures Str2Int(s) == (if i == |s| then 0 else Str2Int(s[i..|s|]))\n  decreases i\n{\n  if i == 0 {\n    if |s| == 0 {\n      assert Str2Int(s) == 0;\n    } else {\n      // s[0..|s|] == s and thus RHS simplifies to Str2Int(s)\n      assert s[0..|s|] == s;\n      assert Str2Int(s) == Str2Int(s[0..|s|]);\n    }\n  } else {\n    var s1 := s[1..|s|];\n    var a := s[0..1];\n    assert s == a + s1;\n    assert |a| == 1;\n    assert a[0] == '0';\n    assert ValidBitString(a);\n    // Str2Int(a) == 0\n    assert Str2Int(\"\") == 0;\n    assert Str2Int(a) == 2 * Str2Int(\"\") + (if a[0] == '1' then 1 else 0);\n    assert Str2Int(a) == 0;\n    // Use concat lemma to reduce Str2Int(s) to Str2Int(s1)\n    Str2IntConcat(a, s1);\n    assert Str2Int(s) == pow2(|s1|) * Str2Int(a) + Str2Int(s1);\n    assert pow2(|s1|) * Str2Int(a) == 0;\n    assert Str2Int(s) == Str2Int(s1);\n    // apply induction on s1 with i-1\n    RemoveLeadingZerosN(s1, i - 1);\n    assert Str2Int(s1) == (if i - 1 == |s1| then 0 else Str2Int(s1[(i - 1)..|s1|]));\n    assert |s1| == |s| - 1;\n    if i - 1 == |s1| {\n      assert i == |s|;\n      assert Str2Int(s) == 0;\n    } else {\n      assert s1[(i - 1)..|s1|] == s[i..|s|];\n      assert Str2Int(s1) == Str2Int(s[i..|s|]);\n      assert Str2Int(s) == Str2Int(s[i..|s|]);\n    }\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n// </vc-spec>\n// <vc-code>\n{\n  // If input not a valid bit string, return \"0\" (arbitrary valid output)\n  if !ValidBitString(s) {\n    t := \"0\";\n    return;\n  }\n\n  if |s| == 0 {\n    t := \"0\";\n    return;\n  }\n\n  // find first index i with s[i] == '1', or i == |s|\n  var i := 0;\n  while i < |s| && s[i] == '0'\n    decreases |s| - i\n    invariant 0 <= i <= |s|\n    invariant forall k | 0 <= k < i :: s[k] == '0'\n  {\n    i := i + 1;\n  }\n\n  if i == |s| {\n    // all zeros -> normalized to \"0\"\n    t := \"0\";\n    // prove the numeric equality when s is valid\n    RemoveLeadingZerosN(s, i);\n    // Str2Int(\"0\") == 0 holds by direct expansion\n    assert Str2Int(\"\") == 0;\n    assert Str2Int(\"0\") == 2 * Str2Int(\"\") + (if \"0\"[0] == '1' then 1 else 0);\n    assert Str2Int(\"0\") == 0;\n    assert Str2Int(s) == 0;\n    assert Str2Int(t) == 0;\n  } else {\n    // there is a leading '1' at position i\n    t := s[i..|s|];\n    // t is non-empty substring of a valid bitstring, hence valid\n    assert |t| > 0;\n    assert ValidBitString(t);\n    // first char of t is '1' (loop exits when s[i] != '0', and ValidBitString implies it's '1')\n    assert s[i] != '0';\n    assert s[i] == '1';\n    assert t[0] == '1';\n    // Now relate numeric values\n    RemoveLeadingZerosN(s, i);\n    assert Str2Int(s) == (if i == |s| then 0 else Str2Int(s[i..|s|]));\n    assert Str2Int(s) == Str2Int(t);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Mul_Add.dfy", "root", false, "", "", false, "bignum_Mul_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul.dfy", "root", true, "", "", false, "bignum_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction BinOf(n: nat): string\n  decreases n\n{\n  if n == 0 then \"\" else BinOf(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}\n\nlemma BinOf_Valid(n: nat)\n  ensures ValidBitString(BinOf(n))\n  decreases n\n{\n  if n == 0 {\n  } else {\n    var q := n / 2;\n    var r := n % 2;\n    BinOf_Valid(q);\n    var tail := if r == 1 then \"1\" else \"0\";\n    var s := BinOf(q) + tail;\n    assert |s| == |BinOf(q)| + 1;\n    forall i | 0 <= i < |s|\n    {\n      if i < |BinOf(q)| {\n        assert s[i] == BinOf(q)[i];\n        reveal ValidBitString(BinOf(q));\n        assert BinOf(q)[i] == '0' || BinOf(q)[i] == '1';\n      } else {\n        assert s[i] == tail[0];\n        if r == 1 {\n          assert tail[0] == '1';\n        } else {\n          assert tail[0] == '0';\n        }\n        assert s[i] == '0' || s[i] == '1';\n      }\n    }\n  }\n}\n\nlemma Str2Int_Push(s: string, i: int)\n  requires ValidBitString(s)\n  requires 0 <= i < |s|\n  ensures Str2Int(s[0..i+1]) == 2 * Str2Int(s[0..i]) + (if s[i] == '1' then 1 else 0)\n  decreases i\n{\n  var t := s[0..i+1];\n  // t has length > 0 because i >= 0\n  assert |t| > 0;\n  // By definition of Str2Int on non-empty string\n  assert Str2Int(t) == 2 * Str2Int(t[0..|t|-1]) + (if t[|t|-1] == '1' then 1 else 0);\n  // Relate slices\n  assert t[0..|t|-1] == s[0..i];\n  assert t[|t|-1] == s[i];\n  assert (if t[|t|-1] == '1' then 1 else 0) == (if s[i] == '1' then 1 else 0);\n  assert Str2Int(t[0..|t|-1]) == Str2Int(s[0..i]);\n  // Conclude\n  assert Str2Int(s[0..i+1]) == 2 * Str2Int(s[0..i]) + (if s[i] == '1' then 1 else 0);\n}\n\nlemma EvenDecomp(n: nat)\n  ensures 2 * (n / 2) + (n % 2) == n\n  decreases n\n{\n  var q := n / 2;\n  var r := n % 2;\n  assert 2 * q + r == n;\n}\n\nlemma BinOf_Str2Int(n: nat)\n  ensures Str2Int(BinOf(n)) == n\n  decreases n\n{\n  if n == 0 {\n  } else {\n    var q := n / 2;\n    var r := n % 2;\n    BinOf_Str2Int(q);\n    BinOf_Valid(q);\n    var tail := if r == 1 then \"1\" else \"0\";\n    var s := BinOf(q) + tail;\n    assert |s| == |BinOf(q)| + 1;\n    var i := |BinOf(q)|;\n    assert 0 <= i < |s|;\n    if r == 1 {\n      assert s[i] == '1';\n    } else {\n      assert s[i] == '0';\n    }\n    Str2Int_Push(s, i);\n    assert s[0..i] == BinOf(q);\n    assert s[0..i+1] == s;\n    assert Str2Int(s) == 2 * Str2Int(BinOf(q)) + (if s[i] == '1' then 1 else 0);\n    assert Str2Int(s) == 2 * Str2Int(BinOf(q)) + r;\n    EvenDecomp(n);\n    assert 2 * q + r == n;\n    assert Str2Int(s) == n;\n  }\n}\n\nmethod IntOf(s: string) returns (n: nat)\n  requires ValidBitString(s)\n  ensures n == Str2Int(s)\n{\n  n := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant n == Str2Int(s[0..i])\n  {\n    n := 2 * n + (if s[i] == '1' then 1 else 0);\n    i := i + 1;\n  }\n}\n\nmethod NatToBin(n: nat) returns (s: string)\n  ensures s == BinOf(n)\n  decreases n\n{\n  if n == 0 {\n    s := \"\";\n  } else {\n    var q := n / 2;\n    var r := n % 2;\n    var prefix := NatToBin(q);\n    s := prefix + (if r == 1 then \"1\" else \"0\");\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var n1 := IntOf(s1);\n  var n2 := IntOf(s2);\n  var p := n1 * n2;\n  res := NatToBin(p);\n  ghost {\n    assert n1 == Str2Int(s1);\n    assert n2 == Str2Int(s2);\n    assert p == n1 * n2;\n    BinOf_Str2Int(p);\n    assert Str2Int(res) == p;\n    assert Str2Int(res) == Str2Int(s1) * Str2Int(s2);\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2.dfy", "root", true, "", "", false, "bignum_ModExpPow2.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\n// <vc-helpers>\nghost function Int2Str(v: nat): string\n  decreases v\n{\n  if v == 0 then \"\" else Int2Str(v / 2) + (if v % 2 == 1 then \"1\" else \"0\")\n}\n\nlemma Int2Str_props(v: nat)\n  ensures ValidBitString(Int2Str(v))\n  ensures Str2Int(Int2Str(v)) == v\n  decreases v\n{\n  if v == 0 {\n    assert Int2Str(v) == \"\";\n    assert ValidBitString(Int2Str(v));\n    assert Str2Int(Int2Str(v)) == 0;\n  } else {\n    Int2Str_props(v / 2);\n    var p := Int2Str(v / 2);\n    var c := (if v % 2 == 1 then \"1\" else \"0\");\n    var s := p + c;\n    assert Int2Str(v) == s;\n    // Prove ValidBitString(s)\n    assert forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1' by {\n      if i < |p| {\n        assert s[i] == p[i];\n        assert p[i] == '0' || p[i] == '1';\n      } else {\n        assert i == |p|;\n        assert s[i] == c[0];\n        if v % 2 == 1 {\n          assert c[0] == '1';\n        } else {\n          assert c[0] == '0';\n        }\n      }\n    }\n    assert ValidBitString(s);\n    // Prove Str2Int(s) == v\n    assert Str2Int(p) == v / 2;\n    assert Str2Int(s) == 2 * Str2Int(p) + (if s[|s|-1] == '1' then 1 else 0);\n    if v % 2 == 1 {\n      assert s[|s|-1] == '1';\n      assert Str2Int(s) == 2 * (v / 2) + 1;\n    } else {\n      assert s[|s|-1] == '0';\n      assert Str2Int(s) == 2 * (v / 2) + 0;\n    }\n    assert 2 * (v / 2) + (if v % 2 == 1 then 1 else 0) == v;\n    assert Str2Int(s) == v;\n  }\n}\n\nghost lemma Mod_mul_mod(a: nat, m: nat)\n  requires m > 0\n  ensures (a % m * a % m) % m == (a * a) % m\n{\n  var qx := a / m;\n  var rx := a % m;\n  var qy := qx;\n  var ry := rx;\n  assert a == qx * m + rx;\n  assert a == qy * m + ry;\n  assert a * a == (qx * m + rx) * (qy * m + ry);\n  assert a * a == qx * qy * m * m + qx * m * ry + qy * m * rx + rx * ry;\n  assert a * a == m * (qx * qy * m + qx * ry + qy * rx) + rx * ry;\n  assert (a * a) % m == (rx * ry) % m;\n  assert rx == a % m;\n  assert ry == a % m;\n  assert (rx * ry) % m == (a % m * a % m) % m;\n}\n\nghost lemma Exp_int_mul(x: nat, y1: nat, y2: nat)\n  decreases y2\n  ensures Exp_int(x, y1) * Exp_int(x, y2) == Exp_int(x, y1 + y2)\n{\n  if y2 == 0 {\n    assert Exp_int(x, y2) == 1;\n    assert Exp_int(x, y1) * Exp_int(x, y2) == Exp_int(x, y1);\n    assert Exp_int(x, y1 + 0) == Exp_int(x, y1);\n  } else {\n    Exp_int_mul(x, y1, y2 - 1);\n    assert Exp_int(x, y2) == x * Exp_int(x, y2 - 1);\n    // by IH: Exp_int(x,y1) * Exp_int(x,y2-1) == Exp_int(x, y1 + y2 - 1)\n    assert Exp_int(x, y1) * Exp_int(x, y2) == x * (Exp_int(x, y1) * Exp_int(x, y2 - 1));\n    assert Exp_int(x, y1) * Exp_int(x, y2 - 1) == Exp_int(x, y1 + y2 - 1);\n    assert x * Exp_int(x, y1 + y2 - 1) == Exp_int(x, y1 + y2);\n  }\n}\n\nghost lemma Exp2_succ(k: nat)\n  ensures Exp_int(2, k) + Exp_int(2, k) == Exp_int(2, k + 1)\n{\n  assert Exp_int(2, k + 1) == 2 * Exp_int(2, k);\n  assert 2 * Exp_int(2, k) == Exp_int(2, k) + Exp_int(2, k);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  var m := Str2Int(sz);\n  var e := Str2Int(sy);\n  if e == 0 {\n    res := Int2Str(1 % m);\n    Int2Str_props(1 % m);\n    return;\n  }\n  assert e == Exp_int(2, n);\n  var r := Str2Int(sx) % m;\n  var i := 0;\n  assert r == Exp_int(Str2Int(sx), Exp_int(2, 0)) % m;\n  while i < n\n    invariant 0 <= i <= n\n    invariant r < m\n    invariant r == Exp_int(Str2Int(sx), Exp_int(2, i)) % m\n    decreases n - i\n  {\n    var oldi := i;\n    var oldr := r;\n    var base := Str2Int(sx);\n    var t := Exp_int(2, oldi);\n    var a := Exp_int(base, t);\n    assert oldr == a % m;\n    r := (r * r) % m;\n    assert r == (oldr * oldr) % m;\n    Mod_mul_mod(a, m);\n    assert r == (a * a) % m;\n    Exp_int_mul(base, t, t);\n    assert (a * a) % m == Exp_int(base, t + t) % m;\n    Exp2_succ(oldi);\n    assert t + t == Exp_int(2, oldi + 1);\n    assert r == Exp_int(base, Exp_int(2, oldi + 1)) % m;\n    i := i + 1;\n  }\n  res := Int2Str(r);\n  Int2Str_props(r);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Mul_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Mul_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare.dfy", "root", true, "", "", false, "bignum_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function pow2(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nlemma Str2Int_sum(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) == (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0)\n  decreases |s|\n{\n  if |s| == 0 {\n  } else {\n    var prefix := s[0..|s|-1];\n    var last := s[|s|-1];\n    Str2Int_sum(prefix);\n    calc {\n      Str2Int(s);\n      == { }\n      2 * Str2Int(prefix) + (if last == '1' then 1 else 0);\n      == { assert Str2Int(prefix) == (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|prefix| - 1 - i) else 0); }\n      2 * (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|prefix| - 1 - i) else 0) + (if last == '1' then 1 else 0);\n      == { }\n      (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then 2 * pow2(|prefix| - 1 - i) else 0) + (if last == '1' then 1 else 0);\n      == { }\n      (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|s| - 1 - i) else 0) + (if last == '1' then pow2(0) else 0);\n      == { }\n      (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0);\n    }\n  }\n}\n\nlemma SumPow_identity(n: nat)\n  ensures (sum k | 0 <= k < n :: pow2(k)) == pow2(n) - 1\n  decreases n\n{\n  if n == 0 {\n    assert (sum k | 0 <= k < 0 :: pow2(k)) == 0;\n    assert pow2(0) - 1 == 0;\n  } else {\n    SumPow_identity(n - 1);\n    calc {\n      (sum k | 0 <= k < n :: pow2(k));\n      == { }\n      (sum k | 0 <= k < n - 1 :: pow2(k)) + pow2(n - 1);\n      == { assert (sum k | 0 <= k < n - 1 :: pow2(k)) == pow2(n - 1) - 1; }\n      (pow2(n - 1) - 1) + pow2(n - 1);\n      == { }\n      2 * pow2(n - 1) - 1;\n      == { assert pow2(n) == 2 * pow2(n - 1); }\n      pow2(n) - 1;\n    }\n  }\n}\n\nlemma Str2Int_upper_bound(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) <= pow2(|s|) - 1\n  decreases |s|\n{\n  Str2Int_sum(s);\n  if |s| == 0 {\n    assert Str2Int(s) == 0;\n    assert pow2(0) - 1 == 0;\n  } else {\n    // Each bit contribution <= corresponding pow2, so sum <= sum pow2\n    assert (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0) <= (sum i | 0 <= i < |s| :: pow2(|s| - 1 - i));\n    assert (sum i | 0 <= i < |s| :: pow2(|s\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\nghost function pow2(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nlemma Str2Int_sum(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) == (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0)\n  decreases |s|\n{\n  if |s| == 0 {\n  } else {\n    var prefix := s[0..|s|-1];\n    var last := s[|s|-1];\n    Str2Int_sum(prefix);\n    calc {\n      Str2Int(s);\n      == { }\n      2 * Str2Int(prefix) + (if last == '1' then 1 else 0);\n      == { assert Str2Int(prefix) == (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|prefix| - 1 - i) else 0); }\n      2 * (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|prefix| - 1 - i) else 0) + (if last == '1' then 1 else 0);\n      == { }\n      (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then 2 * pow2(|prefix| - 1 - i) else 0) + (if last == '1' then 1 else 0);\n      == { }\n      (sum i | 0 <= i < |prefix| :: if prefix[i] == '1' then pow2(|s| - 1 - i) else 0) + (if last == '1' then pow2(0) else 0);\n      == { }\n      (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0);\n    }\n  }\n}\n\nlemma SumPow_identity(n: nat)\n  ensures (sum k | 0 <= k < n :: pow2(k)) == pow2(n) - 1\n  decreases n\n{\n  if n == 0 {\n    assert (sum k | 0 <= k < 0 :: pow2(k)) == 0;\n    assert pow2(0) - 1 == 0;\n  } else {\n    SumPow_identity(n - 1);\n    calc {\n      (sum k | 0 <= k < n :: pow2(k));\n      == { }\n      (sum k | 0 <= k < n - 1 :: pow2(k)) + pow2(n - 1);\n      == { assert (sum k | 0 <= k < n - 1 :: pow2(k)) == pow2(n - 1) - 1; }\n      (pow2(n - 1) - 1) + pow2(n - 1);\n      == { }\n      2 * pow2(n - 1) - 1;\n      == { assert pow2(n) == 2 * pow2(n - 1); }\n      pow2(n) - 1;\n    }\n  }\n}\n\nlemma Str2Int_upper_bound(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) <= pow2(|s|) - 1\n  decreases |s|\n{\n  Str2Int_sum(s);\n  if |s| == 0 {\n    assert Str2Int(s) == 0;\n    assert pow2(0) - 1 == 0;\n  } else {\n    // Each bit contribution <= corresponding pow2, so sum <= sum pow2\n    assert (sum i | 0 <= i < |s| :: if s[i] == '1' then pow2(|s| - 1 - i) else 0) <= (sum i | 0 <= i < |s| :: pow2(|s| - 1 - i));\n    assert (sum i | 0 <= i < |s| :: pow2(|s\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add.dfy", "root", false, "", "", false, "bignum_ModExp_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_DivMod.dfy", "root", false, "", "", false, "bignum_ModExpPow2_DivMod.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_int.dfy", "root", true, "", "", false, "bignum_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nlemma Exp_add(a:nat, b:nat, c:nat)\n  ensures Exp_int(a, b + c) == Exp_int(a, b) * Exp_int(a, c)\n  decreases c\n{\n  if c == 0 {\n    assert Exp_int(a, b + 0) == Exp_int(a, b);\n    assert Exp_int(a, b) * Exp_int(a, 0) == Exp_int(a, b) * 1;\n    assert Exp_int(a, b) * 1 == Exp_int(a, b);\n  } else {\n    Exp_add(a, b, c - 1);\n    assert Exp_int(a, b + c) == a * Exp_int(a, b + c - 1);\n    assert Exp_int(a, c) == a * Exp_int(a, c - 1);\n    assert Exp_int(a, b + c - 1) == Exp_int(a, b) * Exp_int(a, c - 1);\n    calc {\n      Exp_int(a, b + c);\n      == { }\n      a * Exp_int(a, b + c - 1);\n      == { }\n      a * (Exp_int(a, b) * Exp_int(a, c - 1));\n      == { }\n      Exp_int(a, b) * (a * Exp_int(a, c - 1));\n      == { }\n      Exp_int(a, b) * Exp_int(a, c);\n    }\n  }\n}\n\nlemma Exp2_dbl(i: nat)\n  ensures Exp_int(2, i+1) == Exp_int(2, i) + Exp_int(2, i)\n  decreases i\n{\n  assert Exp_int(2, i+1) == 2 * Exp_int(2, i);\n  assert 2 * Exp_int(2, i) == Exp_int(2, i) + Exp_int(2, i);\n}\n\nlemma Mul_mod_zero(m: nat, t: nat)\n  requires m > 0\n  ensures (m * t) % m == 0\n{\n  var q := (m * t) / m;\n  var r := (m * t) % m;\n  assert m * t == m * q + r;\n  assert r < m;\n  assert m * (t - q) == r by {\n    calc {\n      m * (t - q);\n      == { }\n      m * t - m * q;\n      == { }\n      r;\n    }\n  }\n  if t - q > 0 {\n    assert m * (t - q) >= m by {\n      assert m * (t - q) >= m * 1;\n      assert m * 1 == m;\n    }\n    assert r >= m by {\n      calc {\n        r;\n        == { }\n        m * (t - q);\n        >= { }\n        m;\n      }\n    }\n    assert false;\n  }\n  assert t - q == 0;\n  assert r == 0;\n}\n\nlemma Add_mod(a: nat, b: nat, m: nat)\n  requires m > 0\n  ensures (a + b) % m == ((a % m) + (b % m)) % m\n{\n  var qa := a / m; var ra := a % m;\n  var qb := b / m; var rb := b % m;\n  assert a == m * qa + ra;\n  assert b == m * qb + rb;\n  var s := (ra + rb) / m;\n  assert ra + rb == m * s + ((ra + rb) % m);\n  assert a + b == m * (qa + qb + s) + ((ra + rb) % m) by {\n    calc {\n      a + b;\n      == { }\n      (m * qa + ra) + (m * qb + rb);\n      == { }\n      m * (qa + qb) + (ra + rb);\n      == { }\n      m * (qa + qb) + (m * s + ((ra + rb) % m));\n      == { }\n      m * (qa + qb + s) + ((ra + rb) % m);\n    }\n  }\n  assert (a + b) % m == ((ra + rb) % m);\n  assert ((ra + rb) % m) == ((a % m) + (b % m)) % m;\n  assert (a + b) % m == ((a % m) + (b % m)) % m;\n}\n\nlemma Mul_mod_repr(u: nat, v: nat, m: nat)\n  requires m > 0\n  ensures ((u % m) * (v % m)) % m == (u * v) % m\n{\n  var ku := u / m; var ru := u % m;\n  var kv := v / m; var rv := v % m;\n  assert u == m * ku + ru;\n  assert v == m * kv + rv;\n  var t := ku * rv + kv * ru + ku * kv * m;\n  assert u * v == ru * rv + m * t by {\n    calc {\n      u * v;\n      == { }\n      (m * ku + ru) * (m * kv + rv);\n      == { }\n      (m * ku) * (m * kv) + (m * ku) * rv + ru * (m * kv) + ru * rv;\n      == { }\n      ru * rv + m * (ku * rv + kv * ru + ku * kv * m);\n    }\n  }\n  var q := (ru * rv) / m;\n  var rem := (ru * rv) % m;\n  assert ru * rv == m * q + rem;\n  assert u * v == m * (t + q) + rem by {\n    calc {\n      u * v;\n      == { }\n      ru * rv + m * t;\n      == { }\n      m * q + rem + m * t;\n      == { }\n      m * (q + t) + rem;\n    }\n  }\n  assert (u * v) % m == rem;\n  assert rem == (ru * rv) % m;\n  assert (ru * rv) % m == ((u % m) * (v % m)) % m;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  var r: nat := x % z;\n  var i: nat := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= r < z\n    invariant r == Exp_int(x, Exp_int(2, i)) % z\n    decreases n - i\n  {\n    var r_old := r;\n    // square the current remainder\n    r := (r_old * r_old) % z;\n    // relate squared remainder to squared exponent value modulo z\n    assert r_old == Exp_int(x, Exp_int(2, i)) % z;\n    Mul_mod_repr(Exp_int(x, Exp_int(2, i)), Exp_int(x, Exp_int(2, i)), z);\n    assert r == ((Exp_int(x, Exp_int(2, i)) % z) * (Exp_int(x, Exp_int(2, i)) % z)) % z;\n    assert r == (Exp_int(x, Exp_int(2, i)) * Exp_int(x, Exp_int(2, i))) % z;\n    Exp2_dbl(i);\n    Exp_add(x, Exp_int(2, i), Exp_int(2, i));\n    assert Exp_int(x, Exp_int(2, i+1)) == Exp_int(x, Exp_int(2, i)) * Exp_int(x, Exp_int(2, i));\n    assert r == Exp_int(x, Exp_int(2, i+1)) % z;\n    i := i + 1;\n  }\n  res := r;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Add_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Add_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Compare_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_CompareUnequal.dfy", "root", true, "", "", false, "bignum_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function Pow2(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else 2 * Pow2(n-1)\n}\n\nlemma Pow2_monotone(a: nat, b: nat)\n  requires a >= b\n  ensures Pow2(a) >= Pow2(b)\n  decreases a\n{\n  if a == b {\n    // Pow2(a) == Pow2(b)\n  } else {\n    // a > b\n    assert a - 1 >= b;\n    Pow2_monotone(a - 1, b);\n    assert Pow2(a) == 2 * Pow2(a - 1);\n    assert Pow2(a - 1) >= Pow2(b);\n    assert Pow2(a) >= 2 * Pow2(b);\n    assert 2 * Pow2(b) >= Pow2(b); // since Pow2(b) >= 1\n  }\n}\n\nlemma Str2Int_UB(s: string)\n  requires ValidBitString(s)\n  ensures Str2Int(s) <= Pow2(|s|) - 1\n  decreases |s|\n{\n  if |s| == 0 {\n    assert Str2Int(s) == 0;\n    assert Pow2(0) == 1;\n    assert 0 <= 0;\n  } else {\n    var prefix := s[0..|s|-1];\n    Str2Int_UB(prefix);\n    assert Str2Int(s) == 2 * Str2Int(prefix) + (if s[|s|-1] == '1' then 1 else 0);\n    assert Str2Int(prefix) <= Pow2(|prefix|) - 1;\n    assert 2 * Str2Int(prefix) <= 2 * (Pow2(|prefix|) - 1);\n    assert 2 * (Pow2(|prefix|) - 1) + 1 == Pow2(|s|) - 1;\n    assert Str2Int(s) <= Pow2(|s|) - 1;\n  }\n}\n\nlemma Str2Int_firstbit(s: string)\n  requires ValidBitString(s)\n  requires |s| > 0\n  ensures Str2Int(s) >= (if s[0] == '1' then Pow2(|s| - 1) else 0)\n  decreases |s|\n{\n  if |s| == 1 {\n    assert Str2Int(s) == (if s[0] == '1' then 1 else 0);\n    assert Pow2(0) == 1;\n  } else {\n    var prefix := s[0..|s|-1];\n    // prefix length > 0\n    Str2Int_firstbit(prefix);\n    assert Str2Int(s) == 2 * Str2Int(prefix) + (if s[|s|-1] == '1' then 1 else 0);\n    if s[0] == '1' {\n      // prefix[0] == s[0] and |prefix| > 0\n      assert prefix[0] == s[0];\n      assert |prefix| == |s| - 1;\n      // From IH: Str2Int(prefix) >= Pow2(|prefix|-1)\n      // So Str2Int(s) >= 2 * Pow2(|prefix|-1) = Pow2(|s|-1)\n      assert Str2Int(prefix) >= Pow2(|prefix| - 1);\n      assert 2 * Str2Int(prefix) >= 2 * Pow2(|prefix| - 1);\n      assert 2 * Pow2(|prefix| - 1) == Pow2(|s| - 1);\n      assert Str2Int(s) >= Pow2(|s| - 1);\n    } else {\n      // RHS is 0, Str2Int(s) is nat, so >= 0\n      assert Str2Int(s) >= 0;\n    }\n  }\n}\n\nlemma LongerImpliesGreater(s1: string, s2: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires |s1| > |s2|\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  ensures Str2Int(s1) > Str2Int(s2)\n{\n  // From |s2| > 0 and |s1| > |s2| we get |s1| > 1, hence s1[0] != '0' implies s1[0] == '1'\n  assert |s2| > 0;\n  assert |s1| > 1;\n  assert s1[0] != '0';\n  // So s1[0] == '1'\n  Str2Int_firstbit(s1);\n  Str2Int_UB(s2);\n  assert Str2Int(s1) >= Pow2(|s1| - 1);\n  assert |s1| - 1 >= |s2|;\n  Pow2_monotone(|s1| - 1, |s2|);\n  assert Pow2(|s1| - 1) >= Pow2(|s2|);\n  assert Pow2(|s2|) > Pow2(|s2|) - 1;\n  assert Pow2(|s2|) - 1 >= Str2Int(s2);\n  assert Pow2(|s2|) > Str2Int(s2);\n  assert Str2Int(s1) > Str2Int(s2);\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n// </vc-spec>\n// <vc-code>\n{\n  LongerImpliesGreater(s1, s2);\n  res := 1;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_DivMod_Sub.dfy", "root", false, "", "", false, "bignum_DivMod_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Add.dfy", "root", true, "", "", false, "bignum_Add.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nghost function pow2(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nlemma Str2Int_concat(a: string, b: string)\n  requires ValidBitString(a) && ValidBitString(b)\n  ensures ValidBitString(a + b)\n  ensures Str2Int(a + b) == pow2(|b|) * Str2Int(a) + Str2Int(b)\n  decreases |b|\n{\n  if |b| == 0 {\n    // trivial: a + \"\" = a\n  } else {\n    var bpre := b[0..|b|-1];\n    var c := b[|b|-1];\n    // By definition of Str2Int on (a + b):\n    assert Str2Int(a + b) == 2 * Str2Int(a + bpre) + (if c == '1' then 1 else 0);\n    // Apply inductive hypothesis to a + bpre\n    Str2Int_concat(a, bpre);\n    assert Str2Int(a + bpre) == pow2(|bpre|) * Str2Int(a) + Str2Int(bpre);\n    // pow2 relation\n    assert pow2(|b|) == 2 * pow2(|bpre|);\n    // Str2Int relation for b\n    assert Str2Int(b) == 2 * Str2Int(bpre) + (if c == '1' then 1 else 0);\n    // Combine equalities\n    assert Str2Int(a + b) == pow2(|b|) * Str2Int(a) + Str2Int(b);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  var i := |s1| - 1;\n  var j := |s2| - 1;\n  res := \"\";\n  var carry := 0;\n  // Invariant: processed suffixes are s1[i+1..|s1|], s2[j+1..|s2|]\n  while i >= 0 || j >= 0\n    invariant 0 <= i + 1 <= |s1|\n    invariant 0 <= j + 1 <= |s2|\n    invariant 0 <= carry <= 1\n    invariant ValidBitString(res)\n    invariant Str2Int(res) + carry * pow2(|res|) == Str2Int(s1[i+1..|s1|]) + Str2Int(s2[j+1..|s2|])\n  {\n    var b1 := 0;\n    if i >= 0 && s1[i] == '1' { b1 := 1; }\n    var b2 := 0;\n    if j >= 0 && s2[j] == '1' { b2 := 1; }\n    var sum := b1 + b2 + carry;\n    var digit := sum % 2;\n    carry := sum / 2;\n    if digit == 1 {\n      res := \"1\" + res;\n    } else {\n      res := \"0\" + res;\n    }\n    i := i - 1;\n    j := j - 1;\n  }\n\n  if carry == 1 {\n    // use concat lemma to update numeric value for \"1\" + oldRes\n    Str2Int_concat(\"1\", res);\n    res := \"1\" + res;\n  }\n\n  return res;\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExp_Add_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int_ModExpPow2_int.dfy", "root", false, "", "", false, "bignum_ModExp_int_ModExpPow2_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Sub.dfy", "root", false, "", "", false, "bignum_Sub.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod_Compare.dfy", "root", false, "", "", false, "bignum_DivMod_Compare.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExpPow2_Add_Mul.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add_Mul.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp.dfy", "root", true, "", "", false, "bignum_ModExp.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nlemma MulMod(x: nat, y: nat, m: nat)\n  requires m > 0\n  ensures (x * y) % m == ((x % m) * (y % m)) % m\n{\n  var xm := x % m;\n  var xq := x / m;\n  var ym := y % m;\n  var yq := y / m;\n  assert x == xm + m * xq;\n  assert y == ym + m * yq;\n  assert x * y == (xm + m * xq) * (ym + m * yq);\n  assert x * y == xm * ym + m * (xm * yq + xq * ym + m * xq * yq);\n  assert (x * y) % m == (xm * ym) % m;\n  assert ((x % m) * (y % m)) % m == (xm * ym) % m;\n}\n\nlemma Exp_add(b: nat, n: nat, m: nat)\n  ensures Exp_int(b, n + m) == Exp_int(b, n) * Exp_int(b, m)\n  decreases m\n{\n  if m == 0 {\n    assert n + 0 == n;\n    assert Exp_int(b, n + 0) == Exp_int(b, n);\n    assert Exp_int(b, 0) == 1;\n    assert Exp_int(b, n) * Exp_int(b, 0) == Exp_int(b, n);\n  } else {\n    Exp_add(b, n, m - 1);\n    // Exp_int(b, n + m) = b * Exp_int(b, n + m - 1)\n    assert Exp_int(b, n + m) == b * Exp_int(b, n + m - 1);\n    // By induction hypothesis: Exp_int(b, n + m - 1) == Exp_int(b, n) * Exp_int(b, m - 1)\n    assert Exp_int(b, n + m - 1) == Exp_int(b, n) * Exp_int(b, m - 1);\n    // So Exp_int(b, n + m) == b * (Exp_int(b, n) * Exp_int(b, m - 1))\n    assert Exp_int(b, n + m) == b * (Exp_int(b, n) * Exp_int(b, m - 1));\n    // Rearrange: b * (Exp_int(b, n) * Exp_int(b, m - 1)) == Exp_int(b, n) * (b * Exp_int(b, m - 1))\n    assert Exp_int(b, n + m) == Exp_int(b, n) * (b * Exp_int(b, m - 1));\n    // But b * Exp_int(b, m - 1) == Exp_int(b, m)\n    assert b * Exp_int(b, m - 1) == Exp_int(b, m);\n    assert Exp_int(b, n + m) == Exp_int(b, n) * Exp_int(b, m);\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  var m := Str2Int(sz);\n  var bfull := Str2Int(sx);\n  var base := bfull % m;\n  var resNat := 1 % m;\n  var i := 0;\n  while i < |sy|\n    invariant 0 <= i <= |sy|\n    invariant resNat == Exp_int(bfull, Str2Int(sy[0..i])) % m\n    invariant m > 0\n    invariant base == bfull % m\n  {\n    var prefix := Str2Int(sy[0..i]);\n    // square step: compute (resNat * resNat) % m\n    var sq := (resNat * resNat) % m;\n    // Show sq corresponds to Exp_int(bfull, 2*prefix) % m\n    Exp_add(bfull, prefix, prefix);\n    assert Exp_int(bfull, 2 * prefix) == Exp_int(bfull, prefix) * Exp_int(bfull, prefix);\n    MulMod(Exp_int(bfull, prefix), Exp_int(bfull, prefix), m);\n    // Relate sq to multiplication of raw powers\n    assert sq == ((Exp_int(bfull, prefix) % m) * (Exp_int(bfull, prefix) % m)) % m;\n    assert ((Exp_int(bfull, prefix) % m) * (Exp_int(bfull, prefix) % m)) % m == (Exp_int(bfull, prefix) * Exp_int(bfull, prefix)) % m;\n    assert (Exp_int(bfull, prefix) * Exp_int(bfull, prefix)) % m == Exp_int(bfull, 2 * prefix) % m;\n    assert sq == Exp_int(bfull, 2 * prefix) % m;\n    var newRes := sq;\n    if sy[i] == '1' {\n      newRes := (newRes * base) % m;\n      // Show newRes == Exp_int(bfull, 2*prefix + 1) % m\n      Exp_add(bfull, 2 * prefix, 1);\n      assert Exp_int(bfull, 2 * prefix + 1) == Exp_int(bfull, 2 * prefix) * Exp_int(bfull, 1);\n      assert Exp_int(bfull, 1) == bfull;\n      // Relate modulus multiplication\n      MulMod(Exp_int(bfull, 2 * prefix), bfull, m);\n      assert ((Exp_int(bfull, 2 * prefix) % m) * (bfull % m)) % m == (Exp_int(bfull, 2 * prefix) * bfull) % m;\n      assert (Exp_int(bfull, 2 * prefix) * bfull) % m == Exp_int(bfull, 2 * prefix + 1) % m;\n      // combine with sq == Exp_int(... ) % m and base == bfull % m\n      assert newRes == ((Exp_int(bfull, 2 * prefix) % m) * (bfull % m)) % m;\n      assert newRes == Exp_int(bfull, 2 * prefix + 1) % m;\n    } else {\n      assert newRes == Exp_int(bfull, 2 * prefix) % m;\n    }\n    resNat := newRes;\n    i := i + 1;\n  }\n  res := Int2Str(resNat);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_ModExpPow2_Add.dfy", "root", false, "", "", false, "bignum_ModExpPow2_Add.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Zeros.dfy", "root", false, "", "", false, "bignum_Zeros.dfy", "// <vc-preamble>\npredicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_Compare_CompareUnequal.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_int.dfy", "root", true, "", "", false, "bignum_ModExp_int.dfy", "// <vc-preamble>\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\n// <vc-helpers>\nlemma Exp_add(x: nat, m: nat, n: nat)\n  ensures Exp_int(x, m + n) == Exp_int(x, m) * Exp_int(x, n)\n{\n  if n == 0 {\n    // Exp_int(x, m+0) == Exp_int(x,m) * 1 == Exp_int(x,m) * Exp_int(x,0)\n  } else {\n    Exp_add(x, m, n - 1);\n    assert Exp_int(x, m + n) == x * Exp_int(x, m + n - 1);\n    assert Exp_int(x, m + n - 1) == Exp_int(x, m) * Exp_int(x, n - 1);\n    assert Exp_int(x, m + n) == Exp_int(x, m) * (x * Exp_int(x, n - 1));\n    assert x * Exp_int(x, n - 1) == Exp_int(x, n);\n  }\n}\n\nlemma RemMod(z: nat, M: nat, r: nat)\n  requires z > 0\n  requires r < z\n  ensures (z * M + r) % z == r\n{\n  var q := (z * M + r) / z;\n  var rr := (z * M + r) % z;\n  assert z * M + r == z * q + rr;\n  assert rr < z;\n\n  // Work in integers to avoid problematic natural-number subtractions\n  var iz: int := z;\n  var iM: int := M;\n  var ir: int := r;\n  var iq: int := q;\n  var irr: int := rr;\n\n  assert iz * iq + irr == iz * iM + ir;\n  // rearrange in integers\n  assert iz * iq - iz * iM == ir - irr;\n  assert iz * (iq - iM) == ir - irr;\n\n  if iq > iM {\n    assert iq - iM >= 1;\n    assert iz * (iq - iM) >= iz;\n    assert iz * (iq - iM) == ir - irr;\n    // ir - irr < iz because ir < iz and irr >= 0\n    assert ir - irr < iz;\n    assert false;\n  } else if iq < iM {\n    assert iM - iq >= 1;\n    assert iz * (iM - iq) >= iz;\n    assert iz * (iM - iq) == irr - ir;\n    // irr - ir < iz because irr < iz and ir >= 0\n    assert irr - ir < iz;\n    assert false;\n  } else {\n    // iq == iM\n    assert iq == iM;\n    assert irr == ir;\n    // convert back to nat-equalities\n    assert q == M;\n    assert rr == r;\n  }\n}\n\nlemma ModMul(a: nat, b: nat, z: nat)\n  requires z > 0\n  ensures (a % z) * (b % z) % z == (a * b) % z\n{\n  var q1 := a / z; var r1 := a % z;\n  var q2 := b / z; var r2 := b % z;\n  assert a == q1 * z + r1;\n  assert b == q2 * z + r2;\n  assert r1 < z;\n  assert r2 < z;\n\n  // expand a*b\n  assert a * b == (q1 * z + r1) * (q2 * z + r2);\n  assert a * b == q1*q2*z*z + q1*z*r2 + r1*q2*z + r1*r2;\n\n  // group multiples of z\n  var K := q1*q2*z + q1*r2 + r1*q2;\n  assert a * b == z * K + r1 * r2;\n  assert (a * b) % z == (z * K + r1 * r2) % z;\n\n  // write r1*r2 = z*q + r with r < z\n  var q := (r1 * r2) / z;\n  var r := (r1 * r2) % z;\n  assert r1 * r2 == z * q + r;\n  assert r < z;\n\n  // combine: z*K + r1*r2 == z*(K + q) + r\n  assert z * K + r1 * r2 == z * (K + q) + r;\n\n  // hence (z*(K+q) + r) % z == r\n  RemMod(z, K + q, r);\n  assert (z * (K + q) + r) % z == r;\n  assert (a * b) % z == r;\n  assert r == (r1 * r2) % z;\n\n  // relate back to a%z and b%z\n  assert r1 == a % z;\n  assert r2 == b % z;\n  assert (r1 * r2) % z == ((a % z) * (b % z)) % z;\n}\n\nlemma Div2Bound(y: nat, n: nat)\n  requires y < Exp_int(2, n + 1)\n  ensures y / 2 < Exp_int(2, n)\n{\n  // Exp_int(2, n+1) == 2 * Exp_int(2, n)\n  Exp_add(2, 1, n);\n  assert Exp_int(2, n + 1) == 2 * Exp_int(2, n);\n\n  if y / 2 >= Exp_int(2, n) {\n    // then 2*(y/2) >= 2*Exp_int(2,n)\n    assert 2 * (y / 2) >= 2 * Exp_int(2, n);\n    // y == 2*(y/2) + y%2\n    assert y == 2 * (y / 2) + y % 2;\n    // hence y >= 2*Exp_int(2,n)\n    assert y >= 2 * Exp_int(2, n);\n    // which contradicts y < Exp_int(2,n+1) == 2*Exp_int(2,n)\n    assert y >= Exp_int(2, n + 1);\n    assert false;\n  }\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n// </vc-spec>\n// <vc-code>\n{\n  if n == 0 {\n    if y == 0 {\n      return 1 % z;\n    } else {\n      return x % z;\n    }\n  } else {\n    var b := y % 2;\n    var yhalf := y / 2;\n    Div2Bound(y, n);\n    var t := ModExp_int(x, yhalf, n - 1, z);\n    assert t == Exp_int(x, yhalf) % z;\n    var s := (t * t) % z;\n    // relate s to Exp_int(x, 2*yhalf) % z\n    ModMul(Exp_int(x, yhalf), Exp_int(x, yhalf), z);\n    assert s == ((Exp_int(x, yhalf) % z) * (Exp_int(x, yhalf) % z)) % z;\n    assert s == (Exp_int(x, yhalf) * Exp_int(x, yhalf)) % z;\n    Exp_add(x, yhalf, yhalf);\n    assert s == Exp_int(x, 2 * yhalf) % z;\n    if b == 1 {\n      var res := (s * (x % z)) % z;\n      ModMul(Exp_int(x, 2 * yhalf), x, z);\n      assert res == ((Exp_int(x, 2 * yhalf) % z) * (x % z)) % z;\n      assert res == (Exp_int(x, 2 * yhalf) * x) % z;\n      Exp_add(x, 2 * yhalf, 1);\n      assert Exp_int(x, 2 * yhalf + 1) == Exp_int(x, 2 * yhalf) * x;\n      assert res == Exp_int(x, 2 * yhalf + 1) % z;\n      return res;\n    } else {\n      return s;\n    }\n  }\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Sub_NormalizeBitstring.dfy", "root", false, "", "", false, "bignum_Sub_NormalizeBitstring.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_DivMod_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_Add_DivMod_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_DivMod.dfy", "root", true, "", "", false, "bignum_DivMod.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\n// <vc-helpers>\nfunction pow2(k: nat): nat\n  decreases k\n{\n  if k == 0 then 1 else 2 * pow2(k - 1)\n}\n\nlemma pow2_mul(k: nat)\n  ensures pow2(k + 1) == 2 * pow2(k)\n  decreases k\n{\n  if k == 0 {\n  } else {\n    pow2_mul(k - 1);\n  }\n}\n\nlemma Str2IntPrepend(b: bool, s: string)\n  requires ValidBitString(s)\n  ensures Str2Int((if b then \"1\" else \"0\") + s) == (if b then pow2(|s|) else 0) + Str2Int(s)\n  decreases |s|\n{\n  if |s| == 0 {\n    // base case: Str2Int(\"1\") == 1, Str2Int(\"0\") == 0\n  } else {\n    var t := s[0..|s|-1];\n    Str2IntPrepend(b, t);\n    var ss := (if b then \"1\" else \"0\") + s;\n    // unfold definition of Str2Int on ss\n    assert |ss| > 0;\n    var prefix := ss[0..|ss|-1];\n    assert prefix == (if b then \"1\" else \"0\") + t;\n    assert ss[|ss|-1] == s[|s|-1];\n    assert Str2Int(ss) == 2 * Str2Int(prefix) + (if ss[|ss|-1] == '1' then 1 else 0);\n    // Use IH on prefix\n    assert Str2Int(prefix) == (if b then pow2(|t|) else 0) + Str2Int(t);\n    // Combine\n    assert Str2Int(ss) == 2 * ((if b then pow2(|t|) else 0) + Str2Int(t)) + (if s[|s|-1] == '1' then 1 else 0);\n    // 2 * ((if b then pow2(|t|) else 0)) == (if b then 2*pow2(|t|) else 0)\n    assert 2 * ((if b then pow2(|t|) else 0)) == (if b then 2 * pow2(|t|) else 0);\n    // pow2(k+1) == 2*pow2(k)\n    pow2_mul(|t|);\n    assert (if b then 2 * pow2(|t|) else 0) == (if b then pow2(|t| + 1) else 0);\n    // |t| + 1 == |s|\n    assert |t| + 1 == |s|;\n    assert (if b then pow2(|t| + 1) else 0) == (if b then pow2(|s|) else 0);\n    // And 2*Str2Int(t) + lastbit == Str2Int(s)\n    assert Str2Int(s) == 2 * Str2Int(t) + (if s[|s|-1] == '1' then 1 else 0);\n    // Conclude\n    assert Str2Int(ss) == (if b then pow2(|s|) else 0) + Str2Int(s);\n  }\n}\n\nlemma Str2IntAppend(b: bool, t: string)\n  requires ValidBitString(t)\n  ensures Str2Int(t + (if b then \"1\" else \"0\")) == 2 * Str2Int(t) + (if b then 1 else 0)\n  decreases |t|\n{\n  var s := t + (if b then \"1\" else \"0\");\n  if |s| > 0 {\n    var p := s[0..|s|-1];\n    assert p == t;\n    assert s[|s|-1] == (if b then '1' else '0');\n    assert Str2Int(s) == 2 * Str2Int(p) + (if s[|s|-1] == '1' then 1 else 0);\n    assert Str2Int(s) == 2 * Str2Int(t) + (if b then 1 else 0);\n  }\n}\n\nlemma DivNonNeg(a: nat, b: nat)\n  requires b > 0\n  ensures a / b >= 0 && a % b >= 0\n{\n  // For naturals, division and modulus are non-negative.\n}\n\nlemma Div2Less(a: nat)\n  requires a != 0\n  ensures a / 2 < a\n{\n  if a == 1 {\n    // 1/2 == 0 < 1\n  } else {\n    var b := a - 2;\n    assert a == 2 + b;\n    assert a/2 == 1 + b/2;\n    // b/2 <= b holds for all nat b\n    assert b/2 <= b;\n    assert 1 + b/2 <= 1 + b;\n    assert 1 + b == a - 1;\n    assert a/2 <= a - 1;\n    // Hence a/2 < a\n  }\n}\n\nlemma DivHalfLe(k: nat)\n  ensures k / 2 <= k\n  decreases k\n{\n  if k == 0 {\n  } else if k == 1 {\n    assert k / 2 == 0;\n  } else {\n    var t := k - 2;\n    // k == 2 + t\n    DivHalfLe(t);\n    assert k / 2 == 1 + t / 2;\n    assert t / 2 <= t;\n    assert 1 + t / 2 <= 1 + t;\n    assert 1 + t <= k;\n    assert k / 2 <= k;\n  }\n}\n\nlemma NonzeroNatIsPos(a: nat)\n  requires a != 0\n  ensures a > 0\n{\n  // For nat, nonzero implies positive.\n}\n\nmethod ParseBitString(s: string) returns (v: nat)\n  requires ValidBitString(s)\n  ensures v == Str2Int(s)\n{\n  v := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant v == Str2Int(s[0..i])\n    invariant ValidBitString(s[0..i])\n    decreases |s| - i\n  {\n    var prefix := s[0..i];\n    assert ValidBitString(prefix);\n    var bit := if s[i] == '1' then 1 else 0;\n    // Use prepend/appending lemma to justify update\n    Str2IntAppend(s[i] == '1', prefix);\n    // prefix + bit-char equals s[0..i+1]\n    assert prefix + (if s[i] == '1' then \"1\" else \"0\") == s[0..i+1];\n    // Now update v using the arithmetic fact from lemma\n    v := 2 * v + bit;\n    // From Str2IntAppend and invariant v == Str2Int(prefix) before update, we get:\n    assert v == Str2Int(prefix + (if s[i] == '1' then \"1\" else \"0\"));\n    i := i + 1;\n  }\n  // Help the verifier see the postcondition: i == |s| and s[0..i] == s\n  assert i == |s|;\n  assert s[0..i] == s;\n  assert v == Str2Int(s);\n}\n\nmethod NatToBin(n: nat) returns (s: string)\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == n\n{\n  s := \"\";\n  var m := n;\n  var factor := pow2(0); // 1\n  // Invariant: n == m * factor + Str2Int(s)\n  // and factor == pow2(|s|)\n  while m != 0\n    invariant ValidBitString(s)\n    invariant factor == pow2(|s|)\n    invariant n == m * factor + Str2Int(s)\n    decreases m\n  {\n    var old_s := s;\n    var old_m := m;\n    var old_factor := factor;\n    // From loop condition, m != 0, hence old_m != 0\n    assert old_m != 0;\n    var b := m % 2;\n    var ch := if b == 1 then \"1\" else \"0\";\n    s := ch + s;\n    m := m / 2;\n    factor := factor * 2;\n    // Use prepend lemma on old_s\n    Str2IntPrepend(b == 1, old_s);\n    // arithmetic to restore invariant\n    assert old_m == 2 * m + b;\n    assert old_factor == pow2(|old_s|);\n    assert factor == 2 * old_factor;\n    // b * old_factor == (if b == 1 then pow2(|old_s|) else 0)\n    assert b * old_factor == (if b == 1 then pow2(|old_s|) else 0);\n    // Combine to show n unchanged\n    calc {\n      n;\n      == { assert n == old_m * old_factor + Str2Int(old_s); }\n      old_m * old_factor + Str2Int(old_s);\n      == { assert old_m == 2 * m + b; }\n      (2 * m + b) * old_factor + Str2Int(old_s);\n      == { assert (2 * m) * old_factor == m * (2 * old_factor); }\n      m * (2 * old_factor) + b * old_factor + Str2Int(old_s);\n      == { assert 2 * old_factor == factor; }\n      m * factor + b * old_factor + Str2Int(old_s);\n      == { assert b * old_factor == (if b == 1 then pow2(|old_s|) else 0); }\n      m * factor + (if b == 1 then pow2(|old_s|) else 0) + Str2Int(old_s);\n      == { assert (if b == 1 then pow2(|old_s|) else 0) + Str2Int(old_s) == Str2Int(s); }\n      m * factor + Str2Int(s);\n    }\n    // Show decreases measure decreases: old_m > m\n    // After assignment m := old_m / 2, we have:\n    assert m == old_m / 2;\n    if old_m == 1 {\n      assert m == 0;\n      assert m < old_m;\n    } else {\n      // old_m >= 2\n      var t := old_m - 2;\n      assert old_m == 2 + t;\n      assert old_m / 2 == 1 + t / 2;\n      // t/2 <= t\n      DivHalfLe(t);\n      assert t / 2 <= t;\n      assert m == 1 + t / 2;\n      assert m <= 1 + t;\n      assert 1 + t == old_m - 1;\n      assert m <= old_m - 1;\n      assert old_m - 1 < old_m;\n      assert m < old_m;\n    }\n  }\n  // when m == 0, invariant gives n == Str2Int(s)\n  assert Str2Int(s) == n;\n}\n// </vc-helpers>\n\n// <vc-spec>\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n// </vc-spec>\n// <vc-code>\n{\n  // Parse dividend and divisor to nat values\n  var dv := ParseBitString(dividend);\n  var ds := ParseBitString(divisor);\n  // Ensure divisor is positive (help the verifier)\n  assert ds > 0;\n  // Use lemma to show division/modulus are non-negative\n  DivNonNeg(dv, ds);\n  // Compute quotient and remainder as naturals\n  var qn: nat := dv / ds;\n  var rn: nat := dv % ds;\n  // Convert nats back to bit-strings\n  quotient := NatToBin(qn);\n  remainder := NatToBin(rn);\n}\n// </vc-code>\n\n", "", "", ""], ["bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "root", false, "", "", false, "bignum_Compare_CompareUnequal_NormalizeBitString.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "root", false, "", "", false, "bignum_ModExp_DivMod_ModExpPow2_Mul.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_ModExpPow2_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Mul_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Mul_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""], ["bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "root", false, "", "", false, "bignum_ModExp_Add_ModExpPow2_Zeroes.dfy", "// <vc-preamble>\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n// </vc-preamble>\n\n// <vc-helpers>\n// </vc-helpers>\n\n// <vc-spec>\nmethod ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|\n// </vc-spec>\n// <vc-code>\n{\n  assume {:axiom} false;\n}\n// </vc-code>\n", "", "", "", ""]]}