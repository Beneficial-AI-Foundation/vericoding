import Std.Do.Triple
import Std.Tactic.Do

open Std.Do

/-!
{
  "name": "numpy.loadtxt",
  "category": "Text file I/O",
  "description": "Load data from a text file",
  "url": "https://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html",
  "doc": "Load data from a text file.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is \`\`.gz\`\` or \`\`.bz2\`\`, the file is first decompressed. Note\n        that generators must return bytes or strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this i...",
  "code": "@finalize_array_function_like\n@set_module('numpy')\ndef loadtxt(fname, dtype=float, comments='#', delimiter=None,\n            converters=None, skiprows=0, usecols=None, unpack=False,\n            ndmin=0, encoding=None, max_rows=None, *, quotechar=None,\n            like=None):\n    r\"\"\"\n    Load data from a text file.\n\n    Parameters\n    ----------\n    fname : file, str, pathlib.Path, list of str, generator\n        File, filename, list, or generator to read.  If the filename\n        extension is \`\`.gz\`\` or \`\`.bz2\`\`, the file is first decompressed. Note\n        that generators must return bytes or strings. The strings\n        in a list or produced by a generator are treated as lines.\n    dtype : data-type, optional\n        Data-type of the resulting array; default: float.  If this is a\n        structured data-type, the resulting array will be 1-dimensional, and\n        each row will be interpreted as an element of the array.  In this\n        case, the number of columns used must match the number of fields in\n        the data-type.\n    comments : str or sequence of str or None, optional\n        The characters or list of characters used to indicate the start of a\n        comment. None implies no comments. For backwards compatibility, byte\n        strings will be decoded as 'latin1'. The default is '#'.\n    delimiter : str, optional\n        The character used to separate the values. For backwards compatibility,\n        byte strings will be decoded as 'latin1'. The default is whitespace.\n\n        .. versionchanged:: 1.23.0\n           Only single character delimiters are supported. Newline characters\n           cannot be used as the delimiter.\n\n    converters : dict or callable, optional\n        Converter functions to customize value parsing. If \`converters\` is\n        callable, the function is applied to all columns, else it must be a\n        dict that maps column number to a parser function.\n        See examples for further details.\n        Default: None.\n\n        .. versionchanged:: 1.23.0\n           The ability to pass a single callable to be applied to all columns\n           was added.\n\n    skiprows : int, optional\n        Skip the first \`skiprows\` lines, including comments; default: 0.\n    usecols : int or sequence, optional\n        Which columns to read, with 0 being the first. For example,\n        \`\`usecols = (1,4,5)\`\` will extract the 2nd, 5th and 6th columns.\n        The default, None, results in all columns being read.\n    unpack : bool, optional\n        If True, the returned array is transposed, so that arguments may be\n        unpacked using \`\`x, y, z = loadtxt(...)\`\`.  When used with a\n        structured data-type, arrays are returned for each field.\n        Default is False.\n    ndmin : int, optional\n        The returned array will have at least \`ndmin\` dimensions.\n        Otherwise mono-dimensional axes will be squeezed.\n        Legal values: 0 (default), 1 or 2.\n    encoding : str, optional\n        Encoding used to decode the inputfile. Does not apply to input streams.\n        The special value 'bytes' enables backward compatibility workarounds\n        that ensures you receive byte arrays as results if possible and passes\n        'latin1' encoded strings to converters. Override this value to receive\n        unicode arrays and pass strings as input to converters.  If set to None\n        the system default is used. The default value is None.\n\n        .. versionchanged:: 2.0\n            Before NumPy 2, the default was \`\`'bytes'\`\` for Python 2\n            compatibility. The default is now \`\`None\`\`.\n\n    max_rows : int, optional\n        Read \`max_rows\` rows of content after \`skiprows\` lines. The default is\n        to read all the rows. Note that empty rows containing no data such as\n        empty lines and comment lines are not counted towards \`max_rows\`,\n        while such lines are counted in \`skiprows\`.\n\n        .. versionchanged:: 1.23.0\n            Lines containing no data, including comment lines (e.g., lines\n            starting with '#' or as specified via \`comments\`) are not counted\n            towards \`max_rows\`.\n    quotechar : unicode character or None, optional\n        The character used to denote the start and end of a quoted item.\n        Occurrences of the delimiter or comment characters are ignored within\n        a quoted item. The default value is \`\`quotechar=None\`\`, which means\n        quoting support is disabled.\n\n        If two consecutive instances of \`quotechar\` are found within a quoted\n        field, the first is treated as an escape character. See examples.\n\n        .. versionadded:: 1.23.0\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Data read from the text file.\n\n    See Also\n    --------\n    load, fromstring, fromregex\n    genfromtxt : Load data with missing values handled as specified.\n    scipy.io.loadmat : reads MATLAB data files\n\n    Notes\n    -----\n    This function aims to be a fast reader for simply formatted files.  The\n    \`genfromtxt\` function provides more sophisticated handling of, e.g.,\n    lines with missing values.\n\n    Each row in the input text file must have the same number of values to be\n    able to read all values. If all rows do not have same number of values, a\n    subset of up to n columns (where n is the least number of values present\n    in all rows) can be read by specifying the columns via \`usecols\`.\n\n    The strings produced by the Python float.hex method can be used as\n    input for floats.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from io import StringIO   # StringIO behaves like a file object\n    >>> c = StringIO(\"0 1\\n2 3\")\n    >>> np.loadtxt(c)\n    array([[0., 1.],\n           [2., 3.]])\n\n    >>> d = StringIO(\"M 21 72\\nF 35 58\")\n    >>> np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n    ...                      'formats': ('S1', 'i4', 'f4')})\n    array([(b'M', 21, 72.), (b'F', 35, 58.)],\n          dtype=[('gender', 'S1'), ('age', '<i4'), ('weight', '<f4')])\n\n    >>> c = StringIO(\"1,0,2\\n3,0,4\")\n    >>> x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n    >>> x\n    array([1., 3.])\n    >>> y\n    array([2., 4.])\n\n    The \`converters\` argument is used to specify functions to preprocess the\n    text prior to parsing. \`converters\` can be a dictionary that maps\n    preprocessing functions to each column:\n\n    >>> s = StringIO(\"1.618, 2.296\\n3.141, 4.669\\n\")\n    >>> conv = {\n    ...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0\n    ...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1\n    ... }\n    >>> np.loadtxt(s, delimiter=\",\", converters=conv)\n    array([[1., 3.],\n           [3., 5.]])\n\n    \`converters\` can be a callable instead of a dictionary, in which case it\n    is applied to all columns:\n\n    >>> s = StringIO(\"0xDE 0xAD\\n0xC0 0xDE\")\n    >>> import functools\n    >>> conv = functools.partial(int, base=16)\n    >>> np.loadtxt(s, converters=conv)\n    array([[222., 173.],\n           [192., 222.]])\n\n    This example shows how \`converters\` can be used to convert a field\n    with a trailing minus sign into a negative number.\n\n    >>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n    >>> def conv(fld):\n    ...     return -float(fld[:-1]) if fld.endswith(\"-\") else float(fld)\n    ...\n    >>> np.loadtxt(s, converters=conv)\n    array([[ 10.01, -31.25],\n           [ 19.22,  64.31],\n           [-17.57,  63.94]])\n\n    Using a callable as the converter can be particularly useful for handling\n    values with different formatting, e.g. floats with underscores:\n\n    >>> s = StringIO(\"1 2.7 100_000\")\n    >>> np.loadtxt(s, converters=float)\n    array([1.e+00, 2.7e+00, 1.e+05])\n\n    This idea can be extended to automatically handle values specified in\n    many different formats, such as hex values:\n\n    >>> def conv(val):\n    ...     try:\n    ...         return float(val)\n    ...     except ValueError:\n    ...         return float.fromhex(val)\n    >>> s = StringIO(\"1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2\")\n    >>> np.loadtxt(s, delimiter=\",\", converters=conv)\n    array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])\n\n    Or a format where the \`\`-\`\` sign comes after the number:\n\n    >>> s = StringIO(\"10.01 31.25-\\n19.22 64.31\\n17.57- 63.94\")\n    >>> conv = lambda x: -float(x[:-1]) if x.endswith(\"-\") else float(x)\n    >>> np.loadtxt(s, converters=conv)\n    array([[ 10.01, -31.25],\n           [ 19.22,  64.31],\n           [-17.57,  63.94]])\n\n    Support for quoted fields is enabled with the \`quotechar\` parameter.\n    Comment and delimiter characters are ignored when they appear within a\n    quoted item delineated by \`quotechar\`:\n\n    >>> s = StringIO('\"alpha, #42\", 10.0\\n\"beta, #64\", 2.0\\n')\n    >>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n    >>> np.loadtxt(s, dtype=dtype, delimiter=\",\", quotechar='\"')\n    array([('alpha, #42', 10.), ('beta, #64',  2.)],\n          dtype=[('label', '<U12'), ('value', '<f8')])\n\n    Quoted fields can be separated by multiple whitespace characters:\n\n    >>> s = StringIO('\"alpha, #42\"       10.0\\n\"beta, #64\" 2.0\\n')\n    >>> dtype = np.dtype([(\"label\", \"U12\"), (\"value\", float)])\n    >>> np.loadtxt(s, dtype=dtype, delimiter=None, quotechar='\"')\n    array([('alpha, #42', 10.), ('beta, #64',  2.)],\n          dtype=[('label', '<U12'), ('value', '<f8')])\n\n    Two consecutive quote characters within a quoted field are treated as a\n    single escaped character:\n\n    >>> s = StringIO('\"Hello, my name is \"\"Monty\"\"!\"')\n    >>> np.loadtxt(s, dtype=\"U\", delimiter=\",\", quotechar='\"')\n    array('Hello, my name is \"Monty\"!', dtype='<U26')\n\n    Read subset of columns when all rows do not contain equal number of values:\n\n    >>> d = StringIO(\"1 2\\n2 4\\n3 9 12\\n4 16 20\")\n    >>> np.loadtxt(d, usecols=(0, 1))\n    array([[ 1.,  2.],\n           [ 2.,  4.],\n           [ 3.,  9.],\n           [ 4., 16.]])\n\n    \"\"\"\n\n    if like is not None:\n        return _loadtxt_with_like(\n            like, fname, dtype=dtype, comments=comments, delimiter=delimiter,\n            converters=converters, skiprows=skiprows, usecols=usecols,\n            unpack=unpack, ndmin=ndmin, encoding=encoding,\n            max_rows=max_rows\n        )\n\n    if isinstance(delimiter, bytes):\n        delimiter.decode(\"latin1\")\n\n    if dtype is None:\n        dtype = np.float64\n\n    comment = comments\n    # Control character type conversions for Py3 convenience\n    if comment is not None:\n        if isinstance(comment, (str, bytes)):\n            comment = [comment]\n        comment = [\n            x.decode('latin1') if isinstance(x, bytes) else x for x in comment]\n    if isinstance(delimiter, bytes):\n        delimiter = delimiter.decode('latin1')\n\n    arr = _read(fname, dtype=dtype, comment=comment, delimiter=delimiter,\n                converters=converters, skiplines=skiprows, usecols=usecols,\n                unpack=unpack, ndmin=ndmin, encoding=encoding,\n                max_rows=max_rows, quote=quotechar)\n\n    return arr\n\n\n_loadtxt_with_like = array_function_dispatch()(loadtxt)\n\n\ndef _savetxt_dispatcher(fname, X, fmt=None, delimiter=None, newline=None,\n                        header=None, footer=None, comments=None,\n                        encoding=None):\n    return (X,)\n\n\n@array_function_dispatch(_savetxt_dispatcher)\ndef savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\\n', header='',\n            footer='', comments='# ', encoding=None):\n    \"\"\"\n    Save an array to a text file.\n\n    Parameters\n    ----------\n    fname : filename, file handle or pathlib.Path\n        If the filename ends in \`\`.gz\`\`, the file is automatically saved in\n        compressed gzip format.  \`loadtxt\` understands gzipped files\n        transparently.\n    X : 1D or 2D array_like\n        Data to be saved to a text file.\n    fmt : str or sequence of strs, optional\n        A single format (%10.5f), a sequence of formats, or a\n        multi-format string, e.g. 'Iteration %d -- %10.5f', in which\n        case \`delimiter\` is ignored. For complex \`X\`, the legal options\n        for \`fmt\` are:\n\n        * a single specifier, \`\`fmt='%.4e'\`\`, resulting in numbers formatted\n          like \`\`' (%s+%sj)' % (fmt, fmt)\`\`\n        * a full string specifying every real and imaginary part, e.g.\n          \`\`' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'\`\` for 3 columns\n        * a list of specifiers, one per column - in this case, the real\n          and imaginary part must have separate specifiers,\n          e.g. \`\`['%.3e + %.3ej', '(%.15e%+.15ej)']\`\` for 2 columns\n    delimiter : str, optional\n        String or character separating columns.\n    newline : str, optional\n        String or character separating lines.\n    header : str, optional\n        String that will be written at the beginning of the file.\n    footer : str, optional\n        String that will be written at the end of the file.\n    comments : str, optional\n        String that will be prepended to the \`\`header\`\` and \`\`footer\`\` strings,\n        to mark them as comments. Default: '# ',  as expected by e.g.\n        \`\`numpy.loadtxt\`\`.\n    encoding : {None, str}, optional\n        Encoding used to encode the outputfile. Does not apply to output\n        streams. If the encoding is something other than 'bytes' or 'latin1'\n        you will not be able to load the file in NumPy versions < 1.14. Default\n        is 'latin1'.\n\n    See Also\n    --------\n    save : Save an array to a binary file in NumPy \`\`.npy\`\` format\n    savez : Save several arrays into an uncompressed \`\`.npz\`\` archive\n    savez_compressed : Save several arrays into a compressed \`\`.npz\`\` archive\n\n    Notes\n    -----\n    Further explanation of the \`fmt\` parameter\n    (\`\`%[flag]width[.precision]specifier\`\`):\n\n    flags:\n        \`\`-\`\` : left justify\n\n        \`\`+\`\` : Forces to precede result with + or -.\n\n        \`\``0\`\` : Left pad the number with zeros instead of space (see width).\n\n    width:\n        Minimum number of characters to be printed. The value is not truncated\n        if it has more characters.\n\n    precision:\n        - For integer specifiers (eg. \`\`d,i,o,x\`\`), the minimum number of\n          digits.\n        - For \`\`e, E\`\` and \`\`f\`\` specifiers, the number of digits to print\n          after the decimal point.\n        - For \`\`g\`\` and \`\`G\`\`, the maximum number of significant digits.\n        - For \`\`s\`\`, the maximum number of characters.\n\n    specifiers:\n        \`\`c\`\` : character\n\n        \`\`d\`\` or \`\`i\`\` : signed decimal integer\n\n        \`\`e\`\` or \`\`E\`\` : scientific notation with \`\`e\`\` or \`\`E\`\`.\n\n        \`\`f\`\` : decimal floating point\n\n        \`\`g,G\`\` : use the shorter of \`\`e,E\`\` or \`\`f\`\`\n\n        \`\`o\`\` : signed octal\n\n        \`\`s\`\` : string of characters\n\n        \`\`u\`\` : unsigned decimal integer\n\n        \`\`x,X\`\` : unsigned hexadecimal integer\n\n    This explanation of \`\`fmt\`\` is not complete, for an exhaustive\n    specification see [1]_.\n\n    References\n    ----------\n    .. [1] \`Format Specification Mini-Language\n           <https://docs.python.org/library/string.html#format-specification-mini-language>\`_,\n           Python Documentation.\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> x = y = z = np.arange(0.0,5.0,1.0)\n    >>> np.savetxt('test.out', x, delimiter=',')   # X is an array\n    >>> np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n    >>> np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n    \"\"\"\n\n    class WriteWrap:\n        \"\"\"Convert to bytes on bytestream inputs.\n\n        \"\"\"\n        def __init__(self, fh, encoding):\n            self.fh = fh\n            self.encoding = encoding\n            self.do_write = self.first_write\n\n        def close(self):\n            self.fh.close()\n\n        def write(self, v):\n            self.do_write(v)\n\n        def write_bytes(self, v):\n            if isinstance(v, bytes):\n                self.fh.write(v)\n            else:\n                self.fh.write(v.encode(self.encoding))\n\n        def write_normal(self, v):\n            self.fh.write(asunicode(v))\n\n        def first_write(self, v):\n            try:\n                self.write_normal(v)\n                self.write = self.write_normal\n            except TypeError:\n                # input is probably a bytestream\n                self.write_bytes(v)\n                self.write = self.write_bytes\n\n    own_fh = False\n    if isinstance(fname, os.PathLike):\n        fname = os.fspath(fname)\n    if _is_string_like(fname):"
}
-/

/-- Load data from a text file into a 2D array.
    For simplicity, this specification focuses on loading a rectangular matrix of floats. -/
def loadtxt {rows cols : Nat} (filename : String) (delimiter : String := " ") 
    (skiprows : Nat := 0) : Id (Vector (Vector Float cols) rows) :=
  sorry

/-- Specification: loadtxt reads numeric data from a text file into a well-formed 2D array.
    The function preserves the structure of the input data and handles parsing correctly. -/
theorem loadtxt_spec {rows cols : Nat} (filename : String) (delimiter : String := " ") 
    (skiprows : Nat := 0) 
    (h_rectangular : rows > 0 ∧ cols > 0) :
    ⦃⌜rows > 0 ∧ cols > 0 ∧ filename.length > 0⌝⦄
    loadtxt filename delimiter skiprows
    ⦃⇓result => ⌜
      -- Each element is finite (no NaN or infinite values for valid numeric input)
      (∀ i : Fin rows, ∀ j : Fin cols, (result.get i).get j |>.isFinite) ∧
      -- Parsing preserves numeric relationships for well-formed input
      (∀ i : Fin rows, ∀ j : Fin cols, 
        let val := (result.get i).get j
        val |>.isFinite → (val ≥ -1e308 ∧ val ≤ 1e308))⌝⦄ := by
  sorry