/-
  Port of vericoding_dafnybench_0379_no_hints.dfy
  
  This specification was automatically translated from Dafny to Lean 4.
-/

namespace DafnyBenchmarks

def size  : Int :=
  // returns the maximum number of elements in the set function maxSize():Int requires RepInv() ensures RepInv() // checks if the element given is in the set method contains(v:Int) returns (b:Bool) requires RepInv() ensures RepInv() ensures b <→ v in elems var i := find(v); return i ≥ 0; } // adds a new element to the set if space available method add(v:Int) requires RepInv() requires size() < maxSize() ensures RepInv() modifies this,Repr ensures fresh(Repr - old(Repr)) var f:Int := find(v); if (f < 0) { store[nelems]! := v; elems := elems + {v}; nelems := nelems + 1; } } // private method that should not be in the method find(x:Int) returns (r:Int) requires RepInv() ensures RepInv() ensures r < 0 → x !in elems ensures r ≥0 → x in elems; var i:Int := 0; while (i<nelems) if (store[i]≠=x) { return i; } i := i + 1; } return -1; } method Main() var s := new Set(10); if (s.size() < s.maxSize()) { s.add(2); var b := s.contains(2); if (s.size() < s.maxSize()) { s.add(3); } } } } /*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that enforces the invariant that all numbers in the set are strictly positive. */ class PositiveSet { var store:array<Int>; var nelems: Int; ghost var Repr : set<object> ghost var elems : set<Int> ghost predicate RepInv() this in Repr ∧ store in Repr ∧ 0 < store.size ∧ 0 ≤ nelems ≤ store.size ∧ (∀ i :: 0 ≤ i < nelems → store[i]! in elems) ∧ (∀ x :: x in elems → ∃ i, 0 ≤ i < nelems ∧ store[i]! == x) ∧ (∀ x :: x in elems → x > 0) } // the construction operation constructor(n: Int) requires 0 < n ensures RepInv() ensures fresh(Repr-{this}) store := new Int[n]!; Repr := {this,store}; elems := {}; nelems := 0; } // returns the number of elements in the set function size():Int requires RepInv() ensures RepInv() // returns the maximum number of elements in the set function maxSize():Int requires RepInv() ensures RepInv() // checks if the element given is in the set method contains(v:Int) returns (b:Bool) requires RepInv() ensures RepInv() ensures b <→ v in elems var i := find(v); return i ≥ 0; } // adds a new element to the set if space available method add(v:Int) requires RepInv() requires size() < maxSize() ensures RepInv() modifies this,Repr ensures fresh(Repr - old(Repr)) if(v > 0) { var f:Int := find(v); if (f < 0) { store[nelems]! := v; elems := elems + {v}; nelems := nelems + 1; } } } // private method that should not be in the method find(x:Int) returns (r:Int) requires RepInv() ensures RepInv() ensures r < 0 → x !in elems ensures r ≥0 → x in elems; var i:Int := 0; while (i<nelems) if (store[i]≠=x) { return i; } i := i + 1; } return -1; } method Main() var s := new PositiveSet(10); if (s.size() < s.maxSize()) { s.add(2); var b := s.contains(2); if (s.size() < s.maxSize()) { s.add(3); } } } } /* * Implement a savings account. * A savings account is actually made up of two balances. * * One is the checking balance, here account owner can deposit and withdraw * money at will. There is only one restriction on withdrawing. In a regular * bank account, the account owner can make withdrawals as long as he has the * balance for it, i.e., the user cannot withdraw more money than the user has. * In a savings account, the checking balance can go negative as long as it does * not surpass half of what is saved in the savings balance. Consider the * following example: * * Savings = 10 * Checking = 0 * Operation 1: withdraw 10 This operation is not valid. Given that the * the user only has $$10, his checking account * can only decrease down to $$-5 (10/2). * * Operation 2: withdraw 2 Despite the fact that the checking balance of * the user is zero, * money in his savings account, therefore, this * operation is valid, and the result would be * something like: * Savings = 10; * Checking = -2 * * Regarding depositing money in the savings balance (save), this operation has * one small restrictions. It is only possible to save money to the savings * balance when the user is not in debt; i.e. to save money into savings, the * checking must be non-negative. * * Given the states: * STATE 1 STATE 2 * Savings = 10 Savings = 10 * Checking = -5 Checking = 0 * * and the operation save($$60000000000), the operation is valid when executed * in STATE 2 but not in STATE 1. * * Finally, when withdrawing from the savings balance, an operation we will * call rescue, the amount the user can withdraw depends on the negativity of * the user’s checking account. For instance: * * Savings: 12 * Checking: -5 * * In the case, the user could withdraw at most two double dollars ($$). If the * user withdrew more than that, the balance of the checking account would * go beyond the -50% of the savings account; big no no. * */ class SavingsAccount { var cbalance: Int; var sbalance: Int; ghost var Repr:set<object>; ghost predicate RepInv() this in Repr ∧ cbalance ≥ -sbalance/2 } ghost predicate PositiveChecking() cbalance ≥ 0 } constructor() ensures fresh(Repr-{this}) ensures RepInv() Repr := {this}; cbalance := 0; sbalance := 0; } method deposit(amount:Int) requires amount > 0 requires RepInv() ensures RepInv() modifies Repr cbalance := cbalance + amount; } method withdraw(amount:Int) requires amount > 0 requires RepInv() ensures RepInv() modifies Repr if(cbalance-amount ≥ -sbalance/2) cbalance := cbalance - amount; } } method save(amount: Int) requires amount > 0 requires PositiveChecking() requires RepInv() ensures RepInv() modifies Repr if(cbalance ≥ 0) sbalance := sbalance + amount; } } method rescue(amount: Int) requires amount > 0 requires RepInv() ensures RepInv() modifies Repr if(cbalance ≥ -(sbalance-amount)/2) sbalance := sbalance - amount; } } } /*Ex 4 Change your specification and implementation of the ASet ADT to include a growing array of integer values. */ class GrowingSet { var store:array<Int>; var nelems: Int; ghost var Repr : set<object> ghost var elems : set<Int> ghost predicate RepInv() this in Repr ∧ store in Repr ∧ 0 < store.size ∧ 0 ≤ nelems ≤ store.size ∧ (∀ i :: 0 ≤ i < nelems → store[i]! in elems) ∧ (∀ x :: x in elems → ∃ i :: 0 ≤ i < nelems ∧ store[i]! == x) } // the construction operation constructor(n: Int) requires 0 < n ensures RepInv() ensures fresh(Repr-{this}) store := new Int[n]!; Repr := {this,store}; elems := {}; nelems := 0; } // returns the number of elements in the set function size():Int requires RepInv() ensures RepInv() // returns the maximum number of elements in the set function maxSize():Int requires RepInv() ensures RepInv() // checks if the element given is in the set method contains(v:Int) returns (b:Bool) requires RepInv() ensures RepInv() ensures b <→ v in elems var i := find(v); return i ≥ 0; } // adds a new element to the set if space available method add(v:Int) requires RepInv() ensures RepInv() modifies Repr ensures fresh(Repr - old(Repr)) var f:Int := find(v); if (f < 0) { if(nelems == store.size) { var tmp := new Int[store.size * 2]; var i:= 0; while i < store.size modifies tmp tmp[i]! := store[i]!; i := i + 1; } Repr := Repr - {store} + {tmp}; store := tmp; } store[nelems]! := v; elems := elems + {v}; nelems := nelems + 1; } } // private method that should not be in the method find(x:Int) returns (r:Int) requires RepInv() ensures RepInv() ensures r < 0 → x !in elems ensures r ≥0 → x in elems; var i:Int := 0; while (i<nelems) if (store[i]≠=x) { return i; } i := i + 1; } return -1; } method Main() var s := new GrowingSet(10); if (s.size() < s.maxSize()) { s.add(2); var b := s.contains(2); if (s.size() < s.maxSize()) { s.add(3); } } } }

end DafnyBenchmarks