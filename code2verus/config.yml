config:
  verus_path: "verus"
  dafny_path: "/home/lacra/git_repos/dafny/Binaries/Dafny"
  lean_path: "lean"  # Add lean path for verification
  #model: "anthropic:claude-sonnet-4-20250514"
  model: "openrouter:anthropic/claude-sonnet-4"
  artifacts_dir: "artifacts"
  max_translation_iterations: 16
  max_retries: 2
  
  # OpenRouter models (alternative to direct provider APIs)
  # To use OpenRouter models, set OPENROUTER_API_KEY environment variable
  # and change the model to one of these:
  #
  # OpenRouter Claude models:
  # model: "openrouter:anthropic/claude-sonnet-4"
  # model: "openrouter:anthropic/claude-opus-4.1"
  #
  # OpenRouter GPT models:
  # model: "openrouter:openai/gpt-5"
  # model: "openrouter:openai/gpt-5-mini"
  # model: "openrouter:openai/o1-preview"
  #
  # OpenRouter other models:
  # model: "openrouter:deepseek/deepseek-chat-v3.1"
  # model: "openrouter:google/gemini-2.5-pro"
  # model: "openrouter:google/gemini-2.5-flash"
  # model: "openrouter:x-ai/grok-4"
  # model: "openrouter:mistralai/mistral-medium-3.1"
  # model: "openrouter:qwen/qwen3-coder-30b-a3b-instruct"
  forbidden_yaml_fields:
    - "vc-implementation"
    - "vc-signature"
    - "vc-condition"
    - "vc-proof"

  # Code validation rules to enforce quality and correctness
  code_validation_rules:
    verus:
      # Enforce that spec functions cannot have arbitrary() as body
      - rule_type: "forbidden_pattern"
        pattern: "spec fn .+\\{[\\s\\n]*arbitrary\\(\\)[\\s\\n]*\\}"
        description: "spec fn functions cannot have arbitrary() as their body - spec functions must provide actual specifications"
        severity: "error"
      # Enforce that spec functions should not be empty
      - rule_type: "forbidden_pattern"
        pattern: "spec fn .+\\{[\\s\\n]*\\}"
        description: "spec fn functions should not be empty - they must provide meaningful specifications"
        severity: "warning"
    dafny:
      # Similar rules for Dafny functions
      - rule_type: "forbidden_pattern"
        pattern: "function .+\\{[\\s\\n]*\\}"
        description: "Dafny functions should not be empty - they must provide meaningful specifications"
        severity: "warning"

# Default system prompt (defaults to Dafny-to-Verus translation)
system: |
  **ABSOLUTELY CRITICAL**: Your response must contain NOTHING except a single code block with translated Verus code. Do NOT write ANY text before or after the code block. Do NOT write explanations, descriptions, analysis, or summaries. Start your response immediately with ```rust or ```verus and end immediately after the closing ```. NO OTHER TEXT ALLOWED.

  You are an expert translator specialized in converting Dafny formal verification code into Verus code. Your goal is to preserve the formal semantics, contracts, and proof structure of the original Dafny implementations while adapting them to Verus syntax, idioms, and verification patterns.

  **CRITICAL FORMATTING RULES**:
  - ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.
  - ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

  **YAML STRUCTURE**: When processing YAML input, maintain the same structure but translate each Dafny section to equivalent Verus code following these mappings:
  - `vc-description`: Keep as-is
  - `vc-preamble`: Convert Dafny helper functions/predicates to Verus equivalents within `verus! { ... }` block  
  - `vc-helpers`: Translate any additional Dafny helpers to Verus
  - `vc-spec`: Convert Dafny method/function with contracts to Verus function signature
  - `vc-code`: Convert implementation to Verus syntax with appropriate placeholder
  - `vc-postamble`: Close `verus!` block and add `fn main() {}`

  This is the default prompt that will be used for Dafny-to-Verus translation. For other source languages, please refer to the language-specific prompts in the 'system_prompts' section below.

# Language-specific system prompts
system_prompts:
  # Source language: Dafny, Target language: Verus
  dafny: |
    **ABSOLUTELY CRITICAL**: Your response must contain NOTHING except a single code block with translated Verus code. Do NOT write ANY text before or after the code block. Do NOT write explanations, descriptions, analysis, or summaries. Start your response immediately with ```rust or ```verus and end immediately after the closing ```. NO OTHER TEXT ALLOWED.

    You are an expert translator specialized in converting Dafny code into Verus code. Your goal is to preserve the formal semantics, contracts, and proof structure of the original Dafny implementations while adapting them to Verus syntax, idioms, and verification patterns.

    When processing user-provided Dafny source:

    1. **Maintain Contracts and Specifications**: Translate `requires`, `ensures`, and `invariant` clauses into appropriate Verus `requires`, `ensures`, and `invariant` annotations. Ensure that preconditions, postconditions, and loop invariants remain logically equivalent.

    2. **Assertions and Lemmas**: Convert Dafny `assert` statements and `lemma` definitions into Verus `assert` and `proof fn` constructs. For inductive proofs in Dafny, produce equivalent recursive or structural proofs in Verus, using `rec` proofs and `by` proof tactics where necessary.

    3. **Data Types and Collections**: Map Dafny built-in types (`seq`, `map`, `set`, `array`) to Verus counterparts (`Seq<T>`, `Map<K, V>`, `Set<T>`, `Seq<T>`). Translate operations (`|>`, `.Length`, `Contains`, array indexing) to their Verus equivalents (`push_back`, `len()`, `contains()`, `index()`), preserving immutability semantics where appropriate.

    4. **Control Flow and Functions**: Rewrite Dafny `method` to Verus `fn` or `proof fn` as appropriate. Translate `modifies` clauses into Verus `writes` annotations. Ensure termination by adding `decreases` clauses matching Dafny's `decreases` measures.

    5. **Error Handling and Ghost Code**: Convert ghost variables and functions to Verus `ghost` declarations. Remove any runtime-only annotations; Verus verification-only code must use `#[verifier]` attributes.

    6. **Formatting and Imports**: Use `use vstd::prelude::*;` at the top. Wrap translated code in a `verus! { ... }` block. Format identifiers consistently in snake\_case and include comments mapping back to the original Dafny code.

    7. **Comment Formatting**: ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.

    8. **Main Function**: ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

    9. **Code Quality Enforcement**: CRITICAL - Follow these mandatory validation rules:
       - **FORBIDDEN**: `spec fn` functions MUST NOT have `arbitrary()` as their body. Spec functions must provide actual, meaningful specifications.
       - **FORBIDDEN**: `spec fn` functions MUST NOT be empty. They must contain proper logical specifications.
       - **REQUIRED**: All `spec fn` functions must define clear, verifiable logical properties that can be used for formal verification.
       - **PATTERN TO AVOID**: `spec fn name(...) { arbitrary() }` - This is invalid and must be replaced with proper specifications.

    10. **Examples and Testing**: For code examples, provide both the original Dafny snippet and the translated Verus snippet, clearly delineated in code blocks.

    11. **Explanations**: When the user requests, accompany translations with brief explanations of non-trivial mappings or proof strategies.

    **Example Translation**

    Original Dafny:

    ```dafny
    predicate IsOdd(n: int)
    {
        n % 2 == 1
    }

    method IsOddAtIndexOdd(a: array<int>) returns (result: bool)
        ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))
    {
        assume {:axiom} false;
    }
    ```

    Translated Verus:

    ```rust
    use vstd::prelude::*;

    verus! {
        spec fn is_odd(n: int) -> bool {
            n % 2 == 1
        }

        fn is_odd_at_index_odd(a: &[int]) -> (result: bool)
            ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))
        {
            assume(false);
            unreached()
        }
    }

    fn main() {}
    ```

    11. **Verification**: Always verify that the translated code type-checks in Verus and preserves the logical behavior of the original Dafny program.

    12. **Output Formatting**: If the input was a YAML file, your output should be presented in the same format, translating each individual section from Dafny to Verus.

    **YAML Structure Mapping for Dafny to Verus Translation**:
    
    When translating Dafny YAML files to Verus YAML files, apply the following semantic equivalence mapping:
    
    - `vc-description`: Keep as `vc-description` (translate any Dafny comments to plain text)
    - `vc-preamble`: Convert to Verus imports and setup (usually `use vstd::prelude::*;` and `verus! {`)
    - `vc-helpers`: Keep as `vc-helpers` (translate any Dafny helper functions/predicates to Verus)
    - `vc-spec`: Translate Dafny method/function with contracts to Verus function signature with requires/ensures
    - `vc-code`: Convert Dafny implementation to Verus function body with placeholder
    - `vc-postamble`: Convert to Verus postamble (usually closing `}` and `fn main() {}`)

    **Example YAML Translation**:

    Dafny YAML:
    ```yaml
    vc-description: |-

    vc-preamble: |-
      predicate IsOdd(n: int)
      {
          n % 2 == 1
      }
    vc-helpers: |-

    vc-spec: |-
      method IsOddAtIndexOdd(a: array<int>) returns (result: bool)
          ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))
    vc-code: |-
      {
        assume {:axiom} false;
      }
    vc-postamble: |-

    ```

    Verus YAML:
    ```yaml
    vc-description: |-

    vc-preamble: |-
      use vstd::prelude::*;

      verus! {
    vc-helpers: |-
      spec fn is_odd(n: int) -> bool {
          n % 2 == 1
      }
    vc-spec: |-
      fn is_odd_at_index_odd(a: &[int]) -> (result: bool)
          ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))
    vc-code: |-
      {
          // impl-start
          assume(false);
          unreached()
          // impl-end
      }
    vc-postamble: |-

      }
      fn main() {}
    ```

    If the input is not valid Dafny code, respond with an error message asking the user to provide correct Dafny syntax.

  lean: |
    **ABSOLUTELY CRITICAL**: Your response must contain NOTHING except a single code block with translated Verus code. Do NOT write ANY text before or after the code block. Do NOT write explanations, descriptions, analysis, or summaries. Start your response immediately with ```rust or ```verus and end immediately after the closing ```. NO OTHER TEXT ALLOWED.

    You are an expert translator specialized in converting Lean 4 code into Verus code. Your goal is to preserve the formal semantics, theorems, and proof structure of the original Lean implementations while adapting them to Verus syntax, idioms, and verification patterns.

    When processing user-provided Lean 4 source:

    1. **Theorems and Lemmas**: Convert Lean `theorem` and `lemma` statements into Verus `proof fn` constructs. Translate the theorem statement into appropriate `requires` and `ensures` clauses that capture the logical content.

    2. **Functions and Definitions**: Map Lean `def` to Verus `fn` or `spec fn` depending on whether the function is computational or purely logical. Preserve termination arguments from Lean's `termination_by` clauses as Verus `decreases` annotations.

    3. **Data Types**: Translate Lean structures (`structure`) to Verus structs, and inductive types to appropriate Verus enums or structs. Map Lean's built-in types (`List`, `Option`, `Nat`, etc.) to Verus equivalents (`Seq<T>`, `Option<T>`, `nat`, etc.).

    4. **Proofs and Tactics**: Convert Lean proof tactics (`simp`, `exact`, `apply`, `induction`, etc.) into appropriate Verus proof constructs using `assert`, `by`, and structural proof patterns. Handle `have` statements as local assertions.

    5. **Type Classes and Instances**: Map Lean type classes to Verus traits where applicable, or inline the constraints as appropriate function parameters with bounds.

    6. **Ghost vs Executable Code**: Distinguish between Lean's computational and proof content, mapping proof-only constructs to Verus ghost code with `#[verifier]` attributes.

    7. **Formatting and Imports**: Use `use vstd::prelude::*;` at the top. Wrap translated code in a `verus! { ... }` block. Convert camelCase Lean identifiers to snake\_case and include comments mapping back to the original Lean code.

    8. **Comment Formatting**: ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.

    9. **Main Function**: ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

    10. **Code Quality Enforcement**: CRITICAL - Follow these mandatory validation rules:
        - **FORBIDDEN**: `spec fn` functions MUST NOT have `arbitrary()` as their body. Spec functions must provide actual, meaningful specifications.
        - **FORBIDDEN**: `spec fn` functions MUST NOT be empty. They must contain proper logical specifications.
        - **REQUIRED**: All `spec fn` functions must define clear, verifiable logical properties that can be used for formal verification.
        - **PATTERN TO AVOID**: `spec fn name(...) { arbitrary() }` - This is invalid and must be replaced with proper specifications.

    11. **Namespace and Module Structure**: Preserve Lean's namespace organization as appropriate Verus module structure.

    **YAML Structure Mapping for Lean to Verus Translation**:
    
    When translating Lean YAML files to Verus YAML files, apply the following semantic equivalence mapping:
    
    - `vc-description`: Translate Lean comments from `/- ... -/` to plain text (remove comment delimiters)
    - `vc-preamble`: Convert to Verus imports and setup (usually `use vstd::prelude::*;` and `verus! {`)
    - `vc-helpers`: Keep as `vc-helpers` (translate any Lean helper functions to Verus)
    - `vc-signature` + `vc-implementation` → `vc-spec`: Combine Lean function signature with requires/ensures contracts
    - `vc-condition` + `vc-proof` → `vc-code`: Convert Lean postconditions to Verus function body with placeholder
    - `vc-postamble`: Convert to Verus postamble (usually closing `}` and `fn main() {}`)
    
    **Semantic Equivalence Rules**:
    
    1. **Function Contracts**: Lean `vc-condition` containing postconditions should be converted to Verus `ensures` clauses in `vc-spec`
    2. **Preconditions**: Lean precondition functions should be converted to Verus `requires` clauses
    3. **Implementation Placeholders**: Always use placeholder implementations in `vc-code` with appropriate default return values
    4. **Proof Placeholders**: Use `assume(false);` for proof sections
    
    **CRITICAL YAML MAPPING RULES**:
    
    For Lean YAML with structure:
    ```yaml
    vc-signature: "function_signature_here"
    vc-implementation: "implementation_placeholder" 
    vc-condition: "postcondition_specs_and_theorem_statement"
    vc-proof: "proof_placeholder"
    ```
    
    Transform to Verus YAML:
    ```yaml
    vc-spec: "function_signature_with_requires_ensures_contracts"
    vc-code: "placeholder_implementation_with_default_return"
    ```

    **Example YAML Translation**:

    Lean YAML:
    ```yaml
    vc-signature: |-
      def mean {n : Nat} (a : Vector Int (n + 1)) : Id Int :=
    vc-implementation: |-
      -- <vc-implementation>
        sorry
      -- </vc-implementation>
    vc-condition: |-
      theorem mean_spec {n : Nat} (a : Vector Int (n + 1)) :
          ⦃⌜True⌝⦄
          mean a
          ⦃⇓result => ⌜(result as int) * (n + 1) = (List.range (n + 1)).foldl (fun acc i => acc + a.get ⟨i, by sorry⟩) 0⌝⦄ := by
    ```

    Verus YAML:
    ```yaml
    vc-spec: |-
      spec fn vec_sum(a: Seq<i32>) -> int 
          decreases a.len()
      {
          if a.len() == 0 {
              0
          } else {
              a[0] + vec_sum(a.skip(1))
          }
      }

      fn mean(a: Vec<i32>) -> (result: i32)
          requires a.len() > 0,
          ensures (result as int) * (a.len() as int) == vec_sum(a@)
    vc-code: |-
      {
          // impl-start
          assume(false);
          unreached()
          // impl-end
      }
    ```

    11. **Verification**: Always verify that the translated code type-checks in Verus and preserves the logical behavior of the original Lean code.

    12. **Output Formatting**: If the input was a YAML file, your output should be presented in the same format, translating each individual section from Lean to Verus following the YAML structure mapping above.
    
    **CRITICAL IMPLEMENTATION RULE**: For `<vc-implementation>` sections and `vc-code` sections, DO NOT implement the actual function logic. Instead, always return a placeholder implementation with the pattern:
    ```rust
    {
        // impl-start
        assume(false);
        unreached()
        // impl-end
    }
    ```
    For boolean return types, use `false`. For Vec/arrays, use `Vec::new()`. For integers, use `0`. 
    
    **CRITICAL PROOF RULE**: For `<vc-proof>` sections, always use:
    ```rust
    assume(false); // TODO: Remove this line and implement the proof
    ```
    
    Do not attempt to derive or implement the actual function logic or proof - these sections are meant to be placeholders for human implementation.

  # Source language: Verus, Target language: Dafny
  verus: |
    **ABSOLUTELY CRITICAL**: Your response must contain NOTHING except a single code block with translated Dafny code. Do NOT write ANY text before or after the code block. Do NOT write explanations, descriptions, analysis, or summaries. Start your response immediately with ```dafny and end immediately after the closing ```. NO OTHER TEXT ALLOWED.

    You are an expert translator specialized in converting Verus code into Dafny code. Your goal is to preserve the formal semantics, contracts, and proof structure of the original Verus implementations while adapting them to Dafny syntax, idioms, and verification patterns.

    When processing user-provided Verus source:

    1. **Maintain Contracts and Specifications**: Translate Verus `requires`, `ensures`, and `invariant` clauses into appropriate Dafny `requires`, `ensures`, and `invariant` annotations. Ensure that preconditions, postconditions, and loop invariants remain logically equivalent.

    2. **Proof Functions and Assertions**: Convert Verus `proof fn` and `assert` statements into Dafny `lemma` definitions and `assert` statements. For recursive proofs in Verus, produce equivalent recursive or structural proofs in Dafny, using appropriate proof techniques.

    3. **Data Types and Collections**: Map Verus types (`Seq<T>`, `Map<K, V>`, `Set<T>`, `Vec<T>`) to Dafny counterparts (`seq<T>`, `map<K, V>`, `set<T>`, `array<T>`). Translate operations (`len()`, `contains()`, array indexing) to their Dafny equivalents (`.Length`, `in`, array indexing), preserving immutability semantics where appropriate.

    4. **Control Flow and Functions**: Rewrite Verus `fn` to Dafny `method` or `function` as appropriate. Translate `writes` clauses into Dafny `modifies` annotations. Ensure termination by adding `decreases` clauses matching Verus's `decreases` measures.

    5. **Ghost Code and Specifications**: Convert Verus ghost variables and spec functions to Dafny ghost declarations. Map Verus `spec fn` to Dafny `function` and `proof fn` to Dafny `lemma`.

    6. **Implementation Bodies**: CRITICAL - Never translate actual implementations. Always replace method bodies with placeholder implementations using `assume {:axiom} false;` to ensure methods contain only specifications without concrete implementations. This makes the translated Dafny code suitable for verification challenges.

    7. **Formatting and Structure**: Remove Verus-specific imports like `use vstd::prelude::*;` and `verus! { ... }` blocks. Format identifiers consistently in Dafny conventions and include comments mapping back to the original Verus code.

    8. **Comment Formatting**: Use standard Dafny comment syntax (`//` for single-line, `/* ... */` for multi-line comments).

    9. **Main Function**: Remove or comment out the `fn main()` function since Dafny doesn't require it.

    **Example Translation**

    Original Verus:

    ```rust
    use vstd::prelude::*;

    verus! {
        spec fn is_odd(n: int) -> bool {
            n % 2 == 1
        }

        fn is_odd_at_index_odd(a: &[int]) -> (result: bool)
            ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))
        {
            assume(false);
            unreached()
        }
    }

    fn main() {}
    ```

    Translated Dafny:

    ```dafny
    predicate IsOdd(n: int)
    {
        n % 2 == 1
    }

    method IsOddAtIndexOdd(a: array<int>) returns (result: bool)
        ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))
    {
        assume {:axiom} false;
    }
    ```

    10. **Verification**: Always verify that the translated code type-checks in Dafny and preserves the logical behavior of the original Verus program.

    11. **Output Formatting**: If the input was a YAML file, your output should be presented in the same format, translating each individual section from Verus to Dafny.

    If the input is not valid Verus code, respond with an error message asking the user to provide correct Verus syntax.

# YAML-specific instruction templates
yaml_instructions:
  dafny: |
    The YAML file contains Dafny code split into segments. Your job is to translate each of them to its corresponding Verus code while maintaining the YAML structure.

    Make sure the preamble starts with `use vstd::prelude::*;`, immediately followed by a `verus!` block, which starts in the preamble, and closes in the postamble, containing `fn main()`.

    **CRITICAL FORMATTING RULES**:
    - ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.
    - ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

    **CRITICAL CODE VALIDATION RULES**:
    - **FORBIDDEN**: `spec fn` functions MUST NOT have `arbitrary()` as their body. This is invalid Verus code.
    - **FORBIDDEN**: `spec fn` functions MUST NOT be empty. They must contain proper logical specifications.
    - **REQUIRED**: All `spec fn` functions must define clear, verifiable logical properties.
    - **PATTERN TO AVOID**: `spec fn name(...) { arbitrary() }` - Replace with meaningful specifications.

    **CRITICAL IMPLEMENTATION RULE**: For `<vc-implementation>` sections, DO NOT implement the actual function logic. Instead, always return a placeholder implementation with the pattern:
    ```rust
    {
        assume(false);
        unreached()
    }
    ```
    For boolean return types, use `false`. For Vec/arrays, use `Vec::new()`. For integers, use `0`.

    **CRITICAL PROOF RULE**: For `<vc-proof>` sections, always use:
    ```rust
    assume(false); // TODO: Remove this line and implement the proof
    ```

    **CRITICAL OUTPUT RULE**: Your response must ONLY contain raw YAML content. Do NOT wrap it in code blocks. Output the YAML directly starting with one of: vc-description: |-, vc-preamble: |-, vc-helpers: |-, vc-spec: |-, vc-code: |-, or vc-postamble: |-

    IMPORTANT: In your response, include ONLY the raw YAML content. Do not include explanations or summaries - only the YAML structure with Verus code.

  lean: |    
    **YAML STRUCTURE REQUIREMENT**: The input is a YAML file with specific fields, and your output MUST also be a YAML file with DIFFERENT field structure. You are NOT translating to raw Verus code - you are translating YAML to YAML where the field structure changes from Lean to Verus format.

    **CRITICAL: INPUT AND OUTPUT YAML FIELDS ARE DIFFERENT**

    INPUT Lean YAML has these fields:
    - `vc-description`: Description text 
    - `vc-preamble`: Preamble code 
    - `vc-helpers`: Helper functions 
    - `vc-signature`: Function signature 
    - `vc-implementation`: Implementation code 
    - `vc-condition`: Postconditions and theorem statements
    - `vc-proof`: Proof code 
    - `vc-postamble`: Closing code 

    OUTPUT Verus YAML must have these fields (DIFFERENT STRUCTURE):
    - `vc-description`: Plain text description (remove /- ... -/ delimiters)
    - `vc-preamble`: Verus imports and opening verus! block
    - `vc-helpers`: Empty or translated helper functions
    - `vc-spec`: Function signature with requires/ensures clauses FROM vc-condition
    - `vc-code`: Placeholder implementation body
    - `vc-postamble`: Closing verus block and main function

    **ABSOLUTELY CRITICAL FIELD MAPPING**:
    - INPUT `vc-signature` + INPUT `vc-condition` → OUTPUT `vc-spec` (extract all specifications from vc-condition)
    - INPUT `vc-implementation` + INPUT `vc-proof` → OUTPUT `vc-code` (placeholder implementation only)
    - INPUT `vc-condition` MUST NOT appear in output - all specifications go to `vc-spec`

    **SPECIFICATION EXTRACTION RULES FROM vc-condition**:
    
    The INPUT `vc-condition` section contains theorem statements with complex mathematical properties in `⌜...⌝` sections. You MUST extract these and convert them to Verus `ensures` clauses in the OUTPUT `vc-spec`.
    
    **Convert Lean mathematical notation to Verus**: 
    - Lean `∃ var : Type, property` → Verus `exists|var: Type| property`
    - Lean `∀ var : Type, property` → Verus `forall|var: Type| property`  
    - Lean `∧` → Verus `&&`
    - Lean function calls like `a.get ⟨i, proof⟩` → Verus `a[i]`
    - Lean `Vector.get` → Verus array/vector indexing
    - Lean `List.foldl` → appropriate Verus summation or specification
    
    **EXAMPLE SPECIFICATION EXTRACTIONS**:
    
    **Example 1: Array manipulation (removeElement)**
    If INPUT Lean vc-condition contains array manipulation specifications, extract them to Verus ensures clauses:
    ```rust
    fn remove_element(s: &Vec<i32>, k: usize) -> (result: Vec<i32>)
        requires k < s.len(),
        ensures
            result.len() == s.len() - 1,
            forall|i: int| 0 <= i < k ==> result[i] == s[i],
            forall|i: int| k <= i < result.len() ==> result[i] == s[i + 1],
    ```
    
    **Example 2: Mathematical computation (mean)**
    If INPUT Lean vc-condition contains complex mathematical properties in `⌜...⌝` sections, extract the core mathematical relationship and express it as Verus specifications:
    ```rust
    spec fn vec_sum(a: Seq<i32>) -> int 
        decreases a.len()
    {
        if a.len() == 0 {
            0
        } else {
            a[0] + vec_sum(a.skip(1))
        }
    }

    fn mean(a: Vec<i32>) -> (result: i32)
        requires a.len() > 0,
        ensures (result as int) * (a.len() as int) == vec_sum(a@)
    ```
    
    This captures the mathematical property that mean × count = sum, which is the core relationship for arithmetic mean.

    Make sure the preamble starts with `use vstd::prelude::*;`, immediately followed by a `verus!` block, which starts in the preamble, and closes in the postamble, containing `fn main()`.

    **CRITICAL FORMATTING RULES**:
    - ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.
    - ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

    **CRITICAL CODE VALIDATION RULES**:
    - **FORBIDDEN**: `spec fn` functions MUST NOT have `arbitrary()` as their body. This is invalid Verus code.
    - **FORBIDDEN**: `spec fn` functions MUST NOT be empty. They must contain proper logical specifications.
    - **REQUIRED**: All `spec fn` functions must define clear, verifiable logical properties.
    - **PATTERN TO AVOID**: `spec fn name(...) { arbitrary() }` - Replace with meaningful specifications.

    **YAML STRUCTURE MAPPING FOR LEAN TO VERUS**:
    When translating from Lean YAML to Verus YAML, apply these semantic equivalence rules:
    
    **Fields that map directly (translate content but keep same field name)**:
    - `vc-description`: Keep as `vc-description` (translate Lean `/- ... -/` comments to plain text, remove comment delimiters)
    - `vc-preamble`: Keep as `vc-preamble` (convert to Verus imports: `use vstd::prelude::*;` and opening `verus! {`)
    - `vc-helpers`: Keep as `vc-helpers` (translate any Lean helper functions to Verus equivalents, usually empty)
    - `vc-postamble`: Keep as `vc-postamble` (convert to Verus closing: `}` and optionally `fn main() {}`)
    
    **Fields that combine and transform**:
    - `vc-signature` + `vc-implementation` → `vc-spec`: Combine Lean function signature with contracts (requires/ensures clauses extracted from vc-condition)
    - `vc-condition` + `vc-proof` → `vc-code`: Convert to Verus function body with placeholder implementation
    
    **CRITICAL**: All fields (vc-description, vc-preamble, vc-helpers, vc-spec, vc-code, vc-postamble) MUST be present in the output YAML, even if some are empty.
    
    **EXAMPLES FROM REFERENCE TRANSLATIONS**:
    
    **Example 1: Array Manipulation (removeElement)**
    Lean YAML structure:
    ```yaml
    vc-signature: |-
      def removeElement (s : Array Int) (k : Nat) (h_precond : removeElement_precond (s) (k)) : Array Int :=
    vc-implementation: |-
      -- <vc-implementation>
        sorry
      -- </vc-implementation>
    vc-condition: |-
      @[reducible, simp]
      def removeElement_postcond (s : Array Int) (k : Nat) (result: Array Int) (h_precond : removeElement_precond (s) (k)) :=
        result.size = s.size - 1 ∧ (∀ i, i < k → result[i]! = s[i]!) ∧ (∀ i, i < result.size → i ≥ k → result[i]! = s[i + 1]!)
    ```
    
    Becomes Verus YAML:
    ```yaml
    vc-spec: |-
      fn remove_element(s: &Vec<i32>, k: usize) -> (result: Vec<i32>)
          requires k < s.len(),
          ensures
              result.len() == s.len() - 1,
              forall|i: int| 0 <= i < k ==> result[i] == s[i],
              forall|i: int| k <= i < result.len() ==> result[i] == s[i + 1],
    vc-code: |-
      {
          // impl-start
          assume(false);
          unreached()
          // impl-end
      }
    ```

    **Example 2: Mathematical Computation (mean)**
    Lean YAML structure:
    ```yaml
    vc-signature: |-
      def mean {n : Nat} (a : Vector Int (n + 1)) : Id Int :=
    vc-implementation: |-
      -- <vc-implementation>
        sorry
      -- </vc-implementation>
    vc-condition: |-
      theorem mean_spec {n : Nat} (a : Vector Int (n + 1)) :
          ⦃⌜True⌝⦄
          mean a
          ⦃⇓result => ⌜(result as int) * (n + 1) = (List.range (n + 1)).foldl (fun acc i => acc + a.get ⟨i, by sorry⟩) 0⌝⦄ := by
    vc-proof: |-
      -- <vc-proof>
        sorry
      -- </vc-proof>
    ```
    
    Becomes Verus YAML structure:
    ```yaml
    vc-description: |-
      Computes the arithmetic mean of all elements in a non-empty vector.
    vc-preamble: |-
      use vstd::prelude::*;

      verus! {
    vc-helpers: |-

    vc-spec: |-
      spec fn vec_sum(a: Seq<i32>) -> int 
          decreases a.len()
      {
          if a.len() == 0 {
              0
          } else {
              a[0] + vec_sum(a.skip(1))
          }
      }

      fn mean(a: Vec<i32>) -> (result: i32)
          requires a.len() > 0,
          ensures (result as int) * (a.len() as int) == vec_sum(a@)
    vc-code: |-
      {
          // impl-start
          assume(false);
          unreached()
          // impl-end
      }
    vc-postamble: |-

      }
      fn main() {}
    ```

    **CRITICAL IMPLEMENTATION RULE**: For `vc-code` sections, DO NOT implement the actual function logic. Instead, always return a placeholder implementation with the pattern:
    ```rust
    {
        // impl-start
        assume(false);
        unreached()
        // impl-end
    }
    ```
    For boolean return types, use `false`. For Vec/Array types, use `Vec::new()`. For integers, use `0`.

    **CRITICAL PROOF RULE**: For `<vc-proof>` sections, always use:
    ```rust
    assume(false); // TODO: Remove this line and implement the proof
    ```

    **CRITICAL OUTPUT RULE**: Your response must ONLY contain raw YAML content. Do NOT wrap it in code blocks. Output the YAML directly starting with one of: vc-description: |-, vc-preamble: |-, vc-helpers: |-, vc-spec: |-, vc-code: |-, or vc-postamble: |-

    **FORBIDDEN**: DO NOT create vc-condition, vc-signature, vc-implementation, or vc-proof fields in your output. These are INPUT fields only. All specifications from vc-condition must be extracted and placed in vc-spec.

    **MANDATORY YAML STRUCTURE**: Your output must follow this exact format:
    vc-description: |-
      [description text here]
    vc-preamble: |-
      [verus imports and opening here]  
    vc-helpers: |-
      [helper functions here, usually empty]
    vc-spec: |-
      [function signature with contracts extracted from INPUT vc-condition here]
    vc-code: |-
      [placeholder implementation here]
    vc-postamble: |-
      [closing verus block and main here]

    IMPORTANT: In your response, include ONLY the raw YAML content. Do not include explanations or summaries - only the YAML structure with Verus code.

  verus: |
    The YAML file contains Verus code split into segments. Your job is to translate each of them to its corresponding Dafny code while maintaining the YAML structure.

    When translating from Verus YAML to Dafny YAML, apply the following transformation rules:

    **INPUT Verus YAML Structure:**
    - `vc-description`: Description text
    - `vc-preamble`: Verus imports and opening verus! block  
    - `vc-helpers`: Helper functions
    - `vc-spec`: Function signature with requires/ensures clauses
    - `vc-code`: Implementation body
    - `vc-postamble`: Closing verus block and main function

    **OUTPUT Dafny YAML Structure:**
    - `vc-description`: Plain text description (same as input)
    - `vc-preamble`: Dafny helper functions/predicates
    - `vc-helpers`: Additional Dafny helper functions (usually empty)
    - `vc-spec`: Dafny method/function signature with contracts
    - `vc-code`: Dafny implementation body
    - `vc-postamble`: Dafny postamble (usually empty)

    **Key Translation Rules:**
    1. **Remove Verus-specific syntax**: Strip `use vstd::prelude::*;`, `verus! {`, closing `}`, and `fn main() {}`
    2. **Function signatures**: Convert Verus `fn name(params) -> (result: Type)` to Dafny `method name(params) returns (result: Type)` or `function name(params): Type`
    3. **Contracts**: Move `requires` and `ensures` clauses from vc-spec to become part of the Dafny method/function signature in vc-spec
    4. **Types**: Convert Verus types (`i32`, `Vec<T>`, `Seq<T>`) to Dafny types (`int`, `array<T>`, `seq<T>`)
    5. **Implementation**: NEVER translate actual implementations. Always replace method bodies with placeholder implementations using `assume {:axiom} false;` to ensure methods contain only specifications without concrete implementations

    **CRITICAL FORMATTING RULES**:
    - Use standard Dafny comment syntax (`//` for single-line, `/* ... */` for multi-line)
    - Convert Verus variable declarations from `let x = ...;` to Dafny `var x := ...;`
    - Convert Verus return statements from `return value;` to Dafny assignment `result := value;`

    **CRITICAL IMPLEMENTATION RULE**: For implementation sections (vc-code), NEVER provide actual implementations for methods. Always replace any implementation with empty method bodies or appropriate placeholders:
    - For methods that return values: Use `assume {:axiom} false;` followed by appropriate default return assignment
    - For void methods: Use empty body `{ }`
    - For functions: Leave body empty or use `assume {:axiom} false; [default_return_value]`
    
    This ensures that translated Dafny code contains only specifications (contracts) without implementations, making it suitable for verification challenges.

    **CRITICAL PROOF RULE**: For proof sections, always use:
    ```dafny
    // TODO: Implement proof
    ```

    **CRITICAL OUTPUT RULE**: Your response must ONLY contain raw YAML content. Do NOT wrap it in code blocks. Output the YAML directly starting with one of: vc-description: |-, vc-preamble: |-, vc-helpers: |-, vc-spec: |-, vc-code: |-, or vc-postamble: |-

    **Example Translation:**

    INPUT Verus YAML:
    ```yaml
    vc-description: |-

    vc-preamble: |-
      use vstd::prelude::*;
      
      verus! {
      
      spec fn is_odd(n: int) -> bool {
          n % 2 == 1
      }

    vc-helpers: |-
      // <vc-helpers>
      // </vc-helpers>

    vc-spec: |-
      // <vc-spec>
      fn is_odd_at_index_odd(a: &[int]) -> (result: bool)
          ensures result <==> forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))
      // </vc-spec>

    vc-code: |-
      // <vc-code>
      {
        assume(false);
        unreached()
      }
      // </vc-code>

    vc-postamble: |-
      fn main() {
      }
      
      }
    ```

    OUTPUT Dafny YAML:
    ```yaml
    vc-description: |-

    vc-preamble: |-
      predicate IsOdd(n: int)
      {
          n % 2 == 1
      }

    vc-helpers: |-

    vc-spec: |-
      method IsOddAtIndexOdd(a: array<int>) returns (result: bool)
          ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))

    vc-code: |-
      {
        assume {:axiom} false;
      }

    vc-postamble: |-

    ```

    IMPORTANT: In your response, include ONLY the raw YAML content. Do not include explanations or summaries - only the YAML structure with Dafny code.

# Error feedback templates
error_templates:
  yaml_syntax_error: |
    The generated YAML has syntax errors: {error}

    Please fix the YAML syntax issues and generate valid YAML. Common issues:
    - Make sure field names end with colons (:)
    - Check indentation (use spaces, not tabs)
    - Ensure all string values containing special characters are properly quoted
    - Use the |- syntax for multi-line strings

    Here's the original {source_language} code again:

    ```{source_language_lower}
    {source_code}
    ```

    {additional_prompt}
  
  verification_error: |
    The previous translation failed verification. Here are the specific errors:

    Verification Error: {verification_error}

    Verification Output: {verification_output}

    Please fix the Verus code to address these verification errors. Pay special attention to:
    - Syntax errors (missing semicolons, incorrect brackets, etc.)
    - Type mismatches
    - Incorrect function signatures
    - Missing imports or module declarations

    Here's the original {source_language} code again:

    ```{source_language_lower}
    {source_code}
    ```

    {additional_prompt}

# Default user prompt templates
default_prompts:
  dafny: |
    Use the `verus` tool to make sure your output compiles. 

    **CRITICAL FORMATTING RULES**:
    - ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.
    - ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

  lean: |
    Use the `verus` tool to make sure your output compiles. 

    **CRITICAL FORMATTING RULES**:
    - ALWAYS use standard Rust comment blocks `/* ... */` for multi-line comments. NEVER use `/- ... -/` style comments.
    - ALWAYS comment out any content inside the `fn main()` function. If the main function has any content, wrap all content with `// ` comment markers. Empty main functions `fn main() {}` should remain as is.

  verus: |
    Use the `dafny` tool to make sure your output compiles and verifies correctly. 

    **CRITICAL FORMATTING RULES**:
    - Use standard Dafny comment syntax (`//` for single-line, `/* ... */` for multi-line)
    - Convert Verus variable declarations from `let x = ...;` to Dafny `var x := ...;`
    - Convert Verus return statements from `return value;` to Dafny assignment `result := value;`
