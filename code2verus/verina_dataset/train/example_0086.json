{
  "id": "verina_advanced_55",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\n-----Input-----\nThe input consists of:\nxs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\n-----Output-----\nThe output is an integer:\nReturns the number that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\nimport Std.Data.HashMap\nopen Std\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef mostFrequent_precond (xs : List Int) : Prop :=\n  -- !benchmark @start precond\n  xs \u2260 []\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n-- Build a frequency map from the list\ndef countMap (xs : List Int) : HashMap Int Nat :=\n  let step := fun m x =>\n    let current := m.getD x 0\n    m.insert x (current + 1)\n  let init := (HashMap.empty : HashMap Int Nat)\n  xs.foldl step init\n\n-- Compute the maximum frequency in the map\ndef getMaxFrequency (m : HashMap Int Nat) : Nat :=\n  let step := fun acc (_k, v) =>\n    if v > acc then v else acc\n  let init := 0\n  m.toList.foldl step init\n\n-- Extract all keys whose frequency == maxFreq\ndef getCandidates (m : HashMap Int Nat) (maxFreq : Nat) : List Int :=\n  let isTarget := fun (_k, v) => v = maxFreq\n  let extract := fun (k, _) => k\n  m.toList.filter isTarget |>.map extract\n\n-- Return the first candidate element from original list\ndef getFirstWithFreq (xs : List Int) (candidates : List Int) : Int :=\n  match xs.find? (fun x => candidates.contains x) with\n  | some x => x\n  | none => 0\n-- !benchmark @end code_aux\n\n\ndef mostFrequent (xs : List Int) (h_precond : mostFrequent_precond (xs)) : Int :=\n  -- !benchmark @start code\n  let freqMap := countMap xs\n  let maxF := getMaxFrequency freqMap\n  let candidates := getCandidates freqMap maxF\n  getFirstWithFreq xs candidates\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef mostFrequent_postcond (xs : List Int) (result: Int) (h_precond : mostFrequent_precond (xs)) : Prop :=\n  -- !benchmark @start postcond\n  let count := fun x => xs.countP (fun y => y = x)\n  result \u2208 xs \u2227\n  xs.all (fun x => count x \u2264 count result) \u2227\n  ((xs.filter (fun x => count x = count result)).head? = some result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem mostFrequent_spec_satisfied (xs: List Int) (h_precond : mostFrequent_precond (xs)) :\n    mostFrequent_postcond (xs) (mostFrequent (xs) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "mostFrequent",
    "parameters": {
      "param_name": [
        "xs"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/majority-element/",
      "task_id": "lab_mostFrequent_325752578",
      "student_id": [
        15
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[1, 2, 2, 3]\"}",
      "{\"xs\": \"[4, 4, 5, 5, 4]\"}",
      "{\"xs\": \"[9]\"}",
      "{\"xs\": \"[1, 2, 3, 1, 2, 3, 2]\"}",
      "{\"xs\": \"[7, 7, 8, 8, 9, 9, 7]\"}"
    ],
    "expected": [
      [
        "2"
      ],
      [
        "4"
      ],
      [
        "9"
      ],
      [
        "2"
      ],
      [
        "7"
      ]
    ],
    "unexpected": [
      [
        "1",
        "3"
      ],
      [
        "5"
      ],
      [
        "0"
      ],
      [
        "1",
        "3"
      ],
      [
        "8",
        "9"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'xs': '[]'}"
    ]
  },
  "difficulty": "advanced"
}