{
  "id": "verina_advanced_36",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than \u230an / 2\u230b times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\n-----Input-----\nThe input consists of one list:\nxs: A list of natural numbers (List Nat), where a majority element is guaranteed to exist.\n\n-----Output-----\nThe output is a natural number:\nReturns the element that appears more than half the time in the input list.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef majorityElement_precond (xs : List Nat) : Prop :=\n  -- !benchmark @start precond\n  xs.length > 0 \u2227 xs.any (fun x => xs.count x > xs.length / 2)\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef majorityElement (xs : List Nat) (h_precond : majorityElement_precond (xs)) : Nat :=\n  -- !benchmark @start code\n  let rec countOccurrences (target : Nat) (lst : List Nat) : Nat :=\n    match lst with\n    | [] => 0\n    | y :: ys =>\n      if y = target then 1 + countOccurrences target ys\n      else countOccurrences target ys\n\n  let rec findCandidate (lst : List Nat) (candidate : Option Nat) (count : Nat) : Nat :=\n    match lst with\n    | [] =>\n      match candidate with\n      | some c => c\n      | none => 0 -- unreachable since we assume majority element exists\n    | x :: xs =>\n      match candidate with\n      | some c =>\n        if x = c then\n          findCandidate xs (some c) (count + 1)\n        else if count = 0 then\n          findCandidate xs (some x) 1\n        else\n          findCandidate xs (some c) (count - 1)\n      | none =>\n        findCandidate xs (some x) 1\n\n  let cand := findCandidate xs none 0\n  cand\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef majorityElement_postcond (xs : List Nat) (result: Nat) (h_precond : majorityElement_precond (xs)) : Prop :=\n  -- !benchmark @start postcond\n  let count := xs.count result\n  count > xs.length / 2\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem majorityElement_spec_satisfied (xs: List Nat) (h_precond : majorityElement_precond (xs)) :\n    majorityElement_postcond (xs) (majorityElement (xs) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "majorityElement",
    "parameters": {
      "param_name": [
        "xs"
      ],
      "param_type": [
        "List Nat"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/majority-element/description/",
      "task_id": "lab_majorityElement_325005413",
      "student_id": [
        29
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[3, 3, 4, 2, 3, 3, 3]\"}",
      "{\"xs\": \"[1, 1, 2, 1, 3, 1, 1]\"}",
      "{\"xs\": \"[2, 2, 2, 1, 1]\"}",
      "{\"xs\": \"[9, 9, 9, 9, 1, 2, 3]\"}",
      "{\"xs\": \"[5, 5, 5, 5, 5, 6, 7]\"}"
    ],
    "expected": [
      [
        "3"
      ],
      [
        "1"
      ],
      [
        "2"
      ],
      [
        "9"
      ],
      [
        "5"
      ]
    ],
    "unexpected": [
      [
        "2",
        "4"
      ],
      [
        "2",
        "3"
      ],
      [
        "1"
      ],
      [
        "1",
        "2",
        "3"
      ],
      [
        "6",
        "7"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'xs': '[1, 2, 3]'}",
      "{'xs': '[]'}"
    ]
  },
  "difficulty": "advanced"
}