{
  "id": "verina_advanced_60",
  "description": "-----Description-----\n\nThis task requires writing a Lean 4 method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\n-----Input-----\n\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (Nat)\n\n-----Output-----\n\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef partitionEvensOdds_precond (nums : List Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef partitionEvensOdds (nums : List Nat) (h_precond : partitionEvensOdds_precond (nums)) : (List Nat \u00d7 List Nat) :=\n  -- !benchmark @start code\n  let rec helper (nums : List Nat) : (List Nat \u00d7 List Nat) :=\n    match nums with\n    | [] => ([], [])\n    | x :: xs =>\n      let (evens, odds) := helper xs\n      if x % 2 == 0 then (x :: evens, odds)\n      else (evens, x :: odds)\n  helper nums\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef partitionEvensOdds_postcond (nums : List Nat) (result: (List Nat \u00d7 List Nat)) (h_precond : partitionEvensOdds_precond (nums)): Prop :=\n  -- !benchmark @start postcond\n  let evens := result.fst\n  let odds := result.snd\n  -- All elements from nums are in evens ++ odds, no extras\n  evens ++ odds = nums.filter (fun n => n % 2 == 0) ++ nums.filter (fun n => n % 2 == 1) \u2227\n  evens.all (fun n => n % 2 == 0) \u2227\n  odds.all (fun n => n % 2 == 1)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem partitionEvensOdds_spec_satisfied (nums: List Nat) (h_precond : partitionEvensOdds_precond (nums)) :\n    partitionEvensOdds_postcond (nums) (partitionEvensOdds (nums) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "partitionEvensOdds",
    "parameters": {
      "param_name": [
        "nums"
      ],
      "param_type": [
        "List Nat"
      ]
    },
    "return_type": "(List Nat \u00d7 List Nat)"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/sort-array-by-parity/description/",
      "task_id": "lab_partitionEvensOdds_325775567",
      "student_id": [
        44
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums\": \"[1, 2, 3, 4, 5, 6]\"}",
      "{\"nums\": \"[0, 7, 8, 9, 10]\"}",
      "{\"nums\": \"[]\"}",
      "{\"nums\": \"[2, 4, 6, 8]\"}",
      "{\"nums\": \"[1, 3, 5, 7]\"}"
    ],
    "expected": [
      [
        "([2, 4, 6], [1, 3, 5])"
      ],
      [
        "([0, 8, 10], [7, 9])"
      ],
      [
        "([], [])"
      ],
      [
        "([2, 4, 6, 8], [])"
      ],
      [
        "([], [1, 3, 5, 7])"
      ]
    ],
    "unexpected": [
      [
        "([1, 3, 5], [2, 4, 6])"
      ],
      [
        "([8, 0, 10], [9, 7])"
      ],
      [
        "([0], [1])"
      ],
      [
        "([], [2, 4, 6, 8])"
      ],
      [
        "([1, 3, 5, 7], [])"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}