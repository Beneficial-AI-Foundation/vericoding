{
  "id": "verina_basic_108",
  "description": "-----Description-----\nThe problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\n-----Input-----\nThe input consists of:\n\u2022 operations: A list of integers representing sequential operations.\n\n-----Output-----\nThe output is a tuple consisting of:\n\u2022 An array of integers representing the partial sums. The array\u2019s size is one more than the number of operations, starting with 0 and where for each index i such that 0 \u2264 i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n\u2022 A boolean value that is true if there exists an index i (with 1 \u2264 i \u2264 operations.length) such that the i-th partial sum is negative, and false otherwise.\n\n-----Note-----\nThe function should also correctly handle an empty list of operations.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef below_zero_precond (operations : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef buildS (operations : List Int) : Array Int :=\n  let sList := operations.foldl\n    (fun (acc : List Int) (op : Int) =>\n      let last := acc.getLast? |>.getD 0\n      acc.append [last + op])\n    [0]\n  Array.mk sList\n-- !benchmark @end code_aux\n\n\ndef below_zero (operations : List Int) (h_precond : below_zero_precond (operations)) : (Array Int \u00d7 Bool) :=\n  -- !benchmark @start code\n  let s := buildS operations\n  let rec check_negative (lst : List Int) : Bool :=\n    match lst with\n    | []      => false\n    | x :: xs => if x < 0 then true else check_negative xs\n  let result := check_negative (s.toList)\n  (s, result)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef below_zero_postcond (operations : List Int) (result: (Array Int \u00d7 Bool)) (h_precond : below_zero_precond (operations)) :=\n  -- !benchmark @start postcond\n  let s := result.1\n  let result := result.2\n  s.size = operations.length + 1 \u2227\n  s[0]? = some 0 \u2227\n  (List.range (s.size - 1)).all (fun i => s[i + 1]? = some (s[i]! + operations[i]!)) \u2227\n  ((result = true) \u2192 ((List.range (operations.length)).any (fun i => s[i + 1]! < 0))) \u2227\n  ((result = false) \u2192 s.all (\u00b7 \u2265 0))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem below_zero_spec_satisfied (operations: List Int) (h_precond : below_zero_precond (operations)) :\n    below_zero_postcond (operations) (below_zero (operations) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "below_zero",
    "parameters": {
      "param_name": [
        "operations"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "(Array Int \u00d7 Bool)"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_below_zero",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"operations\": \"[1, 2, 3]\"}",
      "{\"operations\": \"[-1, 2, -1]\"}",
      "{\"operations\": \"[]\"}",
      "{\"operations\": \"[0, 0, 0]\"}",
      "{\"operations\": \"[10, -20, 5]\"}"
    ],
    "expected": [
      [
        "(#[0, 1, 3, 6], false)"
      ],
      [
        "(#[0, -1, 1, 0], true)"
      ],
      [
        "(#[0], false)"
      ],
      [
        "(#[0, 0, 0, 0], false)"
      ],
      [
        "(#[0, 10, -10, -5], true)"
      ]
    ],
    "unexpected": [
      [
        "(#[0, 1, 3, 5], false)",
        "(#[0, 2, 3, 6], false)",
        "(#[0, 1, 3, 6], true)"
      ],
      [
        "(#[0, -1, 1, 0], false)",
        "(#[0, -1, 0, 0], true)",
        "(#[0, -2, 1, 0], true)"
      ],
      [
        "(#[0], true)",
        "(#[0, 0], false)",
        "(#[0, 1], false)"
      ],
      [
        "(#[0, 0, 0, 0], true)",
        "(#[0, 0, 0], false)",
        "(#[0, 0, 1, 0], false)"
      ],
      [
        "(#[0, 10, -10, -5], false)",
        "(#[0, 10, -9, -5], true)",
        "(#[0, 10, -10, -6], true)"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}