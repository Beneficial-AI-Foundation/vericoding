{
  "id": "verina_advanced_45",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that finds the maximum subarray sum from a given list of integers. \nA subarray is a contiguous sequence of elements within the list. \nThe function should return the maximum sum that can be obtained from any subarray.\n\n-----Input-----\nThe input is a list of integers:\nxs: A list of integers (can include negative numbers).\n\n-----Output-----\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs. \nIf the list is empty, the result should be 0.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef maxSubarraySum_precond (xs : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef maxSubarraySum (xs : List Int) (h_precond : maxSubarraySum_precond (xs)) : Int :=\n  -- !benchmark @start code\n  let rec helper (lst : List Int) (curMax : Int) (globalMax : Int) : Int :=\n    match lst with\n    | [] => globalMax\n    | x :: rest =>\n      let newCurMax := max x (curMax + x)\n      let newGlobal := max globalMax newCurMax\n      helper rest newCurMax newGlobal\n  match xs with\n  | [] => 0\n  | x :: rest => helper rest x x\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef maxSubarraySum_postcond (xs : List Int) (result: Int) (h_precond : maxSubarraySum_precond (xs)) : Prop :=\n  -- !benchmark @start postcond\n  -- Find all possible subarrays and their sums\n  let subarray_sums := List.range (xs.length + 1) |>.flatMap (fun start =>\n    List.range' 1 (xs.length - start) |>.map (fun len =>\n      ((xs.drop start).take len).sum\n    ))\n\n  -- Check if there exists a subarray with sum equal to result\n  let has_result_subarray := subarray_sums.any (fun sum => sum == result)\n\n\n  -- Check if result is the maximum among all subarray sums\n  let is_maximum := subarray_sums.all (\u00b7 \u2264 result)\n\n  match xs with\n  | [] => result == 0\n  | _ => has_result_subarray \u2227 is_maximum\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem maxSubarraySum_spec_satisfied (xs: List Int) (h_precond : maxSubarraySum_precond (xs)) :\n    maxSubarraySum_postcond (xs) (maxSubarraySum (xs) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "maxSubarraySum",
    "parameters": {
      "param_name": [
        "xs"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_maxSubarraySum_324785655",
      "student_id": [
        37
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[1, -2, 3, 4, -1]\"}",
      "{\"xs\": \"[-2, -3, -1, -5]\"}",
      "{\"xs\": \"[5, -1, 2, -1, 3]\"}",
      "{\"xs\": \"[]\"}",
      "{\"xs\": \"[4, -1, -2, 1, 5]\"}"
    ],
    "expected": [
      [
        "7"
      ],
      [
        "-1"
      ],
      [
        "8"
      ],
      [
        "0"
      ],
      [
        "7"
      ]
    ],
    "unexpected": [
      [
        "6",
        "5"
      ],
      [
        "-2",
        "0"
      ],
      [
        "9"
      ],
      [
        "1"
      ],
      [
        "8"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}