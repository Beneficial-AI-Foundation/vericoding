{
  "id": "verina_advanced_22",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that determines whether a list of integers follows a peak-valley pattern.\n\nA list follows this pattern if:\nA. It strictly increases at first,\nB. Then strictly decreases,\nC. Both parts are non-empty.\n\nExamples:\n- [1, 3, 5, 4, 2] -> true\n- [1, 2, 3] -> false\n- [5, 4, 3] -> false\n- [1, 2, 2, 1] -> false\n\n-----Input-----\nThe input consists of a list of integers:\n\n-----Output-----\nThe output is an integer:\nReturns true if the list has a peak-valley structure, false otherwise.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef isPeakValley_precond (lst : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef isPeakValley (lst : List Int) (h_precond : isPeakValley_precond (lst)) : Bool :=\n  -- !benchmark @start code\n  let rec aux (l : List Int) (increasing : Bool) (startedDecreasing : Bool) : Bool :=\n    match l with\n    | x :: y :: rest =>\n      if x < y then\n        if startedDecreasing then false\n        else aux (y :: rest) true startedDecreasing\n      else if x > y then\n        if increasing then aux (y :: rest) increasing true\n        else false\n      else false\n    | _ => increasing && startedDecreasing\n  aux lst false false\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef isPeakValley_postcond (lst : List Int) (result: Bool) (h_precond : isPeakValley_precond (lst)) : Prop :=\n  -- !benchmark @start postcond\n  let len := lst.length\n  let validPeaks :=\n    List.range len |>.filter (fun p =>\n      1 \u2264 p \u2227 p < len - 1 \u2227\n\n      -- check strictly increasing before peak\n      (List.range p).all (fun i =>\n        lst[i]! < lst[i + 1]!\n      ) \u2227\n\n      -- check strictly decreasing after peak\n      (List.range (len - 1 - p)).all (fun i =>\n        lst[p + i]! > lst[p + i + 1]!\n      )\n    )\n  (validPeaks != [] \u2192 result) \u2227\n  (validPeaks.length = 0 \u2192 \u00ac result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem isPeakValley_spec_satisfied (lst: List Int) (h_precond : isPeakValley_precond (lst)) :\n    isPeakValley_postcond (lst) (isPeakValley (lst) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "isPeakValley",
    "parameters": {
      "param_name": [
        "lst"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Bool"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_isPeakValley_325583306",
      "student_id": [
        4
      ]
    }
  },
  "tests": {
    "input": [
      "{\"lst\": \"[1, 3, 5, 2, 1]\"}",
      "{\"lst\": \"[1, 2, 3, 4, 5]\"}",
      "{\"lst\": \"[]\"}",
      "{\"lst\": \"[1]\"}",
      "{\"lst\": \"[1, 1, 1, 1, 1]\"}",
      "{\"lst\": \"[1, 10, 100, 1]\"}"
    ],
    "expected": [
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ]
    ],
    "unexpected": [
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}