{
  "id": "verina_advanced_57",
  "description": "-----Description----- \nThis task requires writing a Lean 4 function that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the function should determine the next greater element for each value in `nums1` as it appears in `nums2`. \nAll integers in both arrays are unique, and the length constraints are.\n\n-----Input-----\nThe input consists of two lists of integers:\nnums1: A list of integers, which is a subset of nums2.\nnums2: A list of integers containing all elements from nums1 and possibly additional elements.\n\n-----Output-----\nThe output is a list of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef nextGreaterElement_precond (nums1 : List Int) (nums2 : List Int) : Prop :=\n  -- !benchmark @start precond\n  List.Nodup nums1 \u2227\n  List.Nodup nums2 \u2227\n  nums1.all (fun x => x \u2208 nums2)\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef nextGreaterElement (nums1 : List Int) (nums2 : List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : List Int :=\n  -- !benchmark @start code\n  let len1 := nums1.length\n\n  let buildNextGreaterMap : List (Int \u00d7 Int) :=\n    let rec mapLoop (index : Nat) (stack : List Nat) (map : List (Int \u00d7 Int)) : List (Int \u00d7 Int) :=\n      if h : index >= nums2.length then\n        stack.foldl (fun acc pos => (nums2[pos]!, -1) :: acc) map\n      else\n        let currentValue := nums2[index]!\n\n        let rec processStack (s : List Nat) (m : List (Int \u00d7 Int)) : List Nat \u00d7 List (Int \u00d7 Int) :=\n          match s with\n          | [] => ([], m)\n          | topIndex :: rest =>\n              let topValue := nums2[topIndex]!\n              if currentValue > topValue then\n                let newMap := (topValue, currentValue) :: m\n                processStack rest newMap\n              else\n                (s, m)\n\n        let (newStack, newMap) := processStack stack map\n\n        mapLoop (index + 1) (index :: newStack) newMap\n      termination_by nums2.length - index\n\n    mapLoop 0 [] []\n\n  let buildResult : List Int :=\n    let rec resultLoop (i : Nat) (result : List Int) : List Int :=\n      if i >= len1 then\n        result.reverse\n      else\n        let val := nums1[i]!\n        let rec findInMap (m : List (Int \u00d7 Int)) : Int :=\n          match m with\n          | [] => -1\n          | (num, nextGreater) :: rest =>\n              if num == val then nextGreater\n              else findInMap rest\n\n        let nextGreater := findInMap buildNextGreaterMap\n        resultLoop (i + 1) (nextGreater :: result)\n      termination_by len1 - i\n\n    resultLoop 0 []\n\n  buildResult\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef nextGreaterElement_postcond (nums1 : List Int) (nums2 : List Int) (result: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) : Prop :=\n  -- !benchmark @start postcond\n  result.length = nums1.length \u2227\n\n  (List.range nums1.length |>.all (fun i =>\n    let val := nums1[i]!\n    let resultVal := result[i]!\n\n    let j := nums2.findIdx? (fun x => x == val)\n    match j with\n    | none => false\n    | some idx =>\n      let nextGreater := (List.range (nums2.length - idx - 1)).find? (fun k =>\n        let pos := idx + k + 1\n        nums2[pos]! > val\n      )\n\n      match nextGreater with\n      | none => resultVal = -1\n      | some offset => resultVal = nums2[idx + offset + 1]!\n  )) \u2227\n  (result.all (fun val =>\n    val = -1 \u2228 val \u2208 nums2\n  ))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem nextGreaterElement_spec_satisfied (nums1: List Int) (nums2: List Int) (h_precond : nextGreaterElement_precond (nums1) (nums2)) :\n    nextGreaterElement_postcond (nums1) (nums2) (nextGreaterElement (nums1) (nums2) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "nextGreaterElement",
    "parameters": {
      "param_name": [
        "nums1",
        "nums2"
      ],
      "param_type": [
        "List Int",
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/spiral-matrix-ii/",
      "task_id": "lab_nextGreaterElement_324720188",
      "student_id": [
        42
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums1\": \"[4, 1, 2]\", \"nums2\": \"[1, 3, 4, 2]\"}",
      "{\"nums1\": \"[2, 4]\", \"nums2\": \"[1, 2, 3, 4]\"}",
      "{\"nums1\": \"[1]\", \"nums2\": \"[1, 2]\"}",
      "{\"nums1\": \"[5]\", \"nums2\": \"[5, 4, 3, 2, 1]\"}",
      "{\"nums1\": \"[1, 3, 5, 2, 4]\", \"nums2\": \"[6, 5, 4, 3, 2, 1]\"}",
      "{\"nums1\": \"[1, 2, 3]\", \"nums2\": \"[3, 2, 1, 4]\"}",
      "{\"nums1\": \"[4, 3, 2, 1]\", \"nums2\": \"[4, 3, 2, 1]\"}"
    ],
    "expected": [
      [
        "[-1, 3, -1]"
      ],
      [
        "[3, -1]"
      ],
      [
        "[2]"
      ],
      [
        "[-1]"
      ],
      [
        "[-1, -1, -1, -1, -1]"
      ],
      [
        "[4, 4, 4]"
      ],
      [
        "[-1, -1, -1, -1]"
      ]
    ],
    "unexpected": [
      [
        "[3, -1, 3]"
      ],
      [
        "[-1, 3]"
      ],
      [
        "[-1]"
      ],
      [
        "[4]"
      ],
      [
        "[6, 5, 6, 3, 6]"
      ],
      [
        "[-1, -1, -1]"
      ],
      [
        "[3, 2, 1, -1]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'nums1': '[1, 3]', 'nums2': '[1, 2]'}",
      "{'nums1': '[1, 1]', 'nums2': '[1, 2]'}"
    ]
  },
  "difficulty": "advanced"
}