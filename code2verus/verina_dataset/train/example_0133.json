{
  "id": "verina_basic_79",
  "description": "-----Description-----\nGiven a nonempty array of integers and a valid index x (with 1 \u2264 x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\n-----Input-----\nThe input consists of:\n\u2022 a: An array of integers (assumed to be nonempty).\n\u2022 x: A natural number (Nat) such that 1 \u2264 x < a.size.\n\n-----Output-----\nThe output is a pair (m, p) where:\n\u2022 m is the maximum value among the first x elements of the array.\n\u2022 p is an index in the array, with x \u2264 p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size \u2212 1.\n\n-----Note-----\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 \u2264 x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef onlineMax_precond (a : Array Int) (x : Nat) : Prop :=\n  -- !benchmark @start precond\n  a.size > 0 \u2227 x < a.size\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef findBest (a : Array Int) (x : Nat) (i : Nat) (best : Int) : Int :=\n  if i < x then\n    let newBest := if a[i]! > best then a[i]! else best\n    findBest a x (i + 1) newBest\n  else best\n\ndef findP (a : Array Int) (x : Nat) (m : Int) (i : Nat) : Nat :=\n  if i < a.size then\n    if a[i]! > m then i else findP a x m (i + 1)\n  else a.size - 1\n-- !benchmark @end code_aux\n\n\ndef onlineMax (a : Array Int) (x : Nat) (h_precond : onlineMax_precond (a) (x)) : Int \u00d7 Nat :=\n  -- !benchmark @start code\n  let best := a[0]!\n  let m := findBest a x 1 best;\n  let p := findP a x m x;\n  (m, p)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef onlineMax_postcond (a : Array Int) (x : Nat) (result: Int \u00d7 Nat) (h_precond : onlineMax_precond (a) (x)) :=\n  -- !benchmark @start postcond\n  let (m, p) := result;\n  (x \u2264 p \u2227 p < a.size) \u2227\n  (\u2200 i, i < x \u2192 a[i]! \u2264 m) \u2227\n  (\u2203 i, i < x \u2227 a[i]! = m) \u2227\n  ((p < a.size - 1) \u2192 (\u2200 i, i < p \u2192 a[i]! < a[p]!)) \u2227\n  ((\u2200 i, x \u2264 i \u2192 i < a.size \u2192 a[i]! \u2264 m) \u2192 p = a.size - 1)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem onlineMax_spec_satisfied (a: Array Int) (x: Nat) (h_precond : onlineMax_precond (a) (x)) :\n    onlineMax_postcond (a) (x) (onlineMax (a) (x) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "onlineMax",
    "parameters": {
      "param_name": [
        "a",
        "x"
      ],
      "param_type": [
        "Array Int",
        "Nat"
      ]
    },
    "return_type": "Int \u00d7 Nat"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_online_max",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[3, 7, 5, 2, 9]\", \"x\": 3}",
      "{\"a\": \"#[10, 10, 5, 1]\", \"x\": 2}",
      "{\"a\": \"#[1, 3, 3, 3, 1]\", \"x\": 2}",
      "{\"a\": \"#[5, 4, 4, 6, 2]\", \"x\": 2}",
      "{\"a\": \"#[2, 8, 7, 7, 7]\", \"x\": 3}"
    ],
    "expected": [
      [
        "(7, 4)"
      ],
      [
        "(10, 3)"
      ],
      [
        "(3, 4)"
      ],
      [
        "(5, 3)"
      ],
      [
        "(8, 4)"
      ]
    ],
    "unexpected": [
      [
        "(7, 3)",
        "(5, 4)"
      ],
      [
        "(10, 2)",
        "(7, 3)"
      ],
      [
        "(2, 4)",
        "(3, 3)"
      ],
      [
        "(4, 2)",
        "(5, 2)",
        "(6, 3)"
      ],
      [
        "(7, 4)",
        "(8, 3)"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'a': '#[]', 'x': 2}"
    ]
  },
  "difficulty": "basic"
}