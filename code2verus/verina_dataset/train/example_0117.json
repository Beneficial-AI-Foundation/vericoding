{
  "id": "verina_basic_90",
  "description": "-----Description-----  \nThe task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----  \nThe input consists of:  \n\u2022 a: A non-empty 2D array of integers (Array (Array Int)). The array is guaranteed to contain at least one element.\n\u2022 key: An integer value (Int) to search for in the array.\n\n-----Output-----  \nThe output is a pair of integers (Int \u00d7 Int):  \n\u2022 If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.  \n\u2022 If the key is not found, the function returns (-1, -1).\n\n-----Note-----  \nIt is assumed that the input 2D array is sorted by rows and columns.\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n@[reducible, simp]\ndef get2d (a : Array (Array Int)) (i j : Int) : Int :=\n  (a[Int.toNat i]!)[Int.toNat j]!\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef SlopeSearch_precond (a : Array (Array Int)) (key : Int) : Prop :=\n  -- !benchmark @start precond\n  List.Pairwise (\u00b7.size = \u00b7.size) a.toList \u2227\n  a.all (fun x => List.Pairwise (\u00b7 \u2264 \u00b7) x.toList) \u2227\n  (\n    a.size = 0 \u2228 (\n      (List.range (a[0]!.size)).all (fun i =>\n        List.Pairwise (\u00b7 \u2264 \u00b7) (a.map (fun x => x[i]!)).toList\n      )\n    )\n  )\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef SlopeSearch (a : Array (Array Int)) (key : Int) (h_precond : SlopeSearch_precond (a) (key)) : (Int \u00d7 Int) :=\n  -- !benchmark @start code\n  let rows := a.size\n  let cols := if rows > 0 then (a[0]!).size else 0\n\n  let rec aux (m n : Int) (fuel : Nat) : (Int \u00d7 Int) :=\n    if fuel = 0 then (-1, -1)\n    else if m \u2265 Int.ofNat rows || n < 0 then (-1, -1)\n    else if get2d a m n = key then (m, n)\n    else if get2d a m n < key then\n      aux (m + 1) n (fuel - 1)\n    else\n      aux m (n - 1) (fuel - 1)\n\n  aux 0 (Int.ofNat (cols - 1)) (rows + cols)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef SlopeSearch_postcond (a : Array (Array Int)) (key : Int) (result: (Int \u00d7 Int)) (h_precond : SlopeSearch_precond (a) (key)) :=\n  -- !benchmark @start postcond\n  let (m, n) := result;\n  (m \u2265 0 \u2227 m < a.size \u2227 n \u2265 0 \u2227 n < (a[0]!).size \u2227 get2d a m n = key) \u2228\n  (m = -1 \u2227 n = -1 \u2227 a.all (fun x => x.all (fun e => e \u2260 key)))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem SlopeSearch_spec_satisfied (a: Array (Array Int)) (key: Int) (h_precond : SlopeSearch_precond (a) (key)) :\n    SlopeSearch_postcond (a) (key) (SlopeSearch (a) (key) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "SlopeSearch",
    "parameters": {
      "param_name": [
        "a",
        "key"
      ],
      "param_type": [
        "Array (Array Int)",
        "Int"
      ]
    },
    "return_type": "(Int \u00d7 Int)"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_slope_search",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\", \"key\": 5}",
      "{\"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\", \"key\": 3}",
      "{\"a\": \"#[#[1, 2, 3], #[4, 5, 6], #[7, 8, 9]]\", \"key\": 10}",
      "{\"a\": \"#[#[1, 2, 3, 4]]\", \"key\": 4}",
      "{\"a\": \"#[#[1], #[2], #[3], #[4]]\", \"key\": 3}"
    ],
    "expected": [
      [
        "(1, 1)"
      ],
      [
        "(0, 2)"
      ],
      [
        "(-1, -1)"
      ],
      [
        "(0, 3)"
      ],
      [
        "(2, 0)"
      ]
    ],
    "unexpected": [
      [
        "(1, 2)",
        "(0, 1)"
      ],
      [
        "(0, 1)",
        "(1, 2)"
      ],
      [
        "(1, 1)",
        "(2, 2)"
      ],
      [
        "(0, 2)",
        "(1, 3)",
        "(0, 4)"
      ],
      [
        "(1, 0)",
        "(2, 1)"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'a': '#[#[1, 3, 2], #[0, 6, 5], #[7, 8, 9]]', 'key': 2}"
    ]
  },
  "difficulty": "basic"
}