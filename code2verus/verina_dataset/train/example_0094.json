{
  "id": "verina_basic_94",
  "description": "-----Description-----\nThis task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n\u2022 s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n\u2022 The output array has the same size as the input array.\n\u2022 Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef iter_copy_precond (s : Array Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef iter_copy (s : Array Int) (h_precond : iter_copy_precond (s)) : Array Int :=\n  -- !benchmark @start code\n  let rec loop (i : Nat) (acc : Array Int) : Array Int :=\n    if i < s.size then\n      match s[i]? with\n      | some val => loop (i + 1) (acc.push val)\n      | none => acc  -- This case shouldn't happen when i < s.size\n    else\n      acc\n  loop 0 Array.empty\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef iter_copy_postcond (s : Array Int) (result: Array Int) (h_precond : iter_copy_precond (s)) :=\n  -- !benchmark @start postcond\n  (s.size = result.size) \u2227 (\u2200 i : Nat, i < s.size \u2192 s[i]! = result[i]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem iter_copy_spec_satisfied (s: Array Int) (h_precond : iter_copy_precond (s)) :\n    iter_copy_postcond (s) (iter_copy (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "iter_copy",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "Array Int"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_array_copy",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"#[1, 2, 3]\"}",
      "{\"s\": \"#[10, 20, 30, 40]\"}",
      "{\"s\": \"#[]\"}",
      "{\"s\": \"#[-1, -2, -3]\"}",
      "{\"s\": \"#[5, 5, 5, 5]\"}"
    ],
    "expected": [
      [
        "#[1, 2, 3]"
      ],
      [
        "#[10, 20, 30, 40]"
      ],
      [
        "#[]"
      ],
      [
        "#[-1, -2, -3]"
      ],
      [
        "#[5, 5, 5, 5]"
      ]
    ],
    "unexpected": [
      [
        "#[1, 3, 2]",
        "#[1, 2]"
      ],
      [
        "#[10, 20, 30]",
        "#[10, 20, 40, 30]"
      ],
      [
        "#[0]",
        "#[1]"
      ],
      [
        "#[-1, -3, -2]",
        "#[-1, -2]"
      ],
      [
        "#[5, 5, 5]",
        "#[5, 5, 5, 0]",
        "#[0, 5, 5, 5]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}