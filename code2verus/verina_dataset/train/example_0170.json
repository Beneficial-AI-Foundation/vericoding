{
  "id": "verina_basic_27",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that identifies the first repeated character in a given string. The method should return a tuple containing a Boolean value and a character. The Boolean value indicates whether any character in the string is repeated. If it is true, the accompanying character is the first character that appears more than once. If it is false, it indicates that there are no repeated characters in the string.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a tuple (Bool \u00d7 Char):\n- Returns true and the first repeated character in the string if any repeated character is found.\n- Returns false and an arbitrary character if no repeated characters are present.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.",
  "lean_code": "-- !benchmark @start import type=solution\nimport Std.Data.HashSet\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef findFirstRepeatedChar_precond (s : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef findFirstRepeatedChar (s : String) (h_precond : findFirstRepeatedChar_precond (s)) : Option Char :=\n  -- !benchmark @start code\n  let cs := s.toList\n  let rec loop (i : Nat) (seen : Std.HashSet Char) : Option Char :=\n    if i < cs.length then\n      let c := cs[i]!\n      if seen.contains c then\n        some c\n      else\n        loop (i + 1) (seen.insert c)\n    else\n      -- When no repeated char is found, return (false, arbitrary char)\n      none\n  loop 0 Std.HashSet.empty\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef findFirstRepeatedChar_postcond (s : String) (result: Option Char) (h_precond : findFirstRepeatedChar_precond (s)) :=\n  -- !benchmark @start postcond\n  let cs := s.toList\n  match result with\n  | some c =>\n    let secondIdx := cs.zipIdx.findIdx (fun (x, i) => x = c && i \u2260 cs.idxOf c)\n    -- Exists repeated char\n    cs.count c \u2265 2 \u2227\n    -- There is no other repeated char before the found one\n    List.Pairwise (\u00b7 \u2260 \u00b7) (cs.take secondIdx)\n  | none =>\n    -- There is no repeated char\n    List.Pairwise (\u00b7 \u2260 \u00b7) cs\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem findFirstRepeatedChar_spec_satisfied (s: String) (h_precond : findFirstRepeatedChar_precond (s)) :\n    findFirstRepeatedChar_postcond (s) (findFirstRepeatedChar (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "findFirstRepeatedChar",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "String"
      ]
    },
    "return_type": "Option Char"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_602",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"abca\"}",
      "{\"s\": \"abcdef\"}",
      "{\"s\": \"aabbcc\"}",
      "{\"s\": \"\"}",
      "{\"s\": \"abbc\"}",
      "{\"s\": \"Aa\"}"
    ],
    "expected": [
      [
        "some ('a')"
      ],
      [
        "none"
      ],
      [
        "some ('a')"
      ],
      [
        "none"
      ],
      [
        "some ('b')"
      ],
      [
        "none"
      ]
    ],
    "unexpected": [
      [
        "some ('b')",
        "some ('c')",
        "none"
      ],
      [
        "some ('a')",
        "some ('z')"
      ],
      [
        "some ('b')",
        "some ('c')",
        "none"
      ],
      [
        "some ('x')",
        "some ('y')"
      ],
      [
        "some ('a')",
        "some ('c')",
        "none"
      ],
      [
        "some ('A')",
        "some ('a')"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}