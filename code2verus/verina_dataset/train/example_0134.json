{
  "id": "verina_basic_81",
  "description": "-----Description-----  \nThis task involves performing integer division with remainder on natural numbers. Given two natural numbers, x (the dividend) and y (the divisor), the objective is to determine the quotient and remainder. When y is non-zero, the quotient and remainder should satisfy the condition that the dividend equals the divisor multiplied by the quotient plus the remainder, with the remainder being nonnegative and strictly less than y. In the case where y is zero, the result should indicate that no division is performed by returning x as the quotient and 0 as the remainder.\n\n-----Input-----  \nThe input consists of two natural numbers:  \n\u2022 x: A natural number representing the dividend.  \n\u2022 y: A natural number representing the divisor.\n\n-----Output-----  \nThe output is a pair of integers (r, q) where:  \n\u2022 If y \u2260 0, then q is the quotient and r is the remainder such that:  \n   - q * Int.ofNat y + r = Int.ofNat x  \n   - 0 \u2264 r < Int.ofNat y  \n   - 0 \u2264 q  \n\u2022 If y = 0, then the output is (Int.ofNat x, 0).\n\n-----Note-----  \nThe specification regarding the division properties applies only when y is non-zero. When y = 0, the function safely returns (x, 0) in its integer form.",
  "lean_code": "-- !benchmark @start import type=solution\nimport Mathlib\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef DivisionFunction_precond (x : Nat) (y : Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef divMod (x y : Nat) : Int \u00d7 Int :=\n  let q : Int := Int.ofNat (x / y)\n  let r : Int := Int.ofNat (x % y)\n  (r, q)\n-- !benchmark @end code_aux\n\n\ndef DivisionFunction (x : Nat) (y : Nat) (h_precond : DivisionFunction_precond (x) (y)) : Int \u00d7 Int :=\n  -- !benchmark @start code\n  if y = 0 then (Int.ofNat x, 0) else divMod x y\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef DivisionFunction_postcond (x : Nat) (y : Nat) (result: Int \u00d7 Int) (h_precond : DivisionFunction_precond (x) (y)) :=\n  -- !benchmark @start postcond\n  let (r, q) := result;\n  (y = 0 \u2192 r = Int.ofNat x \u2227 q = 0) \u2227\n  (y \u2260 0 \u2192 (q * Int.ofNat y + r = Int.ofNat x) \u2227 (0 \u2264 r \u2227 r < Int.ofNat y) \u2227 (0 \u2264 q))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem DivisionFunction_spec_satisfied (x: Nat) (y: Nat) (h_precond : DivisionFunction_precond (x) (y)) :\n    DivisionFunction_postcond (x) (y) (DivisionFunction (x) (y) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold DivisionFunction_postcond DivisionFunction\n  simp\n  split\n  {\n    simp\n    intro h\u2081\n    contradiction\n  }\n  {\n\n    have h_left : (\u00acy = 0 \u2192\n    (divMod x y).snd * \u2191y + (divMod x y).fst = \u2191x \u2227\n      (0 \u2264 (divMod x y).fst \u2227 (divMod x y).fst < \u2191y) \u2227 0 \u2264 (divMod x y).snd) := by\n      intro h\u2081\n      have h\u2081_left : (divMod x y).snd * \u2191y + (divMod x y).fst = \u2191x := by\n        unfold divMod\n        simp\n        have h\u2081 := Int.ediv_add_emod' x y\n        apply h\u2081\n      have h\u2081_right : (0 \u2264 (divMod x y).1 \u2227 (divMod x y).1 < \u2191y) \u2227 0 \u2264 (divMod x y).2 := by\n        have h\u2082_left : (0 \u2264 (divMod x y).1 \u2227 (divMod x y).1 < \u2191y) := by\n          have h\u2083_left : 0 \u2264 (divMod x y).1 := by\n            unfold divMod\n            simp\n            rw [\u2190Int.natCast_mod, \u2190Int.ofNat_eq_natCast]\n            have ha := Int.zero_le_ofNat (x % y)\n            apply ha\n          have h\u2083_right : (divMod x y).1 < \u2191y := by\n            unfold divMod\n            simp\n            rw [\u2190Int.natCast_mod]\n            have ha := @Int.natMod_lt x y h\u2081\n            rw [Int.natMod, \u2190Int.natCast_mod, Int.toNat_ofNat] at ha\n            rw [\u2190Mathlib.Tactic.Zify.natCast_lt]\n            apply ha\n          exact \u27e8h\u2083_left, h\u2083_right\u27e9\n\n        have h\u2082_right : 0 \u2264 (divMod x y).2 := by\n          unfold divMod\n          simp\n          rw [\u2190Int.natCast_div]\n          have ha := Int.natCast_nonneg (x / y)\n          apply ha\n        exact \u27e8h\u2082_left, h\u2082_right\u27e9\n      exact \u27e8h\u2081_left, h\u2081_right\u27e9\n    have h_right : (y = 0 \u2192 (divMod x y).fst = \u2191x \u2227 (divMod x y).snd = 0) := by\n      intro h\u2080\n      have h\u2081_left : (divMod x y).1 = \u2191x := by\n        unfold divMod\n        simp\n        rw [\u2190Int.natCast_mod, h\u2080, Nat.mod_zero]\n      have h\u2081_right : (divMod x y).snd = 0 := by\n        unfold divMod\n        simp\n        rw [\u2190Int.natCast_div, h\u2080, Nat.div_zero, \u2190@Int.cast_id 0]\n        rfl\n      exact \u27e8h\u2081_left, h\u2081_right\u27e9\n    constructor\n    \u00b7 simp_all [h_left]\n    \u00b7 simp_all [h_right]\n  }\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "DivisionFunction",
    "parameters": {
      "param_name": [
        "x",
        "y"
      ],
      "param_type": [
        "Nat",
        "Nat"
      ]
    },
    "return_type": "Int \u00d7 Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_quotient",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"x\": 10, \"y\": 3}",
      "{\"x\": 15, \"y\": 5}",
      "{\"x\": 7, \"y\": 2}",
      "{\"x\": 0, \"y\": 4}",
      "{\"x\": 10, \"y\": 0}"
    ],
    "expected": [
      [
        "(1, 3)"
      ],
      [
        "(0, 3)"
      ],
      [
        "(1, 3)"
      ],
      [
        "(0, 0)"
      ],
      [
        "(10, 0)"
      ]
    ],
    "unexpected": [
      [
        "(2, 2)",
        "(0, 3)",
        "(1, 4)"
      ],
      [
        "(3, 0)",
        "(1, 1)",
        "(0, 4)"
      ],
      [
        "(3, 1)",
        "(0, 7)",
        "(1, 2)"
      ],
      [
        "(0, 1)",
        "(1, 0)",
        "(2, 0)"
      ],
      [
        "(0, 10)",
        "(10, 1)",
        "(5, 5)"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}