{
  "id": "verina_advanced_8",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\n-----Input-----\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\n-----Output-----\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef canCompleteCircuit_precond (gas : List Int) (cost : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef canCompleteCircuit (gas : List Int) (cost : List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Int :=\n  -- !benchmark @start code\n  let totalGas := gas.foldl (\u00b7 + \u00b7) 0\n  let totalCost := cost.foldl (\u00b7 + \u00b7) 0\n\n  if totalGas < totalCost then\n    -1\n  else\n    let rec loop (g c : List Int) (idx : Nat) (tank : Int) (start : Nat) : Int :=\n      match g, c with\n      | [], [] => start\n      | gi :: gs, ci :: cs =>\n        let tank' := tank + gi - ci\n        if tank' < 0 then\n          loop gs cs (idx + 1) 0 (idx + 1)\n        else\n          loop gs cs (idx + 1) tank' start\n      | _, _ => -1  -- lengths don\u2019t match\n\n    let zipped := List.zip gas cost\n    let rec walk (pairs : List (Int \u00d7 Int)) (i : Nat) (tank : Int) (start : Nat) : Int :=\n      match pairs with\n      | [] => start\n      | (g, c) :: rest =>\n        let newTank := tank + g - c\n        if newTank < 0 then\n          walk rest (i + 1) 0 (i + 1)\n        else\n          walk rest (i + 1) newTank start\n\n    walk zipped 0 0 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef canCompleteCircuit_postcond (gas : List Int) (cost : List Int) (result: Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) : Prop :=\n  -- !benchmark @start postcond\n  let valid (start : Nat) := List.range gas.length |>.all (fun i =>\n    let acc := List.range (i + 1) |>.foldl (fun t j =>\n      let jdx := (start + j) % gas.length\n      t + gas[jdx]! - cost[jdx]!) 0\n    acc \u2265 0)\n  -- For result = -1: It's impossible to complete the circuit starting from any index\n  -- In other words, there's no starting point from which we can always maintain a non-negative gas tank\n  (result = -1 \u2192 (List.range gas.length).all (fun start => \u00ac valid start)) \u2227\n  -- For result \u2265 0: This is the valid starting point\n  -- When starting from this index, the gas tank never becomes negative during the entire circuit\n  (result \u2265 0 \u2192 result < gas.length \u2227 valid result.toNat \u2227 (List.range result.toNat).all (fun start => \u00ac valid start))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem canCompleteCircuit_spec_satisfied (gas: List Int) (cost: List Int) (h_precond : canCompleteCircuit_precond (gas) (cost)) :\n    canCompleteCircuit_postcond (gas) (cost) (canCompleteCircuit (gas) (cost) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "canCompleteCircuit",
    "parameters": {
      "param_name": [
        "gas",
        "cost"
      ],
      "param_type": [
        "List Int",
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/gas-station",
      "task_id": "lab_canCompleteCircuit_324678911",
      "student_id": [
        6
      ]
    }
  },
  "tests": {
    "input": [
      "{\"gas\": \"[1, 2, 3, 4, 5]\", \"cost\": \"[3, 4, 5, 1, 2]\"}",
      "{\"gas\": \"[2, 3, 4]\", \"cost\": \"[3, 4, 3]\"}",
      "{\"gas\": \"[5, 1, 2, 3, 4]\", \"cost\": \"[4, 4, 1, 5, 1]\"}",
      "{\"gas\": \"[3, 3, 4]\", \"cost\": \"[3, 4, 4]\"}",
      "{\"gas\": \"[1, 2, 3]\", \"cost\": \"[1, 2, 3]\"}",
      "{\"gas\": \"[1, 2, 3, 4]\", \"cost\": \"[2, 2, 2, 2]\"}",
      "{\"gas\": \"[0, 0, 0]\", \"cost\": \"[1, 1, 1]\"}"
    ],
    "expected": [
      [
        "3"
      ],
      [
        "-1"
      ],
      [
        "4"
      ],
      [
        "-1"
      ],
      [
        "0"
      ],
      [
        "1"
      ],
      [
        "-1"
      ]
    ],
    "unexpected": [
      [
        "-1",
        "0",
        "1",
        "2",
        "4"
      ],
      [
        "0",
        "1",
        "2",
        "3"
      ],
      [
        "-1",
        "0",
        "1",
        "2",
        "3"
      ],
      [
        "0",
        "1",
        "2"
      ],
      [
        "-1",
        "1",
        "2"
      ],
      [
        "-1",
        "0",
        "2",
        "3"
      ],
      [
        "0",
        "1",
        "2"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}