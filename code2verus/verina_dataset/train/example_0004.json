{
  "id": "verina_basic_95",
  "description": "-----Description-----  \nThis problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n\u2022 arr: An array of integers.  \n\u2022 i: An integer representing the first index (0-indexed) whose element is to be swapped.  \n\u2022 j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----  \nThe output is an array of integers which:  \n\u2022 Has the same size as the input array.  \n\u2022 Contains the element originally at index i in position j and the element originally at index j in position i.  \n\u2022 Leaves all other elements unchanged.\n\n-----Note-----  \nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., Int.toNat i and Int.toNat j are less than arr.size).",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef swap_precond (arr : Array Int) (i : Int) (j : Int) : Prop :=\n  -- !benchmark @start precond\n  i \u2265 0 \u2227\n  j \u2265 0 \u2227\n  Int.toNat i < arr.size \u2227\n  Int.toNat j < arr.size\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef swap (arr : Array Int) (i : Int) (j : Int) (h_precond : swap_precond (arr) (i) (j)) : Array Int :=\n  -- !benchmark @start code\n  let i_nat := Int.toNat i\n  let j_nat := Int.toNat j\n  let arr1 := arr.set! i_nat (arr[j_nat]!)\n  let arr2 := arr1.set! j_nat (arr[i_nat]!)\n  arr2\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef swap_postcond (arr : Array Int) (i : Int) (j : Int) (result: Array Int) (h_precond : swap_precond (arr) (i) (j)) :=\n  -- !benchmark @start postcond\n  (result[Int.toNat i]! = arr[Int.toNat j]!) \u2227\n  (result[Int.toNat j]! = arr[Int.toNat i]!) \u2227\n  (\u2200 (k : Nat), k < arr.size \u2192 k \u2260 Int.toNat i \u2192 k \u2260 Int.toNat j \u2192 result[k]! = arr[k]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem swap_spec_satisfied (arr: Array Int) (i: Int) (j: Int) (h_precond : swap_precond (arr) (i) (j)) :\n    swap_postcond (arr) (i) (j) (swap (arr) (i) (j) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold swap_postcond swap\n  unfold swap_precond at h_precond\n  obtain \u27e8h\u2081, h\u2082, h\u2083, h\u2084\u27e9 := h_precond\n\n  apply And.intro\n  . simp\n    by_cases h_eq : (i = j)\n    . rw [h_eq]\n      rw [Array.getElem!_eq_getD]\n      rw [Array.setIfInBounds]\n      simp [h\u2084]\n    . rw [Array.setIfInBounds_comm]\n      let arr\u2081 := arr.setIfInBounds j.toNat arr[i.toNat]!\n      have ha\u2081 : arr\u2081 = arr.setIfInBounds j.toNat arr[i.toNat]! := rfl\n      let arr_j := arr[j.toNat]!\n      have hi : arr_j = arr[j.toNat]! := rfl\n      rw [\u2190ha\u2081, \u2190hi]\n      have h\u2083' : i.toNat < (arr\u2081.setIfInBounds i.toNat arr_j).size := by\n        rw [ha\u2081]\n        unfold Array.setIfInBounds\n        split\n        . simp\n          split\n          . simp\n            exact h\u2083\n          . simp\n            exact h\u2083\n        . split\n          . simp\n            exact h\u2083\n          . simp\n            exact h\u2083\n      rw [Array.getElem!_eq_getD]\n      unfold Array.getD\n      split\n      . simp\n      . simp\n      intro h\n      have h_contr : i = j := by\n        rw [\u2190 Int.toNat_of_nonneg h\u2081, \u2190 Int.toNat_of_nonneg h\u2082]\n        rw [h]\n      contradiction\n  . apply And.intro\n    . simp\n      by_cases h_eq : (i = j)\n      . rw [h_eq]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.setIfInBounds]\n        simp [h\u2084]\n      . let arr\u2081 := arr.setIfInBounds i.toNat arr[j.toNat]!\n        have ha\u2081 : arr\u2081 = arr.setIfInBounds i.toNat arr[j.toNat]! := rfl\n        let arr_i := arr[i.toNat]!\n        have hi : arr_i = arr[i.toNat]! := rfl\n        rw [\u2190ha\u2081, \u2190hi]\n        have h\u2083' : j.toNat < (arr\u2081.setIfInBounds j.toNat arr_i).size := by\n          rw [ha\u2081]\n          unfold Array.setIfInBounds\n          split\n          . simp\n            split\n            . simp\n              exact h\u2084\n            . simp\n              exact h\u2084\n          . split\n            . simp\n              exact h\u2084\n            . simp\n              exact h\u2084\n        rw [Array.getElem!_eq_getD]\n        unfold Array.getD\n        split\n        . simp\n        . rename_i h\n          contradiction\n    . simp\n      intro k hk hki hkj\n      let arr\u2081 := (arr.setIfInBounds i.toNat arr[j.toNat]!)\n      let harr\u2081 : arr\u2081 = (arr.setIfInBounds i.toNat arr[j.toNat]!) := rfl\n      rw [\u2190harr\u2081]\n      have h\u2081 : arr\u2081[k]! = arr[k]! := by\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . rw [Array.getElem_setIfInBounds_ne arr arr[j.toNat]! hk]\n          rw [Array.getElem!_eq_getD]\n          rw [Array.getD]\n          simp\n          split\n          . rfl\n          . rfl\n          apply ne_comm.mp\n          exact hki\n        . rename_i h_contr\n          rw [harr\u2081] at h_contr\n          simp only [Array.size_setIfInBounds] at h_contr\n          contradiction\n      rw [Array.getElem!_eq_getD]\n      rw [Array.getD]\n      simp\n      split\n      . rw [Array.getElem_setIfInBounds_ne arr\u2081 arr[i.toNat]!]\n        rw [\u2190h\u2081]\n        rw [Array.getElem!_eq_getD]\n        rw [Array.getD]\n        simp\n        split\n        . simp\n        . simp\n        rename_i h\n        exact h\n        rw [ne_comm]\n        exact hkj\n      . rename_i h_contr\n        have h : arr.size = arr\u2081.size := by\n          rw [harr\u2081]\n          simp\n        rw [\u2190h] at h_contr\n        contradiction\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "swap",
    "parameters": {
      "param_name": [
        "arr",
        "i",
        "j"
      ],
      "param_type": [
        "Array Int",
        "Int",
        "Int"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_swap_in_array",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"arr\": \"#[1, 2, 3, 4, 5]\", \"i\": 1, \"j\": 3}",
      "{\"arr\": \"#[10, 20, 30, 40]\", \"i\": 0, \"j\": 3}",
      "{\"arr\": \"#[7, 8, 9]\", \"i\": 1, \"j\": 2}",
      "{\"arr\": \"#[1, 2, 3, 4]\", \"i\": 0, \"j\": 0}",
      "{\"arr\": \"#[-1, -2, -3]\", \"i\": 0, \"j\": 2}"
    ],
    "expected": [
      [
        "#[1, 4, 3, 2, 5]"
      ],
      [
        "#[40, 20, 30, 10]"
      ],
      [
        "#[7, 9, 8]"
      ],
      [
        "#[1, 2, 3, 4]"
      ],
      [
        "#[-3, -2, -1]"
      ]
    ],
    "unexpected": [
      [
        "#[1, 2, 3, 4, 5]",
        "#[1, 3, 2, 4, 5]"
      ],
      [
        "#[10, 40, 30, 20]",
        "#[10, 20, 40, 30]"
      ],
      [
        "#[8, 7, 9]",
        "#[9, 8, 7]"
      ],
      [
        "#[1, 2, 4, 3]",
        "#[4, 2, 3, 1]"
      ],
      [
        "#[-1, -2, -3]",
        "#[-3, -1, -2]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'arr': '#[1, 2, 3, 4]', 'i': -1, 'j': 2}"
    ]
  },
  "difficulty": "basic"
}