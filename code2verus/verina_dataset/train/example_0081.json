{
  "id": "verina_advanced_62",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\n-----Input-----\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\n-----Output-----\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef rain_precond (heights : List (Int)) : Prop :=\n  -- !benchmark @start precond\n  heights.all (fun h => h >= 0)\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef rain (heights : List (Int)) (h_precond : rain_precond (heights)) : Int :=\n  -- !benchmark @start code\n  -- Handle edge cases: need at least 3 elements to trap water\n  if heights.length < 3 then 0 else\n    let n := heights.length\n\n    -- Use two pointers approach for O(n) time with O(1) space\n    let rec aux (left : Nat) (right : Nat) (leftMax : Int) (rightMax : Int) (water : Int) : Int :=\n      if left >= right then\n        water  -- Base case: all elements processed\n      else if heights[left]! <= heights[right]! then\n        -- Process from the left\n        let newLeftMax := max leftMax (heights[left]!)\n        let newWater := water + max 0 (leftMax - heights[left]!)\n        aux (left+1) right newLeftMax rightMax newWater\n      else\n        -- Process from the right\n        let newRightMax := max rightMax (heights[right]!)\n        let newWater := water + max 0 (rightMax - heights[right]!)\n        aux left (right-1) leftMax newRightMax newWater\n      termination_by right - left\n    -- Initialize with two pointers at the ends\n    aux 0 (n-1) (heights[0]!) (heights[n-1]!) 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef rain_postcond (heights : List (Int)) (result: Int) (h_precond : rain_precond (heights)) : Prop :=\n  -- !benchmark @start postcond\n  -- The result is the total amount of rainwater trapped by the given terrain\n  -- If there are fewer than 3 elements, no water can be trapped\n  result >= 0 \u2227\n  -- The result is non-negative\n  if heights.length < 3 then result = 0 else\n    -- Water trapped at each position is min(maxLeft, maxRight) - height\n    result =\n      let max_left_at := \u03bb i =>\n        let rec ml (j : Nat) (max_so_far : Int) : Int :=\n          if j > i then max_so_far\n          else ml (j+1) (max max_so_far (heights[j]!))\n          termination_by i + 1 - j\n        ml 0 0\n\n      let max_right_at := \u03bb i =>\n        let rec mr (j : Nat) (max_so_far : Int) : Int :=\n          if j >= heights.length then max_so_far\n          else mr (j+1) (max max_so_far (heights[j]!))\n          termination_by heights.length - j\n        mr i 0\n\n      let water_at := \u03bb i =>\n        max 0 (min (max_left_at i) (max_right_at i) - heights[i]!)\n\n      let rec sum_water (i : Nat) (acc : Int) : Int :=\n        if i >= heights.length then acc\n        else sum_water (i+1) (acc + water_at i)\n        termination_by heights.length - i\n\n      sum_water 0 0\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem rain_spec_satisfied (heights: List (Int)) (h_precond : rain_precond (heights)) :\n    rain_postcond (heights) (rain (heights) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "rain",
    "parameters": {
      "param_name": [
        "heights"
      ],
      "param_type": [
        "List (Int)"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/trapping-rain-water/description/",
      "task_id": "lab_rain_327045007",
      "student_id": [
        46
      ]
    }
  },
  "tests": {
    "input": [
      "{\"heights\": \"[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\"}",
      "{\"heights\": \"[4, 2, 0, 3, 2, 5]\"}",
      "{\"heights\": \"[1, 1, 1]\"}",
      "{\"heights\": \"[10, 5]\"}",
      "{\"heights\": \"[1, 10, 9, 11]\"}",
      "{\"heights\": \"[]\"}"
    ],
    "expected": [
      [
        "6"
      ],
      [
        "9"
      ],
      [
        "0"
      ],
      [
        "0"
      ],
      [
        "1"
      ],
      [
        "0"
      ]
    ],
    "unexpected": [
      [
        "-1",
        "5",
        "7"
      ],
      [
        "-1",
        "8",
        "10"
      ],
      [
        "-1",
        "3",
        "1"
      ],
      [
        "-1",
        "5",
        "10"
      ],
      [
        "-1",
        "9",
        "2"
      ],
      [
        "-1",
        "100"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'heights': '[-1]'}"
    ]
  },
  "difficulty": "advanced"
}