{
  "id": "verina_basic_44",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\ndef isOdd (n : Int) : Bool :=\n  n % 2 == 1\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef isOddAtIndexOdd_precond (a : Array Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef isOddAtIndexOdd (a : Array Int) (h_precond : isOddAtIndexOdd_precond (a)) : Bool :=\n  -- !benchmark @start code\n  -- First create pairs of (index, value) for all elements in the array\n  let indexedArray := a.mapIdx fun i x => (i, x)\n\n  -- Check if all elements at odd indices are odd numbers\n  indexedArray.all fun (i, x) => !(isOdd i) || isOdd x\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef isOddAtIndexOdd_postcond (a : Array Int) (result: Bool) (h_precond : isOddAtIndexOdd_precond (a)) :=\n  -- !benchmark @start postcond\n  result \u2194 (\u2200 i, (hi : i < a.size) \u2192 isOdd i \u2192 isOdd (a[i]))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :\n    isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold isOddAtIndexOdd isOddAtIndexOdd_postcond\n  simp_all\n  constructor\n  \u00b7 intro h\n    intro i hi h_odd\n    -- Since the function returns true, all elements in satisfy the predicate\n    have h_all_odd : (a.mapIdx (fun j x => (j, x))).all (fun (i, x) => !(isOdd i) || isOdd x) = true := by\n      simp_all\n    -- Apply the property of Array.all\n    rw [Array.all_iff_forall] at h_all_odd\n    simp_all\n    have h_sat_i : !(isOdd i) || isOdd a[i] := by\n      simp\n      apply h_all_odd i hi\n    simp [h_odd] at h_sat_i\n    exact h_sat_i\n  \u00b7 intro h\n    apply Array.all_iff_forall.mpr\n    intro i hi\n    simp\n    intro hi'\n    have h_sat : isOdd i \u2192 isOdd a[i] := by\n      apply h i hi'\n    rw [Decidable.imp_iff_not_or] at h_sat\n    simp at h_sat\n    exact h_sat\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "isOddAtIndexOdd",
    "parameters": {
      "param_name": [
        "a"
      ],
      "param_type": [
        "Array Int"
      ]
    },
    "return_type": "Bool"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_775",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[1, 2, 3, 4, 5]\"}",
      "{\"a\": \"#[1, 3, 5, 7, 9]\"}",
      "{\"a\": \"#[2, 4, 6, 8, 10]\"}",
      "{\"a\": \"#[]\"}",
      "{\"a\": \"#[7]\"}",
      "{\"a\": \"#[0, 1, 0, 1]\"}",
      "{\"a\": \"#[0, 2, 4, 6]\"}"
    ],
    "expected": [
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ]
    ],
    "unexpected": [
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}