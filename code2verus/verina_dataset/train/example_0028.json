{
  "id": "verina_advanced_77",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that calculates how much water can be trapped between elevations after it rains. The input is a list of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\n-----Input-----\n- height: A list of natural numbers representing elevations.\n\n-----Output-----\n- A natural number: total units of water that can be trapped.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef trapRainWater_precond (height : List Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef trapRainWater (height : List Nat) (h_precond : trapRainWater_precond (height)) : Nat :=\n  -- !benchmark @start code\n  Id.run do\n    let mut left := 0\n    let mut right := height.length - 1\n    let mut leftMax := 0\n    let mut rightMax := 0\n    let mut water := 0\n\n    while left < right do\n      let hLeft := height[left]!\n      let hRight := height[right]!\n\n      if hLeft < hRight then\n        if hLeft >= leftMax then\n          leftMax := hLeft\n        else\n          water := water + (leftMax - hLeft)\n        left := left + 1\n      else\n        if hRight >= rightMax then\n          rightMax := hRight\n        else\n          water := water + (rightMax - hRight)\n        right := right - 1\n\n    return water\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef trapRainWater_postcond (height : List Nat) (result: Nat) (h_precond : trapRainWater_precond (height)) : Prop :=\n  -- !benchmark @start postcond\n  let waterAt := List.range height.length |>.map (fun i =>\n    let lmax := List.take (i+1) height |>.foldl Nat.max 0\n    let rmax := List.drop i height |>.foldl Nat.max 0\n    Nat.min lmax rmax - height[i]!)\n\n  result - (waterAt.foldl (\u00b7 + \u00b7) 0) = 0 \u2227 (waterAt.foldl (\u00b7 + \u00b7) 0) \u2264 result\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :\n    trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "trapRainWater",
    "parameters": {
      "param_name": [
        "height"
      ],
      "param_type": [
        "List Nat"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_trapRainWater_325601349",
      "student_id": [
        22
      ]
    }
  },
  "tests": {
    "input": [
      "{\"height\": \"[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\"}",
      "{\"height\": \"[4, 2, 0, 3, 2, 5]\"}",
      "{\"height\": \"[1, 0, 2]\"}",
      "{\"height\": \"[3, 0, 1, 3, 0, 5]\"}",
      "{\"height\": \"[0, 1, 2, 3, 4, 5]\"}",
      "{\"height\": \"[]\"}"
    ],
    "expected": [
      [
        "6"
      ],
      [
        "9"
      ],
      [
        "1"
      ],
      [
        "8"
      ],
      [
        "0"
      ],
      [
        "0"
      ]
    ],
    "unexpected": [
      [
        "5",
        "7"
      ],
      [
        "8"
      ],
      [
        "0",
        "2"
      ],
      [
        "6"
      ],
      [
        "1"
      ],
      [
        "1"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}