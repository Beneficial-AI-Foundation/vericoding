{
  "id": "verina_basic_87",
  "description": "-----Description-----  \nThis problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\n-----Input-----  \nThe input consists of:  \n\u2022 a: An array of integers (Array Int).  \n\n-----Output-----  \nThe output is an array of integers that is:  \n\u2022 Sorted in non-decreasing order.  \n\u2022 A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.  \n\n-----Note-----  \nIt is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef SelectionSort_precond (a : Array Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef findMinIndexInRange (arr : Array Int) (start finish : Nat) : Nat :=\n  let indices := List.range (finish - start)\n  indices.foldl (fun minIdx i =>\n    let currIdx := start + i\n    if arr[currIdx]! < arr[minIdx]! then currIdx else minIdx\n  ) start\n\ndef swap (a : Array Int) (i j : Nat) : Array Int :=\n  if i < a.size && j < a.size && i \u2260 j then\n    let temp := a[i]!\n    let a' := a.set! i a[j]!\n    a'.set! j temp\n  else a\n-- !benchmark @end code_aux\n\n\ndef SelectionSort (a : Array Int) (h_precond : SelectionSort_precond (a)) : Array Int :=\n  -- !benchmark @start code\n  let indices := List.range a.size\n  indices.foldl (fun arr i =>\n    let minIdx := findMinIndexInRange arr i a.size\n    swap arr i minIdx\n  ) a\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef SelectionSort_postcond (a : Array Int) (result: Array Int) (h_precond : SelectionSort_precond (a)) :=\n  -- !benchmark @start postcond\n  List.Pairwise (\u00b7 \u2264 \u00b7) result.toList \u2227 List.isPerm a.toList result.toList\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem SelectionSort_spec_satisfied (a: Array Int) (h_precond : SelectionSort_precond (a)) :\n    SelectionSort_postcond (a) (SelectionSort (a) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "SelectionSort",
    "parameters": {
      "param_name": [
        "a"
      ],
      "param_type": [
        "Array Int"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_selectionsort",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[3, 1, 2]\"}",
      "{\"a\": \"#[0]\"}",
      "{\"a\": \"#[5, 4, 3, 2, 1]\"}",
      "{\"a\": \"#[2, 2, 1, 4]\"}",
      "{\"a\": \"#[10, -5, 0, 3]\"}"
    ],
    "expected": [
      [
        "#[1, 2, 3]"
      ],
      [
        "#[0]"
      ],
      [
        "#[1, 2, 3, 4, 5]"
      ],
      [
        "#[1, 2, 2, 4]"
      ],
      [
        "#[-5, 0, 3, 10]"
      ]
    ],
    "unexpected": [
      [
        "#[3, 1, 2]",
        "#[2, 3, 1]"
      ],
      [
        "#[0, 0]",
        "#[1]"
      ],
      [
        "#[5, 4, 3, 2, 1]",
        "#[1, 5, 4, 3, 2]",
        "#[1, 2, 4, 3, 5]"
      ],
      [
        "#[2, 1, 2, 4]",
        "#[1, 2, 4, 2]"
      ],
      [
        "#[10, -5, 3, 0]",
        "#[0, -5, 3, 10]",
        "#[3, -5, 10, 0]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}