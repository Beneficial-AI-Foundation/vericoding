{
  "id": "verina_basic_71",
  "description": "-----Description-----  \nThis problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical. \n\n-----Input-----  \nThe input consists of:  \n\u2022 str1: A list of characters.  \n\u2022 str2: A list of characters.\n\n-----Output-----  \nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:  \n\u2022 Its length is less than or equal to the length of each input list.  \n\u2022 It is exactly the prefix of both str1 and str2.  \n\u2022 It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----  \nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef LongestCommonPrefix_precond (str1 : List Char) (str2 : List Char) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef LongestCommonPrefix (str1 : List Char) (str2 : List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) : List Char :=\n  -- !benchmark @start code\n  let minLength := Nat.min str1.length str2.length\n  let rec aux (idx : Nat) (acc : List Char) : List Char :=\n    if idx < minLength then\n      match str1[idx]?, str2[idx]? with\n      | some c1, some c2 =>\n          if c1 \u2260 c2 then acc\n          else aux (idx + 1) (acc ++ [c1])\n      | _, _ => acc\n    else acc\n  aux 0 []\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef LongestCommonPrefix_postcond (str1 : List Char) (str2 : List Char) (result: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :=\n  -- !benchmark @start postcond\n  (result.length \u2264 str1.length) \u2227 (result = str1.take result.length) \u2227\n  (result.length \u2264 str2.length) \u2227 (result = str2.take result.length) \u2227\n  (result.length = str1.length \u2228 result.length = str2.length \u2228\n    (str1[result.length]? \u2260 str2[result.length]?))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem LongestCommonPrefix_spec_satisfied (str1: List Char) (str2: List Char) (h_precond : LongestCommonPrefix_precond (str1) (str2)) :\n    LongestCommonPrefix_postcond (str1) (str2) (LongestCommonPrefix (str1) (str2) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "LongestCommonPrefix",
    "parameters": {
      "param_name": [
        "str1",
        "str2"
      ],
      "param_type": [
        "List Char",
        "List Char"
      ]
    },
    "return_type": "List Char"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_longest_prefix",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"str1\": \"['a', 'b', 'c']\", \"str2\": \"['a', 'b', 'd']\"}",
      "{\"str1\": \"['x', 'y', 'z']\", \"str2\": \"['x', 'y', 'z']\"}",
      "{\"str1\": \"['w', 'o']\", \"str2\": \"['w', 'o', 'w']\"}",
      "{\"str1\": \"['a', 'x']\", \"str2\": \"['b', 'y']\"}",
      "{\"str1\": \"[]\", \"str2\": \"['h', 'e', 'l', 'l', 'o']\"}"
    ],
    "expected": [
      [
        "['a', 'b']"
      ],
      [
        "['x', 'y', 'z']"
      ],
      [
        "['w', 'o']"
      ],
      [
        "[]"
      ],
      [
        "[]"
      ]
    ],
    "unexpected": [
      [
        "['a']",
        "['a', 'b', 'c']"
      ],
      [
        "['x', 'y']",
        "['x', 'z']"
      ],
      [
        "['w']",
        "['o']",
        "['w', 'o', 'w']"
      ],
      [
        "['a']",
        "['b']"
      ],
      [
        "['h']",
        "['e']"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}