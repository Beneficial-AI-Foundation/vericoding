{
  "id": "verina_basic_30",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\n-----Input----- \nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output----- \nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\n-----Note----- \nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef elementWiseModulo_precond (a : Array Int) (b : Array Int) : Prop :=\n  -- !benchmark @start precond\n  a.size = b.size \u2227 a.size > 0 \u2227\n  (\u2200 i, i < b.size \u2192 b[i]! \u2260 0)\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef elementWiseModulo (a : Array Int) (b : Array Int) (h_precond : elementWiseModulo_precond (a) (b)) : Array Int :=\n  -- !benchmark @start code\n  a.mapIdx (fun i x => x % b[i]!)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef elementWiseModulo_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :=\n  -- !benchmark @start postcond\n  result.size = a.size \u2227\n  (\u2200 i, i < result.size \u2192 result[i]! = a[i]! % b[i]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem elementWiseModulo_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : elementWiseModulo_precond (a) (b)) :\n    elementWiseModulo_postcond (a) (b) (elementWiseModulo (a) (b) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold elementWiseModulo elementWiseModulo_postcond\n  unfold elementWiseModulo_precond at h_precond\n  simp_all\n  intro i hi\n  have h_maplen : (Array.mapIdx (fun i x => x % b[i]!) a).size = a.size := by\n    apply Array.size_mapIdx\n  have h1 : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (fun i x => x % b[i]!) i a[i] := by\n    apply Array.getElem_mapIdx\n  have h_eq : (Array.mapIdx (fun i x => x % b[i]!) a)[i] = (Array.mapIdx (fun i x => x % b[i]!) a)[i]! := by\n    have hi' : i < (Array.mapIdx (fun i x => x % b[i]!) a).size := by\n      simp only [h_precond, hi, h_maplen]\n    rw [Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', hi, h_precond]\n  rw [\u2190 h_eq]\n  simp only [h1]\n  have h_eq' : a[i] = a[i]! := by\n    have hi_a : i < a.size := by\n      simp only [h_precond, hi]\n    simp_all [Array.getElem!_eq_getD]\n  simp only [h_eq']\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "elementWiseModulo",
    "parameters": {
      "param_name": [
        "a",
        "b"
      ],
      "param_type": [
        "Array Int",
        "Array Int"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_616",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[10, 20, 30]\", \"b\": \"#[3, 7, 5]\"}",
      "{\"a\": \"#[100, 200, 300, 400]\", \"b\": \"#[10, 20, 30, 50]\"}",
      "{\"a\": \"#[-10, -20, 30]\", \"b\": \"#[3, -7, 5]\"}"
    ],
    "expected": [
      [
        "#[1, 6, 0]"
      ],
      [
        "#[0, 0, 0, 0]"
      ],
      [
        "#[2, 1, 0]"
      ]
    ],
    "unexpected": [
      [
        "#[1, 0, 0]",
        "#[0, 6, 0]"
      ],
      [
        "#[0, 0, 0, 1]",
        "#[1, 0, 0, 0]"
      ],
      [
        "#[-1, -5, 0]",
        "#[-1, -6, 1]",
        "#[0, -6, 0]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'a': '#[1]', 'b': '#[4, 0]'}"
    ]
  },
  "difficulty": "basic"
}