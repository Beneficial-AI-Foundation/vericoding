{
  "id": "verina_advanced_59",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef palindromeIgnoreNonAlnum_precond (s : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef palindromeIgnoreNonAlnum (s : String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Bool :=\n  -- !benchmark @start code\n  let cleaned : List Char :=\n    s.data.filter (fun c => c.isAlpha || c.isDigit)\n      |>.map Char.toLower\n\n  let n := cleaned.length\n  let startIndex := 0\n  let endIndex := if n = 0 then 0 else n - 1\n\n  let rec check (l r : Nat) : Bool :=\n    if l >= r then\n      true\n    else if cleaned[l]? = cleaned[r]? then\n      check (l + 1) (r - 1)\n    else\n      false\n\n  check startIndex endIndex\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef palindromeIgnoreNonAlnum_postcond (s : String) (result: Bool) (h_precond : palindromeIgnoreNonAlnum_precond (s)) : Prop :=\n  -- !benchmark @start postcond\n  let cleaned := s.data.filter (fun c => c.isAlpha || c.isDigit) |>.map Char.toLower\nlet forward := cleaned\nlet backward := cleaned.reverse\n\nif result then\n  forward = backward\nelse\n  forward \u2260 backward\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem palindromeIgnoreNonAlnum_spec_satisfied (s: String) (h_precond : palindromeIgnoreNonAlnum_precond (s)) :\n    palindromeIgnoreNonAlnum_postcond (s) (palindromeIgnoreNonAlnum (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "palindromeIgnoreNonAlnum",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "String"
      ]
    },
    "return_type": "Bool"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "N/A",
      "task_id": "lab_palindromeIgnoreNonAlnum_325057855",
      "student_id": [
        17
      ]
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"\"}",
      "{\"s\": \"A man, a plan, a canal: Panama\"}",
      "{\"s\": \"race a car\"}",
      "{\"s\": \"No 'x' in Nixon\"}",
      "{\"s\": \"abc!!cba?\"}",
      "{\"s\": \"Hello, world!\"}"
    ],
    "expected": [
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ]
    ],
    "unexpected": [
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}