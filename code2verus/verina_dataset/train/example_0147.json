{
  "id": "verina_advanced_44",
  "description": "-----Description----- \nGiven an integer array arr and a positive integer k, this task requires writing a Lean 4 method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k, \nthe default return value should be 0.\n\n-----Input-----\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef maxSubarraySumDivisibleByK_precond (arr : Array Int) (k : Int) : Prop :=\n  -- !benchmark @start precond\n  k > 0\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef maxSubarraySumDivisibleByK (arr : Array Int) (k : Int) : Int :=\n  -- !benchmark @start code\n  let n := arr.size\n  if n = 0 || k = 0 then 0\n  else\n    --compute prefix sums for efficient subarray sum calculation\n    let prefixSums := Id.run do\n      let mut prefixSums := Array.mkArray (n + 1) 0\n      for i in [0:n] do\n        prefixSums := prefixSums.set! (i+1) (prefixSums[i]! + arr[i]!)\n      prefixSums\n\n    let minElem := Id.run do -- find minimum element\n      let mut minElem := arr[0]!\n      for elem in arr do\n        minElem := min minElem elem\n      minElem\n    let maxSum := Id.run do\n      let mut maxSum := minElem - 1\n      --check all subarrays with length divisible by k\n      for len in List.range (n+1) do\n        if len % k = 0 && len > 0 then\n          for start in [0:(n - len + 1)] do\n            let endIdx := start + len\n            let subarraySum := prefixSums[endIdx]! - prefixSums[start]!\n            maxSum := max maxSum subarraySum\n      maxSum\n\n    let default : Int := minElem - 1\n    if maxSum = default then 0 else maxSum\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef maxSubarraySumDivisibleByK_postcond (arr : Array Int) (k : Int) (result: Int) : Prop :=\n  -- !benchmark @start postcond\n  let subarrays := List.range (arr.size) |>.flatMap (fun start =>\n    List.range (arr.size - start + 1) |>.map (fun len => arr.extract start (start + len)))\n  let divisibleSubarrays := subarrays.filter (fun subarray => subarray.size % k = 0 && subarray.size > 0)\n  let subarraySums := divisibleSubarrays.map (fun subarray => subarray.sum)\n  (result = 0 \u2192 subarraySums.length = 0) \u2227\n  (result \u2260 0 \u2192 result \u2208 subarraySums \u2227 subarraySums.all (fun sum => sum \u2264 result))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem maxSubarraySumDivisibleByK_spec_satisfied (arr: Array Int) (k: Int) :\n    maxSubarraySumDivisibleByK_postcond (arr) (k) (maxSubarraySumDivisibleByK (arr) (k)) := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "maxSubarraySumDivisibleByK",
    "parameters": {
      "param_name": [
        "arr",
        "k"
      ],
      "param_type": [
        "Array Int",
        "Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/maximum-subarray-sum-with-length-divisible-by-k/description/",
      "task_id": "lab_maxSubarraySumDivisibleByK_325772368",
      "student_id": [
        36
      ]
    }
  },
  "tests": {
    "input": [
      "{\"arr\": \"#[1, 2, 3, 4, 5]\", \"k\": 2}",
      "{\"arr\": \"#[1, -2, 3, -4, 5]\", \"k\": 3}",
      "{\"arr\": \"#[]\", \"k\": 5}",
      "{\"arr\": \"#[1, 2, 3, 4]\", \"k\": 1}",
      "{\"arr\": \"#[-2, 7, 1, 3]\", \"k\": 2}",
      "{\"arr\": \"#[-100, 0, 1]\", \"k\": 5}",
      "{\"arr\": \"#[1999, 1, -1023, 12351, -9999]\", \"k\": 2}"
    ],
    "expected": [
      [
        "14"
      ],
      [
        "4"
      ],
      [
        "0"
      ],
      [
        "10"
      ],
      [
        "9"
      ],
      [
        "0"
      ],
      [
        "13328"
      ]
    ],
    "unexpected": [
      [
        "9",
        "5",
        "15",
        "10"
      ],
      [
        "2",
        "5",
        "3"
      ],
      [
        "-1"
      ],
      [
        "3",
        "4",
        "7",
        "9"
      ],
      [
        "8",
        "11",
        "7"
      ],
      [
        "1",
        "-99"
      ],
      [
        "1999",
        "12351",
        "3329",
        "2352"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}