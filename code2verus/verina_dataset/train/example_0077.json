{
  "id": "verina_advanced_31",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\nimport Mathlib.Data.List.Basic\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef longestIncreasingSubseqLength_precond (xs : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n-- Generate all subsequences\ndef subsequences {\u03b1 : Type} : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[]]\n  | x :: xs =>\n    let subs := subsequences xs\n    subs ++ subs.map (fun s => x :: s)\n\n-- Check if a list is strictly increasing\ndef isStrictlyIncreasing : List Int \u2192 Bool\n  | [] => true\n  | [_] => true\n  | x :: y :: rest => if x < y then isStrictlyIncreasing (y :: rest) else false\n-- !benchmark @end code_aux\n\n\ndef longestIncreasingSubseqLength (xs : List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Nat :=\n  -- !benchmark @start code\n  let subs := subsequences xs\n  let increasing := subs.filter isStrictlyIncreasing\n  increasing.foldl (fun acc s => max acc s.length) 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef longestIncreasingSubseqLength_postcond (xs : List Int) (result: Nat) (h_precond : longestIncreasingSubseqLength_precond (xs)) : Prop :=\n  -- !benchmark @start postcond\n  let allSubseq := (xs.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (\u00b7 < \u00b7) l) |>.map (\u00b7.length)\n  increasingSubseqLens.contains result \u2227 increasingSubseqLens.all (\u00b7 \u2264 result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem longestIncreasingSubseqLength_spec_satisfied (xs: List Int) (h_precond : longestIncreasingSubseqLength_precond (xs)) :\n    longestIncreasingSubseqLength_postcond (xs) (longestIncreasingSubseqLength (xs) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "longestIncreasingSubseqLength",
    "parameters": {
      "param_name": [
        "xs"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/valid-parentheses/description/",
      "task_id": "lab_longestIncreasingSubseqLength_325618023",
      "student_id": [
        25
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[1, 2, 3, 4]\"}",
      "{\"xs\": \"[4, 3, 2, 1]\"}",
      "{\"xs\": \"[1, 3, 2, 4, 0, 5]\"}",
      "{\"xs\": \"[]\"}",
      "{\"xs\": \"[5, 1, 6, 2, 7]\"}"
    ],
    "expected": [
      [
        "4"
      ],
      [
        "1"
      ],
      [
        "4"
      ],
      [
        "0"
      ],
      [
        "3"
      ]
    ],
    "unexpected": [
      [
        "3",
        "2",
        "1"
      ],
      [
        "2",
        "3",
        "4"
      ],
      [
        "3",
        "5"
      ],
      [
        "1"
      ],
      [
        "2",
        "4"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}