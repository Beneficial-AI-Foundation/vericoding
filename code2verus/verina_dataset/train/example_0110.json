{
  "id": "verina_basic_17",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\ndef isUpperCase (c : Char) : Bool :=\n  'A' \u2264 c \u2227 c \u2264 'Z'\n\ndef shift32 (c : Char) : Char :=\n  Char.ofNat (c.toNat + 32)\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef toLowercase_precond (s : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef toLowercase (s : String) (h_precond : toLowercase_precond (s)) : String :=\n  -- !benchmark @start code\n  let cs := s.toList\n  let cs' := cs.map (fun c => if isUpperCase c then shift32 c else c)\n  String.mk cs'\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef toLowercase_postcond (s : String) (result: String) (h_precond : toLowercase_precond (s)) :=\n  -- !benchmark @start postcond\n  let cs := s.toList\n  let cs' := result.toList\n  (result.length = s.length) \u2227\n  (\u2200 i : Nat, i < s.length \u2192\n    (isUpperCase cs[i]! \u2192 cs'[i]! = shift32 cs[i]!) \u2227\n    (\u00acisUpperCase cs[i]! \u2192 cs'[i]! = cs[i]!))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem toLowercase_spec_satisfied (s: String) (h_precond : toLowercase_precond (s)) :\n    toLowercase_postcond (s) (toLowercase (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold toLowercase toLowercase_postcond\n  simp_all\n  constructor\n  \u00b7 unfold String.length\n    simp\n  \u00b7 intro i hi\n    have hi' : i < s.data.length := by\n      unfold String.length at hi\n      simp at hi\n      exact hi\n    constructor <;> simp_all\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "toLowercase",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "String"
      ]
    },
    "return_type": "String"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_477",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"Hello, World!\"}",
      "{\"s\": \"ABC\"}",
      "{\"s\": \"abc\"}",
      "{\"s\": \"\"}",
      "{\"s\": \"1234!@\"}",
      "{\"s\": \"MixedCASE123\"}"
    ],
    "expected": [
      [
        "hello, world!"
      ],
      [
        "abc"
      ],
      [
        "abc"
      ],
      [
        ""
      ],
      [
        "1234!@"
      ],
      [
        "mixedcase123"
      ]
    ],
    "unexpected": [
      [
        "Hello, world!",
        "HELLO, WORLD!",
        "hello, World!"
      ],
      [
        "ABC",
        "Abc",
        "aBC"
      ],
      [
        "ABC",
        "aBc",
        "abC"
      ],
      [
        " ",
        "empty",
        "null"
      ],
      [
        "1234!#",
        "12345!@"
      ],
      [
        "Mixedcase123",
        "mixedCASE123",
        "MIXEDCASE123"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}