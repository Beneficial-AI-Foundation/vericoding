{
  "id": "verina_basic_33",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that returns the smallest natural number missing from a given sorted list of natural numbers. In other words, starting from 0, the method should identify the first natural number that does not appear in the list. The input list is assumed to be sorted in non-decreasing order and contains only natural numbers (including 0).\n\n-----Input-----\nThe input consists of:\ns: A list of natural numbers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that does not appear in the input list.\n\n-----Note-----\nIt is assumed that the input list is sorted and contains only natural numbers.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef smallestMissingNumber_precond (s : List Nat) : Prop :=\n  -- !benchmark @start precond\n  List.Pairwise (\u00b7 \u2264 \u00b7) s\n  -- !benchmark @end precond\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef smallestMissingNumber (s : List Nat) (h_precond : smallestMissingNumber_precond (s)) : Nat :=\n  -- !benchmark @start code\n  let rec findMissing (v : Nat) (l : List Nat) : Nat :=\n    match l with\n    | [] => v\n    | x :: xs =>\n      if x > v then v\n      else if x = v then findMissing (v + 1) xs\n      else findMissing v xs\n  findMissing 0 s\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef smallestMissingNumber_postcond (s : List Nat) (result: Nat) (h_precond : smallestMissingNumber_precond (s)) :=\n  -- !benchmark @start postcond\n  \u00ac List.elem result s \u2227 (\u2200 k : Nat, k < result \u2192 List.elem k s)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem smallestMissingNumber_spec_satisfied (s: List Nat) (h_precond : smallestMissingNumber_precond (s)) :\n    smallestMissingNumber_postcond (s) (smallestMissingNumber (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "smallestMissingNumber",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "List Nat"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_627",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"[0, 1, 2, 6, 9]\"}",
      "{\"s\": \"[4, 5, 10, 11]\"}",
      "{\"s\": \"[0, 1, 2, 3, 4, 5]\"}",
      "{\"s\": \"[]\"}",
      "{\"s\": \"[0, 2, 3, 4]\"}"
    ],
    "expected": [
      [
        "3"
      ],
      [
        "0"
      ],
      [
        "6"
      ],
      [
        "0"
      ],
      [
        "1"
      ]
    ],
    "unexpected": [
      [
        "2",
        "4",
        "5"
      ],
      [
        "1",
        "2"
      ],
      [
        "5",
        "7"
      ],
      [
        "1",
        "2"
      ],
      [
        "0",
        "2",
        "3"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'s': '[3, 2, 1]'}"
    ]
  },
  "difficulty": "basic"
}