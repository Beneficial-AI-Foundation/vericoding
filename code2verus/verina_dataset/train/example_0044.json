{
  "id": "verina_basic_35",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that rearranges an array of integers by moving all zero values to the end of the array. The method should ensure that the relative order of the non-zero elements remains the same, the overall size of the array is unchanged, and the number of zeroes in the array stays constant.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array where:\n- The length is the same as that of the input array.\n- All zero values are positioned at the end.\n- The relative order of non-zero elements is preserved.\n- The count of zero values remains the same as in the input array.\n\n-----Note-----\nThere are no preconditions; the method will always work for any array of integers.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef MoveZeroesToEnd_precond (arr : Array Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef MoveZeroesToEnd (arr : Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) : Array Int :=\n  -- !benchmark @start code\n  let nonZeros := arr.toList.filter (\u00b7 \u2260 0)\n  let zeros := arr.toList.filter (\u00b7 = 0)\n  Array.mk (nonZeros ++ zeros)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef MoveZeroesToEnd_postcond (arr : Array Int) (result: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :=\n  -- !benchmark @start postcond\n  let firstResZeroIdx := result.toList.idxOf 0\n  List.isPerm result.toList arr.toList \u2227\n  result.toList.take firstResZeroIdx = arr.toList.filter (\u00b7 \u2260 0) \u2227\n  result.toList.drop firstResZeroIdx = arr.toList.filter (\u00b7 = 0)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem MoveZeroesToEnd_spec_satisfied (arr: Array Int) (h_precond : MoveZeroesToEnd_precond (arr)) :\n    MoveZeroesToEnd_postcond (arr) (MoveZeroesToEnd (arr) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "MoveZeroesToEnd",
    "parameters": {
      "param_name": [
        "arr"
      ],
      "param_type": [
        "Array Int"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_632",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"arr\": \"#[0, 1, 0, 3, 12]\"}",
      "{\"arr\": \"#[0, 0, 1]\"}",
      "{\"arr\": \"#[1, 2, 3]\"}",
      "{\"arr\": \"#[0, 0, 0]\"}",
      "{\"arr\": \"#[]\"}"
    ],
    "expected": [
      [
        "#[1, 3, 12, 0, 0]"
      ],
      [
        "#[1, 0, 0]"
      ],
      [
        "#[1, 2, 3]"
      ],
      [
        "#[0, 0, 0]"
      ],
      [
        "#[]"
      ]
    ],
    "unexpected": [
      [
        "#[0, 1, 0, 3, 12]",
        "#[1, 0, 3, 12, 0]"
      ],
      [
        "#[0, 0, 1]",
        "#[0, 1, 0]"
      ],
      [
        "#[1, 3, 2]",
        "#[2, 1, 3]"
      ],
      [
        "#[1, 0, 0]",
        "#[0, 1, 0]"
      ],
      [
        "#[0]",
        "#[1]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}