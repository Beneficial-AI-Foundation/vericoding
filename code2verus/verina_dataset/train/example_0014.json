{
  "id": "verina_advanced_56",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that moves all zeroes in a given integer list to the end, while preserving the relative order of the non-zero elements.\n\nThe method `moveZeroes` processes the input list by separating the non-zero and zero elements. It then returns a new list formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single list of integers:\nxs: A list of integers (type: List Int), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list (type: List Int) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef moveZeroes_precond (xs : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n-- Count how many times a specific value appears in the list\n\n-- !benchmark @end code_aux\n\n\ndef moveZeroes (xs : List Int) (h_precond : moveZeroes_precond (xs)) : List Int :=\n  -- !benchmark @start code\n  let nonzeros := xs.filter (fun x => x \u2260 0)\n  let zeros := xs.filter (fun x => x = 0)\n  nonzeros ++ zeros\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\ndef countVal (val : Int) : List Int \u2192 Nat\n  | [] => 0\n  | x :: xs =>\n    let rest := countVal val xs\n    if x = val then rest + 1 else rest\n\n-- Check whether one list is a subsequence of another (preserving relative order)\ndef isSubsequence (xs ys : List Int) : Bool :=\n  match xs, ys with\n  | [], _ => true\n  | _ :: _, [] => false\n  | x :: xt, y :: yt =>\n    if x = y then isSubsequence xt yt else isSubsequence xs yt\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef moveZeroes_postcond (xs : List Int) (result: List Int) (h_precond : moveZeroes_precond (xs)) : Prop :=\n  -- !benchmark @start postcond\n  -- 1. All non-zero elements must maintain their relative order\n  isSubsequence (xs.filter (fun x => x \u2260 0)) result = true \u2227\n\n  -- 2. All zeroes must be located at the end of the output list\n  (result.dropWhile (fun x => x \u2260 0)).all (fun x => x = 0) \u2227\n\n  -- 3. The output must contain the same number of elements,\n  --    and the number of zeroes must remain unchanged\n  countVal 0 xs = countVal 0 result \u2227\n  xs.length = result.length\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem moveZeroes_spec_satisfied (xs: List Int) (h_precond : moveZeroes_precond (xs)) :\n    moveZeroes_postcond (xs) (moveZeroes (xs) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "moveZeroes",
    "parameters": {
      "param_name": [
        "xs"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/move-zeroes/description/",
      "task_id": "lab_moveZeroes_324883943",
      "student_id": [
        41
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[0, 1, 0, 3, 12]\"}",
      "{\"xs\": \"[0, 0, 1]\"}",
      "{\"xs\": \"[1, 2, 3]\"}",
      "{\"xs\": \"[0, 0, 0]\"}",
      "{\"xs\": \"[]\"}",
      "{\"xs\": \"[4, 0, 5, 0, 6]\"}",
      "{\"xs\": \"[0, 1]\"}",
      "{\"xs\": \"[1, 0]\"}",
      "{\"xs\": \"[2, 0, 0, 3]\"}"
    ],
    "expected": [
      [
        "[1, 3, 12, 0, 0]"
      ],
      [
        "[1, 0, 0]"
      ],
      [
        "[1, 2, 3]"
      ],
      [
        "[0, 0, 0]"
      ],
      [
        "[]"
      ],
      [
        "[4, 5, 6, 0, 0]"
      ],
      [
        "[1, 0]"
      ],
      [
        "[1, 0]"
      ],
      [
        "[2, 3, 0, 0]"
      ]
    ],
    "unexpected": [
      [
        "[0, 1, 3, 12, 0]"
      ],
      [
        "[0, 1, 0]"
      ],
      [
        "[1, 3, 2]",
        "[0, 1, 2, 3]"
      ],
      [
        "[0, 0]",
        "[]",
        "[0]"
      ],
      [
        "[0]"
      ],
      [
        "[0, 4, 5, 6, 0]"
      ],
      [
        "[0, 1]"
      ],
      [
        "[0, 1]"
      ],
      [
        "[0, 0, 2, 3]",
        "[2, 0, 3, 0]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}