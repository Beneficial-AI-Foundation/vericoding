{
  "id": "verina_advanced_79",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that implementing the \"Two Sum\" problem. Given a list of integers \nand a target integer, the function should return the indices of the two numbers that add up to \nthe target. If no valid pair exists, the function should return none. And the indices returned must \nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that \n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef twoSum_precond (nums : List Int) (target : Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Option (Nat \u00d7 Nat) :=\n  -- !benchmark @start code\n  let rec outer (lst : List Int) (i : Nat)\n            : Option (Nat \u00d7 Nat) :=\n        match lst with\n        | [] =>\n            none\n        | x :: xs =>\n            let rec inner (lst' : List Int) (j : Nat)\n                    : Option Nat :=\n                match lst' with\n                | [] =>\n                    none\n                | y :: ys =>\n                    if x + y = target then\n                        some j\n                    else\n                        inner ys (j + 1)\n            match inner xs (i + 1) with\n            | some j =>\n                some (i, j)\n            | none =>\n                outer xs (i + 1)\n        outer nums 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef twoSum_postcond (nums : List Int) (target : Int) (result: Option (Nat \u00d7 Nat)) (h_precond : twoSum_precond (nums) (target)) : Prop :=\n  -- !benchmark @start postcond\n    match result with\n    | none => List.Pairwise (\u00b7 + \u00b7 \u2260 target) nums\n    | some (i, j) =>\n        i < j \u2227\n        j < nums.length \u2227\n        nums[i]! + nums[j]! = target \u2227\n        -- i must be the first i\n        List.Pairwise (fun a b => a + b \u2260 target) (nums.take i) \u2227\n        List.all (nums.take i) (fun a => List.all (nums.drop i) (fun b => a + b \u2260 target) ) \u2227\n        -- j must be the first j\n        List.all (nums.drop (j + 1)) (fun a => a + nums[j]! \u2260 target)\n\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :\n    twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "twoSum",
    "parameters": {
      "param_name": [
        "nums",
        "target"
      ],
      "param_type": [
        "List Int",
        "Int"
      ]
    },
    "return_type": "Option (Nat \u00d7 Nat)"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/two-sum/description/",
      "task_id": "lab_twoSum_325525518",
      "student_id": [
        27
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums\": \"[2, 7, 11, 15]\", \"target\": 9}",
      "{\"nums\": \"[3, 2, 4]\", \"target\": 6}",
      "{\"nums\": \"[3, 3]\", \"target\": 6}",
      "{\"nums\": \"[1, 2, 3]\", \"target\": 7}",
      "{\"nums\": \"[0, 4, 3, 0]\", \"target\": 0}"
    ],
    "expected": [
      [
        "some (0, 1)"
      ],
      [
        "some (1, 2)"
      ],
      [
        "some (0, 1)"
      ],
      [
        "none"
      ],
      [
        "some (0, 3)"
      ]
    ],
    "unexpected": [
      [
        "some (1, 2)",
        "none"
      ],
      [
        "some (0, 2)",
        "none"
      ],
      [
        "some (1, 1)",
        "none"
      ],
      [
        "some (0, 2)"
      ],
      [
        "some (1, 2)",
        "none"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}