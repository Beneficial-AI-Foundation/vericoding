{
  "id": "verina_advanced_64",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (List Nat).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef removeElement_precond (lst : List Nat) (target : Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef removeElement (lst : List Nat) (target : Nat) (h_precond : removeElement_precond (lst) (target)) : List Nat :=\n  -- !benchmark @start code\n  let rec helper (lst : List Nat) (target : Nat) : List Nat :=\n    match lst with\n    | [] => []\n    | x :: xs =>\n      let rest := helper xs target\n      if x = target then rest else x :: rest\n  helper lst target\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef removeElement_postcond (lst : List Nat) (target : Nat) (result: List Nat) (h_precond : removeElement_precond (lst) (target)): Prop :=\n  -- !benchmark @start postcond\n  -- 1. All elements equal to target are removed from the result.\n  -- 2. All other elements are preserved in order.\n  -- 3. No new elements are added.\n\n  -- Helper predicate: result contains exactly the elements of lst that are not equal to target, in order\n  let lst' := lst.filter (fun x => x \u2260 target)\n  result.zipIdx.all (fun (x, i) =>\n    match lst'[i]? with\n    | some y => x = y\n    | none => false) \u2227 result.length = lst'.length\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n-- !benchmark @end proof_aux\n\n\ntheorem removeElement_spec_satisfied (lst: List Nat) (target: Nat) (h_precond : removeElement_precond (lst) (target)):\n    removeElement_postcond (lst) (target) (removeElement (lst) (target) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "removeElement",
    "parameters": {
      "param_name": [
        "lst",
        "target"
      ],
      "param_type": [
        "List Nat",
        "Nat"
      ]
    },
    "return_type": "List Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/remove-element/",
      "task_id": "lab_removeElement_323929890",
      "student_id": [
        47
      ]
    }
  },
  "tests": {
    "input": [
      "{\"lst\": \"[1, 2, 3, 2, 4]\", \"target\": 2}",
      "{\"lst\": \"[5, 5, 5, 5]\", \"target\": 5}",
      "{\"lst\": \"[7, 8, 9]\", \"target\": 4}",
      "{\"lst\": \"[]\", \"target\": 3}",
      "{\"lst\": \"[0, 1, 0, 2, 0]\", \"target\": 0}"
    ],
    "expected": [
      [
        "[1, 3, 4]"
      ],
      [
        "[]"
      ],
      [
        "[7, 8, 9]"
      ],
      [
        "[]"
      ],
      [
        "[1, 2]"
      ]
    ],
    "unexpected": [
      [
        "[1, 2, 3, 4]",
        "[1, 2, 3]",
        "[1, 4]"
      ],
      [
        "[5]",
        "[0]",
        "[5, 5]"
      ],
      [
        "[]",
        "[7, 8]",
        "[8, 9]"
      ],
      [
        "[3]",
        "[0]",
        "[1, 2, 3]"
      ],
      [
        "[0, 1, 2]",
        "[1]",
        "[1, 0, 2]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}