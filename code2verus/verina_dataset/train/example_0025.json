{
  "id": "verina_basic_39",
  "description": "-----Description-----  \nThis task requires writing a Lean 4 method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----  \nThe input consists of:  \n\u2022 l: A list of integers.  \n\u2022 n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----  \nThe output is a list of integers:  \n\u2022 Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----  \n\u2022 The precondition requires that n is non-negative.  \n\u2022 If the input list is empty, it should be returned unchanged.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef rotateRight_precond (l : List Int) (n : Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef rotateRight (l : List Int) (n : Nat) (h_precond : rotateRight_precond (l) (n)) : List Int :=\n  -- !benchmark @start code\n  let len := l.length\n  if len = 0 then l\n  else\n    (List.range len).map (fun i : Nat =>\n      let idx_int : Int := ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n      let idx_nat : Nat := Int.toNat idx_int\n      l.getD idx_nat (l.headD 0)\n    )\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef rotateRight_postcond (l : List Int) (n : Nat) (result: List Int) (h_precond : rotateRight_precond (l) (n)) :=\n  -- !benchmark @start postcond\n  result.length = l.length \u2227\n  (\u2200 i : Nat, i < l.length \u2192\n    let len := l.length\n    let rotated_index := Int.toNat ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)\n    result[i]? = l[rotated_index]?)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :\n    rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "rotateRight",
    "parameters": {
      "param_name": [
        "l",
        "n"
      ],
      "param_type": [
        "List Int",
        "Nat"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_743",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"l\": \"[1, 2, 3, 4, 5]\", \"n\": 2}",
      "{\"l\": \"[1, 2, 3, 4, 5]\", \"n\": 7}",
      "{\"l\": \"[1, 2, 3, 4, 5]\", \"n\": 0}",
      "{\"l\": \"[]\", \"n\": 2}"
    ],
    "expected": [
      [
        "4",
        "5",
        "1",
        "2",
        "3"
      ],
      [
        "4",
        "5",
        "1",
        "2",
        "3"
      ],
      [
        "1",
        "2",
        "3",
        "4",
        "5"
      ],
      []
    ],
    "unexpected": [
      [
        "[5, 1, 2, 3, 4]",
        "[3, 4, 5, 1, 2]"
      ],
      [
        "[5, 1, 2, 3, 4]",
        "[3, 4, 5, 1, 2]"
      ],
      [
        "[5, 1, 2, 3, 4]",
        "[4, 5, 1, 2, 3]"
      ],
      [
        "[0]",
        "[42]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}