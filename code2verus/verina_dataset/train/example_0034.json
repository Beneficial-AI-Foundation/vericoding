{
  "id": "verina_basic_56",
  "description": "-----Description-----  \nThe problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\n-----Input-----  \nThe input consists of:  \n\u2022 src: An array of integers representing the source array.  \n\u2022 sStart: A natural number indicating the starting index in src from where to begin copying.  \n\u2022 dest: An array of integers representing the destination array.  \n\u2022 dStart: A natural number indicating the starting index in dest where the segment will be replaced.  \n\u2022 len: A natural number specifying the number of elements to copy.\n\n-----Output-----  \nThe output is an array of integers that:  \n\u2022 Has the same size as the destination array (dest).  \n\u2022 Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.  \n\u2022 Under the preconditions that src.size \u2265 sStart + len and dest.size \u2265 dStart + len, guarantees that:  \n  - All elements with indices less than dStart remain as in dest.  \n  - All elements with indices greater than or equal to dStart + len remain as in dest.  \n  - For each index i with 0 \u2264 i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\n-----Note-----  \nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef copy_precond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) : Prop :=\n  -- !benchmark @start precond\n  src.size \u2265 sStart + len \u2227\n  dest.size \u2265 dStart + len\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef updateSegment : Array Int \u2192 Array Int \u2192 Nat \u2192 Nat \u2192 Nat \u2192 Array Int\n  | r, src, sStart, dStart, 0 => r\n  | r, src, sStart, dStart, n+1 =>\n      let rNew := r.set! (dStart + n) (src[sStart + n]!)\n      updateSegment rNew src sStart dStart n\n-- !benchmark @end code_aux\n\n\ndef copy (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) : Array Int :=\n  -- !benchmark @start code\n  if len = 0 then dest\n  else\n    let r := dest\n    updateSegment r src sStart dStart len\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef copy_postcond (src : Array Int) (sStart : Nat) (dest : Array Int) (dStart : Nat) (len : Nat) (result: Array Int) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :=\n  -- !benchmark @start postcond\n  result.size = dest.size \u2227\n  (\u2200 i, i < dStart \u2192 result[i]! = dest[i]!) \u2227\n  (\u2200 i, dStart + len \u2264 i \u2192 i < result.size \u2192 result[i]! = dest[i]!) \u2227\n  (\u2200 i, i < len \u2192 result[dStart + i]! = src[sStart + i]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem copy_spec_satisfied (src: Array Int) (sStart: Nat) (dest: Array Int) (dStart: Nat) (len: Nat) (h_precond : copy_precond (src) (sStart) (dest) (dStart) (len)) :\n    copy_postcond (src) (sStart) (dest) (dStart) (len) (copy (src) (sStart) (dest) (dStart) (len) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "copy",
    "parameters": {
      "param_name": [
        "src",
        "sStart",
        "dest",
        "dStart",
        "len"
      ],
      "param_type": [
        "Array Int",
        "Nat",
        "Array Int",
        "Nat",
        "Nat"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_copy_part",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"src\": \"#[10, 20, 30, 40, 50]\", \"sStart\": 1, \"dest\": \"#[1, 2, 3, 4, 5, 6]\", \"dStart\": 3, \"len\": 2}",
      "{\"src\": \"#[5, 6, 7, 8]\", \"sStart\": 0, \"dest\": \"#[9, 9, 9, 9, 9]\", \"dStart\": 1, \"len\": 3}",
      "{\"src\": \"#[100, 200]\", \"sStart\": 0, \"dest\": \"#[1, 2, 3]\", \"dStart\": 1, \"len\": 0}",
      "{\"src\": \"#[10, 20, 30, 40, 50]\", \"sStart\": 0, \"dest\": \"#[0, 0, 0, 0, 0]\", \"dStart\": 0, \"len\": 5}",
      "{\"src\": \"#[7, 8, 9, 10]\", \"sStart\": 2, \"dest\": \"#[1, 2, 3, 4, 5, 6]\", \"dStart\": 4, \"len\": 2}"
    ],
    "expected": [
      [
        "#[1, 2, 3, 20, 30, 6]"
      ],
      [
        "#[9, 5, 6, 7, 9]"
      ],
      [
        "#[1, 2, 3]"
      ],
      [
        "#[10, 20, 30, 40, 50]"
      ],
      [
        "#[1, 2, 3, 4, 9, 10]"
      ]
    ],
    "unexpected": [
      [
        "#[1, 2, 3, 10, 30, 6]",
        "#[1, 2, 3, 20, 40, 6]",
        "#[1, 2, 20, 30, 6, 0]"
      ],
      [
        "#[9, 9, 5, 7, 9]",
        "#[9, 5, 7, 6, 9]",
        "#[9, 5, 6, 9, 9]"
      ],
      [
        "#[1, 0, 3]",
        "#[0, 2, 3]",
        "#[1, 2, 0]"
      ],
      [
        "#[10, 20, 30, 40, 60]",
        "#[0, 20, 30, 40, 50]",
        "#[10, 20, 30, 40, 0]"
      ],
      [
        "#[1, 2, 3, 9, 4, 10]",
        "#[1, 2, 9, 4, 3, 10]",
        "#[1, 2, 3, 4, 10, 9]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'src': '#[10, 20, 30]', 'sStart': 1, 'dest': '#[1, 2, 3, 4]', 'dStart': 2, 'len': 3}"
    ]
  },
  "difficulty": "basic"
}