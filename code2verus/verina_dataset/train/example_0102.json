{
  "id": "verina_advanced_34",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that finds the length of the longest strictly increasing subsequence from a given list of integers. \n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\nimport Mathlib.Data.List.Basic\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef longestIncreasingSubsequence_precond (nums : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef longestIncreasingSubsequence (nums : List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Int :=\n  -- !benchmark @start code\n  Id.run do\n    if nums.isEmpty then return 0\n    let mut sub : Array Int := Array.empty\n    sub := sub.push nums.head!\n    for num in nums.tail do\n      if num > sub[sub.size - 1]! then\n        sub := sub.push num\n      else\n       -- << binary search >>\n        let mut left : Nat := 0\n        let mut right : Nat := sub.size - 1\n        while left < right do\n          let mid := (left + right) / 2\n          if sub[mid]! == num then\n            right := mid\n          else if sub[mid]! < num then\n            left := mid + 1\n          else\n            right := mid\n        sub := sub.set! left num\n    return Int.ofNat sub.size\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef longestIncreasingSubsequence_postcond (nums : List Int) (result: Int) (h_precond : longestIncreasingSubsequence_precond (nums)) : Prop :=\n  -- !benchmark @start postcond\n  let allSubseq := (nums.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let increasingSubseqLens := allSubseq.filter (fun l => List.Pairwise (\u00b7 < \u00b7) l) |>.map (\u00b7.length)\n  increasingSubseqLens.contains result \u2227 increasingSubseqLens.all (\u00b7 \u2264 result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem longestIncreasingSubsequence_spec_satisfied (nums: List Int) (h_precond : longestIncreasingSubsequence_precond (nums)) :\n    longestIncreasingSubsequence_postcond (nums) (longestIncreasingSubsequence (nums) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "longestIncreasingSubsequence",
    "parameters": {
      "param_name": [
        "nums"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/longest-increasing-subsequence/description/",
      "task_id": "lab_longestIncreasingSubsequence_325773003",
      "student_id": [
        28
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums\": \"[10, 9, 2, 5, 3, 7, 101, 18]\"}",
      "{\"nums\": \"[0, 1, 0, 3, 2, 3]\"}",
      "{\"nums\": \"[7, 7, 7, 7, 7, 7, 7]\"}",
      "{\"nums\": \"[1, 3, 2, 4]\"}",
      "{\"nums\": \"[10]\"}"
    ],
    "expected": [
      [
        "4"
      ],
      [
        "4"
      ],
      [
        "1"
      ],
      [
        "3"
      ],
      [
        "1"
      ]
    ],
    "unexpected": [
      [
        "3",
        "100"
      ],
      [
        "3",
        "100"
      ],
      [
        "7",
        "7"
      ],
      [
        "2",
        "4"
      ],
      [
        "0"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}