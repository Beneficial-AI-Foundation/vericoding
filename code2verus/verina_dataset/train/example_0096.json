{
  "id": "verina_basic_16",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that replaces every occurrence of a specified character within a string with a new character. The output should be a new string that maintains the same length as the input string, with all instances of the designated character replaced by the given substitute, and all other characters preserved unchanged.\n\n-----Input-----\nThe input consists of:\ns: A string in which the replacement will occur.\noldChar: The character within the string that needs to be replaced.\nnewChar: The character that will substitute for every occurrence of oldChar.\n\n-----Output-----\nThe output is a string that meets the following:\n- It has the same length as the input string.\n- All occurrences of oldChar in the input string are replaced with newChar.\n- All characters other than oldChar remain unchanged.\n\n-----Note-----\nThere are no preconditions; the method will always work. It is assumed that the input string is valid and non-null.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef replaceChars_precond (s : String) (oldChar : Char) (newChar : Char) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef replaceChars (s : String) (oldChar : Char) (newChar : Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) : String :=\n  -- !benchmark @start code\n  let cs := s.toList\n  let cs' := cs.map (fun c => if c = oldChar then newChar else c)\n  String.mk cs'\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef replaceChars_postcond (s : String) (oldChar : Char) (newChar : Char) (result: String) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :=\n  -- !benchmark @start postcond\n  let cs := s.toList\n  let cs' := result.toList\n  result.length = s.length \u2227\n  (\u2200 i, i < cs.length \u2192\n    (cs[i]! = oldChar \u2192 cs'[i]! = newChar) \u2227\n    (cs[i]! \u2260 oldChar \u2192 cs'[i]! = cs[i]!))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem replaceChars_spec_satisfied (s: String) (oldChar: Char) (newChar: Char) (h_precond : replaceChars_precond (s) (oldChar) (newChar)) :\n    replaceChars_postcond (s) (oldChar) (newChar) (replaceChars (s) (oldChar) (newChar) h_precond) h_precond := by\n  -- !benchmark @start proof\n  -- Unfold the definitions of replaceChars and replaceChars_postcond\n  unfold replaceChars replaceChars_postcond\n  -- Split the goal into two parts\n  constructor\n  \u00b7 -- First part: length is preserved\n    simp [String.length]\n  \u00b7 -- Second part: character replacement specification\n    simp_all\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "replaceChars",
    "parameters": {
      "param_name": [
        "s",
        "oldChar",
        "newChar"
      ],
      "param_type": [
        "String",
        "Char",
        "Char"
      ]
    },
    "return_type": "String"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_474",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"hello, world!\", \"oldChar\": \",\", \"newChar\": \";\"}",
      "{\"s\": \"a,b.c\", \"oldChar\": \",\", \"newChar\": \":\"}",
      "{\"s\": \"hello, world!\", \"oldChar\": \"o\", \"newChar\": \"O\"}",
      "{\"s\": \"\", \"oldChar\": \"x\", \"newChar\": \"y\"}",
      "{\"s\": \"test\", \"oldChar\": \"x\", \"newChar\": \"y\"}",
      "{\"s\": \"unchanged\", \"oldChar\": \"u\", \"newChar\": \"u\"}",
      "{\"s\": \"aaa\", \"oldChar\": \"a\", \"newChar\": \"b\"}"
    ],
    "expected": [
      [
        "hello; world!"
      ],
      [
        "a:b.c"
      ],
      [
        "hellO, wOrld!"
      ],
      [
        ""
      ],
      [
        "test"
      ],
      [
        "unchanged"
      ],
      [
        "bbb"
      ]
    ],
    "unexpected": [
      [
        "hello, world!",
        "hello world!",
        "hello;world!"
      ],
      [
        "a,b.c",
        "a;b.c",
        "ab:c"
      ],
      [
        "hello, world!",
        "hellO, world!",
        "hello, wOrld!"
      ],
      [
        " ",
        "abc"
      ],
      [
        "testy",
        "tset",
        "yxest"
      ],
      [
        "nchanged",
        "unchanged!",
        "unchangEd"
      ],
      [
        "aaa",
        "abb",
        "bba"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}