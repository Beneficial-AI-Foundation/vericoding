{
  "id": "verina_advanced_27",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that computes the longest common subsequence (LCS) of two input strings.\nA subsequence of a string is a sequence that can be derived from the original string by deleting zero or more characters (not necessarily contiguous) without changing the order of the remaining characters.\nThe function should return a string that is:\n1) A subsequence of both input strings.\n2) As long as possible among all such common subsequences.\n\nIf multiple LCS answers exist (with the same maximum length), returning any one of them is acceptable.\n\n-----Input-----\ns1: The first input string.\ns2: The second input string.\n\n-----Output-----\nA string representing a longest common subsequence of s1 and s2.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef longestCommonSubsequence_precond (s1 : String) (s2 : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\npartial def toCharList (s : String) : List Char :=\n  s.data\n\npartial def fromCharList (cs : List Char) : String :=\n  cs.foldl (fun acc c => acc.push c) \"\"\n\npartial def lcsAux (xs : List Char) (ys : List Char) : List Char :=\n  match xs, ys with\n  | [], _ => []\n  | _, [] => []\n  | x :: xs', y :: ys' =>\n    if x == y then\n      x :: lcsAux xs' ys'\n    else\n      let left  := lcsAux xs' (y :: ys')\n      let right := lcsAux (x :: xs') ys'\n      if left.length >= right.length then left else right\n-- !benchmark @end code_aux\n\n\ndef longestCommonSubsequence (s1 : String) (s2 : String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : String :=\n  -- !benchmark @start code\n  let xs := toCharList s1\n  let ys := toCharList s2\n  let resultList := lcsAux xs ys\n  fromCharList resultList\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef longestCommonSubsequence_postcond (s1 : String) (s2 : String) (result: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) : Prop :=\n  -- !benchmark @start postcond\n  let allSubseq (arr : List Char) := (arr.foldl fun acc x => acc ++ acc.map (fun sub => x :: sub)) [[]] |>.map List.reverse\n  let subseqA := allSubseq s1.toList\n  let subseqB := allSubseq s2.toList\n  let commonSubseq := subseqA.filter (fun l => subseqB.contains l)\n  commonSubseq.contains result.toList \u2227 commonSubseq.all (fun l => l.length \u2264 result.length)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem longestCommonSubsequence_spec_satisfied (s1: String) (s2: String) (h_precond : longestCommonSubsequence_precond (s1) (s2)) :\n    longestCommonSubsequence_postcond (s1) (s2) (longestCommonSubsequence (s1) (s2) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "longestCommonSubsequence",
    "parameters": {
      "param_name": [
        "s1",
        "s2"
      ],
      "param_type": [
        "String",
        "String"
      ]
    },
    "return_type": "String"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/longest-common-subsequence/description/",
      "task_id": "lab_longestCommonSubsequence_325767793",
      "student_id": [
        21
      ]
    }
  },
  "tests": {
    "input": [
      "{\"s1\": \"abcde\", \"s2\": \"ace\"}",
      "{\"s1\": \"aaaa\", \"s2\": \"bbaaa\"}",
      "{\"s1\": \"xyz\", \"s2\": \"abc\"}",
      "{\"s1\": \"axbxc\", \"s2\": \"abxc\"}",
      "{\"s1\": \"AGGTAB\", \"s2\": \"GXTXAYB\"}"
    ],
    "expected": [
      [
        "ace"
      ],
      [
        "aaa"
      ],
      [
        ""
      ],
      [
        "abxc"
      ],
      [
        "GTAB"
      ]
    ],
    "unexpected": [
      [
        "ab",
        "abc",
        "bce"
      ],
      [
        "aaaaa",
        "b",
        "aaab"
      ],
      [
        "x",
        "y",
        "a",
        "abc"
      ],
      [
        "axc",
        "abcx"
      ],
      [
        "GGTAB",
        "AGGTA"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}