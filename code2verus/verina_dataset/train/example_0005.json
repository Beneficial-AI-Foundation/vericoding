{
  "id": "verina_advanced_81",
  "description": "-----Description-----\nImplement a Lean 4 function that, given a list of integers, removes all duplicates and returns the resulting list in ascending order.\n\n-----Input-----\nThe input consists of a single list of integers:\narr: A list of integers.\n\n-----Output-----\nThe output is a list of integers:\nReturns a list containing the unique elements of the input, sorted in ascending order. The returned list must not contain any duplicates, and every element in the output must appear in the original input list.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef uniqueSorted_precond (arr : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef uniqueSorted (arr : List Int) (h_precond : uniqueSorted_precond (arr)) : List Int :=\n  -- !benchmark @start code\n  let rec insert (x : Int) (sorted : List Int) : List Int :=\n  match sorted with\n  | [] =>\n    [x]\n  | head :: tail =>\n    if x <= head then\n      x :: head :: tail\n    else\n      head :: insert x tail\n\nlet rec insertionSort (xs : List Int) : List Int :=\n  match xs with\n  | [] =>\n    []\n  | h :: t =>\n    let sortedTail := insertionSort t\n    insert h sortedTail\n\nlet removeDups : List Int \u2192 List Int\n| xs =>\n  let rec aux (remaining : List Int) (seen : List Int) (acc : List Int) : List Int :=\n    match remaining with\n    | [] =>\n      acc.reverse\n    | h :: t =>\n      if h \u2208 seen then\n        aux t seen acc\n      else\n        aux t (h :: seen) (h :: acc)\n  aux xs [] []\n\ninsertionSort (removeDups arr)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef uniqueSorted_postcond (arr : List Int) (result: List Int) (h_precond : uniqueSorted_precond (arr)) : Prop :=\n  -- !benchmark @start postcond\n  List.isPerm arr.eraseDups result \u2227 List.Pairwise (\u00b7 \u2264 \u00b7) result\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :\n    uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "uniqueSorted",
    "parameters": {
      "param_name": [
        "arr"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_uniqueSorted_325097530",
      "student_id": [
        17
      ]
    }
  },
  "tests": {
    "input": [
      "{\"arr\": \"[1, 1, 2, 3]\"}",
      "{\"arr\": \"[3, 3, 3]\"}",
      "{\"arr\": \"[]\"}",
      "{\"arr\": \"[5, 2, 2, 5]\"}",
      "{\"arr\": \"[1, 2, 3, 4, 5]\"}"
    ],
    "expected": [
      [
        "[1, 2, 3]"
      ],
      [
        "[3]"
      ],
      [
        "[]"
      ],
      [
        "[2, 5]"
      ],
      [
        "[1, 2, 3, 4, 5]"
      ]
    ],
    "unexpected": [
      [
        "[1, 1, 2, 3]",
        "[2, 3, 1]",
        "[1, 3, 2]"
      ],
      [
        "[3, 3, 3]",
        "[3, 3]",
        "[3, 3, 3, 3]"
      ],
      [
        "[0]",
        "[1]",
        "[999]"
      ],
      [
        "[5, 2]",
        "[2, 2, 5]",
        "[2]"
      ],
      [
        "[1, 2, 3]",
        "[2, 3, 4, 5]",
        "[5, 4, 3, 2, 1]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}