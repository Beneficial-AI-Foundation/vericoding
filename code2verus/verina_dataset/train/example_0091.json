{
  "id": "verina_advanced_53",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that calculates the minimum number of right shifts required to sort a given list of distinct positive integers.\n\nA right shift operation on a list nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe function should return the minimum number of right shifts needed to make the list sorted in ascending order. If the list is already sorted, the function should return 0. If it's impossible to sort the list using only right shifts, the function should return -1.\n\n-----Input-----\nThe input consists of a single list of integers:\nnums: A list (List Int) containing distinct positive integers.\n\n-----Output-----\nThe output is a single integer (Int):\n- If the list can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the list cannot be sorted using right shifts, return -1.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef minimumRightShifts_precond (nums : List Int) : Prop :=\n  -- !benchmark @start precond\n  List.Nodup nums\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef minimumRightShifts (nums : List Int) (h_precond : minimumRightShifts_precond (nums)) : Int :=\n  -- !benchmark @start code\n  let n := nums.length\n  -- base cases: empty or single element list is already sorted\n  if n <= 1 then 0 else\n\n  -- local helper function to check if a list is sorted in ascending order\n  let rec isSortedAux (l : List Int) : Bool :=\n    match l with\n    | [] => true       -- empty list is sorted\n    | [_] => true      -- single element list is sorted\n    | x :: y :: xs => if x <= y then isSortedAux (y :: xs) else false -- check pairwise\n\n  -- check if the input list is already sorted\n  if isSortedAux nums then 0 else\n\n  -- local helper function to perform a single right shift\n  -- assume the list `l` is non-empty based on the initial n > 1 check\n  let rightShiftOnce (l : List Int) : List Int :=\n     match l.reverse with\n     | [] => [] -- should not happen for n > 1\n     | last :: revInit => last :: revInit.reverse -- `last` is the original last element\n\n  -- recursive function to check subsequent shifts\n  -- `shifts_count` is the number of shifts already performed to get `current_list`\n  -- we are checking if `current_list` is sorted\n  let rec checkShifts (shifts_count : Nat) (current_list : List Int) : Int :=\n    -- base case: stop recursion if we've checked n-1 shifts (count goes from 1 to n)\n    -- the original list (0 shifts) has already been checked\n    if shifts_count >= n then -1\n    else\n      -- check if the current state is sorted\n      if isSortedAux current_list then\n        (shifts_count : Int) -- found it after 'shifts_count' shifts\n      else\n        -- recursion: increment shift count, apply next shift\n        checkShifts (shifts_count + 1) (rightShiftOnce current_list)\n  -- specify the decreasing measure for the termination checker: n - shifts_count\n  termination_by n - shifts_count\n\n  -- start the checking process by performing the first shift and checking subsequent states\n  -- the initial list (0 shifts) hass already been checked and is not sorted\n  checkShifts 1 (rightShiftOnce nums) -- start checking from the state after 1 shift\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef minimumRightShifts_postcond (nums : List Int) (result: Int) (h_precond : minimumRightShifts_precond (nums)) : Prop :=\n  -- !benchmark @start postcond\n  let n := nums.length\n\n  let isSorted (l : List Int) := List.Pairwise (\u00b7 \u2264 \u00b7) l\n  let rightShift (k : Nat) (l : List Int) := l.rotateRight k\n\n  -- specification logic based on the result value\n  if n <= 1 then result = 0 else -- specification for base cases\n\n  -- case 1: a non-negative result means a solution was found\n  (result \u2265 0 \u2227\n   -- result corresponds to a valid shift count result < n\n   result < n \u2227\n   -- applying result shifts results in a sorted list\n   isSorted (rightShift result.toNat nums) \u2227\n   -- result is the minimum such non-negative shift count\n   (List.range result.toNat |>.all (fun j => \u00ac isSorted (rightShift j nums)))\n  ) \u2228\n\n  -- case 2: result is -1 means no solution exists within n shifts\n  (result = -1 \u2227\n   -- for all possible shift counts k from 0 to n-1, the resulting list is not sorted\n   (List.range n |>.all (fun k => \u00ac isSorted (rightShift k nums)))\n  )\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem minimumRightShifts_spec_satisfied (nums: List Int) (h_precond : minimumRightShifts_precond (nums)) :\n    minimumRightShifts_postcond (nums) (minimumRightShifts (nums) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "minimumRightShifts",
    "parameters": {
      "param_name": [
        "nums"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_minimumRightShifts_325696322",
      "student_id": [
        40
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums\": \"[3, 4, 5, 1, 2]\"}",
      "{\"nums\": \"[1, 3, 5]\"}",
      "{\"nums\": \"[2, 1, 4]\"}",
      "{\"nums\": \"[1]\"}",
      "{\"nums\": \"[2, 1]\"}",
      "{\"nums\": \"[1, 2, 3, 4, 5]\"}",
      "{\"nums\": \"[5, 1, 2, 3, 4]\"}",
      "{\"nums\": \"[1, 5, 2, 3, 4]\"}"
    ],
    "expected": [
      [
        "2"
      ],
      [
        "0"
      ],
      [
        "-1"
      ],
      [
        "0"
      ],
      [
        "1"
      ],
      [
        "0"
      ],
      [
        "4"
      ],
      [
        "-1"
      ]
    ],
    "unexpected": [
      [
        "-1",
        "4",
        "5"
      ],
      [
        "-1",
        "3"
      ],
      [
        "0",
        "2",
        "3"
      ],
      [
        "-1",
        "1"
      ],
      [
        "-1",
        "0",
        "2"
      ],
      [
        "-1",
        "1",
        "5"
      ],
      [
        "-1",
        "0",
        "5"
      ],
      [
        "0",
        "1",
        "5"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'nums': '[1, 1]'}"
    ]
  },
  "difficulty": "advanced"
}