{
  "id": "verina_basic_93",
  "description": "-----Description-----  \nThis task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\n-----Input-----  \nThe input consists of:  \n\u2022 X: A UInt8 value.  \n\u2022 Y: A UInt8 value.\n\n-----Output-----  \nThe output is a pair of UInt8 values (newX, newY) where:  \n\u2022 newX is equal to the original Y.  \n\u2022 newY is equal to the original X.\n\n-----Note-----  \nThere are no additional preconditions; the function is meant to work correctly for any pair of UInt8 values by leveraging bitwise xor operations.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef SwapBitvectors_precond (X : UInt8) (Y : UInt8) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef SwapBitvectors (X : UInt8) (Y : UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) : UInt8 \u00d7 UInt8 :=\n  -- !benchmark @start code\n  let temp := X.xor Y\n  let newY := temp.xor Y\n  let newX := temp.xor newY\n  (newX, newY)\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef SwapBitvectors_postcond (X : UInt8) (Y : UInt8) (result: UInt8 \u00d7 UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :=\n  -- !benchmark @start postcond\n  result.fst = Y \u2227 result.snd = X \u2227\n  (X \u2260 Y \u2192 result.fst \u2260 X \u2227 result.snd \u2260 Y)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem SwapBitvectors_spec_satisfied (X: UInt8) (Y: UInt8) (h_precond : SwapBitvectors_precond (X) (Y)) :\n    SwapBitvectors_postcond (X) (Y) (SwapBitvectors (X) (Y) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "SwapBitvectors",
    "parameters": {
      "param_name": [
        "X",
        "Y"
      ],
      "param_type": [
        "UInt8",
        "UInt8"
      ]
    },
    "return_type": "UInt8 \u00d7 UInt8"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_swap_bitvector",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"X\": 0, \"Y\": 0}",
      "{\"X\": 5, \"Y\": 10}",
      "{\"X\": 255, \"Y\": 1}",
      "{\"X\": 128, \"Y\": 64}",
      "{\"X\": 15, \"Y\": 15}"
    ],
    "expected": [
      [
        "(0, 0)"
      ],
      [
        "(10, 5)"
      ],
      [
        "(1, 255)"
      ],
      [
        "(64, 128)"
      ],
      [
        "(15, 15)"
      ]
    ],
    "unexpected": [
      [
        "(0, 1)",
        "(1, 0)"
      ],
      [
        "(5, 10)",
        "(10, 10)",
        "(5, 5)"
      ],
      [
        "(255, 1)",
        "(1, 254)",
        "(0, 255)"
      ],
      [
        "(128, 64)",
        "(64, 64)",
        "(0, 128)"
      ],
      [
        "(15, 16)",
        "(16, 15)",
        "(14, 15)"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}