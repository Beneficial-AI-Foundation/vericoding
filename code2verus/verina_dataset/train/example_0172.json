{
  "id": "verina_basic_64",
  "description": "-----Description-----  \nThis task requires writing a Lean 4 method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n\u2022 All characters before the insertion position (atPos) remain unchanged.  \n\u2022 The new characters from nl are inserted starting at index atPos.  \n\u2022 The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----  \nThe input consists of:  \n\u2022 oline: An array of characters representing the original sequence.  \n\u2022 l: A natural number indicating how many characters from oline to consider.  \n\u2022 nl: An array of characters to be inserted into oline.  \n\u2022 p: A natural number indicating how many characters from nl to consider for insertion.  \n\u2022 atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----  \nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:  \n\u2022 Contain the original characters from index 0 up to (but not including) atPos.  \n\u2022 Have the next p characters equal to the characters from nl.  \n\u2022 Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----  \nIt is assumed that:  \n\u2022 atPos is within the range [0, l].  \n\u2022 l does not exceed the size of oline.  \n\u2022 p does not exceed the size of nl.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef insert_precond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) : Prop :=\n  -- !benchmark @start precond\n  l \u2264 oline.size \u2227\n  p \u2264 nl.size \u2227\n  atPos \u2264 l\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef insert (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) : Array Char :=\n  -- !benchmark @start code\n  let result := Array.mkArray (l + p) ' '\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i < atPos then acc.set! i (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  let result := Array.foldl\n    (fun acc i =>\n      acc.set! (atPos + i) (nl[i]!))\n    result\n    (Array.range p)\n\n  let result := Array.foldl\n    (fun acc i =>\n      if i >= atPos then acc.set! (i + p) (oline[i]!) else acc)\n    result\n    (Array.range l)\n\n  result\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef insert_postcond (oline : Array Char) (l : Nat) (nl : Array Char) (p : Nat) (atPos : Nat) (result: Array Char) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :=\n  -- !benchmark @start postcond\n  result.size = l + p \u2227\n  (List.range p).all (fun i => result[atPos + i]! = nl[i]!) \u2227\n  (List.range atPos).all (fun i => result[i]! = oline[i]!) \u2227\n  (List.range (l - atPos)).all (fun i => result[atPos + p + i]! = oline[atPos + i]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem insert_spec_satisfied (oline: Array Char) (l: Nat) (nl: Array Char) (p: Nat) (atPos: Nat) (h_precond : insert_precond (oline) (l) (nl) (p) (atPos)) :\n    insert_postcond (oline) (l) (nl) (p) (atPos) (insert (oline) (l) (nl) (p) (atPos) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "insert",
    "parameters": {
      "param_name": [
        "oline",
        "l",
        "nl",
        "p",
        "atPos"
      ],
      "param_type": [
        "Array Char",
        "Nat",
        "Array Char",
        "Nat",
        "Nat"
      ]
    },
    "return_type": "Array Char"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_insert",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"oline\": \"#['a','b','c','d','e']\", \"l\": 5, \"nl\": \"#['X','Y']\", \"p\": 2, \"atPos\": 2}",
      "{\"oline\": \"#['H','e','l','l','o']\", \"l\": 5, \"nl\": \"#['W','o','r','l','d']\", \"p\": 5, \"atPos\": 0}",
      "{\"oline\": \"#['L','e','a','n']\", \"l\": 4, \"nl\": \"#['4']\", \"p\": 1, \"atPos\": 4}",
      "{\"oline\": \"#['T','e','s','t']\", \"l\": 4, \"nl\": \"#[]\", \"p\": 0, \"atPos\": 2}",
      "{\"oline\": \"#['1','2','3','4','5','6']\", \"l\": 5, \"nl\": \"#['a','b','c']\", \"p\": 3, \"atPos\": 3}"
    ],
    "expected": [
      [
        "#['a','b','X','Y','c','d','e']"
      ],
      [
        "#['W','o','r','l','d','H','e','l','l','o']"
      ],
      [
        "#['L','e','a','n','4']"
      ],
      [
        "#['T','e','s','t']"
      ],
      [
        "#['1','2','3','a','b','c','4','5']"
      ]
    ],
    "unexpected": [
      [
        "#['a','b','X','Y','c','d']",
        "#['a','b','X','Y','c','d','f']",
        "#['a','X','b','Y','c','d','e']"
      ],
      [
        "#['H','e','l','l','o','W','o','r','l','d']",
        "#['W','o','r','l','d','H','e','l','l','o','!']",
        "#['W','o','r','l','d','W','o','r','l','d']"
      ],
      [
        "#['L','e','a','n']",
        "#['L','e','a','n',' ']",
        "#['4','L','e','a','n']"
      ],
      [
        "#['T','e','s']",
        "#['T','s','t','e']",
        "#['t','e','s','T']"
      ],
      [
        "#['1','2','3','a','b','c','4','5','6']",
        "#['1','2','3','4','a','b','c','5','6']",
        "#['1','2','3','a','b','4','c','5','6']"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'oline': \"#['a','b','c']\", 'l': 5, 'nl': \"#['X','Y']\", 'p': 3, 'atPos': 2}"
    ]
  },
  "difficulty": "basic"
}