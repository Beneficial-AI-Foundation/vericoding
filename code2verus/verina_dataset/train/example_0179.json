{
  "id": "verina_basic_29",
  "description": "-----Description-----  \nThis task requires writing a Lean 4 method that removes an element from a given array of integers at a specified index. The resulting array should contain all the original elements except for the one at the given index. Elements before the removed element remain unchanged, and elements after it are shifted one position to the left.\n\n-----Input-----  \nThe input consists of:  \n\u2022 s: An array of integers.  \n\u2022 k: A natural number representing the index of the element to remove (0-indexed).\n\n-----Output-----  \nThe output is an array of integers that:  \n\u2022 Has a length one less than the input array.  \n\u2022 Contains the same elements as the input array, except that the element at index k is omitted.  \n\u2022 Preserves the original order with elements after the removed element shifted left by one position.\n\n-----Note-----  \nIt is assumed that k is a valid index (0 \u2264 k < the length of the array).",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef removeElement_precond (s : Array Int) (k : Nat) : Prop :=\n  -- !benchmark @start precond\n  k < s.size\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef removeElement (s : Array Int) (k : Nat) (h_precond : removeElement_precond (s) (k)) : Array Int :=\n  -- !benchmark @start code\n  s.eraseIdx! k\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef removeElement_postcond (s : Array Int) (k : Nat) (result: Array Int) (h_precond : removeElement_precond (s) (k)) :=\n  -- !benchmark @start postcond\n  result.size = s.size - 1 \u2227\n  (\u2200 i, i < k \u2192 result[i]! = s[i]!) \u2227\n  (\u2200 i, i < result.size \u2192 i \u2265 k \u2192 result[i]! = s[i + 1]!)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem removeElement_spec_satisfied (s: Array Int) (k: Nat) (h_precond : removeElement_precond (s) (k)) :\n    removeElement_postcond (s) (k) (removeElement (s) (k) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold removeElement removeElement_postcond\n  unfold removeElement_precond at h_precond\n  simp_all\n  unfold Array.eraseIdx!\n  simp [h_precond]\n  constructor\n  \u00b7 intro i hi\n    have hi' : i < s.size - 1 := by\n      have hk := Nat.le_sub_one_of_lt h_precond\n      exact Nat.lt_of_lt_of_le hi hk\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    simp [hi', Nat.lt_trans hi h_precond, Array.getElem_eraseIdx, hi]\n  \u00b7 intro i hi hi'\n    rw [Array.getElem!_eq_getD, Array.getElem!_eq_getD]\n    unfold Array.getD\n    have hi'' : i + 1 < s.size := by exact Nat.add_lt_of_lt_sub hi\n    simp [hi, hi'']\n    have : \u00ac i < k := by simp [hi']\n    simp [Array.getElem_eraseIdx, this]\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "removeElement",
    "parameters": {
      "param_name": [
        "s",
        "k"
      ],
      "param_type": [
        "Array Int",
        "Nat"
      ]
    },
    "return_type": "Array Int"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_610",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"#[1, 2, 3, 4, 5]\", \"k\": 2}",
      "{\"s\": \"#[10, 20, 30, 40]\", \"k\": 0}",
      "{\"s\": \"#[10, 20, 30, 40]\", \"k\": 3}",
      "{\"s\": \"#[7]\", \"k\": 0}"
    ],
    "expected": [
      [
        "#[1, 2, 4, 5]"
      ],
      [
        "#[20, 30, 40]"
      ],
      [
        "#[10, 20, 30]"
      ],
      [
        "#[]"
      ]
    ],
    "unexpected": [
      [
        "#[1, 2, 3, 5]",
        "#[1, 3, 4, 5]",
        "#[2, 3, 4, 5]"
      ],
      [
        "#[10, 30, 40]",
        "#[10, 20, 30, 40]",
        "#[20, 30, 40, 0]"
      ],
      [
        "#[20, 30, 40]",
        "#[10, 20, 40]",
        "#[10, 30, 40]"
      ],
      [
        "#[7]",
        "#[0]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'s': '#[1]', 'k': 2}"
    ]
  },
  "difficulty": "basic"
}