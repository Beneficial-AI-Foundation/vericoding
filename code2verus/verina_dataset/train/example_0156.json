{
  "id": "verina_basic_2",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef findSmallest_precond (s : Array Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef findSmallest (s : Array Nat) (h_precond : findSmallest_precond (s)) : Option Nat :=\n  -- !benchmark @start code\n  s.toList.min?\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef findSmallest_postcond (s : Array Nat) (result: Option Nat) (h_precond : findSmallest_precond (s)) :=\n  -- !benchmark @start postcond\n  let xs := s.toList\n  match result with\n  | none => xs = []\n  | some r => r \u2208 xs \u2227 (\u2200 x, x \u2208 xs \u2192 r \u2264 x)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem findSmallest_spec_satisfied (s: Array Nat) (h_precond : findSmallest_precond (s)) :\n    findSmallest_postcond (s) (findSmallest (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  unfold findSmallest_postcond findSmallest\n  cases res : s.toList.min? with\n  | none =>\n    simp only [res]\n    rw [List.min?_eq_none_iff] at res\n    exact res\n  | some r =>\n    simp only [res]\n    rw [List.min?_eq_some_iff'] at res\n    exact res\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "findSmallest",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "Array Nat"
      ]
    },
    "return_type": "Option Nat"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_62",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"#[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]\"}",
      "{\"s\": \"#[0, 1, 2, 3, 4, 5]\"}",
      "{\"s\": \"#[1]\"}",
      "{\"s\": \"#[10, 10, 10]\"}",
      "{\"s\": \"#[3, 2, 2, 2, 2, 2, 2, 1]\"}",
      "{\"s\": \"#[0]\"}",
      "{\"s\": \"#[100, 99, 98]\"}",
      "{\"s\": \"#[]\"}"
    ],
    "expected": [
      [
        "some (1)"
      ],
      [
        "some (0)"
      ],
      [
        "some (1)"
      ],
      [
        "some (10)"
      ],
      [
        "some (1)"
      ],
      [
        "some (0)"
      ],
      [
        "some (98)"
      ],
      [
        "none"
      ]
    ],
    "unexpected": [
      [
        "some (2)",
        "some (0)",
        "none"
      ],
      [
        "some (1)",
        "none"
      ],
      [
        "some (0)",
        "some (2)",
        "none"
      ],
      [
        "some (9)",
        "some (0)",
        "none"
      ],
      [
        "some (2)",
        "some (0)",
        "none"
      ],
      [
        "some (1)",
        "none"
      ],
      [
        "some (99)",
        "some (97)",
        "none"
      ],
      [
        "some (0)"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}