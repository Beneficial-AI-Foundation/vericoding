{
  "id": "verina_advanced_42",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that takes a list of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the function should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A list of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef maxProfit_precond (prices : List Nat) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef updateMinAndProfit (price : Nat) (minSoFar : Nat) (maxProfit : Nat) : (Nat \u00d7 Nat) :=\n  let newMin := Nat.min minSoFar price\n  let profit := if price > minSoFar then price - minSoFar else 0\n  let newMaxProfit := Nat.max maxProfit profit\n  (newMin, newMaxProfit)\n\ndef maxProfitAux (prices : List Nat) (minSoFar : Nat) (maxProfit : Nat) : Nat :=\n  match prices with\n  | [] => maxProfit\n  | p :: ps =>\n    let (newMin, newProfit) := updateMinAndProfit p minSoFar maxProfit\n    maxProfitAux ps newMin newProfit\n-- !benchmark @end code_aux\n\n\ndef maxProfit (prices : List Nat) (h_precond : maxProfit_precond (prices)) : Nat :=\n  -- !benchmark @start code\n  match prices with\n  | [] => 0\n  | p :: ps => maxProfitAux ps p 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef maxProfit_postcond (prices : List Nat) (result: Nat) (h_precond : maxProfit_precond (prices)) : Prop :=\n  -- !benchmark @start postcond\n  (result = 0 \u2227 prices = []) \u2228\n  (\n    -- All valid transactions have profit \u2264 result (using pairwise)\n    List.Pairwise (fun \u27e8pi, i\u27e9 \u27e8pj, j\u27e9 => i < j \u2192 pj - pi \u2264 result) prices.zipIdx \u2227\n\n    -- There exists a transaction with profit = result (using any)\n    prices.zipIdx.any (fun \u27e8pi, i\u27e9 =>\n      prices.zipIdx.any (fun \u27e8pj, j\u27e9 =>\n        i < j \u2227 pj - pi = result))\n  )\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem maxProfit_spec_satisfied (prices: List Nat) (h_precond : maxProfit_precond (prices)) :\n    maxProfit_postcond (prices) (maxProfit (prices) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "maxProfit",
    "parameters": {
      "param_name": [
        "prices"
      ],
      "param_type": [
        "List Nat"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_maxProfit_324256904",
      "student_id": [
        34
      ]
    }
  },
  "tests": {
    "input": [
      "{\"prices\": \"[7, 1, 5, 3, 6, 4]\"}",
      "{\"prices\": \"[7, 6, 4, 3, 1]\"}",
      "{\"prices\": \"[2, 4, 1]\"}",
      "{\"prices\": \"[1, 2]\"}",
      "{\"prices\": \"[]\"}"
    ],
    "expected": [
      [
        "5"
      ],
      [
        "0"
      ],
      [
        "2"
      ],
      [
        "1"
      ],
      [
        "0"
      ]
    ],
    "unexpected": [
      [
        "4",
        "6"
      ],
      [
        "1",
        "2"
      ],
      [
        "1"
      ],
      [
        "0"
      ],
      [
        "1"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}