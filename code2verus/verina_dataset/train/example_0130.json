{
  "id": "verina_advanced_49",
  "description": "-----Description-----\nImplement a Lean 4 function that merges two ascendingly sorted lists of integers into one single sorted list (ascending). The resulting list must contain all elements from both input lists, preserving their ascending order.\n\n-----Input-----\nThe input consists of two lists of integers:\narr1: A sorted list of integers (ascending)\narr2: Another sorted list of integers (ascending)\n\n-----Output-----\nThe output is a list of integers:\nReturns a new list containing all elements from arr1 and arr2, sorted in ascending order.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef mergeSortedLists_precond (arr1 : List Int) (arr2 : List Int) : Prop :=\n  -- !benchmark @start precond\n  List.Pairwise (\u00b7 \u2264 \u00b7) arr1 \u2227 List.Pairwise (\u00b7 \u2264 \u00b7) arr2\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef mergeSortedLists (arr1 : List Int) (arr2 : List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : List Int :=\n  -- !benchmark @start code\n  let rec merge (xs : List Int) (ys : List Int) : List Int :=\n    match xs, ys with\n    | [], _ => ys\n    | _, [] => xs\n    | x :: xt, y :: yt =>\n      if x <= y then\n        x :: merge xt (y :: yt)\n      else\n        y :: merge (x :: xt) yt\n\n  merge arr1 arr2\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef mergeSortedLists_postcond (arr1 : List Int) (arr2 : List Int) (result: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) : Prop :=\n  -- !benchmark @start postcond\n  List.Pairwise (\u00b7 \u2264 \u00b7) result \u2227 List.isPerm (arr1 ++ arr2) result\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem mergeSortedLists_spec_satisfied (arr1: List Int) (arr2: List Int) (h_precond : mergeSortedLists_precond (arr1) (arr2)) :\n    mergeSortedLists_postcond (arr1) (arr2) (mergeSortedLists (arr1) (arr2) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "mergeSortedLists",
    "parameters": {
      "param_name": [
        "arr1",
        "arr2"
      ],
      "param_type": [
        "List Int",
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "N/A",
      "task_id": "lab_mergeSortedLists_325057855",
      "student_id": [
        17
      ]
    }
  },
  "tests": {
    "input": [
      "{\"arr1\": \"[1, 3, 5]\", \"arr2\": \"[2, 4, 6]\"}",
      "{\"arr1\": \"[]\", \"arr2\": \"[]\"}",
      "{\"arr1\": \"[-2, 0, 1]\", \"arr2\": \"[-3, -1]\"}",
      "{\"arr1\": \"[10, 20, 30]\", \"arr2\": \"[5, 25, 35]\"}",
      "{\"arr1\": \"[1, 2, 2]\", \"arr2\": \"[2, 3, 3]\"}"
    ],
    "expected": [
      [
        "[1, 2, 3, 4, 5, 6]"
      ],
      [
        "[]"
      ],
      [
        "[-3, -2, -1, 0, 1]"
      ],
      [
        "[5, 10, 20, 25, 30, 35]"
      ],
      [
        "[1, 2, 2, 2, 3, 3]"
      ]
    ],
    "unexpected": [
      [
        "[1, 3, 5]",
        "[2, 4, 6]",
        "[1, 3, 2, 4, 5, 6]"
      ],
      [
        "[0]",
        "[999]"
      ],
      [
        "[-3, -1]",
        "[0, 1]",
        "[-2, 0, 1]"
      ],
      [
        "[10, 20, 30]",
        "[5, 25, 35]",
        "[10, 20, 25, 30, 35]"
      ],
      [
        "[1, 2, 3]",
        "[2, 2, 2, 3, 3]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'arr1': '[3, 2, 1]', 'arr2': '[6, 5, 4]'}"
    ]
  },
  "difficulty": "advanced"
}