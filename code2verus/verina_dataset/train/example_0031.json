{
  "id": "verina_advanced_21",
  "description": "-----Description-----\nImplement a Lean 4 function that checks if a given string is a palindrome. A string is considered a palindrome\nif it reads the same forward and backward.\n\n-----Input-----\nThe input consists of a single string:\ns: A string\n\n-----Output-----\nThe output is a boolean:\nReturns true if s is a palindrome, false otherwise.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef isPalindrome_precond (s : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef isPalindrome (s : String) (h_precond : isPalindrome_precond (s)) : Bool :=\n  -- !benchmark @start code\n  let length := s.length\n\nif length <= 1 then\n  true\nelse\n  let arr := s.toList\n\n  let rec checkIndices (left : Nat) (right : Nat) (chars : List Char) : Bool :=\n    if left >= right then\n      true\n    else\n      match chars[left]?, chars[right]? with\n      | some cLeft, some cRight =>\n        if cLeft == cRight then\n          checkIndices (left + 1) (right - 1) chars\n        else\n          false\n      | _, _ => false\n  let approach1 := checkIndices 0 (length - 1) arr\n\n  let rec reverseList (acc : List Char) (xs : List Char) : List Char :=\n    match xs with\n    | []      => acc\n    | h :: t  => reverseList (h :: acc) t\n  let reversed := reverseList [] arr\n  let approach2 := (arr == reversed)\n\n  approach1 && approach2\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef isPalindrome_postcond (s : String) (result: Bool) (h_precond : isPalindrome_precond (s)) : Prop :=\n  -- !benchmark @start postcond\n  (result \u2192 (s.toList == s.toList.reverse)) \u2227\n  (\u00ac result \u2192 (s.toList \u2260 [] \u2227 s.toList != s.toList.reverse))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem isPalindrome_spec_satisfied (s: String) (h_precond : isPalindrome_precond (s)) :\n    isPalindrome_postcond (s) (isPalindrome (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "isPalindrome",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "String"
      ]
    },
    "return_type": "Bool"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_isPalindrome_325097530",
      "student_id": [
        17
      ]
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"racecar\"}",
      "{\"s\": \"abba\"}",
      "{\"s\": \"abc\"}",
      "{\"s\": \"\"}",
      "{\"s\": \"a\"}"
    ],
    "expected": [
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "True"
      ]
    ],
    "unexpected": [
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ],
      [
        "False"
      ],
      [
        "False"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}