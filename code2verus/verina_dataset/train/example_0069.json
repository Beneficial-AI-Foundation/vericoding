{
  "id": "verina_basic_89",
  "description": "-----Description-----  \nThis problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----  \nThe input consists of:  \n\u2022 s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----  \nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----  \nNo additional preconditions are required. The method should correctly handle any list, including an empty list.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef SetToSeq_precond (s : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef SetToSeq (s : List Int) (h_precond : SetToSeq_precond (s)) : List Int :=\n  -- !benchmark @start code\n  s.foldl (fun acc x => if acc.contains x then acc else acc ++ [x]) []\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef SetToSeq_postcond (s : List Int) (result: List Int) (h_precond : SetToSeq_precond (s)) :=\n  -- !benchmark @start postcond\n  -- Contains exactly the elements of the set\n  result.all (fun a => a \u2208 s) \u2227 s.all (fun a => a \u2208 result) \u2227\n  -- All elements are unique in the result\n  result.all (fun a => result.count a = 1) \u2227\n  -- The order of elements in the result is preserved\n  List.Pairwise (fun a b => (result.idxOf a < result.idxOf b) \u2192 (s.idxOf a < s.idxOf b)) result\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem SetToSeq_spec_satisfied (s: List Int) (h_precond : SetToSeq_precond (s)) :\n    SetToSeq_postcond (s) (SetToSeq (s) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "SetToSeq",
    "parameters": {
      "param_name": [
        "s"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_set_to_seq",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"[1, 2, 2, 3, 1]\"}",
      "{\"s\": \"[5, 5, 5, 5]\"}",
      "{\"s\": \"[]\"}",
      "{\"s\": \"[11, 22, 33]\"}",
      "{\"s\": \"[3, 1, 4, 1, 5, 9, 2, 6, 5]\"}"
    ],
    "expected": [
      [
        "[1, 2, 3]"
      ],
      [
        "[5]"
      ],
      [
        "[]"
      ],
      [
        "[11, 22, 33]"
      ],
      [
        "[3, 1, 4, 5, 9, 2, 6]"
      ]
    ],
    "unexpected": [
      [
        "[1, 3, 2]",
        "[1, 2, 2, 3]",
        "[2, 1, 3]"
      ],
      [
        "[5, 5]",
        "[]",
        "[6]"
      ],
      [
        "[1]",
        "[2]",
        "[0]"
      ],
      [
        "[33, 22, 11]",
        "[11, 11, 22, 33]",
        "[11, 33]"
      ],
      [
        "[3, 1, 4, 1, 5, 9, 2, 6, 5]",
        "[1, 3, 4, 5, 9, 2, 6]",
        "[3, 1, 4, 5, 9, 6]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}