{
  "id": "verina_advanced_71",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that, given a binary string `s` and an integer `k`, finds the shortest contiguous substring that contains exactly `k` characters `'1'`.\n\nAmong all substrings of `s` that contain exactly `k` occurrences of `'1'`, return the one that is shortest in length. If there are multiple such substrings with the same length, return the lexicographically smallest one.\n\nIf no such substring exists, return the empty string.\n\n-----Input-----\n- s: A binary string (only consisting of characters `'0'` and `'1'`)\n- k: A natural number (k \u2265 0)\n\n-----Output-----\nA string representing the shortest substring of `s` that contains exactly `k` ones. If no such substring exists, return `\"\"`.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\ndef countOnes (lst : List Char) : Nat :=\n  lst.foldl (fun acc c => if c = '1' then acc + 1 else acc) 0\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef shortestBeautifulSubstring_precond (s : String) (k : Nat) : Prop :=\n  -- !benchmark @start precond\n  s.toList.all (fun c => c = '0' \u2228 c = '1')\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef listToString (lst : List Char) : String :=\n  String.mk lst\ndef isLexSmaller (a b : List Char) : Bool :=\n  listToString a < listToString b\ndef allSubstrings (s : List Char) : List (List Char) :=\n  let n := s.length\n  (List.range n).flatMap (fun i =>\n    (List.range (n - i)).map (fun j =>\n      s.drop i |>.take (j + 1)))\n-- !benchmark @end code_aux\n\n\ndef shortestBeautifulSubstring (s : String) (k : Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : String :=\n  -- !benchmark @start code\n  let chars := s.data\n  let candidates := allSubstrings chars |>.filter (fun sub => countOnes sub = k)\n\n  let compare (a b : List Char) : Bool :=\n    a.length < b.length \u2228 (a.length = b.length \u2227 isLexSmaller a b)\n\n  let best := candidates.foldl (fun acc cur =>\n    match acc with\n    | none => some cur\n    | some best => if compare cur best then some cur else some best) none\n  match best with\n  | some b => listToString b\n  | none => \"\"\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef shortestBeautifulSubstring_postcond (s : String) (k : Nat) (result: String) (h_precond : shortestBeautifulSubstring_precond (s) (k)) : Prop :=\n  -- !benchmark @start postcond\n  let chars := s.data\n  let substrings := (List.range chars.length).flatMap (fun i =>\n    (List.range (chars.length - i + 1)).map (fun len =>\n      chars.drop i |>.take len))\n  let isBeautiful := fun sub => countOnes sub = k\n  let beautiful := substrings.filter (fun sub => isBeautiful sub)\n  let targets := beautiful.map (\u00b7.asString) |>.filter (fun s => s \u2260 \"\")\n  (result = \"\" \u2227 targets = []) \u2228\n  (result \u2208 targets \u2227\n   \u2200 r \u2208 targets, r.length \u2265 result.length \u2228 (r.length = result.length \u2227 result \u2264 r))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem shortestBeautifulSubstring_spec_satisfied (s: String) (k: Nat) (h_precond : shortestBeautifulSubstring_precond (s) (k)) :\n    shortestBeautifulSubstring_postcond (s) (k) (shortestBeautifulSubstring (s) (k) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "shortestBeautifulSubstring",
    "parameters": {
      "param_name": [
        "s",
        "k"
      ],
      "param_type": [
        "String",
        "Nat"
      ]
    },
    "return_type": "String"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://huggingface.co/spaces/livecodebench/code_generation_samples",
      "task_id": "lab_shortestBeautifulSubstring_325098964",
      "student_id": [
        32
      ]
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"100011001\", \"k\": 3}",
      "{\"s\": \"1011\", \"k\": 2}",
      "{\"s\": \"000\", \"k\": 1}",
      "{\"s\": \"11111\", \"k\": 3}",
      "{\"s\": \"10100101\", \"k\": 2}",
      "{\"s\": \"1001001\", \"k\": 2}",
      "{\"s\": \"10010001\", \"k\": 1}",
      "{\"s\": \"1001\", \"k\": 0}"
    ],
    "expected": [
      [
        "11001"
      ],
      [
        "11"
      ],
      [
        ""
      ],
      [
        "111"
      ],
      [
        "101"
      ],
      [
        "1001"
      ],
      [
        "1"
      ],
      [
        "0"
      ]
    ],
    "unexpected": [
      [
        "00011",
        "10001",
        ""
      ],
      [
        "101",
        "01",
        ""
      ],
      [
        "0",
        "00",
        "000"
      ],
      [
        "11",
        "1111",
        ""
      ],
      [
        "010",
        "1001",
        "0101"
      ],
      [
        "0010",
        "0100",
        "001"
      ],
      [
        "10",
        "100",
        "000"
      ],
      [
        "10",
        "100",
        "1"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'s': '2', 'k': 1}"
    ]
  },
  "difficulty": "advanced"
}