{
  "id": "verina_advanced_51",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\n-----Input-----\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef mergeSorted_precond (a : List Int) (b : List Int) : Prop :=\n  -- !benchmark @start precond\n  List.Pairwise (\u00b7 \u2264 \u00b7) a \u2227 List.Pairwise (\u00b7 \u2264 \u00b7) b\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\ndef mergeSortedAux : List Int \u2192 List Int \u2192 List Int\n| [], ys => ys\n| xs, [] => xs\n| x :: xs', y :: ys' =>\n  if x \u2264 y then\n    let merged := mergeSortedAux xs' (y :: ys')\n    x :: merged\n  else\n    let merged := mergeSortedAux (x :: xs') ys'\n    y :: merged\n\n-- !benchmark @end code_aux\n\n\ndef mergeSorted (a : List Int) (b : List Int) (h_precond : mergeSorted_precond (a) (b)) : List Int :=\n  -- !benchmark @start code\n  let merged := mergeSortedAux a b\n  merged\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef mergeSorted_postcond (a : List Int) (b : List Int) (result: List Int) (h_precond : mergeSorted_precond (a) (b)) : Prop :=\n  -- !benchmark @start postcond\n  List.Pairwise (\u00b7 \u2264 \u00b7) result \u2227\n  List.isPerm result (a ++ b)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem mergeSorted_spec_satisfied (a: List Int) (b: List Int) (h_precond : mergeSorted_precond (a) (b)) :\n    mergeSorted_postcond (a) (b) (mergeSorted (a) (b) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "mergeSorted",
    "parameters": {
      "param_name": [
        "a",
        "b"
      ],
      "param_type": [
        "List Int",
        "List Int"
      ]
    },
    "return_type": "List Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_mergeSorted_325769371",
      "student_id": [
        15
      ]
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"[1, 3, 5]\", \"b\": \"[2, 4, 6]\"}",
      "{\"a\": \"[1, 2]\", \"b\": \"[1, 2, 3]\"}",
      "{\"a\": \"[]\", \"b\": \"[4, 5]\"}",
      "{\"a\": \"[0, 3, 4]\", \"b\": \"[]\"}",
      "{\"a\": \"[1, 4, 6]\", \"b\": \"[2, 3, 5]\"}"
    ],
    "expected": [
      [
        "[1, 2, 3, 4, 5, 6]"
      ],
      [
        "[1, 1, 2, 2, 3]"
      ],
      [
        "[4, 5]"
      ],
      [
        "[0, 3, 4]"
      ],
      [
        "[1, 2, 3, 4, 5, 6]"
      ]
    ],
    "unexpected": [
      [
        "[1, 3, 5]",
        "[2, 4, 6]",
        "[6, 5, 4]"
      ],
      [
        "[1, 2, 3]"
      ],
      [
        "[]"
      ],
      [
        "[4, 3, 0]"
      ],
      [
        "[1, 4, 6, 2, 3, 5]"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'a': '[1, 2, 3]', 'b': '[6, 5, 4]'}",
      "{'a': '[3, 2, 1]', 'b': '[6, 5, 4]'}"
    ]
  },
  "difficulty": "advanced"
}