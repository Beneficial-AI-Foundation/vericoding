{
  "id": "verina_advanced_75",
  "description": "-----Description-----\nGiven a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane\u2019s Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\n-----Input-----\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\n-----Output-----\nThe output is a single integer representing the maximum subarray sum.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef task_code_precond (sequence : List Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=\n  -- !benchmark @start code\n  match sequence with\n  | []      => 0  -- If no elements are provided (should not happen according to the problem)\n  | x :: xs =>\n      let (_, maxSoFar) :=\n        xs.foldl (fun (acc : Int \u00d7 Int) (x : Int) =>\n          let (cur, maxSoFar) := acc\n          let newCur := if cur + x >= x then cur + x else x\n          let newMax := if maxSoFar >= newCur then maxSoFar else newCur\n          (newCur, newMax)\n        ) (x, x)\n      maxSoFar\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=\n  -- !benchmark @start postcond\n  let subArrays :=\n    List.range (sequence.length + 1) |>.flatMap (fun start =>\n      List.range (sequence.length - start + 1) |>.map (fun len =>\n        sequence.drop start |>.take len))\n  let subArraySums := subArrays.filter (\u00b7 \u2260 []) |>.map (\u00b7.sum)\n  subArraySums.contains result \u2227 subArraySums.all (\u00b7 \u2264 result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :\n    task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "task_code",
    "parameters": {
      "param_name": [
        "sequence"
      ],
      "param_type": [
        "List Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_task_code_325773191",
      "student_id": [
        53
      ]
    }
  },
  "tests": {
    "input": [
      "{\"sequence\": \"[10, -4, 3, 1, 5, 6, -35, 12, 21, -1]\"}",
      "{\"sequence\": \"[2, 1, -4, 3, 4, -4, 6, 5, -5, 1]\"}",
      "{\"sequence\": \"[-1, -2, -3, -4, -5]\"}",
      "{\"sequence\": \"[7]\"}",
      "{\"sequence\": \"[1, 2, 3, 4, 5]\"}"
    ],
    "expected": [
      [
        "33"
      ],
      [
        "14"
      ],
      [
        "-1"
      ],
      [
        "7"
      ],
      [
        "15"
      ]
    ],
    "unexpected": [
      [
        "32",
        "34",
        "0"
      ],
      [
        "13",
        "15",
        "0"
      ],
      [
        "-2",
        "0",
        "1"
      ],
      [
        "0",
        "1",
        "-7"
      ],
      [
        "14",
        "16",
        "0"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}