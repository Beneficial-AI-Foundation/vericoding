{
  "id": "verina_advanced_69",
  "description": "-----Description-----\nGiven a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int \u2014 a sorted list of distinct integers in increasing order\ntarget : Int \u2014 the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef searchInsert_precond (xs : List Int) (target : Int) : Prop :=\n  -- !benchmark @start precond\n  List.Pairwise (\u00b7 < \u00b7) xs\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef searchInsert (xs : List Int) (target : Int) (h_precond : searchInsert_precond (xs) (target)) : Nat :=\n  -- !benchmark @start code\n  match xs with\n  | [] =>\n      0\n  | _ :: _ =>\n      let rec helper : List Int \u2192 Nat \u2192 Nat :=\n        fun ys idx =>\n          match ys with\n          | [] =>\n              idx\n          | y :: ys' =>\n              let isCurrent := y\n              let currentIndex := idx\n              let targetValue := target\n              let condition := targetValue \u2264 isCurrent\n              if condition then\n                currentIndex\n              else\n                let incrementedIndex := currentIndex + 1\n                let rest := ys'\n                helper rest incrementedIndex\n      let startingIndex := 0\n      let result := helper xs startingIndex\n      result\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef searchInsert_postcond (xs : List Int) (target : Int) (result: Nat) (h_precond : searchInsert_precond (xs) (target)) : Prop :=\n  -- !benchmark @start postcond\n  let allBeforeLess := (List.range result).all (fun i => xs[i]! < target)\n  let inBounds := result \u2264 xs.length\n  let insertedCorrectly :=\n    result < xs.length \u2192 target \u2264 xs[result]!\n  inBounds \u2227 allBeforeLess \u2227 insertedCorrectly\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem searchInsert_spec_satisfied (xs: List Int) (target: Int) (h_precond : searchInsert_precond (xs) (target)) :\n    searchInsert_postcond (xs) (target) (searchInsert (xs) (target) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "searchInsert",
    "parameters": {
      "param_name": [
        "xs",
        "target"
      ],
      "param_type": [
        "List Int",
        "Int"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/search-insert-position/",
      "task_id": "lab_searchInsert_325772357",
      "student_id": [
        50
      ]
    }
  },
  "tests": {
    "input": [
      "{\"xs\": \"[1, 3, 5, 6]\", \"target\": 5}",
      "{\"xs\": \"[1, 3, 5, 6]\", \"target\": 2}",
      "{\"xs\": \"[1, 3, 5, 6]\", \"target\": 7}",
      "{\"xs\": \"[1, 3, 5, 6]\", \"target\": 0}",
      "{\"xs\": \"[]\", \"target\": 3}",
      "{\"xs\": \"[10]\", \"target\": 5}",
      "{\"xs\": \"[10]\", \"target\": 15}"
    ],
    "expected": [
      [
        "2"
      ],
      [
        "1"
      ],
      [
        "4"
      ],
      [
        "0"
      ],
      [
        "0"
      ],
      [
        "0"
      ],
      [
        "1"
      ]
    ],
    "unexpected": [
      [
        "0",
        "1",
        "3",
        "4"
      ],
      [
        "0",
        "2",
        "3"
      ],
      [
        "2",
        "3"
      ],
      [
        "1",
        "2"
      ],
      [
        "1"
      ],
      [
        "1"
      ],
      [
        "0"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'xs': '[2, 1]', 'target': 5}",
      "{'xs': '[1, 1]', 'target': 2}"
    ]
  },
  "difficulty": "advanced"
}