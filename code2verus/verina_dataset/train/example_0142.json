{
  "id": "verina_advanced_47",
  "description": "-----Description-----\nThis task requires writing a Lean 4 method that merges all overlapping intervals from a given list of intervals.\n\nEach interval is represented as a pair [start, end], indicating the start and end of the interval. If two intervals overlap, they should be merged into a single interval that spans from the minimum start to the maximum end of the overlapping intervals.\n\nThe goal is to return a list of non-overlapping intervals that cover all the input intervals after merging.\n\n-----Input-----\nThe input consists of one array:\n\nintervals: An array of pairs of integers where intervals[i] = [start\u1d62, end\u1d62] represents the start and end of the ith interval.\n\n-----Output-----\nThe output is an array of pairs of integers:\nReturns the list of merged, non-overlapping intervals sorted by their start times.\n\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef mergeIntervals_precond (intervals : List (Prod Int Int)) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef mergeIntervals (intervals : List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : List (Prod Int Int) :=\n  -- !benchmark @start code\n  -- Insertion sort based on the start of intervals\n  let rec insert (x : Prod Int Int) (sorted : List (Prod Int Int)) : List (Prod Int Int) :=\n    match sorted with\n    | [] => [x]\n    | y :: ys => if x.fst \u2264 y.fst then x :: sorted else y :: insert x ys\n\n  let rec sort (xs : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs with\n    | [] => []\n    | x :: xs' => insert x (sort xs')\n\n  let sorted := sort intervals\n\n  -- Merge sorted intervals\n  let rec merge (xs : List (Prod Int Int)) (acc : List (Prod Int Int)) : List (Prod Int Int) :=\n    match xs, acc with\n    | [], _ => acc.reverse\n    | (s, e) :: rest, [] => merge rest [(s, e)]\n    | (s, e) :: rest, (ps, pe) :: accTail =>\n      if s \u2264 pe then\n        merge rest ((ps, max pe e) :: accTail)\n      else\n        merge rest ((s, e) :: (ps, pe) :: accTail)\n\n  merge sorted []\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef mergeIntervals_postcond (intervals : List (Prod Int Int)) (result: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) : Prop :=\n  -- !benchmark @start postcond\n  -- Check that all original intervals are covered by some result interval\n  let covered := intervals.all (fun (s, e) =>\n    result.any (fun (rs, re) => rs \u2264 s \u2227 e \u2264 re))\n\n  -- Check that no intervals in the result overlap\n  let rec noOverlap (l : List (Prod Int Int)) : Bool :=\n    match l with\n    | [] | [_] => true\n    | (_, e1) :: (s2, e2) :: rest => e1 < s2 && noOverlap ((s2, e2) :: rest)\n\n  covered \u2227 noOverlap result\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem mergeIntervals_spec_satisfied (intervals: List (Prod Int Int)) (h_precond : mergeIntervals_precond (intervals)) :\n    mergeIntervals_postcond (intervals) (mergeIntervals (intervals) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "mergeIntervals",
    "parameters": {
      "param_name": [
        "intervals"
      ],
      "param_type": [
        "List (Prod Int Int)"
      ]
    },
    "return_type": "List (Prod Int Int)"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "[{\"text_file_id\"=>804740898}]",
      "task_id": "lab_mergeIntervals_325627981",
      "student_id": [
        6
      ]
    }
  },
  "tests": {
    "input": [
      "{\"intervals\": \"[(1, 3), (2, 6), (8, 10), (15, 18)]\"}",
      "{\"intervals\": \"[(1, 4), (4, 5)]\"}",
      "{\"intervals\": \"[(1, 10), (2, 3), (4, 5)]\"}",
      "{\"intervals\": \"[(1, 2), (3, 4), (5, 6)]\"}",
      "{\"intervals\": \"[(5, 6), (1, 3), (2, 4)]\"}"
    ],
    "expected": [
      [
        "[(1, 6), (8, 10), (15, 18)]"
      ],
      [
        "[(1, 5)]"
      ],
      [
        "[(1, 10)]"
      ],
      [
        "[(1, 2), (3, 4), (5, 6)]"
      ],
      [
        "[(1, 4), (5, 6)]"
      ]
    ],
    "unexpected": [
      [
        "[(1, 3), (2, 6), (15, 19)]"
      ],
      [
        "[(1, 4), (4, 5), (1, 6)]"
      ],
      [
        "[(2, 3), (4, 5), (1, 5)]"
      ],
      [
        "[(1, 4), (5, 6), (1, 6)]"
      ],
      [
        "[(1, 3), (2, 4), (1, 6)]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}