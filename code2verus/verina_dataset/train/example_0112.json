{
  "id": "verina_basic_73",
  "description": "-----Description-----  \nDetermine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----  \nThe input consists of:  \n\u2022 s: A string that is to be matched.  \n\u2022 p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----  \nThe output is a Boolean value:  \n\u2022 Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.  \n\u2022 Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----  \nIt is assumed that both strings provided have the same length.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef Match_precond (s : String) (p : String) : Prop :=\n  -- !benchmark @start precond\n  s.toList.length = p.toList.length\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef Match (s : String) (p : String) (h_precond : Match_precond (s) (p)) : Bool :=\n  -- !benchmark @start code\n  let sList := s.toList\n  let pList := p.toList\n  let rec loop (i : Nat) : Bool :=\n    if i < sList.length then\n      if (sList[i]! \u2260 pList[i]!) \u2227 (pList[i]! \u2260 '?') then false\n      else loop (i + 1)\n    else true\n  loop 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef Match_postcond (s : String) (p : String) (result: Bool) (h_precond : Match_precond (s) (p)) :=\n  -- !benchmark @start postcond\n  (result = true \u2194 \u2200 n : Nat, n < s.toList.length \u2192 ((s.toList[n]! = p.toList[n]!) \u2228 (p.toList[n]! = '?')))\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem Match_spec_satisfied (s: String) (p: String) (h_precond : Match_precond (s) (p)) :\n    Match_postcond (s) (p) (Match (s) (p) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "Match",
    "parameters": {
      "param_name": [
        "s",
        "p"
      ],
      "param_type": [
        "String",
        "String"
      ]
    },
    "return_type": "Bool"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_match",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"s\": \"abc\", \"p\": \"a?c\"}",
      "{\"s\": \"hello\", \"p\": \"he?lo\"}",
      "{\"s\": \"world\", \"p\": \"w?rld\"}",
      "{\"s\": \"test\", \"p\": \"te?t\"}",
      "{\"s\": \"abc\", \"p\": \"abd\"}"
    ],
    "expected": [
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "True"
      ],
      [
        "False"
      ]
    ],
    "unexpected": [
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "False"
      ],
      [
        "True"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'s': 'abc', 'p': 'ac'}"
    ]
  },
  "difficulty": "basic"
}