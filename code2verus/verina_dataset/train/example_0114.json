{
  "id": "verina_basic_20",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.",
  "lean_code": "-- !benchmark @start import type=solution\nimport Std.Data.HashSet\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n\n@[reducible, simp]\ndef uniqueProduct_precond (arr : Array Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef uniqueProduct (arr : Array Int) (h_precond : uniqueProduct_precond (arr)) : Int :=\n  -- !benchmark @start code\n  let rec loop (i : Nat) (seen : Std.HashSet Int) (product : Int) : Int :=\n    if i < arr.size then\n      let x := arr[i]!\n      if seen.contains x then\n        loop (i + 1) seen product\n      else\n        loop (i + 1) (seen.insert x) (product * x)\n    else\n      product\n  loop 0 Std.HashSet.empty 1\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef uniqueProduct_postcond (arr : Array Int) (result: Int) (h_precond : uniqueProduct_precond (arr)) :=\n  -- !benchmark @start postcond\n  result - (arr.toList.eraseDups.foldl (\u00b7 * \u00b7) 1) = 0 \u2227\n  (arr.toList.eraseDups.foldl (\u00b7 * \u00b7) 1) - result = 0\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :\n    uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "uniqueProduct",
    "parameters": {
      "param_name": [
        "arr"
      ],
      "param_type": [
        "Array Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "dafny-synthesis",
      "link": "https://github.com/Mondego/dafny-synthesis",
      "task_id": "task_id_573",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"arr\": \"#[2, 3, 2, 4]\"}",
      "{\"arr\": \"#[5, 5, 5, 5]\"}",
      "{\"arr\": \"#[]\"}",
      "{\"arr\": \"#[1, 2, 3]\"}",
      "{\"arr\": \"#[0, 2, 3]\"}",
      "{\"arr\": \"#[-1, -2, -1, -3]\"}",
      "{\"arr\": \"#[10, 10, 20, 20, 30]\"}"
    ],
    "expected": [
      [
        "24"
      ],
      [
        "5"
      ],
      [
        "1"
      ],
      [
        "6"
      ],
      [
        "0"
      ],
      [
        "-6"
      ],
      [
        "6000"
      ]
    ],
    "unexpected": [
      [
        "12",
        "30",
        "0"
      ],
      [
        "25",
        "0",
        "10"
      ],
      [
        "0",
        "-1",
        "2"
      ],
      [
        "5",
        "7",
        "2"
      ],
      [
        "1",
        "-1",
        "10"
      ],
      [
        "-1",
        "6",
        "-3"
      ],
      [
        "600",
        "0",
        "5000"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}