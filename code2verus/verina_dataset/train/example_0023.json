{
  "id": "verina_advanced_52",
  "description": "-----Description-----\nThis task requires writing a Lean 4 function that finds the minimum number of operations to collect the integers from 1 to k by performing the following removal operation on a list of integers.\n\nA removal operation consists of removing the last element from the list nums and adding it to your collection.\n\nThe goal is to determine how many elements must be removed from the end of the list until the set of collected elements (that are less than or equal to k) contains all integers from 1 to k, inclusive.\n\n-----Input-----\nThe input consists of a list and a positive integer:\nnums: A list of positive integers.\nk: A positive integer representing the target upper bound for the collection (i.e., we want to collect 1, 2, ..., k).\n\n-----Output-----\nThe output is an integer:\nReturn the minimum number of operations (elements removed from the end of nums) required to have collected all integers from 1 to k.\n\n-----Note-----\nIt is assumed that the input list contains all integers from 1 to k.\n",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef minOperations_precond (nums : List Nat) (k : Nat) : Prop :=\n  -- !benchmark @start precond\n  let target_nums := (List.range k).map (\u00b7 + 1)\n  target_nums.all (fun n => List.elem n nums)\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef minOperations (nums : List Nat) (k : Nat) (h_precond : minOperations_precond (nums) (k)) : Nat :=\n  -- !benchmark @start code\n  -- edge case k=0, requires 0 operations\n  if k == 0 then 0 else\n  -- recursive helper function\n  let rec loop (remaining : List Nat) (collected : List Nat) (collected_count : Nat) (ops : Nat) : Nat :=\n    match remaining with\n    | [] => ops -- base case\n    | head :: tail =>\n      let ops' := ops + 1\n      -- check if the element is relevant (1 <= head <= k) and not already collected\n      -- use a list `collected` to keep track of unique numbers found so far\n      if head > 0 && head <= k && !(List.elem head collected) then\n          let collected' := head :: collected -- add new unique element to our tracking list\n          let collected_count' := collected_count + 1\n          if collected_count' == k then\n            ops' -- found all k distinct required numbers\n          else\n            loop tail collected' collected_count' ops' -- continue searching, count increased\n      else\n        -- element is irrelevant (> k), zero/negative, or a duplicate (already in `collected`)\n        loop tail collected collected_count ops' -- continue searching, count not increased\n  -- start the loop, initially empty collection, 0 count, 0 operations\n  loop nums.reverse [] 0 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef minOperations_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : minOperations_precond (nums) (k)) : Prop :=\n  -- !benchmark @start postcond\n  -- define the list of elements processed after `result` operations\n  let processed := (nums.reverse).take result\n  -- define the target numbers to collect (1 to k)\n  let target_nums := (List.range k).map (\u00b7 + 1)\n\n  -- condition 1: All target numbers must be present in the processed elements\n  let collected_all := target_nums.all (fun n => List.elem n processed)\n\n  -- condition 2: `result` must be the minimum number of operations.\n  -- This means either result is 0 (which implies k must be 0 as target_nums would be empty)\n  -- or result > 0, and taking one less operation (result - 1) is not sufficient\n  let is_minimal :=\n    if result > 0 then\n      -- if one fewer element is taken, not all target numbers should be present\n      let processed_minus_one := (nums.reverse).take (result - 1)\n      \u00ac (target_nums.all (fun n => List.elem n processed_minus_one))\n    else\n      -- if result is 0, it can only be minimal if k is 0 (no targets required)\n      -- So if k=0, `collected_all` is true. If result=0, this condition `k==0` ensures minimality.\n      k == 0\n\n  -- overall specification:\n  collected_all \u2227 is_minimal\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem minOperations_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : minOperations_precond (nums) (k)) :\n    minOperations_postcond (nums) (k) (minOperations (nums) (k) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "minOperations",
    "parameters": {
      "param_name": [
        "nums",
        "k"
      ],
      "param_type": [
        "List Nat",
        "Nat"
      ]
    },
    "return_type": "Nat"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "",
      "task_id": "lab_minOperations_325696322",
      "student_id": [
        40
      ]
    }
  },
  "tests": {
    "input": [
      "{\"nums\": \"[3, 1, 5, 4, 2]\", \"k\": 2}",
      "{\"nums\": \"[3, 1, 5, 4, 2]\", \"k\": 5}",
      "{\"nums\": \"[3, 2, 5, 3, 1]\", \"k\": 3}",
      "{\"nums\": \"[5, 4, 3, 2, 1]\", \"k\": 1}",
      "{\"nums\": \"[5, 4, 1, 2, 3]\", \"k\": 3}",
      "{\"nums\": \"[1, 3, 2, 2, 1]\", \"k\": 2}",
      "{\"nums\": \"[10, 1, 20, 2]\", \"k\": 2}",
      "{\"nums\": \"[1, 2, 3]\", \"k\": 0}"
    ],
    "expected": [
      [
        "4"
      ],
      [
        "5"
      ],
      [
        "4"
      ],
      [
        "1"
      ],
      [
        "3"
      ],
      [
        "2"
      ],
      [
        "3"
      ],
      [
        "0"
      ]
    ],
    "unexpected": [
      [
        "1",
        "2",
        "5"
      ],
      [
        "1",
        "2",
        "3"
      ],
      [
        "1",
        "2",
        "5"
      ],
      [
        "0",
        "2",
        "5"
      ],
      [
        "1",
        "4",
        "5"
      ],
      [
        "1",
        "3",
        "4"
      ],
      [
        "1",
        "2",
        "4"
      ],
      [
        "1",
        "2",
        "3"
      ]
    ]
  },
  "reject_inputs": {
    "input": [
      "{'nums': '[5, 6, 7, 8, 9]', 'k': 3}"
    ]
  },
  "difficulty": "advanced"
}