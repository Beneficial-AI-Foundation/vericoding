{
  "id": "verina_advanced_26",
  "description": "-----Description----- \nThis task requires writing a Lean 4 method that generates all possible letter combinations from a string of digits based on the traditional telephone keypad letter mappings.\n\n-----Input-----\nThe input consists of a string (String). The string may be empty.\n\n-----Output-----\nThe output is a list of strings (List String) where each string represents a unique combination of letters corresponding to the input digits. If the input string is empty, the output is an empty list.\n\n-----Note-----\n\nHere is the mapping from the number to possible letters:\n2: a or b or c\n3: d or e or f\n4: g or h or i\n5: j or k or l\n6: m or n or o\n7: p or q or r or s\n8: t or u or v\n9: w or x or y or z\nother number or not a number: no letters",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\ndef digitToLetters (c : Char) : List Char :=\n  match c with\n  | '2' => ['a', 'b', 'c']\n  | '3' => ['d', 'e', 'f']\n  | '4' => ['g', 'h', 'i']\n  | '5' => ['j', 'k', 'l']\n  | '6' => ['m', 'n', 'o']\n  | '7' => ['p', 'q', 'r', 's']\n  | '8' => ['t', 'u', 'v']\n  | '9' => ['w', 'x', 'y', 'z']\n  | _ => []\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible]\ndef letterCombinations_precond (digits : String) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n-- !benchmark @end code_aux\n\n\ndef letterCombinations (digits : String) (h_precond : letterCombinations_precond (digits)) : List String :=\n  -- !benchmark @start code\n  let chars := digits.toList\n  go chars\n  where\n    go : List Char \u2192 List String\n    | [] => []\n    | (d :: ds) =>\n      let restCombinations := go ds\n      let currentLetters := digitToLetters d\n      match restCombinations with\n      | [] => currentLetters.map (\u03bb c => String.singleton c)\n      | _ => currentLetters.flatMap (\u03bb c => restCombinations.map (\u03bb s => String.singleton c ++ s))\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible]\ndef letterCombinations_postcond (digits : String) (result: List String) (h_precond : letterCombinations_precond (digits)) : Prop :=\n  -- !benchmark @start postcond\n  if digits.isEmpty then\n    result = []\n  else if digits.toList.any (\u03bb c => \u00ac(c \u2208 ['2','3','4','5','6','7','8','9'])) then\n    result = []\n  else\n    let expected := digits.toList.map digitToLetters |>.foldl (\u03bb acc ls => acc.flatMap (\u03bb s => ls.map (\u03bb c => s ++ String.singleton c)) ) [\"\"]\n    result.length = expected.length \u2227 result.all (\u03bb s => s \u2208 expected) \u2227 expected.all (\u03bb s => s \u2208 result)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem letterCombinations_spec_satisfied (digits: String) (h_precond : letterCombinations_precond (digits)) :\n    letterCombinations_postcond (digits) (letterCombinations (digits) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n\n\n",
  "signature": {
    "name": "letterCombinations",
    "parameters": {
      "param_name": [
        "digits"
      ],
      "param_type": [
        "String"
      ]
    },
    "return_type": "List String"
  },
  "metadata": {
    "upstream": {
      "name": "lab_assignment",
      "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/",
      "task_id": "lab_letterCombinations_325016944",
      "student_id": [
        20
      ]
    }
  },
  "tests": {
    "input": [
      "{\"digits\": \"\"}",
      "{\"digits\": \"2\"}",
      "{\"digits\": \"9\"}",
      "{\"digits\": \"23\"}",
      "{\"digits\": \"27\"}",
      "{\"digits\": \"0\"}"
    ],
    "expected": [
      [
        "[]"
      ],
      [
        "[\"a\", \"b\", \"c\"]"
      ],
      [
        "[\"w\", \"x\", \"y\", \"z\"]"
      ],
      [
        "[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]"
      ],
      [
        "[\"ap\", \"aq\", \"ar\", \"as\", \"bp\", \"bq\", \"br\", \"bs\", \"cp\", \"cq\", \"cr\", \"cs\"]"
      ],
      [
        "[]"
      ]
    ],
    "unexpected": [
      [
        "[\"a\"]",
        "[\"b\"]"
      ],
      [
        "[\"a\"]",
        "[\"b\"]",
        "[\"c\"]"
      ],
      [
        "[\"w\"]",
        "[\"x\"]",
        "[\"y\"]",
        "[\"z\"]"
      ],
      [
        "[\"a\"]",
        "[\"b\"]",
        "[\"c\"]"
      ],
      [
        "[\"p\"]",
        "[\"q\"]",
        "[\"r\"]",
        "[\"s\"]"
      ],
      [
        "[\"a\"]",
        "[\"b\"]"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "advanced"
}