{
  "id": "verina_basic_62",
  "description": "-----Description-----  \nThe problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----  \nThe input consists of:  \n\u2022 a: An array of integers.  \n\u2022 key: An integer representing the value to search for in the array.\n\n-----Output-----  \nThe output is an integer which represents:  \n\u2022 The index in the array where the key is found, provided that the index is in the range [0, a.size).  \n\u2022 -1 if the key is not present in the array.  \nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----  \nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.",
  "lean_code": "-- !benchmark @start import type=solution\n\n-- !benchmark @end import\n\n-- !benchmark @start solution_aux\n\n-- !benchmark @end solution_aux\n\n-- !benchmark @start precond_aux\n\n-- !benchmark @end precond_aux\n@[reducible, simp]\ndef Find_precond (a : Array Int) (key : Int) : Prop :=\n  -- !benchmark @start precond\n  True\n  -- !benchmark @end precond\n\n\n-- !benchmark @start code_aux\n\n-- !benchmark @end code_aux\n\n\ndef Find (a : Array Int) (key : Int) (h_precond : Find_precond (a) (key)) : Int :=\n  -- !benchmark @start code\n  let rec search (index : Nat) : Int :=\n    if index < a.size then\n      if a[index]! = key then Int.ofNat index\n      else search (index + 1)\n    else -1\n  search 0\n  -- !benchmark @end code\n\n\n-- !benchmark @start postcond_aux\n\n-- !benchmark @end postcond_aux\n\n\n@[reducible, simp]\ndef Find_postcond (a : Array Int) (key : Int) (result: Int) (h_precond : Find_precond (a) (key)) :=\n  -- !benchmark @start postcond\n  (result = -1 \u2228 (result \u2265 0 \u2227 result < Int.ofNat a.size))\n  \u2227 ((result \u2260 -1) \u2192 (a[(Int.toNat result)]! = key \u2227 \u2200 (i : Nat), i < Int.toNat result \u2192 a[i]! \u2260 key))\n  \u2227 ((result = -1) \u2192 \u2200 (i : Nat), i < a.size \u2192 a[i]! \u2260 key)\n  -- !benchmark @end postcond\n\n\n-- !benchmark @start proof_aux\n\n-- !benchmark @end proof_aux\n\n\ntheorem Find_spec_satisfied (a: Array Int) (key: Int) (h_precond : Find_precond (a) (key)) :\n    Find_postcond (a) (key) (Find (a) (key) h_precond) h_precond := by\n  -- !benchmark @start proof\n  sorry\n  -- !benchmark @end proof\n",
  "signature": {
    "name": "Find",
    "parameters": {
      "param_name": [
        "a",
        "key"
      ],
      "param_type": [
        "Array Int",
        "Int"
      ]
    },
    "return_type": "Int"
  },
  "metadata": {
    "upstream": {
      "name": "clover",
      "link": "https://github.com/ChuyueSun/Clover",
      "task_id": "Clover_find",
      "student_id": null
    }
  },
  "tests": {
    "input": [
      "{\"a\": \"#[1, 2, 3, 4, 5]\", \"key\": 3}",
      "{\"a\": \"#[5, 7, 5, 9]\", \"key\": 5}",
      "{\"a\": \"#[2, 4, 6, 8]\", \"key\": 5}",
      "{\"a\": \"#[]\", \"key\": 10}",
      "{\"a\": \"#[0, -3, -1, -3]\", \"key\": -3}"
    ],
    "expected": [
      [
        "2"
      ],
      [
        "0"
      ],
      [
        "-1"
      ],
      [
        "-1"
      ],
      [
        "1"
      ]
    ],
    "unexpected": [
      [
        "1",
        "3",
        "0"
      ],
      [
        "2",
        "-1"
      ],
      [
        "0",
        "1",
        "3"
      ],
      [
        "0",
        "1",
        "10"
      ],
      [
        "0",
        "2",
        "3"
      ]
    ]
  },
  "reject_inputs": {
    "input": []
  },
  "difficulty": "basic"
}