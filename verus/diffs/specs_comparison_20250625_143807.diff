Found 1339 files with the same name in both directories.

================================================================================
Comparing translations/atomizer_supported/630-dafny_tmp_tmpz2kokaiq_Solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/630-dafny_tmp_tmpz2kokaiq_Solution_spec.rs
+++ verus_specs/translations/atomizer_supported/630-dafny_tmp_tmpz2kokaiq_Solution_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, x: int) -> (index: int)

-    requires sorted(a)

-    ensures 0 <= index < a.len() ==> a[index] == x,

-            index == -1 ==> forall i : int :: 0 <= i < a.len() ==> a[i] != x

-{

+spec fn sorted(a: &[i32]) -> bool {

+    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

 }

 

+pub fn BinarySearch(a: &[i32], x: i32) -> (index: i32)

+    requires sorted(a)

+    ensures 0 <= index < a.len() ==> a[index as int] == x

+    ensures index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x

+{

 }

================================================================================
Comparing translations/atomizer_supported/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec.rs
+++ verus_specs/translations/atomizer_supported/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec.rs
@@ -1,32 +1,97 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Sorted(q: Seq<int>) -> bool {

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

-spec fn Inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {

-    (i <= a1.len()) and (i <= a2.len()) and (i+mid <= a.len()) and

-    (a1[..i] == a[..i]) and (a2[..i] == a[mid..(i+mid)])

-}

-spec fn InvSorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

-    i <= c.len() and j <= d.len() and i + j <= b.len() and

-	((i+j > 0 and i < c.len()) ==> (b[j + i - 1] <= c[i])) and

-	((i+j > 0 and j < d.len()) ==> (b[j + i - 1] <= d[j])) and

-	Sorted(b[..i+j])

-}

-spec fn InvSubSet(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

-    i <= c.len() and j <= d.len() and i + j <= b.len() and

-	multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])

-}

 

-fn MergeSort(a: Vec<int>) -> (b: Vec<int>)

-    ensures b.len() == a.len() and Sorted(b[..]) and multiset(a[..]) == multiset(b[..])

+pub fn merge_sort(a: &[int]) -> (b: Vec<int>)

+    ensures

+        b.len() == a.len() && sorted(b@) && a@.to_multiset() == b@.to_multiset()

 {

 }

 

+spec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {

+    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&

+    (a1.subrange(0, i as int) == a.subrange(0, i as int)) && (a2.subrange(0, i as int) == a.subrange(mid as int, (i + mid) as int))

+}

+

+pub fn merge(b: &mut [int], c: &[int], d: &[int])

+    requires

+        old(b).len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@)

+    ensures

+        sorted(b@) && b@.to_multiset() == c@.to_multiset() + d@.to_multiset()

+{

+}

+

+pub fn merge_loop(b: &mut [int], c: &[int], d: &[int], i0: usize, j0: usize) -> (i: usize, j: usize)

+    requires

+        old(b).len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@),

+        i0 <= c.len() && j0 <= d.len() && i0 + j0 <= old(b).len(),

+        inv_sub_set(old(b)@, c@, d@, i0, j0),

+        inv_sorted(old(b)@, c@, d@, i0, j0),

+        i0 + j0 < old(b).len()

+    ensures

+        i <= c.len() && j <= d.len() && i + j <= b.len(),

+        inv_sub_set(b@, c@, d@, i, j),

+        inv_sorted(b@, c@, d@, i, j),

+        0 <= c.len() - i < c.len() - i0 || (c.len() - i == c.len() - i0 && 0 <= d.len() - j < d.len() - j0)

+{

+}

+

+spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool {

+    i <= c.len() && j <= d.len() && i + j <= b.len() &&

+    ((i + j > 0 && i < c.len()) ==> (b[i + j - 1] <= c[i as int])) &&

+    ((i + j > 0 && j < d.len()) ==> (b[i + j - 1] <= d[j as int])) &&

+    sorted(b.subrange(0, (i + j) as int))

+}

+

+spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool {

+    i <= c.len() && j <= d.len() && i + j <= b.len() &&

+    b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+}

+

+proof fn lemma_multisets_equals(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires

+        i == c.len(),

+        j == d.len(),

+        i + j == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+    ensures

+        b.to_multiset() == c.to_multiset() + d.to_multiset()

+{

+}

+

+proof fn lemma_inv_subset_take_value_from_c(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires

+        i < c.len(),

+        j <= d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[i + j] == c[i as int]

+    ensures

+        b.subrange(0, (i + j + 1) as int).to_multiset() == c.subrange(0, (i + 1) as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+{

+}

+

+proof fn lemma_inv_subset_take_value_from_d(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires

+        i <= c.len(),

+        j < d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[i + j] == d[j as int]

+    ensures

+        b.subrange(0, (i + j + 1) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, (j + 1) as int).to_multiset()

+{

+}

+

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec.rs
+++ verus_specs/translations/atomizer_supported/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec.rs
@@ -1,33 +1,78 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

+pub enum Tree {

+    Empty,

+    Node { left: Box<Tree>, value: int, right: Box<Tree> }

 }

 

-fn GetMin(tree: Tree) -> (res: int)

+

+pub open spec fn BinarySearchTree(tree: Tree) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value, right } => {

+            (matches!(**left, Tree::Empty) || left.get_Node_value() < value)

+            && (matches!(**right, Tree::Empty) || right.get_Node_value() > value)

+            && BinarySearchTree(**left) && BinarySearchTree(**right)

+            && minValue(**right, value) && maxValue(**left, value)

+        }

+    }

+}

+

+

+pub open spec fn maxValue(tree: Tree, max: int) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => (max > v) && maxValue(**left, max) && maxValue(**right, max)

+    }

+}

+

+

+pub open spec fn minValue(tree: Tree, min: int) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => (min < v) && minValue(**left, min) && minValue(**right, min)

+    }

+}

+

+

+pub fn GetMin(tree: Tree) -> (res: int) {

+}

+

+

+pub fn GetMax(tree: Tree) -> (res: int) {

+}

+

+

+pub fn insert(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(BinarySearchTree(res))

 {

 }

 

+

+pub fn insertRecursion(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(res != Tree::Empty ==> BinarySearchTree(res))

+    ensures(forall|x: int| minValue(tree, x) && x < value ==> minValue(res, x))

+    ensures(forall|x: int| maxValue(tree, x) && x > value ==> maxValue(res, x))

+{

+}

+

+

+pub fn delete(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+

+

+{

+}

+

+

+pub fn Inorder(tree: Tree) {

+}

+

+

+pub fn Postorder(tree: Tree) {

+}

+

+

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec.rs
+++ verus_specs/translations/atomizer_supported/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec.rs
@@ -1,15 +1,45 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn isPrefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

 }

 

+

+

+

+

+

+pub fn isSubstring(sub: &str, str: &str) -> bool

+    requires(0 < sub.len() <= str.len())

+{

+}

+

+

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> bool

+    requires(0 < k <= str1.len() && 0 < k <= str2.len())

+{

+}

+

+

+

+

+

+

+pub fn maxCommonSubstringLength(str1: &str, str2: &str) -> nat

+    requires(0 < str1.len() && 0 < str1.len())

+{

+}

+

+

+

+

+

+

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec.rs
+++ verus_specs/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec.rs
@@ -1,15 +1,66 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(x: nat, y: nat) -> (r: nat)

-    ensures (r >= x and r >=y),

-            (r == x or r == y)

+pub fn Max(x: nat, y: nat) -> r: nat

+    requires()

+    ensures(r >= x && r >= y)

+    ensures(r == x || r == y)

 {

 }

 

+

+pub fn Test()

+    requires()

+    ensures()

+{

+}

+

+

+pub fn m1(x: int, y: int) -> z: int

+    requires(0 < x < y)

+    ensures(z >= 0 && z <= y && z != x)

+{

+}

+

+

+spec fn fib(n: nat) -> nat

+{

+    if n == 0 { 1 } else

+    if n == 1 { 1 } else

+    fib(n - 1) + fib(n - 2)

+}

+

+

+pub fn Fib(n: nat) -> r: nat

+    requires()

+    ensures(r == fib(n))

+{

+}

+

+

+enum List<T> {

+    Nil,

+    Cons { head: T, tail: Box<List<T>> }

+}

+

+

+spec fn add(l: List<int>) -> int

+{

+    match l {

+        List::Nil => 0,

+        List::Cons { head: x, tail: xs } => x + add(*xs)

+    }

+}

+

+

+pub fn addImp(l: List<int>) -> s: int

+    requires()

+    ensures(s == add(l))

+{

+}

+

+

+pub fn MaxA(a: &[int]) -> m: int

+    requires(a.len() > 0)

+    ensures(forall|i: usize| 0 <= i < a.len() ==> a[i] <= m)

+    ensures(exists|i: usize| 0 <= i < a.len() && a[i] == m)

+{

 }

================================================================================
Comparing translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec.rs
+++ verus_specs/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec.rs
@@ -1,36 +1,82 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn is_prefix_sum_for(a: Vec<int>, c: Vec<int>, a

+

+

+

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

 {

-    a.Length + 1 == c.Length

-    && c[0] == 0

-    && forall j: : 1 <= j <= a.Length ==> c[j] == sum(a, 0, j)

+    if i == j {

+        0

+    } else {

+        a[j-1] + sum(a, i, j-1)

+    }

 }

 

 

 

 

 

-

-datatype List<T> = Nil | Cons(head: T, tail: List<T>)

-

-

-method from_array<T>(a: array<T>) returns (l: List<T>)

-requires a.Length > 0

-ensures forall j::0 <= j < a.Length ==> mem(a[j], l) -> bool {

-    

-}

-

-fn query(a: Vec<int>, i: int, j: int) -> (s: int)

-    requires 0 <= i <= j <= a.len()

-    ensures s == sum(a, i, j)

+pub fn query(a: &[int], i: int, j: int) -> (s: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(s == sum(a, i, j))

 {

 }

 

+

+

+

+

+proof fn queryLemma(a: &[int], i: int, j: int, k: int)

+    requires(0 <= i <= k <= j <= a.len())

+    ensures(sum(a,i,k) + sum(a,k,j) == sum(a,i,j))

+{

+}

+

+

+

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> (r: int)

+    requires(is_prefix_sum_for(a,c) && 0 <= i <= j <= a.len() < c.len())

+    ensures(r == sum(a, i,j))

+{

+}

+

+

+

+spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool

+{

+    a.len() + 1 == c.len()

+    && c[0] == 0

+    && forall|j: int| 1 <= j <= a.len() ==> c[j] == sum(a,0,j)

+}

+

+

+

+

+

+enum List<T> {

+    Nil,

+    Cons { head: T, tail: Box<List<T>> }

+}

+

+

+

+pub fn from_array<T>(a: &[T]) -> (l: List<T>)

+    requires(a.len() > 0)

+    ensures(forall|j: int| 0 <= j < a.len() ==> mem(a[j], l))

+{

+}

+

+

+

+spec fn mem<T>(x: T, l: List<T>) -> bool

+{

+    match l {

+        List::Nil => false,

+        List::Cons { head: y, tail: r } => if x == y { true } else { mem(x, *r) }

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec.rs
+++ verus_specs/translations/atomizer_supported/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec.rs
@@ -1,15 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn fillK(a: Vec<int>, n: int, k: int, c: int) -> (b: bool)

-    requires 0 <= c <= n,

-             n == a.len()

+pub fn fillK(a: &[i32], n: usize, k: i32, c: usize) -> (b: bool)

+    requires(0 <= c <= n)

+    requires(n == a.len())

 {

 }

 

+pub fn containsSubString(a: &[char], b: &[char]) -> (pos: i32)

+    requires(0 <= b.len() <= a.len())

+{

 }

================================================================================
Comparing translations/atomizer_supported/CVS-handout1_tmp_tmptm52no3k_1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/CVS-handout1_tmp_tmptm52no3k_1_spec.rs
+++ verus_specs/translations/atomizer_supported/CVS-handout1_tmp_tmptm52no3k_1_spec.rs
@@ -1,44 +1,44 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn is_prefix_sum_for(a: Vec<int>, c: Vec<int>, a

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

 {

-    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]

+    if i == j { 0 } else { a[i as usize] + sum(a, i+1, j) }

 }

 

-

-

-

-lemma aux(a: array<int>, c: Vec<int>, i: int, j: int)

-    requires 0 <= i <= j <= a.Length

-    requires a.Length + 1 == c.Length

-    requires c[0] == 0

-    requires is_prefix_sum_for(a, c)

-    ensures forall k: int :: i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k] - c[i] + c[j] - c[k]

-{}

-

-

-

-

-

-

-method queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) returns (r: int)

-    requires a.Length + 1 == c.Length && c[0] == 0

-    requires 0 <= i <= j <= a.Length

-    requires is_prefix_sum_for(a, c)  

-    ensures r == sum(a, i, j) -> bool {

-    

-}

-

-fn query(a: Vec<int>, i: int, j: int) -> (res: int)

+pub fn query(a: &[int], i: int, j: int) -> (res: int)

     requires 0 <= i <= j <= a.len()

     ensures res == sum(a, i, j)

 {

 }

 

+spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool

+{

+    a.len() + 1 == c.len() && c[0] == 0 &&

+    forall|i: int| 0 <= i < a.len() ==> c[(i+1) as usize] == c[i as usize] + a[i as usize]

+}

+

+proof fn aux(a: &[int], c: &[int], i: int, j: int)

+    requires 0 <= i <= j <= a.len()

+    requires a.len() + 1 == c.len()

+    requires c[0] == 0

+    requires is_prefix_sum_for(a, c)

+    ensures forall|k: int| i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k as usize] - c[i as usize] + c[j as usize] - c[k as usize]

+{

+}

+

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> (r: int)

+    requires a.len() + 1 == c.len() && c[0] == 0

+    requires 0 <= i <= j <= a.len()

+    requires is_prefix_sum_for(a, c)

+    ensures r == sum(a, i, j)

+{

+}

+

+pub fn Main()

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/Clover_abs_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_abs_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_abs_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures x>=0 ==> x==y,

-            x<0 ==> x+y==0

+pub fn abs(x: int) -> (y: int)

+    ensures(x >= 0 ==> x == y),

+    ensures(x < 0 ==> x + y == 0),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_all_digits_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_all_digits_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_all_digits_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn allDigits(s: String) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < s.len() ==> s[i] in "0123456789")

+pub fn allDigits(s: &str) -> (result: bool)

+    ensures(result <==> (forall|i: usize| 0 <= i < s.len() ==> "0123456789".contains(s.chars().nth(i).unwrap())))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_array_append_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_array_append_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_array_append_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn append(a: Vec<int>, b: int) -> (c: Vec<int>)

-    ensures a[..] + [b] == c[..]

+pub fn append(a: &[int], b: int) -> (c: Vec<int>)

+    ensures(a@ + [b] == c@)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_array_concat_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_array_concat_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_array_concat_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn concat(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    ensures c.len()==b.len()+a.len(),

-            forall|k: int| 0 <= k < a.len() ==> c[k] == a[k],

-            forall|k: int| 0 <= k < b.len() ==> c[k+a.len()] == b[k]

+pub fn concat(a: &[int], b: &[int]) -> (c: Vec<int>)

+    ensures(c.len() == b.len() + a.len())

+    ensures(forall|k: int| 0 <= k < a.len() ==> c[k] == a[k])

+    ensures(forall|k: int| 0 <= k < b.len() ==> c[k + a.len()] == b[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_array_product_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_array_product_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_array_product_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arrayProduct(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] * b[i]==c[i]

+pub fn arrayProduct(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i && i < a.len() ==> a[i] * b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_array_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_array_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_array_sum_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arraySum(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] + b[i]==c[i]

+pub fn arraySum(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> a[i] + b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_avg_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_avg_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_avg_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeAvg(a: int, b: int) -> (avg: int)

-    ensures avg == (a+b)/2

+pub fn compute_avg(a: int, b: int) -> (avg: int)

+    ensures(avg == (a + b) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_below_zero_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_below_zero_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_below_zero_spec.rs
@@ -1,18 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn below_zero(operations: Seq<int>) -> s: Vec<int>, result: bool

-    ensures s.len() == operations.len() + 1,

-            s[0]==0,

-            forall|i: int| 0 <= i < s.len()-1 ==> s[i+1]==s[i]+operations[i],

-            result == true ==> (exists|i: int| 1 <= i <= operations.len() and s[i] < 0),

-            result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

+pub fn below_zero(operations: Seq<int>) -> (s: Vec<int>, result: bool)

+    ensures

+        s.len() == operations.len() + 1,

+        s[0] == 0,

+        forall|i: int| 0 <= i < s.len() - 1 ==> s[i + 1] == s[i] + operations[i],

+        result == true ==> (exists|i: int| 1 <= i <= operations.len() && s[i] < 0),

+        result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_binary_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_binary_search_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_binary_search_spec.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, key: int) -> (n: int)

-    requires forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j]

-    ensures 0<= n <=a.len(),

-            forall|i: int| 0<= i < n ==> a[i] < key,

-            n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key,

-            forall|i: int| n<= i < a.len() ==> a[i]>=key

+pub fn binary_search(a: &[i32], key: i32) -> (n: usize)

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    ensures(|n: usize|

+        0 <= n <= a.len() &&

+        (forall|i: usize| 0 <= i < n ==> a[i] < key) &&

+        (n == a.len() ==> forall|i: usize| 0 <= i < a.len() ==> a[i] < key) &&

+        (forall|i: usize| n <= i < a.len() ==> a[i] >= key)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_cal_ans_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_cal_ans_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_cal_ans_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalDiv() -> x: int, y: int

-    ensures x==191/7,

-            y==191%7

+pub fn CalDiv() -> (x: int, y: int)

+    ensures(x == 191 / 7)

+    ensures(y == 191 % 7)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_cal_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_cal_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_cal_sum_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sum(N: int) -> (s: int)

-    requires N >= 0

-    ensures s == N * (N + 1) / 2

+pub fn sum(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == n * (n + 1) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_canyon_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_canyon_search_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_canyon_search_spec.rs
@@ -1,18 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CanyonSearch(a: Vec<int>, b: Vec<int>) -> (d: nat)

-    requires a.len() !=0 and b.len()!=0,

-             forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j],

-             forall|i: int, j: int| 0<=i<j<b.len() ==> b[i]<=b[j]

-    ensures exists|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() and d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j]),

-            forall|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])

+pub fn canyon_search(a: &[i32], b: &[i32]) -> nat

+    requires(

+        a.len() != 0 && b.len() != 0

+    )

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < b.len() ==> b[i] <= b[j]

+    )

+    ensures(|d: nat|

+        exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() && d == if a[i] < b[j] { (b[j] - a[i]) as nat } else { (a[i] - b[j]) as nat }

+    )

+    ensures(|d: nat|

+        forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() ==> d <= if a[i] < b[j] { (b[j] - a[i]) as nat } else { (a[i] - b[j]) as nat }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_convert_map_key_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_convert_map_key_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_convert_map_key_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn convert_map_key(inputs: map<nat, bool>, f: nat->nat) -> r: map<nat, bool>

-    requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)

-    ensures forall|k: int| k in inputs <==> f(k) in r,

-            forall|k: int| k in inputs ==> r[f(k)] == inputs[k]

+pub fn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)

+    requires(

+        forall|n1: nat, n2: nat| n1 != n2 ==> f(n1) != f(n2)

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k))

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_copy_part_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_copy_part_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_copy_part_spec.rs
@@ -1,19 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn copy(src: Vec<int>, sStart: nat, dest: Vec<int>, dStart: nat, len: nat) -> (r: Vec<int>)

-    requires src.len() >= sStart + len,

-             dest.len() >= dStart + len

-    ensures r.len() == dest.len(),

-            r[..dStart] == dest[..dStart],

-            r[dStart + len..] == dest[dStart + len..],

-            r[dStart..len+dStart] == src[sStart..len+sStart]

+pub fn copy(src: &[i32], s_start: usize, dest: &[i32], d_start: usize, len: usize) -> Vec<i32>

+    requires 

+        src.len() >= s_start + len,

+        dest.len() >= d_start + len,

+    ensures |r: Vec<i32>|

+        r.len() == dest.len() &&

+        r.subrange(0, d_start as int) == dest.subrange(0, d_start as int) &&

+        r.subrange((d_start + len) as int, dest.len() as int) == dest.subrange((d_start + len) as int, dest.len() as int) &&

+        r.subrange(d_start as int, (len + d_start) as int) == src.subrange(s_start as int, (len + s_start) as int)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_count_lessthan_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_count_lessthan_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_count_lessthan_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLessThan(numbers: set<int>, threshold: int) -> (count: int)

-    ensures count == set i .len() i in numbers and i < threshold|

+pub fn count_less_than(numbers: Set<int>, threshold: int) -> (count: int)

+    ensures(count == numbers.filter(|i: int| i < threshold).len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_double_quadruple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_double_quadruple_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_double_quadruple_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DoubleQuadruple(x: int) -> a: int, b: int

-    ensures a == 2 * x and b == 4 * x

+pub fn DoubleQuadruple(x: int) -> (a: int, b: int)

+    ensures(a == 2 * x && b == 4 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_even_list_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_even_list_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_even_list_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindEvenNumbers(arr: Vec<int>) -> (evenNumbers: Vec<int>)

-    ensures forall x

+pub fn find_even_numbers(arr: &[i32]) -> Vec<i32>

+    ensures(forall|x: i32| arr.contains(&x) && (x % 2 == 0) ==> result@.contains(&x))

+    ensures(forall|x: i32| !arr.contains(&x) ==> !result@.contains(&x))

+    ensures(forall|k: int| 0 <= k < result@.len() ==> result@[k] % 2 == 0)

+    ensures(forall|k: int, l: int| 0 <= k < l < result@.len() ==>

+                exists|n: int, m: int| 0 <= n < m < arr.len() && result@[k] == arr[n] && result@[l] == arr[m])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_find_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_find_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_find_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(a: Vec<int>, key: int) -> (index: int)

-    ensures -1<=index<a.len(),

-            index!=-1 ==> a[index]==key and (forall|i: int| 0 <= i < index ==> a[i] != key),

-            index == -1 ==> (forall|i: int|0 <= i < a.len() ==> a[i] != key)

+pub fn find(a: &[i32], key: i32) -> (index: i32)

+    ensures(

+        -1 <= index < a.len(),

+        index != -1 ==> a[index as int] == key && forall|i: int| 0 <= i < index ==> a[i] != key,

+        index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != key,

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_integer_square_root_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_integer_square_root_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_integer_square_root_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareRoot(N: nat) -> (r: nat)

-    ensures r*r <= N < (r+1)*(r+1)

+pub fn square_root(n: nat) -> (r: nat)

+    ensures(r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_is_even_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_is_even_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_is_even_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeIsEven(x: int) -> (is_even: bool)

-    ensures (x % 2 == 0)==is_even

+pub fn compute_is_even(x: int) -> (is_even: bool)

+    ensures((x % 2 == 0) == is_even)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_is_palindrome_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_is_palindrome_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_is_palindrome_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPalindrome(x: Seq<char>) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1])

+pub fn IsPalindrome(x: Seq<char>) -> (result: bool)

+    ensures(result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_linear_search1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_linear_search1_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_linear_search1_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    ensures 0<=n<=a.len(),

-            n==a.len() or a[n]==e,

-            forall|i: int|0<=i < n ==> e!=a[i]

+pub fn linear_search(a: &[i32], e: i32) -> n: usize

+    ensures([

+        n <= a.len(),

+        n == a.len() || a[n as int] == e,

+        forall|i: int| 0 <= i < n ==> e != a[i],

+    ])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_linear_search2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_linear_search2_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_linear_search2_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    requires exists|i: int|0<=i<a.len() and a[i]==e

-    ensures 0<=n<a.len() and a[n]==e,

-            forall|k: int| 0 <= k < n ==> a[k]!=e

+pub fn linear_search(a: &[int], e: int) -> (n: int)

+    requires(exists|i: int| 0 <= i < a.len() && a[i] == e)

+    ensures(|n: int| 0 <= n < a.len() && a[n] == e)

+    ensures(|n: int| forall|k: int| 0 <= k < n ==> a[k] != e)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_longest_prefix_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_longest_prefix_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_longest_prefix_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LongestCommonPrefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

-    ensures prefix.len() <= str1.len() and prefix == str1[0..prefix.len()]and prefix.len() <= str2.len() and prefix == str2[0..prefix.len()],

-            prefix.len()==str1.len() | .len()prefix==.len()str2 .len() (str1[.len()prefix]!=str2[.len()prefix|])

+pub fn longest_common_prefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

+    ensures(|prefix| <= |str1| && prefix == str1.subrange(0, |prefix| as int) && |prefix| <= |str2| && prefix == str2.subrange(0, |prefix| as int))

+    ensures(|prefix| == |str1| || |prefix| == |str2| || (str1[|prefix| as int] != str2[|prefix| as int]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_match_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_match_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_match_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Match(s: String, p: String) -> (b: bool)

-    requires s.len() == p.len()

-    ensures b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] or p[n] == '?'

+pub fn Match(s: &str, p: &str) -> (b: bool)

+    requires(s.len() == p.len())

+    ensures(b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] || p[n] == '?')

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_max_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_max_array_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_max_array_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxArray(a: Vec<int>) -> (m: int)

-    requires a.len() >= 1

-    ensures forall|k: int| 0 <= k < a.len() ==> m >= a[k],

-            exists|k: int| 0 <= k < a.len() and m == a[k]

+pub fn maxArray(a: &[i32]) -> (m: i32)

+    requires(a.len() >= 1)

+    ensures(forall|k: usize| 0 <= k && k < a.len() ==> m >= a[k])

+    ensures(exists|k: usize| 0 <= k && k < a.len() && m == a[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_min_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_min_array_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_min_array_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn minArray(a: Vec<int>) -> (r: int)

+pub fn minArray(a: &[i32]) -> (r: i32)

     requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> r <= a[i],

-            exists|i: int| 0 <= i < a.len() and r == a[i]

+    ensures forall|i: usize| 0 <= i < a.len() ==> r <= a[i]

+    ensures exists|i: usize| 0 <= i < a.len() && r == a[i]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_min_of_two_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_min_of_two_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_min_of_two_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(x: int, y: int) -> (z: int)

-    ensures x<=y ==> z==x,

-            x>y ==> z==y

+pub fn Min(x: int, y: int) -> (z: int)

+    ensures x <= y ==> z == x,

+    ensures x > y ==> z == y,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_multi_return_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_multi_return_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_multi_return_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultipleReturns(x: int, y: int) -> more: int, less: int

-    ensures more == x+y,

-            less == x-y

+pub fn multiple_returns(x: int, y: int) -> (more: int, less: int)

+    ensures(|result: (int, int)| result.0 == x + y)

+    ensures(|result: (int, int)| result.1 == x - y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_online_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_online_max_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_online_max_spec.rs
@@ -1,20 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn onlineMax(a: Vec<int>, x: int) -> ghost m: int, p: int

-    requires 1<=x<a.len(),

-             a.len()!=0

-    ensures x<=p<a.len(),

-            forall|i: int|0<=i<x==> a[i]<=m,

-            exists|i: int|0<=i<x and a[i]==m,

-            x<=p<a.len()-1 ==> (forall|i: int|0<=i<p ==> a[i]<a[p]),

-            (forall|i: int|x<=i<a.len() and a[i]<=m) ==> p==a.len()-1

+pub fn onlineMax(a: &[int], x: int) -> (ghost m: int, p: int)

+    requires(1 <= x < a.len())

+    requires(a.len() != 0)

+    ensures(|result: (int, int)| x <= result.1 < a.len())

+    ensures(|result: (int, int)| forall|i: int| 0 <= i < x ==> a[i] <= result.0)

+    ensures(|result: (int, int)| exists|i: int| 0 <= i < x && a[i] == result.0)

+    ensures(|result: (int, int)| x <= result.1 < a.len() - 1 ==> (forall|i: int| 0 <= i < result.1 ==> a[i] < a[result.1 as int]))

+    ensures(|result: (int, int)| (forall|i: int| x <= i < a.len() && a[i] <= result.0) ==> result.1 == a.len() - 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_quotient_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_quotient_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_quotient_spec.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(x: nat, y: nat) -> r: int, q: int

-    requires y != 0

-    ensures q * y + r == x and 0 <= r < y and 0 <= q

+pub fn quotient(x: nat, y: nat) -> (r: int, q: int)

+    requires(y != 0)

+    ensures(|result: (int, int)| {

+        let (r, q) = result;

+        q * y + r == x && 0 <= r < y && 0 <= q

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_remove_front_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_remove_front_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_remove_front_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn remove_front(a: Vec<int>) -> (c: Vec<int>)

-    requires a.len()>0

-    ensures a[1..] == c[..]

+pub fn remove_front(a: &[i32]) -> (c: Vec<i32>)

+    requires(a.len() > 0)

+    ensures(a[1..] == c[..])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_return_seven_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_return_seven_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_return_seven_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(x: int) -> (seven: int)

-    ensures seven==7

+pub fn M(x: int) -> (seven: int)

+    ensures seven == 7

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_rotate_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_rotate_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_rotate_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn rotate(a: Vec<int>, offset: int) -> (b: Vec<int>)

-    requires 0<=offset

-    ensures b.len()==a.len(),

-            forall|i: int|0<=i<a.len() ==>  b[i]==a[(i+offset)%a.len()]

+pub fn rotate(a: &[i32], offset: i32) -> Vec<i32>

+    requires(0 <= offset)

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> result[i] == a[(i + offset as usize) % a.len()])

 {

-}

-

+    unimplemented!()

 }

================================================================================
Comparing translations/atomizer_supported/Clover_slope_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_slope_search_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_slope_search_spec.rs
@@ -1,18 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SlopeSearch(a: array2<int>, key: int) -> m: int, n: int

-    requires forall|i: int, j: int, j': int|0<=i<a.Length0 and 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j'],

-             forall|i: int, i': int, j: int|0<=i<i'<a.Length0 and 0<=j<a.Length1 ==> a[i,j]<=a[i',j],

-             exists|i: int, j: int| 0<=i<a.Length0 and 0<=j<a.Length1 and a[i,j]==key

-    ensures 0<=m<a.Length0 and 0<=n<a.Length1,

-            a[m,n]==key

+pub fn SlopeSearch(a: &Array2<i32>, key: i32) -> (m: i32, n: i32)

+    requires(

+        forall|i: usize, j: usize, j_prime: usize| 

+            0 <= i < a.len0() && 0 <= j < j_prime && j_prime < a.len1() ==> 

+            a[i][j] <= a[i][j_prime]

+    )

+    requires(

+        forall|i: usize, i_prime: usize, j: usize| 

+            0 <= i < i_prime && i_prime < a.len0() && 0 <= j < a.len1() ==> 

+            a[i][j] <= a[i_prime][j]

+    )

+    requires(

+        exists|i: usize, j: usize| 

+            0 <= i < a.len0() && 0 <= j < a.len1() && a[i][j] == key

+    )

+    ensures(

+        0 <= m < a.len0() && 0 <= n < a.len1()

+    )

+    ensures(

+        a[m as usize][n as usize] == key

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_swap_arith_reconstructed_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_swap_arith_reconstructed_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_swap_arith_reconstructed_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapArithmetic(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn SwapArithmetic(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_swap_arith_spec_reconstructed_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_swap_arith_spec_reconstructed_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_swap_arith_spec_reconstructed_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapArithmetic(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn swap_arithmetic(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported/Clover_swap_bitvector_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_swap_bitvector_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_swap_bitvector_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapBitvectors(X: bv8, Y: bv8) -> x: bv8, y: bv8

-    ensures x==Y,

-            y==X

+pub fn swap_bitvectors(X: u8, Y: u8) -> (x: u8, y: u8)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported/Clover_swap_sim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_swap_sim_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_swap_sim_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapSimultaneous(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn SwapSimultaneous(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_swap_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_swap_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_swap_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn Swap(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_triple2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_triple2_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_triple2_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_triple3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_triple3_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_triple3_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_triple4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_triple4_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_triple4_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_triple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_triple_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_triple_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn Triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Clover_two_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Clover_two_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/Clover_two_sum_spec.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn twoSum(nums: Vec<int>, target: int) -> i: int, j: int

-    requires nums.len() > 1,

-             exists|i: int, j: int|0 <= i < j < nums.len() and  nums[i] + nums[j] == target

-    ensures 0 <= i < j < nums.len() and nums[i] + nums[j] == target,

-            forall|ii: int, jj: int| (0 <= ii < i and ii < jj < nums.len())  ==> nums[ii] + nums[jj] != target,

-            forall|jj: int| i < jj < j ==> nums[i] + nums[jj] != target

+pub fn twoSum(nums: &[int], target: int) -> (i: int, j: int)

+    requires

+        nums.len() > 1,

+        exists|i: int, j: int| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,

+    ensures |result: (int, int)|

+        0 <= result.0 < result.1 < nums.len() && nums[result.0] + nums[result.1] == target,

+    ensures |result: (int, int)|

+        forall|ii: int, jj: int| (0 <= ii < result.0 && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target,

+    ensures |result: (int, int)|

+        forall|jj: int| result.0 < jj < result.1 ==> nums[result.0] + nums[jj] != target,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec.rs
@@ -1,18 +1,29 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mpositive(v: Vec<int>) -> (b: bool)

-    ensures b==positive(v[0..v.len()])

+

+pub fn mpositive(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

 {

 }

 

+

+pub fn mpositive3(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

+}

+

+

+pub fn mpositive4(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

+}

+

+

+pub fn mpositivertl(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec.rs
@@ -1,15 +1,20 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mroot1(n: int) -> (r: int)

-    requires n>=0

-    ensures r>=0 and r*r <= n <(r+1)*(r+1)

+pub fn mroot1(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

 {

 }

 

+

+pub fn mroot2(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

+{

+}

+

+

+pub fn mroot3(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec.rs
@@ -1,16 +1,65 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn mmaximum1(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k]

+pub fn mmaximum1(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|i: i32| 0 <= i < v.len())

+    ensures(|i: i32| forall|k: usize| 0 <= k < v.len() ==> v[i as usize] >= v[k])

 {

 }

 

+

+

+

+

+pub fn mmaximum2(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|i: i32| 0 <= i < v.len())

+    ensures(|i: i32| forall|k: usize| 0 <= k < v.len() ==> v[i as usize] >= v[k])

+{

+}

+

+

+

+pub fn mfirstMaximum(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|i: i32| 0 <= i < v.len())

+    ensures(|i: i32| forall|k: usize| 0 <= k < v.len() ==> v[i as usize] >= v[k])

+    ensures(|i: i32| forall|l: usize| 0 <= l < i ==> v[i as usize] > v[l])

+

+{

+}

+

+

+

+pub fn mlastMaximum(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|i: i32| 0 <= i < v.len())

+    ensures(|i: i32| forall|k: usize| 0 <= k < v.len() ==> v[i as usize] >= v[k])

+    ensures(|i: i32| forall|l: usize| i < l < v.len() ==> v[i as usize] > v[l])

+{

+}

+

+

+

+

+

+

+

+

+

+pub fn mmaxvalue1(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|m: i32| exists|k: usize| 0 <= k < v.len() && m == v[k])

+    ensures(|m: i32| forall|k: usize| 0 <= k < v.len() ==> m >= v[k])

+{

+}

+

+

+

+pub fn mmaxvalue2(v: &[i32]) -> i32

+    requires(v.len() > 0)

+    ensures(|m: i32| exists|k: usize| 0 <= k < v.len() && m == v[k])

+    ensures(|m: i32| forall|k: usize| 0 <= k < v.len() ==> m >= v[k])

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec.rs
@@ -1,17 +1,50 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

+    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]

 }

 

-fn mallEqual1(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+proof fn equivalenceNoOrder(s: Seq<int>)

+    ensures allEqual(s) <==> (forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] == s[j])

+{

+}

+

+proof fn equivalenceEqualtoFirst(s: Seq<int>)

+    requires s.len() != 0

+    ensures allEqual(s) <==> (forall|i: int| 0 <= i < s.len() ==> s[0] == s[i])

+{

+}

+

+proof fn equivalenceContiguous(s: Seq<int>)

+    ensures (allEqual(s) ==> (forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i + 1]))

+    ensures (allEqual(s) <== (forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i + 1]))

+{

+}

+

+pub fn mallEqual1(v: &[i32]) -> (b: bool)

+    ensures b == allEqual(v@)

+{

+}

+

+pub fn mallEqual2(v: &[i32]) -> (b: bool)

+    ensures b == allEqual(v@)

+{

+}

+

+pub fn mallEqual3(v: &[i32]) -> (b: bool)

+    ensures b == allEqual(v@)

+{

+}

+

+pub fn mallEqual4(v: &[i32]) -> (b: bool)

+    ensures b == allEqual(v@)

+{

+}

+

+pub fn mallEqual5(v: &[i32]) -> (b: bool)

+    ensures b == allEqual(v@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec.rs
@@ -1,27 +1,18 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn strictSorted(s: Seq<int>) -> bool {

+spec fn strict_sorted(s: Seq<int>) -> bool {

     forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] < s[w]

 }

 

-fn mcontained(v: Vec<int>, w: Vec<int>, n: int, m: int) -> (b: bool)

-

-

-

-requires n<=m && n>=0

-requires strictSorted(v[..])

-    requires n<=m and n>=0,

-             strictSorted(v[..]),

-             strictSorted(w[..]),

-             v.len() >= n and w.len() >= m

-    ensures b==forall|k: int| 0<= k< n ==> v[k] in w[..m]

+pub fn mcontained(v: &[int], w: &[int], n: usize, m: usize) -> (b: bool)

+    requires(

+        n <= m && n >= 0,

+        strict_sorted(v@),

+        strict_sorted(w@),

+        v@.len() >= n && w@.len() >= m,

+    )

+    ensures(|b: bool| 

+        b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec.rs
@@ -1,18 +1,26 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mfirstNegative(v: Vec<int>) -> b: bool, i: int

-    ensures b <==> exists|k: int|0<=k<v.len() and v[k]<0,

-            b ==> 0<=i<v.len() and v[i]<0 and positive(v[0..i])

+

+pub fn mfirstNegative(v: &[int]) -> (b: bool, i: int)

+    ensures

+        b <==> exists|k: int| 0 <= k < v.len() && v[k] < 0,

+        b ==> 0 <= i < v.len() && v[i] < 0 && positive(v.subrange(0, i)),

+{

+}

+

+

+pub fn mfirstNegative2(v: &[int]) -> (b: bool, i: int)

+    ensures

+        b <==> exists|k: int| 0 <= k < v.len() && v[k] < 0,

+        b ==> 0 <= i < v.len() && v[i] < 0 && positive(v.subrange(0, i)),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mfirstCero(v: Vec<int>) -> (i: int)

-    ensures 0 <=i<=v.len(),

-            forall|j: int| 0<=j<i ==> v[j]!=0,

-            i!=v.len() ==> v[i]==0

+pub fn mfirstCero(v: &[i32]) -> (i: usize)

+    requires(true)

+    ensures(|result: usize| 0 <= result <= v.len())

+    ensures(|result: usize| forall|j: usize| 0 <= j < result ==> v[j] != 0)

+    ensures(|result: usize| result != v.len() ==> v[result] == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec.rs
@@ -1,18 +1,77 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn SumR(s: Seq<int>) -> int

+{

+    if s.len() == 0 { 0 } else { SumR(s.subrange(0, s.len() - 1)) + s[s.len() - 1] }

+}

 

-verus! {

 

-fn sumElems(v: Vec<int>) -> (sum: int)

+spec fn SumL(s: Seq<int>) -> int

+{

+    if s.len() == 0 { 0 } else { s[0] + SumL(s.subrange(1, s.len())) }

+}

 

-    ensures sum==SumL(v[0..v.len()]),

-            sum==SumR(v[..])

 

-            sum==SumV(v,0,v.len())

+proof fn concatLast(s: Seq<int>, t: Seq<int>)

+    requires t.len() != 0

+    ensures (s + t).subrange(0, (s + t).len() - 1) == s + t.subrange(0, t.len() - 1)

 {

 }

 

+

+proof fn concatFirst(s: Seq<int>, t: Seq<int>)

+    requires s.len() != 0

+    ensures (s + t).subrange(1, (s + t).len()) == s.subrange(1, s.len()) + t

+{

+}

+

+proof fn SumByPartsR(s: Seq<int>, t: Seq<int>)

+    ensures SumR(s + t) == SumR(s) + SumR(t)

+{

+}

+

+proof fn SumByPartsL(s: Seq<int>, t: Seq<int>)

+    ensures SumL(s + t) == SumL(s) + SumL(t)

+{

+}

+

+proof fn equalSumR(s: Seq<int>, i: int, j: int)

+    requires 0 <= i <= j <= s.len()

+    ensures SumR(s.subrange(i, j)) == SumL(s.subrange(i, j))

+{

+}

+

+

+proof fn equalSumsV()

+    ensures forall |v: &[int], i: int, j: int| 0 <= i <= j <= v.len() ==> SumR(v@.subrange(i, j)) == SumL(v@.subrange(i, j))

+{

+}

+

+

+spec fn SumV(v: &[int], c: int, f: int) -> int

+    recommends 0 <= c <= f <= v.len()

+{

+    SumR(v@.subrange(c, f))

+}

+

+

+proof fn ArrayFacts<T>()

+    ensures forall |v: &[T]| v@.subrange(0, v.len()) == v@

+    ensures forall |v: &[T]| v@.subrange(0, v.len()) == v@

+    ensures forall |v: &[T]| v@.subrange(0, v.len()) == v@

+    ensures forall |v: &[T]| v@.subrange(0, v.len()).len() == v.len()

+    ensures forall |v: &[T]| v.len() >= 1 ==> v@.subrange(1, v.len()).len() == v.len() - 1

+    ensures forall |v: &[T], k: nat| k < v.len() ==> v@.subrange(0, k + 1).subrange(0, k) == v@.subrange(0, k)

+{

+}

+

+

+pub fn sumElems(v: &[int]) -> (sum: int)

+    ensures sum == SumR(v@)

+{

+}

+

+

+pub fn sumElemsB(v: &[int]) -> (sum: int)

+    ensures sum == SumR(v@.subrange(0, v.len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec.rs
@@ -1,31 +1,44 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

-spec fn isEven(i: int)

-requires i>=0

-{i%2==0}

 

 

 

-

-function CountEven(s:seq<int>):int

-requires positive(s) -> bool {

-    if s==[] then 0

- else (if (s[s.len()-1]%2==0) then 1 else 0)+CountEven(s[..s.len()-1])

+spec fn isEven(i: int) -> bool

+    requires i >= 0

+{

+    i % 2 == 0

 }

 

-fn mcountEven(v: Vec<int>) -> (n: int)

-    requires positive(v[..])

-    ensures n==CountEven(v[..])

+

+

+spec fn CountEven(s: Seq<int>) -> int

+    requires positive(s)

+    decreases s.len()

+{

+    if s.len() == 0 { 0 }

+    else { (if s[s.len()-1] % 2 == 0 { 1 } else { 0 }) + CountEven(s.subrange(0, s.len()-1)) }

+}

+

+

+

+proof fn ArrayFacts<T>()

+    ensures forall|v: &Vec<T>| v.view().subrange(0, v.len() as int) == v.view(),

+    ensures forall|v: &Vec<T>| v.view().subrange(0, v.len() as int) == v.view(),

+    ensures forall|v: &Vec<T>| v.view().subrange(0, v.len() as int) == v.view(),

+    ensures forall|v: &Vec<T>| v.view().subrange(0, v.len() as int).len() == v.len(),

+    ensures forall|v: &Vec<T>| v.len() >= 1 ==> v.view().subrange(1, v.len() as int).len() == v.len() - 1,

+    ensures forall|v: &Vec<T>| forall|k: nat| k < v.len() ==> v.view().subrange(0, k as int + 1).subrange(0, k as int) == v.view().subrange(0, k as int)

 {

 }

 

+

+

+pub fn mcountEven(v: &Vec<int>) -> (n: int)

+    requires positive(v.view())

+    ensures n == CountEven(v.view())

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec.rs
@@ -1,15 +1,38 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn mCountMin(v: Vec<int>) -> (c: int)

-    requires v.len()>0

-    ensures c==countMin(v,min(v,v.len()),v.len())

+spec fn min(v: &[int], i: int) -> int

+    recommends 1 <= i <= v.len()

+    ensures forall|k: int| 0 <= k < i ==> v[k] >= min(v, i)

+    decreases i

+{

+    if i == 1 {

+        v[0]

+    } else if v[(i-1) as usize] <= min(v, i-1) {

+        v[(i-1) as usize]

+    } else {

+        min(v, i-1)

+    }

+}

 

+spec fn countMin(v: &[int], x: int, i: int) -> int

+    recommends 0 <= i <= v.len()

+    ensures !(exists|k: int| 0 <= k < i && v[k] == x) ==> countMin(v, x, i) == 0

+    decreases i

+{

+    if i == 0 {

+        0

+    } else if v[(i-1) as usize] == x {

+        1 + countMin(v, x, i-1)

+    } else {

+        countMin(v, x, i-1)

+    }

+}

+

+pub fn mCountMin(v: &[int]) -> (c: int)

+    requires v.len() > 0

+    ensures c == countMin(v, min(v, v.len() as int), v.len() as int)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec.rs
@@ -1,16 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn mPeekSum(v: Vec<int>) -> (sum: int)

-    requires v.len()>0

-    ensures sum==peekSum(v,v.len())

-

+pub open spec fn isPeek(v: &[int], i: int) -> bool

+    recommends 0 <= i < v.len()

 {

+    forall|k: int| 0 <= k < i ==> v[i] >= v[k]

 }

 

+

+

+pub open spec fn peekSum(v: &[int], i: int) -> int

+    recommends 0 <= i <= v.len()

+    decreases i

+{

+    if i == 0 {

+        0

+    } else if isPeek(v, i - 1) {

+        v[i - 1] + peekSum(v, i - 1)

+    } else {

+        peekSum(v, i - 1)

+    }

+}

+

+

+

+pub fn mPeekSum(v: &[int]) -> (sum: int)

+    requires(v.len() > 0)

+    ensures(sum == peekSum(v, v.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec.rs
@@ -1,28 +1,35 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_seg(a: Vec<int>, i: int, j: int)

-requires 0 <= i <= j <= a.Length

-reads a

+spec fn sorted_seg(a: &[int], i: int, j: int) -> bool

+    recommends 0 <= i <= j <= a.len()

 {

-    forall l, k: : i <= l <= k < j ==> a[l] <= a[k]

+    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]

 }

 

+pub fn bubbleSorta(a: &mut Vec<int>, c: usize, f: usize)

+    requires

+        c <= f <= old(a).len(),

+    ensures

+        sorted_seg(a, c as int, f as int),

+        a.len() == old(a).len(),

+        multiset(a@.subrange(c as int, f as int)) == multiset(old(a)@.subrange(c as int, f as int)),

+        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int) && 

+        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),

+{

+}

 

-

-

-method bubbleSorta(a:array<int>, c: int, f: int)

-modifies a 

-requires 0 <= c <= f <= a.Length

-ensures sorted_seg(a, c, f) 

-ensures multiset(a[c..f]) == old(multiset(a[c..f]))

-ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..]) -> bool {

-    

+pub fn bubbleSort(a: &mut Vec<int>, c: usize, f: usize)

+    requires

+        c <= f <= old(a).len(),

+    ensures

+        sorted_seg(a, c as int, f as int),

+        a.len() == old(a).len(),

+        multiset(a@.subrange(c as int, f as int)) == multiset(old(a)@.subrange(c as int, f as int)),

+        a@.subrange(0, c as int) == old(a)@.subrange(0, c as int) && 

+        a@.subrange(f as int, a.len() as int) == old(a)@.subrange(f as int, old(a).len() as int),

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec.rs
@@ -1,30 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_seg(a: Vec<int>, i: int, j: int)

-requires 0 <= i <= j <= a.Length

-reads a

+spec fn sorted_seg(a: &[int], i: int, j: int) -> bool

+    recommends 0 <= i <= j <= a.len()

 {

-    forall l, k: : i <= l <= k < j ==> a[l] <= a[k]

+    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]

 }

 

-

-

-

-

-

-method selSort (a:array<int>, c: int, f: int)

-modifies a 

-requires 0 <= c <= f <= a.Length

-ensures sorted_seg(a, c, f) 

-ensures multiset(a[c..f]) == old(multiset(a[c..f]))

-ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..]) -> bool {

-    

+pub fn selSort(a: &mut [int], c: usize, f: usize)

+    requires 

+        0 <= c <= f <= a.len(),

+    ensures

+        sorted_seg(a, c as int, f as int),

+        a.subrange(c as int, f as int).to_multiset() == old(a).subrange(c as int, f as int).to_multiset(),

+        a.subrange(0, c as int) == old(a).subrange(0, c as int) && a.subrange(f as int, a.len() as int) == old(a).subrange(f as int, a.len() as int),

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec.rs
@@ -1,33 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn strictNegative(v: Vec<int>, i: int, j: int)

-reads v

-requires 0<=i<=j<=v.Length

-{forall u | i<=u<j :: v[u]<0}

-

-

-

-

-predicate positive(s:seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

-}

-spec fn isPermutation(s: Seq<int>, t: Seq<int>) -> bool {

-    multiset(s)==multiset(t)

+spec fn strict_negative(v: &[int], i: int, j: int) -> bool

+    recommends 0 <= i <= j <= v.len()

+{

+    forall|u: int| i <= u < j ==> v[u as usize] < 0

 }

 

-fn separate(v: Vec<int>) -> i: int)

-modifies v

-ensures 0<=i<=v.Length

-ensures positive(v[0..i]) && strictNegative(v, i, v.Length

-    ensures 0<=i<=v.len(),

-            positive(v[0..i]) and strictNegative(v,i,v.len()),

-            isPermutation(v[0..v.len()], old(v[0..v.len()]))

+spec fn positive(s: Seq<int>) -> bool {

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

+}

+

+spec fn is_permutation(s: Seq<int>, t: Seq<int>) -> bool {

+    s.to_multiset() == t.to_multiset()

+}

+

+pub fn separate(v: &mut Vec<int>) -> (i: usize)

+    ensures

+        0 <= i <= v.len(),

+        positive(v@.subrange(0, i as int)),

+        strict_negative(v@.as_slice(), i as int, v.len() as int),

+        is_permutation(v@, old(v)@),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec.rs
@@ -1,31 +1,45 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn SumMaxToRight(v: Vec<int>, i: int, s: int)

-reads v

-requires 0<=i<v.Length

+spec fn Sum(v: &[i32], i: int, j: int) -> int

+    recommends 0 <= i <= j <= v.len()

 {

-forall l, ss {: induction l}::0<=l<=i && ss==i+1==> Sum(v, l, ss)<=s

+    if i == j { 0 } else { Sum(v, i, j - 1) + v[j - 1] }

 }

 

-

-

-

-method segMaxSum(v: Vec<int>, i: int) returns (s:int, k: int)

-requires v.Length>0 && 0<=i<v.Length

-ensures 0<=k<=i && s==Sum(v, k, i+1) &&  SumMaxToRight(v, i, s) -> bool {

-    

+spec fn SumMaxToRight(v: &[i32], i: int, s: int) -> bool

+    recommends 0 <= i < v.len()

+{

+    forall|l: int, ss: int| 0 <= l <= i && ss == i + 1 ==> Sum(v, l, ss) <= s

 }

 

-fn segMaxSum(v: Vec<int>, i: int) -> s: int, k: int

-    requires v.len()>0 and 0<=i<v.len()

-    ensures 0<=k<=i and s==Sum(v,k,i+1) and  SumMaxToRight(v,i,s)

+pub fn segMaxSum(v: &[i32], i: usize) -> (s: i32, k: usize)

+    requires(

+        v.len() > 0 && 0 <= i < v.len()

+    )

+    ensures(|result: (i32, usize)|

+        0 <= result.1 <= i && result.0 == Sum(v, result.1 as int, i as int + 1) && SumMaxToRight(v, i as int, result.0)

+    )

 {

 }

 

+spec fn Sum2(v: &[i32], i: int, j: int) -> int

+    recommends 0 <= i <= j <= v.len()

+{

+    if i == j { 0 } else { v[i] + Sum2(v, i + 1, j) }

+}

+

+spec fn SumMaxToRight2(v: &[i32], j: int, i: int, s: int) -> bool

+    recommends 0 <= j <= i < v.len()

+{

+    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> Sum2(v, l, ss) <= s

+}

+

+pub fn segSumaMaxima2(v: &[i32], i: usize) -> (s: i32, k: usize)

+    requires(

+        v.len() > 0 && 0 <= i < v.len()

+    )

+    ensures(|result: (i32, usize)|

+        0 <= result.1 <= i && result.0 == Sum2(v, result.1 as int, i as int + 1) && SumMaxToRight2(v, 0, i as int, result.0)

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec.rs
@@ -1,29 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn summingPair(i: nat, j: nat, nums: Seq<int>, target: int)

-    requires i < |nums|

-    requires j < |nums|

+spec fn summingPair(i: nat, j: nat, nums: Seq<int>, target: int) -> bool

+    recommends(i < nums.len())

+    recommends(j < nums.len())

 {

-    i != j &&  nums[i] + nums[j] == target

+    i != j && nums[i] + nums[j] == target

 }

 

 

-method twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))

-    requires exists i: nat, j: nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)

-    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target) -> bool {

-    

-}

-

-fn twoSum(nums: Seq<int>, target: int) -> pair: (nat, nat)

-    requires exists i:nat,j:nat :: i < j < nums.len() and summingPair(i, j, nums, target) and forall l: nat, m: nat :: l <  m < nums.len() and l != i and m != j ==> !summingPair(l, m, nums, target)

-    ensures 0 <= pair.0 < nums.len() and 0 <= pair.1 < nums.len() and summingPair(pair.0, pair.1, nums, target)

+pub fn twoSum(nums: Seq<int>, target: int) -> (pair: (nat, nat))

+    requires(exists|i: nat, j: nat| i < j < nums.len() && summingPair(i, j, nums, target) && forall|l: nat, m: nat| l < m < nums.len() && l != i && m != j ==> !summingPair(l, m, nums, target))

+    ensures(0 <= pair.0 < nums.len() && 0 <= pair.1 < nums.len() && summingPair(pair.0, pair.1, nums, target))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec.rs
@@ -1,90 +1,89 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BST(t: Tree) -> bool {

-    Ascending(Inorder(t))

-}

-spec fn Ascending(q: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]

-}

-spec fn NoDuplicates(q: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j]

-}

-

-fn Main() {

+pub enum Tree {

+    Empty,

+    Node(int, Box<Tree>, Box<Tree>)

 }

 

 

+pub fn Main() {

+}

 

 

-method PrintTreeNumbersInorder(t: Tree)

+pub fn PrintTreeNumbersInorder(t: Tree) {

+}

+

+

+pub spec fn NumbersInTree(t: Tree) -> Set<int> {

+    NumbersInSequence(Inorder(t))

+}

+

+

+pub spec fn NumbersInSequence(q: Seq<int>) -> Set<int> {

+    Set::new(|x: int| q.contains(x))

+}

+

+

+pub spec fn BST(t: Tree) -> bool {

+    Ascending(Inorder(t))

+}

+

+

+pub spec fn Inorder(t: Tree) -> Seq<int> {

+    match t {

+        Tree::Empty => seq![],

+        Tree::Node(n_, nt1, nt2) => Inorder(*nt1) + seq![n_] + Inorder(*nt2)

+    }

+}

+

+

+pub spec fn Ascending(q: Seq<int>) -> bool {

+    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]

+}

+

+

+pub spec fn NoDuplicates(q: Seq<int>) -> bool { 

+    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j] 

+}

+

+

+pub fn BuildBST(q: Seq<int>) -> (t: Tree)

+    requires(NoDuplicates(q))

+    ensures(BST(t) && NumbersInTree(t) == NumbersInSequence(q))

 {

 }

 

 

-

-

-function NumbersInTree(t: Tree): set<int>

+pub fn InsertBST(t0: Tree, x: int) -> (t: Tree)

+    requires(BST(t0) && !NumbersInTree(t0).contains(x))

+    ensures(BST(t) && NumbersInTree(t) == NumbersInTree(t0).insert(x))

 {

-	NumbersInSequence(Inorder(t))

 }

 

 

-

-

-function NumbersInSequence(q: seq<int>): set<int>

+pub proof fn LemmaBinarySearchSubtree(n: int, left: Tree, right: Tree)

+    requires(BST(Tree::Node(n, Box::new(left), Box::new(right))))

+    ensures(BST(left) && BST(right))

 {

-	set x | x in q

 }

 

 

-

-

-predicate BST(t: Tree)

-{

-	Ascending(Inorder(t))

-}

-

-

-

-

-function Inorder(t: Tree): seq<int>

-{

-	match t {

-		case Empty => []

-		case Node(n', nt1, nt2) => Inorder(nt1)+[n']+Inorder(nt2)

-	}

-}

-

-

-

-

-predicate Ascending(q: Seq<int>, j: : 0 <= i < j < |q| ==> q[i] < q[j]

-}

-

-

-

-

-predicate NoDuplicates(q: seq<int>) { forall i, j: : 0 <= i < j < |q| ==> q[i] != q[j] }

-

-

-

-

-

-

-

-

-

-

-method BuildBST(q: Seq<int>) -> (t: Tree)

-    requires NoDuplicates(q)

-    ensures BST(t) and NumbersInTree(t) == NumbersInSequence(q)

+pub proof fn LemmaAscendingSubsequence(q1: Seq<int>, q2: Seq<int>, i: nat)

+    requires(i <= q1.len() - q2.len() && q2 == q1.subrange(i as int, i + q2.len()))

+    requires(Ascending(q1))

+    ensures(Ascending(q2))

 {

 }

 

+pub proof fn lemma_all_small(q: Seq<int>, i: int)

+    requires(forall|k: int| NumbersInSequence(q).contains(k) ==> k < i)

+    requires(forall|k: int| 0 <= k < q.len() ==> NumbersInSequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] < i)

+{

+}

+

+pub proof fn lemma_all_big(q: Seq<int>, i: int)

+    requires(forall|k: int| NumbersInSequence(q).contains(k) ==> k > i)

+    requires(forall|k: int| 0 <= k < q.len() ==> NumbersInSequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] > i)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArraySplit(a: Vec<int>) -> b: Vec<int>, c: Vec<int>

-    ensures fresh(b),

-            fresh(c),

-            a[..] == b[..] + c[..],

-            a.len() == b.len() + c.len(),

-            a.len() > 1 ==> a.len() > b.len(),

-            a.len() > 1 ==> a.len() > c.len()

+pub fn ArraySplit(a: &[i32]) -> (Vec<i32>, Vec<i32>)

+    ensures(|result: (Vec<i32>, Vec<i32>)| {

+        let (b, c) = result;

+        a@ == b@ + c@ &&

+        a.len() == b.len() + c.len() &&

+        (a.len() > 1 ==> a.len() > b.len()) &&

+        (a.len() > 1 ==> a.len() > c.len())

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec.rs
@@ -1,31 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_between(A: Vec<int>, from: int, to: int)

-    reads A

-{

-    forall i, j: : 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]

+spec fn sorted_between(A: &[i32], from: int, to: int) -> bool {

+    forall|i: int, j: int| 0 <= i <= j < A.len() && from <= i <= j <= to ==> A[i] <= A[j]

 }

 

-

-

-

-predicate sorted(A:array<int>)

-    reads A

-{

-    sorted_between(A, 0, A.Length-1)

+spec fn sorted(A: &[i32]) -> bool {

+    sorted_between(A, 0, (A.len() - 1) as int)

 }

 

+pub fn BubbleSort(A: &mut [i32])

+    ensures sorted(A),

+    ensures A@.to_multiset() == old(A)@.to_multiset(),

+{

+}

 

-

-

-method BubbleSort(A: Vec<int>) -> bool {

-    

+pub fn Main() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec.rs
+++ verus_specs/translations/atomizer_supported/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn addArrays(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len() == b.len()

-    ensures b.len() == c.len(),

-            forall i:int :: 0 <= i <c.len() ==> c[i] == a[i] + b[i]

+pub fn addArrays(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| b.len() == c.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i && i < c.len() ==> c[i] == a[i] + b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec.rs
+++ verus_specs/translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec.rs
@@ -1,16 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn longestPrefix(a: Vec<int>, b: array <int>) -> (i: nat)

-    ensures i <= a.len() and i <= b.len(),

-            a[..i] == b[..i],

-            i < a.len() and i < b.len() ==> a[i] != b[i]

+

+

+

+

+

+

+pub fn longestPrefix(a: &[int], b: &[int]) -> (i: nat)

+    ensures(i <= a.len() && i <= b.len())

+    ensures(a[..i] == b[..i])

+    ensures(i < a.len() && i < b.len() ==> a[i] != b[i])

 {

 }

 

+ 

+

+

+ 

+

+pub fn testLongestPrefix() {

 }

================================================================================
Comparing translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec.rs
+++ verus_specs/translations/atomizer_supported/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec.rs
@@ -1,17 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn odd(n: nat) -> bool {

-    n % 2 == 1

+

+

+

+

+

+pub fn partitionOddEven(a: &mut Vec<nat>)

+    requires(old(a).len() == a.len())

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

+    ensures(!(exists|i: int, j: int| 0 <= i < j < a.len() && even(a[i]) && odd(a[j])))

+{

 }

 

-spec fn even(n: nat) -> bool {

-    n % 2 == 0

+ 

+

+ 

+pub open spec fn odd(n: nat) -> bool { n % 2 == 1 }

+

+

+pub open spec fn even(n: nat) -> bool { n % 2 == 0 }

+

+

+

+

+pub fn testPartitionOddEven() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x+y,

-            (m == x or m == y) and x <= m and y <= m

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(s == x + y)

+    ensures((m == x || m == y) && x <= m && y <= m)

 {

 }

 

+pub fn Main() 

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec.rs
@@ -1,26 +1,19 @@
+pub fn LinearSeach0<T>(a: &[T], P: impl Fn(T) -> bool) -> (n: usize)

+    ensures(0 <= n <= a.len())

+    ensures(n == a.len() || P(a[n]))

+{

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P(n: int) -> bool {

+pub fn P(n: i32) -> bool {

     n % 2 == 0

 }

 

-fn TestLinearSearch() {

+pub fn TestLinearSearch() {

 }

 

-

-

-

-method LinearSeach1<T>(a: Vec<T>, P: T -> bool) -> (n: int)

-    ensures 0 <= n <= a.len(),

-            n == a.len() or P(a[n]),

-            n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> !P(a[i])

+pub fn LinearSeach1<T>(a: &[T], P: impl Fn(T) -> bool) -> (n: usize)

+    ensures(0 <= n <= a.len())

+    ensures(n == a.len() || P(a[n]))

+    ensures(n == a.len() ==> forall|i: usize| 0 <= i < a.len() ==> !P(a[i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec.rs
@@ -1,14 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub fn Power(n: nat) -> nat

+{

+    if n == 0 { 1 } else { 2 * Power((n-1) as nat) }

+}

 

-verus! {

 

-fn CalcPower(n: nat) -> (p: nat)

-    ensures p == 2*n;

+

+pub fn CalcPower(n: nat) -> (p: nat)

+    ensures p == 2*n

 {

 }

 

+

+

+pub fn ComputePower(n: nat) -> (p: nat)

+    ensures p == Power(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec.rs
@@ -1,17 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindPositionOfElement(a: Vec<int>, Element: nat, n1: nat, s1: Seq<int>) -> Position: int, Count: nat

-    requires n1 == s1.len() and 0 <= n1 <= a.len(),

-             forall|i: int| 0<= i < s1.len() ==> a[i] == s1[i]

-    ensures Position == -1 or Position >= 1,

-            s1.len() != 0 and Position >= 1 ==> exists|i: int| 0 <= i < s1.len() and s1[i] == Element

+pub fn find_position_of_element(a: &[i32], element: usize, n1: usize, s1: &[i32]) -> (position: i32, count: usize)

+    requires

+        n1 == s1.len() && 0 <= n1 <= a.len(),

+        forall|i: usize| 0 <= i < s1.len() ==> a[i] == s1[i],

+    ensures

+        position == -1 || position >= 1,

+        s1.len() != 0 && position >= 1 ==> exists|i: usize| 0 <= i < s1.len() && s1[i] == element,

 {

 }

 

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec.rs
@@ -1,15 +1,27 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AssignmentsToMark(students: int, tutors: int) -> (r: int)

-    requires students > 0 and tutors > 1

-    ensures r < students

+pub fn AssignmentsToMark(students: int, tutors: int) -> (r: int)

+    requires(students > 0 && tutors > 1)

+    ensures(|r: int| r < students)

 {

 }

 

+

+proof fn DivisionLemma(n: int, d: int)

+    requires(n > 0 && d > 1)

+    ensures(n / d < n)

+{

+}

+

+

+pub fn AssignmentsToMarkOne(students: int, tutors: int) -> (r: int)

+    requires(students > 0 && tutors > 1)

+    ensures(|r: int| r < students)

+{

+}

+

+

+proof fn CommonElement(a: &[nat], b: &[nat])

+    requires(a.len() > 0 && b.len() > 0 && a[0] == b[0])

+    ensures(a@.to_multiset().intersect(b@.to_multiset()) == seq![a[0]].to_multiset().add(a@.subrange(1, a.len() as int).to_multiset().intersect(b@.subrange(1, b.len() as int).to_multiset())))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_lemma_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_lemma_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_lemma_spec.rs
@@ -1,18 +1,18 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindZero(a: Vec<int>) -> (index: int)

-    requires a != null,

-             forall|i: int| 0 <= i < a.len() ==> 0 <= a[i],

-             forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i]

-    ensures index < 0  ==> forall|i: int| 0 <= i < a.len() ==> a[i] != 0,

-            0 <= index ==> index < a.len() and a[index] == 0

+proof fn SkippingLemma(a: &[int], j: int)

+    requires a.len() >= 0

+    requires forall|i: int| 0 <= i < a.len() ==> 0 <= a[i]

+    requires forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i]

+    requires 0 <= j < a.len()

+    ensures forall|k: int| j <= k < j + a[j] && k < a.len() ==> a[k] != 0

 {

 }

 

+

+pub fn FindZero(a: &[int]) -> (index: int)

+    requires forall|i: int| 0 <= i < a.len() ==> 0 <= a[i]

+    requires forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i]

+    ensures index < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != 0

+    ensures 0 <= index ==> index < a.len() && a[index] == 0

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_mymax_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_mymax_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_mymax_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c>= b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a && c >= b)

 {

 }

 

+pub fn Testing()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_trig_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_trig_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Programs_tmp_tmp99966ew4_trig_spec.rs
@@ -1,22 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P(x: int)

+spec fn P(x: int) -> bool;

 

 

-predicate Q(x: int)

+spec fn Q(x: int) -> bool;

 

 

-method test()

-    requires forall x {

-}

-    ensures Q(0) -> bool {

-    

-}

-

+pub fn test()

+    requires(forall|x: int| P(x) && Q(x))

+    ensures(Q(0))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec.rs
@@ -1,15 +1,70 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputePower(N: int) -> (y: nat)

-    requires N >= 0

-    ensures y == Power(N)

+spec fn power(n: nat) -> nat

+    decreases n

 {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

+}

+

+pub fn compute_power(N: i32) -> (y: u32)

+    requires(N >= 0)

+    ensures(y == power(N as nat))

+{

+    unimplemented!()

+}

+

+pub fn max(a: &[u32]) -> (m: i32)

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i] <= m)

+    ensures((m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i])

+{

+    unimplemented!()

+}

+

+pub fn cube(n: u32) -> (c: u32)

+    ensures(c == n * n * n)

+{

+    unimplemented!()

+}

+

+pub fn increment_matrix(a: &mut Vec<Vec<i32>>)

+    ensures(forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i as int].len() ==> 

+            a[i][j] == old(a)[i][j] + 1)

+{

+    unimplemented!()

+}

+

+pub fn copy_matrix(src: &Vec<Vec<i32>>, dst: &mut Vec<Vec<i32>>)

+    requires(src.len() == dst.len() && 

+             forall|i: int| 0 <= i < src.len() ==> src[i as int].len() == dst[i as int].len())

+    ensures(forall|i: int, j: int| 0 <= i < src.len() && 0 <= j < src[i as int].len() ==> 

+            dst[i][j] == old(src)[i][j])

+{

+    unimplemented!()

+}

+

+pub fn double_array(src: &[i32], dst: &mut [i32])

+    requires(src.len() == dst.len())

+    ensures(forall|i: int| 0 <= i < src.len() ==> dst[i] == 2 * old(src)[i])

+{

+    unimplemented!()

+}

+

+pub fn rotate_left<T>(a: &mut [T])

+    requires(a.len() > 0)

+    ensures(forall|i: int| 0 <= i < a.len() - 1 ==> a[i] == old(a)[(i + 1) as int])

+    ensures(a[a.len() - 1] == old(a)[0])

+{

+    unimplemented!()

+}

+

+pub fn rotate_right<T>(a: &mut [T])

+    requires(a.len() > 0)

+    ensures(forall|i: int| 1 <= i < a.len() ==> a[i] == old(a)[(i - 1) as int])

+    ensures(a[0] == old(a)[a.len() - 1])

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec.rs
@@ -1,15 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputePower(N: int) -> (y: nat)

-    requires N >= 0

-    ensures y == Power(N)

-{

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

 }

 

+pub fn compute_power(n: int) -> (y: nat)

+    requires(n >= 0)

+    ensures(|result: nat| result == power(n as nat))

+{

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Cube(n: nat) -> (c: nat)

-    ensures c == n * n * n

+pub fn cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(x: int, y: int) -> x_out: int, y_out: int, n: int

-    requires x >= 0,

-             y >= 0,

-             x == y

-    ensures y_out == n

+pub fn main(x: int, y: int) -> (x_out: int, y_out: int, n: int)

+    requires(x >= 0)

+    requires(y >= 0)

+    requires(x == y)

+    ensures(|result: (int, int, int)| result.1 == result.2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> x: int, m: int

-    requires n > 0

-    ensures (n <= 0) or (0 <= m and m < n)

+pub fn main(n: int) -> (x: int, m: int)

+    requires(n > 0)

+    ensures(|result: (int, int)| (n <= 0) || (0 <= result.1 && result.1 < n))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> i: int, x: int, y: int

-    requires n >= 0

-    ensures (i % 2 != 0) or (x == 2 * y)

+pub fn main(n: int) -> (i: int, x: int, y: int)

+    requires(n >= 0)

+    ensures(|result: (int, int, int)| (result.0 % 2 != 0) || (result.1 == 2 * result.2))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int, k: int) -> i: int, j: int

-    requires n >= 0,

-             k == 1 or k >= 0

-    ensures k + i + j >= 2 * n

+pub fn main(n: int, k: int) -> (i: int, j: int)

+    requires(n >= 0)

+    requires(k == 1 || k >= 0)

+    ensures(|result: (int, int)| k + result.0 + result.1 >= 2 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, key: int) -> (n: int)

-    requires forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

-    ensures 0 <= n <= a.len(),

-            forall|i: int| 0 <= i < n ==> a[i] < key,

-            forall|i: int| n <= i < a.len() ==> key <= a[i]

+pub fn binary_search(a: &[int], key: int) -> (n: int)

+    requires(

+        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    ensures(|n: int|

+        0 <= n <= a.len() &&

+        (forall|i: int| 0 <= i < n ==> a[i] < key) &&

+        (forall|i: int| n <= i < a.len() ==> key <= a[i])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec.rs
@@ -1,15 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumArray(arr: Vec<int>) -> (sum: int)

-    requires arr.len() > 0

-    ensures sum == Sum(arr, arr.len())

+spec fn Sum(arr: &[int], len: int) -> int

+    recommends(arr.len() > 0 && 0 <= len <= arr.len())

 {

+    if len == 0 { 0 } else { arr[len-1] + Sum(arr, len-1) }

 }

 

+

+pub fn SumArray(arr: &[int]) -> (sum: int)

+    requires(arr.len() > 0)

+    ensures(|result: int| result == Sum(arr, arr.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Main() -> x: int, y: int

-    ensures x == y;

+pub fn Main() -> (x: int, y: int)

+    ensures x == y

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> a: int, b: int

-    requires n >= 0

-    ensures a + b == 3 * n

+pub fn main(n: int) -> (a: int, b: int)

+    requires(n >= 0)

+    ensures(|result: (int, int)| result.0 + result.1 == 3 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(x: int) -> j: int, i: int

-    requires x > 0

-    ensures j == 2 * x

+pub fn main(x: int) -> (j: int, i: int)

+    requires(x > 0)

+    ensures(|result: (int, int)| result.0 == 2 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec.rs
@@ -1,15 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>, n: int) -> (max: int)

-    requires 0 < n <= a.len();

-    ensures is_max(max, a, n);

-{

+spec fn contains(v: int, a: &[int], n: int) -> bool {

+    exists|j: int| 0 <= j < n && a[j as nat] == v

 }

 

+

+spec fn upper_bound(v: int, a: &[int], n: int) -> bool {

+    forall|j: int| 0 <= j < n ==> a[j as nat] <= v

+}

+

+

+spec fn is_max(m: int, a: &[int], n: int) -> bool {

+    contains(m, a, n) && upper_bound(m, a, n)

+}

+

+

+pub fn max(a: &[int], n: int) -> (max: int)

+    requires(

+        0 < n <= a.len(),

+    )

+    ensures(|max: int|

+        is_max(max, a, n),

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int, k: int) -> (k_out: int)

-    requires n > 0;,

-             k > n;

-    ensures k_out >= 0;

+pub fn main(n: int, k: int) -> (k_out: int)

+    requires(n > 0)

+    requires(k > n)

+    ensures(k_out >= 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputePower(n: nat) -> (p: nat)

-    ensures p == Power(n)

-{

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

 }

 

+pub fn compute_power(n: nat) -> (p: nat)

+    ensures p == power(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec.rs
@@ -1,15 +1,15 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn count(v: int, a: Vec<int>, n: int) -> (r: int)

-    requires n >= 0 and n <= a.len();

-    ensures has_count(v, a, n) == r;

+spec fn has_count(v: int, a: &[int], n: int) -> int

+    decreases n

 {

+    if n == 0 { 0 } else {

+        if a[(n-1) as usize] == v { has_count(v, a, n-1) + 1 } else { has_count(v, a, n-1) }

+    }

 }

 

+pub fn count(v: int, a: &[int], n: int) -> (r: int)

+    requires(n >= 0 && n <= a.len())

+    ensures(has_count(v, a, n) == r)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Minimum(a: Vec<int>) -> (m: int)

-    requires a.len() > 0

-    ensures exists|i: int| 0 <= i < a.len() and m == a[i],

-            forall|i: int| 0 <= i < a.len() ==> m <= a[i]

+pub fn minimum(a: &[i32]) -> (m: i32)

+    requires(a.len() > 0)

+    ensures(exists|i: usize| 0 <= i < a.len() && m == a[i])

+    ensures(forall|i: usize| 0 <= i < a.len() ==> m <= a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mult(a: int, b: int) -> (x: int)

-    requires a >= 0 and b >= 0

-    ensures x == a * b

+pub fn mult(a: int, b: int) -> (x: int)

+    requires(a >= 0 && b >= 0)

+    ensures(x == a * b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Main(xInit: int, y: int) -> (z: int)

-    requires xInit >= 0,

-             y >= 0

-    ensures z == 0

+pub fn Main(xInit: int, y: int) -> (z: int)

+    requires

+        xInit >= 0,

+        y >= 0,

+    ensures

+        z == 0,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec.rs
@@ -1,14 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub fn Average(a: int, b: int) -> int

+{

+    (a + b) / 2

+}

 

-verus! {

 

-fn TripleConditions(x: int) -> (r: int)

+

+

+pub fn TripleConditions(x: int) -> (r: int)

     ensures r == 3 * x

 {

 }

 

+

+

+

+

+

+

+

+pub fn ProveSpecificationsEquivalent(x: int) {

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec.rs
@@ -1,24 +1,63 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> r: int)

-    ensures r == 3 * x

+pub fn Average(a: int, b: int) -> int 

 {

-    r := Average(2 * x, 4 * x);

+    (a + b) / 2

 }

 

 

 

 

-method Triple1(x: int) returns (r: int

-    ensures r == 3 * x,

-            r == 3 * x

+pub fn Triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

+{

+    Average(2 * x, 4 * x)

+}

+

+

+

+

+pub fn Triple1(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

 }

 

+

+

+

+pub fn DoubleQuadruple(x: int) -> (a: int, b: int)

+    ensures(a == 2 * x && b == 4 * x)

+{

+    let a = 2 * x;

+    let b = 2 * a;

+    (a, b)

+}

+

+

+

+

+pub fn F() -> int {

+    29

+}

+

+

+

+

+pub fn M() -> (r: int) 

+    ensures(r == 29)

+{

+}

+

+

+

+

+pub fn Caller() {

+}

+

+

+

+

+pub fn MyMethod(x: int) -> (y: int)

+    requires(10 <= x)

+    ensures(25 <= y)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec.rs
@@ -1,15 +1,36 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Index(n: int) -> (i: int)

-    requires 1 <= n

-    ensures 0 <= i < n

+pub fn Index(n: int) -> (i: int)

+    requires(1 <= n)

+    ensures(|i: int| 0 <= i < n)

 {

 }

 

+pub fn Min(x: int, y: int) -> (m: int)

+    ensures(|m: int| m <= x && m <= y)

+    ensures(|m: int| m == x || m == y)

+{

+}

+

+pub fn Max(x: int, y: int) -> (m: int)

+{

+}

+

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(|(s, m): (int, int)| s == x + y)

+    ensures(|(s, m): (int, int)| m == if x >= y { x } else { y })

+{

+}

+

+pub fn MaxSumCaller()

+{

+}

+

+pub fn ReconstructFromMaxSum(s: int, m: int) -> (x: int, y: int)

+    requires(s <= 2 * m)

+    ensures(|(x, y): (int, int)| s == (x + y))

+    ensures(|(x, y): (int, int)| (m == x || m == y) && x <= m && y <= m)

+{

+}

+

+pub fn TestMaxSum(x: int, y: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec.rs
@@ -1,15 +1,37 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn UpWhileLess(N: int) -> (i: int)

-    requires 0 <= N

-    ensures i == N

+pub fn UpWhileLess(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(|result: int| result == N)

 {

 }

 

+

+pub fn UpWhileNotEqual(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(|result: int| result == N)

+{

+}

+

+

+pub fn DownWhileNotEqual(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(|result: int| result == 0)

+{

+}

+

+

+pub fn DownWhileGreater(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(|result: int| result == 0)

+{

+}

+

+

+pub fn Quotient()

+{

+}

+

+

+pub fn Quotient1()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec.rs
@@ -1,13 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

+pub fn Triple(x: int) -> (r: int)

 {

 }

 

+pub fn TripleIf(x: int) -> (r: int) 

+{

+}

+

+pub fn TripleOver(x: int) -> (r: int) 

+{

+}

+

+pub fn TripleConditions(x: int) -> (r: int)

+    requires(x % 2 == 0)

+    ensures(r == 3 * x)

+{

+}

+

+pub fn Caller() 

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main() -> t1: int, t2: int, x: int, y: int

+pub fn main() -> (t1: int, t2: int, x: int, y: int)

     ensures y >= 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn min(a: Vec<int>, n: int) -> (min: int)

-    requires 0 < n <= a.len();

-    ensures (exists i : int :: 0 <= i and i < n and a[i] == min);,

-            (forall i : int :: 0 <= i and i < n ==> a[i] >= min);

+pub fn min(a: &[i32], n: usize) -> (min: i32)

+    requires(

+        0 < n <= a.len()

+    )

+    ensures(|min: i32|

+        exists|i: usize| 0 <= i && i < n && a[i as int] == min

+    )

+    ensures(|min: i32|

+        forall|i: usize| 0 <= i && i < n ==> a[i as int] >= min

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_small_numbers(a: Vec<int>, n: int, max: int) -> (r: int)

-    requires n > 0;,

-             n <= a.len();,

-             (forall i: int :: 0 <= i and i < n ==> a[i] <= max);

-    ensures r <= max * n;

+pub fn add_small_numbers(a: &[int], n: int, max: int) -> (r: int)

+    requires(n > 0)

+    requires(n <= a.len())

+    requires(forall|i: int| 0 <= i && i < n ==> a[i] <= max)

+    ensures(|r: int| r <= max * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn square(n: int) -> (r: int)

-    requires 0 <= n;

-    ensures r == n*n;

+pub fn square(n: int) -> (r: int)

+    requires(0 <= n)

+    ensures(r == n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn is_even(n: int) -> (r: bool)

-    requires n >= 0;

-    ensures r <==> even(n);

+spec fn even(n: int) -> bool

+    recommends n >= 0

 {

+    if n == 0 { true } else { !even(n - 1) }

 }

 

+pub fn is_even(n: int) -> (r: bool)

+    requires n >= 0

+    ensures r <==> even(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec.rs
@@ -1,18 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SearchRecursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

-    requires 0 <= i <= j <= a.len();

-    ensures i <= k < j or k == -1;,

-            k != -1 ==> a[k] == x;,

-            k != -1 ==> forall|r | k < r < j: int| a[r] != x;,

-            k == -1 ==> forall|r | i <= r < j: int| a[r] != x;

+pub fn search_recursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(i <= k < j || k == -1)

+    ensures(k != -1 ==> a[k] == x)

+    ensures(k != -1 ==> forall|r: int| k < r < j ==> a[r] != x)

+    ensures(k == -1 ==> forall|r: int| i <= r < j ==> a[r] != x)

 {

 }

 

+pub fn search_loop(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(i <= k < j || k == -1)

+    ensures(k != -1 ==> a[k] == x)

+    ensures(k != -1 ==> forall|r: int| k < r < j ==> a[r] != x)

+    ensures(k == -1 ==> forall|r: int| i <= r < j ==> a[r] != x)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec.rs
@@ -1,37 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Search(s: Seq<int>, x: int) -> k: int )

-

-    requires forall p, q | 0 <= p < q < |s|: : s[p] <= s[q];

-    ensures 0 <= k <= |s|;

-    ensures forall i | 0 <= i < k :: s[i] <= x;

-    ensures forall i | k <= i < |s| :: s[i] >= x;

-    ensures forall z | z in s[..k] :: z <= x;

-    ensures forall z | z in s[k..] :: z >= x;

-    ensures s == s[..k]+s[k..];

+pub fn search(s: Seq<int>, x: int) -> (k: int)

+    requires(

+        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]

+    )

+    ensures(|k: int|

+        0 <= k <= s.len() &&

+        (forall|i: int| 0 <= i < k ==> s[i] <= x) &&

+        (forall|i: int| k <= i < s.len() ==> s[i] >= x) &&

+        (forall|z: int| s.subrange(0, k).contains(z) ==> z <= x) &&

+        (forall|z: int| s.subrange(k, s.len() as int).contains(z) ==> z >= x) &&

+        s == s.subrange(0, k) + s.subrange(k, s.len() as int)

+    )

 {

 }

 

-

-

-

-method Sort( m: multiset<int> ) returns ( r: seq<int>

-    requires forall|p: int, q  0 <= p < q < .len()s|: int| s[p] <= s[q];

-    ensures 0 <= k <= s.len();,

-            forall|i | 0 <= i < k: int| s[i] <= x;,

-            forall|i  k <= i < .len()s|: int| s[i] >= x;,

-            forall|z | z in s[..k]: int| z <= x;,

-            forall|z | z in s[k..]: int| z >= x;,

-            s == s[..k]+s[k..];,

-            multiset(r) == m;,

-            forall|p: int, q  0 <= p < q < .len()r|: int| r[p] <= r[q];

+pub fn sort(m: Multiset<int>) -> (r: Seq<int>)

+    ensures(|r: Seq<int>|

+        r.to_multiset() == m &&

+        (forall|p: int, q: int| 0 <= p < q < r.len() ==> r[p] <= r[q])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec.rs
@@ -1,13 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn MinOfMultiset(m: multiset<int>) -> (min: int)

-    requires m != multiset

+pub fn min_of_multiset(m: Multiset<int>) -> (min: int)

+    requires(m != Multiset::empty())

+    ensures(m.count(min) > 0)

+    ensures(forall|z: int| m.count(z) > 0 ==> min <= z)

+{

+}

+

+pub fn test(m: Multiset<int>)

+{

+}

+

+pub fn main()

+{

+}

+

+pub fn sort(m: Multiset<int>) -> (s: Seq<int>)

+    ensures(s.to_multiset() == m)

+    ensures(forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q])

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec.rs
@@ -1,16 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Partition(m: multiset<int>) -> pre: multiset<int>, p: int, post: multiset<int>

-    requires m.len() > 0;

-    ensures p in m;,

-            m == pre+multiset

+pub fn Partition(m: Multiset<int>) -> (pre: Multiset<int>, p: int, post: Multiset<int>)

+    requires(m.len() > 0)

+    ensures(m.contains(p))

+    ensures(m == pre + Multiset::singleton(p) + post)

+    ensures(forall|z: int| pre.contains(z) ==> z <= p)

+    ensures(forall|z: int| post.contains(z) ==> z >= p)

 {

 }

 

+pub fn QuickSelect(m: Multiset<int>, k: int) -> (pre: Multiset<int>, kth: int, post: Multiset<int>)

+    requires(0 <= k < m.len())

+    ensures(m.contains(kth))

+    ensures(m == pre + Multiset::singleton(kth) + post)

+    ensures(pre.len() == k)

+    ensures(forall|z: int| pre.contains(z) ==> z <= kth)

+    ensures(forall|z: int| post.contains(z) ==> z >= kth)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec.rs
@@ -1,14 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn F() -> (r: int)

-    ensures r <= 0

+pub fn F() -> (r: int)

+    ensures(r <= 0)

 {

 }

 

+pub fn Main() 

+{

+}

+

+pub fn Mid(p: int, q: int) -> (m: int)

+    requires(p <= q)

+    ensures(p <= m <= q)

+    ensures(m - p <= q - m)

+    ensures(0 <= (q - m) - (m - p) <= 1)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec.rs
@@ -1,18 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsSorted(s: Seq<int>) -> bool {

-    forall|p: int, q  0<=p<q<.len()s|: int| s[p]<=s[q]

+spec fn is_sorted(s: Seq<int>) -> bool {

+    forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]

 }

 

-fn InsertionSort(s: Seq<int>) -> (r: Seq<int>)

-    ensures multiset(r) == multiset(s);,

-            IsSorted(r);

+pub fn insertion_sort(s: Seq<int>) -> (r: Seq<int>)

+    ensures

+        r.to_multiset() == s.to_multiset(),

+        is_sorted(r),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec.rs
@@ -1,26 +1,50 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Is2Pow(n: int) -> bool {

+pub fn Search1000(a: &[i32], x: i32) -> (k: usize)

+    requires 

+        a.len() >= 1000,

+        forall|p: usize, q: usize| 0 <= p < q < 1000 ==> a[p as int] <= a[q as int],

+    ensures 

+        0 <= k <= 1000,

+        forall|r: usize| 0 <= r < k ==> a[r as int] < x,

+        forall|r: usize| k <= r < 1000 ==> a[r as int] >= x,

+{

+}

+

+pub open spec fn Is2Pow(n: int) -> bool

+    decreases n

+{

     if n < 1 then

         false

     else if n == 1 then

         true

     else

-        n%2 == 0 and Is2Pow(n/2)

+        n % 2 == 0 && Is2Pow(n / 2)

 }

 

-fn Search1000(a: Vec<int>, x: int) -> (k: int)

-    requires a.len() >= 1000;,

-             forall|p: int, q | 0 <= p < q < 1000: int| a[p] <= a[q];

-    ensures 0 <= k <= 1000;,

-            forall|r | 0 <= r < k: int| a[r] < x;,

-            forall|r | k <= r < 1000: int| a[r] >= x;

+pub fn Search2PowLoop(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)

+    requires 

+        0 <= i <= i + n <= a.len(),

+        forall|p: usize, q: usize| i <= p < q < i + n ==> a[p as int] <= a[q as int],

+        Is2Pow((n + 1) as int),

+    ensures 

+        i <= k <= i + n,

+        forall|r: usize| i <= r < k ==> a[r as int] < x,

+        forall|r: usize| k <= r < i + n ==> a[r as int] >= x,

+{

+}

+

+pub fn Search2PowRecursive(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)

+    requires 

+        0 <= i <= i + n <= a.len(),

+        forall|p: usize, q: usize| i <= p < q < i + n ==> a[p as int] <= a[q as int],

+        Is2Pow((n + 1) as int),

+    ensures 

+        i <= k <= i + n,

+        forall|r: usize| i <= r < k ==> a[r as int] < x,

+        forall|r: usize| k <= r < i + n ==> a[r as int] >= x,

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec.rs
@@ -1,16 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sumInts(n: int) -> int

+    recommends n >= 0

+{

+    if n == 0 {

+        0

+    } else {

+        sumInts(n-1)+n

+    }

+}

 

-verus! {

 

-fn SumIntsLoop(n: int) -> (s: int)

-    requires n >= 0;

-    ensures s == sumInts(n),

-            s == n*(n+1)/2;

+pub fn SumIntsLoop(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == sumInts(n))

+    ensures(s == n*(n+1)/2)

 {

 }

 

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec.rs
@@ -1,17 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>, b: Vec<int>, i: int, j: int) -> (m: int)

-    requires 0 <= i < a.len(),

-             0 <= j < b.len()

-    ensures a[i] > b[j] ==> m == a[i],

-            a[i] <= b[j] ==> m == b[j]

+pub fn max(a: &[i32], b: &[i32], i: usize, j: usize) -> (m: i32)

+    requires(

+        i < a.len() &&

+        j < b.len()

+    )

+    ensures(|m: i32|

+        (a[i as int] > b[j as int] ==> m == a[i as int]) &&

+        (a[i as int] <= b[j as int] ==> m == b[j as int])

+    )

 {

 }

 

+pub fn testMax(a: &[i32], b: &[i32], i: usize, j: usize)

+    requires(

+        i < a.len() &&

+        j < b.len()

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_SlowMax_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_SlowMax_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_SlowMax_spec.rs
@@ -1,14 +1,8 @@
+pub fn max(x: nat, y: nat) -> nat {

+    if x < y { y } else { x }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn slow_max(a: nat, b: nat) -> (z: nat)

+pub fn slow_max(a: nat, b: nat) -> (z: nat)

     ensures z == max(a, b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_examples1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_examples1_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_examples1_spec.rs
@@ -1,17 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures y>=0;,

-            x>=0 ==> x == y;,

-            x<0 ==> -x == y;,

-            y == abs(x);

+pub fn Abs(x: int) -> (y: int)

+    ensures

+        y >= 0,

+        x >= 0 ==> x == y,

+        x < 0 ==> -x == y,

+        y == abs(x),

 {

 }

 

+spec fn abs(x: int) -> int {

+    if x > 0 { x } else { -x }

+}

+

+pub fn Testing() {

+}

+

+pub fn MultiReturn(x: int, y: int) -> (more: int, less: int)

+    requires

+        y >= 0,

+    ensures

+        less <= x <= more,

+{

+}

+

+pub fn Max(x: int, y: int) -> (a: int)

+    ensures

+        a == x || a == y,

+        x > y ==> a == x,

+        x <= y ==> a == y,

+{

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn findMax(a: Vec<int>, n: int) -> (r: int)

-    requires a.len() > 0,

-             0 < n <= a.len()

-    ensures 0 <= r < n <= a.len();,

-            forall|k: int| 0 <= k < n <= a.len() ==> a[r] >= a[k];,

-            multiset(a[..]) == multiset(old(a[..]));

+pub fn findMax(a: &mut Vec<i32>, n: usize) -> (r: usize)

+    requires(

+        a.len() > 0,

+        0 < n <= a.len(),

+    )

+    ensures(|r: usize|

+        0 <= r < n <= a.len() &&

+        forall|k: usize| 0 <= k < n <= a.len() ==> a[r] >= a[k] &&

+        a@ == old(a)@

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Dafny_tmp_tmpv_d3qi10_2_min_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Dafny_tmp_tmpv_d3qi10_2_min_spec.rs
+++ verus_specs/translations/atomizer_supported/Dafny_tmp_tmpv_d3qi10_2_min_spec.rs
@@ -1,17 +1,50 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

+spec fn min(a: int, b: int) -> int

+    ensures |result: int| result <= a && result <= b

+    ensures |result: int| result == a || result == b

+{

+    if a < b { a } else { b }

+}

 

-fn minMethod(a: int, b: int) -> (c: int)

-    ensures c <= a and c <= b,

-            c == a or c == b

 

-            c == min(a, b)

+

+

+pub fn minMethod(a: int, b: int) -> (c: int)

+    ensures c <= a && c <= b,

+    ensures c == a || c == b,

+

+    ensures c == min(a, b),

 {

 }

 

+

+

+

+spec fn minFunction(a: int, b: int) -> int

+    ensures |result: int| result <= a && result <= b

+    ensures |result: int| result == a || result == b

+{

+    if a < b { a } else { b }

+}

+

+

+

+

+

+

+

+

+pub fn minArray(a: &[int]) -> (m: int)

+    requires a.len() > 0,

+    ensures forall|k: int| 0 <= k < a.len() ==> m <= a[k as usize],

+    ensures exists|k: int| 0 <= k < a.len() && m == a[k as usize],

+{

+}

+

+

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec.rs
+++ verus_specs/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn findMax(a: Vec<int>) -> pos: int, maxVal: int

-    requires a.len() > 0;,

-             forall|i: int| 0 <= i < a.len() ==> a[i] >= 0;

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= maxVal;,

-            exists|i: int| 0 <= i < a.len() and  a[i] == maxVal;,

-            0 <= pos < a.len(),

-            a[pos] == maxVal;

+pub fn findMax(a: &[int]) -> (pos: usize, maxVal: int)

+    requires(a.len() > 0)

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i] >= 0)

+    ensures(|result: (usize, int)| forall|i: int| 0 <= i < a.len() ==> a[i] <= result.1)

+    ensures(|result: (usize, int)| exists|i: int| 0 <= i < a.len() && a[i] == result.1)

+    ensures(|result: (usize, int)| 0 <= result.0 < a.len())

+    ensures(|result: (usize, int)| a[result.0] == result.1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec.rs
+++ verus_specs/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn binarySearch(a: Vec<int>, val: int) -> (pos: int)

-    requires a.len() > 0,

-             forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

-    ensures 0 <= pos < a.len() ==> a[pos] == val,

-            pos < 0 or pos >= a.len()  ==> forall|i: int| 0 <= i < a.len() ==> a[i] != val

+pub fn binarySearch(a: &[i32], val: i32) -> (pos: i32)

+    requires

+        a.len() > 0,

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j],

+    ensures

+        |pos: i32| 0 <= pos < a.len() ==> a[pos as usize] == val,

+        |pos: i32| pos < 0 || pos >= a.len() ==> forall|i: usize| 0 <= i < a.len() ==> a[i] != val,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec.rs
+++ verus_specs/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec.rs
@@ -1,51 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted(a: Vec<int>, a.Length)

+pub open spec fn sorted(a: &[int]) -> bool {

+    sortedA(a, a.len())

 }

 

 

-

-

-predicate sortedA (a: Vec<int>, i: int)

-

-	requires 0 <= i <= a.Length

-	reads a

+pub open spec fn sortedA(a: &[int], i: int) -> bool

+    requires 0 <= i <= a.len()

 {

-	forall k :: 0 < k < i ==> a[k-1] <= a[k]

+    forall|k: int| 0 < k < i ==> a[k-1] <= a[k]

 }

 

 

-

-

-method lookForMin (a: array<int>, i: int) returns (m: int)

-

-	requires 0 <= i < a.Length

-	ensures i <= m < a.Length

-	ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]

+pub fn lookForMin(a: &[int], i: int) -> (m: int)

+    requires 0 <= i < a.len()

+    ensures i <= m < a.len()

+    ensures forall|k: int| i <= k < a.len() ==> a[k] >= a[m]

 {

 }

 

 

-

-

-method insertionSort (a: array<int>)

-

-	modifies a

-	ensures sorted(a) -> bool {

-    

-}

-

-fn lookForMin(a: Vec<int>, i: int) -> (m: int)

-    requires 0 <= i < a.len()

-    ensures i <= m < a.len(),

-            forall|k: int| i <= k < a.len() ==> a[k] >= a[m]

+pub fn insertionSort(a: &mut [int])

+    ensures sorted(a)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec.rs
+++ verus_specs/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec.rs
@@ -1,20 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn quickSorted(Seq: Seq<int>) -> bool {

+pub open spec fn quickSorted(Seq: Seq<int>) -> bool

+{

     forall|idx_1: int, idx_2: int| 0 <= idx_1 < idx_2 < Seq.len() ==> Seq[idx_1] <= Seq[idx_2]

 }

 

-fn threshold(thres: int, Seq: Seq<int>) -> Seq_1: Seq<int>, Seq_2: Seq<int>

-    ensures (forall|x  x in Seq_1: int| x <= thres) and (forall|x .len() x in Seq_2: int| x >= thres),

-            Seq_1.len() + Seq_2.len() == Seq.len(),

-            multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)

+

+pub fn threshold(thres: int, Seq: Seq<int>) -> (Seq_1: Seq<int>, Seq_2: Seq<int>)

+    ensures

+        (forall|x: int| Seq_1.contains(x) ==> x <= thres) && (forall|x: int| Seq_2.contains(x) ==> x >= thres),

+        Seq_1.len() + Seq_2.len() == Seq.len(),

+        Seq_1.to_multiset() + Seq_2.to_multiset() == Seq.to_multiset(),

 {

 }

 

+

+proof fn Lemma_1(Seq_1: Seq<int>, Seq_2: Seq<int>)

+    requires

+        Seq_1.to_multiset() == Seq_2.to_multiset(),

+    ensures

+        forall|x: int| Seq_1.contains(x) ==> Seq_2.contains(x),

+{

+}

+

+

+pub fn quickSort(Seq: Seq<int>) -> (Seq_prime: Seq<int>)

+    ensures

+        Seq.to_multiset() == Seq_prime.to_multiset(),

+{

 }

================================================================================
Comparing translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec.rs
+++ verus_specs/translations/atomizer_supported/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec.rs
@@ -1,14 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn nonZeroReturn(x: int) -> (y: int)

-    ensures y != 0

+pub fn nonZeroReturn(x: int) -> (y: int)

+    ensures(y != 0)

 {

 }

 

+pub fn test() {

 }

================================================================================
Comparing translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec.rs
@@ -1,15 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn aba(a: Vec<int>) -> (b: Vec<int>)

-    ensures a.len() == b.len()

-            forall|x: int| 0<=x<b.len() ==> b[x] == abs(a[x])

+spec fn abs(a: int) -> nat {

+    if a < 0 { -a } else { a }

+}

+

+pub fn aba(a: &[i32]) -> (b: Vec<i32>)

+    ensures

+        a.len() == b.len(),

+        forall|x: int| 0 <= x < b.len() ==> b[x as int] == abs(a[x as int]),

 {

 }

 

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec.rs
+++ verus_specs/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: Vec<nat>) -> (m: int)

-    ensures a.len() > 0 ==> forall|k: int| 0<=k<a.len() ==> m >= a[k]

-            a.len() == 0 ==> m == -1,

-            a.len() > 0 ==> m in a[..]

+pub fn max(a: &[nat]) -> (m: i32)

+    requires(true)

+    ensures(|result: i32| a.len() > 0 ==> (forall|k: usize| 0 <= k < a.len() ==> result >= a[k]))

+    ensures(|result: i32| a.len() == 0 ==> result == -1)

+    ensures(|result: i32| a.len() > 0 ==> exists|k: usize| 0 <= k < a.len() && result == a[k])

 {

 }

 

+pub fn checker()

+    requires(true)

+    ensures(true)

+{

 }

================================================================================
Comparing translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec.rs
+++ verus_specs/translations/atomizer_supported/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec.rs
@@ -1,33 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> b: Vec<char>, functions or methods

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method Reverse(a: Vec<char>) returns (b: array<char>

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|k: int| 0 <= k < a.len() ==> b[k] == a[(a.len()-1) - k];

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|k: usize| 0 <= k < a.len() ==> result[k] == a[(a.len()-1) - k])

 {

 }

 

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_BubbleSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_BubbleSort_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_BubbleSort_spec.rs
@@ -1,40 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted(a: array?<int>, l: int, u: int)

-  reads a;

-  requires a != null;

-  {

-    forall i, j: : 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]

-  }

+spec fn sorted(a: &[i32], l: int, u: int) -> bool

+{

+    forall|i: int, j: int| 0 <= l <= i <= j <= u < a.len() ==> a[i] <= a[j]

+}

 

 

-predicate partitioned(a: array?<int>, i: int)

-  reads a

-  requires a != null

-  {

-    forall k, k': : 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']

-  }

+spec fn partitioned(a: &[i32], i: int) -> bool

+{

+    forall|k: int, k_prime: int| 0 <= k <= i < k_prime < a.len() ==> a[k] <= a[k_prime]

+}

 

 

+pub fn BubbleSort(a: &mut [i32])

+{

+}

 

 

-method BubbleSort(a: array?<int>)

-  modifies a

-  requires a != null

-  {

-}

-

-  

-

-  

-method Main() -> bool {

-    

-}

-

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fact(x: int) -> (y: int)

-    requires x >= 0;

+pub fn Fact(x: int) -> (y: int)

+    requires(x >= 0)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec.rs
@@ -1,36 +1,91 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+pub open spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+pub open spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+pub proof fn PrefixNegationLemma(pre: String, str: String)

+    ensures isPrefixPred(pre, str) <==> !isNotPrefixPred(pre, str)

+    ensures !isPrefixPred(pre, str) <==> isNotPrefixPred(pre, str)

 {

 }

 

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures !res <==> isNotPrefixPred(pre, str)

+    ensures res <==> isPrefixPred(pre, str)

+{

+}

+

+

+pub open spec fn isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+pub open spec fn isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+pub proof fn SubstringNegationLemma(sub: String, str: String)

+    ensures isSubstringPred(sub, str) <==> !isNotSubstringPred(sub, str)

+    ensures !isSubstringPred(sub, str) <==> isNotSubstringPred(sub, str)

+{

+}

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures res <==> isSubstringPred(sub, str)

+{

+}

+

+

+pub open spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+pub open spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+pub proof fn commonKSubstringLemma(k: nat, str1: String, str2: String)

+    ensures haveCommonKSubstringPred(k, str1, str2) <==> !haveNotCommonKSubstringPred(k, str1, str2)

+    ensures !haveCommonKSubstringPred(k, str1, str2) <==> haveNotCommonKSubstringPred(k, str1, str2)

+{

+}

+

+

+pub fn haveCommonKSubstring(k: nat, str1: String, str2: String) -> (found: bool)

+    ensures found <==> haveCommonKSubstringPred(k, str1, str2)

+{

+}

+

+

+pub proof fn haveCommon0SubstringLemma(str1: String, str2: String)

+    ensures haveCommonKSubstringPred(0, str1, str2)

+{

+}

+

+

+pub fn maxCommonSubstringLength(str1: String, str2: String) -> (len: nat)

+    requires str1.len() <= str2.len()

+    ensures forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPred(k, str1, str2)

+    ensures haveCommonKSubstringPred(len, str1, str2)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec.rs
@@ -1,27 +1,60 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPredicate(pre: String, str: String) -> bool {

-    str.len() >= pre.len() and pre <= str

-}

-spec fn isSubstringPredicate(sub: String, str: String) -> bool {

-    str.len() >= sub.len() and (exists|i: int| 0 <= i <= str.len() and isPrefixPredicate(sub, str[i..]))

-}

-spec fn haveCommonKSubstringPredicate(k: nat, str1: String, str2: String) -> bool {

-    str1.len() >= k and str2.len() >= k and (exists|i: int| 0 <= i <= str1.len() - k and isSubstringPredicate((str1[i..])[..k], str2))

-}

-spec fn maxCommonSubstringPredicate(str1: String, str2: String, len: nat) -> bool {

-    forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPredicate(k, str1, str2)

+

+spec fn isPrefixPredicate(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    str.len() >= pre.len() && pre <= str

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures pre.len() > str.len() ==> !res,

-            res == isPrefixPredicate(pre, str)

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        pre.len() > str.len() ==> !res,

+        res == isPrefixPredicate(pre, str),

+{

+}

+

+

+spec fn isSubstringPredicate(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && isPrefixPredicate(sub, str.subrange(i, str.len() as int)))

+}

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        res == isSubstringPredicate(sub, str),

+{

+}

+

+

+spec fn haveCommonKSubstringPredicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+    str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && isSubstringPredicate(str1.subrange(i, str1.len() as int).subrange(0, k as int), str2))

+}

+

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures

+        str1.len() < k || str2.len() < k ==> !found,

+        haveCommonKSubstringPredicate(k, str1, str2) == found,

+{

+}

+

+

+spec fn maxCommonSubstringPredicate(str1: Seq<char>, str2: Seq<char>, len: nat) -> bool

+{

+    forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPredicate(k as nat, str1, str2)

+}

+

+

+pub fn maxCommonSubstringLength(str1: Seq<char>, str2: Seq<char>) -> (len: nat)

+    ensures

+        len <= str1.len() && len <= str2.len(),

+        len >= 0,

+        maxCommonSubstringPredicate(str1, str2, len),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec.rs
@@ -1,35 +1,71 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+proof fn PrefixNegationLemma(pre: Seq<char>, str: Seq<char>)

+    ensures isPrefixPred(pre, str) <==> !isNotPrefixPred(pre, str),

+    ensures !isPrefixPred(pre, str) <==> isNotPrefixPred(pre, str),

+{

+}

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures !res <==> isNotPrefixPred(pre, str),

+    ensures res <==> isPrefixPred(pre, str),

+{

+}

+

+spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+proof fn SubstringNegationLemma(sub: Seq<char>, str: Seq<char>)

+    ensures isSubstringPred(sub, str) <==> !isNotSubstringPred(sub, str),

+    ensures !isSubstringPred(sub, str) <==> isNotSubstringPred(sub, str),

+{

+}

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures res <==> isSubstringPred(sub, str),

+{

+}

+

+spec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+proof fn commonKSubstringLemma(k: nat, str1: Seq<char>, str2: Seq<char>)

+    ensures haveCommonKSubstringPred(k, str1, str2) <==> !haveNotCommonKSubstringPred(k, str1, str2),

+    ensures !haveCommonKSubstringPred(k, str1, str2) <==> haveNotCommonKSubstringPred(k, str1, str2),

+{

+}

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures found <==> haveCommonKSubstringPred(k, str1, str2),

+{

+}

+

+pub fn maxCommonSubstringLength(str1: Seq<char>, str2: Seq<char>) -> (len: nat)

+    requires str1.len() <= str2.len(),

+    ensures forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPred(k as nat, str1, str2),

+    ensures haveCommonKSubstringPred(len, str1, str2),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec.rs
@@ -1,61 +1,59 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn multipleReturns(x: int, y: int) -> more: int, less: int)

-requires y > 0

-ensures less < x < more

-

-

-

-method multipleReturns2 (x:int, y: int) returns (more:int, less: int)

-requires y > 0

-ensures more + less == 2*x

-

-

-

-method multipleReturns3 (x:int, y: int) returns (more:int, less: int)

-requires y > 0

-ensures more - less == 2*y

-

-

-function factorial(n:int):int

-requires n>=0

-{

-    if n==0 || n==1 then 1 else n*factorial(n-1)

-}

-

-

-

-

-

-

-method ComputeFact (n:int) returns (f:int

-    requires y > 0,

-             y > 0,

-             y > 0,

-             n>=0,

-             n >=0

-    ensures less < x < more

-

-

-

-method multipleReturns2 (x:int, y:int) returns (more:int, less:int),

-            more + less == 2*x

-

-

-

-method multipleReturns3 (x:int, y:int) returns (more:int, less:int),

-            more - less == 2*y

-

-

-function factorial(n:int):int,

-            f== factorial(n)

+pub fn multipleReturns(x: int, y: int) -> (more: int, less: int)

+    requires(y > 0)

+    ensures(|result: (int, int)| result.1 < x < result.0)

 {

 }

 

+pub fn multipleReturns2(x: int, y: int) -> (more: int, less: int)

+    requires(y > 0)

+    ensures(|result: (int, int)| result.0 + result.1 == 2*x)

+{

+}

+

+pub fn multipleReturns3(x: int, y: int) -> (more: int, less: int)

+    requires(y > 0)

+    ensures(|result: (int, int)| result.0 - result.1 == 2*y)

+{

+}

+

+spec fn factorial(n: int) -> int

+    recommends(n >= 0)

+{

+    if n == 0 || n == 1 { 1 } else { n * factorial(n-1) }

+}

+

+pub fn ComputeFact(n: int) -> (f: int)

+    requires(n >= 0)

+    ensures(|result: int| result == factorial(n))

+{

+}

+

+pub fn ComputeFact2(n: int) -> (f: int)

+    requires(n >= 0)

+    ensures(|result: int| result == factorial(n))

+{

+}

+

+pub fn Sqare(a: int) -> (x: int)

+    requires(a >= 1)

+    ensures(|result: int| result == a*a)

+{

+}

+

+spec fn sumSerie(n: int) -> int

+    recommends(n >= 1)

+{

+    if n == 1 { 1 } else { sumSerie(n-1) + 2*n - 1 }

+}

+

+proof fn Sqare_Lemma(n: int)

+    requires(n >= 1)

+    ensures(sumSerie(n) == n*n)

+{

+}

+

+pub fn Sqare2(a: int) -> (x: int)

+    requires(a >= 1)

+    ensures(|result: int| result == a*a)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec.rs
+++ verus_specs/translations/atomizer_supported/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec.rs
@@ -1,13 +1,36 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn vector_Sum(v: Seq<int>) -> (x: int)

-    ensures x == sum(v)

+spec fn sum(v: Seq<int>) -> int {

+    if v == seq![] { 

+        0 

+    } else if v.len() == 1 { 

+        v[0] 

+    } else { 

+        v[0] + sum(v.subrange(1, v.len() as int)) 

+    }

+}

+

+proof fn empty_lemma<T>(r: Seq<T>)

+    requires multiset(r) == Multiset::empty(),

+    ensures r == seq![],

+{

+}

+

+proof fn elem_lemma<T>(s: Seq<T>, r: Seq<T>)

+    requires 

+        s != seq![] && multiset(s) == multiset(r),

+    ensures 

+        exists|i: int| 0 <= i < r.len() && r[i] == s[0] && 

+        multiset(s.subrange(1, s.len() as int)) == 

+        multiset(r.subrange(0, i).add(r.subrange(i + 1, r.len() as int))),

+{

+}

+

+proof fn sum_elems_lemma(s: Seq<int>, r: Seq<int>)

+    requires multiset(s) == multiset(r),

+    ensures sum(s) == sum(r),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec.rs
@@ -1,13 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+spec fn Potencia(x: nat, y: nat) -> nat

+    decreases y

+{

+    if y == 0 {

+        1

+    } else {

+        x * Potencia(x, (y - 1) as nat)

+    }

+}

+

+pub fn Pot(x: nat, y: nat) -> (r: nat)

+    ensures r == Potencia(x, y)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec.rs
+++ verus_specs/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec.rs
@@ -1,18 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(arr: Vec<int>, target: int) -> (index: int)

-    requires distinct(arr),

-             sorted(arr)

-    ensures -1 <= index < arr.len(),

-            index == -1 ==> not_found(arr, target),

-            index != -1 ==> found(arr, target, index)

+pub fn binary_search(arr: &[i32], target: i32) -> (index: i32)

+    requires(distinct(arr))

+    requires(sorted(arr))

+    ensures(|index: i32| -1 <= index < arr.len() as i32)

+    ensures(|index: i32| index == -1 ==> not_found(arr, target))

+    ensures(|index: i32| index != -1 ==> found(arr, target, index))

 {

 }

 

+pub open spec fn sorted(a: &[i32]) -> bool

+{

+   forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] <= a[k]

+}

+

+pub open spec fn distinct(arr: &[i32]) -> bool

+{

+    forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]

+}

+

+pub open spec fn not_found(arr: &[i32], target: i32) -> bool

+{

+    forall|j: int| 0 <= j < arr.len() ==> arr[j] != target

+}

+

+pub open spec fn found(arr: &[i32], target: i32, index: i32) -> bool

+    recommends(-1 <= index < arr.len() as i32)

+{

+    if index == -1 { false }

+    else if arr[index as int] == target { true }

+    else { false }

 }

================================================================================
Comparing translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec.rs
@@ -1,15 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn largest_sum(nums: Vec<int>, k: int) -> (sum: int)

-    requires nums.len() > 0

-    ensures max_sum_subarray(nums, sum, 0, nums.len())

+pub fn largest_sum(nums: &[i32], k: i32) -> (sum: i32)

+    requires(nums.len() > 0)

+    ensures(|sum: i32| max_sum_subarray(nums, sum, 0, nums.len()))

 {

 }

 

+pub open spec fn max_sum_subarray(arr: &[i32], sum: i32, start: usize, stop: usize) -> bool

+    recommends(arr.len() > 0)

+    recommends(0 <= start <= stop <= arr.len())

+{

+    forall|u: usize, v: usize| start <= u < v <= stop ==> Sum_Array(arr, u, v) <= sum

+}

+

+pub open spec fn Sum_Array(arr: &[i32], start: usize, stop: usize) -> i32

+    recommends(0 <= start <= stop <= arr.len())

+    decreases(stop - start)

+{

+    if start >= stop {

+        0

+    } else {

+        arr[stop - 1] + Sum_Array(arr, start, stop - 1)

+    }

 }

================================================================================
Comparing translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec.rs
@@ -1,19 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn twoSum(nums: Vec<int>, target: int) -> index1: int, index2: int

-    requires 2 <= nums.len(),

-             exists|i: int, j: int| (0 <= i < j < nums.len() and nums[i] + nums[j] == target)

-    ensures index1 != index2,

-            0 <= index1 < nums.len(),

-            0 <= index2 < nums.len(),

-            nums[index1] + nums[index2] == target

+pub fn twoSum(nums: &[i32], target: i32) -> (index1: usize, index2: usize)

+    requires

+        2 <= nums.len(),

+        exists|i: usize, j: usize| (0 <= i < j < nums.len() && nums[i] + nums[j] == target),

+    ensures |result: (usize, usize)|

+        result.0 != result.1 &&

+        0 <= result.0 < nums.len() &&

+        0 <= result.1 < nums.len() &&

+        nums[result.0] + nums[result.1] == target,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec.rs
+++ verus_specs/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountToAndReturnN(n: int) -> (r: int)

-    requires n >= 0

-    ensures r == n

+pub fn count_to_and_return_n(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(r == n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec.rs
+++ verus_specs/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeSum(n: nat) -> (s: nat)

-    ensures s ==Sum(n)

-{

+spec fn sum(n: nat) -> nat {

+    if n == 0 { 0 } else { n + sum(n - 1) }

 }

 

+pub fn compute_sum(n: nat) -> (s: nat)

+    ensures s == sum(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec.rs
+++ verus_specs/translations/atomizer_supported/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Carre(a: nat) -> (c: nat)

-    ensures c == a*a

+pub fn Carre(a: nat) -> (c: nat)

+    ensures(c == a * a)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec.rs
+++ verus_specs/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn C(n: nat) -> nat 

+{

+    if n == 0 { 1 } else { (4 * n - 2) * C((n-1) as nat) / (n + 1) }

+}

 

-verus! {

 

-fn calcC(n: nat) -> (res: nat)

+

+pub fn calcC(n: nat) -> (res: nat)

     ensures res == C(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec.rs
+++ verus_specs/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn find(a: Vec<int>, key: int) -> (index: int)

-    requires a.len() > 0;

-    ensures 0 <= index <= a.len();,

-            index < a.len() ==> a[index] == key;

+pub fn find(a: &[i32], key: i32) -> (index: usize)

+    requires(a.len() > 0)

+    ensures(index <= a.len())

+    ensures(index < a.len() ==> a[index] == key)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec.rs
@@ -1,14 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn calcSum(n: nat) -> nat 

+{   

+    n * (n - 1) / 2

+}

 

-verus! {

 

-fn sum(n: nat) -> (s: nat)

+pub fn sum(n: nat) -> (s: nat)

     ensures s == calcSum(n + 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec.rs
+++ verus_specs/translations/atomizer_supported/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec.rs
@@ -1,25 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isSorted(a: Vec<int>, from: nat, to: nat)

-  reads a

-  requires 0 <= from <= to <= a.Length

+

+pub fn insertionSort(a: &mut Vec<i32>)

+    requires(true)

+    ensures(isSorted(a, 0, a.len() as nat))

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

 {

-    forall i, j: : from <= i < j < to ==> a[i] <= a[j]

 }

 

 

+pub open spec fn isSorted(a: &Vec<i32>, from: nat, to: nat) -> bool

+    recommends 0 <= from <= to <= a.len()

+{

+    forall|i: nat, j: nat| from <= i < j < to ==> a[i as int] <= a[j as int]

+}

 

 

-

-

-method testInsertionSort() -> bool {

-    

+pub fn testInsertionSort()

+    requires(true)

+    ensures(true)

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec.rs
+++ verus_specs/translations/atomizer_supported/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn leq(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    ensures result <==> (a.len() <= b.len() and a[..] == b[..a.len()]) or (exists|k: int| 0 <= k < a.len() and k < b.len() and a[..k] == b[..k] and a[k] < b[k])

+pub fn leq(a: &[i32], b: &[i32]) -> bool

+    ensures(|result: bool| result <==> (a.len() <= b.len() && a[..] == b[..a.len()]) || (exists|k: usize| 0 <= k < a.len() && k < b.len() && a[..k] == b[..k] && a[k] < b[k]))

 {

 }

 

+pub fn testLeq()

+{

 }

================================================================================
Comparing translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec.rs
+++ verus_specs/translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec.rs
@@ -1,14 +1,8 @@
+spec fn F(n: nat) -> nat {

+    if n <= 2 { n } else { F(n - 1) + F(n - 3) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn calcF(n: nat) -> (res: nat)

+pub fn calcF(n: nat) -> (res: nat)

     ensures res == F(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec.rs
+++ verus_specs/translations/atomizer_supported/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec.rs
@@ -1,14 +1,8 @@
+spec fn R(n: nat) -> nat {

+    if n == 0 { 0 } else if R((n-1) as nat) > n { R((n-1) as nat) - n } else { R((n-1) as nat) + n }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn calcR(n: nat) -> (r: nat)

+pub fn calcR(n: nat) -> (r: nat)

     ensures r == R(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec.rs
@@ -1,14 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+spec fn potencia(x: nat, y: nat) -> nat

+    decreases y

 {

+    if y == 0 {

+        1

+    } else {

+        x * potencia(x, y - 1)

+    }

 }

 

+pub fn pot(x: nat, y: nat) -> (r: nat)

+    ensures r == potencia(x, y)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Par(n: int) -> bool {

+pub open spec fn Par(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn FazAlgo(a: int, b: int) -> x: int, y: int

-    requires a >= b and Par (a-b)

+

+pub fn FazAlgo(a: int, b: int) -> (x: int, y: int)

+    requires a >= b && Par(a - b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec.rs
@@ -1,14 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat {

+    if n < 2 {

+        n

+    } else {

+        fib(n - 2) + fib(n - 1)

+    }

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (x: nat)

-    ensures x == Fib(n)

+pub fn compute_fib(n: nat) -> (x: nat)

+    ensures x == fib(n)

 {

 }

 

+

+pub fn teste()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn buscar(a: Vec<int>, x: int) -> (r: int)

-    ensures r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x,

-            0 <= r < a.len() ==> a[r] == x

+pub fn buscar(a: &[int], x: int) -> (r: int)

+    ensures(r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x)

+    ensures(0 <= r < a.len() ==> a[r] == x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec.rs
@@ -1,14 +1,16 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn soma(a: &[nat], i: nat) -> nat

+    recommends i <= a.len()

+{

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + soma(a, i-1)

+    }

+}

 

-verus! {

-

-fn somatorio(a: Vec<nat>) -> (s: nat)

+pub fn somatorio(a: &[nat]) -> (s: nat)

     ensures s == soma(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec.rs
@@ -1,14 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fatorial(n: nat) -> (f: nat)

-    ensures f == Fat(n)

+spec fn fat(n: nat) -> nat

+    decreases n

 {

+    if n == 0 { 1 } else { n * fat(n - 1) }

 }

 

+pub fn fatorial(n: nat) -> (f: nat)

+    ensures f == fat(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec.rs
@@ -1,12 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputeFib(n: nat) -> (x: nat)

+spec fn Fib(n: nat) -> nat {

+    if n < 2 {

+        n

+    } else {

+        Fib((n - 2) as nat) + Fib((n - 1) as nat)

+    }

+}

+

+pub fn ComputeFib(n: nat) -> (x: nat)

     ensures x == Fib(n)

 {

 }


================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec.rs
@@ -1,14 +1,54 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+

+

+

+

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec.rs
+++ verus_specs/translations/atomizer_supported/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec.rs
@@ -1,13 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+

+spec fn Potencia(x: nat, y: nat) -> nat {

+    if y == 0 {

+        1

+    } else {

+        x * Potencia(x, y - 1)

+    }

+}

+

+

+pub fn Pot(x: nat, y: nat) -> (r: nat)

+    ensures r == Potencia(x, y)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec.rs
@@ -1,14 +1,8 @@
+spec fn f2(n: nat) -> nat {

+    if n == 0 { 0 } else { 5 * f2(n / 3) + n % 4 }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mod2(n: nat) -> (a: nat)

+pub fn mod2(n: nat) -> (a: nat)

     ensures a == f2(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mod(n: nat) -> (a: nat)

-    ensures a == f(n)

-{

+spec fn f(n: nat) -> nat {

+    if n == 0 { 1 }

+    else if n % 2 == 0 { 1 + 2 * f(n / 2) }

+    else { 2 * f(n / 2) }

 }

 

+

+pub fn mod_fn(n: nat) -> (a: nat)

+    ensures(a == f(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec.rs
@@ -1,14 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn pow(a: int, e: nat) -> int {

+    if e == 0 { 1 } else { a * pow(a, (e - 1) as nat) }

+}

 

-verus! {

 

-fn Pow(a: nat, n: nat) -> (y: nat)

+pub fn Pow(a: nat, n: nat) -> (y: nat)

     ensures y == pow(a, n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec.rs
@@ -1,14 +1,8 @@
+spec fn sum(n: nat) -> int {

+    if n == 0 { 0 } else { n + sum((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sum(n: nat) -> (s: int)

+pub fn Sum(n: nat) -> (s: int)

     ensures s == sum(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem2(p: int, q: int, X: int, Y: int) -> r: int, s: int

-    requires p == 2*X + Y and q == X + 3

-    ensures r == X and s == Y

+pub fn problem2(p: int, q: int, X: int, Y: int) -> (r: int, s: int)

+    requires(p == 2*X + Y && q == X + 3)

+    ensures(|result: (int, int)| result.0 == X && result.1 == Y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem3(m: int, X: int) -> (r: int)

-    requires X >= 0 and (2*m == 1 - X or m == X + 3)

-    ensures r == X

+pub fn problem3(m: int, X: int) -> (r: int)

+    requires

+        X >= 0 && (2*m == 1 - X || m == X + 3)

+    ensures

+        r == X

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec.rs
@@ -1,14 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn problem5(n: nat) -> (x: int)

-    ensures x == f(n)

-{

+

+

+

+

+

+

+

+

+spec fn f(n: int) -> int {

+    if n < 0 { 0 } else { 3 * f(n - 5) + n }

 }

 

+

+

+pub fn problem5(n: nat) -> (x: int)

+    ensures(x == f(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec.rs
+++ verus_specs/translations/atomizer_supported/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec.rs
@@ -1,14 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem6(n: nat) -> (a: int)

-    ensures a == fSum(n)

-{

+spec fn f(n: int) -> int {

+    if n <= 0 { 1 } else { n + f(n-1)*f(n-2) }

 }

 

+spec fn fSum(n: nat) -> int {

+    if n <= 0 { 0 } else { f(n-1) + fSum(n-1) }

+}

+

+pub fn problem6(n: nat) -> (a: int)

+    ensures(a == fSum(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec.rs
@@ -1,34 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted(a: Vec<int>, start: int, end: int)

- requires a!=null       

- requires 0<=start<=end<=a.Length       

- reads a       

- {           

-   forall j, k: : start<=j<k<end ==> a[j]<=a[k]

- }

+spec fn sorted(a: &[i32], start: int, end: int) -> bool

+    recommends

+        0 <= start <= end <= a.len(),

+{

+    forall|j: int, k: int| start <= j < k < end ==> a[j] <= a[k]

+}

 

-

-

-

-

-

-method InsertionSort (a:array<int>)

-requires a!=null && a.Length>1 

-ensures sorted(a, 0, a.Length) 

-modifies a

+pub fn insertion_sort(a: &mut Vec<i32>)

+    requires

+        a.len() > 1,

+    ensures

+        sorted(a, 0, a.len()),

 {

 }

-      

 

-method Main() -> bool {

-    

+pub fn main()

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec.rs
@@ -1,29 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn reversed(arr: Vec<char>, outarr: Vec<char>, outarr

-{

-  forall k: : 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]

+spec fn reversed(arr: &[char], outarr: &[char]) -> bool {

+    arr.len() == outarr.len() &&

+    forall|k: int| 0 <= k <= (arr.len() as int) - 1 ==> outarr[k] == arr[(arr.len() as int) - 1 - k]

 }

 

+pub fn yarra(arr: &[char]) -> (outarr: Vec<char>)

+    requires(arr.len() > 0)

+    ensures(arr.len() == outarr.len() && reversed(arr, &outarr))

+{

+    unimplemented!()

+}

 

-

-

-method yarra(arr : array<char>) returns (outarr : array<char>)

-requires arr != null && arr.Length > 0

-ensures outarr != null && arr.Length == outarr.Length && reversed(arr, outarr) -> bool {

+pub fn main() {

     

 }

 

-fn yarra(arr: Vec<char>) -> (outarr: Vec<char>)

-    requires arr != null and arr.len() > 0

-    ensures outarr != null and arr.len() == outarr.len() and reversed(arr,outarr)

-{

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec.rs
@@ -1,122 +1,55 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn SplitPoint(a: Vec<int>, n: int)

-    reads a

-    requires 0 <= n <= n

-

-{

-    forall i, j: : 0 <= i < n <= j < a.Length ==> a[i] <= a[j]

+spec fn split_point(a: &[int], n: int) -> bool {

+    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]

 }

 

-

-

-

-method SelectionSort(a: array<int>)

-    modifies a

-    ensures forall i, j: : 0 <= i < j < a.Length ==> a[i] <= a[j]

-    ensures multiset(a[..]) == old(multiset(a[..])) -> bool {

-    

-}

-spec fn SwapFrame(a: Vec<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+pub fn selection_sort(a: &mut [int])

+    ensures forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

+    ensures a@.to_multiset() == old(a)@.to_multiset(),

 {

 }

 

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

-{

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

-}

-

-

-

-method QuickSortAux(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi) -> bool {

-    

-}

-

-fn SelectionSort(a: Vec<int>, j: : 0 <= i < j < a.Length ==> a[i] <= a[j]

-    ensures multiset(a[..]) == old(multiset(a[..]))

+pub fn quick_sort(a: &mut [int])

+    ensures forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

+    ensures a@.to_multiset() == old(a)@.to_multiset(),

 {

 }

 

+spec fn swap_frame(a: &[int], old_a: &[int], lo: int, hi: int) -> bool

+    recommends 0 <= lo <= hi <= a.len()

+{

+    true

+}

 

+spec fn swap_frame_full(a: &[int], old_a: &[int], lo: int, hi: int) -> bool

+    recommends 0 <= lo <= hi <= a.len()

+{

+    (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) && 

+    a@.to_multiset() == old_a@.to_multiset()

+}

 

-

-method QuickSort(a: array<int>)

-    modifies a

-    ensures forall i, j: : 0 <= i < j < a.Length ==> a[i] <= a[j]

-    ensures multiset(a[..]) == old(multiset(a[..]))

+pub fn quick_sort_aux(a: &mut [int], lo: int, hi: int)

+    requires 0 <= lo <= hi <= a.len(),

+    requires split_point(a, lo) && split_point(a, hi),

+    ensures forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

+    ensures swap_frame_full(a, &old(a), lo, hi),

+    ensures split_point(a, lo) && split_point(a, hi),

 {

 }

 

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+pub fn partition(a: &mut [int], lo: int, hi: int) -> (p: int)

+    requires 0 <= lo < hi <= a.len(),

+    requires split_point(a, lo) && split_point(a, hi),

+    ensures lo <= p < hi,

+    ensures forall|i: int| lo <= i < p ==> a[i] < a[p as int],

+    ensures forall|i: int| p <= i < hi ==> a[p as int] <= a[i],

+    ensures split_point(a, lo) && split_point(a, hi),

+    ensures swap_frame_full(a, &old(a), lo, hi),

 {

-}

-

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

-{

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

-}

-

-

-

-method QuickSortAux(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi)

-{

-}

-

-

-

-

-method Partition(a: Vec<int>, lo: int, hi: int) -> (p: int)

-    requires 0 <= lo <= hi <= a.len()

-    reads a,

-             0 <= lo <= hi <= a.len()

-    reads a,

-             0 <= lo <= hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a,

-             0 <= lo < hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a

-    ensures forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            multiset(a[..]) == old(multiset(a[..])),

-            forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            multiset(a[..]) == old(multiset(a[..])),

-            forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

-            SwapFrame(a, lo, hi),

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            lo <= p < hi,

-            forall|i: int| lo <= i < p ==> a[i] < a[p],

-            forall|i: int| p <= i < hi ==> a[p] <= a[i],

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            SwapFrame(a, lo, hi)

-{

+    0

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec.rs
@@ -1,15 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Foo(y: int, x: int) -> (z: int)

-    requires 0 <= y

-    ensures z == x*y

+pub fn Foo(y: int, x: int) -> (z: int)

+    requires(0 <= y)

+    ensures(z == x*y)

 {

 }

 

+pub fn stringToSet(s: Seq<char>) -> (r: Set<char>)

+    ensures(forall|x: int| 0 <= x < s.len() ==> r.contains(s[x]))

+{

+}

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_BoatsToSavePeople_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_BoatsToSavePeople_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_BoatsToSavePeople_spec.rs
@@ -1,29 +1,49 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

+

+spec fn sumBoat(s: Seq<nat>) -> nat 

+    recommends 1 <= s.len() <= 2

+{

+    if s.len() == 1 { s[0] } else { s[0] + s[1] }

+}

+

+

 spec fn isSafeBoat(boat: Seq<nat>, limit: nat) -> bool {

-    1 <= boat.len() <= 2 and sumBoat(boat) <= limit

+    1 <= boat.len() <= 2 && sumBoat(boat) <= limit

 }

+

+

+spec fn multisetAdd(ss: Seq<Seq<nat>>) -> Multiset<nat> {

+    if ss == seq![] { 

+        multiset!{} 

+    } else { 

+        ss[0].to_multiset() + multisetAdd(ss.subrange(1, ss.len() as int))

+    }

+}

+

+

 spec fn multisetEqual(ss: Seq<Seq<nat>>, xs: Seq<nat>) -> bool {

-    multiset(xs) == multisetAdd(ss)

+    xs.to_multiset() == multisetAdd(ss)

 }

+

+

 spec fn allSafe(boats: Seq<Seq<nat>>, limit: nat) -> bool {

-    forall|boat: int| boat in boats ==> isSafeBoat(boat, limit)

+    forall|boat| boats.contains(boat) ==> isSafeBoat(boat, limit)

 }

+

+

 spec fn sorted(list: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < list.len() ==> list[i] <= list[j]

 }

 

-fn numRescueBoats(people: Seq<nat>, limit: nat) -> (boats: nat)

-    requires people.len() >= 1,

-             sorted(people),

-             forall i: nat :: i < people.len() ==> 1 <= people[i] <= limit

-    ensures exists boatConfig: seq<seq<nat>> :: multisetEqual(boatConfig, people) and allSafe(boatConfig, limit) and boats == boatConfig.len()

+

+pub fn numRescueBoats(people: Seq<nat>, limit: nat) -> (boats: nat)

+    requires(people.len() >= 1)

+    requires(sorted(people))

+    requires(forall|i: nat| i < people.len() ==> 1 <= people[i as int] <= limit)

+    ensures(exists|boatConfig: Seq<Seq<nat>>| multisetEqual(boatConfig, people) && allSafe(boatConfig, limit) && boats == boatConfig.len())

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn removeElement(nums: Vec<int>, val: int) -> (i: int)

-    ensures forall|k: int| 0 < k < i < nums.len() ==> nums[k] != val

-    modifies nums

+pub fn removeElement(nums: &mut Vec<i32>, val: i32) -> (i: i32)

+    ensures(

+        forall|k: usize| 0 < k < i < nums.len() ==> nums[k] != val

+    )

 {

 }

 

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec.rs
@@ -1,19 +1,69 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPath(paths: Seq<TreeNode>, root: TreeNode) -> bool {

-    if paths.len() == 0 then false else match paths[0] {

-        case Nil => false

-        case Cons(val, left, right) => if paths.len() == 1 then root == paths[0] else root == paths[0] and (isPath(paths[1..], left) or isPath(paths[1..], right))

+#[derive(PartialEq, Eq)]

+pub enum TreeNode {

+    Nil,

+    Cons { val: nat, left: Box<TreeNode>, right: Box<TreeNode> }

 }

 

-fn hasPathSum(root: TreeNode, targetSum: int) -> (b: bool)

-    ensures b ==> exists p: seq<TreeNode> :: isPath(p, root) and pathSum(p) == targetSum

+pub spec fn TreeSeq(root: TreeNode) -> Seq<TreeNode>

+    decreases root

+{

+    match root {

+        TreeNode::Nil => seq![TreeNode::Nil],

+        TreeNode::Cons { val, left, right } => seq![root] + TreeSeq(*left) + TreeSeq(*right)

+    }

+}

+

+pub spec fn TreeSet(root: TreeNode) -> Set<TreeNode>

+    decreases root

+{

+    match root {

+        TreeNode::Nil => set![TreeNode::Nil],

+        TreeNode::Cons { val, left, right } => TreeSet(*left) + set![root] + TreeSet(*right)

+    }

+}

+

+pub spec fn isPath(paths: Seq<TreeNode>, root: TreeNode) -> bool

+    decreases paths.len()

+{

+    if paths.len() == 0 {

+        false

+    } else {

+        match paths[0] {

+            TreeNode::Nil => false,

+            TreeNode::Cons { val, left, right } => {

+                if paths.len() == 1 {

+                    root == paths[0]

+                } else {

+                    root == paths[0] && (isPath(paths.subrange(1, paths.len() as int), *left) || isPath(paths.subrange(1, paths.len() as int), *right))

+                }

+            }

+        }

+    }

+}

+

+pub spec fn pathSum(paths: Seq<TreeNode>) -> nat

+    decreases paths.len()

+{

+    if paths.len() == 0 {

+        0

+    } else {

+        match paths[0] {

+            TreeNode::Nil => 0,

+            TreeNode::Cons { val, left, right } => val + pathSum(paths.subrange(1, paths.len() as int))

+        }

+    }

+}

+

+pub fn hasPathSum(root: TreeNode, targetSum: int) -> (b: bool)

+    ensures(b ==> exists|p: Seq<TreeNode>| isPath(p, root) && pathSum(p) == targetSum)

+{

+}

+

+pub fn Test()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec.rs
@@ -1,21 +1,144 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn stepEndsAt(xs: Seq<Steps>, n: nat) -> bool {

+#[derive(PartialEq, Eq)]

+pub enum Steps {

+    One,

+    Two,

+}

+

+pub spec fn stepSum(xs: Seq<Steps>) -> nat {

+    if xs.len() == 0 { 

+        0 

+    } else { 

+        (match xs[0] {

+            Steps::One => 1,

+            Steps::Two => 2,

+        }) + stepSum(xs.subrange(1, xs.len() as int))

+    }

+}

+

+pub open spec fn stepEndsAt(xs: Seq<Steps>, n: nat) -> bool {

     stepSum(xs) == n

 }

-spec fn allEndAtN(ss: set<seq<Steps> >, n: nat) -> bool {

-    forall|xs: int|  xs in ss ==> stepEndsAt(xs, n)

+

+pub open spec fn allEndAtN(ss: Set<Seq<Steps>>, n: nat) -> bool {

+    forall |xs| ss.contains(xs) ==> stepEndsAt(xs, n)

 }

 

-fn climbStairs(n: nat) -> (count: nat)

-    ensures exists ss: set< seq<Steps> > :: count == ss.len() and allEndAtN(ss, n)

+proof fn stepBaseZero() 

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 0) && ss.len() == 0

 {

 }

 

+proof fn stepBaseOne() 

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 1) && ss.len() == 1

+{

+}

+

+proof fn stepBaseTwo() 

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 2) && ss.len() == 2

+{

+}

+

+pub spec fn plusOne(x: Seq<Steps>) -> Seq<Steps> {

+    seq![Steps::One].add(x)

+}

+

+pub spec fn addOne(ss: Set<Seq<Steps>>) -> Set<Seq<Steps>>

+    ensures forall |x| ss.contains(x) ==> addOne(ss).contains(plusOne(x)),

+    ensures addOne(ss) == Set::new(|x| ss.contains(x)).map(|x| plusOne(x)),

+{

+    Set::new(|x| ss.contains(x)).map(|x| plusOne(x))

+}

+

+proof fn SeqsNotEqualImplication<T>(xs: Seq<T>, ys: Seq<T>, someT: T)

+    requires xs != ys

+    ensures (exists |i: nat| i < xs.len() && i < ys.len() && xs[i as int] != ys[i as int]) || xs.len() < ys.len() || ys.len() < xs.len()

+{

+}

+

+proof fn UnequalSeqs<T>(xs: Seq<T>, ys: Seq<T>, someT: T)

+    requires xs != ys

+    ensures seq![someT].add(xs) != seq![someT].add(ys)

+{

+}

+

+proof fn plusOneNotIn(ss: Set<Seq<Steps>>, x: Seq<Steps>)

+    requires !ss.contains(x)

+    ensures !addOne(ss).contains(plusOne(x))

+{

+}

+

+proof fn addOneSize(ss: Set<Seq<Steps>>)

+    ensures addOne(ss).len() == ss.len()

+{

+}

+

+proof fn addOneSum(ss: Set<Seq<Steps>>, sum: nat) 

+    requires allEndAtN(ss, sum)

+    ensures allEndAtN(addOne(ss), sum+1)

+{

+}

+

+proof fn endAtNPlus(ss: Set<Seq<Steps>>, sz: Set<Seq<Steps>>, sum: nat)

+    requires allEndAtN(ss, sum)

+    requires allEndAtN(sz, sum)

+    ensures allEndAtN(ss.union(sz), sum)

+{

+}

+

+pub spec fn plusTwo(x: Seq<Steps>) -> Seq<Steps> {

+    seq![Steps::Two].add(x)

+}

+

+pub spec fn addTwo(ss: Set<Seq<Steps>>) -> Set<Seq<Steps>>

+    ensures forall |x| ss.contains(x) ==> addTwo(ss).contains(plusTwo(x)),

+    ensures addTwo(ss) == Set::new(|x| ss.contains(x)).map(|x| plusTwo(x)),

+{

+    Set::new(|x| ss.contains(x)).map(|x| plusTwo(x))

+}

+

+proof fn plusTwoNotIn(ss: Set<Seq<Steps>>, x: Seq<Steps>)

+    requires !ss.contains(x)

+    ensures !addTwo(ss).contains(plusTwo(x))

+{

+}

+

+proof fn addTwoSize(ss: Set<Seq<Steps>>)

+    ensures addTwo(ss).len() == ss.len()

+{

+}

+

+proof fn addTwoSum(ss: Set<Seq<Steps>>, sum: nat) 

+    requires allEndAtN(ss, sum)

+    ensures allEndAtN(addTwo(ss), sum+2)

+{

+}

+

+proof fn setSizeAddition<T>(sx: Set<T>, sy: Set<T>, sz: Set<T>) 

+    requires sx.disjoint(sy)

+    requires sz == sx.union(sy)

+    ensures sx.union(sy).len() == sx.len() + sy.len()

+    ensures sz.len() == sx.len() + sy.len()

+{

+}

+

+proof fn stepSetsAdd(i: nat, steps: &[nat]) 

+    requires i >= 2

+    requires steps.len() >= i+1

+    requires forall |k: nat| k < i ==> exists |ss: Set<Seq<Steps>>| steps[k] == #[trigger] ss.len() && allEndAtN(ss, k)

+    ensures exists |sp: Set<Seq<Steps>>| sp.len() == steps[i-1] + steps[i-2] && allEndAtN(sp, i)

+{

+}

+

+pub fn climbStairs(n: nat) -> (count: nat)

+    ensures exists |ss: Set<Seq<Steps>>| count == ss.len() && allEndAtN(ss, n)

+{

+}

+

+pub fn Test() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec.rs
@@ -1,14 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn toMultiset(s: String) -> (mset: multiset<char>)

-    ensures multiset(s) == mset

+pub fn toMultiset(s: &str) -> Multiset<char>

+    ensures(multiset(s.view()) == result)

 {

 }

 

+pub fn msetEqual(s: Multiset<char>, t: Multiset<char>) -> bool

+    ensures(s == t <==> result)

+{

+}

+

+pub fn isAnagram(s: &str, t: &str) -> bool

+    ensures((multiset(s.view()) == multiset(t.view())) == result)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec.rs
@@ -1,17 +1,174 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

+

+

+

+spec fn eight(x: nat) -> nat {

+    9 * x + 5

+}

+

+

 

 spec fn isOdd(x: nat) -> bool {

     x % 2 == 1

 }

 

+

+

 spec fn isEven(x: nat) -> bool {

     x % 2 == 0

 }

 

+

+

+proof fn eightL(x: nat)

+    requires(isOdd(x))

+    ensures(isEven(eight(x)))

+{

+

+}

+

+

+

+spec fn nineteenf(x: nat) -> nat {

+    7*x+4

+}

+

+

+spec fn nineteens(x: nat) -> nat {

+    3*x+11

+}

+

+

+

+proof fn nineteenlemma(x: nat) 

+    requires(isEven(nineteenf(x)))

+    ensures(isOdd(nineteens(x)))

+{

+

+}

+

+

+

+spec fn relationDomain<T>(s: Set<(T,T)>) -> Set<T> {

+    set_choose(|z: (T,T)| s.contains(z), |z: (T,T)| z.0)

+}

+

+

+

+spec fn reflexive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    recommends(relationOnASet(R, S))

+{

+    forall|s: T| S.contains(s) ==> R.contains((s,s))

+}

+

+

+

+spec fn symmetric<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    recommends(relationOnASet(R, S))

+{

+    forall|x: T, y: T| S.contains(x) && S.contains(y) && R.contains((x,y)) ==> R.contains((y, x))

+}

+

+

+

+spec fn transitive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    recommends(relationOnASet(R, S))

+{

+    forall|a: T, b: T, c: T| S.contains(a) && S.contains(b) && S.contains(c) && R.contains((a,b)) && R.contains((b,c)) ==> R.contains((a,c))

+}

+

+

+

+spec fn equivalenceRelation<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    recommends(relationOnASet(R, S))

+{

+    reflexive(R, S) && symmetric(R, S) && transitive(R, S)

+}

+

+

+

+spec fn relationOnASet<T>(R: Set<(T,T)>, S: Set<T>) -> bool {

+    forall|ts: (T,T)| R.contains(ts) ==> S.contains(ts.0) && S.contains(ts.1)

+}

+

+

+

+proof fn reflexiveUnion<T>(R_1: Set<(T,T)>, S_1: Set<T>, R_2: Set<(T,T)>, S_2: Set<T>)

+    requires(R_1.len() > 0)

+    requires(R_2.len() > 0)

+    requires(S_1.len() > 0)

+    requires(S_2.len() > 0)

+    requires(relationOnASet(R_1, S_1))

+    requires(relationOnASet(R_2, S_2))

+    requires(reflexive(R_1, S_1))

+    requires(reflexive(R_2, S_2))

+    ensures(reflexive(R_1.union(R_2), S_1.union(S_2)))

+{

+

+}

+

+

+

+proof fn symmetricUnion<T>(R_1: Set<(T,T)>, S_1: Set<T>, R_2: Set<(T,T)>, S_2: Set<T>)

+    requires(R_1.len() > 0)

+    requires(R_2.len() > 0)

+    requires(S_1.len() > 0)

+    requires(S_2.len() > 0)

+    requires(relationOnASet(R_1, S_1))

+    requires(relationOnASet(R_2, S_2))

+    requires(symmetric(R_1, S_1))

+    requires(symmetric(R_2, S_2))

+    ensures(symmetric(R_1.union(R_2), S_1.union(S_2)))

+{

+

+}

+

+

+

+proof fn transitiveUnion<T>(R_1: Set<(T,T)>, S_1: Set<T>, R_2: Set<(T,T)>, S_2: Set<T>)

+    requires(R_1.len() > 0)

+    requires(R_2.len() > 0)

+    requires(S_1.len() > 0)

+    requires(S_2.len() > 0)

+    requires(relationOnASet(R_1, S_1))

+    requires(relationOnASet(R_2, S_2))

+    requires(transitive(R_1, S_1))

+    requires(transitive(R_2, S_2))

+    ensures(transitive(R_1.union(R_2), S_1.union(S_2)))

+{

+

+}

+

+

+

+proof fn transitiveUnionContra<T>() -> (R1: Set<(T, T)>, S1: Set<T>, R2: Set<(T, T)>, S2: Set<T>)

+    ensures(relationOnASet(R1, S1))

+    ensures(relationOnASet(R2, S2))

+    ensures(transitive(R1, S1))

+    ensures(transitive(R2, S2))

+    ensures(!transitive(R1.union(R2), S1.union(S2)))

+{

+

+}

+

+

+

+proof fn notTrueAlways<T>()

+    ensures(!(forall|S1: Set<T>, S2: Set<T>, R1: Set<(T,T)>, R2: Set<(T, T)>| 

+        relationOnASet(R1, S1) &&

+        relationOnASet(R2, S2) &&

+        transitive(R1, S1) &&

+        transitive(R2, S2) ==> transitive(R1.union(R2), S1.union(S2))))

+{

+

+}

+

+

+

+pub fn test() {

+

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn plus_one(x: int) -> (r: int)

-    requires x >= 0;

-    ensures r == x + 1;

+pub fn plus_one(x: int) -> (r: int)

+    requires(x >= 0)

+    ensures(r == x + 1)

 {

 }

 

+pub fn add_by_one(x: int, y: int) -> (r: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_by_one(x: int, y: int) -> (r: int)

-    requires y >= 0;

-    ensures r == x + y;

+pub fn add_by_one(x: int, y: int) -> (r: int)

+    requires(y >= 0)

+    ensures(r == x + y)

 {

 }

 

+pub fn bar(x: int, y: int) -> (r: int)

+    requires(y >= 0)

+    ensures(r == x + y)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMax(a: Vec<int>) -> (max: int)

-    requires a != null and a.len() > 0;

-    ensures 0 <= max < a.len();,

-            forall|x: int| 0 <= x < a.len() ==> a[max] >= a[x];

+pub fn find_max(a: &[int]) -> (max: usize)

+    requires(

+        a.len() > 0

+    )

+    ensures(|max: usize|

+        0 <= max < a.len() &&

+        forall|x: int| 0 <= x < a.len() ==> a[max] >= a[x]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalcProduct(m: nat, n: nat) -> (res: nat)

-    ensures res == m*n;

+pub fn calc_product(m: nat, n: nat) -> (res: nat)

+    ensures(res == m * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec.rs
@@ -1,14 +1,30 @@
+pub fn sum_up_to(n: nat) -> nat

+{

+    if n == 0 { 0 } else { sum_up_to((n - 1) as nat) + 1 }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumUpTo(n: nat) -> (r: nat)

-    ensures r == sum_up_to (n);

+pub fn SumUpTo(n: nat) -> nat

+    ensures(|result: nat| result == sum_up_to(n))

 {

 }

 

+pub fn total(a: Seq<nat>) -> nat

+{

+    if a.len() == 0 { 0 } else { total(a.subrange(0, a.len() - 1)) + a[a.len() - 1] }

+}

+

+proof fn total_lemma(a: Seq<nat>, i: nat)

+    requires(

+        a.len() > 0,

+        0 <= i < a.len()

+    )

+    ensures(

+        total(a.subrange(0, i)) + a[i] == total(a.subrange(0, i + 1))

+    )

+{

+}

+

+pub fn Total(a: Seq<nat>) -> nat

+    ensures(|result: nat| result == total(a.subrange(0, a.len())))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec.rs
@@ -1,13 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn AdditiveFactorial(n: nat) -> (u: nat)

-    ensures u == Factorial(n);

+spec fn factorial(n: nat) -> nat

+    decreases n

+{

+    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }

+}

+

+pub fn additive_factorial(n: nat) -> (u: nat)

+    ensures u == factorial(n)

+{

+}

+

+pub fn find(A: &mut Vec<int>, N: int, f: int)

+    requires 

+        A.len() == N,

+        0 <= f < N,

+    ensures

+        forall|p: int, q: int| 0 <= p <= f <= q < N ==> A[p] <= A[q]

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny4_Primes_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny4_Primes_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny4_Primes_spec.rs
@@ -1,24 +1,109 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsPrime(n: int) -> bool {

-    2 <= n and forall|m: int| 2 <= m < n ==> n % m != 0

+spec fn is_prime(n: int) -> bool {

+    2 <= n && forall|m: int| 2 <= m < n ==> n % m != 0

 }

 

-spec fn AllPrimes(s: set<int>, bound: int) -> bool {

-

-  (forall|x: int| x in s ==> IsPrime(x)) and

-

-  (forall|p: int| IsPrime(p) and p <= bound ==> p in s)

+proof fn always_more_primes(k: int)

+    ensures exists|p: int| k <= p && is_prime(p)

+{

+    todo!()

 }

 

-spec fn IsPrime_Alt(n: int) -> bool {

-    2 <= n and forall|m: int| 2 <= m < n and IsPrime(m) ==> n % m != 0

+proof fn no_finite_set_contains_all_primes(s: Set<int>)

+    ensures exists|p: int| is_prime(p) && !s.contains(p)

+{

+    todo!()

+}

+

+spec fn all_primes(s: Set<int>, bound: int) -> bool {

+    (forall|x: int| s.contains(x) ==> is_prime(x)) &&

+    (forall|p: int| is_prime(p) && p <= bound ==> s.contains(p))

+}

+

+proof fn get_larger_prime(s: Set<int>, bound: int) -> (p: int)

+    requires all_primes(s, bound)

+    ensures bound < p && is_prime(p)

+{

+    todo!()

+}

+

+spec fn product(s: Set<int>) -> int

+    decreases s.len()

+{

+    if s.len() == 0 { 1 } else {

+        let a = pick_largest(s);

+        a * product(s.remove(a))

+    }

+}

+

+proof fn product_property(s: Set<int>)

+    requires forall|x: int| s.contains(x) ==> 1 <= x

+    ensures 1 <= product(s) && forall|x: int| s.contains(x) ==> x <= product(s)

+{

+    todo!()

+}

+

+proof fn product_plus_one_is_prime(s: Set<int>, q: int)

+    requires all_primes(s, q) && q == product(s)

+    ensures is_prime(q + 1)

+{

+    todo!()

+}

+

+proof fn remove_factor(x: int, s: Set<int>)

+    requires s.contains(x)

+    ensures product(s) == x * product(s.remove(x))

+{

+    todo!()

+}

+

+spec fn is_prime_alt(n: int) -> bool {

+    2 <= n && forall|m: int| 2 <= m < n && is_prime(m) ==> n % m != 0

+}

+

+proof fn alt_prime_definition(n: int)

+    requires is_prime_alt(n)

+    ensures is_prime(n)

+{

+    todo!()

+}

+

+proof fn composite(c: int) -> (a: int, b: int)

+    requires 2 <= c && !is_prime(c)

+    ensures 2 <= a < c && 2 <= b && a * b == c

+    ensures is_prime(a)

+{

+    todo!()

+}

+

+spec fn pick_largest(s: Set<int>) -> int

+    requires s.len() != 0

+{

+    arbitrary()

+}

+

+proof fn largest_element_exists(s: Set<int>)

+    requires s.len() != 0

+    ensures exists|x: int| s.contains(x) && forall|y: int| s.contains(y) ==> y <= x

+{

+    todo!()

+}

+

+proof fn mul_pos(a: int, b: int)

+    requires 1 <= a && 1 <= b

+    ensures a <= a * b

+{

+    todo!()

+}

+

+proof fn mul_div_mod(a: nat, b: nat, c: nat, j: nat)

+    requires a * b == c && j < a

+    ensures (c + j) % a == j

+{

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny0_snapshots_Inputs_Snapshots1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny0_snapshots_Inputs_Snapshots1_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny0_snapshots_Inputs_Snapshots1_spec.rs
@@ -1,13 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P() -> bool {

-    false

+pub fn M()

+{

 }

 

+pub fn N()

+    ensures P()

+{

+}

+

+pub fn P() -> bool

+{

+    false

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(blood: Vec<int>, key: int) -> (index: int)

-    requires blood != null

-    ensures 0 <= index ==> index < blood.len() and blood[index] == key,

-            index < 0 ==> forall|k: int| 0 <= k < blood.len() ==> blood[k] != key

+pub fn Find(blood: &[int], key: int) -> (index: int)

+    requires(true)

+    ensures(|index: int| 0 <= index ==> index < blood.len() && blood[index] == key)

+    ensures(|index: int| index < 0 ==> forall|k: int| 0 <= k < blood.len() ==> blood[k] != key)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec.rs
+++ verus_specs/translations/atomizer_supported/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec.rs
@@ -1,14 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) -> (z: int)

-    ensures proveFunctionalPostcondition ==> z == if x > 101 then x-10 else 91;

+pub fn NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) -> z: int

+    ensures(proveFunctionalPostcondition ==> z == if x > 101 { x-10 } else { 91 })

 {

 }

 

+pub fn Gcd(x1: int, x2: int)

+    requires(1 <= x1 && 1 <= x2)

+{

+}

+

+pub fn Determinant(X: &mut [[int; M]; M], M: int) -> z: int

+    requires(1 <= M)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec.rs
@@ -1,15 +1,29 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn sumOdds(n: nat) -> (sum: nat)

-    requires n > 0;

-    ensures sum == n * n;

+pub fn sumOdds(n: nat) -> (sum: nat)

+    requires(n > 0)

+    ensures(sum == n * n)

 {

 }

 

+

+

+

+

+

+

+

+pub fn intDiv(n: int, d: int) -> (q: int, r: int)

+    requires(n >= d && n >= 0 && d > 0)

+    ensures((d*q)+r == n && 0 <= q <= n/2 && 0 <= r < d)

+{

+}

+

+

+

+pub fn intDivImpl(n: int, d: int) -> (q: int, r: int)

+    requires(n >= d && n >= 0 && d > 0)

+    ensures((d*q)+r == n && 0 <= q <= n/2 && 0 <= r < d)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec.rs
@@ -1,15 +1,80 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn fibIter(n: nat) -> (a: nat)

-    requires n > 0

-    ensures a == fib(n)

+

+spec fn fib(n: nat) -> nat

+{

+    if n < 2 { n } else { fib((n-2) as nat) + fib((n-1) as nat) }

+}

+

+

+

+pub fn fibIter(n: nat) -> (a: nat)

+    requires(n > 0)

+    ensures(a == fib(n))

 {

 }

 

-}
+

+

+

+

+

+

+

+spec fn fact(n: nat) -> nat

+{

+    if n == 0 { 1 } else { n * fact((n-1) as nat) }

+}

+

+

+

+pub fn factIter(n: nat) -> (a: nat)

+    requires(n >= 0)

+    ensures(a == fact(n))

+{

+}

+ 

+

+

+

+

+

+spec fn gcd(m: nat, n: nat) -> nat

+    requires(m > 0 && n > 0)

+{

+    if m == n { m }

+    else if m > n { gcd((m - n) as nat, n) }

+    else { gcd(m, (n - m) as nat) }

+}

+

+

+

+pub fn gcdI(m: int, n: int) -> (g: int)

+    requires(m > 0 && n > 0)

+    ensures(g == gcd(m, n))

+{

+}

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec.rs
@@ -1,15 +1,17 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn gcdI(m: int, n: int) -> (d: int)

-    requires m > 0 and n > 0

-    ensures d == gcd(m,n)

+spec fn gcd_prime(x: int, y: int) -> int

+    recommends x > 0 && y > 0

 {

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd_prime(y, x) }

 }

 

+

+

+pub fn gcdI(m: int, n: int) -> (d: int)

+    requires m > 0 && n > 0

+    ensures d == gcd(m, n)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec.rs
@@ -1,15 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn gcdI(m: int, n: int) -> (d: int)

-    requires m > 0 and n > 0

-    ensures d == gcd(m, n);

+spec fn gcd_prime(x: int, y: int) -> int

+    recommends x > 0 && y > 0

 {

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd_prime(y, x) }

 }

 

+

+pub fn gcdI(m: int, n: int) -> (d: int)

+    requires(m > 0 && n > 0)

+    ensures(|result: int| result == gcd(m, n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec.rs
@@ -1,38 +1,30 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted(a: Seq<int>) -> bool {

-    forall|i  0 < i < .len()a|: int| a[i-1] <= a[i]

-}

-

-fn swap(a: Vec<int>, i: nat, j: nat)

-    modifies a

-    requires a != null && a.Length > 0 && i < a.Length && j < a.Length

-    ensures a[i] == old(a[j])

-    ensures a[j] == old(a[i])

+pub fn swap(a: &mut [i32], i: usize, j: usize)

+    requires(

+        a.len() > 0 && i < a.len() && j < a.len()

+    )

+    ensures(|a_new: &mut [i32]|

+        a_new[i as int] == old(a)[j as int] &&

+        a_new[j as int] == old(a)[i as int]

+    )

 {

 }

 

-

-

-

-

-

-

-

-method FindMin(a: array<int>, lo: nat) -> (minIdx: nat)

-    requires a != null and a.len() > 0 and i < a.len() and j < a.len(),

-             a != null and a.len() > 0 and lo < a.len()

-    ensures a[i] == old(a[j]),

-            a[j] == old(a[i]),

-            lo <= minIdx < a.len(),

-            forall|x: int| lo <= x < a.len() ==> a[minIdx] <= a[x]

+pub fn FindMin(a: &[i32], lo: usize) -> usize

+    requires(

+        a.len() > 0 && lo < a.len()

+    )

+    ensures(|minIdx: usize|

+        lo <= minIdx && minIdx < a.len() &&

+        forall|x: usize| lo <= x && x < a.len() ==> a[minIdx as int] <= a[x as int]

+    )

 {

 }

 

+pub open spec fn sorted(a: Seq<i32>) -> bool

+{

+    forall|i: int| 0 < i < a.len() ==> a[i-1] <= a[i]

+}

+

+pub fn selectionSort(a: &mut [i32])

+{

 }

================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec.rs
@@ -1,14 +1,177 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn square0(n: nat) -> (sqn: nat)

-    ensures sqn == n*n

+pub fn square0(n: nat) -> (sqn: nat)

+    ensures(sqn == n*n)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn square1(n: nat) -> (sqn: nat)

+    ensures(sqn == n*n)

+{

+}

+

+

+

+

+

+

+

+

+

+

+pub fn q(x: nat, y: nat) -> (z: nat)

+    requires(y - x > 2)

+    ensures(x < z*z < y)

+{

+}

+

+

+

+pub fn strange()

+    ensures(1==2)

+{

+}

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn test0()

+{

+}

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec.rs
+++ verus_specs/translations/atomizer_supported/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec.rs
@@ -1,15 +1,76 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Gauss(n: int) -> (sum: int)

-    requires n >= 0

-    ensures sum == n*(n+1)/2

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn Gauss(n: int) -> sum: int

+    requires(n >= 0)

+    ensures(sum == n*(n+1)/2)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn sumOdds(n: nat) -> sum: nat

+    ensures(sum == n*n)

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec.rs
+++ verus_specs/translations/atomizer_supported/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec.rs
@@ -1,15 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn peasantMult(a: int, b: int) -> (r: int)

+proof fn peasant_mult_lemma(a: int, b: int)

+    requires b >= 0

+    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)

+    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)

+{

+}

+

+pub fn peasant_mult(a: int, b: int) -> (r: int)

     requires b > 0

     ensures r == a * b

 {

 }

 

+pub fn euclidian_div(a: int, b: int) -> (q: int, r: int)

+    requires a >= 0

+    requires b > 0

+    ensures a == b * q + r

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec.rs
@@ -1,15 +1,76 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn copyArr(a: Vec<int>, l: int, r: int) -> (ret: Vec<int>)

-    requires 0 <= l < r <= a.len()

-    ensures ret[..] == a[l..r]

+

+spec fn sorted(s: Seq<int>) -> bool {

+    forall|k1: int, k2: int| 0 <= k1 <= k2 < s.len() ==> s[k1] <= s[k2]

+}

+

+

+

+

+

+

+

+pub fn copyArr(a: &[int], l: int, r: int) -> (ret: Vec<int>)

+    requires(

+        0 <= l < r <= a.len()

+    )

+    ensures(|ret: Vec<int>|

+        ret@ == a@.subrange(l as int, r as int)

+    )

 {

+    unimplemented!()

+}

+

+

+

+

+

+

+

+pub fn mergeArr(a: &mut Vec<int>, l: int, m: int, r: int)

+    requires(

+        0 <= l < m < r <= old(a).len(),

+        sorted(old(a)@.subrange(l as int, m as int)) && sorted(old(a)@.subrange(m as int, r as int))

+    )

+    ensures(

+        sorted(a@.subrange(l as int, r as int)),

+        a@.subrange(0, l as int) == old(a)@.subrange(0, l as int),

+        a@.subrange(r as int, a.len() as int) == old(a)@.subrange(r as int, old(a).len() as int)

+    )

+{

+    unimplemented!()

+}

+

+

+

+

+

+

+

+pub fn sort(a: &mut Vec<int>)

+    ensures(

+        sorted(a@)

+    )

+{

+    unimplemented!()

+}

+

+

+

+pub fn sortAux(a: &mut Vec<int>, l: int, r: int)

+    requires(

+        0 <= l < r <= old(a).len()

+    )

+    ensures(

+        sorted(a@.subrange(l as int, r as int)),

+        a@.subrange(0, l as int) == old(a)@.subrange(0, l as int),

+        a@.subrange(r as int, a.len() as int) == old(a)@.subrange(r as int, old(a).len() as int)

+    )

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec.rs
@@ -1,20 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StringSwap(s: String, i: nat, j: nat) -> (t: String)

-    requires i >= 0 and j >= 0 and s.len() >= 0;,

-             s.len() > 0 ==> i < s.len() and j < s.len();

-    ensures multiset(s[..]) == multiset(t[..]);,

-            s.len() == t.len();,

-            s.len() > 0 ==> forall k:nat :: k != i and k != j and k < s.len() ==> t[k] == s[k],

-            s.len() > 0 ==> t[i] == s[j] and t[j] == s[i];,

-            s.len() == 0 ==> t == s;

+pub fn string_swap(s: &str, i: usize, j: usize) -> (t: String)

+    requires(

+        i >= 0 && j >= 0 && s.len() >= 0

+    )

+    requires(

+        s.len() > 0 ==> i < s.len() && j < s.len()

+    )

+    ensures(|t: String|

+        multiset(s@) == multiset(t@) &&

+        s.len() == t.len() &&

+        (s.len() > 0 ==> forall|k: usize| k != i && k != j && k < s.len() ==> t[k] == s[k]) &&

+        (s.len() > 0 ==> t[i] == s[j] && t[j] == s[i]) &&

+        (s.len() == 0 ==> t@ == s@)

+    )

 {

+    unimplemented!()

 }

 

+pub fn check() {

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec.rs
@@ -1,43 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Sorted(a: String, low: int, high: int)

-requires 0 <= low <= high <= |a|

-{ 

-    forall j, k: : low <= j < k < high ==> a[j] <= a[k] 

+pub spec fn sorted(a: Seq<char>, low: int, high: int) -> bool

+{

+    &&& 0 <= low <= high <= a.len()

+    &&& forall|j: int, k: int| low <= j < k < high ==> a[j] <= a[k]

 }

 

-

-

-

-method String3Sort(a: string) returns (b: string) 

-requires |a| == 3;

-ensures Sorted(b, 0, |b|);

-ensures |a| == |b|;

-ensures multiset{

-}

-

-{

-}

- == multiset{a[0], a[1], a[2]};

-

-{

-    b: = a;

-    if (b[0] > b[1]) -> bool {

-    b := b[0 := b[1]][1 := b[0]];

-}

-

-fn String3Sort(a: String) -> (b: String)

-    requires a.len() == 3;

-    ensures Sorted(b, 0, b.len());,

-            a.len() == b.len();,

-            multiset

+pub fn string3_sort(a: Seq<char>) -> (b: Seq<char>)

+    requires(a.len() == 3)

+    ensures(sorted(b, 0, b.len()))

+    ensures(a.len() == b.len())

+    ensures(multiset![b[0], b[1], b[2]] == multiset![a[0], a[1], a[2]])

 {

 }

 

+pub fn check()

+{

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Getmini(a: Vec<int>) -> (mini: nat)

+pub fn Getmini(a: &[i32]) -> usize

     requires a.len() > 0

-    ensures 0 <= mini < a.len()

-            forall|x: int| 0 <= x < a.len() ==> a[mini] <= a[x]

-            forall|x: int| 0 <= x < mini ==> a[mini] < a[x]

+    ensures |mini: usize| 0 <= mini < a.len()

+    ensures |mini: usize| forall |x: usize| 0 <= x < a.len() ==> a[mini] <= a[x]

+    ensures |mini: usize| forall |x: usize| 0 <= x < mini ==> a[mini] < a[x]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec.rs
@@ -1,15 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Symmetric(a: Vec<int>) -> (flag: bool)

-    ensures flag == true ==> forall|x: int| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1],

-            flag == false ==> exists|x: int| 0 <= x < a.len() and a[x] != a[a.len() - x - 1]

+pub fn symmetric(a: &[i32]) -> (flag: bool)

+    ensures(

+        flag == true ==> forall|x: usize| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1]

+    )

+    ensures(

+        flag == false ==> exists|x: usize| 0 <= x < a.len() && a[x] != a[a.len() - x - 1]

+    )

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec.rs
@@ -1,15 +1,30 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn sum(s: Vec<int>) -> (a: int)

-    requires s.len() > 0

-    ensures sumcheck(s, s.len()) == a

+

+

+

+spec fn sumcheck(s: &[int], i: int) -> int

+    recommends 0 <= i <= s.len()

+{

+    if i == 0 { 0 }

+    else { s[i - 1] + sumcheck(s, i - 1) }

+}

+

+

+

+

+

+pub fn sum(s: &[int]) -> (a: int)

+    requires(s.len() > 0)

+    ensures(sumcheck(s, s.len() as int) == a)

 {

 }

 

+

+

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec.rs
@@ -1,16 +1,18 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(s: Vec<nat>) -> (a: int)

-    requires s.len() > 0

-    ensures forall|x: int| 0 <= x < s.len() ==> a >= s[x],

-            a in s[..]

+pub fn maxcheck(s: &[nat], i: int, max: int) -> int

+    requires 0 <= i <= s.len()

 {

 }

 

+

+pub fn max(s: &[nat]) -> int

+    requires s.len() > 0

+    ensures |result: int| forall|x: int| 0 <= x < s.len() ==> result >= s[x]

+    ensures |result: int| exists|i: int| 0 <= i < s.len() && result == s[i]

+{

+}

+

+

+pub fn Checker()

+{

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firste(a: Vec<char>) -> (c: int)

-    ensures -1 <= c < a.len(),

-            0 <= c < a.len() ==> a[c] == 'e' and forall|x: int| 0 <= x < c ==> a[x] != 'e',

-            c == -1 ==> forall|x: int| 0 <= x < a.len() ==> a[x] != 'e'

+pub fn firste(a: &[char]) -> (c: i32)

+    requires(

+        true

+    )

+    ensures(|c: i32|

+        -1 <= c && c < a.len() as i32 &&

+        (0 <= c && c < a.len() as i32 ==> a[c as usize] == 'e' && forall|x: usize| 0 <= x && x < c as usize ==> a[x] != 'e') &&

+        (c == -1 ==> forall|x: usize| 0 <= x && x < a.len() ==> a[x] != 'e')

+    )

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_p1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_p1_spec.rs
+++ verus_specs/translations/atomizer_supported/SENG2011_tmp_tmpgk5jq85q_p1_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|x: int| 0 <= x < a.len() ==> b[x] == a[a.len() - x - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|x: usize| 0 <= x < a.len() ==> result[x] == a[a.len() - x - 1])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn best_time_to_buy_and_sell_stock(prices: Vec<int>) -> (max_profit: int)

-    requires 1 <= prices.len() <= 100000,

-             forall|i: int| 0 <= i < prices.len() ==> 0 <= prices[i] <= 10000

-    ensures forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= prices[j] - prices[i]

+pub fn best_time_to_buy_and_sell_stock(prices: &[i32]) -> (max_profit: i32)

+    requires(1 <= prices.len() <= 100000)

+    requires(forall|i: int| 0 <= i < prices.len() ==> 0 <= prices[i] <= 10000)

+    ensures(|max_profit: i32| forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= prices[j] - prices[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec.rs
@@ -1,20 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

+

+pub fn contains_duplicate(nums: Seq<int>) -> (result: bool)

+    requires

+        1 <= nums.len() <= 100000,

+        forall|i: int| 0 <= i < nums.len() ==> -1000000000 <= nums[i] <= 1000000000,

+    ensures

+        result <==> distinct(nums),

+{

+}

 

 spec fn distinct(nums: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] != nums[j]

 }

 

-fn contains_duplicate(nums: Seq<int>) -> (result: bool)

-    requires 1 <= nums.len() <= 100000,

-             forall|i: int| 0 <= i < nums.len() ==> -1000000000 <= nums[i] <= 1000000000

-    ensures result <==> distinct(nums)

-{

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn counting_bits(n: int) -> (result: Vec<int>)

-    requires 0 <= n <= 100000

-    ensures result.len() == n + 1,

-            forall|i: int| 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2

+pub fn counting_bits(n: int) -> (result: Vec<int>)

+    requires(0 <= n <= 100000)

+    ensures(result.len() == n + 1)

+    ensures(forall|i: int| 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec.rs
@@ -1,18 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn longest_increasing_subsequence(nums: Vec<int>) -> (max: int)

-    requires 1 <= nums.len() <= 2500,

-             forall|i: int| 0 <= i < nums.len() ==> -10000 <= nums[i] <= 10000

-

-    ensures clause so that max is indeed equal to the longest increasing subsequence,

-            max >= 1

+pub fn longest_increasing_subsequence(nums: &[i32]) -> (max: i32)

+    requires(

+        1 <= nums.len() <= 2500,

+        forall|i: int| 0 <= i < nums.len() ==> -10000 <= nums[i as int] <= 10000,

+    )

+    ensures(|max: i32| max >= 1)

 {

 }

 

+pub fn find_max(x: i32, y: i32) -> (result: i32)

+    ensures(|result: i32| result == if x > y { x } else { y })

+{

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec.rs
@@ -1,43 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn non_overlapping_intervals(intervals: array2<int>) -> count: int)

-    modifies intervals

-    requires 1 <= intervals.Length0 <= 100000

-    requires intervals.Length1 == 2

-    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000

-    requires forall i: : 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000

-

-    ensures count >= 0

+pub fn non_overlapping_intervals(intervals: &mut [[i32; 2]]) -> i32

+    requires(

+        1 <= intervals.len() <= 100000,

+        forall|i: usize| 0 <= i < intervals.len() ==> -50000 <= intervals[i][0] <= 50000,

+        forall|i: usize| 0 <= i < intervals.len() ==> -50000 <= intervals[i][1] <= 50000,

+    )

+    ensures(|count: i32| count >= 0)

 {

 }

 

-

-

-

-

-

-

-

-method bubble_sort(a: array2<int>)

-    modifies a

-    requires a.Length1 == 2

-    ensures sorted(a, 0, a.Length0 - 1

-    requires 1 <= intervals.Length0 <= 100000,

-             intervals.Length1 == 2,

-             forall|i: int| 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000,

-             forall|i: int| 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000

-

-             a.Length1 == 2

-    ensures clause so that count is indeed equal to the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping.,

-            count >= 0,

-            sorted(a, 0, a.Length0 - 1)

+pub fn bubble_sort(a: &mut [[i32; 2]])

+    requires(true)

+    ensures(sorted(a, 0, a.len() as i32 - 1))

 {

 }

 

+pub open spec fn sorted(a: &[[i32; 2]], l: i32, u: i32) -> bool {

+    forall|i: i32, j: i32| 0 <= l <= i <= j <= u < a.len() ==> a[i as usize][1] <= a[j as usize][1]

+}

+

+pub open spec fn partitioned(a: &[[i32; 2]], i: i32) -> bool {

+    forall|k: i32, k_prime: i32| 0 <= k <= i < k_prime < a.len() ==> a[k as usize][1] <= a[k_prime as usize][1]

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec.rs
@@ -1,25 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn is_sorted(nums: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

-}

-spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]

-}

-

-fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)

-    requires is_sorted(nums),

-             1 <= nums.len() <= 30000,

-             forall|i: int| 0 <= i < nums.len() ==> -100 <= nums[i] <= 100

-    ensures is_sorted_and_distinct(result),

-            forall|i: int| i in nums <==> i in result

+pub fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)

+    requires(is_sorted(nums))

+    requires(1 <= nums.len() <= 30000)

+    requires(forall|i: int| 0 <= i < nums.len() ==> -100 <= nums[i] <= 100)

+    ensures(is_sorted_and_distinct(result))

+    ensures(forall|i: int| nums.contains(i) <==> result.contains(i))

 {

 }

 

+spec fn is_sorted(nums: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

+}

+

+spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]

 }

================================================================================
Comparing translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn isPalindrome(s: Vec<char>) -> (result: bool)

-    requires 1<= s.len() <= 200000

-    ensures result <==> (forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i])

+pub fn isPalindrome(s: &[char]) -> (result: bool)

+    requires(1 <= s.len() <= 200000)

+    ensures(result <==> (forall|i: usize| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec.rs
@@ -1,13 +1,111 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn factImp(n: int) -> (r: int)

+pub fn factImp(n: int) -> (r: int)

 {

 }

 

-}
+

+spec fn power(n: int, m: nat) -> int {

+  if m==0 { 1 } else { n*power(n,m-1) }

+}

+

+

+spec fn pow(n: int, m: nat, r: int) -> int {

+  if m==0 { r } else { pow(n,m-1,r*n) }

+}

+

+

+spec fn powerAlt(n: int, m: nat) -> int {

+  pow(n,m,1)

+}

+

+

+

+

+

+

+

+spec fn equivalentes(n: int, m: nat, r: int) -> int

+  ensures power(n,m) == pow(n,m,r)

+

+

+proof fn l1(n: int, m: nat, r: int)

+  ensures equivalentes(n,m, r) == powerAlt(n,m)

+

+

+

+

+

+spec fn fact(n: nat) -> nat

+{

+  if n==0 { 1 } else { n*fact(n-1) }

+}

+

+

+spec fn factAcc(n: nat, a: int) -> int

+{

+  if (n == 0) { a } else { factAcc(n-1,n*a) }

+}

+

+

+spec fn factAlt(n: nat) -> int { factAcc(n,1) }

+

+

+proof fn factAcc_correct(n: nat, a: int)

+  ensures factAcc(n,a) == fact(n)*a

+

+

+proof fn equiv(n: nat)

+  ensures fact(n) == factAlt(n) {

+  factAcc_correct(n, 1);

+}

+

+

+

+

+

+spec fn mystery1(n: nat, m: nat) -> nat

+  ensures mystery1(n,m) == n+m

+{ if n==0 { m } else { mystery1(n-1,m+1) } }

+

+

+

+

+

+spec fn mystery2(n: nat, m: nat) -> nat

+  ensures mystery2(n,m) == n+m

+{ if m==0 { n } else { mystery2(n+1,m-1) } }

+

+

+

+

+

+spec fn mystery3(n: nat, m: nat) -> nat

+  ensures mystery3(n,m) == n*m

+{ if n==0 { 0 } else { mystery1(m,mystery3(n-1,m)) } }

+

+

+

+

+

+spec fn mystery4(n: nat, m: nat) -> nat

+  ensures mystery4(n,m) == power(n,m)

+{ if m==0 { 1 } else { mystery3(n,mystery4(n,m-1)) } }

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec.rs
@@ -1,15 +1,41 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: int, b: int) -> (z: int)

-    requires true

-    ensures z >= a or z >= b

+pub fn max(a: int, b: int) -> z: int

+    requires(true)

+    ensures(z >= a || z >= b)

 {

 }

 

+pub fn Main()

+{

+}

+

+pub fn mystery1(n: nat, m: nat) -> res: nat

+    ensures(n + m == res)

+{

+}

+

+pub fn mystery2(n: nat, m: nat) -> res: nat

+    ensures(n * m == res)

+{

+}

+

+pub fn m1(x: int, y: int) -> z: int

+    requires(0 < x < y)

+    ensures(z >= 0 && z < y && z != x)

+{

+}

+

+pub fn m2(x: nat) -> y: int

+    requires(x <= -1)

+    ensures(y > x && y < x)

+{

+}

+

+pub fn m3(x: int, y: int) -> z: bool

+    ensures(z ==> x == y)

+{

+}

+

+pub fn m4(x: int, y: int) -> z: bool

+    ensures(z ==> x == y && x == y ==> z)

+{

 }

================================================================================
Comparing translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec.rs
@@ -1,14 +1,68 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat

+{

+  if n == 0 { 1 } else

+  if n == 1 { 1 } else { fib((n-1) as nat) + fib((n-2) as nat) }

+}

 

-verus! {

 

-fn Fib(n: nat) -> (r: nat)

-    ensures r == fib(n)

+pub fn Fib(n: nat) -> (r: nat)

+    ensures(r == fib(n))

 {

 }

 

+

+

+

+pub enum List<T> {

+    Nil,

+    Cons { head: T, tail: Box<List<T>> }

+}

+

+

+spec fn add(l: List<int>) -> int {

+    match l {

+        List::Nil => 0,

+        List::Cons { head: x, tail: xs } => x + add(*xs)

+    }

+}

+

+

+pub fn addImp(l: List<int>) -> (r: int)

+    ensures(r == add(l))

+{

+}

+

+

+

+

+pub fn maxArray(arr: &[int]) -> (max: int)

+    requires(arr.len() > 0)

+    ensures(forall|i: int| 0 <= i < arr.len() ==> arr[i as usize] <= max)

+    ensures(exists|x: int| 0 <= x < arr.len() && arr[x as usize] == max)

+{

+}

+

+

+

+

+pub fn maxArrayReverse(arr: &[int]) -> (max: int)

+    requires(arr.len() > 0)

+    ensures(forall|i: int| 0 <= i < arr.len() ==> arr[i as usize] <= max)

+    ensures(exists|x: int| 0 <= x < arr.len() && arr[x as usize] == max)

+{

+}

+

+

+

+

+spec fn sum(n: nat) -> nat

+{

+    if n == 0 { 0 } else { n + sum((n-1) as nat) }

+}

+

+

+pub fn sumBackwards(n: nat) -> (r: nat)

+    ensures(r == sum(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec.rs
+++ verus_specs/translations/atomizer_supported/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec.rs
@@ -1,15 +1,54 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn query(a: Vec<int>, i: int, j: int) -> (res: int)

+spec fn sum(a: &[i32], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

+{

+    if i == j { 0 } else { a[j-1] + sum(a, i, j-1) }

+}

+

+pub fn query(a: &[i32], i: usize, j: usize) -> (res: i32)

     requires 0 <= i <= j <= a.len()

-    ensures res == sum(a, i, j)

+    ensures res == sum(a, i as int, j as int)

 {

 }

 

+pub fn queryFast(a: &[i32], c: &[i32], i: usize, j: usize) -> (r: i32)

+    requires 0 <= i <= j <= a.len()

+    requires is_prefix_sum_for(a, c)

+    ensures r == sum(a, i as int, j as int)

+{

+}

+

+spec fn is_prefix_sum_for(a: &[i32], c: &[i32]) -> bool

+{

+    a.len() + 1 == c.len() && forall|i: int| 0 <= i <= a.len() ==> c[i] == sum(a, 0, i)

+}

+

+proof fn proof(a: &[i32], i: int, j: int, k: int)

+    requires 0 <= i <= k <= j <= a.len()

+    ensures sum(a, i, k) + sum(a, k, j) == sum(a, i, j)

+{

+}

+

+enum List<T> {

+    Nil,

+    Cons { head: T, tail: Box<List<T>> }

+}

+

+pub fn from_array<T>(a: &[T]) -> (l: List<T>)

+    ensures forall|i: int| 0 <= i < a.len() ==> mem(a[i], l)

+    ensures forall|x: T| mem(x, l) ==> exists|y: int| 0 <= y < a.len() && a[y] == x

+{

+}

+

+spec fn mem<T>(x: T, l: List<T>) -> bool

+{

+    match l {

+        List::Nil => false,

+        List::Cons { head: h, tail: t } => h == x || mem(x, *t)

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec.rs
+++ verus_specs/translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec.rs
@@ -1,28 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn div_ent_it(a: int, b: int) -> c: int, r: int)

-

-

-

-

-    requires a >= 0 && b > 0

-    ensures  a == b*c + r && 0 <= r < b

+pub fn div_ent_it(a: int, b: int) -> (c: int, r: int)

+    requires(a >= 0 && b > 0)

+    ensures(|result: (int, int)| a == b * result.0 + result.1 && 0 <= result.1 < b)

 {

 }

 

-

-

-

-method Main(

-    requires a >= 0 and b > 0

-    ensures a == b*c + r and 0 <= r < b

+pub fn Main()

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec.rs
+++ verus_specs/translations/atomizer_supported/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec.rs
@@ -1,19 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn suma_it(V: Vec<int>) -> x: int)

-

-

-

-

-    ensures  x == suma_vector(V, 0

+pub fn suma_it(V: &[i32]) -> (x: i32)

     ensures x == suma_vector(V, 0)

 {

 }

 

+pub open spec fn suma_vector(V: &[i32], n: nat) -> i32

+    recommends 0 <= n <= V.len()

+{

+    if n == V.len() { 0 } else { V[n as int] + suma_vector(V, n + 1) }

+}

+

+pub fn Main()

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec.rs
+++ verus_specs/translations/atomizer_supported/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec.rs
@@ -1,34 +1,53 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn merged(a1: Seq<int>, a2: Seq<int>, b: Vec<int>, start: int, end: int)

-  reads b

-  requires end - start  == |a2| + |a1|

-  requires 0 <= start <= end <= b.Length

+pub fn mergeSimple(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Array<int>)

+    requires(

+        sorted_seq(a1),

+        sorted_seq(a2),

+        0 <= start <= end <= b.len(),

+        a1.len() + a2.len() == end - start + 1,

+    )

+    ensures(

+        sorted_slice(b, start, end),

+    )

 {

-  multiset(a1) + multiset(a2) == multiset(b[start..end])

 }

 

-

-

-

-predicate sorted_slice(a: array<int>, start: int, end: int)

-  requires 0 <= start <= end <= a.Length

-  reads a

+pub fn merge(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Array<int>)

+    requires(

+        sorted_seq(a1),

+        sorted_seq(a2),

+        end - start == a1.len() + a2.len(),

+        0 <= start < end < a1.len() && end <= a2.len() < b.len(),

+        end < a1.len() && end < a2.len(),

+        b.len() == a2.len() + a1.len(),

+    )

+    ensures(

+        sorted_slice(b, start, end),

+        merged(a1, a2, b, start, end),

+    )

 {

-  forall i, j: : start <= i <= j < end ==> a[i] <= a[j]

 }

 

+pub closed spec fn merged(a1: Seq<int>, a2: Seq<int>, b: &Array<int>, start: int, end: int) -> bool

+    recommends(

+        end - start == a2.len() + a1.len(),

+        0 <= start <= end <= b.len(),

+    )

+{

+    a1.to_multiset() + a2.to_multiset() == b.subrange(start, end).to_multiset()

+}

 

+pub closed spec fn sorted_slice(a: &Array<int>, start: int, end: int) -> bool

+    recommends(0 <= start <= end <= a.len())

+{

+    forall|i: int, j: int| start <= i <= j < end ==> a[i] <= a[j]

+}

 

-

-predicate sorted_seq(a: seq<int>) -> bool {

+pub closed spec fn sorted_seq(a: Seq<int>) -> bool

+{

     forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]

 }

 

+pub closed spec fn sorted(a: &Array<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

 }

================================================================================
Comparing translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec.rs
+++ verus_specs/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>) -> (max: int)

-    requires a != null;

-    ensures forall|j: int| j >= 0 and j < a.len() ==> max >= a[j];

-            a.len() > 0 ==> exists|j: int| j >= 0 and j < a.len() and max == a[j];

+pub fn max(a: &[int]) -> (max: int)

+    requires(a.len() > 0)

+    ensures(|max: int| forall|j: usize| j < a.len() ==> max >= a[j])

+    ensures(|max: int| exists|j: usize| j < a.len() && max == a[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec.rs
+++ verus_specs/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn sum_array(a: Vec<int>) -> (sum: int)

-    requires a != null;

-    ensures sum == sumTo(a, a.len());

+spec fn sumTo(a: &[int], n: int) -> int

+    requires 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else { sumTo(a, n-1) + a[n-1] }

 }

 

+

+pub fn sum_array(a: &[int]) -> (sum: int)

+    ensures(sum == sumTo(a, a.len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec.rs
+++ verus_specs/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TriangleNumber(N: int) -> (t: int)

-    requires N >= 0

-    ensures t == N * (N + 1) / 2

+pub fn triangle_number(n: int) -> (t: int)

+    requires(n >= 0)

+    ensures(t == n * (n + 1) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec.rs
+++ verus_specs/translations/atomizer_supported/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arrayUpToN(n: int) -> (a: Vec<int>)

-    requires n >= 0

-    ensures a.len() == n,

-            forall|j: int| 0 < j < n ==> a[j] >= 0,

-            forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]

+pub fn arrayUpToN(n: int) -> (a: Vec<int>)

+    requires(n >= 0)

+    ensures(a.len() == n)

+    ensures(forall|j: int| 0 < j < n ==> a[j] >= 0)

+    ensures(forall|j: int, k: int| 0 <= j <= k < n ==> a[j] <= a[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec.rs
+++ verus_specs/translations/atomizer_supported/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec.rs
@@ -1,56 +1,85 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Sorted(q: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

-}

-spec fn HasAddends(q: Seq<int>, x: int) -> bool {

-    exists|i: int, j: int| 0 <= i < j < q.len() and q[i] + q[j] == x

-}

-spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat)

-	requires IsValidIndex(q, i) && IsValidIndex(q, j) -> bool {

-    q[i] + q[j] == x

-}

-spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat)

-	requires AreOreredIndices(q, i, j) -> bool {

-    HasAddends(q[i..(j + 1)], x)

-}

-spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

-    AreOreredIndices(q, i, j) and

-	HasAddendsInIndicesRange(q, x, i, j) and

-	AreAddendsIndices(q, sum, i, j)

-}

-

-fn Main()

+pub fn Main()

 {

 }

 

 

 

 

-predicate Sorted(q: Seq<int>, j: : 0 <= i <= j < |q| ==> q[i] <= q[j] 

+spec fn Sorted(q: Seq<int>) -> bool

+{

+	forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j] 

 }

 

 

 

 

-predicate HasAddends(q: seq<int>, x: int)

+spec fn HasAddends(q: Seq<int>, x: int) -> bool

 {

-	exists i, j: : 0 <= i < j < |q| && q[i] + q[j] == x

+	exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x

 }

 

 

 

 

-method FindAddends(q: seq<int>, x: int) -> i: nat, j: nat

-    requires Sorted(q) and HasAddends(q, x)

-    ensures i < j < q.len() and q[i]+q[j] == x

+pub fn FindAddends(q: Seq<int>, x: int) -> (i: nat, j: nat)

+	requires(Sorted(q) && HasAddends(q, x))

+	ensures(|result: (nat, nat)| result.0 < result.1 < q.len() && q[result.0] + q[result.1] == x)

 {

 }

 

+

+

+

+spec fn IsValidIndex<T>(q: Seq<T>, i: nat) -> bool

+{

+	0 <= i < q.len()

+}

+

+

+

+

+spec fn AreOreredIndices<T>(q: Seq<T>, i: nat, j: nat) -> bool

+{

+	0 <= i < j < q.len()

+}

+

+

+

+

+spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+	recommends(IsValidIndex(q, i) && IsValidIndex(q, j))

+{

+	q[i] + q[j] == x

+}

+

+

+

+

+spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+	recommends(AreOreredIndices(q, i, j))

+{

+	HasAddends(q.subrange(i, j + 1), x)

+}

+

+

+

+

+spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool

+{

+	AreOreredIndices(q, i, j) &&

+	HasAddendsInIndicesRange(q, x, i, j) &&

+	AreAddendsIndices(q, sum, i, j)

+}

+

+

+

+

+proof fn LoopInvWhenSumIsBigger(q: Seq<int>, x: int, i: nat, j: nat, sum: int)

+	requires(HasAddends(q, x))

+	requires(Sorted(q))

+	requires(sum > x)

+	requires(LoopInv(q, x, i, j, sum))

+	ensures(HasAddendsInIndicesRange(q, x, i, j - 1))

+{

 }

================================================================================
Comparing translations/atomizer_supported/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec.rs
+++ verus_specs/translations/atomizer_supported/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec.rs
@@ -1,15 +1,109 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn PlusOne(x: int) -> (y: int)

-    requires x >= 0

-    ensures y > 0

+

+

+pub fn PlusOne(x: int) -> (y: int)

+    requires(x >= 0)

+    ensures(|y: int| y > 0)

 {

 }

 

+

+

+

+

+

+pub fn Swap(a: &mut [int], i: int, j: int)

+    requires(0 <= i < a.len() && 0 <= j < a.len())

+{

+}

+

+

+

+

+

+

+

+

+pub fn IntDiv(m: int, n: int) -> (d: int, r: int)

+    requires(n > 0)

+    ensures(|d: int, r: int| m == n * d + r && 0 <= r < n)

+{

+}

+

+

+

+

+

+

+

+pub fn ArraySum(a: &[int], b: &[int]) -> (c: Vec<int>)

+    requires(a.len() == b.len())

+    ensures(|c: Vec<int>| c.len() == a.len() && 

+        forall|i: int| 0 <= i < c.len() ==> c[i] == a[i] + b[i])

+{

+}

+

+

+

+

+

+

+

+

+

+

+

+pub fn Euclid(m: int, n: int) -> (gcd: int)

+    requires(m > 1 && n > 1 && m >= n)

+    ensures(|gcd: int| gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0)

+{

+}

+

+

+

+

+

+

+pub fn IsSorted(a: &[int]) -> (isSorted: bool)

+    ensures(|isSorted: bool| isSorted <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] <= a[j])

+{

+}

+

+

+

+

+

+

+pub fn IsPrime(m: int) -> (isPrime: bool)

+    requires(m > 0)

+    ensures(|isPrime: bool| isPrime <==> (m > 1 && forall|j: int| 2 <= j < m ==> m % j != 0))

+{

+}

+

+

+

+

+

+

+

+

+pub fn Reverse(a: &[int]) -> (aRev: Vec<int>)

+    ensures(|aRev: Vec<int>| aRev.len() == a.len())

+    ensures(|aRev: Vec<int>| forall|i: int| 0 <= i < a.len() ==> a[i] == aRev[aRev.len()-i-1])

+{

+}

+

+

+

+

+

+

+

+

+pub fn NoDups(a: &[int]) -> (noDups: bool)

+    requires(forall|j: int| 0 < j < a.len() ==> a[j-1] <= a[j])

+    ensures(|noDups: bool| noDups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j])

+{

 }

================================================================================
Comparing translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec.rs
+++ verus_specs/translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn A8Q1(y0: int, x: int) -> (z: int)

-    requires y0 >= 0;

+spec fn power(a: int, n: int) -> int

+    recommends 0 <= n;

 

-    ensures z==power(x,y0);

+pub fn A8Q1(y0: int, x: int) -> (z: int)

+    requires(y0 >= 0)

+    ensures(z == power(x, y0))

 {

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec.rs
+++ verus_specs/translations/atomizer_supported/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn simple(y: int) -> (x: int)

-    requires y==6;

-    ensures x==7;

+pub fn simple(y: int) -> (x: int)

+    requires(y == 6)

+    ensures(x == 7)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec.rs
+++ verus_specs/translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Two(x: int) -> (y: int)

+pub fn Two(x: int) -> (y: int)

     ensures y == x + 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec.rs
+++ verus_specs/translations/atomizer_supported/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M1(x: int, y: int) -> (r: int)

-    ensures r == x*y

+pub fn M1(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

 {

 }

 

+pub fn A1(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec.rs
+++ verus_specs/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec.rs
@@ -1,14 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn binSearch(a: Vec<int>, K: int) -> (b: bool)

-    requires isSorted(a)

-    ensures b == exists i:nat :: i < a.len() and a[i] == K

+

+spec fn isSorted(a: &[i32]) -> bool {

+    forall|i: nat, j: nat| i < j < a.len() ==> a[i as int] <= a[j as int]

+}

+

+

+pub fn binSearch(a: &[i32], K: i32) -> (b: bool)

+    requires(isSorted(a))

+    ensures(b == exists|i: nat| i < a.len() && a[i as int] == K)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec.rs
+++ verus_specs/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec.rs
@@ -1,14 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn ComputeFib(n: nat) -> (f: nat)

-    ensures f == fib(n);

+spec fn fib(n: nat) -> nat

 {

+  if n == 0 { 0 }

+  else if n == 1 { 1 }

+  else { fib((n - 1) as nat) + fib((n - 2) as nat) }

 }

 

+pub fn ComputeFib(n: nat) -> (f: nat)

+    ensures(f == fib(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec.rs
+++ verus_specs/translations/atomizer_supported/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec.rs
@@ -1,26 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(a: Vec<int>, key: int) -> (i: int)

-    requires a != null;

-

-    ensures 0 <= i ==> (

-                       i < a.len() and 

-

-                       a[i] == key and 

-

-                       forall|k: int| 0 <= k < i ==> a[k] != key

-                      );

-

-            i < 0 ==> 

-

-           forall|k: int| 0 <= k < a.len() ==> a[k] != key;

+pub fn find(a: &[i32], key: i32) -> i32

+    requires(true)

+    ensures(|i: i32| 0 <= i ==> (i < a.len() && 

+                                 a[i as usize] == key && 

+                                 forall|k: usize| 0 <= k < i ==> a[k] != key))

+    ensures(|i: i32| i < 0 ==> 

+            forall|k: usize| 0 <= k < a.len() ==> a[k] != key)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec.rs
+++ verus_specs/translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec.rs
@@ -1,22 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn correct_pair(pair: (int, int), nums: Seq<int>, target: int) -> bool {

-    var (i, j) := pair;

-  and 0 <= i < nums.len()

-  and 0 <= j < nums.len()

-  and i != j

-  and nums[i] + nums[j] == target

+    let (i, j) = pair;

+    && 0 <= i < nums.len()

+    && 0 <= j < nums.len()

+    && i != j

+    && nums[i] + nums[j] == target

 }

 

-fn twoSum(nums: Seq<int>, target: int) -> pair: (int, int)

-    requires exists|i: int, j: int| correct_pair((i, j), nums, target)

-    ensures correct_pair(pair, nums, target)

+pub fn twoSum(nums: Seq<int>, target: int) -> (pair: (int, int))

+    requires(exists|i: int, j: int| correct_pair((i, j), nums, target))

+    ensures(correct_pair(pair, nums, target))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec.rs
+++ verus_specs/translations/atomizer_supported/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec.rs
@@ -1,54 +1,179 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn palindromic(s: String, i: int, j: int)

-  requires 0 <= i <= j <= |s|

+

+spec fn palindromic(s: Seq<char>, i: int, j: int) -> bool

+    recommends 0 <= i <= j <= s.len()

 {

-  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))

+    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))

+}

+

+

+proof fn lemma_palindromic_contains(s: Seq<char>, lo: int, hi: int, lo_prime: int, hi_prime: int)

+    requires 

+        0 <= lo <= lo_prime <= hi_prime <= hi <= s.len(),

+        lo + hi == lo_prime + hi_prime,

+        palindromic(s, lo, hi)

+    ensures palindromic(s, lo_prime, hi_prime)

+{

+    if lo < lo_prime {

+        lemma_palindromic_contains(s, lo + 1, hi - 1, lo_prime, hi_prime);

+    }

+}

+

+

+pub fn expand_from_center(s: Seq<char>, i0: int, j0: int) -> (lo: int, hi: int)

+    requires 

+        0 <= i0 <= j0 <= s.len(),

+        palindromic(s, i0, j0)

+    ensures 

+        0 <= lo <= hi <= s.len() && palindromic(s, lo, hi),

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == i0 + j0 ==> j - i <= hi - lo

+{

 }

 

 

 

+pub fn longestPalindrome(s: Seq<char>) -> (ans: Seq<char>, lo: int, hi: int)

+    ensures 

+        0 <= lo <= hi <= s.len() && ans == s.subrange(lo, hi),

+        palindromic(s, lo, hi),

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo

+{

+}

+

+pub fn longestPalindrome_prime(s: Seq<char>) -> (ans: Seq<char>, lo: int, hi: int)

+    ensures 

+        0 <= lo <= hi <= s.len() && ans == s.subrange(lo, hi),

+        palindromic(s, lo, hi),

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo

+{

+}

+

+spec fn insert_bogus_chars(s: Seq<char>, bogus: char) -> Seq<char>

+    ensures |insert_bogus_chars(s, bogus)| == 2 * s.len() + 1,

+        forall|i: int| 0 <= i <= s.len() ==> insert_bogus_chars(s, bogus)[i * 2] == bogus,

+        forall|i: int| 0 <= i < s.len() ==> insert_bogus_chars(s, bogus)[i * 2 + 1] == s[i]

+{

+    if s.len() == 0 {

+        seq![bogus]

+    } else {

+        let s_prime_old = insert_bogus_chars(s.subrange(1, s.len() as int), bogus);

+        let s_prime_new = seq![bogus, s[0]].add(s_prime_old);

+        s_prime_new

+    }

+}

+

+fn argmax(a: &Vec<i32>, start: usize) -> (usize, i32)

+    requires 

+        0 <= start < a.len()

+    ensures 

+        start <= argmax(a, start).0 < a.len() && a[argmax(a, start).0] == argmax(a, start).1,

+        forall|i: int| start <= i < a.len() ==> a[i] <= argmax(a, start).1

+{

+}

 

 

-lemma lemma_palindromic_contains(s: string, lo: int, hi: int, lo': int, hi': int)

-  requires 0 <= lo <= lo' <= hi' <= hi <= |s|

-  requires lo + hi == lo' + hi'

-  requires palindromic(s, lo, hi)

-  ensures palindromic(s, lo', hi') -> bool {

-    if lo < lo' {

-    lemma_palindromic_contains(s, lo + 1, hi - 1, lo', hi');

-}

-spec fn inbound_radius(s': String, c: int, r: int) -> bool {

-    r >= 0 and 0 <= c-r and c+r < s'.len()

-}

-spec fn palindromic_radius(s': String, c: int, r: int)

-  requires inbound_radius(s', c, r) -> bool {

-    palindromic(s', c-r, c+r+1)

-}

-spec fn max_radius(s': String, c: int, r: int) -> bool {

-    and inbound_radius(s', c, r)

-  and palindromic_radius(s', c, r)

-  and (forall|r' | r' > r and inbound_radius(s': int, c: int, r'): int| !palindromic_radius(s', c, r'))

-}

-spec fn max_interval_for_same_center(s: String, k: int, lo: int, hi: int) -> bool {

-    and 0 <= lo <= hi <= s.len()

-  and lo + hi == k

-  and palindromic(s, lo, hi)

-  and (forall|i: int, j  0 <= i <= j <= .len()s| and palindromic(s: int, i: int, j) and i + j == k: int| j - i <= hi - lo)

+spec fn inbound_radius(s_prime: Seq<char>, c: int, r: int) -> bool

+{

+    r >= 0 && 0 <= c-r && c+r < s_prime.len()

 }

 

-fn expand_from_center(s: String, i0: int, j0: int) -> lo: int, hi: int

-    requires 0 <= i0 <= j0 <= s.len(),

-             palindromic(s, i0, j0)

-    ensures 0 <= lo <= hi <= s.len() and palindromic(s, lo, hi),

-            forall|i: int, j  0 <= i <= j <= .len()s| and palindromic(s: int, i: int, j)

-    and i + j == i0 + j0

+

+spec fn palindromic_radius(s_prime: Seq<char>, c: int, r: int) -> bool

+    recommends inbound_radius(s_prime, c, r)

+{

+    palindromic(s_prime, c-r, c+r+1)

+}

+

+

+spec fn max_radius(s_prime: Seq<char>, c: int, r: int) -> bool

+{

+    && inbound_radius(s_prime, c, r)

+    && palindromic_radius(s_prime, c, r)

+    && (forall|r_prime: int| r_prime > r && inbound_radius(s_prime, c, r_prime) ==> !palindromic_radius(s_prime, c, r_prime))

+}

+

+

+

+proof fn lemma_palindromic_radius_contains(s_prime: Seq<char>, c: int, r: int, r_prime: int)

+    requires 

+        inbound_radius(s_prime, c, r) && palindromic_radius(s_prime, c, r),

+        0 <= r_prime <= r

+    ensures 

+        inbound_radius(s_prime, c, r_prime) && palindromic_radius(s_prime, c, r_prime)

+{

+    lemma_palindromic_contains(s_prime, c-r, c+r+1, c-r_prime, c+r_prime+1);

+}

+

+

+proof fn lemma_end_of_expansion(s_prime: Seq<char>, c: int, r: int)

+    requires 

+        inbound_radius(s_prime, c, r) && palindromic_radius(s_prime, c, r),

+        inbound_radius(s_prime, c, r + 1) ==> s_prime[c - (r + 1)] != s_prime[c + (r + 1)]

+    ensures max_radius(s_prime, c, r)

+{

+}

+

+

+proof fn lemma_mirrored_palindrome(s_prime: Seq<char>, c: int, r: int, c1: int, r1: int, c2: int)

+    requires 

+        max_radius(s_prime, c, r) && max_radius(s_prime, c1, r1),

+        c - r <= c1 < c < c2 <= c + r,

+        c2 - c == c - c1

+    ensures 

+        c2 + r1 < c + r ==> max_radius(s_prime, c2, r1),

+        c2 + r1 > c + r ==> max_radius(s_prime, c2, c + r - c2),

+        c2 + r1 == c + r ==> palindromic_radius(s_prime, c2, c + r - c2)

+{

+}

+

+spec fn abs(x: int) -> int {

+    if x >= 0 { x } else { -x }

+}

+

+

+proof fn lemma_result_transfer(s: Seq<char>, s_prime: Seq<char>, bogus: char, radii: &Vec<i32>, c: int, r: int, hi: int, lo: int)

+    requires 

+        s_prime == insert_bogus_chars(s, bogus),

+        radii.len() == s_prime.len(),

+        forall|i: int| 0 <= i < radii.len() ==> max_radius(s_prime, i, radii[i]),

+        (c, r) == argmax(radii, 0),

+        lo == (c - r) / 2 && hi == (c + r) / 2

+    ensures 

+        0 <= lo <= hi <= s.len(),

+        palindromic(s, lo, hi),

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo

+{

+}

+

+

+spec fn max_interval_for_same_center(s: Seq<char>, k: int, lo: int, hi: int) -> bool {

+    && 0 <= lo <= hi <= s.len()

+    && lo + hi == k

+    && palindromic(s, lo, hi)

+    && (forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == k ==> j - i <= hi - lo)

+}

+

+

+proof fn lemma_palindrome_isomorph(s: Seq<char>, s_prime: Seq<char>, bogus: char, lo: int, hi: int)

+    requires 

+        s_prime == insert_bogus_chars(s, bogus),

+        0 <= lo <= hi <= s.len()

+    ensures palindromic(s, lo, hi) <==> palindromic_radius(s_prime, lo + hi, hi - lo)

+{

+}

+

+

+

+proof fn lemma_palindrome_bogus(s: Seq<char>, s_prime: Seq<char>, bogus: char, c: int, r: int)

+    requires 

+        s_prime == insert_bogus_chars(s, bogus),

+        inbound_radius(s_prime, c, r) && palindromic_radius(s_prime, c, r),

+        (c + r) % 2 == 1

+    ensures 

+        inbound_radius(s_prime, c, r + 1) && palindromic_radius(s_prime, c, r + 1)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_ex3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_ex3_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_ex3_spec.rs
@@ -1,20 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sortedbad(s: String) -> bool {

+spec fn sortedbad(s: Seq<char>) -> bool {

 

-  forall|i: int, j: int| 0 <= i <= j < s.len() and s[i] == 'b' and s[j] != 'b' ==> i < j and

+    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] == 'b' && s[j] != 'b' ==> i < j) &&

 

-  forall|i: int, j: int| 0 <= i <= j < s.len() and s[i] != 'd' and s[j] == 'd' ==> i < j

+    (forall|i: int, j: int| 0 <= i <= j < s.len() && s[i] != 'd' && s[j] == 'd' ==> i < j)

 }

 

-fn BadSort(a: String) -> (b: String)

-    requires forall|i: int| 0<=i<a.len() ==> a[i] in

+pub fn BadSort(a: Seq<char>) -> (b: Seq<char>)

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i] == 'a' || a[i] == 'b' || a[i] == 'c' || a[i] == 'd')

+    ensures(sortedbad(b))

+    ensures(b.to_multiset() == a.to_multiset())

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p1_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p1_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumArray(xs: Vec<int>) -> (s: int)

-    ensures s == Sum(xs[..])

-{

+spec fn sum(xs: Seq<int>) -> int {

+    if xs.len() == 0 { 0 } else { sum(xs.subrange(0, xs.len() - 1)) + xs[xs.len() - 1] }

 }

 

+pub fn sum_array(xs: &[int]) -> (s: int)

+    ensures(s == sum(xs@))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p2_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p2_spec.rs
@@ -1,15 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn absx(x: Vec<int>) -> (y: Vec<int>)

-    ensures y.len() == x.len(),

-            forall|i: int| 0 <= i < y.len() ==>  y[i] == abs(x[i])

+spec fn abs(x: int) -> nat {

+    if x < 0 { -x } else { x }

+}

+

+pub fn absx(x: &[i32]) -> (y: Vec<i32>)

+    ensures

+        y.len() == x.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == abs(x[i] as int),

 {

 }

 

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p3_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p3_spec.rs
@@ -1,30 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn max(x: Vec<nat>) -> (y: nat) 

 

-requires x.Length > 0

 

-ensures forall j :: 0 <= j < x.Length ==> y >= x[j]

 

-ensures y in x[..]

+

+

+pub fn max(x: &[nat]) -> (y: nat)

+

+    requires(x.len() > 0)

+

+    ensures(forall|j: int| 0 <= j < x.len() ==> y >= x[j as usize])

+

+    ensures(exists|i: int| 0 <= i < x.len() && y == x[i as usize])

 {

 }

 

 

 

-

-method Main()

-    requires x.len() > 0

-

-    ensures forall|j: int| 0 <= j < x.len() ==> y >= x[j]

-

-            y in x[..]

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p4_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p4_spec.rs
@@ -1,17 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn single(x: Vec<int>, y: Vec<int>) -> (b: Vec<int>)

-    requires x.len() > 0,

-             y.len() > 0

-

-    ensures b[..] == x[..] + y[..]

+pub fn single(x: &[i32], y: &[i32]) -> Vec<i32>

+    requires(x.len() > 0)

+    requires(y.len() > 0)

+    ensures(|result: Vec<i32>| result@ == x@ + y@)

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p6_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-duck_tmp_tmplawbgxjo_p6_spec.rs
@@ -1,14 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn FilterVowelsArray(xs: Vec<char>) -> (ys: Vec<char>)

-    ensures fresh(ys),

-            FilterVowels(xs[..]) == ys[..]

+const VOWELS: Set<char> = set!['a', 'e', 'i', 'o', 'u'];

+

+spec fn filter_vowels(xs: Seq<char>) -> Seq<char>

+    decreases xs.len()

+{

+    if xs.len() == 0 {

+        seq![]

+    } else if VOWELS.contains(xs[xs.len() - 1]) {

+        filter_vowels(xs.subrange(0, xs.len() - 1)).push(xs[xs.len() - 1])

+    } else {

+        filter_vowels(xs.subrange(0, xs.len() - 1))

+    }

+}

+

+pub fn filter_vowels_array(xs: &[char]) -> (ys: Vec<char>)

+    ensures(filter_vowels(xs@) == ys@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_appendArray_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_appendArray_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_appendArray_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn appendArray(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    ensures c.len() == a.len() + b.len(),

-            forall|i: int| 0 <= i < a.len() ==> a[i] == c[i],

-            forall|i: int| 0 <= i < b.len() ==> b[i] == c[a.len() + i]

+pub fn appendArray(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(true)

+    ensures(|result: Vec<i32>| result.len() == a.len() + b.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> a[i] == result[i])

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < b.len() ==> b[i] == result[a.len() + i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_countNeg_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_countNeg_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_countNeg_spec.rs
@@ -1,13 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn CountNeg(a: Vec<int>) -> (cnt: nat)

-    ensures cnt == verifyNeg(a, a.len())

+spec fn verifyNeg(a: &[int], idx: int) -> nat

+    recommends 0 <= idx <= a.len()

+{

+    if idx == 0 { 0 }

+    else { verifyNeg(a, idx - 1) + (if a[idx - 1] < 0 { 1 } else { 0 }) }

+}

+

+pub fn CountNeg(a: &[int]) -> (cnt: nat)

+    ensures cnt == verifyNeg(a, a.len() as int)

+{

+}

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_filter_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_filter_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_filter_spec.rs
@@ -1,13 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Filter(a: Seq<char>, b: set<char>) -> (c: set<char>)

-    ensures forall|x: int| x in a and x in b <==> x in c

+pub fn Filter(a: Seq<char>, b: Set<char>) -> (c: Set<char>)

+    ensures forall|x: char| a.contains(x) && b.contains(x) <==> c.contains(x)

+{

+}

+

+pub fn TesterFilter()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_firstE_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_firstE_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_firstE_spec.rs
@@ -1,14 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firstE(a: Vec<char>) -> (x: int)

-    ensures if 'e' in a[..] then 0 <= x < a.len() and a[x] == 'e' and forall|i | 0 <= i < x: int| a[i] != 'e' else x == -1

+pub fn firstE(a: &[char]) -> (x: i32)

+    ensures(

+        if a@.contains('e') then 0 <= x < a@.len() && a@[x as int] == 'e' && forall|i: int| 0 <= i < x ==> a@[i] != 'e' else x == -1

+    )

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_maxArray_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_maxArray_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_maxArray_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxArray(a: Vec<int>) -> (max: int)

-    requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= max,

-            exists|i: int| 0 <= i < a.len() and a[i] == max

+pub fn max_array(a: &[i32]) -> (max: i32)

+    requires(a.len() > 0)

+    ensures(forall|i: usize| 0 <= i < a.len() ==> a[i] <= max)

+    ensures(exists|i: usize| 0 <= i < a.len() && a[i] == max)

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec.rs
@@ -1,25 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn acheck(a: Vec<int>, n: int)

-reads a

-requires n >= 1

+

+spec fn acheck(a: &[int], n: int) -> bool

+    recommends n >= 1

 {

-	a.Length % 2 == 0 && 

-	forall i :: 0 <= i < a.Length ==> 

-		if i % n == 0 then a[i] == 0 else a[i] != 0

+    a.len() % 2 == 0 && 

+    forall|i: int| 0 <= i < a.len() ==> 

+        if i % n == 0 { a[i as usize] == 0 } else { a[i as usize] != 0 }

 }

 

 

 

-

-method Main() -> bool {

-    

+pub fn Main()

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec.rs
@@ -1,20 +1,30 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn triple(a: Vec<int>) -> bool {

-    

+

+spec fn triple(a: &[int]) -> bool

+{

+    exists|i: int| 0 <= i < a.len() - 2 && a[i] == a[i + 1] && a[i + 1] == a[i + 2]

 }

 

-fn GetTriple(a: Vec<int>) -> (index: int)

-    ensures 0 <= index < a.len() - 2 or index == a.len(),

-            index == a.len() <==> !triple(a),

-            0 <= index < a.len() - 2 <==> triple(a),

-            0 <= index < a.len() - 2 ==> a[index] == a[index + 1] == a[index + 2]

+

+

+pub fn GetTriple(a: &[int]) -> (index: usize)

+    ensures

+        0 <= index < a.len() - 2 || index == a.len(),

+    ensures

+        index == a.len() <==> !triple(a),

+    ensures

+        0 <= index < a.len() - 2 <==> triple(a),

+    ensures

+        0 <= index < a.len() - 2 ==> a[index as int] == a[index as int + 1] && a[index as int + 1] == a[index as int + 2],

+{

+}

+

+

+

+pub fn TesterGetTriple()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_reverse_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_reverse_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercise_tmp_tmpouftptir_reverse_spec.rs
@@ -1,17 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a == old(a),

-            b.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> b[i] == a[a.len() - i - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| result.len() == a.len())

+    ensures(|result: Vec<char>| forall|i: usize| 0 <= i < a.len() ==> result[i] == a[a.len() - i - 1])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec.rs
@@ -1,24 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn RemoveDuplicates(nums: Vec<int>) -> num_length: int)

-  modifies nums

-  requires forall i, j | 0 <= i < j < nums.Length: : nums[i] <= nums[j]

-  ensures nums.Length == old(nums).Length

-  ensures 0 <= num_length <= nums.Length

-  ensures forall i, j | 0 <= i < j < num_length: : nums[i] != nums[j]

-  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..]

-    requires forall|i: int, j | 0 <= i < j < nums.len(): int| nums[i] <= nums[j]

-    ensures nums.len() == old(nums).len(),

-            0 <= num_length <= nums.len(),

-            forall|i: int, j | 0 <= i < j < num_length: int| nums[i] != nums[j],

-            forall|i | 0 <= i < num_length: int| nums[i] in old(nums[..]),

-            forall|i | 0 <= i < nums.len(): int| old(nums[i]) in nums[..num_length]

+pub fn remove_duplicates(nums: &mut Vec<i32>) -> (num_length: usize)

+    requires

+        forall|i: int, j: int| 0 <= i < j < old(nums).len() ==> old(nums)[i] <= old(nums)[j],

+    ensures

+        nums.len() == old(nums).len(),

+        0 <= num_length <= nums.len(),

+        forall|i: int, j: int| 0 <= i < j < num_length ==> nums[i] != nums[j],

+        forall|i: int| 0 <= i < num_length ==> old(nums)@.contains(nums[i]),

+        forall|i: int| 0 <= i < old(nums).len() ==> nums@.subrange(0, num_length as int).contains(old(nums)[i]),

+{

+}

+

+pub fn testing()

+{

+}

+

+pub fn main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(N: int, a: Vec<int>) -> sum: int, max: int

-    requires 0 <= N and a.len() == N and (forall|k: int| 0 <= k and k < N ==> 0 <= a[k]);

-    ensures sum <= N * max;

+pub fn M(N: int, a: &[int]) -> (sum: int, max: int)

+    requires 

+        0 <= N && a.len() == N && (forall|k: int| 0 <= k && k < N ==> 0 <= a[k as usize]),

+    ensures |result: (int, int)|

+        result.0 <= N * result.1,

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec.rs
@@ -1,14 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

 }

 

+pub fn Mul(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

+{

+}

+

+pub fn Main()

+{

+}

+

+pub fn TestAdd(x: int, y: int)

+{

+}

+

+pub fn TestMul(x: int, y: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec.rs
@@ -1,15 +1,14 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSegSum(a: Seq<int>) -> k: int, m: int

-    ensures 0 <= k <= m <= a.len(),

-            forall|p: int, q: int| 0 <= p <= q <= a.len() ==> Sum(a, p, q) <= Sum(a, k, m)

+spec fn Sum(a: Seq<int>, s: int, t: int) -> int

+    recommends 0 <= s <= t <= a.len()

 {

+    if s == t { 0 } else { Sum(a, s, (t-1) as nat) + a[(t-1) as int] }

 }

 

+pub fn MaxSegSum(a: Seq<int>) -> (k: int, m: int)

+    ensures 

+        0 <= k <= m <= a.len(),

+        forall|p: int, q: int| 0 <= p <= q <= a.len() ==> Sum(a, p, q) <= Sum(a, k, m)

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFactorial(n: int) -> (u: int)

-    requires 1 <= n;

-    ensures u == Factorial(n);

-{

+spec fn factorial(n: nat) -> nat {

+    if n == 0 { 1 } else { n * factorial(n - 1) }

 }

 

+pub fn compute_factorial(n: int) -> (u: int)

+    requires(1 <= n)

+    ensures(u == factorial(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Regression19_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Regression19_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Regression19_spec.rs
@@ -1,37 +1,59 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn ContainsNothingBut5(s: set<int>) -> bool {

-    forall|q: int| q in s ==> q == 5

+spec fn contains_nothing_but_5(s: Set<int>) -> bool {

+    forall|q: int| s.contains(q) ==> q == 5

 }

 

-spec fn YeahContains5(s: set<int>) -> bool {

-    exists|q: int| q in s and q == 5

+spec fn yeah_contains_5(s: Set<int>) -> bool {

+    exists|q: int| s.contains(q) && q == 5

 }

 

-spec fn ViaSetComprehension(s: set<int>) -> bool {

-    set q .len() q in s and q == 5| != 0

+spec fn via_set_comprehension(s: Set<int>) -> bool {

+    Set::new(|q: int| s.contains(q) && q == 5).len() != 0

 }

 

-spec fn LambdaTest(s: set<int>) -> bool {

-    (q => q in s)(5)

+spec fn lambda_test(s: Set<int>) -> bool {

+    (|q: int| s.contains(q))(5)

 }

 

-spec fn ViaMapComprehension(s: set<int>) -> bool {

-    (map q .len() q in s and q == 5 :: true).Keys| != 0

+spec fn via_map_comprehension(s: Set<int>) -> bool {

+    Map::new(|q: int| s.contains(q) && q == 5, |q: int| true).dom().len() != 0

 }

 

-spec fn Contains5(s: set<int>) -> bool {

-    var q := 5; q in s

+spec fn contains_5(s: Set<int>) -> bool {

+    {

+        let q = 5;

+        s.contains(q)

+    }

 }

 

-spec fn RIs5(r: R) -> bool {

-    match r case MakeR(q) => q == 5 case Other => false

+enum R {

+    MakeR(int),

+    Other,

 }

 

+spec fn r_is_5(r: R) -> bool {

+    match r {

+        R::MakeR(q) => q == 5,

+        R::Other => false,

+    }

+}

+

+proof fn nonempty_set(x: int, s: Set<int>)

+    requires(s.contains(x))

+    ensures(s.len() != 0)

+{

+}

+

+proof fn nonempty_map(x: int, s: Map<int, bool>)

+    requires(s.dom().contains(x))

+    ensures(s.len() != 0)

+{

+}

+

+pub fn m(s: Set<int>, r: R, q: int)

+    requires(

+        s == Set::empty() && r == R::MakeR(5)

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_large-quantifiers-dont-break-dafny_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_large-quantifiers-dont-break-dafny_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_large-quantifiers-dont-break-dafny_spec.rs
@@ -1,114 +1,59 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn P0(x: bool)

+spec fn P0(x: bool) -> bool;

+spec fn P1(x: bool) -> bool;

+spec fn P2(x: bool) -> bool;

+spec fn P3(x: bool) -> bool;

+spec fn P4(x: bool) -> bool;

+spec fn P5(x: bool) -> bool;

+spec fn P6(x: bool) -> bool;

+spec fn P7(x: bool) -> bool;

+spec fn P8(x: bool) -> bool;

+spec fn P9(x: bool) -> bool;

+spec fn P10(x: bool) -> bool;

+spec fn P11(x: bool) -> bool;

+spec fn P12(x: bool) -> bool;

+spec fn P13(x: bool) -> bool;

+spec fn P14(x: bool) -> bool;

+spec fn P15(x: bool) -> bool;

+spec fn P16(x: bool) -> bool;

+spec fn P17(x: bool) -> bool;

+spec fn P18(x: bool) -> bool;

+spec fn P19(x: bool) -> bool;

+spec fn P20(x: bool) -> bool;

+spec fn P21(x: bool) -> bool;

+spec fn P22(x: bool) -> bool;

+spec fn P23(x: bool) -> bool;

+spec fn P24(x: bool) -> bool;

+spec fn P25(x: bool) -> bool;

+spec fn P26(x: bool) -> bool;

+spec fn P27(x: bool) -> bool;

+spec fn P28(x: bool) -> bool;

+spec fn P29(x: bool) -> bool;

+spec fn P30(x: bool) -> bool;

+spec fn P31(x: bool) -> bool;

+spec fn P32(x: bool) -> bool;

+spec fn P33(x: bool) -> bool;

+spec fn P34(x: bool) -> bool;

+spec fn P35(x: bool) -> bool;

+spec fn P36(x: bool) -> bool;

+spec fn P37(x: bool) -> bool;

+spec fn P38(x: bool) -> bool;

+spec fn P39(x: bool) -> bool;

+spec fn P40(x: bool) -> bool;

+spec fn P41(x: bool) -> bool;

+spec fn P42(x: bool) -> bool;

+spec fn P43(x: bool) -> bool;

+spec fn P44(x: bool) -> bool;

+spec fn P45(x: bool) -> bool;

+spec fn P46(x: bool) -> bool;

+spec fn P47(x: bool) -> bool;

+spec fn P48(x: bool) -> bool;

+spec fn P49(x: bool) -> bool;

 

-predicate P1(x: bool)

-

-predicate P2(x: bool)

-

-predicate P3(x: bool)

-

-predicate P4(x: bool)

-

-predicate P5(x: bool)

-

-predicate P6(x: bool)

-

-predicate P7(x: bool)

-

-predicate P8(x: bool)

-

-predicate P9(x: bool)

-

-predicate P10(x: bool)

-

-predicate P11(x: bool)

-

-predicate P12(x: bool)

-

-predicate P13(x: bool)

-

-predicate P14(x: bool)

-

-predicate P15(x: bool)

-

-predicate P16(x: bool)

-

-predicate P17(x: bool)

-

-predicate P18(x: bool)

-

-predicate P19(x: bool)

-

-predicate P20(x: bool)

-

-predicate P21(x: bool)

-

-predicate P22(x: bool)

-

-predicate P23(x: bool)

-

-predicate P24(x: bool)

-

-predicate P25(x: bool)

-

-predicate P26(x: bool)

-

-predicate P27(x: bool)

-

-predicate P28(x: bool)

-

-predicate P29(x: bool)

-

-predicate P30(x: bool)

-

-predicate P31(x: bool)

-

-predicate P32(x: bool)

-

-predicate P33(x: bool)

-

-predicate P34(x: bool)

-

-predicate P35(x: bool)

-

-predicate P36(x: bool)

-

-predicate P37(x: bool)

-

-predicate P38(x: bool)

-

-predicate P39(x: bool)

-

-predicate P40(x: bool)

-

-predicate P41(x: bool)

-

-predicate P42(x: bool)

-

-predicate P43(x: bool)

-

-predicate P44(x: bool)

-

-predicate P45(x: bool)

-

-predicate P46(x: bool)

-

-predicate P47(x: bool)

-

-predicate P48(x: bool)

-

-predicate P49(x: bool)

-

-

-method M() -> bool {

-    

+pub fn M() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_loop-detection-looks-at-ranges-too_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_loop-detection-looks-at-ranges-too_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_triggers_loop-detection-looks-at-ranges-too_spec.rs
@@ -1,16 +1,4 @@
+pub fn P(x: int) -> bool

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P(x: int)

-

-

-method M(x: int) -> bool {

-    

-}

-

+pub fn M(x: int) {

 }

================================================================================
Comparing translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec.rs
@@ -1,16 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Maximum(values: Seq<int>) -> (max: int)

-    requires values != []

-    ensures max in values,

-            forall|i  0 <= i < .len()values|: int| values[i] <= max

+pub fn Maximum(values: Seq<int>) -> (max: int)

+    requires

+        values != seq![],

+    ensures

+        values.contains(max),

+        forall|i: int| 0 <= i < values.len() ==> values[i] <= max,

 {

 }

 

+proof fn MaximumIsUnique(values: Seq<int>, m1: int, m2: int)

+    requires

+        values.contains(m1) && (forall|i: int| 0 <= i < values.len() ==> values[i] <= m1),

+        values.contains(m2) && (forall|i: int| 0 <= i < values.len() ==> values[i] <= m2),

+    ensures

+        m1 == m2,

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec.rs
@@ -1,16 +1,33 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures 0 <= y,

-            x < 0 ==> y == -x,

-            x >= 0 ==> y == x

+pub fn Abs(x: int) -> (y: int)

+    ensures(0 <= y)

+    ensures(x < 0 ==> y == -x)

+    ensures(x >= 0 ==> y == x)

 {

 }

 

+

+pub fn TestingAbs()

+{

+}

+

+

+pub fn TestingAbs2()

+{

+}

+

+

+

+

+

+

+

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a)

+    ensures(c >= b)

+{

+}

+

+

+pub fn TestingMax() {

 }

================================================================================
Comparing translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec.rs
@@ -1,12 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub fn abs(x: int) -> int

+{

+    if x < 0 { -x } else { x }

+}

 

-verus! {

 

-fn Testing_abs()

+

+

+pub fn Testing_abs()

 {

 }

 

@@ -19,14 +20,14 @@
 

 

 

-function max(a: int, b: int): int

+pub fn max(a: int, b: int) -> int

 {

 

-    if a > b then a else b

+    if a > b { a } else { b }

 }

 

 

-method Testing_max() {

+pub fn Testing_max() {

 }

 

 

@@ -38,9 +39,27 @@
 

 

 

-method Abs(x: int) -> (y: int)

-    ensures abs(x) == y

+pub fn Abs(x: int) -> (y: int)

+    ensures(abs(x) == y)

 {

 }

 

+

+

+

+

+

+

+

+pub fn Double(val: int) -> int

+{

+    2 * val

+}

+

+

+

+

+pub fn TestDouble(val: int) -> (val2: int)

+    ensures(val2 == Double(val))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec.rs
@@ -1,14 +1,18 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Expt(b: int, n: nat) -> int

+    recommends n >= 0

+{

+    if n == 0 { 1 } else { b * Expt(b, (n - 1) as nat) }

+}

 

-verus! {

 

-fn expt(b: int, n: nat) -> (res: int)

-    ensures res == Expt(b, n)

+

+pub fn expt(b: int, n: nat) -> (res: int)

+    ensures(res == Expt(b, n))

 {

 }

 

+proof fn distributive(x: int, a: nat, b: nat)

+    ensures(Expt(x, a) * Expt(x, b) == Expt(x, a + b))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fact(n: nat) -> nat 

+    ensures |result: nat| result >= 1

+{

+    if n == 0 { 1 } else { n * fact((n - 1) as nat) }

+}

 

-verus! {

 

-fn factorial(n: nat) -> (res: nat)

+pub fn factorial(n: nat) -> (res: nat)

     ensures res == fact(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_max_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-programs_tmp_tmpcwodh6qh_src_max_spec.rs
@@ -1,15 +1,22 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures a >= b ==> c == a,

-            b >= a ==> c == b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(a >= b ==> c == a)

+    ensures(b >= a ==> c == b)

 {

 }

 

+

+pub fn MaxTest()

+{

+}

+

+

+pub fn max(a: int, b: int) -> int

+{

+    if a > b { a } else { b }

+}

+

+

+pub fn maxTest()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_101_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_101_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_101_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn KthElement(arr: Vec<int>, k: int) -> (result: int)

-    requires 1 <= k <= arr.len()

-    ensures result == arr[k - 1]

+pub fn kth_element(arr: &[i32], k: i32) -> (result: i32)

+    requires(1 <= k <= arr.len())

+    ensures(|result: i32| result == arr[(k - 1) as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_105_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_105_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_105_spec.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountTrue(a: Vec<bool>) -> (result: int)

-    requires a != null

-    ensures result == countTo(a, a.len())

+spec fn countTo(a: &[bool], n: int) -> int

+    recommends 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else { countTo(a, n-1) + (if a[n-1] { 1 } else { 0 }) }

 }

 

+

+pub fn CountTrue(a: &[bool]) -> (result: int)

+    ensures(result == countTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_106_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_106_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_106_spec.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AppendArrayToSeq(s: Seq<int>, a: Vec<int>) -> (r: Seq<int>)

-    requires a != null

-    ensures r.len() == s.len() + a.len(),

-            forall|i: int| 0 <= i < s.len() ==> r[i] == s[i],

-            forall|i: int| 0 <= i < a.len() ==> r[s.len() + i] == a[i]

+pub fn append_array_to_seq(s: Seq<int>, a: &[int]) -> (r: Seq<int>)

+    requires(

+        true

+    )

+    ensures(

+        |result| == |s| + a.len() &&

+        forall|i: int| 0 <= i < |s| ==> result[i] == s[i] &&

+        forall|i: int| 0 <= i < a.len() ==> result[|s| + i] == a[i]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_113_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_113_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_113_spec.rs
@@ -1,18 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool

+{

     48 <= c as int <= 57

 }

 

-fn IsInteger(s: String) -> (result: bool)

-    ensures result <==> (s.len() > 0) and (forall|i: int| 0 <= i < s.len() ==> IsDigit(s[i]))

+

+

+pub fn is_integer(s: &str) -> (result: bool)

+    ensures

+        result <==> (s.len() > 0) && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_126_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_126_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_126_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfCommonDivisors(a: int, b: int) -> (sum: int)

-    requires a > 0 and b > 0

-    ensures sum >= 0,

-            forall|d: int| 1 <= d <= a and 1 <= d <= b and a % d == 0 and b % d == 0 ==> sum >= d

+pub fn SumOfCommonDivisors(a: int, b: int) -> (sum: int)

+    requires(a > 0 && b > 0)

+    ensures(sum >= 0)

+    ensures(forall|d: int| 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_127_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_127_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_127_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Multiply(a: int, b: int) -> (result: int)

+pub fn multiply(a: int, b: int) -> (result: int)

     ensures result == a * b

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_133_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_133_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_133_spec.rs
@@ -1,14 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfNegatives(a: Vec<int>) -> (result: int)

-    ensures result == sumNegativesTo(a, a.len())

+spec fn sumNegativesTo(a: &[int], n: int) -> int

+    recommends

+        0 <= n && n <= a.len(),

 {

+    if n == 0 { 

+        0 

+    } else if a[n-1] < 0 { 

+        sumNegativesTo(a, n-1) + a[n-1] 

+    } else { 

+        sumNegativesTo(a, n-1) 

+    }

 }

 

+

+pub fn SumOfNegatives(a: &[int]) -> (result: int)

+    ensures(result == sumNegativesTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_135_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_135_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_135_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthHexagonalNumber(n: int) -> (hexNum: int)

+pub fn nth_hexagonal_number(n: int) -> (hexNum: int)

     requires n >= 0

     ensures hexNum == n * ((2 * n) - 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_142_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_142_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_142_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountIdenticalPositions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

-    requires a.len() == b.len() and b.len() == c.len()

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < a.len() and a[i] == b[i] and b[i] == c[i]|

+pub fn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

+    requires(a.len() == b.len() && b.len() == c.len())

+    ensures(count >= 0)

+    ensures(count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_143_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_143_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_143_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountArrays(arrays: Seq<Vec<int>>) -> (count: int)

+pub fn CountArrays(arrays: Seq<&mut [int]>) -> (count: int)

     ensures count >= 0,

-            count == arrays.len()

+    ensures count == arrays.len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_145_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_145_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_145_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() > 1

-    ensures forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] - a[j] <= diff

+pub fn max_difference(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 1)

+    ensures(forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] - a[j] <= diff)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_14_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_14_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_14_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TriangularPrismVolume(base: int, height: int, length: int) -> (volume: int)

-    requires base > 0,

-             height > 0,

-             length > 0

-    ensures volume == (base * height * length) / 2

+pub fn triangular_prism_volume(base: int, height: int, length: int) -> (volume: int)

+    requires

+        base > 0,

+        height > 0,

+        length > 0,

+    ensures

+        volume == (base * height * length) / 2,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_170_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_170_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_170_spec.rs
@@ -1,16 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumInRange(a: Vec<int>, start: int, end: int) -> (sum: int)

-    requires a != null,

-             0 <= start and start <= end and end <= a.len()

-    ensures sum == sumTo(a, start, end)

+spec fn sumTo(a: &[int], start: int, end: int) -> int

+    recommends

+        0 <= start && start <= end && end <= a.len(),

 {

+    if start == end { 0 } else { sumTo(a, start, (end - 1) as int) + a[(end - 1) as int] }

 }

 

+

+pub fn SumInRange(a: &[int], start: int, end: int) -> (sum: int)

+    requires(

+        0 <= start && start <= end && end <= a.len(),

+    )

+    ensures(|sum: int|

+        sum == sumTo(a, start, end)

+    )

+{

+    unimplemented!()

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_171_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_171_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_171_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PentagonPerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 5 * side

+pub fn PentagonPerimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 5 * side)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_17_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_17_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_17_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 4 * side

+pub fn square_perimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 4 * side)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_18_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_18_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_18_spec.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveChars(s1: String, s2: String) -> (v: String)

-    ensures v.len() <= s1.len(),

-            forall|i: int| 0 <= i < v.len() ==> (v[i] in s1) and !(v[i] in s2),

-            forall|i: int| 0 <= i < s1.len() ==> (s1[i] in s2) or (s1[i] in v)

+pub fn remove_chars(s1: &str, s2: &str) -> (v: String)

+    requires(

+        true

+    )

+    ensures(|v: String|

+        v.len() <= s1.len() &&

+        (forall|i: usize| 0 <= i < v.len() ==> 

+            s1.contains(v.chars().nth(i as int).unwrap()) && 

+            !s2.contains(v.chars().nth(i as int).unwrap())) &&

+        (forall|i: usize| 0 <= i < s1.len() ==> 

+            s2.contains(s1.chars().nth(i as int).unwrap()) || 

+            v.contains(s1.chars().nth(i as int).unwrap()))

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_227_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_227_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_227_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinOfThree(a: int, b: int, c: int) -> (min: int)

-    ensures min <= a and min <= b and min <= c,

-            (min == a) | (min == b) .len()| (min == c)

+pub fn MinOfThree(a: int, b: int, c: int) -> (min: int)

+    ensures(min <= a && min <= b && min <= c)

+    ensures((min == a) || (min == b) || (min == c))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_230_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_230_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_230_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceBlanksWithChar(s: String, ch: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == ' ' ==> v[i] == ch) and (s[i] != ' ' ==> v[i] == s[i])

+pub fn replace_blanks_with_char(s: &str, ch: char) -> (v: String)

+    ensures(

+        v.len() == s.len() &&

+        forall|i: usize| 0 <= i < s.len() ==> 

+            (s.as_bytes()[i] == b' ' ==> v.as_bytes()[i] == ch as u8) &&

+            (s.as_bytes()[i] != b' ' ==> v.as_bytes()[i] == s.as_bytes()[i])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_234_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_234_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_234_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeVolume(size: int) -> (volume: int)

-    requires size > 0

-    ensures volume == size * size * size

+pub fn CubeVolume(size: int) -> (volume: int)

+    requires(size > 0)

+    ensures(volume == size * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_238_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_238_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_238_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountNonEmptySubstrings(s: String) -> (count: int)

+pub fn count_non_empty_substrings(s: &str) -> (count: i32)

     ensures count >= 0,

-            count == (s.len() * (s.len() + 1)) / 2

+    ensures count == (s.len() * (s.len() + 1)) / 2,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_240_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_240_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_240_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceLastElement(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

-    requires first.len() > 0

-    ensures result.len() == first.len() - 1 + second.len(),

-            forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

-            forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1]

+pub fn replace_last_element(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

+    requires

+        first.len() > 0,

+    ensures

+        result.len() == first.len() - 1 + second.len(),

+        forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

+        forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_242_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_242_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_242_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountCharacters(s: String) -> (count: int)

-    ensures count >= 0,

-            count == s.len()

+pub fn count_characters(s: &str) -> (count: i32)

+    ensures(count >= 0),

+    ensures(count == s.len()),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_251_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_251_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_251_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn InsertBeforeEach(s: Seq<String>, x: String) -> (v: Seq<String>)

-    ensures v.len() == 2 * s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[2*i] == x and v[2*i + 1] == s[i]

+pub fn insert_before_each(s: Seq<String>, x: String) -> (v: Seq<String>)

+    ensures(v.len() == 2 * s.len())

+    ensures(forall|i: int| 0 <= i < s.len() ==> v[2*i] == x && v[2*i + 1] == s[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_257_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_257_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_257_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(a: int, b: int) -> (result: Seq<int>)

-    ensures result.len() == 2,

-            result[0] == b,

-            result[1] == a

+pub fn swap(a: int, b: int) -> (result: Seq<int>)

+    ensures

+        result.len() == 2,

+        result[0] == b,

+        result[1] == a,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_261_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_261_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_261_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivision(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_division(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_262_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_262_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_262_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitArray(arr: Vec<int>, L: int) -> firstPart: Seq<int>, secondPart: Seq<int>

+pub fn SplitArray(arr: &[int], L: int) -> (firstPart: Seq<int>, secondPart: Seq<int>)

     requires 0 <= L <= arr.len()

-    ensures firstPart.len() == L,

-            secondPart.len() == arr.len() - L,

-            firstPart + secondPart == arr[..]

+    ensures |firstPart| == L

+    ensures |secondPart| == arr.len() - L

+    ensures firstPart + secondPart == arr@

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_264_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_264_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_264_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DogYears(humanYears: int) -> (dogYears: int)

-    requires humanYears >= 0

-    ensures dogYears == 7 * humanYears

+pub fn DogYears(humanYears: int) -> (dogYears: int)

+    requires(humanYears >= 0)

+    ensures(dogYears == 7 * humanYears)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_266_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_266_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_266_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LateralSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 4 * size * size

+pub fn LateralSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 4 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_267_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_267_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_267_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfSquaresOfFirstNOddNumbers(n: int) -> (sum: int)

-    requires n >= 0

-    ensures sum == (n * (2 * n - 1) * (2 * n + 1)) / 3

+pub fn sum_of_squares_of_first_n_odd_numbers(n: int) -> (sum: int)

+    requires(n >= 0)

+    ensures(sum == (n * (2 * n - 1) * (2 * n + 1)) / 3)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_268_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_268_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_268_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StarNumber(n: int) -> (star: int)

+pub fn star_number(n: int) -> (star: int)

     requires n >= 0

     ensures star == 6 * n * (n - 1) + 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_269_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_269_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_269_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AsciiValue(c: char) -> (ascii: int)

-    ensures ascii == c as int

+pub fn ascii_value(c: char) -> (ascii: i32)

+    ensures ascii == c as i32

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_273_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_273_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_273_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SubtractSequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn subtract_sequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_279_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_279_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_279_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthDecagonalNumber(n: int) -> (decagonal: int)

-    requires n >= 0

-    ensures decagonal == 4 * n * n - 3 * n

+pub fn NthDecagonalNumber(n: int) -> (decagonal: int)

+    requires(n >= 0)

+    ensures(decagonal == 4 * n * n - 3 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_282_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_282_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_282_spec.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseSubtraction(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len()

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn element_wise_subtraction(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_284_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_284_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_284_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllElementsEqual(a: Vec<int>, n: int) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> a[i] == n,

-            !result ==> exists|i: int| 0 <= i < a.len() and a[i] != n

+pub fn all_elements_equal(a: &[i32], n: i32) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: usize| 0 <= i < a.len() ==> a[i] == n)

+    ensures(!result ==> exists|i: usize| 0 <= i < a.len() && a[i] != n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_290_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_290_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_290_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxLengthList(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

-    requires lists.len() > 0

-    ensures forall|l: int| l in lists ==> l.len() <= maxList.len(),

-            maxList in lists

+pub fn max_length_list(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

+    requires(lists.len() > 0)

+    ensures(forall|l: Seq<int>| lists.contains(l) ==> l.len() <= maxList.len())

+    ensures(lists.contains(maxList))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_292_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_292_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_292_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(a: int, b: int) -> (result: int)

-    requires b != 0

-    ensures result == a / b

+pub fn quotient(a: int, b: int) -> (result: int)

+    requires(b != 0)

+    ensures(result == a / b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_304_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_304_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_304_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementAtIndexAfterRotation(l: Seq<int>, n: int, index: int) -> (element: int)

-    requires n >= 0,

-             0 <= index < l.len()

-    ensures element == l[(index - n + l.len()) % l.len()]

+pub fn element_at_index_after_rotation(l: Seq<int>, n: int, index: int) -> (element: int)

+    requires 

+        n >= 0,

+        0 <= index < l.len(),

+    ensures |element: int|

+        element == l[(index - n + l.len()) % l.len()],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_307_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_307_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_307_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DeepCopySeq(s: Seq<int>) -> (copy: Seq<int>)

-    ensures copy.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i]

+pub fn deep_copy_seq(s: Seq<int>) -> (copy: Seq<int>)

+    ensures

+        copy.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_309_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_309_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_309_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (maxValue: int)

-    ensures maxValue == a or maxValue == b,

-            maxValue >= a and maxValue >= b

+pub fn Max(a: int, b: int) -> (maxValue: int)

+    ensures(maxValue == a || maxValue == b)

+    ensures(maxValue >= a && maxValue >= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_310_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_310_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_310_spec.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ToCharArray(s: String) -> (a: Vec<char>)

-    ensures a.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> a[i] == s[i]

+pub fn to_char_array(s: &str) -> Vec<char>

+    requires(true)

+    ensures(|result: Vec<char>| result.len() == s.len())

+    ensures(|result: Vec<char>| forall|i: usize| 0 <= i < s.len() ==> result[i] == s.chars().nth(i).unwrap())

 {

-}

-

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_396_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_396_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_396_spec.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StartAndEndWithSameChar(s: String) -> (result: bool)

-    requires s.len() > 0

-    ensures result <==> s[0] == s[s.len() - 1]

+pub fn start_and_end_with_same_char(s: &str) -> (result: bool)

+    requires

+        s.len() > 0,

+    ensures

+        result <==> s@[0] == s@[s@.len() - 1],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_397_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_397_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_397_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianOfThree(a: int, b: int, c: int) -> (median: int)

-    ensures median == a | median == b .len()| median == c,

-            (median >= a and median <= b) | (median >= b and median <= a) .len() (median >= a and median <= c) .len() (median >= c and median <= a) .len() (median >= b and median <= c) .len()| (median >= c and median <= b)

+pub fn median_of_three(a: int, b: int, c: int) -> (median: int)

+    ensures(median == a || median == b || median == c)

+    ensures((median >= a && median <= b) || (median >= b && median <= a) || (median >= a && median <= c) || (median >= c && median <= a) || (median >= b && median <= c) || (median >= c && median <= b))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_399_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_399_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_399_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BitwiseXOR(a: Seq<bv32>, b: Seq<bv32>) -> (result: Seq<bv32>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i]

+pub fn bitwise_xor(a: Seq<u32>, b: Seq<u32>) -> (result: Seq<u32>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<u32>| result.len() == a.len())

+    ensures(|result: Seq<u32>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_3_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_3_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsNonPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (exists|k: int| 2 <= k < n and n % k == 0)

+pub fn is_non_prime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (exists|k: int| 2 <= k < n && n % k == 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_401_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_401_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_401_spec.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IndexWiseAddition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

-    requires a.len() > 0 and b.len() > 0,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len(),

-            forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j]

+pub fn index_wise_addition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

+    requires(a.len() > 0 && b.len() > 0)

+    requires(a.len() == b.len())

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len())

+    ensures(result.len() == a.len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_404_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_404_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_404_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(a: int, b: int) -> (minValue: int)

-    ensures minValue == a or minValue == b,

-            minValue <= a and minValue <= b

+pub fn Min(a: int, b: int) -> (minValue: int)

+    ensures(minValue == a || minValue == b)

+    ensures(minValue <= a && minValue <= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_406_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_406_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_406_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsOdd(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 1

+pub fn is_odd(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_412_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_412_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_412_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

+pub fn remove_odd_numbers(arr: &[int]) -> (even_list: Vec<int>)

+    ensures

+        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i]) && arr@.contains(even_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_even(arr[i]) ==> even_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_414_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_414_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_414_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AnyValueExists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < seq1.len() and seq1[i] in seq2)

+pub fn any_value_exists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < seq1.len() && seq2.contains(seq1[i])))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_424_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_424_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_424_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ExtractRearChars(l: Seq<String>) -> (r: Seq<char>)

-    requires forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]

+pub fn extract_rear_chars(l: Seq<Seq<char>>) -> (r: Seq<char>)

+    requires(

+        forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

+    )

+    ensures(|r: Seq<char>|

+        r.len() == l.len() &&

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_426_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_426_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_426_spec.rs
@@ -1,13 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 != 0

 }

 

+pub fn filter_odd_numbers(arr: &[i32]) -> Vec<i32>

+    ensures(forall|i: int| 0 <= i < result.len() ==> is_odd(result[i] as int) && arr@.contains(result[i]))

+    ensures(forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> result@.contains(arr[i]))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_431_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_431_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_431_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasCommonElement(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    requires a != null and b != null

-    ensures result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() and a[i] == b[j],

-            !result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() ==> a[i] != b[j]

+pub fn HasCommonElement(a: &[i32], b: &[i32]) -> (result: bool)

+    requires(

+        true

+    )

+    ensures(|result: bool|

+        result ==> exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i as usize] == b[j as usize]

+    )

+    ensures(|result: bool|

+        !result ==> forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i as usize] != b[j as usize]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_432_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_432_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_432_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianLength(a: int, b: int) -> (median: int)

-    requires a > 0 and b > 0

-    ensures median == (a + b) / 2

+pub fn median_length(a: i32, b: i32) -> (median: i32)

+    requires(a > 0 && b > 0)

+    ensures(median == (a + b) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_433_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_433_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_433_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsGreater(n: int, a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i],

-            !result ==> exists|i: int| 0 <= i < a.len() and n <= a[i]

+pub fn is_greater(n: int, a: &[int]) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i])

+    ensures(!result ==> exists|i: int| 0 <= i < a.len() && n <= a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_435_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_435_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_435_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastDigit(n: int) -> (d: int)

+pub fn last_digit(n: int) -> (d: int)

     requires n >= 0

-    ensures 0 <= d < 10,

-            n % 10 == d

+    ensures 0 <= d < 10

+    ensures n % 10 == d

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_436_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_436_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_436_spec.rs
@@ -1,13 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsNegative(n: int) -> bool {

+spec fn is_negative(n: int) -> bool {

     n < 0

 }

 

+pub fn find_negative_numbers(arr: &[i32]) -> (negative_list: Vec<i32>)

+    ensures

+

+        forall|i: int| 0 <= i < negative_list.len() ==> is_negative(negative_list[i] as int) && arr@.contains(negative_list[i]),

+

+        forall|i: int| 0 <= i < arr.len() && is_negative(arr[i] as int) ==> negative_list@.contains(arr[i])

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_441_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_441_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_441_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 6 * size * size

+pub fn CubeSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 6 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_445_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_445_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_445_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultiplyElements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i]

+pub fn multiply_elements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_447_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_447_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_447_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeElements(a: Vec<int>) -> (cubed: Vec<int>)

-    ensures cubed.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i]

+pub fn CubeElements(a: &[i32]) -> (cubed: Vec<i32>)

+    requires(true)

+    ensures(|cubed: Vec<i32>| cubed.len() == a.len())

+    ensures(|cubed: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_452_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_452_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_452_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) and (costPrice <= sellingPrice ==> loss == 0)

+pub fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

+    requires(costPrice >= 0 && sellingPrice >= 0)

+    ensures((costPrice > sellingPrice) ==> (loss == costPrice - sellingPrice) && (costPrice <= sellingPrice) ==> (loss == 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_454_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_454_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_454_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsZ(s: String) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < s.len() and (s[i] == 'z' or s[i] == 'Z'))

+pub fn contains_z(s: &str) -> (result: bool)

+    ensures(result <==> (exists|i: usize| 0 <= i < s.len() && (s[i] == 'z' || s[i] == 'Z')))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_455_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_455_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_455_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MonthHas31Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month in

+pub fn MonthHas31Days(month: int) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_457_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_457_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_457_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinLengthSublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

-    requires s.len() > 0

-    ensures minSublist in s,

-            forall|sublist: int| sublist in s ==> minSublist.len() <= sublist.len()

+pub fn min_length_sublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

+    requires(s.len() > 0)

+    ensures(s.contains(minSublist))

+    ensures(forall|sublist: Seq<int>| s.contains(sublist) ==> minSublist.len() <= sublist.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_458_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_458_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_458_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RectangleArea(length: int, width: int) -> (area: int)

-    requires length > 0,

-             width > 0

-    ensures area == length * width

+pub fn rectangle_area(length: int, width: int) -> (area: int)

+    requires(length > 0)

+    requires(width > 0)

+    ensures(area == length * width)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_460_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_460_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_460_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn GetFirstElements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

-    requires forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0

-    ensures result.len() == lst.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0]

+pub fn get_first_elements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

+    requires(

+        forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0

+    )

+    ensures(|result: Seq<int>| 

+        result.len() == lst.len() &&

+        forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_461_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_461_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_461_spec.rs
@@ -1,19 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub open spec fn is_upper_case(c: char) -> bool

+{

     65 <= c as int <= 90

 }

 

-fn CountUppercase(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsUpperCase(s[i])|

+

+

+pub fn count_uppercase(s: &str) -> (count: i32)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s@.len()).filter(|i: int| is_upper_case(s@[i]))).len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_470_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_470_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_470_spec.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PairwiseAddition(a: Vec<int>) -> (result: Vec<int>)

-    requires a != null,

-             a.len() % 2 == 0

-    ensures result != null,

-            result.len() == a.len() / 2,

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

+pub fn PairwiseAddition(a: &[i32]) -> Vec<i32>

+    requires a.len() % 2 == 0

+    ensures |result: Vec<i32>| result.len() == a.len() / 2

+    ensures |result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_472_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_472_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_472_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsConsecutiveNumbers(a: Vec<int>) -> (result: bool)

-    requires a.len()>0

-    ensures result <==> (exists|i: int| 0 <= i < a.len() - 1 and a[i] + 1 == a[i + 1])

+pub fn contains_consecutive_numbers(a: &[i32]) -> (result: bool)

+    requires(a.len() > 0)

+    ensures(result <==> (exists|i: usize| 0 <= i < a.len() - 1 && a[i] + 1 == a[i + 1]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_474_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_474_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_474_spec.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceChars(s: String, oldChar: char, newChar: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == oldChar ==> v[i] == newChar) and (s[i] != oldChar ==> v[i] == s[i])

+pub fn replace_chars(s: &str, old_char: char, new_char: char) -> (v: String)

+    requires(s.len() <= usize::MAX)

+    ensures(|v: String| v.len() == s.len())

+    ensures(|v: String| forall|i: usize| 0 <= i < s.len() ==> 

+        (s.get_char(i) == old_char ==> v.get_char(i) == new_char) && 

+        (s.get_char(i) != old_char ==> v.get_char(i) == s.get_char(i)))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_476_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_476_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_476_spec.rs
@@ -1,15 +1,35 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn SumMinMax(a: Vec<int>) -> (sum: int)

-    requires a.len() > 0

-    ensures sum == Max(a[..]) + Min(a[..])

+pub fn SumMinMax(a: &[i32]) -> (sum: i32)

+    requires

+        a.len() > 0,

+    ensures

+        sum == Max(a@) + Min(a@),

 {

 }

 

+pub open spec fn Min(a: Seq<i32>) -> i32

+    recommends

+        a.len() > 0,

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let minPrefix = Min(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] <= minPrefix { a[a.len() - 1] } else { Min(a.subrange(0, a.len() - 1)) }

+    }

+}

+

+pub open spec fn Max(a: Seq<i32>) -> i32

+    recommends

+        a.len() > 0,

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let maxPrefix = Max(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] >= maxPrefix { a[a.len() - 1] } else { Max(a.subrange(0, a.len() - 1)) }

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_477_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_477_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_477_spec.rs
@@ -1,22 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub closed spec fn is_upper_case(c: char) -> bool

+{

     65 <= c as int <= 90

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub closed spec fn is_upper_lower_pair(C: char, c: char) -> bool

+{

     (C as int) == (c as int) - 32

 }

 

-fn ToLowercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

+

+pub closed spec fn shift32(c: char) -> char

 {

+    ((c as int + 32) % 128) as char

 }

 

+

+pub fn to_lowercase(s: &str) -> (v: String)

+    ensures

+        v@.len() == s@.len(),

+        forall|i: int| 0 <= i < s@.len() ==> 

+            if is_upper_case(s@[i]) { 

+                is_upper_lower_pair(s@[i], v@[i]) 

+            } else { 

+                v@[i] == s@[i] 

+            }

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_554_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_554_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_554_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 == 1

 }

 

+pub fn find_odd_numbers(arr: &[i32]) -> (odd_list: Vec<i32>)

+    ensures

+        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i] as int) && arr@.contains(odd_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> odd_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_555_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_555_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_555_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceSumCubesAndSumNumbers(n: int) -> (diff: int)

-    requires n >= 0

-    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2

+pub fn difference_sum_cubes_and_sum_numbers(n: int) -> (diff: int)

+    requires(n >= 0)

+    ensures(diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_557_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_557_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_557_spec.rs
@@ -1,28 +1,49 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub open spec fn IsLowerCase(c: char) -> bool

+{

     97 <= c as int <= 122

 }

-spec fn IsUpperCase(c: char) -> bool {

+

+

+pub open spec fn IsUpperCase(c: char) -> bool

+{

     65 <= c as int <= 90

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+

+pub open spec fn IsLowerUpperPair(c: char, C: char) -> bool

+{

     (c as int) == (C as int) + 32

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub open spec fn IsUpperLowerPair(C: char, c: char) -> bool

+{

     (C as int) == (c as int) - 32

 }

 

-fn ToggleCase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

+

+pub open spec fn ShiftMinus32(c: char) -> char

 {

+    ((c as int - 32) % 128) as char

 }

 

+

+pub open spec fn Shift32(c: char) -> char

+{

+    ((c as int + 32) % 128) as char

+}

+

+

+pub fn ToggleCase(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if IsLowerCase(s[i as usize]) then 

+                IsLowerUpperPair(s[i as usize], v[i as usize]) 

+            else if IsUpperCase(s[i as usize]) then 

+                IsUpperLowerPair(s[i as usize], v[i as usize]) 

+            else 

+                v[i as usize] == s[i as usize]

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_565_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_565_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_565_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitStringIntoChars(s: String) -> (v: Seq<char>)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[i] == s[i]

+pub fn split_string_into_chars(s: &str) -> (v: Vec<char>)

+    ensures

+        v.len() == s.len(),

+        forall|i: usize| 0 <= i < s.len() ==> v[i] == s.chars().nth(i).unwrap(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_566_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_566_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_566_spec.rs
@@ -1,16 +1,61 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfDigits(number: nat) -> (sum: nat)

-    requires number >= 0

-    ensures sum >= 0,

-            sum == SumDigits(number)

+pub fn SumOfDigits(number: nat) -> (sum: nat)

+    requires(number >= 0)

+    ensures(sum >= 0)

+    ensures(sum == SumDigits(number))

 {

 }

 

+proof fn X(x: nat)

+    ensures(Power10(NumberOfDigits(x)) > x)

+{

+}

+

+proof fn NumberIdentity(number: nat, pmax: nat)

+    requires(pmax == Power10(NumberOfDigits(number)))

+    ensures(number == number % pmax)

+{

+}

+

+proof fn InIntValues(n: nat)

+    ensures(IntValues(n).contains(0))

+    ensures(IntValues(n).contains(n))

+    ensures(IntValues(n).contains(n/10))

+{

+}

+

+spec fn IntValues(n: int) -> (r: Seq<int>)

+    requires(n >= 0)

+    ensures(r.contains(0))

+    ensures(r.contains(n))

+    ensures(r.contains(n/10))

+{

+}

+

+spec fn Power10(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(n > 0 ==> r % 10 == 0)

+{

+}

+

+spec fn NumberToSeq(number: int) -> Seq<int>

+    requires(number >= 0)

+{

+}

+

+spec fn Sum(digits: Seq<int>) -> int

+{

+}

+

+spec fn SumDigits(n: nat) -> nat

+{

+}

+

+spec fn SumDigitsRecursive(n: nat, p: nat) -> (r: nat)

+{

+}

+

+spec fn NumberOfDigits(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(r == 1 <==> (0 <= n <= 9))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_567_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_567_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_567_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSorted(a: Vec<int>) -> (sorted: bool)

-    requires a.len() > 0

-    ensures sorted <== forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            !sorted ==> exists|i: int, j: int| 0 <= i < j < a.len() and a[i] > a[j]

+pub fn is_sorted(a: &[i32]) -> (sorted: bool)

+    requires(a.len() > 0)

+    ensures(sorted <==> (forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]))

+    ensures(!sorted ==> (exists|i: usize, j: usize| 0 <= i < j < a.len() && a[i] > a[j]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_572_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_572_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_572_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(a: Vec<int>) -> (result: Seq<int>)

-    requires a != null

-    ensures forall|x: int| x in result <==> exists|i: int| 0 <= i < a.len() and a[i] == x,

-            forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]

+pub fn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)

+    requires(true)

+    ensures(forall|x: i32| result@.contains(x) <==> exists|i: usize| 0 <= i < a.len() && a[i] == x)

+    ensures(forall|i: usize, j: usize| 0 <= i < j < result@.len() ==> result@[i] != result@[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_573_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_573_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_573_spec.rs
@@ -1,14 +1,36 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn UniqueProduct(arr: Vec<int>) -> (product: int)

-    ensures product == SetProduct((set i | 0 <= i < arr.len() :: arr[i]))

+pub fn UniqueProduct(arr: &[int]) -> (product: int)

+    ensures product == SetProduct(Set::new(|i: int| 0 <= i < arr.len() ==> arr[i as usize]))

 {

 }

 

+spec fn SetProduct(s: Set<int>) -> int

+    decreases s.len()

+{

+    if s.is_empty() {

+        1

+    } else {

+        let x = s.choose();

+        x * SetProduct(s.remove(x))

+    }

+}

+

+proof fn SetProductLemma(s: Set<int>, x: int)

+    requires x in s

+    ensures SetProduct(s.remove(x)) * x == SetProduct(s)

+    decreases s.len()

+{

+    if !s.is_empty() {

+        let y = s.choose();

+        if y == x {

+        } else {

+            SetProductLemma(s.remove(y), x);

+            SetProductLemma(s.remove(x), y);

+        }

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_576_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_576_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_576_spec.rs
@@ -1,14 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)

-    ensures true <== (exists|i: int| 0 <= i <= main.len() - sub.len() and sub == main[i..i + sub.len()])

+pub fn is_sublist(sub: Vec<i32>, main: Vec<i32>) -> (result: bool)

+    ensures(

+        true == exists|i: usize| 0 <= i && i <= main.len() - sub.len() && sub == main.subrange(i, i + sub.len())

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_577_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_577_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_577_spec.rs
@@ -1,15 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+fn Factorial(n: int) -> int

+    requires n >= 0

+    ensures 0 <= Factorial(n)

+    {

+        if n == 0 { 1 }

+        else { n * Factorial(n-1) }

+    }

 

-verus! {

 

-fn FactorialOfLastDigit(n: int) -> (fact: int)

-    requires n >= 0

-    ensures fact == Factorial(n % 10)

+

+pub fn FactorialOfLastDigit(n: int) -> int

+    requires(n >= 0)

+    ensures(|fact: int| fact == Factorial(n % 10))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_578_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_578_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_578_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

-    requires s1.len() == s2.len() and s2.len() == s3.len()

-    ensures r.len() == 3 * s1.len(),

-            forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] and r[3*i + 1] == s2[i] and r[3*i + 2] == s3[i]

+pub fn interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

+    requires(s1.len() == s2.len() && s2.len() == s3.len())

+    ensures(|result: Seq<int>| result.len() == 3 * s1.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < s1.len() ==> result[3*i] == s1[i] && result[3*i + 1] == s2[i] && result[3*i + 2] == s3[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_581_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_581_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_581_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

-    requires baseEdge > 0,

-             height > 0

-    ensures area == baseEdge * baseEdge + 2 * baseEdge * height

+pub fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

+    requires(baseEdge > 0)

+    requires(height > 0)

+    ensures(|area: int| area == baseEdge * baseEdge + 2 * baseEdge * height)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_586_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_586_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_586_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitAndAppend(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0 and n < l.len()

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i + n) % l.len()]

+pub fn split_and_append(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0 && n < l.len())

+    ensures(|r: Seq<int>| r.len() == l.len())

+    ensures(|r: Seq<int>| forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i + n) % l.len()])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_587_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_587_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_587_spec.rs
@@ -1,16 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArrayToSeq(a: Vec<int>) -> (s: Seq<int>)

-    requires a != null

-    ensures s.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> s[i] == a[i]

+pub fn array_to_seq(a: &[i32]) -> (s: Vec<i32>)

+    requires(

+        true

+    )

+    ensures(|s: Vec<i32>| 

+        s.len() == a.len() &&

+        forall|i: usize| 0 <= i < a.len() ==> s[i] == a[i]

+    )

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_588_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_588_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_588_spec.rs
@@ -1,15 +1,41 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn DifferenceMinMax(a: Vec<int>) -> (diff: int)

-    requires a.len() > 0

-    ensures diff == Max(a[..]) - Min(a[..])

+pub fn difference_min_max(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 0)

+    ensures(diff == max(a@) - min(a@))

 {

 }

 

+pub open spec fn min(a: Seq<i32>) -> i32

+    recommends(a.len() > 0)

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let min_prefix = min(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] <= min_prefix {

+            a[a.len() - 1]

+        } else {

+            min(a.subrange(0, a.len() - 1))

+        }

+    }

+}

+

+pub open spec fn max(a: Seq<i32>) -> i32

+    recommends(a.len() > 0)

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let max_prefix = max(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] >= max_prefix {

+            a[a.len() - 1]

+        } else {

+            max(a.subrange(0, a.len() - 1))

+        }

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_58_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_58_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_58_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOppositeSign(a: int, b: int) -> (result: bool)

-    ensures result <==> (a < 0 and b > 0) or (a > 0 and b < 0)

+pub fn has_opposite_sign(a: i32, b: i32) -> (result: bool)

+    ensures(result <==> (a < 0 && b > 0) || (a > 0 && b < 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_594_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_594_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_594_spec.rs
@@ -1,25 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+spec fn is_odd(n: int) -> bool

+{

     n % 2 != 0

 }

 

-fn FirstEvenOddDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() >= 2,

-             exists|i: int| 0 <= i < a.len() and IsEven(a[i]),

-             exists|i: int| 0 <= i < a.len() and IsOdd(a[i])

-    ensures exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and IsEven(a[i]) and IsOdd(a[j]) and diff == a[i] - a[j] and 

-        (forall|k: int| 0 <= k < i ==> IsOdd(a[k])) and (forall|k: int| 0 <= k < j ==> IsEven(a[k]))

+

+pub fn first_even_odd_difference(a: &[int]) -> (diff: int)

+    requires

+        a.len() >= 2,

+        exists|i: int| 0 <= i < a.len() && is_even(a[i as usize]),

+        exists|i: int| 0 <= i < a.len() && is_odd(a[i as usize]),

+    ensures

+        exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && is_even(a[i as usize]) && is_odd(a[j as usize]) && diff == a[i as usize] - a[j as usize] && 

+            (forall|k: int| 0 <= k < i ==> is_odd(a[k as usize])) && (forall|k: int| 0 <= k < j ==> is_even(a[k as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_598_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_598_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_598_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsArmstrong(n: int) -> (result: bool)

-    requires 100 <= n < 1000

-    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))

+pub fn IsArmstrong(n: int) -> bool

+    requires(100 <= n < 1000)

+    ensures(|result: bool| result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10))))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_59_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_59_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_59_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

-    requires n >= 0

-    ensures octagonalNumber == n * (3 * n - 2)

+pub fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

+    requires(n >= 0)

+    ensures(octagonalNumber == n * (3 * n - 2))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_600_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_600_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_600_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsEven(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 0

+pub fn is_even(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_602_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_602_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_602_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstRepeatedChar(s: String) -> found: bool, c: char

-    ensures found ==> exists|i: int, j: int| 0 <= i < j < s.len() and s[i] == s[j] and s[i] == c and (forall|k: int, l: int| 0 <= k < l < j and s[k] == s[l] ==> k >= i),

-            !found ==> (forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j])

+pub fn find_first_repeated_char(s: &str) -> (found: bool, c: char)

+    ensures(found ==> exists|i: usize, j: usize| 0 <= i < j < s.len() && s[i] == s[j] && s[i] == c && (forall|k: usize, l: usize| 0 <= k < l < j && s[k] == s[l] ==> k >= i))

+    ensures(!found ==> (forall|i: usize, j: usize| 0 <= i < j < s.len() ==> s[i] != s[j]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_603_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_603_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_603_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LucidNumbers(n: int) -> (lucid: Seq<int>)

-    requires n >= 0

-    ensures forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0,

-            forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n,

-            forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j]

+pub fn LucidNumbers(n: int) -> (lucid: Seq<int>)

+    requires(n >= 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n)

+    ensures(forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_605_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_605_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_605_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (forall|k: int| 2 <= k < n ==> n % k != 0)

+pub fn IsPrime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (forall|k: int| 2 <= k < n >>= n % k != 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_610_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_610_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_610_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveElement(s: Vec<int>, k: int) -> (v: Vec<int>)

-    requires 0 <= k < s.len()

-    ensures v.len() == s.len() - 1,

-            forall|i: int| 0 <= i < k ==> v[i] == s[i],

-            forall|i: int| k <= i < v.len() ==> v[i] == s[i + 1]

+pub fn remove_element(s: &[i32], k: usize) -> Vec<i32>

+    requires(k < s.len())

+    ensures(|result: Vec<i32>| result.len() == s.len() - 1)

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < k ==> result[i] == s[i])

+    ensures(|result: Vec<i32>| forall|i: usize| k <= i < result.len() ==> result[i] == s[i + 1])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_616_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_616_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_616_spec.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseModulo(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i]

+pub fn element_wise_modulo(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires

+        a.len() == b.len(),

+        forall|i: usize| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        |result: Vec<i32>| 

+            result.len() == a.len() &&

+            forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] % b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_618_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_618_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_618_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_divide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_61_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_61_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_61_spec.rs
@@ -1,18 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn CountSubstringsWithSumOfDigitsEqualToLength(s: String) -> (count: int)

+

+pub fn count_substrings_with_sum_of_digits_equal_to_length(s: &str) -> (count: i32)

     ensures count >= 0

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_622_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_622_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_622_spec.rs
@@ -1,19 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMedian(a: Vec<int>, b: Vec<int>) -> (median: int)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             a.len() > 0,

-             forall|i: int| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1],

-             forall|i: int| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1]

-    ensures median == if (a.len() % 2 == 0) then (a[a.len() / 2 - 1] + b[0]) / 2 else a[a.len() / 2]

+pub fn find_median(a: &[i32], b: &[i32]) -> i32

+    requires(

+        a.len() == b.len() &&

+        a.len() > 0 &&

+        forall|i: usize| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1] &&

+        forall|i: usize| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1]

+    )

+    ensures(|median: i32|

+        median == if a.len() % 2 == 0 { (a[a.len() / 2 - 1] + b[0]) / 2 } else { a[a.len() / 2] }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_623_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_623_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_623_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PowerOfListElements(l: Seq<int>, n: int) -> (result: Seq<int>)

-    requires n >= 0

-    ensures result.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> result[i] == Power(l[i], n)

+pub fn power_of_list_elements(l: Seq<int>, n: int) -> (result: Seq<int>)

+    requires(n >= 0)

+    ensures(|result| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> result[i] == power(l[i], n))

 {

 }

 

+spec fn power(base: int, exponent: int) -> int

+    recommends(exponent >= 0)

+{

+    if exponent == 0 { 1 } else { base * power(base, exponent - 1) }

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_624_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_624_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_624_spec.rs
@@ -1,22 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub open spec fn is_lower_case(c: char) -> bool

+{

     97 <= c as int <= 122

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+

+pub open spec fn is_lower_upper_pair(c: char, C: char) -> bool

+{

     (c as int) == (C as int) + 32

 }

 

-fn ToUppercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]

+

+pub open spec fn shift_minus32(c: char) -> char

 {

+    ((c as int - 32) % 128) as char

 }

 

+

+pub fn to_uppercase(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if is_lower_case(s@[i]) { 

+                is_lower_upper_pair(s@[i], v@[i]) 

+            } else { 

+                v@[i] == s@[i] 

+            }

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_626_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_626_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_626_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

-    requires radius > 0

-    ensures area == radius * radius

+pub fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

+    requires(radius > 0)

+    ensures(area == radius * radius)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_627_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_627_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_627_spec.rs
@@ -1,18 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestMissingNumber(s: Seq<int>) -> (v: int)

-    requires forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],

-             forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

-    ensures 0 <= v,

-            v !in s,

-            forall|k: int| 0 <= k < v ==> k in s

+pub fn smallest_missing_number(s: Seq<int>) -> (v: int)

+    requires(

+        forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]

+    ),

+    requires(

+        forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

+    ),

+    ensures(|v: int|

+        0 <= v

+    ),

+    ensures(|v: int|

+        !(s.contains(v))

+    ),

+    ensures(|v: int|

+        forall|k: int| 0 <= k < v ==> s.contains(k)

+    ),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_629_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_629_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_629_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

+pub fn find_even_numbers(arr: &[i32]) -> (even_list: Vec<i32>)

+    ensures

+        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && arr@.contains(even_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> even_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_62_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_62_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_62_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindSmallest(s: Vec<int>) -> (min: int)

+pub fn find_smallest(s: &[i32]) -> (min: i32)

     requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> min <= s[i],

-            exists|i: int| 0 <= i < s.len() and min == s[i]

+    ensures forall|i: usize| 0 <= i < s.len() ==> min <= s[i]

+    ensures exists|i: usize| 0 <= i < s.len() && min == s[i]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_637_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_637_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_637_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures result <==> costPrice == sellingPrice

+pub fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

+    requires(costPrice >= 0 && sellingPrice >= 0)

+    ensures(result <==> costPrice == sellingPrice)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_641_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_641_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_641_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthNonagonalNumber(n: int) -> (number: int)

-    requires n >= 0

-    ensures number == n * (7 * n - 5) / 2

+pub fn NthNonagonalNumber(n: int) -> (number: int)

+    requires(n >= 0)

+    ensures(number == n * (7 * n - 5) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_69_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_69_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_69_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsSequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < list.len() and sub == list[i])

+pub fn contains_sequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < list.len() && sub == list[i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_70_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_70_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_70_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllSequencesEqualLength(sequences: Seq<Seq<int>>) -> (result: bool)

-    ensures result <==> forall|i: int, j: int| 0 <= i < sequences.len() and 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len()

+pub fn AllSequencesEqualLength(sequences: Seq<Seq<int>>) -> (result: bool)

+    ensures(result <==> forall|i: int, j: int| 0 <= i < sequences.len() && 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_728_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_728_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_728_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddLists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i]

+pub fn add_lists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_732_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_732_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_732_spec.rs
@@ -1,19 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSpaceCommaDot(c: char) -> bool {

-    c == ' ' | c == ',' .len()| c == '.'

+pub open spec fn is_space_comma_dot(c: char) -> bool

+{

+    c == ' ' || c == ',' || c == '.'

 }

 

-fn ReplaceWithColon(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') and (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])

+

+

+pub fn replace_with_colon(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> (is_space_comma_dot(s[i as usize]) ==> v[i as usize] == ':') && (!is_space_comma_dot(s[i as usize]) ==> v[i as usize] == s[i as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_733_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_733_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_733_spec.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstOccurrence(arr: Vec<int>, target: int) -> (index: int)

-    requires arr != null,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures 0 <= index < arr.len() ==> arr[index] == target,

-            index == -1 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] != target,

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn find_first_occurrence(arr: &[i32], target: i32) -> (index: i32)

+    requires(forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j])

+    ensures(|index: i32| 0 <= index < arr.len() ==> arr[index as usize] == target)

+    ensures(|index: i32| index == -1 ==> forall|i: usize| 0 <= i < arr.len() ==> arr[i] != target)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_741_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_741_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_741_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllCharactersSame(s: String) -> (result: bool)

-    ensures result ==> forall|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() ==> s[i] == s[j],

-            !result ==> (s.len() > 1) and (exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] != s[j])

+pub fn all_characters_same(s: &str) -> (result: bool)

+    ensures(result ==> forall|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() ==> s.as_bytes()[i] == s.as_bytes()[j])

+    ensures(!result ==> (s.len() > 1) && (exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s.as_bytes()[i] != s.as_bytes()[j]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_743_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_743_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_743_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateRight(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i - n + l.len()) % l.len()]

+pub fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0)

+    ensures(|r| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_750_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_750_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_750_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddTupleToList(l: seq<(int, int)>, t: (int, int)) -> r: seq<(int, int)>

-    ensures r.len() == l.len() + 1,

-            r[r.len() - 1] == t,

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]

+pub fn AddTupleToList(l: Seq<(int, int)>, t: (int, int)) -> (r: Seq<(int, int)>)

+    ensures

+        r.len() == l.len() + 1,

+        r[r.len() - 1] == t,

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_751_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_751_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_751_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMinHeap(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] and (2*i + 2 == a.len() or a[i] <= a[2*i + 2]),

-            !result ==> exists|i: int| 0 <= i < a.len() / 2 and (a[i] > a[2*i + 1] or (2*i + 2 != a.len() and a[i] > a[2*i + 2]))

+pub fn is_min_heap(a: &[i32]) -> bool

+    requires(true)

+    ensures(|result: bool| result ==> forall|i: usize| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.len() || a[i] <= a[2*i + 2]))

+    ensures(|result: bool| !result ==> exists|i: usize| 0 <= i < a.len() / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.len() && a[i] > a[2*i + 2])))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_755_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_755_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_755_spec.rs
@@ -1,18 +1,26 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SecondSmallest(s: Vec<int>) -> (secondSmallest: int)

-    requires s.len() >= 2

-

-             exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] != s[i]

-    ensures exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] == secondSmallest,

-            forall|k: int|  0 <= k < s.len() and s[k] != min(s[..])  ==>  s[k] >= secondSmallest

+pub fn min_pair(s: Seq<int>) -> (r: int)

+    requires

+        s.len() == 2,

+    ensures

+        s[0] <= s[1] <==> r == s[0],

+        s[0] > s[1] ==> r == s[1],

 {

 }

 

+pub fn min(s: Seq<int>) -> (r: int)

+    requires

+        s.len() >= 2,

+    ensures

+        forall|i: int| 0 <= i < s.len() ==> r <= s[i],

+{

+}

+

+pub fn second_smallest(s: &[int]) -> (second_smallest: int)

+    requires

+        s.len() >= 2,

+        exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i as int] == min(s@) && s[j as int] != s[i as int],

+    ensures

+        exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i as int] == min(s@) && s[j as int] == second_smallest,

+        forall|k: usize| 0 <= k < s.len() && s[k as int] != min(s@) ==> s[k as int] >= second_smallest,

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_759_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_759_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_759_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDecimalWithTwoPrecision(s: String) -> (result: bool)

-    ensures result ==> (exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2),

-            !result ==> !(exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2)

+pub fn is_decimal_with_two_precision(s: &str) -> (result: bool)

+    ensures(result ==> (exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

+    ensures(!result ==> !(exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_760_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_760_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_760_spec.rs
@@ -1,16 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOnlyOneDistinctElement(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] == a[j],

-            !result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and a[i] != a[j]

+pub fn has_only_one_distinct_element(a: &[i32]) -> (result: bool)

+    ensures(result ==> forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j])

+    ensures(!result ==> exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_762_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_762_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_762_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMonthWith30Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month == 4 | month == 6 .len() month == 9 .len()| month == 11

+pub fn IsMonthWith30Days(month: i32) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> (month == 4 || month == 6 || month == 9 || month == 11))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_764_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_764_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_764_spec.rs
@@ -1,19 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool

+{

     48 <= c as int <= 57

 }

 

-fn CountDigits(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsDigit(s[i])|

+

+pub fn count_digits(s: &str) -> (count: i32)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s.len() as int).filter(|i: int| is_digit(s.index(*i)))).len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_769_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_769_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_769_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

-    ensures forall|x: int| x in diff <==> (x in a and x !in b),

-            forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]

+pub fn difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

+    ensures(forall|x: int| diff.contains(x) <==> (a.contains(x) && !b.contains(x))),

+    ensures(forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_770_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_770_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_770_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfFourthPowerOfOddNumbers(n: int) -> (sum: int)

-    requires n > 0

-    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15

+pub fn SumOfFourthPowerOfOddNumbers(n: int) -> (sum: int)

+    requires(n > 0)

+    ensures(sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_775_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_775_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_775_spec.rs
@@ -1,18 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(n: int) -> bool {

+pub open spec fn IsOdd(n: int) -> bool

+{

     n % 2 == 1

 }

 

-fn IsOddAtIndexOdd(a: Vec<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (IsOdd(i) ==> IsOdd(a[i]))

+

+

+pub fn IsOddAtIndexOdd(a: &[int]) -> (result: bool)

+    ensures(result <==> forall|i: int| 0 <= i < a.len() ==> (IsOdd(i) ==> IsOdd(a[i as usize])))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_776_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_776_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_776_spec.rs
@@ -1,19 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsVowel(c: char) -> bool {

-    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'

+pub open spec fn is_vowel(c: char) -> bool {

+    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 

+    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'

 }

 

-fn CountVowelNeighbors(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 1 <= i < s.len()-1 and IsVowel(s[i-1]) and IsVowel(s[i+1]) |

+

+pub fn count_vowel_neighbors(s: &str) -> (count: i32)

+    requires(s.len() <= i32::MAX)

+    ensures(count >= 0)

+    ensures(count == Set::<int>::new(|i: int| 1 <= i < s.len() && is_vowel(s[i-1]) && is_vowel(s[i+1])).len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_77_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_77_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_77_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDivisibleBy11(n: int) -> (result: bool)

-    ensures result <==> n % 11 == 0

+pub fn is_divisible_by_11(n: int) -> (result: bool)

+    ensures(result <==> n % 11 == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_784_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_784_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_784_spec.rs
@@ -1,35 +1,56 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+spec fn is_odd(n: int) -> bool

+{

     n % 2 != 0

 }

-spec fn IsFirstEven(evenIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < evenIndex ==> IsOdd(lst[i])

-}

-spec fn IsFirstOdd(oddIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < oddIndex ==> IsEven(lst[i])

+

+

+spec fn is_first_even(even_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= even_index < lst.len(),

+        is_even(lst[even_index as int])

+{

+    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i])

 }

 

-fn FirstEvenOddIndices(lst: Seq<int>) -> evenIndex: int, oddIndex: int

-    requires lst.len() >= 2,

-             exists|i: int| 0 <= i < lst.len() and IsEven(lst[i]),

-             exists|i: int| 0 <= i < lst.len() and IsOdd(lst[i])

-    ensures 0 <= evenIndex < lst.len(),

-            0 <= oddIndex < lst.len()

 

-            that it's the first, not just any,

-            IsEven(lst[evenIndex]) and IsFirstEven(evenIndex, lst),

-            IsOdd(lst[oddIndex]) and IsFirstOdd(oddIndex, lst)

+spec fn is_first_odd(odd_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= odd_index < lst.len(),

+        is_odd(lst[odd_index as int])

+{

+    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i])

+}

+

+

+pub fn first_even_odd_indices(lst: Seq<int>) -> (even_index: int, odd_index: int)

+    requires

+        lst.len() >= 2,

+        exists|i: int| 0 <= i < lst.len() && is_even(lst[i]),

+        exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])

+    ensures

+        0 <= even_index < lst.len(),

+        0 <= odd_index < lst.len(),

+

+        is_even(lst[even_index]) && is_first_even(even_index, lst),

+        is_odd(lst[odd_index]) && is_first_odd(odd_index, lst)

 {

 }

 

+

+pub fn product_even_odd(lst: Seq<int>) -> (product: int)

+    requires

+        lst.len() >= 2,

+        exists|i: int| 0 <= i < lst.len() && is_even(lst[i]),

+        exists|i: int| 0 <= i < lst.len() && is_odd(lst[i])

+    ensures

+        exists|i: int, j: int| 0 <= i < lst.len() && is_even(lst[i]) && is_first_even(i, lst) && 

+                               0 <= j < lst.len() && is_odd(lst[j])  && is_first_odd(j, lst) && product == lst[i] * lst[j]

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_790_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_790_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_790_spec.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

-fn IsEvenAtIndexEven(lst: Seq<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < lst.len() ==> (IsEven(i) ==> IsEven(lst[i]))

+

+pub fn is_even_at_index_even(lst: Seq<int>) -> (result: bool)

+    ensures

+        result <==> forall|i: int| 0 <= i < lst.len() ==> (is_even(i) ==> is_even(lst[i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_792_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_792_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_792_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLists(lists: Seq<Seq<int>>) -> (count: int)

+pub fn count_lists(lists: Seq<Seq<int>>) -> (count: int)

     ensures count >= 0,

-            count == lists.len()

+    ensures count == lists.len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_793_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_793_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_793_spec.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastPosition(arr: Vec<int>, elem: int) -> (pos: int)

-    requires arr.len() > 0,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures pos == -1 | (0 <= pos < arr.len() and arr[pos] == elem and (pos <= arr.len() - 1 .len()| arr[pos + 1] > elem)),

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn last_position(arr: &mut [i32], elem: i32) -> (pos: i32)

+    requires(

+        arr.len() > 0,

+        forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

+    )

+    ensures(|pos: i32|

+        pos == -1 || (0 <= pos < arr.len() && arr[pos as usize] == elem && (pos >= arr.len() as i32 - 1 || arr[(pos + 1) as usize] > elem)),

+        forall|i: usize| 0 <= i < arr.len() ==> arr[i] == old(arr)[i]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_798_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_798_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_798_spec.rs
@@ -1,14 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArraySum(a: Vec<int>) -> (result: int)

-    ensures result == sumTo(a, a.len())

+spec fn sumTo(a: &[int], n: int) -> int

+    recommends

+        0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else { sumTo(a, n-1) + a[n-1] }

 }

 

+

+pub fn ArraySum(a: &[int]) -> (result: int)

+    ensures(result == sumTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_799_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_799_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_799_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateLeftBits(n: bv32, d: int) -> (result: bv32)

-    requires 0 <= d < 32

-    ensures result == ((n << d) | (n >> (32 - d)))

+pub fn rotate_left_bits(n: u32, d: int) -> (result: u32)

+    requires(0 <= d < 32)

+    ensures(result == ((n << d) | (n >> (32 - d))))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_79_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_79_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_79_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsLengthOdd(s: String) -> (result: bool)

-    ensures result <==> s.len() % 2 == 1

+pub fn is_length_odd(s: &str) -> (result: bool)

+    ensures(result <==> s.len() % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_801_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_801_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_801_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountEqualNumbers(a: int, b: int, c: int) -> (count: int)

-    ensures count >= 0 and count <= 3,

-            (count == 3) <==> (a == b and b == c),

-            (count == 2) <==> ((a == b and b != c) | (a != b and b == c) .len()| (a == c and b != c)),

-            (count == 1) <==> (a != b and b != c and a != c)

+pub fn count_equal_numbers(a: int, b: int, c: int) -> (count: int)

+    ensures(count >= 0 && count <= 3)

+    ensures((count == 3) <==> (a == b && b == c))

+    ensures((count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c)))

+    ensures((count == 1) <==> (a != b && b != c && a != c))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_803_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_803_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_803_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPerfectSquare(n: int) -> (result: bool)

-    requires n >= 0

-    ensures result == true ==> (exists i: int :: 0 <= i <= n and i * i == n),

-            result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)

+pub fn is_perfect_square(n: int) -> (result: bool)

+    requires(n >= 0)

+    ensures(result == true ==> (exists|i: int| 0 <= i <= n && i * i == n))

+    ensures(result == false ==> (forall|a: int| 0 < a*a < n ==> a*a != n))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_804_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_804_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_804_spec.rs
@@ -1,18 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

-fn IsProductEven(a: Vec<int>) -> (result: bool)

-    ensures result <==> exists|i: int| 0 <= i < a.len() and IsEven(a[i])

+pub fn is_product_even(a: &[int]) -> (result: bool)

+    ensures(result <==> exists|i: int| 0 <= i < a.len() && is_even(a[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_807_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_807_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_807_spec.rs
@@ -1,20 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(x: int) -> bool {

+spec fn IsOdd(x: int) -> bool

+{

     x % 2 != 0

 }

 

-fn FindFirstOdd(a: Vec<int>) -> found: bool, index: int

-    requires a != null

-    ensures !found ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i]),

-            found ==> 0 <= index < a.len() and IsOdd(a[index]) and forall|i: int| 0 <= i < index ==> !IsOdd(a[i])

+

+

+pub fn FindFirstOdd(a: &[int]) -> (found: bool, index: int)

+    requires(a.len() >= 0)

+    ensures(|result: (bool, int)| !result.0 ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i as usize]))

+    ensures(|result: (bool, int)| result.0 ==> 0 <= result.1 < a.len() && IsOdd(a[result.1 as usize]) && forall|i: int| 0 <= i < result.1 ==> !IsOdd(a[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_808_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_808_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_808_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsK(s: Seq<int>, k: int) -> (result: bool)

-    ensures result <==> k in s

+pub fn contains_k(s: Seq<int>, k: int) -> (result: bool)

+    ensures(result <==> s.contains(k))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_809_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_809_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_809_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSmaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

-    requires a.len() == b.len()

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i],

-            !result <==> exists|i: int| 0 <= i < a.len() and a[i] <= b[i]

+pub fn is_smaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

+    requires(a.len() == b.len())

+    ensures(result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i])

+    ensures(!result <==> exists|i: int| 0 <= i < a.len() && a[i] <= b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_80_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_80_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_80_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TetrahedralNumber(n: int) -> (t: int)

-    requires n >= 0

-    ensures t == n * (n + 1) * (n + 2) / 6

+pub fn tetrahedral_number(n: int) -> (t: int)

+    requires(n >= 0)

+    ensures(t == n * (n + 1) * (n + 2) / 6)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_86_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_86_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_86_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CenteredHexagonalNumber(n: nat) -> (result: nat)

-    requires n >= 0

-    ensures result == 3 * n * (n - 1) + 1

+pub fn centered_hexagonal_number(n: nat) -> (result: nat)

+    requires(n >= 0)

+    ensures(result == 3 * n * (n - 1) + 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_89_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_89_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_89_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ClosestSmaller(n: int) -> (m: int)

-    requires n > 0

-    ensures m + 1 == n

+pub fn closest_smaller(n: int) -> (m: int)

+    requires n > 0,

+    ensures m + 1 == n,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_8_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_8_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_8_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareElements(a: Vec<int>) -> (squared: Vec<int>)

-    ensures squared.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> squared[i] == a[i] * a[i]

+pub fn square_elements(a: &[i32]) -> (squared: Vec<i32>)

+    ensures

+        squared.len() == a.len(),

+        forall|i: usize| 0 <= i < a.len() ==> squared[i] == a[i] * a[i]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_94_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_94_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_94_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinSecondValueFirst(s: Vec<Seq<int>>) -> (firstOfMinSecond: int)

-    requires s.len() > 0,

-             forall|i: int| 0 <= i < s.len() ==> s[i].len() >= 2

-    ensures exists|i: int| 0 <= i < s.len() and firstOfMinSecond == s[i][0] and 

-        (forall|j: int| 0 <= j < s.len() ==> s[i][1] <= s[j][1])

+pub fn min_second_value_first(s: &[Vec<i32>]) -> i32

+    requires

+        s.len() > 0,

+        forall|i: usize| 0 <= i < s.len() ==> s[i].len() >= 2,

+    ensures

+        |result: i32| exists|i: usize| 0 <= i < s.len() && result == s[i][0] && 

+            (forall|j: usize| 0 <= j < s.len() ==> s[i][1] <= s[j][1]),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-synthesis_task_id_95_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-synthesis_task_id_95_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-synthesis_task_id_95_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestListLength(s: Seq<Seq<int>>) -> (v: int)

-    requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> v <= s[i].len(),

-            exists|i: int| 0 <= i < s.len() and v == s[i].len()

+pub fn smallest_list_length(s: Seq<Seq<int>>) -> (v: int)

+    requires(s.len() > 0)

+    ensures(forall|i: int| 0 <= i < s.len() ==> v <= s[i].len())

+    ensures(exists|i: int| 0 <= i < s.len() && v == s[i].len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c >= b and (c == a or c == b)

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures c >= a && c >= b && (c == a || c == b)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    requires x < 0

-    ensures 0 < y,

-            y == -x

+pub fn Abs(x: int) -> (y: int)

+    requires(x < 0)

+    ensures(0 < y)

+    ensures(y == -x)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec.rs
@@ -1,14 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat

+{

+	if n == 0 { 0 } else

+	if n == 1 { 1 } else {

+		fib((n - 1) as nat) + fib((n - 2) as nat)

+	}

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (b: nat)

-    ensures b == fib(n)

+

+

+pub fn ComputeFib(n: nat) -> (b: nat)

+	ensures b == fib(n)

 {

 }

 

+

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMax(a: Vec<int>) -> (max_idx: nat)

-    requires a.len() > 0

-    ensures 0 <= max_idx < a.len(),

-            forall|j: int| 0 <= j < a.len() ==> a[max_idx] >= a[j]

+pub fn find_max(a: &[i32]) -> usize

+    requires(a.len() > 0)

+    ensures(|max_idx: usize| 0 <= max_idx < a.len())

+    ensures(|max_idx: usize| forall|j: usize| 0 <= j < a.len() ==> a[max_idx] >= a[j])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec.rs
@@ -1,20 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn InMap(nums: Seq<int>, m: map<int, int>, t: int) -> bool {

-    forall|j: int| 0 <= j < nums.len() ==> t - nums[j] in m

+spec fn InMap(nums: Seq<int>, m: Map<int, int>, t: int) -> bool {

+    forall|j: int| 0 <= j < nums.len() ==> m.contains_key(t - nums[j])

 }

 

-fn TwoSum(nums: Vec<int>, target: int) -> r: (int, int)

-    ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() and 

-                       nums[r.0] + nums[r.1] == target and

-                       forall|i: int, j: int| 0 <= i < j < r.1 ==> nums[i] + nums[j] != target,

-            r.0 == -1 <==> forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] + nums[j] != target

+pub fn TwoSum(nums: &[int], target: int) -> (int, int)

+    ensures |r: (int, int)| 

+        0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() && 

+                     nums[r.0] + nums[r.1] == target &&

+                     forall|i: int, j: int| 0 <= i < j < r.1 ==> nums[i] + nums[j] != target,

+    ensures |r: (int, int)| 

+        r.0 == -1 <==> forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] + nums[j] != target,

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec.rs
@@ -1,18 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn sqrt(x: int, r: int) -> bool {

-    r*r <= x and (r+1)*(r+1) > x

+    r*r <= x && (r+1)*(r+1) > x

 }

 

-fn mySqrt(x: int) -> (res: int)

-    requires 0 <= x;

-    ensures sqrt(x, res);

+proof fn uniqueSqrt(x: int, r1: int, r2: int)

+    requires 

+        x >= 0 && r1 >= 0 && r2 >= 0,

+    ensures 

+        sqrt(x, r1) && sqrt(x, r2) ==> r1 == r2

+{

+}

+

+pub fn mySqrt(x: int) -> (res: int)

+    requires 

+        0 <= x,

+    ensures 

+        sqrt(x, res),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ClimbStairs(n: nat) -> (r: nat)

-    ensures r == Stairs(n)

-{

+spec fn stairs(n: nat) -> nat {

+    if n <= 1 { 1 } else { stairs(n - 2) + stairs(n - 1) }

 }

 

+pub fn climb_stairs(n: usize) -> (r: usize)

+    requires n >= 0,

+    ensures r == stairs(n as nat),

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0277-find-the-celebrity_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0277-find-the-celebrity_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_leetcode_0277-find-the-celebrity_spec.rs
@@ -1,42 +1,26 @@
+spec fn knows(a: int, b: int) -> bool;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn knows(a: int, b: int)

-

-

-predicate isCelebrity(n : int, i: int)

-requires n >= 0 && 0 <= i < n;

+spec fn isCelebrity(n: int, i: int) -> bool

+    requires n >= 0 && 0 <= i < n

 {

-    forall j :: 0 <= j < n && i != j ==> knows(j, i) && !knows(i, j)

+    forall|j: int| 0 <= j < n && i != j ==> knows(j, i) && !knows(i, j)

 }

 

-

-

-

-lemma knowerCannotBeCelebrity(n: int, i: int)

-requires n >= 0 && 0 <= i < n

-ensures (exists j :: 0 <= j < n && j != i && knows(i, j)) ==> !isCelebrity(n, i)

-{}

-

-

-

-

-ghost method isCelebrityP(n: int, i: int) returns (r : bool)

-requires n >= 0 && 0 <= i < n;

-ensures r <==> isCelebrity(n, i);

+proof fn knowerCannotBeCelebrity(n: int, i: int)

+    requires n >= 0 && 0 <= i < n

+    ensures (exists|j: int| 0 <= j < n && j != i && knows(i, j)) ==> !isCelebrity(n, i)

 {

-    var j: = 0;

-    r := true;

-    while j < n

-    {

-        if j != i {

-            if !knows(j, i) || knows(i, j) -> bool {

-    return false;

 }

 

+pub fn isCelebrityP(n: int, i: int) -> (r: bool)

+    requires(n >= 0 && 0 <= i < n)

+    ensures(r <==> isCelebrity(n, i))

+{

+}

+

+pub fn findCelebrity(n: int) -> (r: int)

+    requires(2 <= n <= 100)

+    ensures(0 <= r < n ==> isCelebrity(n, r))

+    ensures(r == -1 ==> forall|i: int| 0 <= i < n ==> !isCelebrity(n, i))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec.rs
@@ -1,25 +1,52 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn random(a: int, b: int) -> r: int)

-

-  ensures a <= b ==> a <= r <= b

-

-

-lemma eqMultiset_t<T>(t: T, s1: Seq<T>, s2: Seq<T>

-    requires a <= b,

-             multiset(s1) == multiset(s2)

-    ensures a <= b ==> a <= r <= b

-

-

-lemma eqMultiset_t<T>(t: T, s1: seq<T>, s2: seq<T>),

-            t in s1 <==> t in s2

+pub fn random(a: int, b: int) -> (r: int)

+    ensures(a <= b ==> a <= r && r <= b)

 {

 }

 

+proof fn eqMultiset_t<T>(t: T, s1: Seq<T>, s2: Seq<T>)

+    requires(s1.to_multiset() == s2.to_multiset())

+    ensures(s1.contains(t) <==> s2.contains(t))

+{

+}

+

+proof fn eqMultiset<T>(s1: Seq<T>, s2: Seq<T>)

+    requires(s1.to_multiset() == s2.to_multiset())

+    ensures(forall|t: T| s1.contains(t) <==> s2.contains(t))

+{

+}

+

+pub fn swap<T>(a: &mut [T], i: int, j: int)

+    requires(0 <= i < old(a).len() && 0 <= j < old(a).len())

+    ensures(a[i as int] == old(a)[j as int])

+    ensures(a[j as int] == old(a)[i as int])

+    ensures(forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m])

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

+{

+}

+

+pub fn getAllShuffledDataEntries<T>(m_dataEntries: &[T]) -> (result: Vec<T>)

+    ensures(result@.len() == m_dataEntries@.len())

+    ensures(result@.to_multiset() == m_dataEntries@.to_multiset())

+{

+}

+

+spec fn set_of_seq<T>(s: Seq<T>) -> Set<T>

+{

+    Set::new(|x: T| s.contains(x))

+}

+

+proof fn in_set_of_seq<T>(x: T, s: Seq<T>)

+    ensures(s.contains(x) <==> set_of_seq(s).contains(x))

+{

+}

+

+proof fn subset_set_of_seq<T>(s1: Seq<T>, s2: Seq<T>)

+    requires(set_of_seq(s1).subset_of(set_of_seq(s2)))

+    ensures(forall|x: T| s1.contains(x) ==> s2.contains(x))

+{

+}

+

+pub fn getRandomDataEntry<T>(m_workList: &[T], avoidSet: Seq<T>) -> (e: T)

+    requires(m_workList@.len() > 0)

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec.rs
@@ -1,14 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn IterativeFactorial(n: nat) -> (result: nat)

-    ensures result == Factorial(n)

-{

+spec fn factorial(n: nat) -> nat {

+    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }

 }

 

+

+

+

+

+pub fn iterative_factorial(n: nat) -> (result: nat)

+    ensures(result == factorial(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec.rs
@@ -1,14 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn FibonacciIterative(n: nat) -> (f: nat)

-    ensures f == Fibonacci(n)

-{

+spec fn Fibonacci(n: nat) -> nat {

+    match n {

+        0 => 0,

+        1 => 1,

+        _ => Fibonacci((n - 1) as nat) + Fibonacci((n - 2) as nat),

+    }

 }

 

+

+

+

+

+pub fn FibonacciIterative(n: nat) -> (f: nat)

+    ensures(f == Fibonacci(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_tmp_tmp49a6ihvk_m4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_tmp_tmp49a6ihvk_m4_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_tmp_tmp49a6ihvk_m4_spec.rs
@@ -1,13 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Below(c: Color, d: Color) -> bool {

-    c == Red | c == d .len()| d == Blue

+#[derive(PartialEq, Eq)]

+pub enum Color {

+    Red,

+    White,

+    Blue,

 }

 

+pub open spec fn below(c: Color, d: Color) -> bool {

+    c == Color::Red || c == d || d == Color::Blue

+}

+

+pub fn dutch_flag(a: &mut Vec<Color>)

+    requires old(a).len() > 0,

+    ensures forall|i: int, j: int| 0 <= i < j < a.len() ==> below(a[i], a[j]),

+    ensures a@.to_multiset() == old(a)@.to_multiset(),

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec.rs
@@ -1,42 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Preserved(a: Vec<int>, left: nat, right: nat)

-    reads a

-    requires left <= right <= a.Length

-{

-    multiset(a[left..right]) == multiset(old(a[left..right]))

+spec fn preserved(a: &[i32], left: usize, right: usize) -> bool {

+    left <= right && right <= a.len() &&

+    a[left..right].to_multiset() == old(a)[left..right].to_multiset()

 }

 

-

-

-

-ghost predicate Ordered(a: array<int>, left: nat, right: nat)

-    reads a

-    requires left <= right <= a.Length

+spec fn ordered(a: &[i32], left: usize, right: usize) -> bool

+    requires left <= right <= a.len()

 {

-    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]

+    forall|i: usize| 0 < left <= i < right ==> a[i-1] <= a[i]

 }

 

-twostate predicate Sorted(a: array<int>)

-    reads a

-{

-    Ordered(a, 0, a.Length) && Preserved(a, 0, a.Length)

+spec fn sorted(a: &[i32]) -> bool {

+    ordered(a, 0, a.len()) && preserved(a, 0, a.len())

 }

 

-

-twostate predicate Sorted(a: Vec<int>, 0, a.Length) && Preserved(a, 0, a.Length)

-}

-

-

-

-method SelectionnSort(a: Vec<int>) -> bool {

-    

-}

-

+pub fn selection_sort(a: &mut [i32])

+    ensures sorted(a)

+{

 }

================================================================================
Comparing translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_derangement_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_derangement_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_derangement_spec.rs
@@ -1,17 +1,42 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

+

+

 

 spec fn derangement(s: Seq<nat>) -> bool {

     forall|i: int| 0 <= i < s.len() ==> s[i] != i

 }

 

+

+

 spec fn permutation(s: Seq<nat>) -> bool {

-    forall|i: int| 0 <= i < s.len() ==> i in s

+    forall|i: int| 0 <= i < s.len() ==> s.contains(i)

+}

+

+

+

+spec fn multisetRange(n: nat) -> Multiset<nat> {

+    Seq::new(n, |i: int| i).to_multiset()

+}

+

+

+

+spec fn distinct<A>(s: Seq<A>) -> bool {

+    forall|x: int, y: int| x != y && 0 <= x <= y < s.len() ==> s[x] != s[y]

+}

+

+

+

+pub fn test() {

+}

+

+pub fn end(links: Seq<nat>)

+    requires(|links| > 0)

+    requires(permutation(links))

+    requires(derangement(links))

+    requires(distinct(links))

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_minmax2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_minmax2_spec.rs
+++ verus_specs/translations/atomizer_supported/dafny_tmp_tmp59p638nn_examples_minmax2_spec.rs
@@ -1,15 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceMinMax(a: Vec<int>) -> (diff: int)

-    requires a.len() > 0

-    ensures diff == (Max(a[..]) - Min(a[..]))

+pub fn DifferenceMinMax(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 0)

+    ensures(|diff: i32| diff == (Max(a@) - Min(a@)))

 {

 }

 

+pub spec fn Min(a: Seq<i32>) -> (m: i32)

+    requires(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let minPrefix = Min(a.subrange(0, a.len() as int - 1));

+        if a[a.len() - 1] <= minPrefix { a[a.len() - 1] } else { minPrefix }

+    }

+}

+

+pub spec fn Max(a: Seq<i32>) -> (m: i32)

+    requires(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let maxPrefix = Max(a.subrange(0, a.len() as int - 1));

+        if a[a.len() - 1] >= maxPrefix { a[a.len() - 1] } else { maxPrefix }

+    }

 }

================================================================================
Comparing translations/atomizer_supported/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec.rs
+++ verus_specs/translations/atomizer_supported/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec.rs
@@ -1,48 +1,35 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isSorted(a: Vec<real>, from: nat, to: nat)

-  requires 0 <= from <= to <= a.Length

-  reads a

+

+spec fn isSorted(a: &[f64], from: nat, to: nat) -> bool

+    recommends 0 <= from <= to <= a.len()

 {

-    forall i, j: : from <= i < j < to ==> a[i] <= a[j] 

+    forall|i: int, j: int| from <= i < j < to ==> a[i as usize] <= a[j as usize]

 }

 

 

-

-

-

-

-method selectionSort(a: array<real>)

-  modifies a

-  ensures isSorted(a, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..])) -> bool {

-    

-}

-

-fn selectionSort(a: Vec<real>, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..]))

+pub fn selectionSort(a: &mut [f64])

+    ensures isSorted(a, 0, a.len()),

+    ensures a@.to_multiset() == old(a)@.to_multiset()

 {

 }

 

 

 

+pub fn findMin(a: &[f64], from: nat, to: nat) -> (index: nat)

+    requires 0 <= from < to <= a.len()

+    ensures from <= index < to

+    ensures forall|k: int| from <= k < to ==> a[k as usize] >= a[index as usize]

+{

+}

 

+pub fn testSelectionSort()

+{

+}

 

-

-

-

-method findMin(a: Vec<real>, from: nat, to: nat) -> (index: nat)

-    requires 0 <= from < to <= a.len()

-    ensures isSorted(a, 0, a.len()),

-            multiset(a[..]) == multiset(old(a[..])),

-            from <= index < to,

-            forall|k: int| from <= k < to ==> a[k] >= a[index]

+pub fn testFindMin()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec.rs
+++ verus_specs/translations/atomizer_supported/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec.rs
@@ -1,13 +1,55 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SqrSum(n: int) -> (s: int)

+pub fn SqrSum(n: int) -> (s: int)

 {

 }

 

+pub fn DivMod(a: int, b: int) -> (q: int, r: int)

+{

+}

+

+pub fn HoareTripleAssmAssrt()

+{

+}

+

+pub fn HoareTripleReqEns(i: int, k: int) -> (k_: int)

+    requires(k == i*i)

+    ensures(k_ == (i+1)*(i+1))

+{

+}

+

+pub fn Invariant1()

+{

+}

+

+spec fn SqrSumRec(n: int) -> int

+    requires(n >= 0)

+{

+    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }

+}

+

+pub fn SqrSum1(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == SqrSumRec(n))

+{

+}

+

+proof fn L1(n: int)

+    requires(n >= 0)

+    ensures(SqrSumRec(n) == n*(n+1)*(2*n + 1)/6)

+{

+}

+

+proof fn L(n: int)

+    requires(n >= 0)

+    ensures(SqrSumBy6(n) == 6 * SqrSumRec(n))

+{

+}

+

+pub fn DivMod1(a: int, b: int) -> (q: int, r: int)

+    requires(b > 0 && a >= 0)

+    ensures(a == b*q + r && 0 <= r < b)

+{

+}

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/formal-verification_tmp_tmpoepcssay_strings3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal-verification_tmp_tmpoepcssay_strings3_spec.rs
+++ verus_specs/translations/atomizer_supported/formal-verification_tmp_tmpoepcssay_strings3_spec.rs
@@ -1,36 +1,90 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+spec fn isPrefixPred(pre: &str, str: &str) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: &str, str: &str) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+proof fn PrefixNegationLemma(pre: &str, str: &str)

+    ensures isPrefixPred(pre, str) <==> !isNotPrefixPred(pre, str)

+    ensures !isPrefixPred(pre, str) <==> isNotPrefixPred(pre, str)

 {

 }

 

+

+pub fn isPrefix(pre: &str, str: &str) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

+{

+}

+

+

+spec fn isSubstringPred(sub: &str, str: &str) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+spec fn isNotSubstringPred(sub: &str, str: &str) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+proof fn SubstringNegationLemma(sub: &str, str: &str)

+    ensures isSubstringPred(sub, str) <==> !isNotSubstringPred(sub, str)

+    ensures !isSubstringPred(sub, str) <==> isNotSubstringPred(sub, str)

+{

+}

+

+

+pub fn isSubstring(sub: &str, str: &str) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+    ensures(res ==> isSubstringPred(sub, str))

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(!res <==> isNotSubstringPred(sub, str))

+{

+}

+

+

+spec fn haveCommonKSubstringPred(k: nat, str1: &str, str2: &str) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: &str, str2: &str) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+proof fn commonKSubstringLemma(k: nat, str1: &str, str2: &str)

+    ensures haveCommonKSubstringPred(k, str1, str2) <==> !haveNotCommonKSubstringPred(k, str1, str2)

+    ensures !haveCommonKSubstringPred(k, str1, str2) <==> haveNotCommonKSubstringPred(k, str1, str2)

+{

+}

+

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> (found: bool)

+    ensures(found <==> haveCommonKSubstringPred(k, str1, str2))

+    ensures(!found <==> haveNotCommonKSubstringPred(k, str1, str2))

+{

+}

+

+

+pub fn maxCommonSubstringLength(str1: &str, str2: &str) -> (len: nat)

+    requires(str1.len() <= str2.len())

+    ensures(forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPred(k as nat, str1, str2))

+    ensures(haveCommonKSubstringPred(len, str1, str2))

+{

 }

================================================================================
Comparing translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PalVerify(a: Vec<char>) -> (yn: bool)

-    ensures yn == true ==> forall|i: int| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i -1],

-            yn == false ==> exists|i: int| 0 <= i < a.len()/2 and a[i] != a[a.len() - i -1],

-            forall|j: int| 0<=j<a.len() ==> a[j] == old(a[j])

+pub fn pal_verify(a: &[char]) -> (yn: bool)

+    requires(true)

+    ensures(|result: bool| yn == true ==> (forall|i: usize| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i - 1]))

+    ensures(|result: bool| yn == false ==> (exists|i: usize| 0 <= i < a.len()/2 && a[i] != a[a.len() - i - 1]))

+    ensures(|result: bool| forall|j: usize| 0 <= j < a.len() ==> a[j] == old(a)[j])

 {

 }

 

+pub fn test()

+    requires(true)

+    ensures(true)

+{

 }

================================================================================
Comparing translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec.rs
@@ -1,15 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Forbid42(x: int, y: int) -> (z: int)

-    requires y != 42;

-    ensures z == x/(42-y);

+pub fn Forbid42(x: int, y: int) -> (z: int)

+    requires(y != 42)

+    ensures(z == x/(42-y))

 {

 }

 

+pub fn Allow42(x: int, y: int) -> (z: int, err: bool)

+    ensures(y != 42 ==> z == x/(42-y) && err == false)

+    ensures(y == 42 ==> z == 0 && err == true)

+{

+}

+

+pub fn TEST1()

+{

 }

================================================================================
Comparing translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec.rs
+++ verus_specs/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec.rs
@@ -1,22 +1,57 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn nomultiples(u: Seq<nat>) -> bool {

-    forall|j: int, k: int| 0<=j<k<u.len() ==> u[j] != u[k]

+spec fn bullspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    reccbull(s, u, 0)

 }

 

-fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> b: nat, c: nat

+spec fn cowspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    recccow(s, u, 0)

+}

+

+spec fn reccbull(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] == u[i] {

+        reccbull(s, u, i + 1) + 1

+    } else {

+        reccbull(s, u, i + 1)

+    }

+}

+

+spec fn recccow(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] != u[i] && u[i] in s {

+        recccow(s, u, i + 1) + 1

+    } else {

+        recccow(s, u, i + 1)

+    }

+}

+

+spec fn nomultiples(u: Seq<nat>) -> bool {

+    forall|j: int, k: int| 0 <= j < k < u.len() ==> u[j] != u[k]

+}

+

+pub fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> (b: nat, c: nat)

     requires 0 < u.len() == s.len() <= 10,

-             nomultiples(u) and nomultiples(s);

-    ensures b >= 0 and c >= 0,

-            b == bullspec(s, u),

-            c == cowspec(s, u)

+    requires nomultiples(u) && nomultiples(s),

+    ensures b >= 0 && c >= 0,

+    ensures b == bullspec(s, u),

+    ensures c == cowspec(s, u),

 {

 }

 

+pub fn TEST() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec.rs
+++ verus_specs/translations/atomizer_supported/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec.rs
@@ -1,29 +1,57 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn below(first: Bases, second: Bases) -> bool {

-    first == second |

-    first == A .len() 

-    (first == C and (second ==  G .len() second == T)) .len() 

-    (first == G and second == T) .len()|

-    second == T

+#[derive(PartialEq, Eq, Specification)]

+pub enum Bases {

+    A,

+    C,

+    G,

+    T,

 }

-spec fn bordered(s: Seq<Bases>) -> bool {

+

+pub fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

+    requires

+        0 < s.len() && x < s.len() && y < s.len(),

+    ensures

+        t.len() == s.len(),

+    ensures

+        forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b],

+    ensures

+        t[x] == s[y] && s[x] == t[y],

+    ensures

+        s.to_multiset() == t.to_multiset(),

+{

+}

+

+pub open spec fn below(first: Bases, second: Bases) -> bool {

+    first == second ||

+    first == Bases::A || 

+    (first == Bases::C && (second == Bases::G || second == Bases::T)) || 

+    (first == Bases::G && second == Bases::T) ||

+    second == Bases::T

+}

+

+pub open spec fn bordered(s: Seq<Bases>) -> bool {

     forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])

 }

 

-fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

-    requires 0 < s.len() and x < s.len() and y < s.len()

-    ensures t.len() == s.len(),

-            forall b:nat :: 0 <= b < s.len() and b != x and b != y ==> t[b] == s[b],

-            t[x] == s[y] and s[x] == t[y],

-            multiset(s) == multiset(t)

+pub fn sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)

+    requires

+        0 < bases.len(),

+    ensures

+        sobases.len() == bases.len(),

+    ensures

+        bordered(sobases),

+    ensures

+        bases.to_multiset() == sobases.to_multiset(),

 {

 }

 

+pub fn testerexchange() {

+}

+

+pub fn testsort() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec.rs
+++ verus_specs/translations/atomizer_supported/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec.rs
@@ -1,14 +1,11 @@
+spec fn fib(n: nat) -> nat

+{

+    if n == 0 { 0 } else

+    if n == 1 { 1 } else

+    { fib((n - 1) as nat) + fib((n - 2) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFib(n: nat) -> (b: nat)

+pub fn ComputeFib(n: nat) -> (b: nat)

     ensures b == fib(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec.rs
+++ verus_specs/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec.rs
@@ -1,14 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn do_algebra(operators: Seq<char>, operands: Seq<int>) -> (result: int)

-    requires operators != [] and operands != [] and operators.len() + 1 == operands.len(),

-             forall|i: int| 0 <= i < operands.len() ==> operands[i] >= 0

+spec fn pow(base: int, exponent: int) -> int

+    recommends exponent >= 0

+{

+    if exponent == 0 { 1 }

+    else if exponent % 2 == 0 { pow(base * base, exponent / 2) }

+    else { base * pow(base, exponent - 1) }

+}

+

+pub fn do_algebra(operators: Seq<char>, operands: Seq<int>) -> (result: int)

+    requires

+        operators != Seq::<char>::empty() && operands != Seq::<int>::empty() && operators.len() + 1 == operands.len(),

+        forall|i: int| 0 <= i < operands.len() ==> operands[i] >= 0,

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec.rs
+++ verus_specs/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec.rs
@@ -1,14 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sum(s: Seq<int>, n: nat) -> int

+    recommends n <= s.len()

+{

+    if s.len() == 0 || n == 0 {

+        0

+    } else {

+        s[0] + sum(s.subrange(1, s.len() as int), (n-1) as nat)

+    }

+}

 

-verus! {

 

-fn below_zero(ops: Seq<int>) -> (result: bool)

-    ensures result <==> exists n: nat :: n <= ops.len() and sum(ops, n) < 0

+proof fn sum_plus(s: Seq<int>, i: nat)

+    requires i < s.len()

+    ensures sum(s, i) + s[i as int] == sum(s, (i+1) as nat)

 {

 }

 

+

+pub fn below_zero(ops: Seq<int>) -> (result: bool)

+    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0

+{

 }

================================================================================
Comparing translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec.rs
+++ verus_specs/translations/atomizer_supported/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec.rs
@@ -1,15 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub open spec fn isMax(m: int, numbers: Seq<int>) -> bool

+{

+    numbers.contains(m) &&

+    forall|i: int| 0 <= i < numbers.len() ==> numbers[i] <= m

+}

 

-verus! {

 

-fn max(numbers: Seq<int>) -> (result: int)

-    requires numbers != []

-    ensures isMax(result, numbers)

+pub fn max(numbers: Seq<int>) -> (result: int)

+    requires

+        numbers.len() != 0,

+    ensures

+        isMax(result, numbers),

 {

 }

 

+

+pub fn rolling_max(numbers: Seq<int>) -> (result: Seq<int>)

+    requires

+        numbers.len() != 0,

+    ensures

+        result.len() == numbers.len(),

+        forall|i: int| 0 < i < result.len() ==> isMax(result[i], numbers.subrange(0, i+1)),

+{

 }

================================================================================
Comparing translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec.rs
+++ verus_specs/translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn buscar(a: Vec<int>, x: int) -> (r: int)

-    ensures r < 0 ==> forall|i: int| 0 <= i <a.len() ==> a[i] != x,

-            0 <= r < a.len() ==> a[r] == x

+pub fn buscar(a: &[int], x: int) -> (r: int)

+    ensures(r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x)

+    ensures(0 <= r < a.len() ==> a[r] == x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec.rs
+++ verus_specs/translations/atomizer_supported/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec.rs
@@ -1,14 +1,16 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn somaAteAberto(a: &[nat], i: nat) -> nat

+    recommends i <= a.len()

+{

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + somaAteAberto(a, i-1)

+    }

+}

 

-verus! {

-

-fn somatorio(a: Vec<nat>) -> (s: nat)

+pub fn somatorio(a: &[nat]) -> (s: nat)

     ensures s == somaAteAberto(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/nitwit_tmp_tmplm098gxz_nit_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/nitwit_tmp_tmplm098gxz_nit_spec.rs
+++ verus_specs/translations/atomizer_supported/nitwit_tmp_tmplm098gxz_nit_spec.rs
@@ -1,41 +1,100 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

-spec fn requires(valid_base(b))

-  requires (nitness(b, n))

-  ensures (nitness(b, sum))

-  ensures (nitness(b, carry)) -> bool {

-    

+

+pub fn nit_increment(b: nat, n: nat) -> (sum: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, sum))

+    ensures(nitness(b, carry))

+{

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

+

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

+{

 }

 

-fn nit_increment(b: nat, n: nat) -> sum: nat, carry: nat)

+pub fn nit_flip(b: nat, n: nat) -> (nf: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, nf))

+{

+}

 

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

 

-  requires (valid_base(b)

-    requires (valid_base(b)),

-             (nitness(b, n))

-    ensures (nitness(b, sum)),

-            (nitness(b, carry))

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

+

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_add(b: nat, p: Seq<nat>, q: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    requires(bibble(b, q))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_increment(b: nat, p: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_flip(b: nat, p: Seq<nat>) -> (fp: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, fp))

+{

+}

+

+pub fn n_complement(b: nat, p: Seq<nat>) -> (com: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, com))

+{

+}

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_demos_ch03_nim_v3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_demos_ch03_nim_v3_spec.rs
+++ verus_specs/translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_demos_ch03_nim_v3_spec.rs
@@ -1,39 +1,71 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Init(v: Variables) -> bool {

-    and v.piles.len() == 3

-  and v.turn.P1?

+pub enum Player {

+    P1,

+    P2,

 }

 

-spec fn Turn(v: Variables, v': Variables, step: Step)

-  requires step.TurnStep?

-{

-  var p := step.p;

-  var take := step.take;

-  && p < |v.piles|

-  && take <= v.piles[p]

-  && v' == v.(piles := v.piles[p := v.piles[p] - take]).(turn := v.turn.Other())

+impl Player {

+    pub open spec fn other(self) -> Player {

+        match self {

+            Player::P1 => Player::P2,

+            Player::P2 => Player::P1,

+        }

+    }

 }

 

-

-

-

-

-

-ghost predicate NextStep(v: Variables, v': Variables, step: Step) -> bool {

-    match step {

-    case TurnStep(_, _) => Turn(v, v', step)

-    case NoOpStep() => v' == v

+pub struct Variables {

+    pub piles: Seq<nat>,

+    pub turn: Player,

 }

 

-spec fn Next(v: Variables, v': Variables) -> bool {

-    exists|step: int| NextStep(v, v', step)

+pub open spec fn init(v: Variables) -> bool {

+    &&& v.piles.len() == 3

+    &&& matches!(v.turn, Player::P1)

+}

+

+pub enum Step {

+    TurnStep { take: nat, p: nat },

+    NoOpStep,

+}

+

+pub open spec fn turn(v: Variables, v_prime: Variables, step: Step) -> bool

+    recommends step matches Step::TurnStep { .. }

+{

+    let Step::TurnStep { p, take } = step;

+    &&& p < v.piles.len()

+    &&& take <= v.piles[p as int]

+    &&& v_prime == Variables {

+        piles: v.piles.update(p as int, v.piles[p as int] - take),

+        turn: v.turn.other(),

+    }

+}

+

+pub open spec fn next_step(v: Variables, v_prime: Variables, step: Step) -> bool {

+    match step {

+        Step::TurnStep { .. } => turn(v, v_prime, step),

+        Step::NoOpStep => v_prime == v,

+    }

+}

+

+pub proof fn next_step_deterministic_given_step(v: Variables, v_prime: Variables, v_prime_prime: Variables, step: Step)

+    requires(next_step(v, v_prime, step))

+    requires(next_step(v, v_prime_prime, step))

+    ensures(v_prime == v_prime_prime)

+{

+}

+

+pub open spec fn next(v: Variables, v_prime: Variables) -> bool {

+    exists|step: Step| next_step(v, v_prime, step)

+}

+

+pub proof fn example_behavior() -> (b: Seq<Variables>)

+    ensures(b.len() >= 3)

+    ensures(init(b[0]))

+    ensures(forall|i: nat| i + 1 < b.len() ==> next(b[i as int], b[(i + 1) as int]))

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_exercises_chapter04-invariants_ch03exercise03_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_exercises_chapter04-invariants_ch03exercise03_spec.rs
+++ verus_specs/translations/atomizer_supported/protocol-verification-fa2023_tmp_tmpw6hy3mjp_exercises_chapter04-invariants_ch03exercise03_spec.rs
@@ -1,83 +1,112 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn ValidIdx(idx: int) -> bool {

-    0 <= idx < this.clientCount

+#[derive(PartialEq, Eq, Specification)]

+pub enum ServerGrant {

+    Unlocked,

+    Client { id: nat },

 }

 

-spec fn WellFormed() -> bool {

-    clients.len() == this.clientCount

+#[derive(PartialEq, Eq, Specification)]

+pub enum ClientRecord {

+    Released,

+    Acquired,

 }

 

-spec fn Init(v: Variables) -> bool {

-    and v.WellFormed()

-

-  and v.server.Unlocked?

-  and v.clients.len() == v.clientCount

-  and forall|i  0 <= i < .len()v.clients|: int| v.clients[i].Released?

-

+#[derive(PartialEq, Eq, Specification)]

+pub struct Variables {

+    pub clientCount: nat,

+    pub server: ServerGrant,

+    pub clients: Seq<ClientRecord>,

 }

 

-spec fn Acquire(v: Variables, v': Variables, id: int) -> bool {

-    and v.WellFormed()

-  and v'.WellFormed()

-  and v.ValidIdx(id)

+impl Variables {

+    pub open spec fn ValidIdx(self, idx: int) -> bool {

+        0 <= idx < self.clientCount

+    }

 

-  and v.server.Unlocked?

-

-  and v'.server == Client(id)

-  and v'.clients == v.clients[id := Acquired]

-  and v'.clientCount == v.clientCount

+    pub open spec fn WellFormed(self) -> bool {

+        self.clients.len() == self.clientCount

+    }

 }

 

-spec fn Release(v: Variables, v': Variables, id: int) -> bool {

-    and v.WellFormed()

-  and v'.WellFormed()

-  and v.ValidIdx(id)

-

-  and v.clients[id].Acquired?

-

-  and v'.server.Unlocked?

-  and v'.clients == v.clients[id := Released]

-  and v'.clientCount == v.clientCount

+pub open spec fn Init(v: Variables) -> bool {

+    && v.WellFormed()

+    && v.server == ServerGrant::Unlocked

+    && v.clients.len() == v.clientCount

+    && forall|i: int| 0 <= i < v.clients.len() ==> v.clients[i] == ClientRecord::Released

 }

 

-spec fn NextStep(v: Variables, v': Variables, step: Step) -> bool {

-    match step

-

-  case AcquireStep(id) => Acquire(v, v', id)

-  case ReleaseStep(id) => Release(v, v', id)

-

+pub open spec fn Acquire(v: Variables, v_prime: Variables, id: int) -> bool {

+    && v.WellFormed()

+    && v_prime.WellFormed()

+    && v.ValidIdx(id)

+    && v.server == ServerGrant::Unlocked

+    && v_prime.server == ServerGrant::Client { id: id as nat }

+    && v_prime.clients == v.clients.update(id, ClientRecord::Acquired)

+    && v_prime.clientCount == v.clientCount

 }

 

-spec fn Next(v: Variables, v': Variables) -> bool {

-    exists|step: int| NextStep(v, v', step)

+pub open spec fn Release(v: Variables, v_prime: Variables, id: int) -> bool {

+    && v.WellFormed()

+    && v_prime.WellFormed()

+    && v.ValidIdx(id)

+    && v.clients[id] == ClientRecord::Acquired

+    && v_prime.server == ServerGrant::Unlocked

+    && v_prime.clients == v.clients.update(id, ClientRecord::Released)

+    && v_prime.clientCount == v.clientCount

 }

 

-spec fn Safety(v: Variables) -> bool {

-

-

-

-

-

-  forall|i: int, j 

-    and 0 <= i < .len()v.clients

-    and 0 <= j < .len()v.clients|

-    and v.clients[i].Acquired?

-    and v.clients[j].Acquired?: int| i == j

-

+#[derive(PartialEq, Eq, Specification)]

+pub enum Step {

+    AcquireStep { id: int },

+    ReleaseStep { id: int },

 }

 

-spec fn ClientHoldsLock(v: Variables, clientIndex: nat)

-  requires v.WellFormed() -> bool {

+pub open spec fn NextStep(v: Variables, v_prime: Variables, step: Step) -> bool {

+    match step {

+        Step::AcquireStep { id } => Acquire(v, v_prime, id),

+        Step::ReleaseStep { id } => Release(v, v_prime, id),

+    }

+}

 

-  and v.server == Client(clientIndex)

+pub proof fn NextStepDeterministicGivenStep(v: Variables, v_prime: Variables, step: Step)

+    requires NextStep(v, v_prime, step)

+    ensures forall|v_prime_prime: Variables| NextStep(v, v_prime_prime, step) ==> v_prime == v_prime_prime

+{

+}

 

+pub open spec fn Next(v: Variables, v_prime: Variables) -> bool {

+    exists|step: Step| NextStep(v, v_prime, step)

+}

+

+pub open spec fn Safety(v: Variables) -> bool {

+    forall|i: int, j: int|

+        0 <= i < v.clients.len()

+        && 0 <= j < v.clients.len()

+        && v.clients[i] == ClientRecord::Acquired

+        && v.clients[j] == ClientRecord::Acquired

+        ==> i == j

+}

+

+pub open spec fn ClientHoldsLock(v: Variables, clientIndex: nat) -> bool

+    recommends v.WellFormed()

+{

+    v.server == ServerGrant::Client { id: clientIndex }

+}

+

+pub proof fn PseudoLiveness(clientA: nat, clientB: nat) -> (behavior: Seq<Variables>)

+    requires clientA == 2

+    requires clientB == 0

+    ensures 2 <= behavior.len()

+    ensures Init(behavior[0])

+    ensures forall|i: int| 0 <= i < behavior.len() - 1 ==> Next(behavior[i], behavior[i + 1])

+    ensures forall|i: int| 0 <= i < behavior.len() ==> Safety(behavior[i])

+    ensures behavior[behavior.len() - 1].WellFormed()

+    ensures ClientHoldsLock(behavior[1], clientA)

+    ensures ClientHoldsLock(behavior[behavior.len() - 1], clientB)

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass1_ex6_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass1_ex6_spec.rs
+++ verus_specs/translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass1_ex6_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Ceiling7(n: nat) -> (k: nat)

-    requires n >= 0

-    ensures k == n-(n%7)

+pub fn ceiling7(n: nat) -> (k: nat)

+    requires(n >= 0)

+    ensures(k == n - (n % 7))

 {

 }

 

+pub fn test7()

+{

 }

================================================================================
Comparing translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass2_ex2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass2_ex2_spec.rs
+++ verus_specs/translations/atomizer_supported/se2011_tmp_tmp71eb82zt_ass2_ex2_spec.rs
@@ -1,37 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn check(a: Vec<int>, seclar: int)

-requires a.Length > 0

-reads a

-{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-

-method SecondLargest(a:array<int>) -> (seclar: int)

-    requires a.len() > 0

-reads a,

-             a.len() > 0

-

-    ensures exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-            for the method 

-

-method SecondLargest(a:array<int>) returns (seclar:int),

-            exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])

+pub fn SecondLargest(a: &[i32]) -> (seclar: i32)

+    requires(a.len() > 0)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/software_analysis_tmp_tmpmt6bo9sf_ss_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/software_analysis_tmp_tmpmt6bo9sf_ss_spec.rs
+++ verus_specs/translations/atomizer_supported/software_analysis_tmp_tmpmt6bo9sf_ss_spec.rs
@@ -1,41 +1,42 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn is_sorted(ss: Seq<int>) -> bool {

-    forall i, j: int:: 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]

-}

-spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool {

-    a.len() == b.len()  and 

-    ((a.len() == 0 and b.len() == 0) |  

-    exists i,j : int :: 0<=i<.len()a and  0<=j<.len()b  and a[i] == b[j] and is_permutation(a[0..i] + if i < .len()a then a[i+1..] else [], b[0..j] + if j < .len()b| then  b[j+1..] else []))

-}

-spec fn is_permutation(a: Seq<int>, b: Seq<int>, j: int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))

-

-

-

-

-

-

-

-

-predicate is_permutation2(a: Seq<int>, b: Seq<int>) -> bool {

-    multiset(a) == multiset(b)

-}

-

-fn find_min_index(a: Vec<int>, s: int, e: int) -> (min_i: int)

-    requires a.len() > 0,

-             0 <= s < a.len(),

-             e <= a.len(),

-             e > s

-    ensures min_i >= s,

-            min_i < e,

-            forall k: int :: s <= k < e ==> a[min_i] <= a[k]

+pub fn find_min_index(a: &[i32], s: usize, e: usize) -> (min_i: usize)

+    requires(

+        a.len() > 0 &&

+        s < a.len() &&

+        e <= a.len() &&

+        e > s

+    )

+    ensures(|min_i: usize|

+        min_i >= s &&

+        min_i < e &&

+        forall|k: usize| s <= k < e ==> a[min_i as int] <= a[k as int]

+    )

 {

 }

 

+spec fn is_sorted(ss: Seq<i32>) -> bool

+{

+    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]

+}

+

+spec fn is_permutation(a: Seq<i32>, b: Seq<i32>) -> bool

+{

+    a.len() == b.len() &&

+    ((a.len() == 0 && b.len() == 0) ||

+    exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && 

+    is_permutation(a.subrange(0, i) + (if i < a.len() { a.subrange(i+1, a.len() as int) } else { seq![] }),

+                   b.subrange(0, j) + (if j < b.len() { b.subrange(j+1, b.len() as int) } else { seq![] })))

+}

+

+spec fn is_permutation2(a: Seq<i32>, b: Seq<i32>) -> bool

+{

+    a.to_multiset() == b.to_multiset()

+}

+

+pub fn selection_sort(ns: &mut [i32])

+    requires(ns.len() >= 0)

+    ensures(

+        is_sorted(ns@) &&

+        is_permutation2(old(ns)@, ns@)

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_binary_search_binary_search_specs_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_binary_search_binary_search_specs_spec.rs
+++ verus_specs/translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_binary_search_binary_search_specs_spec.rs
@@ -1,25 +1,103 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTransition(intSeq: Seq<int>, key: int, r: int)

-    requires (forall i, j | 0 <= i <= j < |intSeq|: : intSeq[i] <= intSeq[j]) -> bool {

-    and (r >= 0 ==> r < intSeq.len() and intSeq[r] == key)

-    and (r < 0 ==> forall i:nat  i < .len()intSeq| :: intSeq[i] != key)

+pub fn BinarySearch(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    ensures(r < 0 ==> forall|i: nat| i < intSeq.len() ==> intSeq[i] != key)

+{

 }

 

-spec fn BinarySearchDeterministicTransition(intSeq: Seq<int>, key: int, r: int)

-    requires (forall i, j | 0 <= i <= j < |intSeq|: : intSeq[i] <= intSeq[j]) -> bool {

-    and (r >= 0 ==> r < intSeq.len() and intSeq[r] == key)

-    and (r < 0 ==> forall i:nat  i < .len()intSeq :: intSeq[i] != key)

+

+spec fn BinarySearchTransition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    && (r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    && (r < 0 ==> forall|i: nat| i < intSeq.len() ==> intSeq[i] != key)

+}

 

 

-    and (r < 0 ==> r == -1)

-    and (r >= 0 ==> forall i:nat .len() i < r :: intSeq[i] < key)

+pub fn BinarySearchDeterministic(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    ensures(r < 0 ==> forall|i: nat| i < intSeq.len() ==> intSeq[i] != key)

+    ensures(r < 0 ==> r == -1)

+    ensures(r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+{

 }

 

+

+spec fn BinarySearchDeterministicTransition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    && (r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    && (r < 0 ==> forall|i: nat| i < intSeq.len() ==> intSeq[i] != key)

+    && (r < 0 ==> r == -1)

+    && (r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+}

+

+

+pub fn BinarySearchWrong1(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    ensures(r < 0 ==> forall|i: nat| 0 < i < intSeq.len() ==> intSeq[i] != key)

+    ensures(r < 0 ==> r == -1)

+    ensures(r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+{

+}

+

+

+spec fn BinarySearchWrong1Transition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    && (r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    && (r < 0 ==> forall|i: nat| 0 < i < intSeq.len() ==> intSeq[i] != key)

+    && (r < 0 ==> r == -1)

+    && (r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+}

+

+

+pub fn BinarySearchWrong2(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    ensures(r < 0 ==> forall|i: nat| 0 <= i < intSeq.len() - 1 ==> intSeq[i] != key)

+    ensures(r < 0 ==> r == -1)

+    ensures(r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+{

+}

+

+

+spec fn BinarySearchWrong2Transition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    && (r >= 0 ==> r < intSeq.len() && intSeq[r] == key)

+    && (r < 0 ==> forall|i: nat| 0 <= i < intSeq.len() - 1 ==> intSeq[i] != key)

+    && (r < 0 ==> r == -1)

+    && (r >= 0 ==> forall|i: nat| i < r ==> intSeq[i] < key)

+}

+

+

+pub fn BinarySearchWrong3(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(r < 0 || (r < intSeq.len() && intSeq[r] == key))

+{

+}

+

+

+spec fn BinarySearchWrong3Transition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    r < 0 || (r < intSeq.len() && intSeq[r] == key)

+}

+

+

+pub fn BinarySearchWrong4(intSeq: Seq<int>, key: int) -> (r: int)

+    requires(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+    ensures(0 <= r < intSeq.len() && intSeq[r] == key)

+{

+}

+

+

+spec fn BinarySearchWrong4Transition(intSeq: Seq<int>, key: int, r: int) -> bool

+    recommends(forall|i: int, j: int| 0 <= i <= j < intSeq.len() ==> intSeq[i] <= intSeq[j])

+{

+    0 <= r < intSeq.len() && intSeq[r] == key

 }

================================================================================
Comparing translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_max_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_max_max_spec.rs
+++ verus_specs/translations/atomizer_supported/specTesting_tmp_tmpueam35lx_examples_max_max_spec.rs
@@ -1,15 +1,143 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn post_max(a: int, b: int, m: int) -> bool {

-    and m >= a

-    and m >= b

-    and (m == a or m == b)

+

+pub fn max(a: int, b: int) -> (m: int)

+    ensures

+        m >= a,

+        m >= b,

+        m == a || m == b,

+{

+}

+

+

+

+pub open spec fn post_max(a: int, b: int, m: int) -> bool

+{

+    && m >= a

+    && m >= b

+    && (m == a || m == b)

+}

+

+

+

+

+

+

+pub proof fn post_max_point_1_prime(a: int, b: int, m: int)

+    requires

+        a > b,

+        post_max(a, b, m),

+    ensures

+        m == a,

+{

+}

+

+

+

+

+

+pub proof fn post_max_point_2(a: int, b: int, m: int)

+    requires

+        a == b,

+        m != a || m != b,

+    ensures

+        !post_max(a, b, m),

+{

+}

+

+

+

+pub proof fn post_max_point_3(a: int, b: int, m: int)

+    requires

+        a < b,

+        m != b,

+    ensures

+        !post_max(a, b, m),

+{

+}

+

+

+

+pub proof fn post_max_vertical_1_prime(a: int, b: int, m: int)

+    requires

+        post_max(a, b, m),

+    ensures

+        m == a || m == b,

+{

+}

+

+

+

+

+

+pub proof fn post_max_realistic_1(a: int, b: int, m: int)

+    requires

+        a > b,

+        m == a,

+    ensures

+        post_max(a, b, m),

+{

+}

+

+

+

+pub proof fn post_max_realistic_2(a: int, b: int, m: int)

+    requires

+        a < b,

+        m == b,

+    ensures

+        post_max(a, b, m),

+{

+}

+

+

+

+pub proof fn post_max_realistic_3(a: int, b: int, m: int)

+    requires

+        a == b,

+        m == a,

+    ensures

+        post_max(a, b, m),

+{

+}

+

+

+

+

+pub proof fn max_deterministic_prime(a: int, b: int, m: int, m_prime: int)

+    requires

+        m != m_prime,

+    ensures

+        !post_max(a, b, m) || !post_max(a, b, m_prime),

+{

+}

+

+

+

+pub proof fn lemmaInvTheProposerOfAnyValidBlockInAnHonestBlockchailnIsInTheSetOfValidatorsHelper6Helper<T>(

+        s: Seq<int>,

+        b: int,

+        i: nat

+    )

+    requires

+        s.len() > i,

+        b == s[i as int],

+    ensures

+        s.subrange(0, i as int) + seq![b] == s.subrange(0, (i + 1) as int),

+{

+}

+

+

+

+pub proof fn multisetEquality(m1: Multiset<int>, m2: Multiset<int>, m3: Multiset<int>, m4: Multiset<int>)

+   requires

+       m1 > m2 + m3,

+       m1 == m2 + m4,

+   ensures

+       m3 < m4,

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter01_solutions_exercise04_solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter01_solutions_exercise04_solution_spec.rs
+++ verus_specs/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter01_solutions_exercise04_solution_spec.rs
@@ -1,13 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn AtLeastTwiceAsBigPredicate(a: int, b: int) -> bool {

-    a >= 2*b

+pub fn AtLeastTwiceAsBigFunction(a: int, b: int) -> bool {

+    

 }

 

+pub fn AtLeastTwiceAsBigPredicate(a: int, b: int) -> bool {

+    

+}

+

+pub fn Double(a: int) -> int {

+    

+}

+

+pub fn TheseTwoPredicatesAreEquivalent(x: int, y: int) {

+    

+}

+

+pub fn FourTimesIsPrettyBig(x: int)

+    requires(x >= 0)

+{

+    

 }

================================================================================
Comparing translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise01_solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise01_solution_spec.rs
+++ verus_specs/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise01_solution_spec.rs
@@ -1,23 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn divides(f: nat, i: nat)

-  requires 1<=f

+spec fn divides(f: nat, i: nat) -> bool

+    recommends 1 <= f

 {

-  i % f == 0

+    i % f == 0

 }

 

-

-

-

-predicate IsPrime(i:nat) -> bool {

-    and 1 < i

-  and forall|f: int| 1 < f < i ==> !divides(f, i)

+spec fn IsPrime(i: nat) -> bool

+{

+    1 < i && forall|f: nat| 1 < f < i ==> !divides(f, i)

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec.rs
+++ verus_specs/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec.rs
@@ -1,28 +1,29 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn divides(f: nat, i: nat)

-  requires 1<=f

+

+spec fn divides(f: nat, i: nat) -> bool

+    recommends 1 <= f

 {

-  i % f == 0

+    i % f == 0

 }

 

 

+spec fn IsPrime(i: nat) -> bool

+{

+    1 < i && forall|f: nat| 1 < f < i ==> !divides(f, i)

+}

 

 

-predicate IsPrime(i:nat) -> bool {

-    and 1<i

-  and ( forall|f: int| 1 < f < i ==> !divides(f, i) )

+pub fn test_prime(i: nat) -> (result: bool)

+    requires(1 < i)

+    ensures(result == IsPrime(i))

+{

 }

 

-fn test_prime(i: nat) -> (result: bool)

-    requires 1<i

-    ensures result == IsPrime(i)

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec.rs
+++ verus_specs/translations/atomizer_supported/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec.rs
@@ -1,22 +1,26 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSorted(s: Seq<int>) -> bool {

+spec fn is_sorted(s: Seq<int>) -> bool {

     forall|i: int| 0 <= i < s.len()-1 ==> s[i] <= s[i+1]

 }

-spec fn SortSpec(input: Seq<int>, output: Seq<int>) -> bool {

-    and IsSorted(output)

-  and multiset(output) == multiset(input)

+

+spec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool {

+    && is_sorted(output)

+    && output.to_multiset() == input.to_multiset()

 }

 

-fn merge_sort(input: Seq<int>) -> (output: Seq<int>)

-    ensures SortSpec(input, output)

+pub fn merge_sort(input: Seq<int>) -> (output: Seq<int>)

+    ensures(sort_spec(input, output))

 {

 }

 

+pub fn merge(a: Seq<int>, b: Seq<int>) -> (output: Seq<int>)

+    requires(is_sorted(a))

+    requires(is_sorted(b))

+    ensures(sort_spec(a.add(b), output))

+{

+}

+

+pub fn fast_sort(input: Seq<int>) -> (output: Seq<int>)

+{

 }

================================================================================
Comparing translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec.rs
+++ verus_specs/translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec.rs
@@ -1,14 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Somatorio(a: Vec<nat>) -> (s: nat)

-    ensures s == SomaAte(a,a.len())

+spec fn SomaAte(a: &[nat], i: nat) -> nat

+    recommends 0 <= i <= a.len()

 {

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + SomaAte(a, i-1)

+    }

 }

 

+

+pub fn Somatorio(a: &[nat]) -> (s: nat)

+    ensures(s == SomaAte(a, a.len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec.rs
+++ verus_specs/translations/atomizer_supported/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec.rs
@@ -1,14 +1,8 @@
+spec fn Fat(n: nat) -> nat {

+    if n == 0 { 1 } else { n * Fat((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fatorial(n: nat) -> (r: nat)

+pub fn Fatorial(n: nat) -> (r: nat)

     ensures r == Fat(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/tangent-finder_tmp_tmpgyzf44ve_circles_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/tangent-finder_tmp_tmpgyzf44ve_circles_spec.rs
+++ verus_specs/translations/atomizer_supported/tangent-finder_tmp_tmpgyzf44ve_circles_spec.rs
@@ -1,17 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Tangent(r: Vec<int>, x: Vec<int>) -> (b: bool)

-    requires forall|i: int, j: int| 0 <= i <= j < x.len() ==> x[i] <= x[j]

-             forall|i: int, j: int| (0 <= i < r.len() and 0 <= j < x.len()) ==> (r[i] >= 0 and x[j] >= 0)

-    ensures !b ==> forall|i: int, j: int| 0 <= i< r.len() and 0 <= j < x.len() ==> r[i] != x[j],

-            b ==> exists|i: int, j: int| 0 <= i< r.len() and 0 <= j < x.len() and r[i] == x[j]

+pub fn tangent(r: &[i32], x: &[i32]) -> (b: bool)

+    requires(

+        forall|i: usize, j: usize| 0 <= i <= j < x.len() ==> x[i] <= x[j]

+    )

+    requires(

+        forall|i: usize, j: usize| (0 <= i < r.len() && 0 <= j < x.len()) ==> (r[i] >= 0 && x[j] >= 0)

+    )

+    ensures(|b: bool|

+        !b ==> forall|i: usize, j: usize| 0 <= i < r.len() && 0 <= j < x.len() ==> r[i] != x[j]

+    )

+    ensures(|b: bool|

+        b ==> exists|i: usize, j: usize| 0 <= i < r.len() && 0 <= j < x.len() && r[i] == x[j]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec.rs
+++ verus_specs/translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec.rs
@@ -1,58 +1,92 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn notin(y: nat, x: Vec<nat>, x: Seq<nat>) -> bool {

+spec fn sum(X_val: &[int], X_crd: &[nat],

+           v_val: &[int], v_crd: &[nat], kX: nat, kV: nat, pX_end: nat, pV_end: nat) -> int

+    recommends

+        X_val.len() == X_crd.len(),

+        pX_end <= X_crd.len(),

+        0 <= kX <= X_crd.len(),

+        v_val.len() == v_crd.len(),

+        pV_end <= v_crd.len(),

+        0 <= kV <= v_crd.len(),

+    decreases pX_end + pV_end - kX - kV

+{

+    if pV_end <= kV || pX_end <= kX {

+        0

+    } else if X_crd[kX as int] == v_crd[kV as int] {

+        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + v_val[kV as int] * X_val[kX as int]

+    } else if X_crd[kX as int] < v_crd[kV as int] {

+        sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)

+    } else {

+        sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)

+    }

+}

+

+spec fn min(x: nat, y: nat) -> nat {

+    if x <= y { x } else { y }

+}

+

+spec fn notin(y: nat, x: &[nat]) -> bool {

     forall|i: int| 0 <= i < x.len() ==> y != x[i]

 }

 

-fn DSpMSpV(X_val: Vec<int>, X_crd: Vec<nat>, X_pos: Vec<nat>, X_crd1: Vec<nat>, X_len: nat, v_val: Vec<int>, v_crd: Vec<nat>) -> y: Vec<int>, j: : 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];

-  requires forall i :: 0 <= i < X_pos.Length ==> 0 <= X_pos[i] <= X_val.Length

-

-  requires X_len >= X_crd1.Length

-  requires forall i :: 0 <= i < X_crd1.Length ==> X_crd1[i] < X_len

-

-  requires X_crd1.Length < X_pos.Length

-  requires forall i, j: : 0 <= i < j < X_crd1.Length ==> X_crd1[i] < X_crd1[j]

-

-

-  requires v_val.Length == v_crd.Length

-

-  ensures y.Length == X_len

-  ensures forall i :: 0 <= i < y.Length ==> 

-    y[i] == 

-      if index(i, X_crd1) < X_crd1.Length then 

-        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)

-      else 0

-  {

+spec fn notin_seq(y: nat, x: Seq<nat>) -> bool {

+    forall|i: int| 0 <= i < x.len() ==> y != x[i]

 }

 

+spec fn index_seq(x: nat, y: Seq<nat>) -> nat

+    ensures |ret: nat| ret >= y.len() ==> notin_seq(x, y),

+    ensures |ret: nat| ret < y.len() ==> y[ret as int] == x,

+    decreases y.len()

+{

+    if y.len() == 0 {

+        0

+    } else {

+        if y[0] == x {

+            0

+        } else {

+            1 + index_seq(x, y.subrange(1, y.len() as int))

+        }

+    }

+}

 

+spec fn index(x: nat, y: &[nat]) -> nat

+    ensures |ret: nat| ret >= y.len() ==> notin(x, y),

+    ensures |ret: nat| ret < y.len() ==> y[ret as int] == x

+{

+    index_seq(x, y@)

+}

 

+pub fn DSpMSpV(X_val: &[int], X_crd: &[nat], X_pos: &[nat],

+               X_crd1: &[nat], X_len: nat,

+               v_val: &[int], v_crd: &[nat]) -> (y: Vec<int>)

+    requires

+        X_pos.len() >= 1,

+        X_val.len() == X_crd.len(),

+        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],

+        forall|i: int| 0 <= i < X_pos.len() ==> 0 <= X_pos[i] <= X_val.len(),

+        X_len >= X_crd1.len(),

+        forall|i: int| 0 <= i < X_crd1.len() ==> X_crd1[i] < X_len,

+        X_crd1.len() < X_pos.len(),

+        forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> X_crd1[i] < X_crd1[j],

+        v_val.len() == v_crd.len()

+    ensures

+        y.len() == X_len,

+        forall|i: int| 0 <= i < y.len() ==> 

+            y[i] == 

+                if index(i as nat, X_crd1) < X_crd1.len() {

+                    sum(X_val, X_crd, v_val, v_crd, X_pos[index(i as nat, X_crd1) as int], 0, X_pos[index(i as nat, X_crd1) as int + 1], v_val.len())

+                } else {

+                    0

+                }

+{

+    unimplemented!()

+}

 

-method Main(

-    requires X_pos.len() >= 1,

-             X_val.len() == X_crd.len(),

-             forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j];,

-             forall|i: int| 0 <= i < X_pos.len() ==> 0 <= X_pos[i] <= X_val.len(),

-             X_len >= X_crd1.len(),

-             forall|i: int| 0 <= i < X_crd1.len() ==> X_crd1[i] < X_len,

-             X_crd1.len() < X_pos.len(),

-             forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> X_crd1[i] < X_crd1[j]

-

-

-             v_val.len() == v_crd.len()

-    ensures y.len() == X_len,

-            forall|i: int| 0 <= i < y.len() ==> 

-    y[i] == 

-      if index(i, X_crd1) < X_crd1.len() then 

-        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.len())

-      else 0

-{

+pub fn Main() {

+    

 }

 

 }

================================================================================
Comparing translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec.rs
+++ verus_specs/translations/atomizer_supported/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec.rs
@@ -1,20 +1,39 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn SpMV(X_val: Vec<int>, X_crd: Vec<nat>, X_pos: Vec<nat>, v: Vec<int>) -> (y: Vec<int>)

-    requires X_crd.len() >= 1,

-             X_crd.len() == X_val.len();,

-             forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j];,

-             forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

-             forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

-             X_pos.len() >= 1

-    ensures y.len() + 1 == X_pos.len(),

-            forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])

+spec fn sum(X_val: &[int], X_crd: &[nat], v: &[int], b: int, k: int) -> int

+    recommends

+        X_val.len() >= b >= 0,

+        k <= X_val.len(),

+        X_val.len() == X_crd.len(),

+        forall|i: int| 0 <= i < X_crd.len() ==> 0 <= X_crd[i] < v.len(),

+    decreases k - b

+{

+    if k <= b {

+        0

+    } else {

+        sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]

+    }

+}

+

+pub fn SpMV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], v: &[int]) -> (y: Vec<int>)

+    requires(

+        X_crd.len() >= 1,

+        X_crd.len() == X_val.len(),

+        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],

+        forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

+        forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

+        X_pos.len() >= 1,

+    )

+    ensures(

+        y.len() + 1 == X_pos.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1]),

+    )

+{

+}

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec.rs
+++ verus_specs/translations/atomizer_supported/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec.rs
@@ -1,8 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

@@ -10,4 +6,9 @@
     true

 }

 

+pub fn Isort(a: &mut Vec<nat>)

+    ensures sorted(a@)

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec.rs
+++ verus_specs/translations/atomizer_supported/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec.rs
@@ -1,19 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+fn getSize(i: int, j: int) -> int

+{

+    j - i + 1    

+}

 

-verus! {

 

-fn longestZero(a: Vec<int>) -> sz: int, pos: int

-    requires 1 <= a.len()

-    ensures 0 <= sz <= a.len(),

-            0 <= pos < a.len(),

-            pos + sz <= a.len(),

-            forall i:int  :: pos <= i < pos + sz ==> a[i] == 0,

-            forall|i: int, j: int| (0 <= i < j < a.len() and getSize(i, j) > sz) ==> exists|k: int| i <= k <= j and a[k] != 0

+

+

+

+

+

+pub fn longestZero(a: &[int]) -> (sz: int, pos: int)   

+    requires(1 <= a.len())

+    ensures(|result: (int, int)| {

+        let (sz, pos) = result;

+        0 <= sz <= a.len() &&

+        0 <= pos < a.len() &&

+        pos + sz <= a.len() &&

+        (forall|i: int| pos <= i < pos + sz ==> a[i] == 0) &&

+        (forall|i: int, j: int| (0 <= i < j < a.len() && getSize(i, j) > sz) ==> exists|k: int| i <= k <= j && a[k] != 0)

+    })

 {

 }

 

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec.rs
+++ verus_specs/translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec.rs
@@ -1,16 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn torneo(Valores: array?<real>, i: int, j: int, k: int) -> pos_padre: int, pos_madre: int

-    requires Valores != null and Valores.len() >= 20 and Valores.len() < 50 and i >= 0 and j >= 0 and k >= 0,

-             i < Valores.len() and j < Valores.len() and k < Valores.len() and i != j and j != k and k != i

-    ensures exists p, q, r | p in

+pub fn torneo(valores: &[f64], i: usize, j: usize, k: usize) -> (pos_padre: usize, pos_madre: usize)

+    requires(

+        valores.len() >= 20 && valores.len() < 50 && 

+        i < valores.len() && j < valores.len() && k < valores.len() && 

+        i != j && j != k && k != i

+    )

+    ensures(|result: (usize, usize)| {

+        let (pos_padre, pos_madre) = result;

+        exists|p: usize, q: usize, r: usize| {

+            &&& (p == i || p == j || p == k)

+            &&& (q == i || q == j || q == k) 

+            &&& (r == i || r == j || r == k)

+            &&& p != q && q != r && p != r

+            &&& valores[p] >= valores[q] && valores[q] >= valores[r]

+            &&& pos_padre == p && pos_madre == q

+        }

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec.rs
+++ verus_specs/translations/atomizer_supported/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec.rs
@@ -1,15 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn suma_componentes(V: array?<int>) -> (suma: int)

-    requires V != null

-    ensures suma == suma_aux(V, 0)

+pub fn suma_componentes(V: &[i32]) -> (suma: i32)

+    requires(V.len() >= 0)

+    ensures(|result: i32| result == suma_aux(V, 0))

 {

 }

 

+spec fn suma_aux(V: &[i32], n: usize) -> i32

+    requires(0 <= n <= V.len())

+    decreases(V.len() - n)

+{

+    if n == V.len() {

+        0

+    } else {

+        V[n] + suma_aux(V, n + 1)

+    }

 }

================================================================================
Comparing translations/atomizer_supported/vmware-verification-2023_tmp_tmpoou5u54i_demos_leader_election_spec.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported/vmware-verification-2023_tmp_tmpoou5u54i_demos_leader_election_spec.rs
+++ verus_specs/translations/atomizer_supported/vmware-verification-2023_tmp_tmpoou5u54i_demos_leader_election_spec.rs
@@ -1,103 +1,202 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn ValidIdx(i: int) -> bool {

-    0<=i<ids.len()

-}

-

-spec fn UniqueIds() -> bool {

-    (forall|i: int, j | ValidIdx(i) and ValidIdx(j) and ids[i]==ids[j]: int| i == j)

-}

-

-spec fn WF() -> bool {

-    and 0 < ids.len()

-    and UniqueIds()

-}

-

-spec fn WF(c: Constants) -> bool {

-    and c.WF()

-    and highest_heard.len() == c.ids.len()

-}

-

-spec fn Init(c: Constants, v: Variables) -> bool {

-    and v.WF(c)

-  and c.UniqueIds()

-

-  and (forall|i | c.ValidIdx(i): int| v.highest_heard[i] == -1)

-}

-

-spec fn Transmission(c: Constants, v: Variables, v': Variables, srcidx: nat) -> bool {

-    and v.WF(c)

-  and v'.WF(c)

-  and c.ValidIdx(srcidx)

-

-

-  and var dstidx := NextIdx(c, srcidx);

-

-

-  and var message := max(v.highest_heard[srcidx], c.ids[srcidx]);

-

-

-  and var dst_new_max := max(v.highest_heard[dstidx], message);

-

-

-  and v' == v.(highest_heard := v.highest_heard[dstidx := dst_new_max])

-}

-

-spec fn NextStep(c: Constants, v: Variables, v': Variables, step: Step) -> bool {

+

+

+

+pub struct Constants {

+    pub ids: Seq<nat>,

+}

+

+impl Constants {

+    pub open spec fn ValidIdx(&self, i: int) -> bool {

+        0 <= i < self.ids.len()

+    }

+

+    pub open spec fn UniqueIds(&self) -> bool {

+        forall|i: int, j: int| self.ValidIdx(i) && self.ValidIdx(j) && self.ids[i] == self.ids[j] ==> i == j

+    }

+

+    pub open spec fn WF(&self) -> bool {

+        &&& 0 < self.ids.len()

+        &&& self.UniqueIds()

+    }

+}

+

+

+

+

+

+pub struct Variables {

+    pub highest_heard: Seq<int>,

+}

+

+impl Variables {

+    pub open spec fn WF(&self, c: Constants) -> bool {

+        &&& c.WF()

+        &&& self.highest_heard.len() == c.ids.len()

+    }

+}

+

+

+

+pub open spec fn Init(c: Constants, v: Variables) -> bool {

+    &&& v.WF(c)

+    &&& c.UniqueIds()

+

+    &&& forall|i: int| c.ValidIdx(i) ==> v.highest_heard[i] == -1

+}

+

+

+

+pub open spec fn max(a: int, b: int) -> int {

+    if a > b { a } else { b }

+}

+

+

+

+pub open spec fn NextIdx(c: Constants, idx: nat) -> nat

+    recommends c.WF(), c.ValidIdx(idx as int)

+{

+    if idx + 1 == c.ids.len() { 0 } else { idx + 1 }

+}

+

+

+

+pub open spec fn Transmission(c: Constants, v: Variables, v_prime: Variables, srcidx: nat) -> bool {

+    &&& v.WF(c)

+    &&& v_prime.WF(c)

+    &&& c.ValidIdx(srcidx as int)

+

+    &&& {

+        let dstidx = NextIdx(c, srcidx);

+

+        let message = max(v.highest_heard[srcidx as int], c.ids[srcidx as int]);

+

+        let dst_new_max = max(v.highest_heard[dstidx as int], message);

+

+        v_prime == Variables { highest_heard: v.highest_heard.update(dstidx as int, dst_new_max) }

+    }

+}

+

+

+

+pub enum Step {

+    TransmissionStep { srcidx: nat },

+}

+

+

+

+pub open spec fn NextStep(c: Constants, v: Variables, v_prime: Variables, step: Step) -> bool {

     match step {

-    case TransmissionStep(srcidx) => Transmission(c, v, v', srcidx)

-}

-

-spec fn Next(c: Constants, v: Variables, v': Variables) -> bool {

-    exists|step: int| NextStep(c, v, v', step)

-}

-

-spec fn IsLeader(c: Constants, v: Variables, i: int)

-  requires v.WF(c) -> bool {

-    and c.ValidIdx(i)

-  and v.highest_heard[i] == c.ids[i]

-}

-

-spec fn Safety(c: Constants, v: Variables)

-  requires v.WF(c) -> bool {

-    forall|i: int, j | IsLeader(c: int, v: int, i) and IsLeader(c: int, v: int, j): int| i == j

-}

-

-spec fn IsChord(c: Constants, v: Variables, start: int, end: int) -> bool {

-    and v.WF(c)

-  and c.ValidIdx(start)

-  and c.ValidIdx(end)

-  and c.ids[start] == v.highest_heard[end]

-}

-

-spec fn Between(start: int, node: int, end: int) -> bool {

-    if start < end

-  then start < node < end

-  else node < end or start < node

-}

-

-spec fn OnChordHeardDominatesId(c: Constants, v: Variables, start: int, end: int)

-  requires v.WF(c) -> bool {

-    forall|node | Between(start: int, node: int, end) and c.ValidIdx(node): int| v.highest_heard[node] > c.ids[node]

-}

-

-spec fn OnChordHeardDominatesIdInv(c: Constants, v: Variables) -> bool {

-    and v.WF(c)

-  and (forall|start: int, end

-       | IsChord(c: int, v: int, start: int, end): int| OnChordHeardDominatesId(c, v, start, end)

-          )

-}

-

-spec fn Inv(c: Constants, v: Variables) -> bool {

-    and v.WF(c)

-  and OnChordHeardDominatesIdInv(c, v)

-  and Safety(c, v)

+        Step::TransmissionStep { srcidx } => Transmission(c, v, v_prime, srcidx),

+    }

+}

+

+

+

+pub open spec fn Next(c: Constants, v: Variables, v_prime: Variables) -> bool {

+    exists|step: Step| NextStep(c, v, v_prime, step)

+}

+

+

+

+

+

+

+

+

+

+

+

+pub open spec fn IsLeader(c: Constants, v: Variables, i: int) -> bool

+    recommends v.WF(c)

+{

+    &&& c.ValidIdx(i)

+    &&& v.highest_heard[i] == c.ids[i]

+}

+

+

+

+pub open spec fn Safety(c: Constants, v: Variables) -> bool

+    recommends v.WF(c)

+{

+    forall|i: int, j: int| IsLeader(c, v, i) && IsLeader(c, v, j) ==> i == j

+}

+

+

+

+

+

+

+

+

+

+

+

+pub open spec fn IsChord(c: Constants, v: Variables, start: int, end: int) -> bool {

+    &&& v.WF(c)

+    &&& c.ValidIdx(start)

+    &&& c.ValidIdx(end)

+    &&& c.ids[start] == v.highest_heard[end]

+}

+

+

+

+pub open spec fn Between(start: int, node: int, end: int) -> bool {

+    if start < end {

+        start < node < end

+    } else {

+        node < end || start < node

+    }

+}

+

+

+

+pub open spec fn OnChordHeardDominatesId(c: Constants, v: Variables, start: int, end: int) -> bool

+    recommends v.WF(c)

+{

+    forall|node: int| Between(start, node, end) && c.ValidIdx(node) ==> v.highest_heard[node] > c.ids[node]

+}

+

+

+

+pub open spec fn OnChordHeardDominatesIdInv(c: Constants, v: Variables) -> bool {

+    &&& v.WF(c)

+    &&& forall|start: int, end: int| IsChord(c, v, start, end) ==> OnChordHeardDominatesId(c, v, start, end)

+}

+

+

+

+pub open spec fn Inv(c: Constants, v: Variables) -> bool {

+    &&& v.WF(c)

+    &&& OnChordHeardDominatesIdInv(c, v)

+    &&& Safety(c, v)

+}

+

+

+

+pub proof fn InitImpliesInv(c: Constants, v: Variables)

+    requires Init(c, v)

+    ensures Inv(c, v)

+{

+}

+

+

+

+pub proof fn NextPreservesInv(c: Constants, v: Variables, v_prime: Variables)

+    requires Inv(c, v), Next(c, v, v_prime)

+    ensures Inv(c, v_prime)

+{

+}

+

+

+

+pub proof fn InvImpliesSafety(c: Constants, v: Variables)

+    requires Inv(c, v)

+    ensures Safety(c, v)

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/630-dafny_tmp_tmpz2kokaiq_Solution_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/630-dafny_tmp_tmpz2kokaiq_Solution_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/630-dafny_tmp_tmpz2kokaiq_Solution_spec_task_1.rs
@@ -1,16 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn BinarySearch(a: Vec<int>, x: int) -> (index: int)

-    requires sorted(a)

-    ensures 0 <= index < a.len() ==> a[index] == x,

-            index == -1 ==> forall i : int :: 0 <= i < a.len() ==> a[i] != x

+spec fn sorted(a: &[int]) -> bool

 {

+   forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

 }

 

+

+

+

+pub fn BinarySearch(a: &[int], x: int) -> (index: int)

+    requires(sorted(a))

+    ensures(0 <= index < a.len() ==> a[index] == x)

+    ensures(index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_1.rs
@@ -1,17 +1,69 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Sorted(q: Seq<int>) -> bool {

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

 

-fn MergeSort(a: Vec<int>) -> (b: Vec<int>)

-    ensures b.len() == a.len() and Sorted(b[..]) and multiset(a[..]) == multiset(b[..])

+pub fn merge_sort(a: &[int]) -> (b: Vec<int>)

+    ensures

+        b.len() == a.len() && sorted(b@) && a@.to_multiset() == b@.to_multiset()

+{

+}

+

+pub fn merge(b: &mut [int], c: &[int], d: &[int])

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@)

+    ensures

+        sorted(b@) && b@.to_multiset() == c@.to_multiset() + d@.to_multiset()

+{

+}

+

+pub fn merge_loop(b: &mut [int], c: &[int], d: &[int], i0: usize, j0: usize) -> (i: usize, j: usize)

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@),

+        i0 <= c.len() && j0 <= d.len() && i0 + j0 <= b.len(),

+        inv_sub_set(b@, c@, d@, i0, j0),

+        inv_sorted(b@, c@, d@, i0, j0),

+        i0 + j0 < b.len()

+    ensures

+        i <= c.len() && j <= d.len() && i + j <= b.len(),

+        inv_sub_set(b@, c@, d@, i, j),

+        inv_sorted(b@, c@, d@, i, j),

+        0 <= c.len() - i < c.len() - i0 || (c.len() - i == c.len() - i0 && 0 <= d.len() - j < d.len() - j0)

+{

+}

+

+spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool;

+

+spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool;

+

+proof fn lemma_multisets_equals(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires

+        i == c.len(),

+        j == d.len(),

+        i + j == b.len(),

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+    ensures

+        b.to_multiset() == c.to_multiset() + d.to_multiset()

+{

+}

+

+proof fn lemma_inv_subset_take_value_from_c(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize);

+

+proof fn lemma_inv_subset_take_value_from_d(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires

+        i <= c.len(),

+        j < d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[i + j as int] == d[j as int]

+    ensures

+        b.subrange(0, i + j + 1 as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j + 1 as int).to_multiset()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_2.rs
@@ -1,98 +1,69 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Sorted(q: Seq<int>) -> bool {

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

 

-fn Merge(b: Vec<int>, c: Vec<int>, d: Vec<int>, correctly, efficiently, clearly

-

-DO NOT modify the specification or any other part of the method's signature

-*/

-

-method Merge(b: Vec<int>, c: Vec<int>, d: Vec<int>, c: Vec<int>, d: Vec<int>, i0: nat, j0: nat) -> i: nat, j: nat)

-		requires b != c && b != d && b.Length == c.Length + d.Length

-		requires Sorted(c[..]) && Sorted(d[..])

-		requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length

-		requires InvSubSet(b[..], c[..], d[..], i0, j0)

-		requires InvSorted(b[..], c[..], d[..], i0, j0)

-		requires i0 + j0 < b.Length

-

-		modifies b

-

-		ensures i <= c.Length && j <= d.Length && i + j <= b.Length

-		ensures InvSubSet(b[..], c[..], d[..], i, j)

-		ensures InvSorted(b[..], c[..], d[..], i, j)

-

-		ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)

-		{

-

-			i, j: = i0, j0;

-				

-				if(i == c.Length || (j< d.Length && d[j] < c[i])){

-

-				b[i+j]: = d[j];

-				lemmaInvSubsetTakeValueFromD(b[..], c[..], d[..], i, j);

-

-				j: = j + 1;

-			}

-			else{

-

-				

-				b[i+j] := c[i];

-

-				lemmaInvSubsetTakeValueFromC(b[..], c[..], d[..], i, j);

-				i: = i + 1;

-			}

-

-

-		}

-

-	

-

-

-

-

-

-

-

-

-

-

-

-lemma LemmaMultysetsEquals (b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat

-    requires b != c and b != d and b.len() == c.len() + d.len(),

-             Sorted(c[..]) and Sorted(d[..]),

-             b != c and b != d and b.len() == c.len() + d.len(),

-             Sorted(c[..]) and Sorted(d[..]),

-             b != c and b != d and b.len() == c.len() + d.len(),

-             Sorted(c[..]) and Sorted(d[..]),

-             i0 <= c.len() and j0 <= d.len() and i0 + j0 <= b.len(),

-             InvSubSet(b[..],c[..],d[..],i0,j0),

-             InvSorted(b[..],c[..],d[..],i0,j0),

-             i0 + j0 < b.len()

-

-		modifies b,

-             i == c.len();,

-             j == d.len();,

-             i + j == b.len();,

-             multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])

-    ensures Sorted(b[..]) and multiset(b[..]) == multiset(c[..])+multiset(d[..])

-	modifies b,

-            Sorted(b[..]) and multiset(b[..]) == multiset(c[..])+multiset(d[..])

-	modifies b,

-            i <= c.len() and j <= d.len() and i + j <= b.len(),

-            InvSubSet(b[..],c[..],d[..],i,j),

-            InvSorted(b[..],c[..],d[..],i,j)

-

-            ensures 0 <= c.len() - i < c.len() - i0 or (c.len() - i == c.len() - i0 and 0 <= d.len() - j < d.len() - j0),

-            multiset(b[..]) == multiset(c[..])+multiset(d[..]);

+pub fn merge(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>)

+    requires(

+        old(b).len() == c.len() + d.len() &&

+        sorted(c@) && sorted(d@)

+    )

+    ensures(

+        sorted(b@) && 

+        b@.to_multiset() == c@.to_multiset() + d@.to_multiset()

+    )

 {

 }

 

+pub fn merge_loop(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>, i0: usize, j0: usize) -> (i: usize, j: usize)

+    requires(

+        old(b).len() == c.len() + d.len() &&

+        sorted(c@) && sorted(d@) &&

+        i0 <= c.len() && j0 <= d.len() && i0 + j0 <= old(b).len() &&

+        inv_sub_set(old(b)@, c@, d@, i0, j0) &&

+        inv_sorted(old(b)@, c@, d@, i0, j0) &&

+        i0 + j0 < old(b).len()

+    )

+    ensures(

+        i <= c.len() && j <= d.len() && i + j <= b.len() &&

+        inv_sub_set(b@, c@, d@, i, j) &&

+        inv_sorted(b@, c@, d@, i, j) &&

+        (0 <= c.len() - i < c.len() - i0 || (c.len() - i == c.len() - i0 && 0 <= d.len() - j < d.len() - j0))

+    )

+{

+}

+

+spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool;

+

+spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize) -> bool;

+

+proof fn lemma_multisets_equals(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires(

+        i == c.len() &&

+        j == d.len() &&

+        i + j == b.len() &&

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+    )

+    ensures(

+        b.to_multiset() == c.to_multiset() + d.to_multiset()

+    )

+{

+}

+

+proof fn lemma_inv_subset_take_value_from_c(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize);

+

+proof fn lemma_inv_subset_take_value_from_d(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: usize, j: usize)

+    requires(

+        i <= c.len() &&

+        j < d.len() &&

+        i + j < b.len() &&

+        c.len() + d.len() == b.len() &&

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset() &&

+        b[i + j as int] == d[j as int]

+    )

+    ensures(

+        b.subrange(0, i + j + 1 as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j + 1 as int).to_multiset()

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_spec_task_3.rs
@@ -1,18 +1,79 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Sorted(q: Seq<int>) -> bool {

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

 

-fn MergeSort(a: Vec<int>) -> (b: Vec<int>)

-    ensures b.len() == a.len() and Sorted(b[..]) and multiset(a[..]) == multiset(b[..])

+pub fn merge_sort(a: &mut Vec<int>) -> (b: Vec<int>)

+    ensures

+        b.len() == a.len() && sorted(b@) && a@.to_multiset() == b@.to_multiset()

 {

+    unimplemented!()

+}

+

+pub fn merge(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>)

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@)

+    ensures

+        sorted(b@) && b@.to_multiset() == c@.to_multiset() + d@.to_multiset()

+{

+    unimplemented!()

+}

+

+pub fn merge_loop(b: &mut Vec<int>, c: &Vec<int>, d: &Vec<int>, i0: nat, j0: nat) -> (i: nat, j: nat)

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@),

+        i0 <= c.len() && j0 <= d.len() && i0 + j0 <= b.len(),

+        inv_sub_set(b@, c@, d@, i0, j0),

+        inv_sorted(b@, c@, d@, i0, j0),

+        i0 + j0 < b.len()

+    ensures

+        i <= c.len() && j <= d.len() && i + j <= b.len(),

+        inv_sub_set(b@, c@, d@, i, j),

+        inv_sorted(b@, c@, d@, i, j),

+        0 <= c.len() - i < c.len() - i0 || (c.len() - i == c.len() - i0 && 0 <= d.len() - j < d.len() - j0)

+{

+    unimplemented!()

+}

+

+spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool;

+

+spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool;

+

+proof fn lemma_multisets_equals(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat)

+    requires

+        i == c.len(),

+        j == d.len(),

+        i + j == b.len(),

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+    ensures

+        b.to_multiset() == c.to_multiset() + d.to_multiset()

+{

+    unimplemented!()

+}

+

+proof fn lemma_inv_subset_take_value_from_c(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat);

+

+proof fn lemma_inv_subset_take_value_from_d(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat)

+    requires

+        i <= c.len(),

+        j < d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, i + j as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[i + j as int] == d[j as int]

+    ensures

+        b.subrange(0, i + j + 1 as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j + 1 as int).to_multiset()

+{

+    unimplemented!()

+}

+

+pub fn main() {

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_1.rs
@@ -1,13 +1,3 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn GetMin(tree: Tree) -> (res: int)

+pub fn GetMin(tree: Tree) -> (res: int)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_2.rs
@@ -1,13 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn GetMax(tree: Tree) -> (res: int)

-{

+

+

+

+

+

+

+

+pub fn GetMax(tree: Tree) -> int {

 }

 

-}
+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_3.rs
@@ -1,35 +1,48 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

+pub enum Tree {

+    Empty,

+    Node { left: Box<Tree>, value: i32, right: Box<Tree> }

 }

 

-fn insert(tree: Tree, value: int) -> (res: Tree)

-    requires BinarySearchTree(tree)

-    ensures BinarySearchTree(res)

+pub open spec fn binary_search_tree(tree: Tree) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value, right } => {

+            (left.is_Empty() || left.get_Node_value() < value)

+            && (right.is_Empty() || right.get_Node_value() > value)

+            && binary_search_tree(*left) && binary_search_tree(*right)

+            && min_value(*right, value) && max_value(*left, value)

+        }

+    }

+}

+

+pub open spec fn max_value(tree: Tree, max: i32) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => {

+            (max > v) && max_value(*left, max) && max_value(*right, max)

+        }

+    }

+}

+

+pub open spec fn min_value(tree: Tree, min: i32) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => {

+            (min < v) && min_value(*left, min) && min_value(*right, min)

+        }

+    }

+}

+

+pub fn insert(tree: Tree, value: i32) -> (res: Tree)

+    requires(binary_search_tree(tree))

+    ensures(binary_search_tree(res))

 {

 }

 

+pub fn insert_recursion(tree: Tree, value: i32) -> (res: Tree)

+    requires(binary_search_tree(tree))

+    ensures(res != Tree::Empty ==> binary_search_tree(res))

+    ensures(forall|x: i32| min_value(tree, x) && x < value ==> min_value(res, x))

+    ensures(forall|x: i32| max_value(tree, x) && x > value ==> max_value(res, x))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_4.rs
@@ -1,37 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

-}

-

-fn insertRecursion(tree: Tree, value: int) -> (res: Tree)

-    requires BinarySearchTree(tree)

-    ensures res != Empty ==> BinarySearchTree(res),

-            forall|x: int| minValue(tree, x) and x < value ==> minValue(res, x),

-            forall|x: int| maxValue(tree, x) and x > value ==> maxValue(res, x)

+pub fn insertRecursion(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(res != Empty ==> BinarySearchTree(res))

+    ensures(forall |x| minValue(tree, x) && x < value ==> minValue(res, x))

+    ensures(forall |x| maxValue(tree, x) && x > value ==> maxValue(res, x))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_5.rs
@@ -1,33 +1,38 @@
+datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

+spec fn BinarySearchTree(tree: Tree) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(_, _, _) =>

+      (tree.left == Tree::Empty || tree.left.value < tree.value)

+      && (tree.right == Tree::Empty || tree.right.value > tree.value)

+      && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)

+      && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)

+  }

 }

 

-fn GetMin(tree: Tree) -> (res: int)

+spec fn maxValue(tree: Tree, max: int) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(left, v, right) => (max > v) && maxValue(left, max) && maxValue(right, max)

+  }

+}

+

+spec fn minValue(tree: Tree, min: int) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(left, v, right) => (min < v) && minValue(left, min) && minValue(right, min)

+  }

+}

+

+pub fn GetMin(tree: Tree) -> (res: int)

 {

 }

 

+pub fn delete(tree: Tree, value: int) -> (res: Tree)

+  requires BinarySearchTree(tree)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_spec_task_8.rs
@@ -1,33 +1,90 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

+spec fn BinarySearchTree(tree: Tree) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(left, value, right) =>

+      (left == Tree::Empty || left.value < value)

+      && (right == Tree::Empty || right.value > value)

+      && BinarySearchTree(*left) && BinarySearchTree(*right)

+      && minValue(*right, value) && maxValue(*left, value)

+  }

 }

 

-fn GetMin(tree: Tree) -> (res: int)

+

+

+spec fn maxValue(tree: Tree, max: int) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(left, v, right) => (max > v) && maxValue(*left, max) && maxValue(*right, max)

+  }

+}

+

+

+

+spec fn minValue(tree: Tree, min: int) -> bool

+{

+  match tree {

+    Tree::Empty => true,

+    Tree::Node(left, v, right) => (min < v) && minValue(*left, min) && minValue(*right, min)

+  }

+}

+

+

+

+pub fn GetMin(tree: Tree) -> (res: int)

 {

 }

 

+

+

+pub fn GetMax(tree: Tree) -> (res: int)

+{

+}

+

+

+

+pub fn insert(tree: Tree, value: int) -> (res: Tree)

+  requires(BinarySearchTree(tree))

+  ensures(BinarySearchTree(res))

+{

+}

+

+

+

+pub fn insertRecursion(tree: Tree, value: int) -> (res: Tree)

+  requires(BinarySearchTree(tree))

+  ensures(res != Tree::Empty ==> BinarySearchTree(res))

+  ensures(forall|x: int| minValue(tree, x) && x < value ==> minValue(res, x))

+  ensures(forall|x: int| maxValue(tree, x) && x > value ==> maxValue(res, x))

+{

+}

+

+

+

+pub fn delete(tree: Tree, value: int) -> (res: Tree)

+  requires(BinarySearchTree(tree))

+

+

+{

+}

+

+

+

+pub fn Inorder(tree: Tree)

+{

+}

+

+

+

+pub fn Postorder(tree: Tree)

+{

+}

+

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_1.rs
@@ -1,15 +1,7 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn isPrefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_2.rs
@@ -1,15 +1,24 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn is_prefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

 }

 

-}
+

+

+

+

+pub fn is_substring(sub: &str, str: &str) -> bool

+    requires(0 < sub.len() <= str.len())

+{

+}

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_3.rs
@@ -1,15 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn isPrefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

 }

 

+

+

+

+

+pub fn isSubstring(sub: &str, str: &str) -> bool

+    requires(0 < sub.len() <= str.len())

+{

+}

+

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> bool

+    requires(0 < k <= str1.len() && 0 < k <= str2.len())

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_4.rs
@@ -1,15 +1,40 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn isPrefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

 }

 

-}
+

+

+

+

+

+pub fn isSubstring(sub: &str, str: &str) -> bool

+    requires(0 < sub.len() <= str.len())

+{

+}

+

+

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> bool

+    requires(0 < k <= str1.len() && 0 < k <= str2.len())

+{

+}

+

+

+

+

+

+

+pub fn maxCommonSubstringLength(str1: &str, str2: &str) -> nat

+    requires(0 < str1.len() && 0 < str1.len())

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_spec_task_5.rs
@@ -1,15 +1,45 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    requires 0 < pre.len() <= str.len()

-             that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: "str[i] != pre[i]"

+pub fn isPrefix(pre: &str, str: &str) -> bool

+    requires(0 < pre.len() <= str.len())

 {

 }

 

+

+

+

+

+

+pub fn isSubstring(sub: &str, str: &str) -> bool

+    requires(0 < sub.len() <= str.len())

+{

+}

+

+

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> bool

+    requires(0 < k <= str1.len() && 0 < k <= str2.len())

+{

+}

+

+

+

+

+

+

+pub fn maxCommonSubstringLength(str1: &str, str2: &str) -> nat

+    requires(0 < str1.len() && 0 < str1.len())

+{

+}

+

+

+

+

+

+

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(x: nat, y: nat) -> (r: nat)

-    ensures (r >= x and r >=y),

-            (r == x or r == y)

+pub fn Max(x: nat, y: nat) -> (r: nat)

+    ensures(r >= x && r >= y)

+    ensures(r == x || r == y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(x: nat, y: nat) -> (r: nat)

-    ensures (r >= x and r >=y),

-            (r == x or r == y)

+pub fn Max(x: nat, y: nat) -> (r: nat)

+    ensures(r >= x && r >= y)

+    ensures(r == x || r == y)

 {

 }

 

+pub fn Test()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_3.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn m1(x: int, y: int) -> (z: int)

-    requires 0 < x < y

-    ensures z >= 0 and z <= y and z != x

+pub fn m1(x: int, y: int) -> (z: int)

+    requires(0 < x < y)

+    ensures(|z: int| z >= 0 && z <= y && z != x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_4.rs
@@ -1,14 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fib(n: nat) -> (r: nat)

-    ensures r == fib(n)

-{

+spec fn fib(n: nat) -> nat {

+    if n == 0 { 1 } else

+    if n == 1 { 1 } else

+    fib((n - 1) as nat) + fib((n - 2) as nat)

 }

 

+pub fn Fib(n: nat) -> (r: nat)

+    ensures(r == fib(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_5.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn addImp(l: List<int>) -> (s: int)

-    ensures s == add(l)

+pub fn add_imp(l: List<int>) -> (s: int)

+    ensures(s == add(l))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_spec_task_6.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxA(a: Vec<int>) -> (m: int)

+pub fn MaxA(a: &[i32]) -> (m: i32)

     requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= m,

-            exists|i: int| 0 <= i < a.len() and a[i] == m

+    ensures forall|i: usize| 0 <= i < a.len() ==> a[i] <= m

+    ensures exists|i: usize| 0 <= i < a.len() && a[i] == m

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_1.rs
@@ -1,15 +1,55 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn query(a: Vec<int>, i: int, j: int) -> (s: int)

+

+

+

+spec fn sum(a: &[int], i: int, j: int) -> int

+    requires 0 <= i <= j <= a.len()

+    decreases j - i

+{

+    if i == j {

+        0

+    } else {

+        a[j-1] + sum(a, i, j-1)

+    }

+}

+

+

+

+

+

+pub fn query(a: &[int], i: int, j: int) -> (s: int)

     requires 0 <= i <= j <= a.len()

     ensures s == sum(a, i, j)

 {

 }

 

+

+

+

+

+pub fn query(a: &[int], i: int, j: int) -> (s: int)

+    requires 0 <= i <= j <= a.len()

+    ensures s == sum(a, i, j)

+{

+}

+

+

+

+

+pub fn query(a: &[int], i: int, j: int) -> (s: int)

+    requires 0 <= i <= j <= a.len()

+    ensures s == sum(a, i, j)

+{

+}

+

+

+

+

+

+

+

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_spec_task_2.rs
@@ -1,15 +1,41 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) -> (r: int)

-    requires is_prefix_sum_for(a,c) and 0 <= i <= j <= a.len() < c.len()

-    ensures r == sum(a, i,j)

+pub fn sum(a: &[int], i: int, j: int) -> int

+    requires(

+        0 <= i <= j <= a.len()

+    )

+{

+    unimplemented!()

+}

+

+pub proof fn queryLemma(a: &[int], i: int, j: int, k: int)

+    requires(

+        0 <= i <= k <= j <= a.len()

+    )

+    ensures(

+        sum(a, i, k) + sum(a, k, j) == sum(a, i, j)

+    )

 {

 }

 

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> int

+    requires(

+        is_prefix_sum_for(a, c) && 0 <= i <= j <= a.len() < c.len()

+    )

+    ensures(|r: int|

+        r == sum(a, i, j)

+    )

+{

+    unimplemented!()

+}

+

+pub spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool

+{

+    a.len() + 1 == c.len()

+    && c[0] == 0

+    && forall|j: int| 1 <= j <= a.len() ==> c[j] == sum(a, 0, j)

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn fillK(a: Vec<int>, n: int, k: int, c: int) -> (b: bool)

-    requires 0 <= c <= n,

-             n == a.len()

+pub fn fillK(a: &[i32], n: i32, k: i32, c: i32) -> (b: bool)

+    requires(0 <= c <= n)

+    requires(n == a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_spec_task_2.rs
@@ -1,14 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn containsSubString(a: Vec<char>, b: Vec<char>) -> (pos: int)

-    requires 0 <= b.len() <= a.len()

+pub fn containsSubString(a: &[char], b: &[char]) -> (pos: i32)

+    requires(0 <= b.len() <= a.len())

+    ensures(|pos: i32| true)

 {

-}

-

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_1.rs
@@ -1,15 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn query(a: Vec<int>, i: int, j: int) -> (res: int)

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

+{

+    if i == j { 0 } else { a[i as usize] + sum(a, i + 1, j) }

+}

+

+pub fn query(a: &[int], i: int, j: int) -> (res: int)

     requires 0 <= i <= j <= a.len()

     ensures res == sum(a, i, j)

 {

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_2.rs
@@ -1,44 +1,32 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn is_prefix_sum_for(a: Vec<int>, c: Vec<int>, a

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

 {

-    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]

+    if i == j { 0 } else { a[i as usize] + sum(a, i+1, j) }

 }

 

-

-

-

-lemma aux(a: array<int>, c: Vec<int>, i: int, j: int)

-    requires 0 <= i <= j <= a.Length

-    requires a.Length + 1 == c.Length

-    requires c[0] == 0

-    requires is_prefix_sum_for(a, c)

-    ensures forall k: int :: i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k] - c[i] + c[j] - c[k]

-{}

-

-

-

-

-

-

-method queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) returns (r: int)

-    requires a.Length + 1 == c.Length && c[0] == 0

-    requires 0 <= i <= j <= a.Length

-    requires is_prefix_sum_for(a, c)  

-    ensures r == sum(a, i, j) -> bool {

-    

+spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool

+{

+    a.len() + 1 == c.len() && c[0] == 0 &&

+    forall|i: int| 0 <= i < a.len() ==> c[(i+1) as usize] == c[i as usize] + a[i as usize]

 }

 

-fn queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) -> (r: int)

-    requires a.len() + 1 == c.len() and c[0] == 0,

+proof fn aux(a: &[int], c: &[int], i: int, j: int)

+    requires 0 <= i <= j <= a.len(),

+             a.len() + 1 == c.len(),

+             c[0] == 0,

+             is_prefix_sum_for(a, c)

+    ensures forall|k: int| i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k as usize] - c[i as usize] + c[j as usize] - c[k as usize]

+{

+}

+

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> (r: int)

+    requires a.len() + 1 == c.len() && c[0] == 0,

              0 <= i <= j <= a.len(),

-             is_prefix_sum_for(a,c)

+             is_prefix_sum_for(a, c)

     ensures r == sum(a, i, j)

 {

 }


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/CVS-handout1_tmp_tmptm52no3k_1_spec_task_3.rs
@@ -1,45 +1,42 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn is_prefix_sum_for(a: Vec<int>, c: Vec<int>, a

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

 {

-    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]

+    if i == j { 0 } else { a[i as usize] + sum(a, i+1, j) }

 }

 

-

-

-

-lemma aux(a: array<int>, c: Vec<int>, i: int, j: int)

-    requires 0 <= i <= j <= a.Length

-    requires a.Length + 1 == c.Length

-    requires c[0] == 0

-    requires is_prefix_sum_for(a, c)

-    ensures forall k: int :: i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k] - c[i] + c[j] - c[k]

-{}

-

-

-

-

-

-

-method queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) returns (r: int)

-    requires a.Length + 1 == c.Length && c[0] == 0

-    requires 0 <= i <= j <= a.Length

-    requires is_prefix_sum_for(a, c)  

-    ensures r == sum(a, i, j) -> bool {

-    

+spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool

+{

+    a.len() + 1 == c.len() &&

+    c[0] == 0 &&

+    forall|i: int| 0 <= i < a.len() ==> c[(i+1) as usize] == c[i as usize] + a[i as usize]

 }

 

-fn queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) -> (r: int)

-    requires a.len() + 1 == c.len() and c[0] == 0,

-             0 <= i <= j <= a.len(),

-             is_prefix_sum_for(a,c)

-    ensures r == sum(a, i, j)

+proof fn aux(a: &[int], c: &[int], i: int, j: int)

+    requires

+        0 <= i <= j <= a.len(),

+        a.len() + 1 == c.len(),

+        c[0] == 0,

+        is_prefix_sum_for(a, c)

+    ensures

+        forall|k: int| i <= k <= j ==> sum(a, i, k) + sum(a, k, j) == c[k as usize] - c[i as usize] + c[j as usize] - c[k as usize]

+{

+}

+

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> (r: int)

+    requires(

+        a.len() + 1 == c.len() && c[0] == 0,

+        0 <= i <= j <= a.len(),

+        is_prefix_sum_for(a, c)

+    )

+    ensures(r == sum(a, i, j))

+{

+}

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_abs_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_abs_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_abs_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures x>=0 ==> x==y,

-            x<0 ==> x+y==0

+pub fn abs(x: int) -> (y: int)

+    ensures(x >= 0 ==> x == y),

+    ensures(x < 0 ==> x + y == 0),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_all_digits_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_all_digits_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_all_digits_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn allDigits(s: String) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < s.len() ==> s[i] in "0123456789")

+pub fn all_digits(s: &str) -> (result: bool)

+    ensures(result <==> (forall|i: usize| 0 <= i < s.len() ==> "0123456789".contains(s.as_bytes()[i] as char)))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_array_append_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_array_append_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_array_append_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn append(a: Vec<int>, b: int) -> (c: Vec<int>)

-    ensures a[..] + [b] == c[..]

+pub fn append(a: &[int], b: int) -> (c: Vec<int>)

+    ensures(a@ + [b] == c@)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_array_concat_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_array_concat_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_array_concat_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn concat(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    ensures c.len()==b.len()+a.len(),

-            forall|k: int| 0 <= k < a.len() ==> c[k] == a[k],

-            forall|k: int| 0 <= k < b.len() ==> c[k+a.len()] == b[k]

+pub fn concat(a: &[int], b: &[int]) -> (c: Vec<int>)

+    ensures(c.len() == b.len() + a.len())

+    ensures(forall|k: int| 0 <= k < a.len() ==> c[k] == a[k])

+    ensures(forall|k: int| 0 <= k < b.len() ==> c[k + a.len()] == b[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_array_product_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_array_product_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_array_product_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arrayProduct(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] * b[i]==c[i]

+pub fn arrayProduct(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i && i < a.len() ==> a[i] * b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_array_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_array_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_array_sum_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arraySum(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] + b[i]==c[i]

+pub fn arraySum(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> a[i] + b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_avg_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_avg_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_avg_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeAvg(a: int, b: int) -> (avg: int)

-    ensures avg == (a+b)/2

+pub fn compute_avg(a: int, b: int) -> (avg: int)

+    ensures avg == (a + b) / 2

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_below_zero_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_below_zero_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_below_zero_spec_task_1.rs
@@ -1,18 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn below_zero(operations: Seq<int>) -> s: Vec<int>, result: bool

-    ensures s.len() == operations.len() + 1,

-            s[0]==0,

-            forall|i: int| 0 <= i < s.len()-1 ==> s[i+1]==s[i]+operations[i],

-            result == true ==> (exists|i: int| 1 <= i <= operations.len() and s[i] < 0),

-            result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

+pub fn below_zero(operations: Seq<int>) -> (s: Vec<int>, result: bool)

+    ensures

+        s.len() == operations.len() + 1,

+        s[0] == 0,

+        forall|i: int| 0 <= i < s.len() - 1 ==> s[i + 1] == s[i] + operations[i],

+        result == true ==> (exists|i: int| 1 <= i <= operations.len() && s[i] < 0),

+        result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_binary_search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_binary_search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_binary_search_spec_task_1.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, key: int) -> (n: int)

-    requires forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j]

-    ensures 0<= n <=a.len(),

-            forall|i: int| 0<= i < n ==> a[i] < key,

-            n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key,

-            forall|i: int| n<= i < a.len() ==> a[i]>=key

+pub fn binary_search(a: &[i32], key: i32) -> (n: usize)

+    requires(

+        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    ensures(|n: usize|

+        0 <= n <= a.len() &&

+        (forall|i: int| 0 <= i < n ==> a[i] < key) &&

+        (n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key) &&

+        (forall|i: int| n <= i < a.len() ==> a[i] >= key)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_cal_ans_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_cal_ans_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_cal_ans_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalDiv() -> x: int, y: int

-    ensures x==191/7,

-            y==191%7

+pub fn cal_div() -> (x: int, y: int)

+    ensures

+        x == 191 / 7,

+        y == 191 % 7,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_cal_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_cal_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_cal_sum_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sum(N: int) -> (s: int)

-    requires N >= 0

-    ensures s == N * (N + 1) / 2

+pub fn sum(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == n * (n + 1) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_canyon_search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_canyon_search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_canyon_search_spec_task_1.rs
@@ -1,18 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CanyonSearch(a: Vec<int>, b: Vec<int>) -> (d: nat)

-    requires a.len() !=0 and b.len()!=0,

-             forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j],

-             forall|i: int, j: int| 0<=i<j<b.len() ==> b[i]<=b[j]

-    ensures exists|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() and d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j]),

-            forall|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])

+pub fn canyon_search(a: &[i32], b: &[i32]) -> usize

+    requires(

+        a.len() != 0 && b.len() != 0

+    )

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < b.len() ==> b[i] <= b[j]

+    )

+    ensures(|d: usize|

+        exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() && d == if a[i] < b[j] { (b[j] - a[i]) as usize } else { (a[i] - b[j]) as usize }

+    )

+    ensures(|d: usize|

+        forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() ==> d <= if a[i] < b[j] { (b[j] - a[i]) as usize } else { (a[i] - b[j]) as usize }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_convert_map_key_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_convert_map_key_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_convert_map_key_spec_task_1.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn convert_map_key(inputs: map<nat, bool>, f: nat->nat) -> r: map<nat, bool>

-    requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)

-    ensures forall|k: int| k in inputs <==> f(k) in r,

-            forall|k: int| k in inputs ==> r[f(k)] == inputs[k]

+pub fn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)

+    requires(

+        forall|n1: nat, n2: nat| n1 != n2 ==> f(n1) != f(n2)

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k))

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_copy_part_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_copy_part_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_copy_part_spec_task_1.rs
@@ -1,19 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn copy(src: Vec<int>, sStart: nat, dest: Vec<int>, dStart: nat, len: nat) -> (r: Vec<int>)

-    requires src.len() >= sStart + len,

-             dest.len() >= dStart + len

-    ensures r.len() == dest.len(),

-            r[..dStart] == dest[..dStart],

-            r[dStart + len..] == dest[dStart + len..],

-            r[dStart..len+dStart] == src[sStart..len+sStart]

+pub fn copy(src: &[i32], sStart: usize, dest: &[i32], dStart: usize, len: usize) -> Vec<i32>

+    requires

+        src.len() >= sStart + len,

+        dest.len() >= dStart + len,

+    ensures |r: Vec<i32>|

+        r.len() == dest.len() &&

+        r[..dStart] == dest[..dStart] &&

+        r[dStart + len..] == dest[dStart + len..] &&

+        r[dStart..len + dStart] == src[sStart..len + sStart],

 {

-}

-

+    unimplemented!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_count_lessthan_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_count_lessthan_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_count_lessthan_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLessThan(numbers: set<int>, threshold: int) -> (count: int)

-    ensures count == set i .len() i in numbers and i < threshold|

+pub fn count_less_than(numbers: Set<int>, threshold: int) -> (count: int)

+    ensures count == numbers.filter(|i: int| *i < threshold).len()

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_double_quadruple_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_double_quadruple_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_double_quadruple_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DoubleQuadruple(x: int) -> a: int, b: int

-    ensures a == 2 * x and b == 4 * x

+pub fn DoubleQuadruple(x: int) -> (a: int, b: int)

+    ensures(a == 2 * x && b == 4 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_even_list_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_even_list_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_even_list_spec_task_1.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindEvenNumbers(arr: Vec<int>) -> (evenNumbers: Vec<int>)

-    ensures forall x

+pub fn find_even_numbers(arr: &[i32]) -> Vec<i32>

+    ensures(forall|x: i32| arr.contains(&x) && (x % 2 == 0) ==> result@.contains(&x))

+    ensures(forall|x: i32| !arr.contains(&x) ==> !result@.contains(&x))

+    ensures(forall|k: int| 0 <= k < result@.len() ==> result@[k] % 2 == 0)

+    ensures(forall|k: int, l: int| 0 <= k < l < result@.len() ==>

+        exists|n: int, m: int| 0 <= n < m < arr.len() && result@[k] == arr[n] && result@[l] == arr[m])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_find_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_find_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_find_spec_task_1.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(a: Vec<int>, key: int) -> (index: int)

-    ensures -1<=index<a.len(),

-            index!=-1 ==> a[index]==key and (forall|i: int| 0 <= i < index ==> a[i] != key),

-            index == -1 ==> (forall|i: int|0 <= i < a.len() ==> a[i] != key)

+pub fn find(a: &[i32], key: i32) -> (index: i32)

+    ensures(

+        -1 <= index < a.len(),

+        index != -1 ==> a[index as int] == key && forall|i: int| 0 <= i < index ==> a[i] != key,

+        index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != key,

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_integer_square_root_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_integer_square_root_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_integer_square_root_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareRoot(N: nat) -> (r: nat)

-    ensures r*r <= N < (r+1)*(r+1)

+pub fn square_root(n: nat) -> (r: nat)

+    ensures(r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_is_even_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_is_even_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_is_even_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeIsEven(x: int) -> (is_even: bool)

-    ensures (x % 2 == 0)==is_even

+pub fn compute_is_even(x: int) -> (is_even: bool)

+    ensures((x % 2 == 0) == is_even)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_is_palindrome_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_is_palindrome_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_is_palindrome_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPalindrome(x: Seq<char>) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1])

+pub fn is_palindrome(x: Seq<char>) -> (result: bool)

+    ensures(result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_linear_search1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_linear_search1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_linear_search1_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    ensures 0<=n<=a.len(),

-            n==a.len() or a[n]==e,

-            forall|i: int|0<=i < n ==> e!=a[i]

+pub fn linear_search(a: &[int], e: int) -> n: int

+    ensures(0 <= n <= a.len())

+    ensures(n == a.len() || a[n] == e)

+    ensures(forall|i: int| 0 <= i < n ==> e != a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_linear_search2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_linear_search2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_linear_search2_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    requires exists|i: int|0<=i<a.len() and a[i]==e

-    ensures 0<=n<a.len() and a[n]==e,

-            forall|k: int| 0 <= k < n ==> a[k]!=e

+pub fn linear_search(a: &[i32], e: i32) -> (n: usize)

+    requires(exists|i: usize| 0 <= i < a.len() && a[i] == e)

+    ensures(|n: usize| 0 <= n < a.len() && a[n] == e)

+    ensures(|n: usize| forall|k: usize| 0 <= k < n ==> a[k] != e)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_longest_prefix_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_longest_prefix_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_longest_prefix_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LongestCommonPrefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

-    ensures prefix.len() <= str1.len() and prefix == str1[0..prefix.len()]and prefix.len() <= str2.len() and prefix == str2[0..prefix.len()],

-            prefix.len()==str1.len() | .len()prefix==.len()str2 .len() (str1[.len()prefix]!=str2[.len()prefix|])

+pub fn longest_common_prefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

+    ensures(|prefix| <= |str1| && prefix == str1.subrange(0, |prefix| as int) && |prefix| <= |str2| && prefix == str2.subrange(0, |prefix| as int))

+    ensures(|prefix| == |str1| || |prefix| == |str2| || (str1[|prefix| as int] != str2[|prefix| as int]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_match_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_match_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_match_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Match(s: String, p: String) -> (b: bool)

-    requires s.len() == p.len()

-    ensures b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] or p[n] == '?'

+pub fn Match(s: String, p: String) -> (b: bool)

+    requires(s.len() == p.len())

+    ensures(b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] || p[n] == '?')

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_max_array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_max_array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_max_array_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxArray(a: Vec<int>) -> (m: int)

-    requires a.len() >= 1

-    ensures forall|k: int| 0 <= k < a.len() ==> m >= a[k],

-            exists|k: int| 0 <= k < a.len() and m == a[k]

+pub fn maxArray(a: &[i32]) -> (m: i32)

+    requires(a.len() >= 1)

+    ensures(forall|k: usize| 0 <= k < a.len() ==> m >= a[k])

+    ensures(exists|k: usize| 0 <= k < a.len() && m == a[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_min_array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_min_array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_min_array_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn minArray(a: Vec<int>) -> (r: int)

-    requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> r <= a[i],

-            exists|i: int| 0 <= i < a.len() and r == a[i]

+pub fn minArray(a: &[i32]) -> (r: i32)

+    requires(a.len() > 0)

+    ensures(forall|i: usize| 0 <= i < a.len() ==> r <= a[i])

+    ensures(exists|i: usize| 0 <= i < a.len() && r == a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_min_of_two_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_min_of_two_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_min_of_two_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(x: int, y: int) -> (z: int)

-    ensures x<=y ==> z==x,

-            x>y ==> z==y

+pub fn Min(x: int, y: int) -> (z: int)

+    ensures

+        x <= y ==> z == x,

+        x > y ==> z == y,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_multi_return_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_multi_return_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_multi_return_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultipleReturns(x: int, y: int) -> more: int, less: int

-    ensures more == x+y,

-            less == x-y

+pub fn multiple_returns(x: int, y: int) -> (more: int, less: int)

+    ensures(|result: (int, int)| result.0 == x + y),

+    ensures(|result: (int, int)| result.1 == x - y),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_online_max_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_online_max_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_online_max_spec_task_1.rs
@@ -1,20 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn onlineMax(a: Vec<int>, x: int) -> ghost m: int, p: int

-    requires 1<=x<a.len(),

-             a.len()!=0

-    ensures x<=p<a.len(),

-            forall|i: int|0<=i<x==> a[i]<=m,

-            exists|i: int|0<=i<x and a[i]==m,

-            x<=p<a.len()-1 ==> (forall|i: int|0<=i<p ==> a[i]<a[p]),

-            (forall|i: int|x<=i<a.len() and a[i]<=m) ==> p==a.len()-1

+pub fn onlineMax(a: &[int], x: int) -> (ghost m: int, p: int)

+    requires(1 <= x < a.len())

+    requires(a.len() != 0)

+    ensures(|result: (int, int)| x <= result.1 < a.len())

+    ensures(|result: (int, int)| forall|i: int| 0 <= i < x ==> a[i] <= result.0)

+    ensures(|result: (int, int)| exists|i: int| 0 <= i < x && a[i] == result.0)

+    ensures(|result: (int, int)| x <= result.1 < a.len() - 1 ==> (forall|i: int| 0 <= i < result.1 ==> a[i] < a[result.1 as int]))

+    ensures(|result: (int, int)| (forall|i: int| x <= i < a.len() && a[i] <= result.0) ==> result.1 == a.len() - 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_quotient_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_quotient_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_quotient_spec_task_1.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(x: nat, y: nat) -> r: int, q: int

-    requires y != 0

-    ensures q * y + r == x and 0 <= r < y and 0 <= q

+pub fn quotient(x: nat, y: nat) -> (r: int, q: int)

+    requires(y != 0)

+    ensures(|result: (int, int)| {

+        let (r, q) = result;

+        q * y + r == x && 0 <= r < y && 0 <= q

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_remove_front_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_remove_front_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_remove_front_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn remove_front(a: Vec<int>) -> (c: Vec<int>)

-    requires a.len()>0

-    ensures a[1..] == c[..]

+pub fn remove_front(a: &[i32]) -> (c: Vec<i32>)

+    requires(a.len() > 0)

+    ensures(a.subrange(1, a.len() as int) =~= c@)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_return_seven_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_return_seven_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_return_seven_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(x: int) -> (seven: int)

-    ensures seven==7

+pub fn M(x: int) -> (seven: int)

+    ensures(seven == 7)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_rotate_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_rotate_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_rotate_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn rotate(a: Vec<int>, offset: int) -> (b: Vec<int>)

-    requires 0<=offset

-    ensures b.len()==a.len(),

-            forall|i: int|0<=i<a.len() ==>  b[i]==a[(i+offset)%a.len()]

+pub fn rotate(a: &[i32], offset: i32) -> Vec<i32>

+    requires(0 <= offset)

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i && i < a.len() ==> result[i] == a[(i + offset as usize) % a.len()])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_slope_search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_slope_search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_slope_search_spec_task_1.rs
@@ -1,18 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SlopeSearch(a: array2<int>, key: int) -> m: int, n: int

-    requires forall|i: int, j: int, j': int|0<=i<a.Length0 and 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j'],

-             forall|i: int, i': int, j: int|0<=i<i'<a.Length0 and 0<=j<a.Length1 ==> a[i,j]<=a[i',j],

-             exists|i: int, j: int| 0<=i<a.Length0 and 0<=j<a.Length1 and a[i,j]==key

-    ensures 0<=m<a.Length0 and 0<=n<a.Length1,

-            a[m,n]==key

+pub fn SlopeSearch(a: &Array2<i32>, key: i32) -> (m: i32, n: i32)

+    requires(

+        forall|i: usize, j: usize, j_prime: usize| 

+            0 <= i < a.len0() && 0 <= j < j_prime < a.len1() ==> a[i][j] <= a[i][j_prime]

+    )

+    requires(

+        forall|i: usize, i_prime: usize, j: usize| 

+            0 <= i < i_prime < a.len0() && 0 <= j < a.len1() ==> a[i][j] <= a[i_prime][j]

+    )

+    requires(

+        exists|i: usize, j: usize| 

+            0 <= i < a.len0() && 0 <= j < a.len1() && a[i][j] == key

+    )

+    ensures(|result: (i32, i32)| 

+        0 <= result.0 < a.len0() && 0 <= result.1 < a.len1()

+    )

+    ensures(|result: (i32, i32)| 

+        a[result.0 as usize][result.1 as usize] == key

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_reconstructed_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_reconstructed_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_reconstructed_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapArithmetic(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn swap_arithmetic(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_spec_reconstructed_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_spec_reconstructed_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_swap_arith_spec_reconstructed_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapArithmetic(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn swap_arithmetic(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_swap_bitvector_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_swap_bitvector_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_swap_bitvector_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapBitvectors(X: bv8, Y: bv8) -> x: bv8, y: bv8

-    ensures x==Y,

-            y==X

+pub fn swap_bitvectors(X: u8, Y: u8) -> (x: u8, y: u8)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_swap_sim_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_swap_sim_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_swap_sim_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapSimultaneous(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn swap_simultaneous(X: int, Y: int) -> (x: int, y: int)

+    ensures x == Y,

+    ensures y == X,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_swap_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_swap_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_swap_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn Swap(X: int, Y: int) -> (x: int, y: int)

+    ensures

+        x == Y,

+        y == X,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_triple2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_triple2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_triple2_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_triple3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_triple3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_triple3_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_triple4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_triple4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_triple4_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn Triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_triple_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_triple_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_triple_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Clover_two_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Clover_two_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Clover_two_sum_spec_task_1.rs
@@ -1,18 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn twoSum(nums: Vec<int>, target: int) -> i: int, j: int

+pub fn twoSum(nums: &[i32], target: i32) -> (i: usize, j: usize)

     requires nums.len() > 1,

-             exists|i: int, j: int|0 <= i < j < nums.len() and  nums[i] + nums[j] == target

-    ensures 0 <= i < j < nums.len() and nums[i] + nums[j] == target,

-            forall|ii: int, jj: int| (0 <= ii < i and ii < jj < nums.len())  ==> nums[ii] + nums[jj] != target,

-            forall|jj: int| i < jj < j ==> nums[i] + nums[jj] != target

+    requires exists|i: usize, j: usize| 0 <= i < j < nums.len() && nums[i] + nums[j] == target,

+    ensures |result: (usize, usize)| {

+        let (i, j) = result;

+        0 <= i < j < nums.len() && nums[i] + nums[j] == target

+    },

+    ensures |result: (usize, usize)| {

+        let (i, j) = result;

+        forall|ii: usize, jj: usize| (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target

+    },

+    ensures |result: (usize, usize)| {

+        let (i, j) = result;

+        forall|jj: usize| i < jj < j ==> nums[i] + nums[jj] != target

+    },

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_1.rs
@@ -1,18 +1,29 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mpositive(v: Vec<int>) -> (b: bool)

-    ensures b==positive(v[0..v.len()])

+

+pub fn mpositive(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

 {

 }

 

+

+pub fn mpositive(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

+}

+

+

+pub fn mpositive(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

+}

+

+

+pub fn mpositive(v: &[int]) -> (b: bool)

+    ensures(b == positive(v@))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_2.rs
@@ -1,18 +1,17 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mpositive3(v: Vec<int>) -> (b: bool)

-    ensures b==positive(v[0..v.len()])

+

+

+

+

+pub fn mpositive3(v: &[int]) -> (b: bool)

+    ensures(b == positive(v.view(0..v.len() as int)))

 {

 }

 

-}
+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_3.rs
@@ -1,18 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

+use vstd::prelude::*;

 

 spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mpositive4(v: Vec<int>) -> (b: bool)

-    ensures b==positive(v[0..v.len()])

+pub fn mpositive4(v: &[int]) -> (b: bool)

+    ensures b == positive(v@)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_spec_task_4.rs
@@ -1,17 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mpositivertl(v: Vec<int>) -> (b: bool)

-    ensures b==positive(v[0..v.len()])

+pub fn mpositivertl(v: &[int]) -> (b: bool)

+    ensures b == positive(v@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mroot1(n: int) -> (r: int)

-    requires n>=0

-    ensures r>=0 and r*r <= n <(r+1)*(r+1)

+pub fn mroot1(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_2.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mroot2(n: int) -> (r: int)

-    requires n>=0

-    ensures r>=0 and r*r <= n <(r+1)*(r+1)

+pub fn mroot2(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_spec_task_3.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mroot3(n: int) -> (r: int)

-    requires n>=0

-    ensures r>=0 and r*r <= n <(r+1)*(r+1)

+pub fn mroot3(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(|r: int| r >= 0 && r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mmaximum1(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k]

+pub fn mmaximum1(v: &[i32]) -> (i: usize)

+    requires(v.len() > 0)

+    ensures(i < v.len())

+    ensures(forall|k: usize| k < v.len() ==> v[i as int] >= v[k as int])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_2.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mmaximum2(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k]

+pub fn mmaximum2(v: &[i32]) -> (i: usize)

+    requires

+        v.len() > 0,

+    ensures

+        0 <= i < v.len(),

+        forall|k: usize| 0 <= k < v.len() ==> v[i as int] >= v[k as int],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_3.rs
@@ -1,18 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mfirstMaximum(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k],

-            forall|l: int| 0<=l<i ==> v[i]>v[l]

-

+pub fn mfirstMaximum(v: &[i32]) -> (i: usize)

+    requires v.len() > 0

+    ensures 0 <= i < v.len()

+    ensures forall|k: usize| 0 <= k < v.len() ==> v[i as int] >= v[k as int]

+    ensures forall|l: usize| 0 <= l < i ==> v[i as int] > v[l as int]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_4.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mlastMaximum(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k],

-            forall|l: int| i<l<v.len() ==> v[i]>v[l]

+pub fn mlastMaximum(v: &[i32]) -> (i: usize)

+    requires

+        v.len() > 0,

+    ensures

+        0 <= i < v.len(),

+        forall|k: usize| 0 <= k < v.len() ==> v[i as int] >= v[k as int],

+        forall|l: usize| i < l < v.len() ==> v[i as int] > v[l as int],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_5.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mmaximum1(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k]

+pub fn mmaximum1(v: &[i32]) -> (i: usize)

+    requires v.len() > 0

+    ensures 0 <= i < v.len()

+    ensures forall|k: usize| 0 <= k < v.len() ==> v[i as int] >= v[k as int]

 {

 }

 

+pub fn mmaxvalue1(v: &[i32]) -> (m: i32)

+    requires v.len() > 0

+    ensures exists|k: usize| 0 <= k < v.len() && m == v[k as int]

+    ensures forall|k: usize| 0 <= k < v.len() ==> m >= v[k as int]

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_spec_task_6.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mmaximum2(v: Vec<int>) -> (i: int)

-    requires v.len()>0

-    ensures 0<=i<v.len(),

-            forall|k: int| 0<=k<v.len() ==> v[i]>=v[k]

+pub fn mmaximum2(v: &[int]) -> (i: usize)

+    requires(v.len() > 0)

+    ensures(|i: usize| 0 <= i < v.len())

+    ensures(|i: usize| forall|k: usize| 0 <= k < v.len() ==> v[i] >= v[k])

 {

 }

 

+pub fn mmaxvalue2(v: &[int]) -> (m: int)

+    requires(v.len() > 0)

+    ensures(|m: int| exists|k: usize| 0 <= k < v.len() && m == v[k])

+    ensures(|m: int| forall|k: usize| 0 <= k < v.len() ==> m >= v[k])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_1.rs
@@ -1,18 +1,43 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

+spec fn allEqual(s: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]

 }

 

-fn mallEqual1(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn mallEqual1(v: &[int]) -> (b: bool)

+    ensures(b == allEqual(v@))

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_2.rs
@@ -1,18 +1,39 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn allEqual(s: Seq<int>) -> bool

+{ forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j] }

 

-verus! {

 

-spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

-}

 

-fn mallEqual2(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn mallEqual2(v: &[int]) -> (b: bool)

+    ensures(b == allEqual(v@.subrange(0, v@.len() as int)))

 {

 }

 

-}
+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_3.rs
@@ -1,17 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

+    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]

 }

 

-fn mallEqual3(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+proof fn equivalenceContiguous(s: Seq<int>)

+    ensures 

+        allEqual(s) ==> (forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i + 1]),

+        allEqual(s) <== (forall|i: int| 0 <= i < s.len() - 1 ==> s[i] == s[i + 1])

+{

+}

+

+pub fn mallEqual3(v: &[int]) -> (b: bool)

+    ensures b == allEqual(v@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_4.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

+spec fn allEqual(s: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]

 }

 

-fn mallEqual4(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+

+pub fn mallEqual4(v: &[int]) -> (b: bool)

+    ensures(b == allEqual(v@))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_spec_task_5.rs
@@ -1,17 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn allEqual(s: Seq<int>) -> bool {

-    forall|i: int, j: int|0<=i<s.len() and 0<=j<s.len() ==> s[i]==s[j]

+    forall|i: int, j: int| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j]

 }

 

-fn mallEqual5(v: Vec<int>) -> (b: bool)

-    ensures b==allEqual(v[0..v.len()])

+pub fn mallEqual5(v: &[int]) -> (b: bool)

+    ensures

+        b == allEqual(v@),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_spec_task_1.rs
@@ -1,27 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn strictSorted(s: Seq<int>) -> bool {

+spec fn strict_sorted(s: Seq<int>) -> bool {

     forall|u: int, w: int| 0 <= u < w < s.len() ==> s[u] < s[w]

 }

 

-fn mcontained(v: Vec<int>, w: Vec<int>, n: int, m: int) -> (b: bool)

-

-

-

-requires n<=m && n>=0

-requires strictSorted(v[..])

-    requires n<=m and n>=0,

-             strictSorted(v[..]),

-             strictSorted(w[..]),

-             v.len() >= n and w.len() >= m

-    ensures b==forall|k: int| 0<= k< n ==> v[k] in w[..m]

+pub fn mcontained(v: &[int], w: &[int], n: usize, m: usize) -> (b: bool)

+    requires(

+        n <= m && n >= 0,

+        strict_sorted(v@),

+        strict_sorted(w@),

+        v.len() >= n && w.len() >= m,

+    )

+    ensures(|b: bool| 

+        b == forall|k: int| 0 <= k < n ==> w@.subrange(0, m as int).contains(v@[k])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_1.rs
@@ -1,19 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+spec fn positive(s: Seq<int>) -> bool

+{

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mfirstNegative(v: Vec<int>) -> b: bool, i: int

-    ensures b <==> exists|k: int|0<=k<v.len() and v[k]<0,

-            b ==> 0<=i<v.len() and v[i]<0 and positive(v[0..i])

+

+

+pub fn mfirstNegative(v: &[int]) -> (b: bool, i: int)

+    ensures(b <==> exists|k: int| 0 <= k < v.len() && v[k] < 0)

+    ensures(b ==> 0 <= i < v.len() && v[i] < 0 && positive(v.subrange(0, i as int)))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_spec_task_2.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

 spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mfirstNegative2(v: Vec<int>) -> b: bool, i: int

-    ensures b <==> exists|k: int|0<=k<v.len() and v[k]<0,

-            b ==> 0<=i<v.len() and v[i]<0 and positive(v[0..i])

+pub fn mfirstNegative2(v: &[int]) -> (b: bool, i: int)

+    ensures(b <==> exists|k: int| 0 <= k < v.len() && v[k] < 0),

+    ensures(b ==> 0 <= i < v.len() && v[i] < 0 && positive(v.subrange(0, i as int))),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mfirstCero(v: Vec<int>) -> (i: int)

-    ensures 0 <=i<=v.len(),

-            forall|j: int| 0<=j<i ==> v[j]!=0,

-            i!=v.len() ==> v[i]==0

+pub fn mfirstCero(v: &[i32]) -> (i: i32)

+    ensures(0 <= i <= v.len())

+    ensures(forall|j: i32| 0 <= j < i ==> v[j as usize] != 0)

+    ensures(i != v.len() ==> v[i as usize] == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_1.rs
@@ -1,17 +1,57 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn sumElems(v: Vec<int>) -> (sum: int)

 

-    ensures sum==SumL(v[0..v.len()]),

-            sum==SumR(v[..])

+spec fn SumR(s: Seq<int>) -> int

+{

+    if s == seq![] { 0 }

+    else { SumR(s.subrange(0, s.len() as int - 1)) + s[s.len() - 1] }

+}

 

-            sum==SumV(v,0,v.len())

+

+spec fn SumL(s: Seq<int>) -> int

+{

+    if s == seq![] { 0 }

+    else { s[0] + SumL(s.subrange(1, s.len() as int)) }

+}

+

+

+

+

+

+proof fn SumByPartsR(s: Seq<int>, t: Seq<int>)

+    ensures SumR(s + t) == SumR(s) + SumR(t)

+{

+}

+

+

+proof fn SumByPartsL(s: Seq<int>, t: Seq<int>)

+    ensures SumL(s + t) == SumL(s) + SumL(t)

+{

+}

+

+

+proof fn equalSumR(s: Seq<int>, i: int, j: int)

+    requires 0 <= i <= j <= s.len()

+    ensures SumR(s.subrange(i, j)) == SumL(s.subrange(i, j))

+{

+}

+

+

+

+

+spec fn SumV(v: &[int], c: int, f: int) -> int

+    recommends 0 <= c <= f <= v.len()

+{

+    SumR(v@.subrange(c, f))

+}

+

+

+

+

+pub fn sumElems(v: &[int]) -> (sum: int)

+    ensures sum == SumR(v@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_spec_task_2.rs
@@ -1,15 +1,58 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn sumElemsB(v: Vec<int>) -> (sum: int)

 

-    ensures sum==SumL(v[0..v.len()]),

-            sum==SumR(v[0..v.len()])

+spec fn SumR(s: Seq<int>) -> int

+{

+    if s.len() == 0 { 0 }

+    else { SumR(s.subrange(0, s.len() - 1)) + s[s.len() - 1] }

+}

+

+

+spec fn SumL(s: Seq<int>) -> int

+{

+    if s.len() == 0 { 0 }

+    else { s[0] + SumL(s.subrange(1, s.len())) }

+}

+

+

+

+

+

+proof fn SumByPartsR(s: Seq<int>, t: Seq<int>)

+    ensures SumR(s + t) == SumR(s) + SumR(t)

+{

+}

+

+

+proof fn SumByPartsL(s: Seq<int>, t: Seq<int>)

+    ensures SumL(s + t) == SumL(s) + SumL(t)

+{

+}

+

+

+proof fn equalSumR(s: Seq<int>, i: int, j: int)

+    requires 0 <= i <= j <= s.len()

+    ensures SumR(s.subrange(i, j)) == SumL(s.subrange(i, j))

+{

+}

+

+

+proof fn equalSumsV() 

+    ensures forall|v: &[int], i: int, j: int| 0 <= i <= j <= v.len() ==> SumR(v@.subrange(i, j)) == SumL(v@.subrange(i, j))

+{

+}

+

+

+

+

+

+

+

+

+pub fn sumElemsB(v: &[int]) -> (sum: int)

+    ensures sum == SumR(v@.subrange(0, v.len()))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_spec_task_1.rs
@@ -1,18 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn positive(s: Seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

 }

 

-fn mcountEven(v: Vec<int>) -> (n: int)

-    requires positive(v[..])

-    ensures n==CountEven(v[..])

+spec fn CountEven(s: Seq<int>) -> int

+    recommends positive(s)

+{

+    if s == seq![] {

+        0

+    } else {

+        (if s[s.len() - 1] % 2 == 0 { 1 } else { 0 }) + CountEven(s.subrange(0, s.len() - 1))

+    }

+}

+

+pub fn mcountEven(v: &[int]) -> (n: int)

+    requires(positive(v@))

+    ensures(n == CountEven(v@))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_spec_task_1.rs
@@ -1,15 +1,42 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn mCountMin(v: Vec<int>) -> (c: int)

-    requires v.len()>0

-    ensures c==countMin(v,min(v,v.len()),v.len())

+spec fn min(v: &[int], i: int) -> int

+    recommends

+        1 <= i <= v.len(),

+    ensures |result: int|

+        forall|k: int| 0 <= k < i ==> v[k] >= result,

+{

+    if i == 1 {

+        v[0]

+    } else if v[(i-1) as usize] <= min(v, i-1) {

+        v[(i-1) as usize]

+    } else {

+        min(v, i-1)

+    }

+}

 

+spec fn countMin(v: &[int], x: int, i: int) -> int

+    recommends

+        0 <= i <= v.len(),

+    ensures |result: int|

+        !v.subrange(0, i as usize).contains(x) ==> result == 0,

+{

+    if i == 0 {

+        0

+    } else if v[(i-1) as usize] == x {

+        1 + countMin(v, x, i-1)

+    } else {

+        countMin(v, x, i-1)

+    }

+}

+

+pub fn mCountMin(v: &[int]) -> (c: int)

+    requires

+        v.len() > 0,

+    ensures

+        c == countMin(v, min(v, v.len() as int), v.len() as int),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_spec_task_1.rs
@@ -1,16 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn mPeekSum(v: Vec<int>) -> (sum: int)

-    requires v.len()>0

-    ensures sum==peekSum(v,v.len())

-

+pub open spec fn isPeek(v: &[int], i: int) -> bool

+    requires 0 <= i < v.len()

 {

+    forall|k: int| 0 <= k < i ==> v[i] >= v[k]

 }

 

+

+

+pub open spec fn peekSum(v: &[int], i: int) -> int

+    requires 0 <= i <= v.len()

+    decreases i

+{

+    if i == 0 {

+        0

+    } else if isPeek(v, i - 1) {

+        v[i - 1] + peekSum(v, i - 1)

+    } else {

+        peekSum(v, i - 1)

+    }

+}

+

+

+

+pub fn mPeekSum(v: &[int]) -> (sum: int)

+    requires v.len() > 0

+    ensures sum == peekSum(v, v.len() as int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_1.rs
@@ -1,28 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_seg(a: Vec<int>, i: int, j: int)

-requires 0 <= i <= j <= a.Length

-reads a

+spec fn sorted_seg(a: &[int], i: int, j: int) -> bool

+    recommends 0 <= i <= j <= a.len()

 {

-    forall l, k: : i <= l <= k < j ==> a[l] <= a[k]

+    forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]

 }

 

-

-

-

-method bubbleSorta(a:array<int>, c: int, f: int)

-modifies a 

-requires 0 <= c <= f <= a.Length

-ensures sorted_seg(a, c, f) 

-ensures multiset(a[c..f]) == old(multiset(a[c..f]))

-ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..]) -> bool {

-    

+pub fn bubbleSorta(a: &mut [int], c: usize, f: usize)

+    requires 

+        c <= f <= old(a).len(),

+    ensures

+        sorted_seg(a, c as int, f as int),

+        a.subrange(c as int, f as int).to_multiset() == old(a).subrange(c as int, f as int).to_multiset(),

+        a.subrange(0, c as int) == old(a).subrange(0, c as int) && a.subrange(f as int, old(a).len() as int) == old(a).subrange(f as int, old(a).len() as int),

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_spec_task_2.rs
@@ -1,29 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted_seg(a: Vec<int>, i: int, j: int)

-requires 0 <= i <= j <= a.Length

-reads a

+spec fn sorted_seg(a: &[int], i: int, j: int) -> bool

 {

-    forall l, k: : i <= l <= k < j ==> a[l] <= a[k]

+    &&& 0 <= i <= j <= a.len()

+    &&& forall|l: int, k: int| i <= l <= k < j ==> a[l] <= a[k]

 }

 

-

-

-

-

-method bubbleSort(a:array<int>, c: int, f: int)

-modifies a 

-requires 0 <= c <= f <= a.Length

-ensures sorted_seg(a, c, f) 

-ensures multiset(a[c..f]) == old(multiset(a[c..f]))

-ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..]) -> bool {

-    

-}

-

+pub fn bubbleSort(a: &mut Vec<int>, c: usize, f: usize)

+    requires(

+        0 <= c <= f <= a.len()

+    )

+    ensures(

+        sorted_seg(a, c as int, f as int) &&

+        multiset(a.subrange(c as int, f as int)) == old(multiset(a.subrange(c as int, f as int))) &&

+        a.subrange(0, c as int) == old(a.subrange(0, c as int)) &&

+        a.subrange(f as int, a.len() as int) == old(a.subrange(f as int, a.len() as int))

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_spec_task_1.rs
@@ -1,30 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted_seg(a: Vec<int>, i: int, j: int)

-requires 0 <= i <= j <= a.Length

-reads a

+spec fn sorted_seg(a: &[i32], i: usize, j: usize) -> bool

 {

-    forall l, k: : i <= l <= k < j ==> a[l] <= a[k]

+    0 <= i <= j <= a.len() &&

+    forall|l: usize, k: usize| i <= l <= k < j ==> a[l] <= a[k]

 }

 

 

-

-

-

-

-method selSort (a:array<int>, c: int, f: int)

-modifies a 

-requires 0 <= c <= f <= a.Length

-ensures sorted_seg(a, c, f) 

-ensures multiset(a[c..f]) == old(multiset(a[c..f]))

-ensures a[..c]==old(a[..c]) && a[f..]==old(a[f..]) -> bool {

-    

-}

-

+pub fn selSort(a: &mut [i32], c: usize, f: usize)

+    requires(0 <= c <= f <= a.len())

+    ensures(sorted_seg(a, c, f))

+    ensures(a.subrange(c, f).to_multiset() == old(a).subrange(c, f).to_multiset())

+    ensures(a.subrange(0, c) == old(a).subrange(0, c) && a.subrange(f, a.len()) == old(a).subrange(f, old(a).len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_spec_task_1.rs
@@ -1,33 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn strictNegative(v: Vec<int>, i: int, j: int)

-reads v

-requires 0<=i<=j<=v.Length

-{forall u | i<=u<j :: v[u]<0}

-

-

-

-

-predicate positive(s:seq<int>) -> bool {

-    forall|u: int|0<=u<s.len() ==> s[u]>=0

-}

-spec fn isPermutation(s: Seq<int>, t: Seq<int>) -> bool {

-    multiset(s)==multiset(t)

+spec fn strictNegative(v: &[i32], i: int, j: int) -> bool

+    recommends 0 <= i <= j <= v.len()

+{

+    forall|u: int| i <= u < j ==> v[u as usize] < 0

 }

 

-fn separate(v: Vec<int>) -> i: int)

-modifies v

-ensures 0<=i<=v.Length

-ensures positive(v[0..i]) && strictNegative(v, i, v.Length

-    ensures 0<=i<=v.len(),

-            positive(v[0..i]) and strictNegative(v,i,v.len()),

-            isPermutation(v[0..v.len()], old(v[0..v.len()]))

+spec fn positive(s: Seq<i32>) -> bool {

+    forall|u: int| 0 <= u < s.len() ==> s[u] >= 0

+}

+

+spec fn isPermutation(s: Seq<i32>, t: Seq<i32>) -> bool {

+    s.to_multiset() == t.to_multiset()

+}

+

+pub fn separate(v: &mut Vec<i32>) -> (i: usize)

+    requires(

+        old(v).len() <= usize::MAX

+    )

+    ensures(

+        0 <= i <= v.len() &&

+        positive(v@.subrange(0, i as int)) &&

+        strictNegative(v.as_slice(), i as int, v.len() as int) &&

+        isPermutation(v@, old(v)@)

+    )

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_1.rs
@@ -1,31 +1,29 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn SumMaxToRight(v: Vec<int>, i: int, s: int)

-reads v

-requires 0<=i<v.Length

+spec fn Sum(v: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= v.len()

 {

-forall l, ss {: induction l}::0<=l<=i && ss==i+1==> Sum(v, l, ss)<=s

+    if i == j { 0 } else { Sum(v, i, j-1) + v[j-1] }

 }

 

-

-

-

-method segMaxSum(v: Vec<int>, i: int) returns (s:int, k: int)

-requires v.Length>0 && 0<=i<v.Length

-ensures 0<=k<=i && s==Sum(v, k, i+1) &&  SumMaxToRight(v, i, s) -> bool {

-    

+spec fn SumMaxToRight(v: &[int], i: int, s: int) -> bool

+    recommends 0 <= i < v.len()

+{

+    forall|l: int, ss: int| 0 <= l <= i && ss == i+1 ==> Sum(v, l, ss) <= s

 }

 

-fn segMaxSum(v: Vec<int>, i: int) -> s: int, k: int

-    requires v.len()>0 and 0<=i<v.len()

-    ensures 0<=k<=i and s==Sum(v,k,i+1) and  SumMaxToRight(v,i,s)

+pub fn segMaxSum(v: &[int], i: usize) -> (s: int, k: usize)

+    requires(

+        v.len() > 0 && i < v.len()

+    )

+    ensures(|result: (int, usize)| {

+        let (s, k) = result;

+        k <= i && s == Sum(v, k as int, i as int + 1) && SumMaxToRight(v, i as int, s)

+    })

 {

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_spec_task_2.rs
@@ -1,16 +1,34 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn segSumaMaxima2(v: Vec<int>, i: int) -> s: int, k: int

-    requires v.len()>0 and 0<=i<v.len()

-    ensures 0<=k<=i and s==Sum2(v,k,i+1) and  SumMaxToRight2(v,0,i,s)

+spec fn Sum2(v: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= v.len()

+{

+    if i == j {

+        0

+    } else {

+        v[i as usize] + Sum2(v, i + 1, j)

+    }

+}

 

+spec fn SumMaxToRight2(v: &[int], j: int, i: int, s: int) -> bool

+    recommends 0 <= j <= i < v.len()

 {

+    forall|l: int, ss: int| j <= l <= i && ss == i + 1 ==> Sum2(v, l, ss) <= s

+}

+

+pub fn segSumaMaxima2(v: &[int], i: usize) -> (s: int, k: usize)

+    requires(

+        v.len() > 0 && i < v.len()

+    )

+    ensures(|result: (int, usize)|

+        0 <= result.1 <= i && 

+        result.0 == Sum2(v, result.1 as int, i as int + 1) && 

+        SumMaxToRight2(v, 0, i as int, result.0)

+    )

+{

+    

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_spec_task_1.rs
@@ -1,29 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn summingPair(i: nat, j: nat, nums: Seq<int>, target: int)

-    requires i < |nums|

-    requires j < |nums|

+spec fn summingPair(i: nat, j: nat, nums: Seq<int>, target: int) -> bool

+    requires(i < nums.len())

+    requires(j < nums.len())

 {

-    i != j &&  nums[i] + nums[j] == target

+    i != j && nums[i] + nums[j] == target

 }

 

 

-method twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))

-    requires exists i: nat, j: nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)

-    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target) -> bool {

-    

-}

-

-fn twoSum(nums: Seq<int>, target: int) -> pair: (nat, nat)

-    requires exists i:nat,j:nat :: i < j < nums.len() and summingPair(i, j, nums, target) and forall l: nat, m: nat :: l <  m < nums.len() and l != i and m != j ==> !summingPair(l, m, nums, target)

-    ensures 0 <= pair.0 < nums.len() and 0 <= pair.1 < nums.len() and summingPair(pair.0, pair.1, nums, target)

+pub fn twoSum(nums: Seq<int>, target: int) -> (pair: (nat, nat))

+    requires(exists|i: nat, j: nat| i < j < nums.len() && summingPair(i, j, nums, target) && forall|l: nat, m: nat| l < m < nums.len() && l != i && m != j ==> !summingPair(l, m, nums, target))

+    ensures(0 <= pair.0 < nums.len() && 0 <= pair.1 < nums.len() && summingPair(pair.0, pair.1, nums, target))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_1.rs
@@ -1,89 +1,68 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn BST(t: Tree) -> bool {

+pub enum Tree {

+    Empty,

+    Node(int, Box<Tree>, Box<Tree>),

+}

+

+pub fn Main() {

+}

+

+pub fn PrintTreeNumbersInorder(t: Tree) {

+}

+

+pub spec fn NumbersInTree(t: Tree) -> Set<int> {

+    NumbersInSequence(Inorder(t))

+}

+

+pub spec fn NumbersInSequence(q: Seq<int>) -> Set<int> {

+    Set::new(|x: int| q.contains(x))

+}

+

+pub spec fn BST(t: Tree) -> bool {

     Ascending(Inorder(t))

 }

-spec fn Ascending(q: Seq<int>) -> bool {

+

+pub spec fn Inorder(t: Tree) -> Seq<int> {

+    match t {

+        Tree::Empty => seq![],

+        Tree::Node(n_, nt1, nt2) => Inorder(*nt1) + seq![n_] + Inorder(*nt2)

+    }

+}

+

+pub spec fn Ascending(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]

 }

-spec fn NoDuplicates(q: Seq<int>) -> bool {

+

+pub spec fn NoDuplicates(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j]

 }

 

-fn Main() {

-}

-

-

-

-

-method PrintTreeNumbersInorder(t: Tree)

+pub fn BuildBST(q: Seq<int>) -> (t: Tree)

+    requires(NoDuplicates(q))

+    ensures(BST(t) && NumbersInTree(t) == NumbersInSequence(q))

 {

 }

 

-

-

-

-function NumbersInTree(t: Tree): set<int>

+pub fn InsertBST(t0: Tree, x: int) -> (t: Tree)

+    requires(BST(t0) && !NumbersInTree(t0).contains(x))

+    ensures(BST(t) && NumbersInTree(t) == NumbersInTree(t0).insert(x))

 {

-	NumbersInSequence(Inorder(t))

 }

 

-

-

-

-function NumbersInSequence(q: seq<int>): set<int>

+proof fn lemma_all_small(q: Seq<int>, i: int)

+    requires(forall|k: int| NumbersInSequence(q).contains(k) ==> k < i)

+    requires(forall|k: int| 0 <= k < q.len() ==> NumbersInSequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] < i)

 {

-	set x | x in q

 }

 

-

-

-

-predicate BST(t: Tree)

-{

-	Ascending(Inorder(t))

-}

-

-

-

-

-function Inorder(t: Tree): seq<int>

-{

-	match t {

-		case Empty => []

-		case Node(n', nt1, nt2) => Inorder(nt1)+[n']+Inorder(nt2)

-	}

-}

-

-

-

-

-predicate Ascending(q: Seq<int>, j: : 0 <= i < j < |q| ==> q[i] < q[j]

-}

-

-

-

-

-predicate NoDuplicates(q: seq<int>) { forall i, j: : 0 <= i < j < |q| ==> q[i] != q[j] }

-

-

-

-

-

-

-

-

-

-

-method BuildBST(q: Seq<int>) -> (t: Tree)

-    requires NoDuplicates(q)

-    ensures BST(t) and NumbersInTree(t) == NumbersInSequence(q)

+proof fn lemma_all_big(q: Seq<int>, i: int)

+    requires(forall|k: int| NumbersInSequence(q).contains(k) ==> k > i)

+    requires(forall|k: int| 0 <= k < q.len() ==> NumbersInSequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] > i)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_3.rs
@@ -1,24 +1,62 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn BST(t: Tree) -> bool {

-    Ascending(Inorder(t))

+pub enum Tree {

+    Empty,

+    Node(int, Box<Tree>, Box<Tree>),

 }

-spec fn Ascending(q: Seq<int>) -> bool {

+

+spec fn numbers_in_tree(t: Tree) -> Set<int> {

+    numbers_in_sequence(inorder(t))

+}

+

+spec fn numbers_in_sequence(q: Seq<int>) -> Set<int> {

+    Set::new(|x: int| q.contains(x))

+}

+

+spec fn bst(t: Tree) -> bool {

+    ascending(inorder(t))

+}

+

+spec fn inorder(t: Tree) -> Seq<int> {

+    match t {

+        Tree::Empty => seq![],

+        Tree::Node(n, nt1, nt2) => inorder(*nt1) + seq![n] + inorder(*nt2)

+    }

+}

+

+spec fn ascending(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]

 }

-spec fn NoDuplicates(q: Seq<int>) -> bool {

+

+spec fn no_duplicates(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] != q[j]

 }

 

-fn BuildBST(q: Seq<int>) -> (t: Tree)

-    requires NoDuplicates(q)

-    ensures BST(t) and NumbersInTree(t) == NumbersInSequence(q)

+pub fn build_bst(q: Seq<int>) -> (t: Tree)

+    requires(no_duplicates(q))

+    ensures(bst(t) && numbers_in_tree(t) == numbers_in_sequence(q))

+{

+}

+

+pub fn insert_bst(t0: Tree, x: int) -> (t: Tree)

+    requires(bst(t0) && !numbers_in_tree(t0).contains(x))

+    ensures(bst(t) && numbers_in_tree(t) == numbers_in_tree(t0).insert(x))

+{

+}

+

+proof fn lemma_all_small(q: Seq<int>, i: int)

+    requires(forall|k: int| numbers_in_sequence(q).contains(k) ==> k < i)

+    requires(forall|k: int| 0 <= k < q.len() ==> numbers_in_sequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] < i)

+{

+}

+

+proof fn lemma_all_big(q: Seq<int>, i: int)

+    requires(forall|k: int| numbers_in_sequence(q).contains(k) ==> k > i)

+    requires(forall|k: int| 0 <= k < q.len() ==> numbers_in_sequence(q).contains(q[k]))

+    ensures(forall|j: int| 0 <= j < q.len() ==> q[j] > i)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Practice_tmp_tmphnmt4ovh_BST_spec_task_4.rs
@@ -1,22 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BST(t: Tree) -> bool {

-    Ascending(Inorder(t))

-}

-spec fn Ascending(q: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < q.len() ==> q[i] < q[j]

-}

-

-fn InsertBST(t0: Tree, x: int) -> (t: Tree)

-    requires BST(t0) and x !in NumbersInTree(t0)

-    ensures BST(t) and NumbersInTree(t) == NumbersInTree(t0)+

+pub fn InsertBST(t0: Tree, x: int) -> (t: Tree)

+    requires(BST(t0) && x !in NumbersInTree(t0))

+    ensures(BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x})

 {

 }

 

+pub fn lemma_all_small(q: seq<int>, i: int)

+    requires(forall|k| k in NumbersInSequence(q) ==> k < i)

+    requires(forall|k| 0 <= k < |q| ==> q[k] in NumbersInSequence(q))

+    ensures(forall|j| 0 <= j < |q| ==> q[j] < i)

+{

+}

+

+pub fn lemma_all_big(q: seq<int>, i: int)

+    requires(forall|k| k in NumbersInSequence(q) ==> k > i)

+    requires(forall|k| 0 <= k < |q| ==> q[k] in NumbersInSequence(q))

+    ensures(forall|j| 0 <= j < |q| ==> q[j] > i)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_spec_task_1.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArraySplit(a: Vec<int>) -> b: Vec<int>, c: Vec<int>

-    ensures fresh(b),

-            fresh(c),

-            a[..] == b[..] + c[..],

-            a.len() == b.len() + c.len(),

-            a.len() > 1 ==> a.len() > b.len(),

-            a.len() > 1 ==> a.len() > c.len()

+pub fn array_split(a: &[i32]) -> (Vec<i32>, Vec<i32>)

+    ensures(|result: (Vec<i32>, Vec<i32>)| {

+        let (b, c) = result;

+        &&& a@ == b@ + c@

+        &&& a.len() == b.len() + c.len()

+        &&& a.len() > 1 ==> a.len() > b.len()

+        &&& a.len() > 1 ==> a.len() > c.len()

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_1.rs
@@ -1,31 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_between(A: Vec<int>, from: int, to: int)

-    reads A

-{

-    forall i, j: : 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]

+spec fn sorted_between(A: &Vec<i32>, from: int, to: int) -> bool {

+    forall|i: int, j: int| 0 <= i <= j < A.len() && from <= i <= j <= to ==> A[i] <= A[j]

 }

 

-

-

-

-predicate sorted(A:array<int>)

-    reads A

-{

-    sorted_between(A, 0, A.Length-1)

+spec fn sorted(A: &Vec<i32>) -> bool {

+    sorted_between(A, 0, A.len() - 1)

 }

 

-

-

-

-method BubbleSort(A: Vec<int>) -> bool {

-    

+pub fn BubbleSort(A: &mut Vec<i32>)

+    requires(A.len() > 0)

+    ensures(sorted(A))

+    ensures(A@.to_multiset() == old(A)@.to_multiset())

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny-programs_tmp_tmpnso9eu7u_Algorithms + sorting_bubble-sort_spec_task_2.rs
@@ -1,31 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_between(A: Vec<int>, from: int, to: int)

-    reads A

-{

-    forall i, j: : 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]

+spec fn sorted_between(A: &[i32], from: int, to: int) -> bool {

+    forall|i: int, j: int| 0 <= i <= j < A.len() && from <= i <= j <= to ==> A[i] <= A[j]

 }

 

-

-

-

-predicate sorted(A:array<int>)

-    reads A

-{

-    sorted_between(A, 0, A.Length-1)

+spec fn sorted(A: &[i32]) -> bool {

+    sorted_between(A, 0, A.len() as int - 1)

 }

 

+pub fn BubbleSort(A: &mut Vec<i32>)

+    ensures sorted(A)

+    ensures A@.to_multiset() == old(A)@.to_multiset()

+{

+}

 

-

-

-method BubbleSort(A: Vec<int>) -> bool {

-    

+pub fn Main() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn addArrays(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len() == b.len()

-    ensures b.len() == c.len(),

-            forall i:int :: 0 <= i <c.len() ==> c[i] == a[i] + b[i]

+pub fn addArrays(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| b.len() == c.len())

+    ensures(|c: Vec<i32>| forall|i: int| 0 <= i < c.len() ==> c[i as usize] == a[i as usize] + b[i as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_1.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn longestPrefix(a: Vec<int>, b: array <int>) -> (i: nat)

-    ensures i <= a.len() and i <= b.len(),

-            a[..i] == b[..i],

-            i < a.len() and i < b.len() ==> a[i] != b[i]

+pub fn longest_prefix(a: &[i32], b: &[i32]) -> (i: usize)

+    ensures

+        i <= a.len() && i <= b.len(),

+        a.subrange(0, i as int) == b.subrange(0, i as int),

+        i < a.len() && i < b.len() ==> a[i] != b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_spec_task_2.rs
@@ -1,16 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn longestPrefix(a: Vec<int>, b: array <int>) -> (i: nat)

-    ensures i <= a.len() and i <= b.len(),

-            a[..i] == b[..i],

-            i < a.len() and i < b.len() ==> a[i] != b[i]

+

+

+

+

+

+

+pub fn longestPrefix(a: &[int], b: &[int]) -> (i: nat)

+    ensures(i <= a.len() && i <= b.len())

+    ensures(a[..i] == b[..i])

+    ensures(i < a.len() && i < b.len() ==> a[i] != b[i])

 {

 }

 

+ 

+

+

+ 

+

+pub fn testLongestPrefix() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_1.rs
@@ -1,17 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn odd(n: nat) -> bool {

-    n % 2 == 1

+pub fn partitionOddEven(a: &mut Vec<nat>)

+    requires old(a).len() > 0

+    ensures a@.to_multiset() == old(a)@.to_multiset()

+    ensures !(exists|i: int, j: int| 0 <= i < j < a.len() && even(a[i]) && odd(a[j]))

+{

 }

 

-spec fn even(n: nat) -> bool {

-    n % 2 == 0

-}

+pub open spec fn odd(n: nat) -> bool { n % 2 == 1 }

+

+pub open spec fn even(n: nat) -> bool { n % 2 == 0 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_spec_task_2.rs
@@ -1,17 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn odd(n: nat) -> bool {

-    n % 2 == 1

+

+

+

+

+

+pub fn partitionOddEven(a: &mut Vec<nat>)

+    requires(old(a).len() == a.len())

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

+    ensures(!(exists|i: int, j: int| 0 <= i < j < a.len() && even(a[i]) && odd(a[j])))

+{

 }

 

-spec fn even(n: nat) -> bool {

-    n % 2 == 0

+

+pub open spec fn odd(n: nat) -> bool { n % 2 == 1 }

+

+

+pub open spec fn even(n: nat) -> bool { n % 2 == 0 }

+

+

+pub fn testPartitionOddEven() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x+y,

-            (m == x or m == y) and x <= m and y <= m

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures s == x + y,

+    ensures (m == x || m == y) && x <= m && y <= m,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x+y,

-            (m == x or m == y) and x <= m and y <= m

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures

+        s == x + y,

+        (m == x || m == y) && x <= m && y <= m,

 {

 }

 

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_1.rs
@@ -1,13 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P(n: int) -> bool {

-    n % 2 == 0

+pub fn LinearSeach0<T>(a: &[T], P: impl Fn(&T) -> bool) -> (n: usize)

+    ensures(

+        n <= a.len() &&

+        (n == a.len() || P(&a[n]))

+    )

+{

 }

 

+pub closed spec fn P(n: int) -> bool {

+    n % 2 == 0

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_Week4__LinearSearch_spec_task_3.rs
@@ -1,13 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

 

 spec fn P(n: int) -> bool {

     n % 2 == 0

 }

 

+

+

+pub fn LinearSeach1<T>(a: &[T], P: spec_fn(T) -> bool) -> (n: usize)

+    ensures

+        0 <= n <= a.len(),

+        n == a.len() || P(a[n as int]),

+        n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> !P(a[i]),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_1.rs
@@ -1,14 +1,9 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn CalcPower(n: nat) -> (p: nat)

-    ensures p == 2*n;

+

+pub fn CalcPower(n: nat) -> (p: nat)

+    ensures p == 2*n

 {

 }

 

-}

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_spec_task_2.rs
@@ -1,14 +1,17 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub fn power(n: nat) -> nat

+{

+    if n == 0 { 1 } else { 2 * power((n-1) as nat) }

+}

 

-verus! {

 

-fn CalcPower(n: nat) -> (p: nat)

-    ensures p == 2*n;

+pub fn calc_power(n: nat) -> (p: nat)

+    ensures p == 2*n

 {

 }

 

+

+pub fn compute_power(n: nat) -> (p: nat)

+    ensures p == power(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_1.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindPositionOfElement(a: Vec<int>, Element: nat, n1: nat, s1: Seq<int>) -> Position: int, Count: nat

-    requires n1 == s1.len() and 0 <= n1 <= a.len(),

-             forall|i: int| 0<= i < s1.len() ==> a[i] == s1[i]

-    ensures Position == -1 or Position >= 1,

-            s1.len() != 0 and Position >= 1 ==> exists|i: int| 0 <= i < s1.len() and s1[i] == Element

+pub fn FindPositionOfElement(a: &[i32], Element: usize, n1: usize, s1: &[i32]) -> (Position: i32, Count: usize)

+    requires

+        n1 == s1.len() && 0 <= n1 <= a.len(),

+        forall|i: usize| 0 <= i < s1.len() ==> a[i] == s1[i],

+    ensures |result|

+        result.0 == -1 || result.0 >= 1,

+        s1.len() != 0 && result.0 >= 1 ==> exists|i: usize| 0 <= i < s1.len() && s1[i] == Element,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_spec_task_2.rs
@@ -1,17 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindPositionOfElement(a: Vec<int>, Element: nat, n1: nat, s1: Seq<int>) -> Position: int, Count: nat

-    requires n1 == s1.len() and 0 <= n1 <= a.len(),

-             forall|i: int| 0<= i < s1.len() ==> a[i] == s1[i]

-    ensures Position == -1 or Position >= 1,

-            s1.len() != 0 and Position >= 1 ==> exists|i: int| 0 <= i < s1.len() and s1[i] == Element

+pub fn find_position_of_element(a: &[i32], element: usize, n1: usize, s1: &[i32]) -> (position: i32, count: usize)

+    requires(

+        n1 == s1.len() && 0 <= n1 <= a.len() &&

+        forall|i: usize| 0 <= i < s1.len() ==> a[i] == s1[i]

+    )

+    ensures(|result: (i32, usize)|

+        result.0 == -1 || result.0 >= 1 &&

+        s1.len() != 0 && result.0 >= 1 ==> exists|i: usize| 0 <= i < s1.len() && s1[i] == element

+    )

 {

 }

 

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_1.rs
@@ -1,15 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AssignmentsToMark(students: int, tutors: int) -> (r: int)

-    requires students > 0 and tutors > 1

-    ensures r < students

+pub fn AssignmentsToMark(students: int, tutors: int) -> (r: int)

+    requires(students > 0 && tutors > 1)

+    ensures(|r: int| r < students)

 {

 }

 

+

+proof fn DivisionLemma(n: int, d: int)

+    requires(n > 0 && d > 1)

+    ensures(n / d < n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_spec_task_2.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AssignmentsToMarkOne(students: int, tutors: int) -> (r: int)

-    requires students > 0 and tutors > 1

-    ensures r < students

+pub fn AssignmentsToMarkOne(students: int, tutors: int) -> (r: int)

+    requires(students > 0 && tutors > 1)

+    ensures(r < students)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_lemma_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_lemma_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_lemma_spec_task_1.rs
@@ -1,18 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindZero(a: Vec<int>) -> (index: int)

-    requires a != null,

-             forall|i: int| 0 <= i < a.len() ==> 0 <= a[i],

-             forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i]

-    ensures index < 0  ==> forall|i: int| 0 <= i < a.len() ==> a[i] != 0,

-            0 <= index ==> index < a.len() and a[index] == 0

+proof fn SkippingLemma(a: &[int], j: int)

+    requires(a.len() >= 0)

+    requires(forall|i: int| 0 <= i < a.len() ==> 0 <= a[i])

+    requires(forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i])

+    requires(0 <= j < a.len())

+    ensures(forall|k: int| j <= k < j + a[j] && k < a.len() ==> a[k] != 0)

 {

 }

 

+

+pub fn FindZero(a: &[int]) -> (index: int)

+    requires(a.len() >= 0)

+    requires(forall|i: int| 0 <= i < a.len() ==> 0 <= a[i])

+    requires(forall|i: int| 0 < i < a.len() ==> a[i-1]-1 <= a[i])

+    ensures(|index: int| index < 0  ==> forall|i: int| 0 <= i < a.len() ==> a[i] != 0)

+    ensures(|index: int| 0 <= index ==> index < a.len() && a[index] == 0)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c>= b

+pub fn Max(a: i32, b: i32) -> (c: i32)

+    ensures(c >= a && c >= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_mymax_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c>= b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a && c >= b)

 {

 }

 

+pub fn Testing()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_trig_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_trig_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Programs_tmp_tmp99966ew4_trig_spec_task_1.rs
@@ -1,19 +1,9 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn P(x: int)

+spec fn P(x: int) -> bool;

 

 

-method test()

-    requires forall x {

-}

-    ensures Q(0) -> bool {

-    

-}

-

+pub fn test()

+    requires(forall|x: int| P(x) && Q(x))

+    ensures(Q(0))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_1.rs
@@ -1,15 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputePower(N: int) -> (y: nat)

-    requires N >= 0

-    ensures y == Power(N)

+

+spec fn Power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * Power((n - 1) as nat) }

+}

+

+

+pub fn ComputePower(N: int) -> (y: nat)

+    requires(N >= 0)

+    ensures(y == Power(N as nat))

 {

+    

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_2.rs
@@ -1,58 +1,53 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * Power((n - 1) as nat) }

+}

 

-verus! {

-

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn ComputePower1(N: int) -> (y: nat)

+    requires(N >= 0)

+    ensures(y == Power(N as nat))

 {

 }

 

+pub fn Max(a: &[nat]) -> (m: int)

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i as usize] <= m)

+    ensures((m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i as usize])

+{

+}

+

+pub fn Cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

+{

+}

+

+pub fn IncrementMatrix(a: &mut [[int]])

+    ensures(forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i as usize].len() ==> a[i as usize][j as usize] == old(a)[i as usize][j as usize] + 1)

+{

+}

+

+pub fn CopyMatrix(src: &[[int]], dst: &mut [[int]])

+    requires(src.len() == dst.len() && forall|i: int| 0 <= i < src.len() ==> src[i as usize].len() == dst[i as usize].len())

+    ensures(forall|i: int, j: int| 0 <= i < src.len() && 0 <= j < src[i as usize].len() ==> dst[i as usize][j as usize] == old(src)[i as usize][j as usize])

+{

+}

+

+pub fn DoubleArray(src: &[int], dst: &mut [int])

+    requires(src.len() == dst.len())

+    ensures(forall|i: int| 0 <= i < src.len() ==> dst[i as usize] == 2 * old(src)[i as usize])

+{

+}

+

+pub fn RotateLeft<T>(a: &mut [T])

+    requires(a.len() > 0)

+    ensures(forall|i: int| 0 <= i < a.len() - 1 ==> a[i as usize] == old(a)[(i + 1) as usize])

+    ensures(a[(a.len() - 1) as usize] == old(a)[0])

+{

+}

+

+pub fn RotateRight<T>(a: &mut [T])

+    requires(a.len() > 0)

+    ensures(forall|i: int| 1 <= i < a.len() ==> a[i as usize] == old(a)[(i - 1) as usize])

+    ensures(a[0] == old(a)[(a.len() - 1) as usize])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_3.rs
@@ -1,58 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power(n - 1) }

+}

 

-verus! {

-

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn compute_power1(N: int) -> (y: nat)

+    requires(N >= 0)

+    ensures(y == power(N))

 {

 }

 

+pub fn max(a: &[nat]) -> (m: int)

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i] <= m)

+    ensures((m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i])

+{

+}

+

+pub fn cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_4.rs
@@ -1,58 +1,20 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * Power((n - 1) as nat) }

+}

 

-verus! {

-

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn Max(a: &[nat]) -> i32

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i] <= result)

+    ensures((result == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && result == a[i])

 {

 }

 

+pub fn Cube(n: nat) -> nat

+    ensures(result == n * n * n)

+{

+}

+

+pub fn IncrementMatrix(a: &mut [[i32]])

+    ensures(forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[0].len() ==> a[i][j] == old(a)[i][j] + 1)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_5.rs
@@ -1,57 +1,36 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

+}

 

+pub fn compute_power1(N: int) -> (y: nat)

+    requires(N >= 0)

+    ensures(y == power(N as nat))

+{

+}

 

+pub fn max(a: &[nat]) -> (m: int)

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i] <= m)

+    ensures((m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i])

+{

+}

 

+pub fn cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

+{

+}

 

+pub fn increment_matrix(a: &mut [[int]])

+    ensures(forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[0].len() ==> a[i][j] == old(a)[i][j] + 1)

+{

+}

 

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn copy_matrix(src: &[[int]], dst: &mut [[int]])

+    requires(src.len() == dst.len() && src[0].len() == dst[0].len())

+    ensures(forall|i: int, j: int| 0 <= i < src.len() && 0 <= j < src[0].len() ==> dst[i][j] == old(src)[i][j])

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_6.rs
@@ -1,57 +1,43 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

+}

 

+pub fn max(a: &[nat]) -> (m: i32)

+    ensures

+        forall|i: int| 0 <= i < a.len() ==> a[i] <= m,

+        (m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i]

+{

+}

 

+pub fn cube(n: nat) -> (c: nat)

+    ensures c == n * n * n

+{

+}

 

+pub fn increment_matrix(a: &mut Vec<Vec<i32>>)

+    requires old(a).len() > 0 ==> old(a)[0].len() > 0,

+    ensures 

+        a.len() == old(a).len(),

+        forall|i: int| 0 <= i < a.len() ==> a[i].len() == old(a)[i].len(),

+        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[i].len() ==> a[i][j] == old(a)[i][j] + 1

+{

+}

 

+pub fn copy_matrix(src: &Vec<Vec<i32>>, dst: &mut Vec<Vec<i32>>)

+    requires 

+        src.len() == dst.len(),

+        forall|i: int| 0 <= i < src.len() ==> src[i].len() == dst[i].len()

+    ensures forall|i: int, j: int| 0 <= i < src.len() && 0 <= j < src[i].len() ==> dst[i][j] == old(src)[i][j]

+{

+}

 

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn double_array(src: &[i32], dst: &mut [i32])

+    requires src.len() == dst.len()

+    ensures forall|i: int| 0 <= i < src.len() ==> dst[i] == 2 * old(src)[i]

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_7.rs
@@ -1,58 +1,44 @@
+spec fn Power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * Power((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn ComputePower1(N: int) -> (y: nat)

+    requires(N >= 0)

+    ensures(y == Power(N as nat))

 {

 }

 

+pub fn Max(a: &[nat]) -> (m: int)

+    ensures(forall|i: int| 0 <= i < a.len() ==> a[i] <= m)

+    ensures((m == 0 && a.len() == 0) || exists|i: int| 0 <= i < a.len() && m == a[i])

+{

+}

+

+pub fn Cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

+{

+}

+

+pub fn IncrementMatrix(a: &mut [[int]])

+    ensures(forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < a[0].len() ==> a[i][j] == old(a)[i][j] + 1)

+{

+}

+

+pub fn CopyMatrix(src: &[[int]], dst: &mut [[int]])

+    requires(src.len() == dst.len() && src[0].len() == dst[0].len())

+    ensures(forall|i: int, j: int| 0 <= i < src.len() && 0 <= j < src[0].len() ==> dst[i][j] == old(src)[i][j])

+{

+}

+

+pub fn DoubleArray(src: &[int], dst: &mut [int])

+    requires(src.len() == dst.len())

+    ensures(forall|i: int| 0 <= i < src.len() ==> dst[i] == 2 * old(src)[i])

+{

+}

+

+pub fn RotateLeft(a: &mut [int])

+    requires(a.len() > 0)

+    ensures(forall|i: int| 0 <= i < a.len() - 1 ==> a[i] == old(a)[(i+1) as int])

+    ensures(a[a.len()-1] == old(a)[0])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_spec_task_8.rs
@@ -1,58 +1,46 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub fn Power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * Power(n - 1) }

+}

 

-verus! {

-

-fn ComputePower1(N: int) -> y: nat) requires N >= 0

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    requires N >= 0

-

-             N >= 0

-

-             N >= 0

-

-    ensures y == Power(N)

-

-            y == Power(N)

-

-            y == Power(N)

-

+pub fn Max(a: &[nat]) -> i32

+    ensures(forall|i: usize| i < a.len() ==> a[i] <= result)

+    ensures((result == 0 && a.len() == 0) || exists|i: usize| i < a.len() && result == a[i])

 {

 }

 

+pub fn Cube(n: nat) -> nat

+    ensures(result == n * n * n)

+{

+}

+

+pub fn IncrementMatrix(a: &mut [[i32]])

+    ensures(forall|i: usize, j: usize| i < a.len() && j < a[i].len() ==> a[i][j] == old(a)[i][j] + 1)

+{

+}

+

+pub fn CopyMatrix(src: &[[i32]], dst: &mut [[i32]])

+    requires(src.len() == dst.len() && forall|i: usize| i < src.len() ==> src[i].len() == dst[i].len())

+    ensures(forall|i: usize, j: usize| i < src.len() && j < src[i].len() ==> dst[i][j] == old(src)[i][j])

+{

+}

+

+pub fn DoubleArray(src: &[i32], dst: &mut [i32])

+    requires(src.len() == dst.len())

+    ensures(forall|i: usize| i < src.len() ==> dst[i] == 2 * old(src)[i])

+{

+}

+

+pub fn RotateLeft(a: &mut [i32])

+    requires(a.len() > 0)

+    ensures(forall|i: usize| i < a.len() - 1 ==> a[i] == old(a)[i + 1])

+    ensures(a[a.len() - 1] == old(a)[0])

+{

+}

+

+pub fn RotateRight(a: &mut [i32])

+    requires(a.len() > 0)

+    ensures(forall|i: usize| 1 <= i && i < a.len() ==> a[i] == old(a)[i - 1])

+    ensures(a[0] == old(a)[a.len() - 1])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_spec_task_1.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputePower(N: int) -> (y: nat)

-    requires N >= 0

-    ensures y == Power(N)

-{

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

 }

 

+pub fn compute_power(n: int) -> (y: nat)

+    requires(n >= 0)

+    ensures(y == power(n as nat))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Cube(n: nat) -> (c: nat)

-    ensures c == n * n * n

+pub fn cube(n: nat) -> (c: nat)

+    ensures(c == n * n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(x: int, y: int) -> x_out: int, y_out: int, n: int

+pub fn main(x: int, y: int) -> (x_out: int, y_out: int, n: int)

     requires x >= 0,

-             y >= 0,

-             x == y

-    ensures y_out == n

+    requires y >= 0,

+    requires x == y,

+    ensures |result: (int, int, int)| result.1 == result.2,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> x: int, m: int

-    requires n > 0

-    ensures (n <= 0) or (0 <= m and m < n)

+pub fn main(n: int) -> (x: int, m: int)

+    requires(n > 0)

+    ensures(|result: (int, int)| (n <= 0) || (0 <= result.1 && result.1 < n))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> i: int, x: int, y: int

-    requires n >= 0

-    ensures (i % 2 != 0) or (x == 2 * y)

+pub fn main(n: int) -> (i: int, x: int, y: int)

+    requires(n >= 0)

+    ensures(|result: (int, int, int)| (result.0 % 2 != 0) || (result.1 == 2 * result.2))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int, k: int) -> i: int, j: int

-    requires n >= 0,

-             k == 1 or k >= 0

-    ensures k + i + j >= 2 * n

+pub fn main(n: int, k: int) -> (i: int, j: int)

+    requires(n >= 0)

+    requires(k == 1 || k >= 0)

+    ensures(|result: (int, int)| k + result.0 + result.1 >= 2 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, key: int) -> (n: int)

-    requires forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

-    ensures 0 <= n <= a.len(),

-            forall|i: int| 0 <= i < n ==> a[i] < key,

-            forall|i: int| n <= i < a.len() ==> key <= a[i]

+pub fn binary_search(a: &[int], key: int) -> (n: int)

+    requires(forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j])

+    ensures(|n: int| 0 <= n <= a.len())

+    ensures(|n: int| forall|i: int| 0 <= i < n ==> a[i] < key)

+    ensures(|n: int| forall|i: int| n <= i < a.len() ==> key <= a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_spec_task_1.rs
@@ -1,15 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumArray(arr: Vec<int>) -> (sum: int)

-    requires arr.len() > 0

-    ensures sum == Sum(arr, arr.len())

+spec fn sum(arr: &[int], len: int) -> int

+    recommends

+        arr.len() > 0 && 0 <= len <= arr.len()

 {

+    if len == 0 { 0 } else { arr[len-1] + sum(arr, len-1) }

 }

 

+pub fn sum_array(arr: &[int]) -> (sum: int)

+    requires

+        arr.len() > 0

+    ensures

+        sum == sum(arr, arr.len() as int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_06_n_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Main() -> x: int, y: int

-    ensures x == y;

+pub fn Main() -> (x: int, y: int)

+    ensures x == y

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int) -> a: int, b: int

-    requires n >= 0

-    ensures a + b == 3 * n

+pub fn main(n: int) -> (a: int, b: int)

+    requires(n >= 0)

+    ensures(|result: (int, int)| result.0 + result.1 == 3 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(x: int) -> j: int, i: int

-    requires x > 0

-    ensures j == 2 * x

+pub fn main(x: int) -> (j: int, i: int)

+    requires(x > 0)

+    ensures(|result: (int, int)| result.0 == 2 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_spec_task_1.rs
@@ -1,15 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>, n: int) -> (max: int)

-    requires 0 < n <= a.len();

-    ensures is_max(max, a, n);

-{

+spec fn contains(v: int, a: &[int], n: int) -> bool {

+    exists|j: int| 0 <= j < n && a[j as nat] == v

 }

 

+

+spec fn upper_bound(v: int, a: &[int], n: int) -> bool {

+    forall|j: int| 0 <= j < n ==> a[j as nat] <= v

+}

+

+

+spec fn is_max(m: int, a: &[int], n: int) -> bool {

+    contains(m, a, n) && upper_bound(m, a, n)

+}

+

+

+pub fn max(a: &[int], n: int) -> (max: int)

+    requires(

+        0 < n <= a.len()

+    )

+    ensures(|max: int|

+        is_max(max, a, n)

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main(n: int, k: int) -> (k_out: int)

-    requires n > 0;,

-             k > n;

-    ensures k_out >= 0;

+pub fn main(n: int, k: int) -> (k_out: int)

+    requires(n > 0)

+    requires(k > n)

+    ensures(|k_out: int| k_out >= 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_spec_task_1.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputePower(n: nat) -> (p: nat)

-    ensures p == Power(n)

-{

+spec fn power(n: nat) -> nat {

+    if n == 0 { 1 } else { 2 * power((n - 1) as nat) }

 }

 

+pub fn compute_power(n: usize) -> (p: usize)

+    ensures p == power(n as nat)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_spec_task_1.rs
@@ -1,15 +1,15 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn count(v: int, a: Vec<int>, n: int) -> (r: int)

-    requires n >= 0 and n <= a.len();

-    ensures has_count(v, a, n) == r;

+spec fn has_count(v: int, a: &[int], n: int) -> int

+    decreases n

 {

+    if n == 0 { 0 } else {

+        if a[n-1] == v { has_count(v, a, n-1) + 1 } else { has_count(v, a, n-1) }

+    }

 }

 

+pub fn count(v: int, a: &[int], n: int) -> (r: int)

+    requires(n >= 0 && n <= a.len())

+    ensures(has_count(v, a, n) == r)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Minimum(a: Vec<int>) -> (m: int)

-    requires a.len() > 0

-    ensures exists|i: int| 0 <= i < a.len() and m == a[i],

-            forall|i: int| 0 <= i < a.len() ==> m <= a[i]

+pub fn minimum(a: &[i32]) -> (m: i32)

+    requires(a.len() > 0)

+    ensures(exists|i: usize| 0 <= i < a.len() && m == a[i])

+    ensures(forall|i: usize| 0 <= i < a.len() ==> m <= a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mult(a: int, b: int) -> (x: int)

-    requires a >= 0 and b >= 0

-    ensures x == a * b

+pub fn mult(a: int, b: int) -> (x: int)

+    requires(a >= 0 && b >= 0)

+    ensures(x == a * b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Main(xInit: int, y: int) -> (z: int)

-    requires xInit >= 0,

-             y >= 0

-    ensures z == 0

+pub fn Main(xInit: int, y: int) -> (z: int)

+    requires(xInit >= 0)

+    requires(y >= 0)

+    ensures(z == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleConditions(x: int) -> (r: int)

+pub fn TripleConditions(x: int) -> (r: int)

     ensures r == 3 * x

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Function_spec_task_3.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleConditions(x: int) -> (r: int)

-    ensures r == 3 * x

+pub fn TripleConditions(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

 }

 

+pub fn ProveSpecificationsEquivalent(x: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_1.rs
@@ -1,14 +1,26 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Triple1(x: int) -> (r: int)

-    ensures r == 3 * x

+

+

+

+pub fn Triple1(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

 }

 

-}
+

+

+

+pub fn DoubleQuadruple(x: int) -> (a: int, b: int)

+    ensures(a == 2 * x && b == 4 * x)

+{

+}

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_2.rs
@@ -1,14 +1,26 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn M() -> (r: int)

-    ensures r == 29

+

+

+

+

+

+

+

+

+

+pub fn M() -> (r: int)

+    ensures(r == 29)

 {

 }

 

+

+

+

+

+

+pub fn M() -> (r: int)

+    ensures(r == 29)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_3.rs
@@ -1,12 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn M() -> (r: int)

+spec fn F() -> int {

+    29

+}

+

+pub fn M() -> (r: int)

+    ensures r == 29

+{

+}

+

+pub fn Caller() {

+}

+

+pub fn M() -> (r: int)

     ensures r == 29

 {

 }


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost_spec_task_4.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MyMethod(x: int) -> (y: int)

-    requires 10 <= x

-    ensures 25 <= y

+pub fn MyMethod(x: i32) -> (y: i32)

+    requires(10 <= x)

+    ensures(25 <= y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Index(n: int) -> (i: int)

-    requires 1 <= n

-    ensures 0 <= i < n

+pub fn Index(n: int) -> (i: int)

+    requires(1 <= n)

+    ensures(|i: int| 0 <= i < n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_2.rs
@@ -1,15 +1,22 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Min(x: int, y: int) -> (m: int)

-    ensures m <= x and m <= y,

-            m == x or m == y

+

+pub fn Min(x: int, y: int) -> (m: int)

+    ensures(m <= x && m <= y)

+    ensures(m == x || m == y)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_3.rs
@@ -1,13 +1,27 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Max(x: int, y: int) -> (m: int)

-{

+

+

+

+pub fn Max(x: int, y: int) -> (m: int) {

 }

 

-}
+

+

+

+

+pub fn Max(x: int, y: int) -> (m: int) {

+}

+Sum

+

+

+

+

+pub fn Max(x: int, y: int) -> (m: int) {

+}

+SumCaller

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_4.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x + y,

-            m == if x >= y then x else y

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(s == x + y)

+    ensures(m == if x >= y { x } else { y })

 {

 }

 

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(s == x + y)

+    ensures(m == if x >= y { x } else { y })

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_5.rs
@@ -1,15 +1,28 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x + y,

-            m == if x >= y then x else y

+

+

+

+

+

+

+

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(s == x + y)

+    ensures(m == if x >= y { x } else { y })

 {

 }

 

-}
+

+

+

+

+

+pub fn MaxSumCaller() {

+}

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_6.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReconstructFromMaxSum(s: int, m: int) -> x: int, y: int

-    requires s <= 2 * m

-    ensures s == (x + y),

-            (m == x or m == y) and x <= m and y <= m

+pub fn ReconstructFromMaxSum(s: int, m: int) -> (x: int, y: int)

+    requires(s <= 2 * m)

+    ensures(|result: (int, int)| s == (result.0 + result.1))

+    ensures(|result: (int, int)| (m == result.0 || m == result.1) && result.0 <= m && result.1 <= m)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Index_spec_task_7.rs
@@ -1,15 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSum(x: int, y: int) -> s: int, m: int

-    ensures s == x + y,

-            m == if x >= y then x else y

+pub fn MaxSum(x: int, y: int) -> (s: int, m: int)

+    ensures(s == x + y)

+    ensures(m == if x >= y { x } else { y })

 {

 }

 

+pub fn ReconstructFromMaxSum(s: int, m: int) -> (x: int, y: int)

+    requires(s <= 2 * m)

+    ensures(s == (x + y))

+    ensures((m == x || m == y) && x <= m && y <= m)

+{

+}

+

+pub fn TestMaxSum(x: int, y: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn UpWhileLess(N: int) -> (i: int)

-    requires 0 <= N

-    ensures i == N

+pub fn UpWhileLess(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(i == N)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_2.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn UpWhileNotEqual(N: int) -> (i: int)

-    requires 0 <= N

-    ensures i == N

+pub fn UpWhileNotEqual(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(i == N)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_3.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DownWhileNotEqual(N: int) -> (i: int)

-    requires 0 <= N

-    ensures i == 0

+pub fn DownWhileNotEqual(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(i == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant_spec_task_4.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DownWhileGreater(N: int) -> (i: int)

-    requires 0 <= N

-    ensures i == 0

+pub fn DownWhileGreater(N: int) -> (i: int)

+    requires(0 <= N)

+    ensures(i == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_1.rs
@@ -1,13 +1,20 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

+pub fn Triple(x: int) -> (r: int)

 {

 }

 

-}
+

+pub fn Triple(x: int) -> (r: int)

+{

+}

+

+

+pub fn Triple(x: int) -> (r: int)

+{

+}

+

+

+pub fn Triple(x: int) -> (r: int)

+{

+}

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_2.rs
@@ -1,13 +1,2 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleIf(x: int) -> (r: int)

-{

-}

-

+pub fn TripleIf(x: int) -> (r: int) {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_3.rs
@@ -1,13 +1,2 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleOver(x: int) -> (r: int)

-{

-}

-

+pub fn TripleOver(x: int) -> (r: int) {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_4.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleConditions(x: int) -> (r: int)

-    requires x % 2 == 0

-    ensures r == 3 * x

+pub fn TripleConditions(x: int) -> (r: int)

+    requires(x % 2 == 0)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple_spec_task_5.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TripleConditions(x: int) -> (r: int)

-    requires x % 2 == 0

-    ensures r == 3 * x

+pub fn TripleConditions(x: int) -> (r: int)

+    requires(x % 2 == 0)

+    ensures(r == 3 * x)

 {

 }

 

+pub fn Caller()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn main() -> t1: int, t2: int, x: int, y: int

+pub fn main() -> (t1: int, t2: int, x: int, y: int)

     ensures y >= 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn min(a: Vec<int>, n: int) -> (min: int)

-    requires 0 < n <= a.len();

-    ensures (exists i : int :: 0 <= i and i < n and a[i] == min);,

-            (forall i : int :: 0 <= i and i < n ==> a[i] >= min);

+pub fn min(a: &[i32], n: i32) -> (min: i32)

+    requires(0 < n <= a.len())

+    ensures(exists|i: i32| 0 <= i && i < n && a[i as usize] == min)

+    ensures(forall|i: i32| 0 <= i && i < n ==> a[i as usize] >= min)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_small_numbers(a: Vec<int>, n: int, max: int) -> (r: int)

-    requires n > 0;,

-             n <= a.len();,

-             (forall i: int :: 0 <= i and i < n ==> a[i] <= max);

-    ensures r <= max * n;

+pub fn add_small_numbers(a: &[int], n: int, max: int) -> (r: int)

+    requires(n > 0)

+    requires(n <= a.len())

+    requires(forall|i: int| 0 <= i && i < n ==> a[i] <= max)

+    ensures(|r: int| r <= max * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn square(n: int) -> (r: int)

-    requires 0 <= n;

-    ensures r == n*n;

+pub fn square(n: int) -> (r: int)

+    requires(0 <= n)

+    ensures(r == n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_spec_task_1.rs
@@ -1,15 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn is_even(n: int) -> (r: bool)

-    requires n >= 0;

-    ensures r <==> even(n);

+spec fn even(n: int) -> bool

+    recommends n >= 0

 {

+    if n == 0 { true } else { !even(n-1) }

 }

 

+

+pub fn is_even(n: int) -> (r: bool)

+    requires(n >= 0)

+    ensures(r <==> even(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_1.rs
@@ -1,18 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SearchRecursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

-    requires 0 <= i <= j <= a.len();

-    ensures i <= k < j or k == -1;,

-            k != -1 ==> a[k] == x;,

-            k != -1 ==> forall|r | k < r < j: int| a[r] != x;,

-            k == -1 ==> forall|r | i <= r < j: int| a[r] != x;

+pub fn SearchRecursive(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(|k: int| i <= k < j || k == -1)

+    ensures(|k: int| k != -1 ==> a[k] == x)

+    ensures(|k: int| k != -1 ==> forall|r: int| k < r < j ==> a[r] != x)

+    ensures(|k: int| k == -1 ==> forall|r: int| i <= r < j ==> a[r] != x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 1_LinearSearch_spec_task_2.rs
@@ -1,18 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SearchLoop(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

-    requires 0 <= i <= j <= a.len();

-    ensures i <= k < j or k == -1;,

-            k != -1 ==> a[k] == x;,

-            k != -1 ==> forall|r | k < r < j: int| a[r] != x;,

-            k == -1 ==> forall|r | i <= r < j: int| a[r] != x;

+pub fn SearchLoop(a: Seq<int>, i: int, j: int, x: int) -> (k: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(|k: int| i <= k < j || k == -1)

+    ensures(|k: int| k != -1 ==> a[k] == x)

+    ensures(|k: int| k != -1 ==> forall|r: int| k < r < j ==> a[r] != x)

+    ensures(|k: int| k == -1 ==> forall|r: int| i <= r < j ==> a[r] != x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset_spec_task_2.rs
@@ -1,37 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Search(s: Seq<int>, x: int) -> k: int )

-

-    requires forall p, q | 0 <= p < q < |s|: : s[p] <= s[q];

-    ensures 0 <= k <= |s|;

-    ensures forall i | 0 <= i < k :: s[i] <= x;

-    ensures forall i | k <= i < |s| :: s[i] >= x;

-    ensures forall z | z in s[..k] :: z <= x;

-    ensures forall z | z in s[k..] :: z >= x;

-    ensures s == s[..k]+s[k..];

+pub fn search(s: Seq<int>, x: int) -> (k: int)

+    requires(

+        forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]

+    )

+    ensures(|k: int|

+        0 <= k <= s.len() &&

+        (forall|i: int| 0 <= i < k ==> s[i] <= x) &&

+        (forall|i: int| k <= i < s.len() ==> s[i] >= x) &&

+        (forall|z: int| s.subrange(0, k).contains(z) ==> z <= x) &&

+        (forall|z: int| s.subrange(k, s.len() as int).contains(z) ==> z >= x) &&

+        s == s.subrange(0, k) + s.subrange(k, s.len() as int)

+    )

 {

 }

 

-

-

-

-method Sort( m: multiset<int> ) returns ( r: seq<int>

-    requires forall|p: int, q  0 <= p < q < .len()s|: int| s[p] <= s[q];

-    ensures 0 <= k <= s.len();,

-            forall|i | 0 <= i < k: int| s[i] <= x;,

-            forall|i  k <= i < .len()s|: int| s[i] >= x;,

-            forall|z | z in s[..k]: int| z <= x;,

-            forall|z | z in s[k..]: int| z >= x;,

-            s == s[..k]+s[k..];,

-            multiset(r) == m;,

-            forall|p: int, q  0 <= p < q < .len()r|: int| r[p] <= r[q];

+pub fn sort(m: Multiset<int>) -> (r: Seq<int>)

+    ensures(|r: Seq<int>|

+        r.to_multiset() == m &&

+        (forall|p: int, q: int| 0 <= p < q < r.len() ==> r[p] <= r[q])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_1.rs
@@ -1,14 +1,7 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinOfMultiset(m: multiset<int>) -> (min: int)

-    requires m != multiset

+pub fn min_of_multiset(m: Multiset<int>) -> (min: int)

+    requires(m != Multiset::empty())

+    ensures(m.count(min) > 0)

+    ensures(forall|z: int| m.count(z) > 0 ==> min <= z)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_2.rs
@@ -1,14 +1,66 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn MinOfMultiset(m: multiset<int>) -> (min: int)

-    requires m != multiset

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn MinOfMultiset(m: multiset<int>) -> (min: int)

+    requires(m != multiset{})

+    ensures(min in m)

+    ensures(forall |z| z in m ==> min <= z)

 {

 }

 

+

+

+

+

+pub fn Test(m: multiset<int>)

+{

+}

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn Sort(m: multiset<int>) -> (s: seq<int>)

+

+    ensures(multiset(s) == m)

+    ensures(forall |p,q| 0 <= p < q < |s| ==> s[p] <= s[q])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_3.rs
@@ -1,13 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn MinOfMultiset(m: multiset<int>) -> (min: int)

-    requires m != multiset

+pub fn MinOfMultiset(m: Multiset<int>) -> (min: int)

+    requires(m != Multiset::empty())

+    ensures(m.count(min) > 0)

+    ensures(forall|z: int| m.count(z) > 0 ==> min <= z)

+{

+}

+

+pub fn Main()

+{

+}

+

+pub fn Sort(m: Multiset<int>) -> (s: Seq<int>)

+    ensures(s.to_multiset() == m)

+    ensures(forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q])

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset_spec_task_4.rs
@@ -1,13 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn MinOfMultiset(m: multiset<int>) -> (min: int)

-    requires m != multiset

+pub fn min_of_multiset(m: Multiset<int>) -> (min: int)

+    requires(m != Multiset::empty())

+    ensures(m.count(min) > 0)

+    ensures(forall|z: int| m.count(z) > 0 ==> min <= z)

+{

+}

+

+pub fn sort(m: Multiset<int>) -> (s: Seq<int>)

+    ensures(s.to_multiset() == m)

+    ensures(forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q])

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_1.rs
@@ -1,16 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Partition(m: multiset<int>) -> pre: multiset<int>, p: int, post: multiset<int>

-    requires m.len() > 0;

-    ensures p in m;,

-            m == pre+multiset

+pub fn Partition(m: Multiset<int>) -> (pre: Multiset<int>, p: int, post: Multiset<int>)

+    requires(m.len() > 0)

+    ensures(m.contains(p))

+    ensures(m == pre + Multiset::singleton(p) + post)

+    ensures(forall|z: int| pre.contains(z) ==> z <= p)

+    ensures(forall|z: int| post.contains(z) ==> z >= p)

 {

 }

 

+pub fn QuickSelect(m: Multiset<int>, k: int) -> (pre: Multiset<int>, kth: int, post: Multiset<int>)

+    requires(m.len() > 0)

+    requires(0 <= k < m.len())

+    ensures(kth in m)

+    ensures(m == pre + Multiset::singleton(kth) + post)

+    ensures(pre.len() == k)

+    ensures(forall|z: int| pre.contains(z) ==> z <= kth)

+    ensures(forall|z: int| post.contains(z) ==> z >= kth)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 8_H8_spec_task_2.rs
@@ -1,16 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn QuickSelect(m: multiset<int>, k: int) -> pre: multiset<int>, kth: int, post: multiset<int>

-    requires 0 <= k < m.len();

-    ensures kth in m;,

-            m == pre+multiset

+pub fn Partition(m: Multiset<int>) -> (pre: Multiset<int>, p: int, post: Multiset<int>)

+    requires(m.len() > 0)

+    ensures(m == pre + Multiset::singleton(p) + post)

+    ensures(forall|z: int| pre.count(z) > 0 ==> z <= p)

+    ensures(forall|z: int| post.count(z) > 0 ==> z >= p)

 {

+    unimplemented!()

+}

+

+pub fn QuickSelect(m: Multiset<int>, k: int) -> (pre: Multiset<int>, kth: int, post: Multiset<int>)

+    requires(0 <= k < m.len())

+    ensures(m.count(kth) > 0)

+    ensures(m == pre + Multiset::singleton(kth) + post)

+    ensures(pre.len() == k)

+    ensures(forall|z: int| pre.count(z) > 0 ==> z <= kth)

+    ensures(forall|z: int| post.count(z) > 0 ==> z >= kth)

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn F() -> (r: int)

-    ensures r <= 0

+pub fn F() -> (r: int)

+    ensures(r <= 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_F1a_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn F() -> (r: int)

-    ensures r <= 0

+pub fn F() -> (r: int)

+    ensures(r <= 0)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_spec_task_1.rs
@@ -1,18 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsSorted(s: Seq<int>) -> bool {

-    forall|p: int, q  0<=p<q<.len()s|: int| s[p]<=s[q]

+spec fn is_sorted(s: Seq<int>) -> bool {

+    forall|p: int, q: int| 0 <= p < q < s.len() ==> s[p] <= s[q]

 }

 

-fn InsertionSort(s: Seq<int>) -> (r: Seq<int>)

-    ensures multiset(r) == multiset(s);,

-            IsSorted(r);

+pub fn insertion_sort(s: Seq<int>) -> (r: Seq<int>)

+    ensures

+        r.to_multiset() == s.to_multiset(),

+        is_sorted(r),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_1.rs
@@ -1,18 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Search1000(a: Vec<int>, x: int) -> (k: int)

-    requires a.len() >= 1000;,

-             forall|p: int, q | 0 <= p < q < 1000: int| a[p] <= a[q];

-    ensures 0 <= k <= 1000;,

-            forall|r | 0 <= r < k: int| a[r] < x;,

-            forall|r | k <= r < 1000: int| a[r] >= x;

+pub fn Search1000(a: &[i32], x: i32) -> k: i32

+    requires(a.len() >= 1000)

+    requires(forall|p: usize, q: usize| 0 <= p < q < 1000 ==> a[p] <= a[q])

+    ensures(0 <= k <= 1000)

+    ensures(forall|r: usize| 0 <= r < k ==> a[r] < x)

+    ensures(forall|r: usize| k <= r < 1000 ==> a[r] >= x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_2.rs
@@ -1,28 +1,24 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Is2Pow(n: int) -> bool {

-    if n < 1 then

+pub open spec fn Is2Pow(n: int) -> bool {

+    if n < 1 {

         false

-    else if n == 1 then

+    } else if n == 1 {

         true

-    else

-        n%2 == 0 and Is2Pow(n/2)

+    } else {

+        n % 2 == 0 && Is2Pow(n / 2)

+    }

 }

 

-fn Search2PowLoop(a: Vec<int>, i: int, n: int, x: int) -> (k: int)

-    requires 0 <= i <= i+n <= a.len();,

-             forall|p: int, q | i <= p < q < i+n: int| a[p] <= a[q];,

-             Is2Pow(n+1);

-    ensures i <= k <= i+n;,

-            forall|r | i <= r < k: int| a[r] < x;,

-            forall|r | k <= r < i+n: int| a[r] >= x;

+

+

+pub fn Search2PowLoop(a: &[int], i: int, n: int, x: int) -> (k: int)

+    requires

+        0 <= i <= i + n <= a.len(),

+        forall|p: int, q: int| i <= p < q < i + n ==> a[p] <= a[q],

+        Is2Pow(n + 1),

+    ensures

+        i <= k <= i + n,

+        forall|r: int| i <= r < k ==> a[r] < x,

+        forall|r: int| k <= r < i + n ==> a[r] >= x,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_Search1000_spec_task_3.rs
@@ -1,28 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Is2Pow(n: int) -> bool {

-    if n < 1 then

+pub spec fn Is2Pow(n: int) -> bool {

+    if n < 1 {

         false

-    else if n == 1 then

+    } else if n == 1 {

         true

-    else

-        n%2 == 0 and Is2Pow(n/2)

+    } else {

+        n % 2 == 0 && Is2Pow(n / 2)

+    }

 }

 

-fn Search2PowRecursive(a: Vec<int>, i: int, n: int, x: int) -> (k: int)

-    requires 0 <= i <= i+n <= a.len();,

-             forall|p: int, q | i <= p < q < i+n: int| a[p] <= a[q];,

-             Is2Pow(n+1);

-    ensures i <= k <= i+n;,

-            forall|r | i <= r < k: int| a[r] < x;,

-            forall|r | k <= r < i+n: int| a[r] >= x;

+pub fn Search2PowRecursive(a: &[i32], i: usize, n: usize, x: i32) -> (k: usize)

+    requires

+        i <= i + n <= a.len(),

+        forall|p: int, q: int| i <= p < q < i + n ==> a[p as int] <= a[q as int],

+        Is2Pow((n + 1) as int),

+    ensures

+        |k: usize| i <= k <= i + n,

+        |k: usize| forall|r: int| i <= r < k ==> a[r] < x,

+        |k: usize| forall|r: int| k <= r < i + n ==> a[r] >= x,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_1.rs
@@ -1,16 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumIntsLoop(n: int) -> (s: int)

-    requires n >= 0;

-    ensures s == sumInts(n),

-            s == n*(n+1)/2;

+spec fn sumInts(n: int) -> int

+    recommends n >= 0

 {

+    if n == 0 {

+        0

+    } else {

+        sumInts(n-1)+n

+    }

 }

 

+

+

+pub fn SumIntsLoop(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == sumInts(n))

+    ensures(s == n*(n+1)/2)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_spec_task_2.rs
@@ -1,16 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sumInts(n: int) -> int

+    recommends n >= 0

+{

+    if n == 0 {

+        0

+    } else {

+        sumInts(n-1)+n

+    }

+}

 

-verus! {

 

-fn SumIntsLoop(n: int) -> (s: int)

-    requires n >= 0;

-    ensures s == sumInts(n),

-            s == n*(n+1)/2;

+pub fn SumIntsLoop(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == sumInts(n))

+    ensures(s == n*(n+1)/2)

 {

 }

 

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_1.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>, b: Vec<int>, i: int, j: int) -> (m: int)

-    requires 0 <= i < a.len(),

-             0 <= j < b.len()

-    ensures a[i] > b[j] ==> m == a[i],

-            a[i] <= b[j] ==> m == b[j]

+pub fn max(a: &[i32], b: &[i32], i: usize, j: usize) -> (m: i32)

+    requires(

+        i < a.len(),

+        j < b.len(),

+    )

+    ensures(|m: i32|

+        a[i as int] > b[j as int] ==> m == a[i as int] &&

+        a[i as int] <= b[j as int] ==> m == b[j as int]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_spec_task_2.rs
@@ -1,17 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>, b: Vec<int>, i: int, j: int) -> (m: int)

-    requires 0 <= i < a.len(),

-             0 <= j < b.len()

-    ensures a[i] > b[j] ==> m == a[i],

-            a[i] <= b[j] ==> m == b[j]

+pub fn max(a: &[i32], b: &[i32], i: usize, j: usize) -> (m: i32)

+    requires(

+        i < a.len() &&

+        j < b.len()

+    )

+    ensures(|m: i32|

+        (a[i as int] > b[j as int] ==> m == a[i as int]) &&

+        (a[i as int] <= b[j as int] ==> m == b[j as int])

+    )

 {

 }

 

+pub fn testMax(a: &[i32], b: &[i32], i: usize, j: usize)

+    requires(

+        i < a.len() &&

+        j < b.len()

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_SlowMax_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_SlowMax_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_SlowMax_spec_task_1.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub open spec fn max(x: nat, y: nat) -> nat

+{

+    if x < y { y } else { x }

+}

 

-verus! {

 

-fn slow_max(a: nat, b: nat) -> (z: nat)

+

+pub fn slow_max(a: nat, b: nat) -> (z: nat)

     ensures z == max(a, b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_1.rs
@@ -1,17 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures y>=0;,

-            x>=0 ==> x == y;,

-            x<0 ==> -x == y;,

-            y == abs(x);

+pub fn Abs(x: int) -> (y: int)

+    requires()

+    ensures(|y: int| y >= 0)

+    ensures(|y: int| x >= 0 ==> x == y)

+    ensures(|y: int| x < 0 ==> -x == y)

+    ensures(|y: int| y == abs(x))

 {

 }

 

+spec fn abs(x: int) -> int {

+    if x > 0 { x } else { -x }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_2.rs
@@ -1,17 +1,24 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures y>=0;,

-            x>=0 ==> x == y;,

-            x<0 ==> -x == y;,

-            y == abs(x);

+pub fn Abs(x: int) -> (y: int)

+    requires()

+    ensures(|y: int| y >= 0)

+    ensures(|y: int| x >= 0 ==> x == y)

+    ensures(|y: int| x < 0 ==> -x == y)

+    ensures(|y: int| y == abs(x))

 {

 }

 

-}
+

+spec fn abs(x: int) -> int {

+    if x > 0 { x } else { -x }

+}

+

+

+pub fn Testing()

+    requires()

+    ensures()

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_3.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultiReturn(x: int, y: int) -> more: int, less: int

-    requires y>=0;

-    ensures less <= x <= more;

+pub fn MultiReturn(x: int, y: int) -> (more: int, less: int)

+    requires(y >= 0)

+    ensures(|result: (int, int)| result.1 <= x <= result.0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples1_spec_task_4.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(x: int, y: int) -> (a: int)

-    ensures a == x or a == y;,

-            x > y ==> a == x;,

-            x <= y ==> a == y;

+pub fn Max(x: int, y: int) -> (a: int)

+    ensures

+        a == x || a == y,

+        x > y ==> a == x,

+        x <= y ==> a == y,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_by_inc(x: nat, y: nat) -> (z: nat)

-    ensures z == x+y;

+pub fn add_by_inc(x: nat, y: nat) -> (z: nat)

+    ensures z == x + y

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_2.rs
@@ -1,14 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Product(m: nat, n: nat) -> (res: nat)

-    ensures res == m*n;

+

+pub fn Product(m: nat, n: nat) -> (res: nat)

+    ensures(res == m * n)

 {

 }

 

-}
+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_examples2_spec_task_3.rs
@@ -1,15 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn gcdCalc(m: nat, n: nat) -> (res: nat)

-    requires m>0 and n>0;

-    ensures res == gcd(m,n);

+pub fn gcdCalc(m: nat, n: nat) -> (res: nat)

+    requires(m > 0 && n > 0)

+    ensures(res == gcd(m, n))

 {

 }

 

+spec fn gcd(m: nat, n: nat) -> nat

+    recommends(m > 0 && n > 0)

+{

+    if m == n { n }

+    else if m > n { gcd((m - n) as nat, n) }

+    else { gcd(m, (n - m) as nat) }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_spec_task_1.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn findMax(a: Vec<int>, n: int) -> (r: int)

-    requires a.len() > 0,

-             0 < n <= a.len()

-    ensures 0 <= r < n <= a.len();,

-            forall|k: int| 0 <= k < n <= a.len() ==> a[r] >= a[k];,

-            multiset(a[..]) == multiset(old(a[..]));

+pub fn findMax(a: &mut Vec<i32>, n: i32) -> (r: i32)

+    requires(

+        a.len() > 0,

+        0 < n <= a.len(),

+    )

+    ensures(|result: i32|

+        0 <= result < n <= a.len() &&

+        forall|k: i32| 0 <= k < n <= a.len() ==> a[result as int] >= a[k as int] &&

+        a@ == old(a)@

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_1.rs
@@ -1,17 +1,41 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

+spec fn min(a: int, b: int) -> int

+    ensures |result: int| result <= a && result <= b

+    ensures |result: int| result == a || result == b

+{

+    if a < b { a } else { b }

+}

 

-fn minMethod(a: int, b: int) -> (c: int)

-    ensures c <= a and c <= b,

-            c == a or c == b

 

-            c == min(a, b)

+

+

+pub fn minMethod(a: int, b: int) -> (c: int)

+    ensures c <= a && c <= b,

+    ensures c == a || c == b,

+

+    ensures c == min(a, b),

 {

 }

 

-}
+

+

+

+spec fn min(a: int, b: int) -> int

+    ensures |result: int| result <= a && result <= b

+    ensures |result: int| result == a || result == b

+{

+    if a < b { a } else { b }

+}

+

+

+

+

+

+spec fn min(a: int, b: int) -> int

+    ensures |result: int| result <= a && result <= b

+    ensures |result: int| result == a || result == b

+{

+    if a < b { a } else { b }

+}

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Dafny_tmp_tmpv_d3qi10_2_min_spec_task_2.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn minArray(a: Vec<int>) -> (m: int)

-    requires a!= null  and a.len() > 0 ;

-    ensures forall|k | 0 <= k < a.len(): int| m <= a[k],

-            exists|k | 0 <= k < a.len(): int| m == a[k]

+pub fn minArray(a: &[i32]) -> (m: i32)

+    requires(a.len() > 0)

+    ensures(|m: i32| forall|k: usize| 0 <= k < a.len() ==> m <= a[k])

+    ensures(|m: i32| exists|k: usize| 0 <= k < a.len() && m == a[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_spec_task_1.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn findMax(a: Vec<int>) -> pos: int, maxVal: int

-    requires a.len() > 0;,

-             forall|i: int| 0 <= i < a.len() ==> a[i] >= 0;

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= maxVal;,

-            exists|i: int| 0 <= i < a.len() and  a[i] == maxVal;,

-            0 <= pos < a.len(),

-            a[pos] == maxVal;

+pub fn findMax(a: &[int]) -> (pos: usize, maxVal: int)

+    requires(a.len() > 0)

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i] >= 0)

+    ensures(|result: (usize, int)| forall|i: int| 0 <= i < a.len() ==> a[i] <= result.1)

+    ensures(|result: (usize, int)| exists|i: int| 0 <= i < a.len() && a[i] == result.1)

+    ensures(|result: (usize, int)| 0 <= result.0 < a.len())

+    ensures(|result: (usize, int)| a[result.0 as int] == result.1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_spec_task_1.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn binarySearch(a: Vec<int>, val: int) -> (pos: int)

-    requires a.len() > 0,

-             forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

-    ensures 0 <= pos < a.len() ==> a[pos] == val,

-            pos < 0 or pos >= a.len()  ==> forall|i: int| 0 <= i < a.len() ==> a[i] != val

+pub fn binarySearch(a: &[i32], val: i32) -> (pos: i32)

+    requires(

+        a.len() > 0,

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    ensures(|pos: i32|

+        (0 <= pos < a.len() ==> a[pos as usize] == val) &&

+        (pos < 0 || pos >= a.len() ==> forall|i: usize| 0 <= i < a.len() ==> a[i] != val)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn lookForMin(a: Vec<int>, i: int) -> (m: int)

-    requires 0 <= i < a.len()

-    ensures i <= m < a.len(),

-            forall|k: int| i <= k < a.len() ==> a[k] >= a[m]

+pub fn lookForMin(a: &[i32], i: usize) -> (m: usize)

+    requires(

+        i < a.len()

+    )

+    ensures(|m: usize|

+        i <= m && m < a.len() &&

+        forall|k: usize| i <= k && k < a.len() ==> a[k as int] >= a[m as int]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_spec_task_2.rs
@@ -1,51 +1,25 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted(a: Vec<int>, a.Length)

+pub open spec fn sorted(a: &[int]) -> bool {

+    sortedA(a, a.len())

 }

 

 

-

-

-predicate sortedA (a: Vec<int>, i: int)

-

-	requires 0 <= i <= a.Length

-	reads a

+pub open spec fn sortedA(a: &[int], i: int) -> bool

+    requires 0 <= i <= a.len()

 {

-	forall k :: 0 < k < i ==> a[k-1] <= a[k]

+    forall|k: int| 0 < k < i ==> a[k-1] <= a[k]

 }

 

 

-

-

-method lookForMin (a: array<int>, i: int) returns (m: int)

-

-	requires 0 <= i < a.Length

-	ensures i <= m < a.Length

-	ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]

+pub fn lookForMin(a: &[int], i: int) -> (m: int)

+    requires 0 <= i < a.len()

+    ensures i <= m < a.len()

+    ensures forall|k: int| i <= k < a.len() ==> a[k] >= a[m]

 {

 }

 

 

-

-

-method insertionSort (a: array<int>)

-

-	modifies a

-	ensures sorted(a) -> bool {

-    

-}

-

-fn lookForMin(a: Vec<int>, i: int) -> (m: int)

-    requires 0 <= i < a.len()

-    ensures i <= m < a.len(),

-            forall|k: int| i <= k < a.len() ==> a[k] >= a[m]

+pub fn insertionSort(a: &mut [int])

+    ensures sorted(a)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_1.rs
@@ -1,16 +1,9 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn threshold(thres: int, Seq: Seq<int>) -> Seq_1: Seq<int>, Seq_2: Seq<int>

-    ensures (forall|x  x in Seq_1: int| x <= thres) and (forall|x .len() x in Seq_2: int| x >= thres),

-            Seq_1.len() + Seq_2.len() == Seq.len(),

-            multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)

+pub fn threshold(thres: int, Seq: Seq<int>) -> (Seq_1: Seq<int>, Seq_2: Seq<int>)

+    ensures

+        (forall|x: int| Seq_1.contains(x) ==> x <= thres) && (forall|x: int| Seq_2.contains(x) ==> x >= thres),

+        Seq_1.len() + Seq_2.len() == Seq.len(),

+        Seq_1.to_multiset().add(Seq_2.to_multiset()) == Seq.to_multiset(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_spec_task_2.rs
@@ -1,14 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn quickSort(Seq: Seq<int>) -> (Seq': Seq<int>)

-    ensures multiset(Seq) == multiset(Seq')

+pub fn quickSort(Seq: Seq<int>) -> (Seq': Seq<int>)

+    ensures(multiset(Seq) == multiset(Seq'))

 {

 }

 

+

+

+pub fn threshold(thres: int, Seq: Seq<int>) -> (Seq_1: Seq<int>, Seq_2: Seq<int>)

+    ensures((forall|x| x in Seq_1 ==> x <= thres) && (forall|x| x in Seq_2 ==> x >= thres))

+    ensures(|Seq_1| + |Seq_2| == |Seq|)

+    ensures(multiset(Seq_1) + multiset(Seq_2) == multiset(Seq))

+{

+}

+

+

+

+proof fn Lemma_1(Seq_1: Seq, Seq_2: Seq)

+    requires(multiset(Seq_1) == multiset(Seq_2))

+    ensures(forall|x| x in Seq_1 ==> x in Seq_2)

+{

+}

+

+

+

+pub fn quickSort(Seq: Seq<int>) -> (Seq': Seq<int>)

+    ensures(multiset(Seq) == multiset(Seq'))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn nonZeroReturn(x: int) -> (y: int)

-    ensures y != 0

+pub fn nonZeroReturn(x: int) -> (y: int)

+    ensures(y != 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn nonZeroReturn(x: int) -> (y: int)

-    ensures y != 0

+pub fn nonZeroReturn(x: int) -> (y: int)

+    ensures(y != 0)

 {

 }

 

+pub fn test()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_1.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn aba(a: Vec<int>) -> (b: Vec<int>)

-    ensures a.len() == b.len()

-            forall|x: int| 0<=x<b.len() ==> b[x] == abs(a[x])

-{

+fn abs(a: int) -> nat {

+    if a < 0 { -a } else { a }

 }

 

+pub fn aba(a: &[int]) -> Vec<int>

+    ensures |result| == a.len(),

+    ensures forall|x: usize| 0 <= x < result.len() ==> result[x] == abs(a[x]),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex2_spec_task_2.rs
@@ -1,15 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn aba(a: Vec<int>) -> (b: Vec<int>)

-    ensures a.len() == b.len()

-            forall|x: int| 0<=x<b.len() ==> b[x] == abs(a[x])

+spec fn abs(a: int) -> nat {

+    if a < 0 { -a } else { a }

+}

+

+pub fn aba(a: &[i32]) -> (b: Vec<i32>)

+    ensures

+        a.len() == b.len(),

+        forall|x: int| 0 <= x < b.len() ==> b[x as int] == abs(a[x as int]),

 {

 }

 

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_1.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: Vec<nat>) -> (m: int)

-    ensures a.len() > 0 ==> forall|k: int| 0<=k<a.len() ==> m >= a[k]

-            a.len() == 0 ==> m == -1,

-            a.len() > 0 ==> m in a[..]

+pub fn Max(a: &[nat]) -> (m: int)

+    requires(true)

+    ensures(|result: int| a.len() > 0 ==> forall|k: int| 0 <= k < a.len() ==> result >= a[k])

+    ensures(|result: int| a.len() == 0 ==> result == -1)

+    ensures(|result: int| a.len() > 0 ==> exists|i: int| 0 <= i < a.len() && result == a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_ex3_spec_task_2.rs
@@ -1,16 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: Vec<nat>) -> (m: int)

-    ensures a.len() > 0 ==> forall|k: int| 0<=k<a.len() ==> m >= a[k]

-            a.len() == 0 ==> m == -1,

-            a.len() > 0 ==> m in a[..]

+pub fn Max(a: &[nat]) -> m: int

+    requires(true)

+    ensures(a.len() > 0 ==> forall|k: int| 0 <= k < a.len() ==> m >= a[k as usize])

+    ensures(a.len() == 0 ==> m == -1)

+    ensures(a.len() > 0 ==> exists|i: int| 0 <= i < a.len() && m == a[i as usize])

 {

 }

 

+

+pub fn Checker()

+    requires(true)

+    ensures(true)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_1.rs
@@ -1,33 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> b: Vec<char>, functions or methods

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method Reverse(a: Vec<char>) returns (b: array<char>

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|k: int| 0 <= k < a.len() ==> b[k] == a[(a.len()-1) - k];

+pub fn Reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|k: usize| 0 <= k < a.len() ==> result[k] == a[(a.len()-1) - k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FlexWeek_tmp_tmpc_tfdj_3_reverse_spec_task_2.rs
@@ -1,33 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> b: Vec<char>, functions or methods

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method Reverse(a: Vec<char>) returns (b: array<char>

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|k: int| 0 <= k < a.len() ==> b[k] == a[(a.len()-1) - k];

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|k: usize| 0 <= k < a.len() ==> result[k] == a[(a.len()-1) - k])

 {

 }

 

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fact(x: int) -> (y: int)

-    requires x >= 0;

+pub fn Fact(x: int) -> (y: int)

+    requires(x >= 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fact(x: int) -> (y: int)

-    requires x >= 0;

+pub fn Fact(x: int) -> (y: int)

+    requires(x >= 0)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_1.rs
@@ -1,24 +1,42 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

+spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_2.rs
@@ -1,30 +1,56 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

+pub open spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+pub open spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

 {

 }

 

-}
+

+pub open spec fn isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+pub open spec fn isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures

+        res <==> isSubstringPred(sub, str)

+

+{

+}

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_3.rs
@@ -1,36 +1,67 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+pub open spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+pub open spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

 {

 }

 

-}
+

+pub open spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+pub open spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+

+{

+}

+

+

+pub open spec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+pub open spec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures(found <==> haveCommonKSubstringPred(k, str1, str2))

+

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_spec_task_4.rs
@@ -1,36 +1,78 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+predicate isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+predicate isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

 {

 }

 

+

+predicate isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+predicate isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+

+{

+}

+

+

+predicate haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+predicate haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: String, str2: String) -> (found: bool)

+    ensures(found <==> haveCommonKSubstringPred(k, str1, str2))

+

+{

+}

+

+

+proof fn haveCommon0SubstringLemma(str1: String, str2: String)

+    ensures(haveCommonKSubstringPred(0, str1, str2))

+{

+}

+

+

+pub fn maxCommonSubstringLength(str1: String, str2: String) -> (len: nat)

+    requires(str1.len() <= str2.len())

+    ensures(forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPred(k, str1, str2))

+    ensures(haveCommonKSubstringPred(len, str1, str2))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_1.rs
@@ -1,19 +1,28 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPredicate(pre: String, str: String) -> bool {

-    str.len() >= pre.len() and pre <= str

+pub open spec fn isPrefixPredicate(pre: &str, str: &str) -> bool

+{

+  str.len() >= pre.len() && pre <= str

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures pre.len() > str.len() ==> !res,

-            res == isPrefixPredicate(pre, str)

+

+

+

+pub fn isPrefix(pre: &str, str: &str) -> (res: bool)

+    ensures(pre.len() > str.len() ==> !res)

+    ensures(res == isPrefixPredicate(pre, str))

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_2.rs
@@ -1,22 +1,40 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPredicate(pre: String, str: String) -> bool {

-    str.len() >= pre.len() and pre <= str

-}

-spec fn isSubstringPredicate(sub: String, str: String) -> bool {

-    str.len() >= sub.len() and (exists|i: int| 0 <= i <= str.len() and isPrefixPredicate(sub, str[i..]))

+pub open spec fn isPrefixPredicate(pre: Seq<char>, str: Seq<char>) -> bool

+{

+  str.len() >= pre.len() && pre <= str

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures pre.len() > str.len() ==> !res,

-            res == isPrefixPredicate(pre, str)

+

+

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+  ensures(pre.len() > str.len() ==> !res)

+  ensures(res == isPrefixPredicate(pre, str))

 {

 }

 

-}
+

+

+

+pub open spec fn isSubstringPredicate(sub: Seq<char>, str: Seq<char>) -> bool

+{

+  str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && isPrefixPredicate(sub, str.subrange(i, str.len() as int)))

+}

+

+

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+  ensures(res == isSubstringPredicate(sub, str))

+{

+}

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_3.rs
@@ -1,25 +1,43 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPredicate(pre: String, str: String) -> bool {

-    str.len() >= pre.len() and pre <= str

-}

-spec fn isSubstringPredicate(sub: String, str: String) -> bool {

-    str.len() >= sub.len() and (exists|i: int| 0 <= i <= str.len() and isPrefixPredicate(sub, str[i..]))

-}

-spec fn haveCommonKSubstringPredicate(k: nat, str1: String, str2: String) -> bool {

-    str1.len() >= k and str2.len() >= k and (exists|i: int| 0 <= i <= str1.len() - k and isSubstringPredicate((str1[i..])[..k], str2))

+pub open spec fn isPrefixPredicate(pre: Seq<char>, str: Seq<char>) -> bool

+{

+  str.len() >= pre.len() && pre <= str

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures pre.len() > str.len() ==> !res,

-            res == isPrefixPredicate(pre, str)

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        pre.len() > str.len() ==> !res,

+        res == isPrefixPredicate(pre, str),

 {

 }

 

-}
+

+pub open spec fn isSubstringPredicate(sub: Seq<char>, str: Seq<char>) -> bool

+{

+  str.len() >= sub.len() && (exists|i: int| 0 <= i <= str.len() && isPrefixPredicate(sub, str.subrange(i as int, str.len() as int)))

+}

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        res == isSubstringPredicate(sub, str),

+{

+}

+

+

+pub open spec fn haveCommonKSubstringPredicate(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+  str1.len() >= k && str2.len() >= k && (exists|i: int| 0 <= i <= str1.len() - k && isSubstringPredicate((str1.subrange(i as int, str1.len() as int)).subrange(0int, k as int), str2))

+}

+

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures

+        str1.len() < k || str2.len() < k ==> !found,

+        haveCommonKSubstringPredicate(k, str1, str2) == found,

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_spec_task_4.rs
@@ -1,28 +1,47 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPredicate(pre: String, str: String) -> bool {

-    str.len() >= pre.len() and pre <= str

-}

-spec fn isSubstringPredicate(sub: String, str: String) -> bool {

-    str.len() >= sub.len() and (exists|i: int| 0 <= i <= str.len() and isPrefixPredicate(sub, str[i..]))

-}

-spec fn haveCommonKSubstringPredicate(k: nat, str1: String, str2: String) -> bool {

-    str1.len() >= k and str2.len() >= k and (exists|i: int| 0 <= i <= str1.len() - k and isSubstringPredicate((str1[i..])[..k], str2))

-}

-spec fn maxCommonSubstringPredicate(str1: String, str2: String, len: nat) -> bool {

-    forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPredicate(k, str1, str2)

+spec fn isPrefixPredicate(pre: &str, str: &str) -> bool

+{

+    str.len() >= pre.len() && pre <= str

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures pre.len() > str.len() ==> !res,

-            res == isPrefixPredicate(pre, str)

+pub fn isPrefix(pre: &str, str: &str) -> (res: bool)

+    ensures

+        pre.len() > str.len() ==> !res,

+        res == isPrefixPredicate(pre, str),

 {

 }

 

+spec fn isSubstringPredicate(sub: &str, str: &str) -> bool

+{

+    str.len() >= sub.len() && (exists|i: usize| 0 <= i <= str.len() && isPrefixPredicate(sub, &str[i..]))

+}

+

+pub fn isSubstring(sub: &str, str: &str) -> (res: bool)

+    ensures

+        res == isSubstringPredicate(sub, str),

+{

+}

+

+spec fn haveCommonKSubstringPredicate(k: nat, str1: &str, str2: &str) -> bool

+{

+    str1.len() >= k && str2.len() >= k && (exists|i: usize| 0 <= i <= str1.len() - k && isSubstringPredicate(&(&str1[i..])[..k], str2))

+}

+

+pub fn haveCommonKSubstring(k: nat, str1: &str, str2: &str) -> (found: bool)

+    ensures

+        str1.len() < k || str2.len() < k ==> !found,

+        haveCommonKSubstringPredicate(k, str1, str2) == found,

+{

+}

+

+spec fn maxCommonSubstringPredicate(str1: &str, str2: &str, len: nat) -> bool

+{

+    forall|k: nat| len < k <= str1.len() ==> !haveCommonKSubstringPredicate(k, str1, str2)

+}

+

+pub fn maxCommonSubstringLength(str1: &str, str2: &str) -> (len: nat)

+    ensures

+        len <= str1.len() && len <= str2.len(),

+        len >= 0,

+        maxCommonSubstringPredicate(str1, str2, len),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_1.rs
@@ -1,23 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

+predicate isPrefixPred(pre: Seq<char>, str: Seq<char>) {

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+predicate isNotPrefixPred(pre: Seq<char>, str: Seq<char>) {

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_2.rs
@@ -1,30 +1,69 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

+

+

+

+

+

+pub open spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+

+pub open spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str),

 {

 }

 

+

+pub open spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+

+pub open spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        res <==> isSubstringPred(sub, str),

+

+{

+}

+

+

+

+

+

+

+

+

+

+

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_3.rs
@@ -1,36 +1,84 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+

+

+

+spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+

+spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

 {

 }

 

+

+spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+

+spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+

+

+

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        res <==> isSubstringPred(sub, str)

+

+{

+}

+

+

+

+spec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures

+        found <==> haveCommonKSubstringPred(k, str1, str2)

+

+{

+}

+

+

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_spec_task_4.rs
@@ -1,35 +1,58 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool {

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

+{

+}

+

+spec fn isSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+spec fn isNotSubstringPred(sub: Seq<char>, str: Seq<char>) -> bool {

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len()))

+}

+

+pub fn isSubstring(sub: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        res <==> isSubstringPred(sub, str)

+{

+}

+

+spec fn haveCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: Seq<char>, str2: Seq<char>) -> bool {

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+pub fn haveCommonKSubstring(k: nat, str1: Seq<char>, str2: Seq<char>) -> (found: bool)

+    ensures

+        found <==> haveCommonKSubstringPred(k, str1, str2)

+{

+}

+

+pub fn maxCommonSubstringLength(str1: Seq<char>, str2: Seq<char>) -> (len: nat)

+    requires

+        str1.len() <= str2.len()

+    ensures

+        forall|k: int| len < k <= str1.len() ==> !haveCommonKSubstringPred(k as nat, str1, str2),

+        haveCommonKSubstringPred(len, str1, str2)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_4.rs
@@ -1,15 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFact(n: int) -> (f: int)

-    requires n >=0

-    ensures f== factorial(n)

+pub fn factorial(n: int) -> int

+    requires(n >= 0)

 {

 }

 

+pub fn ComputeFact(n: int) -> f: int

+    requires(n >= 0)

+    ensures(f == factorial(n))

+{

+}

+

+pub fn ComputeFact(n: int) -> f: int

+    requires(n >= 0)

+    ensures(f == factorial(n))

+{

+}

+

+pub fn Sqare_Lemma(n: int)

+    requires(n >= 1)

+    ensures(sumSerie(n) == n * n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_5.rs
@@ -1,15 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFact2(n: int) -> (f: int)

-    requires n >=0

-    ensures f== factorial(n)

+pub fn factorial(n: int) -> int

+    requires(n >= 0)

 {

 }

 

+pub fn ComputeFact2(n: int) -> int

+    requires(n >= 0)

+    ensures(|f: int| f == factorial(n))

+{

+}

+

+pub fn Sqare_Lemma(n: int)

+    requires(n >= 1)

+    ensures(sumSerie(n) == n * n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_6.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sqare(a: int) -> (x: int)

-    requires a>=1

-    ensures x == a*a

+pub fn Sqare(a: int) -> (x: int)

+    requires(a >= 1)

+    ensures(x == a * a)

 {

 }

 

+pub fn Sqare_Lemma(n: int)

+    requires(n >= 1)

+    ensures(sumSerie(n) == n * n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 1_Lab3_spec_task_7.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sqare2(a: int) -> (x: int)

-    requires a>=1

-    ensures x == a*a

+pub fn sqare2(a: int) -> (x: int)

+    requires(a >= 1)

+    ensures(x == a * a)

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_1.rs
@@ -1,14 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn vector_Sum(v: Seq<int>) -> (x: int)

-    ensures x == sum(v)

+spec fn sum(v: Seq<int>) -> int 

 {

+    if v =~= seq![] then 0

+    else if v.len() == 1 then v[0]

+    else v[0] + sum(v.subrange(1, v.len() as int))

+}

+

+proof fn empty_Lemma(r: Seq<int>)

+    ensures r =~= seq![]

+{

+    if r !=~= seq![] {

+    }

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_2.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxSeq(v: Seq<int>) -> (max: int)

-    requires v.len() >= 1

-    ensures forall|i: int| 0 <= i < v.len() ==> max >= v[i],

-            max in v

+pub fn maxSeq(v: Vec<i32>) -> (max: i32)

+    requires(v.len() >= 1)

+    ensures(|max: i32| forall|i: usize| 0 <= i < v.len() ==> max >= v[i])

+    ensures(|max: i32| exists|i: usize| 0 <= i < v.len() && max == v[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque 2_Lab6_spec_task_3.rs
@@ -1,16 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Cubes(n: int) -> (s: Seq<int>)

+pub fn Cubes(n: int) -> (s: Seq<int>)

     requires n >= 0

-    ensures s.len() == n,

-            forall i:int :: 0 <= i < n ==> s[i] == i*i*i

+    ensures |s| == n

+    ensures forall|i: int| 0 <= i < n ==> s[i] == i*i*i

 {

 }

 

+pub fn empty_Lemma(r: Seq<int>)

+    ensures r == Seq::empty()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_spec_task_1.rs
@@ -1,14 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+spec fn Potencia(x: nat, y: nat) -> nat

+    decreases y

 {

+    if y == 0 {

+        1

+    } else {

+        x * Potencia(x, (y - 1) as nat)

+    }

+}

+

+pub fn Pot(x: nat, y: nat) -> (r: nat)

+    ensures r == Potencia(x, y)

+{

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary Search_binary_search_spec_task_1.rs
@@ -1,18 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(arr: Vec<int>, target: int) -> (index: int)

-    requires distinct(arr),

-             sorted(arr)

-    ensures -1 <= index < arr.len(),

-            index == -1 ==> not_found(arr, target),

-            index != -1 ==> found(arr, target, index)

+pub fn BinarySearch(arr: &[i32], target: i32) -> (index: i32)

+    requires(distinct(arr))

+    requires(sorted(arr))

+    ensures(|index: i32| -1 <= index < arr.len() as i32)

+    ensures(|index: i32| index == -1 ==> not_found(arr, target))

+    ensures(|index: i32| index != -1 ==> found(arr, target, index))

 {

 }

 

+pub open spec fn sorted(a: &[i32]) -> bool

+{

+   forall|j: usize, k: usize| 0 <= j < k < a.len() ==> a[j] <= a[k]

+}

+

+pub open spec fn distinct(arr: &[i32]) -> bool

+{

+    forall|i: usize, j: usize| 0 <= i < arr.len() && 0 <= j < arr.len() && i != j ==> arr[i] != arr[j]

+}

+

+pub open spec fn not_found(arr: &[i32], target: i32) -> bool

+{

+    forall|j: usize| 0 <= j < arr.len() ==> arr[j] != target

+}

+

+pub open spec fn found(arr: &[i32], target: i32, index: i32) -> bool

+    recommends(-1 <= index < arr.len() as i32)

+{

+    if index == -1 { false }

+    else if arr[index as usize] == target { true }

+    else { false }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest Sum_largest_sum_spec_task_1.rs
@@ -1,15 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn largest_sum(nums: Vec<int>, k: int) -> (sum: int)

-    requires nums.len() > 0

-    ensures max_sum_subarray(nums, sum, 0, nums.len())

+pub fn largest_sum(nums: &[int], k: int) -> (sum: int)

+    requires(nums.len() > 0)

+    ensures(|result: int| max_sum_subarray(nums, result, 0, nums.len()))

 {

 }

 

+pub open spec fn max_sum_subarray(arr: &[int], sum: int, start: int, stop: int) -> bool

+    recommends(

+        arr.len() > 0,

+        0 <= start <= stop <= arr.len()

+    )

+{

+    forall|u: int, v: int| start <= u < v <= stop ==> Sum_Array(arr, u, v) <= sum

+}

+

+pub open spec fn Sum_Array(arr: &[int], start: int, stop: int) -> int

+    recommends(0 <= start <= stop <= arr.len())

+    decreases(stop - start)

+{

+    if start >= stop {

+        0

+    } else {

+        arr[stop-1] + Sum_Array(arr, start, stop-1)

+    }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum_spec_task_1.rs
@@ -1,19 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn twoSum(nums: Vec<int>, target: int) -> index1: int, index2: int

-    requires 2 <= nums.len(),

-             exists|i: int, j: int| (0 <= i < j < nums.len() and nums[i] + nums[j] == target)

-    ensures index1 != index2,

-            0 <= index1 < nums.len(),

-            0 <= index2 < nums.len(),

-            nums[index1] + nums[index2] == target

+pub fn twoSum(nums: &[i32], target: i32) -> (index1: usize, index2: usize)

+    requires 

+        2 <= nums.len(),

+        exists|i: int, j: int| (0 <= i < j < nums.len() && nums[i as int] + nums[j as int] == target),

+    ensures |result: (usize, usize)|

+        result.0 != result.1 &&

+        result.0 < nums.len() &&

+        result.1 < nums.len() &&

+        nums[result.0 as int] + nums[result.1 as int] == target,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo4-CountAndReturn_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountToAndReturnN(n: int) -> (r: int)

-    requires n >= 0

-    ensures r == n

+pub fn count_to_and_return_n(n: int) -> (r: int)

+    requires(n >= 0)

+    ensures(r == n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo7-ComputeSum_spec_task_1.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeSum(n: nat) -> (s: nat)

-    ensures s ==Sum(n)

-{

+spec fn sum(n: nat) -> nat {

+    if n == 0 { 0 } else { n + sum(n - 1) }

 }

 

+pub fn compute_sum(n: nat) -> (s: nat)

+    ensures s == sum(n)

+{

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/M2_tmp_tmp2laaavvl_Software Verification_Exercices_Exo9-Carre_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Carre(a: nat) -> (c: nat)

-    ensures c == a*a

+pub fn Carre(a: nat) -> (c: nat)

+    ensures(c == a * a)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn C(n: nat) -> nat {

+    if n == 0 { 1 } else { (4 * n - 2) * C((n - 1) as nat) / (n + 1) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn calcC(n: nat) -> (res: nat)

+pub fn calcC(n: nat) -> (res: nat)

     ensures res == C(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn find(a: Vec<int>, key: int) -> (index: int)

-    requires a.len() > 0;

-    ensures 0 <= index <= a.len();,

-            index < a.len() ==> a[index] == key;

+pub fn find(a: &[i32], key: i32) -> (index: usize)

+    requires(a.len() > 0)

+    ensures(index <= a.len())

+    ensures(index < a.len() ==> a[index as int] == key)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_spec_task_1.rs
@@ -1,14 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn calcSum(n: nat) -> nat 

+{   

+    n * (n - 1) / 2

+}

 

-verus! {

 

-fn sum(n: nat) -> (s: nat)

+pub fn sum(n: nat) -> (s: nat)

     ensures s == calcSum(n + 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_spec_task_2.rs
@@ -1,25 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isSorted(a: Vec<int>, from: nat, to: nat)

-  reads a

-  requires 0 <= from <= to <= a.Length

+

+pub fn insertionSort(a: &mut Vec<i32>)

+    requires(old(a).len() > 0)

+    ensures(isSorted(a, 0, a.len() as nat))

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

 {

-    forall i, j: : from <= i < j < to ==> a[i] <= a[j]

 }

 

 

+pub open spec fn isSorted(a: &Vec<i32>, from: nat, to: nat) -> bool

+    recommends(0 <= from <= to <= a.len())

+{

+    forall|i: int, j: int| from <= i < j < to ==> a[i as usize] <= a[j as usize]

+}

 

 

-

-

-method testInsertionSort() -> bool {

-    

+pub fn testInsertionSort() {

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn leq(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    ensures result <==> (a.len() <= b.len() and a[..] == b[..a.len()]) or (exists|k: int| 0 <= k < a.len() and k < b.len() and a[..k] == b[..k] and a[k] < b[k])

+pub fn leq(a: &[i32], b: &[i32]) -> bool

+    ensures(|result: bool| result <==> (a.len() <= b.len() && a[..] == b[..a.len()]) || (exists|k: usize| 0 <= k < a.len() && k < b.len() && a[..k] == b[..k] && a[k] < b[k]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MFS_tmp_tmpmmnu354t_Testes anteriores_T2_ex5_2020_2_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn leq(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    ensures result <==> (a.len() <= b.len() and a[..] == b[..a.len()]) or (exists|k: int| 0 <= k < a.len() and k < b.len() and a[..k] == b[..k] and a[k] < b[k])

+pub fn leq(a: &[i32], b: &[i32]) -> bool

+    ensures(|result: bool| result <==> (a.len() <= b.len() && a[..] == b[..a.len()]) || (exists|k: usize| 0 <= k < a.len() && k < b.len() && a[..k] == b[..k] && a[k] < b[k]))

 {

 }

 

+pub fn testLeq()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn F(n: nat) -> nat {

+    if n <= 2 { n } else { F(n-1) + F(n-3) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn calcF(n: nat) -> (res: nat)

+pub fn calcF(n: nat) -> (res: nat)

     ensures res == F(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn R(n: nat) -> nat {

+    if n == 0 { 0 } else if R((n-1) as nat) > n { R((n-1) as nat) - n } else { R((n-1) as nat) + n }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn calcR(n: nat) -> (r: nat)

+pub fn calcR(n: nat) -> (r: nat)

     ensures r == R(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_spec_task_1.rs
@@ -1,14 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+spec fn potencia(x: nat, y: nat) -> nat

+    decreases y

 {

+    if y == 0 {

+        1

+    } else {

+        x * potencia(x, y - 1)

+    }

 }

 

+pub fn pot(x: nat, y: nat) -> (r: nat)

+    ensures r == potencia(x, y)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_spec_task_1.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Par(n: int) -> bool {

+spec fn Par(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn FazAlgo(a: int, b: int) -> x: int, y: int

-    requires a >= b and Par (a-b)

+

+pub fn FazAlgo(a: int, b: int) -> (x: int, y: int)

+    requires a >= b && Par(a - b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_1.rs
@@ -1,14 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Fib(n: nat) -> nat

+{

+    if n < 2 {

+        n

+    } else {

+        Fib((n-2) as nat) + Fib((n-1) as nat)

+    }

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (x: nat)

+

+pub fn ComputeFib(n: nat) -> (x: nat)

     ensures x == Fib(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_spec_task_2.rs
@@ -1,14 +1,22 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Fib(n: nat) -> nat

+{

+    if n < 2 {

+        n

+    } else {

+        Fib(n-2) + Fib(n-1)

+    }

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (x: nat)

+

+pub fn ComputeFib(n: nat) -> (x: nat)

     ensures x == Fib(n)

 {

 }

 

+

+

+pub fn Teste()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn buscar(a: Vec<int>, x: int) -> (r: int)

-    ensures r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x,

-            0 <= r < a.len() ==> a[r] == x

+pub fn buscar(a: &[int], x: int) -> (r: int)

+    ensures(r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x)

+    ensures(0 <= r < a.len() ==> a[r] == x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_spec_task_1.rs
@@ -1,14 +1,14 @@
+spec fn soma(a: &[nat], i: nat) -> nat

+    recommends i <= a.len()

+{

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + soma(a, i-1)

+    }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn somatorio(a: Vec<nat>) -> (s: nat)

+pub fn somatorio(a: &[nat]) -> (s: nat)

     ensures s == soma(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_spec_task_1.rs
@@ -1,14 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Fatorial(n: nat) -> (f: nat)

+spec fn Fat(n: nat) -> nat

+    decreases n

+{

+    if n == 0 { 1 } else { n * Fat((n - 1) as nat) }

+}

+

+pub fn Fatorial(n: nat) -> (f: nat)

     ensures f == Fat(n)

 {

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_spec_task_1.rs
@@ -1,12 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn ComputeFib(n: nat) -> (x: nat)

+spec fn Fib(n: nat) -> nat {

+    if n < 2 {

+        n

+    } else {

+        Fib((n - 2) as nat) + Fib((n - 1) as nat)

+    }

+}

+

+pub fn ComputeFib(n: nat) -> (x: nat)

     ensures x == Fib(n)

 {

 }


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_spec_task_1.rs
@@ -1,14 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Mult(x: nat, y: nat) -> (r: nat)

-    ensures r == x * y

+

+

+

+

+pub fn Mult(x: nat, y: nat) -> (r: nat)

+    ensures(r == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_spec_task_1.rs
@@ -1,14 +1,68 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Pot(x: nat, y: nat) -> (r: nat)

-    ensures r == Potencia(x,y)

+

+

+

+

+

+

+

+

+pub open spec fn Potencia(x: nat, y: nat) -> nat {

+    if y == 0 {

+        1

+    } else {

+        x * Potencia(x, y - 1)

+    }

+}

+

+

+

+

+

+pub fn Pot(x: nat, y: nat) -> (r: nat)

+    ensures r == Potencia(x, y)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn f2(n: nat) -> nat {

+    if n == 0 { 0 } else { 5 * f2(n / 3) + n % 4 }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mod2(n: nat) -> (a: nat)

+pub fn mod2(n: nat) -> (a: nat)

     ensures a == f2(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_spec_task_1.rs
@@ -1,14 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mod(n: nat) -> (a: nat)

-    ensures a == f(n)

-{

+spec fn f(n: nat) -> nat {

+    if n == 0 { 1 }

+    else if n % 2 == 0 { 1 + 2 * f(n / 2) }

+    else { 2 * f(n / 2) }

 }

 

+pub fn mod(n: nat) -> (a: nat)

+    ensures(a == f(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_spec_task_1.rs
@@ -1,14 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn pow(a: int, e: nat) -> int {

+    if e == 0 { 1 } else { a * pow(a, (e - 1) as nat) }

+}

 

-verus! {

 

-fn Pow(a: nat, n: nat) -> (y: nat)

+pub fn Pow(a: nat, n: nat) -> (y: nat)

     ensures y == pow(a, n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn sum(n: nat) -> int {

+    if n == 0 { 0 } else { n + sum((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sum(n: nat) -> (s: int)

+pub fn Sum(n: nat) -> (s: int)

     ensures s == sum(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem2(p: int, q: int, X: int, Y: int) -> r: int, s: int

-    requires p == 2*X + Y and q == X + 3

-    ensures r == X and s == Y

+pub fn problem2(p: int, q: int, X: int, Y: int) -> (r: int, s: int)

+    requires(p == 2*X + Y && q == X + 3)

+    ensures(|result: (int, int)| result.0 == X && result.1 == Y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem3(m: int, X: int) -> (r: int)

-    requires X >= 0 and (2*m == 1 - X or m == X + 3)

-    ensures r == X

+pub fn problem3(m: int, X: int) -> (r: int)

+    requires(X >= 0 && (2*m == 1 - X || m == X + 3))

+    ensures(|r: int| r == X)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_spec_task_1.rs
@@ -1,14 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn problem5(n: nat) -> (x: int)

-    ensures x == f(n)

-{

+

+

+

+

+

+

+

+

+spec fn f(n: int) -> int {

+    if n < 0 { 0 } else { 3 * f(n - 5) + n }

 }

 

+

+

+pub fn problem5(n: nat) -> (x: int)

+    ensures(x == f(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_spec_task_1.rs
@@ -1,14 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn problem6(n: nat) -> (a: int)

-    ensures a == fSum(n)

-{

+spec fn f(n: int) -> int {

+    if n <= 0 { 1 } else { n + f(n-1)*f(n-2) }

 }

 

+spec fn fSum(n: nat) -> int {

+    if n <= 0 { 0 } else { f(n-1) + fSum(n-1) }

+}

+

+pub fn problem6(n: nat) -> (a: int)

+    ensures(a == fSum(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_InsertionSort_spec_task_2.rs
@@ -1,34 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted(a: Vec<int>, start: int, end: int)

- requires a!=null       

- requires 0<=start<=end<=a.Length       

- reads a       

- {           

-   forall j, k: : start<=j<k<end ==> a[j]<=a[k]

- }

+spec fn sorted(a: &[i32], start: int, end: int) -> bool

+    recommends

+        0 <= start <= end <= a.len(),

+{

+    forall|j: int, k: int| start <= j < k < end ==> a[j] <= a[k]

+}

 

-

-

-

-

-

-method InsertionSort (a:array<int>)

-requires a!=null && a.Length>1 

-ensures sorted(a, 0, a.Length) 

-modifies a

+pub fn insertion_sort(a: &mut Vec<i32>)

+    requires

+        a.len() > 1,

+    ensures

+        sorted(a, 0, a.len()),

 {

 }

-      

 

-method Main() -> bool {

-    

+pub fn main()

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_1.rs
@@ -1,29 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn reversed(arr: Vec<char>, outarr: Vec<char>, outarr

-{

-  forall k: : 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]

+spec fn reversed(arr: &[char], outarr: &[char]) -> bool {

+    arr.len() == outarr.len() &&

+    forall|k: int| 0 <= k < arr.len() ==> outarr[k] == arr[(arr.len() - 1 - k) as int]

 }

 

-

-

-

-method yarra(arr : array<char>) returns (outarr : array<char>)

-requires arr != null && arr.Length > 0

-ensures outarr != null && arr.Length == outarr.Length && reversed(arr, outarr) -> bool {

-    

-}

-

-fn yarra(arr: Vec<char>) -> (outarr: Vec<char>)

-    requires arr != null and arr.len() > 0

-    ensures outarr != null and arr.len() == outarr.len() and reversed(arr,outarr)

+pub fn yarra(arr: &[char]) -> (outarr: Vec<char>)

+    requires(arr.len() > 0)

+    ensures(arr.len() == outarr.len() && reversed(arr, &outarr))

 {

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced examples_ReverseString_spec_task_2.rs
@@ -1,29 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn reversed(arr: Vec<char>, outarr: Vec<char>, outarr

-{

-  forall k: : 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]

+spec fn reversed(arr: &[char], outarr: &[char]) -> bool {

+    arr.len() == outarr.len() &&

+    forall|k: int| 0 <= k <= (arr.len() as int) - 1 ==> outarr[k] == arr[(arr.len() as int) - 1 - k]

 }

 

-

-

-

-method yarra(arr : array<char>) returns (outarr : array<char>)

-requires arr != null && arr.Length > 0

-ensures outarr != null && arr.Length == outarr.Length && reversed(arr, outarr) -> bool {

-    

-}

-

-fn yarra(arr: Vec<char>) -> (outarr: Vec<char>)

-    requires arr != null and arr.len() > 0

-    ensures outarr != null and arr.len() == outarr.len() and reversed(arr,outarr)

+pub fn yarra(arr: &[char]) -> (outarr: Vec<char>)

+    requires(arr.len() > 0)

+    ensures(arr.len() == outarr.len() && reversed(arr, &outarr))

 {

 }

 

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_2.rs
@@ -1,111 +1,47 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn SplitPoint(a: Vec<int>, n: int)

-    reads a

-    requires 0 <= n <= n

-

-{

-    forall i, j: : 0 <= i < n <= j < a.Length ==> a[i] <= a[j]

+spec fn SplitPoint(a: &[int], n: int) -> bool {

+    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]

 }

 

-

-

-

-

-

-method QuickSort(a: array<int>)

-    modifies a

-    ensures forall i, j: : 0 <= i < j < a.Length ==> a[i] <= a[j]

-    ensures multiset(a[..]) == old(multiset(a[..])) -> bool {

-    

-}

-spec fn SwapFrame(a: Vec<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+pub fn QuickSort(a: &mut [int])

+    ensures

+        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

+        a@ == old(a)@.to_multiset(),

 {

 }

 

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+spec fn SwapFrame(a: &[int], old_a: &[int], lo: int, hi: int) -> bool

+    recommends 

+        0 <= lo <= hi <= a.len()

 {

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

+    (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) && 

+    a@.to_multiset() == old_a@.to_multiset()

 }

 

-

-

-method QuickSortAux(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi) -> bool {

-    

-}

-

-fn QuickSort(a: Vec<int>, j: : 0 <= i < j < a.Length ==> a[i] <= a[j]

-    ensures multiset(a[..]) == old(multiset(a[..]))

+pub fn QuickSortAux(a: &mut [int], lo: int, hi: int)

+    requires

+        0 <= lo <= hi <= a.len(),

+        SplitPoint(a, lo) && SplitPoint(a, hi),

+    ensures

+        forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

+        SwapFrame(a, old(a), lo, hi),

+        SplitPoint(a, lo) && SplitPoint(a, hi),

 {

 }

 

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

-{

-}

-

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

-{

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

-}

-

-

-

-method QuickSortAux(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi)

-{

-}

-

-

-

-

-method Partition(a: Vec<int>, lo: int, hi: int) -> (p: int)

-    requires 0 <= lo <= hi <= a.len()

-    reads a,

-             0 <= lo <= hi <= a.len()

-    reads a,

-             0 <= lo <= hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a,

-             0 <= lo < hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a

-    ensures forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            multiset(a[..]) == old(multiset(a[..])),

-            forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

-            SwapFrame(a, lo, hi),

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            lo <= p < hi,

-            forall|i: int| lo <= i < p ==> a[i] < a[p],

-            forall|i: int| p <= i < hi ==> a[p] <= a[i],

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            SwapFrame(a, lo, hi)

+pub fn Partition(a: &mut [int], lo: int, hi: int) -> (p: int)

+    requires

+        0 <= lo < hi <= a.len(),

+        SplitPoint(a, lo) && SplitPoint(a, hi),

+    ensures

+        lo <= p < hi,

+        forall|i: int| lo <= i < p ==> a[i] < a[p],

+        forall|i: int| p <= i < hi ==> a[p] <= a[i],

+        SplitPoint(a, lo) && SplitPoint(a, hi),

+        SwapFrame(a, old(a), lo, hi),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_3.rs
@@ -1,71 +1,41 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn SplitPoint(a: Vec<int>, n: int)

-    reads a

-    requires 0 <= n <= n

-

-{

-    forall i, j: : 0 <= i < n <= j < a.Length ==> a[i] <= a[j]

+spec fn SplitPoint(a: &[int], n: int) -> bool {

+    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]

 }

 

-

-

-

-

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+spec fn SwapFrame(a: &[int], old_a: &[int], lo: int, hi: int) -> bool

+    recommends 0 <= lo <= hi <= a.len()

 {

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

+    (forall|i: int| 0 <= i < lo || hi <= i < a.len() ==> a[i] == old_a[i]) && 

+    a@.to_multiset() == old_a@.to_multiset()

 }

 

-

-

-method QuickSortAux(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi) -> bool {

-    

-}

-

-fn QuickSortAux(a: Vec<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures forall i, j: : lo <= i < j < hi ==> a[i] <= a[j]

-    ensures SwapFrame(a, lo, hi)

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi)

+pub fn QuickSortAux(a: &mut Vec<int>, lo: int, hi: int)

+    requires

+        0 <= lo <= hi <= old(a).len(),

+        SplitPoint(&old(a), lo) && SplitPoint(&old(a), hi),

+    ensures

+        a.len() == old(a).len(),

+        forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

+        SwapFrame(&a, &old(a), lo, hi),

+        SplitPoint(&a, lo) && SplitPoint(&a, hi),

 {

 }

 

-

-

-

-method Partition(a: Vec<int>, lo: int, hi: int) -> (p: int)

-    requires 0 <= lo <= hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a,

-             0 <= lo < hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a

-    ensures forall|i: int, j: int| lo <= i < j < hi ==> a[i] <= a[j],

-            SwapFrame(a, lo, hi),

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            lo <= p < hi,

-            forall|i: int| lo <= i < p ==> a[i] < a[p],

-            forall|i: int| p <= i < hi ==> a[p] <= a[i],

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            SwapFrame(a, lo, hi)

+pub fn Partition(a: &mut Vec<int>, lo: int, hi: int) -> (p: int)

+    requires

+        0 <= lo < hi <= old(a).len(),

+        SplitPoint(&old(a), lo) && SplitPoint(&old(a), hi),

+    ensures

+        a.len() == old(a).len(),

+        lo <= p < hi,

+        forall|i: int| lo <= i < p ==> a[i] < a[p],

+        forall|i: int| p <= i < hi ==> a[p] <= a[i],

+        SplitPoint(&a, lo) && SplitPoint(&a, hi),

+        SwapFrame(&a, &old(a), lo, hi),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_ProgramProofs_ch15_spec_task_4.rs
@@ -1,56 +1,28 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn SplitPoint(a: Vec<int>, n: int)

-    reads a

-    requires 0 <= n <= n

-

-{

-    forall i, j: : 0 <= i < n <= j < a.Length ==> a[i] <= a[j]

+spec fn SplitPoint(a: &[int], n: int) -> bool {

+    forall|i: int, j: int| 0 <= i < n <= j < a.len() ==> a[i] <= a[j]

 }

 

-

-

-

-

-

-twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)

-    requires 0 <= lo <= hi <= a.Length

-    reads a

+spec fn SwapFrame(a: &[int], old_a: &[int], lo: int, hi: int) -> bool

+    requires 0 <= lo <= hi <= a.len()

 {

-    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))

+    (forall|i: int| (0 <= i < lo || hi <= i < a.len()) ==> a[i] == old_a[i]) && 

+    a@ == old_a@

 }

 

-

-

-

-

-method Partition(a: array<int>, lo: int, hi: int) returns (p: int)

-    requires 0 <= lo < hi <= a.Length

-    requires SplitPoint(a, lo) && SplitPoint(a, hi)

-    modifies a

-    ensures lo <= p < hi

-    ensures forall i: : lo <= i < p ==> a[i] < a[p]

-    ensures forall i :: p <= i < hi ==> a[p] <= a[i]

-    ensures SplitPoint(a, lo) && SplitPoint(a, hi)

-    ensures SwapFrame(a, lo, hi) -> bool {

-    

-}

-

-fn Partition(a: Vec<int>, lo: int, hi: int) -> (p: int)

-    requires 0 <= lo < hi <= a.len(),

-             SplitPoint(a, lo) and SplitPoint(a, hi)

-    modifies a

-    ensures lo <= p < hi,

-            forall|i: int| lo <= i < p ==> a[i] < a[p],

-            forall|i: int| p <= i < hi ==> a[p] <= a[i],

-            SplitPoint(a, lo) and SplitPoint(a, hi),

-            SwapFrame(a, lo, hi)

+pub fn Partition(a: &mut [int], lo: int, hi: int) -> (p: int)

+    requires 

+        0 <= lo < hi <= old(a).len(),

+        SplitPoint(&*old(a), lo) && SplitPoint(&*old(a), hi)

+    ensures 

+        lo <= p < hi,

+        forall|i: int| lo <= i < p ==> a[i] < a[p],

+        forall|i: int| p <= i < hi ==> a[p] <= a[i],

+        SplitPoint(&*a, lo) && SplitPoint(&*a, hi),

+        SwapFrame(&*a, &*old(a), lo, hi)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_examples_simpleMultiplication_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Foo(y: int, x: int) -> (z: int)

-    requires 0 <= y

-    ensures z == x*y

+pub fn Foo(y: int, x: int) -> (z: int)

+    requires(0 <= y)

+    ensures(z == x * y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_1.rs
@@ -1,15 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn removeElement(nums: Vec<int>, val: int) -> (i: int)

-    ensures forall|k: int| 0 < k < i < nums.len() ==> nums[k] != val

-    modifies nums

+pub fn removeElement(nums: &mut [i32], val: i32) -> (i: usize)

+    ensures(forall|k: usize| 0 < k < i < nums.len() ==> nums[k] != val)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_lc-remove-element_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn removeElement(nums: Vec<int>, val: int) -> (i: int)

-    ensures forall|k: int| 0 < k < i < nums.len() ==> nums[k] != val

-    modifies nums

+pub fn removeElement(nums: &mut Vec<i32>, val: i32) -> (i: i32)

+    ensures(

+        forall|k: usize| 0 < k < i < nums.len() ==> nums[k] != val

+    )

 {

 }

 

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_pathSum_spec_task_1.rs
@@ -1,19 +1,37 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isPath(paths: Seq<TreeNode>, root: TreeNode) -> bool {

-    if paths.len() == 0 then false else match paths[0] {

-        case Nil => false

-        case Cons(val, left, right) => if paths.len() == 1 then root == paths[0] else root == paths[0] and (isPath(paths[1..], left) or isPath(paths[1..], right))

+spec fn is_path(paths: Seq<TreeNode>, root: TreeNode) -> bool {

+    if paths.len() == 0 { 

+        false 

+    } else { 

+        match paths[0] {

+            TreeNode::Nil => false,

+            TreeNode::Cons(val, left, right) => {

+                if paths.len() == 1 { 

+                    root == paths[0] 

+                } else { 

+                    root == paths[0] && (is_path(paths.subrange(1, paths.len() as int), left) || is_path(paths.subrange(1, paths.len() as int), right))

+                }

+            }

+        }

+    }

 }

 

-fn hasPathSum(root: TreeNode, targetSum: int) -> (b: bool)

-    ensures b ==> exists p: seq<TreeNode> :: isPath(p, root) and pathSum(p) == targetSum

+spec fn path_sum(paths: Seq<TreeNode>) -> nat {

+    if paths.len() == 0 { 

+        0 

+    } else { 

+        match paths[0] {

+            TreeNode::Nil => 0,

+            TreeNode::Cons(val, left, right) => val + path_sum(paths.subrange(1, paths.len() as int))

+        }

+    }

+}

+

+pub fn has_path_sum(root: TreeNode, target_sum: int) -> (b: bool)

+    ensures(b ==> exists|p: Seq<TreeNode>| is_path(p, root) && path_sum(p) == target_sum)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_stairClimbing_spec_task_1.rs
@@ -1,21 +1,99 @@
+pub enum Steps {

+    One,

+    Two,

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub spec fn stepSum(xs: Seq<Steps>) -> nat {

+    if xs.len() == 0 { 0 } else {

+        match xs[0] {

+            Steps::One => 1,

+            Steps::Two => 2,

+        } + stepSum(xs.subrange(1, xs.len() as int))

+    }

+}

 

-verus! {

-

-spec fn stepEndsAt(xs: Seq<Steps>, n: nat) -> bool {

+pub spec fn stepEndsAt(xs: Seq<Steps>, n: nat) -> bool {

     stepSum(xs) == n

 }

-spec fn allEndAtN(ss: set<seq<Steps> >, n: nat) -> bool {

-    forall|xs: int|  xs in ss ==> stepEndsAt(xs, n)

+

+pub spec fn allEndAtN(ss: Set<Seq<Steps>>, n: nat) -> bool {

+    forall |xs| ss.contains(xs) ==> stepEndsAt(xs, n)

 }

 

-fn climbStairs(n: nat) -> (count: nat)

-    ensures exists ss: set< seq<Steps> > :: count == ss.len() and allEndAtN(ss, n)

+pub proof fn stepBaseZero()

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 0) && ss.len() == 0

 {

 }

 

+pub proof fn stepBaseOne()

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 1) && ss.len() == 1

+{

+}

+

+pub proof fn stepBaseTwo()

+    ensures exists |ss: Set<Seq<Steps>>| allEndAtN(ss, 2) && ss.len() == 2

+{

+}

+

+pub spec fn plusOne(x: Seq<Steps>) -> Seq<Steps> {

+    seq![Steps::One].add(x)

+}

+

+pub spec fn addOne(ss: Set<Seq<Steps>>) -> Set<Seq<Steps>>

+    ensures forall |x| ss.contains(x) ==> addOne(ss).contains(plusOne(x)),

+    ensures addOne(ss) == Set::new(|x| ss.contains(x) && plusOne(x) == x)

+{

+    Set::new(|x| exists |y| ss.contains(y) && x == plusOne(y))

+}

+

+pub proof fn UnequalSeqs<T>(xs: Seq<T>, ys: Seq<T>, someT: T)

+    requires xs != ys

+    ensures seq![someT].add(xs) != seq![someT].add(ys)

+{

+}

+

+pub proof fn plusOneNotIn(ss: Set<Seq<Steps>>, x: Seq<Steps>)

+    requires !ss.contains(x)

+    ensures !addOne(ss).contains(plusOne(x))

+{

+}

+

+pub proof fn addOneSize(ss: Set<Seq<Steps>>)

+    ensures addOne(ss).len() == ss.len()

+{

+}

+

+pub spec fn plusTwo(x: Seq<Steps>) -> Seq<Steps> {

+    seq![Steps::Two].add(x)

+}

+

+pub spec fn addTwo(ss: Set<Seq<Steps>>) -> Set<Seq<Steps>>

+    ensures forall |x| ss.contains(x) ==> addTwo(ss).contains(plusTwo(x)),

+    ensures addTwo(ss) == Set::new(|x| exists |y| ss.contains(y) && x == plusTwo(y))

+{

+    Set::new(|x| exists |y| ss.contains(y) && x == plusTwo(y))

+}

+

+pub proof fn plusTwoNotIn(ss: Set<Seq<Steps>>, x: Seq<Steps>)

+    requires !ss.contains(x)

+    ensures !addTwo(ss).contains(plusTwo(x))

+{

+}

+

+pub proof fn addTwoSize(ss: Set<Seq<Steps>>)

+    ensures addTwo(ss).len() == ss.len()

+{

+}

+

+pub proof fn stepSetsAdd(i: nat, steps: &[nat])

+    requires i >= 2,

+    requires steps.len() >= i + 1,

+    requires forall |k: nat| k < i ==> exists |ss: Set<Seq<Steps>>| steps[k] == ss.len() && allEndAtN(ss, k)

+    ensures exists |sp: Set<Seq<Steps>>| sp.len() == steps[i-1] + steps[i-2] && allEndAtN(sp, i)

+{

+}

+

+pub fn climbStairs(n: nat) -> (count: nat)

+    ensures exists |ss: Set<Seq<Steps>>| count == ss.len() && allEndAtN(ss, n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn toMultiset(s: String) -> (mset: multiset<char>)

-    ensures multiset(s) == mset

+pub fn toMultiset(s: &str) -> (mset: Multiset<char>)

+    ensures(Multiset::from_seq(s@) == mset)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_2.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn msetEqual(s: multiset<char>, t: multiset<char>) -> (equal: bool)

-    ensures s == t <==> equal

+pub fn msetEqual(s: Multiset<char>, t: Multiset<char>) -> (equal: bool)

+    ensures(s == t <==> equal)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_leetcode_validAnagram_spec_task_3.rs
@@ -1,14 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn toMultiset(s: String) -> (mset: multiset<char>)

-    ensures multiset(s) == mset

+pub fn toMultiset(s: &str) -> Multiset<char>

+    ensures(result == s@.to_multiset())

 {

 }

 

+pub fn msetEqual(s: Multiset<char>, t: Multiset<char>) -> bool

+    ensures((s == t) <==> result)

+{

+}

+

+pub fn isAnagram(s: &str, t: &str) -> bool

+    ensures((s@.to_multiset() == t@.to_multiset()) == result)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms and leetcode_math_pearson_spec_task_1.rs
@@ -1,13 +1,95 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-spec fn isEven(x: nat) -> bool {

-    x % 2 == 0

+pub fn eight(x: nat) -> nat {

 }

 

+

+

+

+

+pub fn isEven(x: nat) -> bool {

+}

+

+

+

+pub fn eight(x: nat) -> nat {

+}

+

+

+

+pub fn nineteenf(x: nat) -> nat {

+}

+

+

+

+

+

+

+

+

+

+pub fn reflexive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn symmetric<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn transitive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn equivalenceRelation<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn relationOnASet<T>(R: Set<(T,T)>, S: Set<T>) -> bool {

+}

+

+

+

+pub fn reflexive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn symmetric<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+    

+

+

+pub fn transitive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+pub fn transitive<T>(R: Set<(T,T)>, S: Set<T>) -> bool

+    requires(relationOnASet(R, S))

+{

+}

+

+

+

+

+

+pub fn test() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn plus_one(x: int) -> (r: int)

-    requires x >= 0;

-    ensures r == x + 1;

+pub fn plus_one(x: int) -> (r: int)

+    requires(x >= 0)

+    ensures(r == x + 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_details_spec_task_2.rs
@@ -1,13 +1,3 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_by_one(x: int, y: int) -> (r: int)

-{

-}

-

+pub fn add_by_one(x: int, y: int) -> (r: int) {

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn add_by_one(x: int, y: int) -> (r: int)

-    requires y >= 0;

-    ensures r == x + y;

+pub fn add_by_one(x: int, y: int) -> (r: int)

+    requires(y >= 0)

+    ensures(r == x + y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_add_by_one_spec_task_2.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn bar(x: int, y: int) -> (r: int)

-    requires y >= 0;

-    ensures r == x + y;

+pub fn bar(x: i32, y: i32) -> (r: i32)

+    requires

+        y >= 0,

+    ensures

+        r == x + y,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_find_max_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMax(a: Vec<int>) -> (max: int)

-    requires a != null and a.len() > 0;

-    ensures 0 <= max < a.len();,

-            forall|x: int| 0 <= x < a.len() ==> a[max] >= a[x];

+pub fn find_max(a: &[i32]) -> (max: usize)

+    requires(

+        a.len() > 0

+    )

+    ensures(|max: usize|

+        0 <= max < a.len() &&

+        forall|x: usize| 0 <= x < a.len() ==> a[max] >= a[x]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_product_details_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalcProduct(m: nat, n: nat) -> (res: nat)

-    ensures res == m*n;

+pub fn calc_product(m: nat, n: nat) -> (res: nat)

+    ensures(res == m * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_1.rs
@@ -1,14 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub open spec fn sum_up_to(n: nat) -> nat {

+    if n == 0 { 0 } else { sum_up_to((n-1) as nat) + 1 }

+}

 

-verus! {

 

-fn SumUpTo(n: nat) -> (r: nat)

-    ensures r == sum_up_to (n);

+pub fn SumUpTo(n: nat) -> (r: nat)

+    ensures r == sum_up_to(n)

 {

 }

 

-}
+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol_spec_task_2.rs
@@ -1,14 +1,22 @@
+spec fn total(a: Seq<nat>) -> nat {

+    if a.len() == 0 {

+        0

+    } else {

+        total(a.subrange(0, a.len() - 1)) + a[a.len() - 1]

+    }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Total(a: Seq<nat>) -> (r: nat)

-    ensures r == total (a[0..a.len()]);

+proof fn total_lemma(a: Seq<nat>, i: nat)

+    requires

+        a.len() > 0,

+        0 <= i < a.len(),

+    ensures

+        total(a.subrange(0, i)) + a[i] == total(a.subrange(0, i + 1)),

 {

 }

 

+pub fn Total(a: Seq<nat>) -> (r: nat)

+    ensures

+        r == total(a.subrange(0, a.len())),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from dafny main repo_dafny2_Classics_spec_task_1.rs
@@ -1,14 +1,13 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AdditiveFactorial(n: nat) -> (u: nat)

-    ensures u == Factorial(n);

+spec fn factorial(n: nat) -> nat

+    decreases n

 {

+    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }

 }

 

+pub fn additive_factorial(n: nat) -> (u: nat)

+    ensures u == factorial(n)

+{

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(blood: Vec<int>, key: int) -> (index: int)

-    requires blood != null

-    ensures 0 <= index ==> index < blood.len() and blood[index] == key,

-            index < 0 ==> forall|k: int| 0 <= k < blood.len() ==> blood[k] != key

+pub fn Find(blood: &[i32], key: i32) -> (index: i32)

+    requires(true)

+    ensures(|index: i32| 0 <= index ==> index < blood.len() && blood[index as usize] == key)

+    ensures(|index: i32| index < 0 ==> forall|k: usize| 0 <= k < blood.len() ==> blood[k] != key)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) -> (z: int)

-    ensures proveFunctionalPostcondition ==> z == if x > 101 then x-10 else 91;

+pub fn NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) -> z: int

+    ensures(proveFunctionalPostcondition ==> z == if x > 101 { x-10 } else { 91 })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant examples_KatzManna_spec_task_3.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Determinant(X: array2<int>, M: int) -> (z: int)

-    requires 1 <= M;,

-             X != null and M == X.Length0 and M == X.Length1;

-  modifies X;

+pub fn Determinant(X: &mut Vec<Vec<i32>>, M: i32) -> (z: i32)

+    requires 

+        1 <= M,

+        X.len() == M,

+        forall|i: int| 0 <= i < M ==> X[i].len() == M

+    ensures true

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_1.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn sumOdds(n: nat) -> (sum: nat)

-    requires n > 0;

-    ensures sum == n * n;

+pub fn sumOdds(n: nat) -> (sum: nat)

+    requires(n > 0)

+    ensures(sum == n * n)

 {

 }

 

-}
+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_spec_task_3.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn intDivImpl(n: int, d: int) -> q: int, r: int

-    requires n >= d and n >= 0 and d > 0;

-    ensures (d*q)+r == n and 0 <= q <= n/2 and 0 <= r < d;

+pub fn intDivImpl(n: int, d: int) -> (q: int, r: int)

+    requires(n >= d && n >= 0 && d > 0)

+    ensures(|result: (int, int)| (d * result.0) + result.1 == n && 0 <= result.0 <= n/2 && 0 <= result.1 < d)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_1.rs
@@ -1,15 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn fibIter(n: nat) -> (a: nat)

+spec fn fib(n: nat) -> nat {

+    if n < 2 { n } else { fib((n-2) as nat) + fib((n-1) as nat) }

+}

+

+pub fn fibIter(n: nat) -> (a: nat)

     requires n > 0

     ensures a == fib(n)

 {

+    todo!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_2.rs
@@ -1,15 +1,51 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn factIter(n: nat) -> (a: nat)

-    requires n >= 0;

-    ensures a == fact(n)

+

+

+

+

+

+

+

+

+spec fn fact(n: nat) -> nat

+{

+    if n == 0 { 1 } else { n * fact((n - 1) as nat) }

+}

+

+

+

+pub fn factIter(n: nat) -> (a: nat)

+    requires(n >= 0)

+    ensures(a == fact(n))

 {

 }

+ 

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_spec_task_3.rs
@@ -1,15 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn gcdI(m: int, n: int) -> (g: int)

-    requires m > 0 and n > 0

-    ensures g == gcd(m, n);

+spec fn gcd(m: nat, n: nat) -> nat

+    recommends m > 0 && n > 0

 {

+    if m == n { m }

+    else if m > n { gcd((m - n) as nat, n) }

+    else { gcd(m, (n - m) as nat) }

 }

 

+pub fn gcdI(m: int, n: int) -> (g: int)

+    requires m > 0 && n > 0

+    ensures g == gcd(m as nat, n as nat)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_spec_task_1.rs
@@ -1,15 +1,27 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

+spec fn gcd_prime(x: int, y: int) -> int

+    requires x > 0 && y > 0

+{

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd_prime(y, x) }

+}

 

-fn gcdI(m: int, n: int) -> (d: int)

-    requires m > 0 and n > 0

-    ensures d == gcd(m,n)

+

+

+pub fn gcdI(m: int, n: int) -> (d: int)

+    requires(m > 0 && n > 0)

+    ensures(|d: int| d == gcd(m, n))

 {

 }

 

+

+

+spec fn gcd_prime(x: int, y: int) -> int

+    requires x > 0 && y > 0

+{

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd_prime(y, x) }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_spec_task_1.rs
@@ -1,15 +1,32 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn gcdI(m: int, n: int) -> (d: int)

-    requires m > 0 and n > 0

-    ensures d == gcd(m, n);

+

+

+spec fn gcd_prime(x: int, y: int) -> int

+    recommends x > 0 && y > 0

+{

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd(y, x) }

+}

+

+

+

+pub fn gcdI(m: int, n: int) -> (d: int)

+    requires(m > 0 && n > 0)

+    ensures(d == gcd(m, n))

 {

 }

 

+

+

+

+

+spec fn gcd_prime(x: int, y: int) -> int

+    recommends x > 0 && y > 0

+{

+    if x == y { x }

+    else if x > y { gcd_prime(x - y, y) }

+    else { gcd(y, x) }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMin(a: Vec<int>, lo: nat) -> (minIdx: nat)

-    requires a != null and a.len() > 0 and lo < a.len()

-    ensures lo <= minIdx < a.len(),

-            forall|x: int| lo <= x < a.len() ==> a[minIdx] <= a[x]

+pub fn find_min(a: &[i32], lo: usize) -> (minIdx: usize)

+    requires(

+        a.len() > 0 && lo < a.len()

+    )

+    ensures(|minIdx: usize|

+        lo <= minIdx && minIdx < a.len() &&

+        forall|x: usize| lo <= x && x < a.len() ==> a[minIdx as int] <= a[x as int]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_spec_task_3.rs
@@ -1,38 +1,30 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn sorted(a: Seq<int>) -> bool {

-    forall|i  0 < i < .len()a|: int| a[i-1] <= a[i]

-}

-

-fn swap(a: Vec<int>, i: nat, j: nat)

-    modifies a

-    requires a != null && a.Length > 0 && i < a.Length && j < a.Length

-    ensures a[i] == old(a[j])

-    ensures a[j] == old(a[i])

+pub fn swap(a: &mut [i32], i: usize, j: usize)

+    requires(

+        a.len() > 0 && i < a.len() && j < a.len()

+    )

+    ensures(|a: &mut [i32]|

+        a[i] == old(a)[j] &&

+        a[j] == old(a)[i]

+    )

 {

 }

 

-

-

-

-

-

-

-

-method FindMin(a: array<int>, lo: nat) -> (minIdx: nat)

-    requires a != null and a.len() > 0 and i < a.len() and j < a.len(),

-             a != null and a.len() > 0 and lo < a.len()

-    ensures a[i] == old(a[j]),

-            a[j] == old(a[i]),

-            lo <= minIdx < a.len(),

-            forall|x: int| lo <= x < a.len() ==> a[minIdx] <= a[x]

+pub fn FindMin(a: &[i32], lo: usize) -> (minIdx: usize)

+    requires(

+        a.len() > 0 && lo < a.len()

+    )

+    ensures(|minIdx: usize|

+        lo <= minIdx && minIdx < a.len() &&

+        forall|x: usize| lo <= x && x < a.len() ==> a[minIdx] <= a[x]

+    )

 {

 }

 

+pub open spec fn sorted(a: Seq<i32>) -> bool

+{

+    forall|i: int| 0 < i < a.len() ==> a[i-1] <= a[i]

+}

+

+pub fn selectionSort(a: &mut [i32])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn square0(n: nat) -> (sqn: nat)

-    ensures sqn == n*n

+pub fn square0(n: nat) -> (sqn: nat)

+    ensures(sqn == n*n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_2.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn square1(n: nat) -> (sqn: nat)

-    ensures sqn == n*n

+pub fn square1(n: nat) -> (sqn: nat)

+    requires(n >= 0)

+    ensures(sqn == n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_4.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn q(x: nat, y: nat) -> (z: nat)

-    requires y - x > 2

-    ensures x < z*z < y

-

-

-method strange(),

-            1==2

+pub fn q(x: nat, y: nat) -> (z: nat)

+    requires(y - x > 2)

+    ensures(x < z * z < y)

 {

 }

 

+pub fn strange()

+    ensures(1 == 2)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_spec_task_5.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn q(x: nat, y: nat) -> (z: nat)

-    requires y - x > 2

-    ensures x < z*z < y

-

-

-method strange(),

-            1==2

+pub fn q(x: nat, y: nat) -> (z: nat)

+    requires(y - x > 2)

+    ensures(x < z * z < y)

 {

 }

 

+pub fn strange()

+    ensures(1 == 2)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_1.rs
@@ -1,15 +1,64 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn Gauss(n: int) -> (sum: int)

-    requires n >= 0

-    ensures sum == n*(n+1)/2

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn Gauss(n: int) -> (sum: int)

+    requires(n >= 0)

+    ensures(sum == n*(n+1)/2)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_spec_task_2.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn sumOdds(n: nat) -> (sum: nat)

-    ensures sum == n*n;

+pub fn sumOdds(n: nat) -> (sum: nat)

+    ensures(sum == n * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_1.rs
@@ -1,14 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn peasantMult(a: int, b: int) -> (r: int)

-    requires b > 0

-    ensures r == a * b

+proof fn peasant_mult_lemma(a: int, b: int)

+    requires b >= 0

+    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)

+    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)

+{

+}

+

+pub fn peasant_mult(a: int, b: int) -> (r: int)

+    requires(b > 0)

+    ensures(r == a * b)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780_spec_task_2.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn euclidianDiv(a: int, b: int) -> q: int, r: int

+pub fn euclidian_div(a: int, b: int) -> (q: int, r: int)

     requires a >= 0,

-             b > 0

-    ensures a == b * q + r

+    requires b > 0,

+    ensures |result: (int, int)| a == b * result.0 + result.1,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_1.rs
@@ -1,15 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn copyArr(a: Vec<int>, l: int, r: int) -> (ret: Vec<int>)

-    requires 0 <= l < r <= a.len()

-    ensures ret[..] == a[l..r]

+pub fn copyArr(a: &[int], l: int, r: int) -> (ret: Vec<int>)

+    requires(

+        0 <= l < r <= a.len()

+    )

+    ensures(|ret: Vec<int>|

+        ret@ == a[l as usize..r as usize]

+    )

 {

 }

 

-}
+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_2.rs
@@ -1,15 +1,44 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sorted(s: Seq<int>) -> bool {

+    forall|k1: int, k2: int| 0 <= k1 <= k2 < s.len() ==> s[k1] <= s[k2]

+}

 

-verus! {

 

-fn copyArr(a: Vec<int>, l: int, r: int) -> (ret: Vec<int>)

-    requires 0 <= l < r <= a.len()

-    ensures ret[..] == a[l..r]

+

+

+

+

+

+pub fn copyArr(a: &[int], l: int, r: int) -> (ret: Vec<int>)

+    requires(

+        0 <= l < r <= a.len()

+    )

+    ensures(|ret: Vec<int>|

+        ret@ == a@.subrange(l as int, r as int)

+    )

 {

 }

 

-}
+

+

+

+

+

+

+pub fn mergeArr(a: &mut [int], l: int, m: int, r: int)

+    requires(

+        0 <= l < m < r <= old(a).len() &&

+        sorted(old(a)@.subrange(l as int, m as int)) && sorted(old(a)@.subrange(m as int, r as int))

+    )

+    ensures(

+        sorted(a@.subrange(l as int, r as int)) &&

+        a@.subrange(0, l as int) == old(a)@.subrange(0, l as int) &&

+        a@.subrange(r as int, a.len() as int) == old(a)@.subrange(r as int, old(a).len() as int)

+    )

+{

+}

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_3.rs
@@ -1,14 +1,71 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn copyArr(a: Vec<int>, l: int, r: int) -> (ret: Vec<int>)

-    requires 0 <= l < r <= a.len()

-    ensures ret[..] == a[l..r]

+

+spec fn sorted(s: Seq<int>) -> bool {

+    forall|k1: int, k2: int| 0 <= k1 <= k2 < s.len() ==> s[k1] <= s[k2]

+}

+

+

+

+

+

+

+

+pub fn copyArr(a: &[int], l: int, r: int) -> (ret: Vec<int>)

+    requires(

+        0 <= l < r <= a.len()

+    )

+    ensures(|ret: Vec<int>|

+        ret@ == a@.subrange(l, r)

+    )

+{

+}

+

+

+

+

+

+

+

+pub fn mergeArr(a: &mut [int], l: int, m: int, r: int)

+    requires(

+        0 <= l < m < r <= old(a).len() &&

+        sorted(old(a)@.subrange(l, m)) && sorted(old(a)@.subrange(m, r))

+    )

+    ensures(

+        sorted(a@.subrange(l, r)) &&

+        a@.subrange(0, l) == old(a)@.subrange(0, l) &&

+        a@.subrange(r, a.len() as int) == old(a)@.subrange(r, old(a).len() as int)

+    )

+{

+}

+

+

+

+

+

+

+

+pub fn sort(a: &mut [int])

+    ensures(

+        sorted(a@)

+    )

+{

+}

+

+

+

+pub fn sortAux(a: &mut [int], l: int, r: int)

+    requires(

+        0 <= l < r <= old(a).len()

+    )

+    ensures(

+        sorted(a@.subrange(l, r)) &&

+        a@.subrange(0, l) == old(a)@.subrange(0, l) &&

+        a@.subrange(r, a.len() as int) == old(a)@.subrange(r, old(a).len() as int)

+    )

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_spec_task_4.rs
@@ -1,14 +1,50 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn copyArr(a: Vec<int>, l: int, r: int) -> (ret: Vec<int>)

-    requires 0 <= l < r <= a.len()

-    ensures ret[..] == a[l..r]

+

+spec fn sorted(s: Seq<int>) -> bool {

+    forall|k1: int, k2: int| 0 <= k1 <= k2 < s.len() ==> s[k1] <= s[k2]

+}

+

+

+

+

+

+

+

+pub fn copyArr(a: &Vec<int>, l: int, r: int) -> (ret: Vec<int>)

+    requires(0 <= l < r <= a.len())

+    ensures(ret@ == a@.subrange(l, r))

+{

+}

+

+

+

+

+

+

+

+pub fn mergeArr(a: &mut Vec<int>, l: int, m: int, r: int)

+    requires(0 <= l < m < r <= old(a).len())

+    requires(sorted(old(a)@.subrange(l, m)) && sorted(old(a)@.subrange(m, r)))

+    ensures(sorted(a@.subrange(l, r)))

+    ensures(a@.subrange(0, l) == old(a)@.subrange(0, l))

+    ensures(a@.subrange(r, a.len() as int) == old(a)@.subrange(r, old(a).len() as int))

+{

+}

+

+

+

+

+

+

+

+pub fn sortAux(a: &mut Vec<int>, l: int, r: int)

+    requires(0 <= l < r <= old(a).len())

+    ensures(sorted(a@.subrange(l, r)))

+    ensures(a@.subrange(0, l) == old(a)@.subrange(0, l))

+    ensures(a@.subrange(r, a.len() as int) == old(a)@.subrange(r, old(a).len() as int))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_1.rs
@@ -1,20 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StringSwap(s: String, i: nat, j: nat) -> (t: String)

-    requires i >= 0 and j >= 0 and s.len() >= 0;,

-             s.len() > 0 ==> i < s.len() and j < s.len();

-    ensures multiset(s[..]) == multiset(t[..]);,

-            s.len() == t.len();,

-            s.len() > 0 ==> forall k:nat :: k != i and k != j and k < s.len() ==> t[k] == s[k],

-            s.len() > 0 ==> t[i] == s[j] and t[j] == s[i];,

-            s.len() == 0 ==> t == s;

+pub fn string_swap(s: Seq<char>, i: nat, j: nat) -> (t: Seq<char>)

+    requires(

+        i >= 0 && j >= 0 && s.len() >= 0

+    )

+    requires(

+        s.len() > 0 ==> i < s.len() && j < s.len()

+    )

+    ensures(|t|

+        s.to_multiset() == t.to_multiset()

+    )

+    ensures(|t|

+        s.len() == t.len()

+    )

+    ensures(|t|

+        s.len() > 0 ==> forall|k: nat| k != i && k != j && k < s.len() ==> t[k as int] == s[k as int]

+    )

+    ensures(|t|

+        s.len() > 0 ==> t[i as int] == s[j as int] && t[j as int] == s[i as int]

+    )

+    ensures(|t|

+        s.len() == 0 ==> t == s

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex1_spec_task_2.rs
@@ -1,20 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StringSwap(s: String, i: nat, j: nat) -> (t: String)

-    requires i >= 0 and j >= 0 and s.len() >= 0;,

-             s.len() > 0 ==> i < s.len() and j < s.len();

-    ensures multiset(s[..]) == multiset(t[..]);,

-            s.len() == t.len();,

-            s.len() > 0 ==> forall k:nat :: k != i and k != j and k < s.len() ==> t[k] == s[k],

-            s.len() > 0 ==> t[i] == s[j] and t[j] == s[i];,

-            s.len() == 0 ==> t == s;

+pub fn string_swap(s: &str, i: usize, j: usize) -> (t: String)

+    requires(

+        i >= 0 && j >= 0 && s.len() >= 0,

+        s.len() > 0 ==> i < s.len() && j < s.len(),

+    )

+    ensures(|t: String|

+        multiset(s[..]) == multiset(t[..]) &&

+        s.len() == t.len() &&

+        (s.len() > 0 ==> forall|k: usize| k != i && k != j && k < s.len() ==> t[k] == s[k]) &&

+        (s.len() > 0 ==> t[i] == s[j] && t[j] == s[i]) &&

+        (s.len() == 0 ==> t == s)

+    )

 {

 }

 

+pub fn check()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_1.rs
@@ -1,43 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Sorted(a: String, low: int, high: int)

-requires 0 <= low <= high <= |a|

-{ 

-    forall j, k: : low <= j < k < high ==> a[j] <= a[k] 

+spec fn sorted(a: &str, low: int, high: int) -> bool

+    requires 0 <= low <= high <= a.len()

+{

+    forall|j: int, k: int| low <= j < k < high ==> a[j] <= a[k]

 }

 

-

-

-

-method String3Sort(a: string) returns (b: string) 

-requires |a| == 3;

-ensures Sorted(b, 0, |b|);

-ensures |a| == |b|;

-ensures multiset{

-}

-

+pub fn string3_sort(a: &str) -> (b: String)

+    requires a.len() == 3

+    ensures sorted(&b, 0, b.len())

+    ensures a.len() == b.len()

+    ensures multiset{b.chars().nth(0), b.chars().nth(1), b.chars().nth(2)} == multiset{a.chars().nth(0), a.chars().nth(1), a.chars().nth(2)}

 {

-}

- == multiset{a[0], a[1], a[2]};

-

-{

-    b: = a;

-    if (b[0] > b[1]) -> bool {

-    b := b[0 := b[1]][1 := b[0]];

-}

-

-fn String3Sort(a: String) -> (b: String)

-    requires a.len() == 3;

-    ensures Sorted(b, 0, b.len());,

-            a.len() == b.len();,

-            multiset

-{

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_ass2_ex2_spec_task_2.rs
@@ -1,43 +1,26 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-spec fn Sorted(a: String, low: int, high: int)

-requires 0 <= low <= high <= |a|

+

+

+spec fn Sorted(a: string, low: int, high: int) -> bool

+    requires 0 <= low <= high <= a.len()

 { 

-    forall j, k: : low <= j < k < high ==> a[j] <= a[k] 

+    forall |j: int, k: int| low <= j < k < high ==> a[j] <= a[k] 

 }

 

 

 

-

-method String3Sort(a: string) returns (b: string) 

-requires |a| == 3;

-ensures Sorted(b, 0, |b|);

-ensures |a| == |b|;

-ensures multiset{

-}

-

-{

-}

- == multiset{a[0], a[1], a[2]};

-

-{

-    b: = a;

-    if (b[0] > b[1]) -> bool {

-    b := b[0 := b[1]][1 := b[0]];

-}

-

-fn String3Sort(a: String) -> (b: String)

-    requires a.len() == 3;

-    ensures Sorted(b, 0, b.len());,

-            a.len() == b.len();,

-            multiset

+pub fn String3Sort(a: string) -> (b: string)

+    requires a.len() == 3

+    ensures Sorted(b, 0, b.len())

+    ensures a.len() == b.len()

+    ensures multiset{b[0], b[1], b[2]} == multiset{a[0], a[1], a[2]}

 {

 }

 

+

+

+pub fn check()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Getmini(a: Vec<int>) -> (mini: nat)

+pub fn Getmini(a: &[i32]) -> usize

     requires a.len() > 0

-    ensures 0 <= mini < a.len()

-            forall|x: int| 0 <= x < a.len() ==> a[mini] <= a[x]

-            forall|x: int| 0 <= x < mini ==> a[mini] < a[x]

+    ensures |mini: usize| 0 <= mini < a.len()

+    ensures |mini: usize| forall|x: usize| 0 <= x < a.len() ==> a[mini] <= a[x]

+    ensures |mini: usize| forall|x: usize| 0 <= x < mini ==> a[mini] < a[x]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex2_spec_task_2.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Getmini(a: Vec<int>) -> (mini: nat)

+pub fn Getmini(a: &[i32]) -> usize

     requires a.len() > 0

-    ensures 0 <= mini < a.len()

-            forall|x: int| 0 <= x < a.len() ==> a[mini] <= a[x]

-            forall|x: int| 0 <= x < mini ==> a[mini] < a[x]

+    ensures |mini: usize| 0 <= mini < a.len()

+    ensures |mini: usize| forall|x: usize| 0 <= x < a.len() ==> a[mini] <= a[x]

+    ensures |mini: usize| forall|x: usize| 0 <= x < mini ==> a[mini] < a[x]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Symmetric(a: Vec<int>) -> (flag: bool)

-    ensures flag == true ==> forall|x: int| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1],

-            flag == false ==> exists|x: int| 0 <= x < a.len() and a[x] != a[a.len() - x - 1]

+pub fn Symmetric(a: &[i32]) -> (flag: bool)

+    ensures(flag == true ==> forall|x: usize| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1])

+    ensures(flag == false ==> exists|x: usize| 0 <= x < a.len() && a[x] != a[a.len() - x - 1])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_exam_ex3_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Symmetric(a: Vec<int>) -> (flag: bool)

-    ensures flag == true ==> forall|x: int| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1],

-            flag == false ==> exists|x: int| 0 <= x < a.len() and a[x] != a[a.len() - x - 1]

+pub fn symmetric(a: &[i32]) -> (flag: bool)

+    ensures(flag == true ==> forall|x: usize| 0 <= x < a.len() ==> a[x] == a[a.len() - x - 1])

+    ensures(flag == false ==> exists|x: usize| 0 <= x < a.len() && a[x] != a[a.len() - x - 1])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_1.rs
@@ -1,15 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn sum(s: Vec<int>) -> (a: int)

-    requires s.len() > 0

-    ensures sumcheck(s, s.len()) == a

+

+

+

+spec fn sumcheck(s: &[int], i: int) -> int

+    recommends 0 <= i <= s.len()

+{

+    if i == 0 { 0 }

+    else { s[i - 1] + sumcheck(s, i - 1) }

+}

+

+

+

+

+

+pub fn sum(s: &[int]) -> (a: int)

+    requires(s.len() > 0)

+    ensures(sumcheck(s, s.len() as int) == a)

 {

 }

 

+

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex1_spec_task_2.rs
@@ -1,15 +1,24 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn sum(s: Vec<int>) -> (a: int)

-    requires s.len() > 0

-    ensures sumcheck(s, s.len()) == a

+spec fn sumcheck(s: &[int], i: int) -> int

+    decreases i

+{

+    requires(0 <= i <= s.len());

+    if i == 0 { 0 } else { s[i - 1] + sumcheck(s, i - 1) }

+}

+

+

+

+

+

+pub fn sum(s: &[int]) -> (a: int)

+    requires(s.len() > 0)

+    ensures(sumcheck(s, s.len() as int) == a)

 {

 }

 

+

+

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(s: Vec<nat>) -> (a: int)

-    requires s.len() > 0

-    ensures forall|x: int| 0 <= x < s.len() ==> a >= s[x],

-            a in s[..]

+pub fn max(s: &[nat]) -> (a: int)

+    requires(s.len() > 0)

+    ensures(forall|x: int| 0 <= x < s.len() ==> a >= s[x])

+    ensures(exists|i: int| 0 <= i < s.len() && a == s[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex2_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(s: Vec<nat>) -> (a: int)

-    requires s.len() > 0

-    ensures forall|x: int| 0 <= x < s.len() ==> a >= s[x],

-            a in s[..]

+pub fn max(s: &[nat]) -> (a: int)

+    requires(s.len() > 0)

+    ensures(forall|x: int| 0 <= x < s.len() ==> a >= s[x])

+    ensures(exists|i: int| 0 <= i < s.len() && a == s[i])

 {

 }

 

+pub fn Checker()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_1.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firste(a: Vec<char>) -> (c: int)

-    ensures -1 <= c < a.len(),

-            0 <= c < a.len() ==> a[c] == 'e' and forall|x: int| 0 <= x < c ==> a[x] != 'e',

-            c == -1 ==> forall|x: int| 0 <= x < a.len() ==> a[x] != 'e'

+pub fn firste(a: &[char]) -> (c: i32)

+    requires(

+        true

+    )

+    ensures(|c: i32|

+        -1 <= c && c < a.len() as i32 &&

+        (0 <= c && c < a.len() as i32 ==> a[c as usize] == 'e' && forall|x: i32| 0 <= x && x < c ==> a[x as usize] != 'e') &&

+        (c == -1 ==> forall|x: i32| 0 <= x && x < a.len() as i32 ==> a[x as usize] != 'e')

+    )

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_flex_ex5_spec_task_2.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firste(a: Vec<char>) -> (c: int)

-    ensures -1 <= c < a.len(),

-            0 <= c < a.len() ==> a[c] == 'e' and forall|x: int| 0 <= x < c ==> a[x] != 'e',

-            c == -1 ==> forall|x: int| 0 <= x < a.len() ==> a[x] != 'e'

+pub fn firste(a: &[char]) -> (c: i32)

+    requires(

+        true

+    )

+    ensures(|c: i32|

+        -1 <= c && c < a.len() as i32 &&

+        (0 <= c && c < a.len() as i32 ==> a[c as usize] == 'e' && forall|x: i32| 0 <= x && x < c ==> a[x as usize] != 'e') &&

+        (c == -1 ==> forall|x: i32| 0 <= x && x < a.len() as i32 ==> a[x as usize] != 'e')

+    )

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|x: int| 0 <= x < a.len() ==> b[x] == a[a.len() - x - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|x: usize| 0 <= x < a.len() ==> result[x] == a[a.len() - x - 1])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/SENG2011_tmp_tmpgk5jq85q_p1_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a.len() == b.len(),

-            forall|x: int| 0 <= x < a.len() ==> b[x] == a[a.len() - x - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| a.len() == result.len())

+    ensures(|result: Vec<char>| forall|x: usize| 0 <= x < a.len() ==> result[x] == a[a.len() - x - 1])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn best_time_to_buy_and_sell_stock(prices: Vec<int>) -> (max_profit: int)

-    requires 1 <= prices.len() <= 100000,

-             forall|i: int| 0 <= i < prices.len() ==> 0 <= prices[i] <= 10000

-    ensures forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= prices[j] - prices[i]

+pub fn best_time_to_buy_and_sell_stock(prices: &[i32]) -> (max_profit: i32)

+    requires(1 <= prices.len() <= 100000)

+    requires(forall|i: int| 0 <= i < prices.len() ==> 0 <= prices[i] <= 10000)

+    ensures(|max_profit: i32| forall|i: int, j: int| 0 <= i < j < prices.len() ==> max_profit >= prices[j] - prices[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Contains Duplicate_contains_duplicate_spec_task_1.rs
@@ -1,20 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn distinct(nums: Seq<int>) -> bool {

+pub fn contains_duplicate(nums: Seq<int>) -> (result: bool)

+    requires

+        1 <= nums.len() <= 100000,

+        forall|i: int| 0 <= i < nums.len() ==> -1000000000 <= nums[i] <= 1000000000,

+    ensures

+        result <==> distinct(nums),

+{

+}

+

+pub open spec fn distinct(nums: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] != nums[j]

 }

 

-fn contains_duplicate(nums: Seq<int>) -> (result: bool)

-    requires 1 <= nums.len() <= 100000,

-             forall|i: int| 0 <= i < nums.len() ==> -1000000000 <= nums[i] <= 1000000000

-    ensures result <==> distinct(nums)

-{

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Counting Bits_counting_bits_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn counting_bits(n: int) -> (result: Vec<int>)

+pub fn counting_bits(n: int) -> (result: Vec<int>)

     requires 0 <= n <= 100000

-    ensures result.len() == n + 1,

-            forall|i: int| 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2

+    ensures result.len() == n + 1

+    ensures forall|i: int| 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Longest Increasing Subsequence_longest_increasing_subsequence_spec_task_1.rs
@@ -1,18 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn longest_increasing_subsequence(nums: Vec<int>) -> (max: int)

-    requires 1 <= nums.len() <= 2500,

-             forall|i: int| 0 <= i < nums.len() ==> -10000 <= nums[i] <= 10000

-

-    ensures clause so that max is indeed equal to the longest increasing subsequence,

-            max >= 1

+pub fn longest_increasing_subsequence(nums: &[i32]) -> (max: i32)

+    requires(1 <= nums.len() <= 2500)

+    requires(forall|i: usize| 0 <= i < nums.len() ==> -10000 <= nums[i] <= 10000)

+    ensures(|max: i32| max >= 1)

 {

 }

 

+pub fn find_max(x: i32, y: i32) -> (result: i32)

+{

+    if x > y { x } else { y }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Non-overlapping Intervals_non_overlapping_intervals_spec_task_1.rs
@@ -1,43 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn non_overlapping_intervals(intervals: array2<int>) -> count: int)

-    modifies intervals

-    requires 1 <= intervals.Length0 <= 100000

-    requires intervals.Length1 == 2

-    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000

-    requires forall i: : 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000

-

-    ensures count >= 0

+pub fn non_overlapping_intervals(intervals: &mut Array2<i32>) -> (count: i32)

+    requires(

+        1 <= intervals.len_0() <= 100000,

+        intervals.len_1() == 2,

+        forall|i: usize| 0 <= i < intervals.len_0() ==> -50000 <= intervals[i, 0] <= 50000,

+        forall|i: usize| 0 <= i < intervals.len_0() ==> -50000 <= intervals[i, 1] <= 50000,

+    )

+    ensures(count >= 0)

 {

 }

 

-

-

-

-

-

-

-

-method bubble_sort(a: array2<int>)

-    modifies a

-    requires a.Length1 == 2

-    ensures sorted(a, 0, a.Length0 - 1

-    requires 1 <= intervals.Length0 <= 100000,

-             intervals.Length1 == 2,

-             forall|i: int| 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000,

-             forall|i: int| 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000

-

-             a.Length1 == 2

-    ensures clause so that count is indeed equal to the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping.,

-            count >= 0,

-            sorted(a, 0, a.Length0 - 1)

+pub fn bubble_sort(a: &mut Array2<i32>)

+    requires(a.len_1() == 2)

+    ensures(sorted(a, 0, a.len_0() - 1))

 {

 }

 

+pub fn sorted(a: &Array2<i32>, l: i32, u: i32) -> bool

+    requires(a.len_1() == 2)

+{

+    forall|i: i32, j: i32| 0 <= l <= i <= j <= u < a.len_0() ==> a[i, 1] <= a[j, 1]

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Remove Duplicates from Sorted Array_remove_duplicates_from_sorted_array_spec_task_1.rs
@@ -1,25 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn is_sorted(nums: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

-}

-spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]

-}

-

-fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)

-    requires is_sorted(nums),

-             1 <= nums.len() <= 30000,

-             forall|i: int| 0 <= i < nums.len() ==> -100 <= nums[i] <= 100

-    ensures is_sorted_and_distinct(result),

-            forall|i: int| i in nums <==> i in result

+pub fn remove_duplicates_from_sorted_array(nums: Seq<int>) -> (result: Seq<int>)

+    requires(is_sorted(nums))

+    requires(1 <= nums.len() <= 30000)

+    requires(forall|i: int| 0 <= i < nums.len() ==> -100 <= nums[i] <= 100)

+    ensures(is_sorted_and_distinct(result))

+    ensures(forall|i: int| nums.contains(i) <==> result.contains(i))

 {

 }

 

+spec fn is_sorted(nums: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

+}

+

+spec fn is_sorted_and_distinct(nums: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] < nums[j]

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-Verification_tmp_tmpv4ueky2d_Valid Palindrome_valid_panlindrome_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn isPalindrome(s: Vec<char>) -> (result: bool)

-    requires 1<= s.len() <= 200000

-    ensures result <==> (forall|i: int| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i])

+pub fn isPalindrome(s: &[char]) -> (result: bool)

+    requires(1 <= s.len() <= 200000)

+    ensures(result <==> (forall|i: usize| 0 <= i < s.len() / 2 ==> s[i] == s[s.len() - 1 - i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula1_spec_task_1.rs
@@ -1,13 +1,3 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn factImp(n: int) -> (r: int)

+pub fn factImp(n: int) -> (r: int)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: int, b: int) -> (z: int)

-    requires true

-    ensures z >= a or z >= b

+pub fn max(a: int, b: int) -> (z: int)

+    requires(true)

+    ensures(z >= a || z >= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: int, b: int) -> (z: int)

-    requires true

-    ensures z >= a or z >= b

+pub fn max(a: int, b: int) -> (z: int)

+    requires(true)

+    ensures(z >= a || z >= b)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_3.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mystery1(n: nat, m: nat) -> (res: nat)

-    ensures n+m == res

+pub fn mystery1(n: nat, m: nat) -> (res: nat)

+    ensures(n + m == res)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_4.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn mystery1(n: nat, m: nat) -> (res: nat)

-    ensures n+m == res

+pub fn mystery1(n: nat, m: nat) -> (res: nat)

+    ensures(n + m == res)

 {

 }

 

+pub fn mystery2(n: nat, m: nat) -> (res: nat)

+    ensures(n * m == res)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_5.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn m1(x: int, y: int) -> (z: int)

-    requires 0 < x < y

-    ensures z >= 0 and z < y and z != x

+pub fn m1(x: int, y: int) -> (z: int)

+    requires(0 < x < y)

+    ensures(|z: int| z >= 0 && z < y && z != x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_6.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn m2(x: nat) -> (y: int)

-    requires x <= -1

-    ensures y > x and y < x

+pub fn m2(x: nat) -> (y: int)

+    requires(x <= -1)

+    ensures(|y: int| y > x && y < x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_7.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn m3(x: int, y: int) -> (z: bool)

-    ensures z ==> x==y

+pub fn m3(x: i32, y: i32) -> (z: bool)

+    ensures(z ==> x == y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_spec_task_8.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn m4(x: int, y: int) -> (z: bool)

-    ensures z ==> x==y and x==y ==> z

+pub fn m4(x: int, y: int) -> (z: bool)

+    ensures(z ==> x==y && x==y ==> z)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_1.rs
@@ -1,14 +1,27 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat

+{

+    if n == 0 { 1 } else

+    if n == 1 { 1 } else fib((n-1) as nat) + fib((n-2) as nat)

+}

 

-verus! {

 

-fn Fib(n: nat) -> (r: nat)

-    ensures r == fib(n)

+pub fn Fib(n: nat) -> (r: nat)

+    ensures(r == fib(n))

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_2.rs
@@ -1,12 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn addImp(l: List<int>) -> (r: int)

+pub enum List<T> {

+    Nil,

+    Cons(T, Box<List<T>>),

+}

+

+pub open spec fn add(l: List<int>) -> int {

+    match l {

+        List::Nil => 0,

+        List::Cons(x, xs) => x + add(*xs),

+    }

+}

+

+pub fn addImp(l: List<int>) -> (r: int)

     ensures r == add(l)

 {

 }


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_3.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxArray(arr: Vec<int>) -> (max: int)

-    requires arr.len() > 0

-    ensures forall i: int :: 0 <= i < arr.len() ==> arr[i] <= max,

-            exists|x: int|0 <= x < arr.len() and arr[x] == max

+pub fn maxArray(arr: &[int]) -> (max: int)

+    requires(arr.len() > 0)

+    ensures(forall|i: int| 0 <= i < arr.len() ==> arr[i] <= max)

+    ensures(exists|x: int| 0 <= x < arr.len() && arr[x] == max)

 {

 }

 

+pub fn maxArray(arr: &[int]) -> (max: int)

+    requires(arr.len() > 0)

+    ensures(forall|i: int| 0 <= i < arr.len() ==> arr[i] <= max)

+    ensures(exists|x: int| 0 <= x < arr.len() && arr[x] == max)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_4.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxArrayReverse(arr: Vec<int>) -> (max: int)

-    requires arr.len() > 0

-    ensures forall i: int :: 0 <= i < arr.len() ==> arr[i] <= max,

-            exists|x: int|0 <= x < arr.len() and arr[x] == max

+pub fn maxArrayReverse(arr: &[i32]) -> (max: i32)

+    requires(arr.len() > 0)

+    ensures(|max: i32| forall|i: usize| 0 <= i < arr.len() ==> arr[i] <= max)

+    ensures(|max: i32| exists|x: usize| 0 <= x < arr.len() && arr[x] == max)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_spec_task_5.rs
@@ -1,14 +1,8 @@
+fn sum(n: nat) -> nat {

+    if n == 0 { 0 } else { n + sum((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn sumBackwards(n: nat) -> (r: nat)

+pub fn sumBackwards(n: nat) -> (r: nat)

     ensures r == sum(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_1.rs
@@ -1,14 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn query(a: Vec<int>, i: int, j: int) -> (res: int)

-    requires 0 <= i <= j <= a.len()

-    ensures res == sum(a, i, j)

+

+

+

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

+{

+    if i == j { 0 } else { a[j as usize - 1] + sum(a, i, j - 1) }

+}

+

+

+

+pub fn query(a: &[int], i: usize, j: usize) -> (res: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(res == sum(a, i as int, j as int))

+{

+}

+

+

+

+

+

+pub fn query2(a: &[int], i: usize, j: usize) -> (res: int)

+    requires(0 <= i <= j <= a.len())

+    ensures(res == sum(a, i as int, j as int))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_spec_task_2.rs
@@ -1,16 +1,32 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn queryFast(a: Vec<int>, c: Vec<int>, i: int, j: int) -> (r: int)

-    requires 0 <= i <= j <= a.len(),

-             is_prefix_sum_for(a,c)

-    ensures r == sum(a, i, j)

+spec fn sum(a: &[int], i: int, j: int) -> int

+    recommends 0 <= i <= j <= a.len()

 {

+    if i == j { 0 } else { a[j as usize - 1] + sum(a, i, j - 1) }

+}

+

+pub fn queryFast(a: &[int], c: &[int], i: int, j: int) -> (r: int)

+    requires(

+        0 <= i <= j <= a.len(),

+        is_prefix_sum_for(a, c)

+    )

+    ensures(r == sum(a, i, j))

+{

+    unimplemented!()

+}

+

+spec fn is_prefix_sum_for(a: &[int], c: &[int]) -> bool {

+    a.len() + 1 == c.len() && forall|i: int| 0 <= i <= a.len() ==> c[i as usize] == sum(a, 0, i)

+}

+

+proof fn proof(a: &[int], i: int, j: int, k: int)

+    requires(0 <= i <= k <= j <= a.len())

+    ensures(sum(a, i, k) + sum(a, k, j) == sum(a, i, j))

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_div_ent_it_spec_task_2.rs
@@ -1,28 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn div_ent_it(a: int, b: int) -> c: int, r: int)

-

-

-

-

-    requires a >= 0 && b > 0

-    ensures  a == b*c + r && 0 <= r < b

+pub fn div_ent_it(a: int, b: int) -> (c: int, r: int)

+    requires(a >= 0 && b > 0)

+    ensures(|result: (int, int)| a == b * result.0 + result.1 && 0 <= result.1 < b)

 {

 }

 

-

-

-

-method Main(

-    requires a >= 0 and b > 0

-    ensures a == b*c + r and 0 <= r < b

+pub fn Main()

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_1.rs
@@ -1,19 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn suma_it(V: Vec<int>) -> x: int)

-

-

-

-

-    ensures  x == suma_vector(V, 0

-    ensures x == suma_vector(V, 0)

+pub fn suma_it(V: &[i32]) -> (x: i32)

+    ensures(x == suma_vector(V, 0))

 {

 }

 

+pub fn suma_vector(V: &[i32], n: usize) -> i32

+    requires(0 <= n && n <= V.len())

+{

+    if n == V.len() {

+        0

+    } else {

+        V[n] + suma_vector(V, n + 1)

+    }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/TFG_tmp_tmpbvsao41w_Algoritmos Dafny_suma_it_spec_task_2.rs
@@ -1,19 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn suma_it(V: Vec<int>) -> x: int)

-

-

-

-

-    ensures  x == suma_vector(V, 0

-    ensures x == suma_vector(V, 0)

+pub fn suma_it(V: &[i32]) -> (x: i32)

+    ensures(x == suma_vector(V, 0))

 {

 }

 

+spec fn suma_vector(V: &[i32], n: nat) -> i32

+    recommends(0 <= n <= V.len())

+{

+    if n == V.len() { 0 } else { V[n] + suma_vector(V, n + 1) }

+}

+

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_1.rs
@@ -1,22 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn sorted_slice(a: Vec<int>, start: int, end: int)

-  requires 0 <= start <= end <= a.Length

-  reads a

+pub fn mergeSimple(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Vec<int>)

+    requires(sorted_seq(a1))

+    requires(sorted_seq(a2))

+    requires(0 <= start <= end <= b.len())

+    requires(a1.len() + a2.len() == end - start + 1)

+    ensures(sorted_slice(b, start, end))

 {

-  forall i, j: : start <= i <= j < end ==> a[i] <= a[j]

 }

 

+spec fn sorted_slice(a: &Vec<int>, start: int, end: int) -> bool

+    recommends(0 <= start <= end <= a.len())

+{

+    forall|i: int, j: int| start <= i <= j < end ==> a[i] <= a[j]

+}

 

-

-

-predicate sorted_seq(a: seq<int>) -> bool {

+spec fn sorted_seq(a: Seq<int>) -> bool

+{

     forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_spec_task_2.rs
@@ -1,34 +1,29 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn merged(a1: Seq<int>, a2: Seq<int>, b: Vec<int>, start: int, end: int)

-  reads b

-  requires end - start  == |a2| + |a1|

-  requires 0 <= start <= end <= b.Length

+pub fn merge(a1: Seq<int>, a2: Seq<int>, start: int, end: int, b: &mut Vec<int>)

+    requires(sorted_seq(a1))

+    requires(sorted_seq(a2))

+    requires(end - start == a1.len() + a2.len())

+    requires(0 <= start < end < a1.len() && end <= a2.len() < b.len())

+    requires(end < a1.len() && end < a2.len())

+    requires(b.len() == a2.len() + a1.len())

+    ensures(sorted_slice(b, start, end))

+    ensures(merged(a1, a2, b, start, end))

 {

-  multiset(a1) + multiset(a2) == multiset(b[start..end])

 }

 

-

-

-

-predicate sorted_slice(a: array<int>, start: int, end: int)

-  requires 0 <= start <= end <= a.Length

-  reads a

+pub fn merged(a1: Seq<int>, a2: Seq<int>, b: &Vec<int>, start: int, end: int) -> bool

+    requires(end - start == a2.len() + a1.len())

+    requires(0 <= start <= end <= b.len())

 {

-  forall i, j: : start <= i <= j < end ==> a[i] <= a[j]

+    a1.to_multiset() + a2.to_multiset() == b.subrange(start, end).to_multiset()

 }

 

-

-

-

-predicate sorted_seq(a: seq<int>) -> bool {

-    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]

+pub fn sorted_slice(a: &Vec<int>, start: int, end: int) -> bool

+    requires(0 <= start <= end <= a.len())

+{

+    forall|i: int, j: int| start <= i <= j < end ==> a[i] <= a[j]

 }

 

+pub fn sorted_seq(a: Seq<int>) -> bool

+{

+    forall|i: int, j: int| 0 <= i <= j < a.len() ==> a[i] <= a[j]

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn max(a: Vec<int>) -> (max: int)

-    requires a != null;

-    ensures forall|j: int| j >= 0 and j < a.len() ==> max >= a[j];

-            a.len() > 0 ==> exists|j: int| j >= 0 and j < a.len() and max == a[j];

+pub fn max(a: &[int]) -> (max: int)

+    requires(a.len() > 0)

+    ensures(|max: int| forall|j: usize| j < a.len() ==> max >= a[j])

+    ensures(|max: int| exists|j: usize| j < a.len() && max == a[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_spec_task_1.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn sum_array(a: Vec<int>) -> (sum: int)

-    requires a != null;

-    ensures sum == sumTo(a, a.len());

+spec fn sumTo(a: &[int], n: int) -> int

+    requires 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else { sumTo(a, n-1) + a[n-1] }

 }

 

+

+pub fn sum_array(a: &[int]) -> (sum: int)

+    ensures(sum == sumTo(a, a.len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TriangleNumber(N: int) -> (t: int)

-    requires N >= 0

-    ensures t == N * (N + 1) / 2

+pub fn triangle_number(n: int) -> (t: int)

+    requires(n >= 0)

+    ensures(t == n * (n + 1) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arrayUpToN(n: int) -> (a: Vec<int>)

-    requires n >= 0

-    ensures a.len() == n,

-            forall|j: int| 0 < j < n ==> a[j] >= 0,

-            forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]

+pub fn arrayUpToN(n: int) -> (a: Vec<int>)

+    requires(n >= 0)

+    ensures(a.len() == n)

+    ensures(forall|j: int| 0 < j < n ==> a[j] >= 0)

+    ensures(forall|j: int, k: int| 0 <= j <= k < n ==> a[j] <= a[k])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_1.rs
@@ -1,56 +1,51 @@
+pub fn Main() {

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Sorted(q: Seq<int>) -> bool {

+pub open spec fn Sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

-spec fn HasAddends(q: Seq<int>, x: int) -> bool {

-    exists|i: int, j: int| 0 <= i < j < q.len() and q[i] + q[j] == x

-}

-spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat)

-	requires IsValidIndex(q, i) && IsValidIndex(q, j) -> bool {

-    q[i] + q[j] == x

-}

-spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat)

-	requires AreOreredIndices(q, i, j) -> bool {

-    HasAddends(q[i..(j + 1)], x)

-}

-spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

-    AreOreredIndices(q, i, j) and

-	HasAddendsInIndicesRange(q, x, i, j) and

-	AreAddendsIndices(q, sum, i, j)

+

+pub open spec fn HasAddends(q: Seq<int>, x: int) -> bool {

+    exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x

 }

 

-fn Main()

+pub fn FindAddends(q: Seq<int>, x: int) -> (i: nat, j: nat)

+    requires(Sorted(q) && HasAddends(q, x))

+    ensures(|result: (nat, nat)| result.0 < result.1 < q.len() && q[result.0] + q[result.1] == x)

 {

 }

 

-

-

-

-predicate Sorted(q: Seq<int>, j: : 0 <= i <= j < |q| ==> q[i] <= q[j] 

+pub open spec fn IsValidIndex<T>(q: Seq<T>, i: nat) -> bool {

+    0 <= i < q.len()

 }

 

-

-

-

-predicate HasAddends(q: seq<int>, x: int)

-{

-	exists i, j: : 0 <= i < j < |q| && q[i] + q[j] == x

+pub open spec fn AreOreredIndices<T>(q: Seq<T>, i: nat, j: nat) -> bool {

+    0 <= i < j < q.len()

 }

 

-

-

-

-method FindAddends(q: seq<int>, x: int) -> i: nat, j: nat

-    requires Sorted(q) and HasAddends(q, x)

-    ensures i < j < q.len() and q[i]+q[j] == x

+pub open spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+    requires(IsValidIndex(q, i) && IsValidIndex(q, j))

 {

+    q[i] + q[j] == x

 }

 

+pub open spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+    requires(AreOreredIndices(q, i, j))

+{

+    HasAddends(q.subrange(i, j + 1), x)

+}

+

+pub open spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

+    AreOreredIndices(q, i, j) &&

+    HasAddendsInIndicesRange(q, x, i, j) &&

+    AreAddendsIndices(q, sum, i, j)

+}

+

+pub proof fn LoopInvWhenSumIsBigger(q: Seq<int>, x: int, i: nat, j: nat, sum: int)

+    requires(HasAddends(q, x))

+    requires(Sorted(q))

+    requires(sum > x)

+    requires(LoopInv(q, x, i, j, sum))

+    ensures(HasAddendsInIndicesRange(q, x, i, j - 1))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_spec_task_2.rs
@@ -1,35 +1,62 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Sorted(q: Seq<int>) -> bool {

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

-spec fn HasAddends(q: Seq<int>, x: int) -> bool {

-    exists|i: int, j: int| 0 <= i < j < q.len() and q[i] + q[j] == x

-}

-spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat)

-	requires IsValidIndex(q, i) && IsValidIndex(q, j) -> bool {

-    q[i] + q[j] == x

-}

-spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat)

-	requires AreOreredIndices(q, i, j) -> bool {

-    HasAddends(q[i..(j + 1)], x)

-}

-spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

-    AreOreredIndices(q, i, j) and

-	HasAddendsInIndicesRange(q, x, i, j) and

-	AreAddendsIndices(q, sum, i, j)

+

+spec fn has_addends(q: Seq<int>, x: int) -> bool {

+    exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x

 }

 

-fn FindAddends(q: Seq<int>, x: int) -> i: nat, j: nat

-    requires Sorted(q) and HasAddends(q, x)

-    ensures i < j < q.len() and q[i]+q[j] == x

+pub fn find_addends(q: Seq<int>, x: int) -> (i: usize, j: usize)

+    requires 

+        sorted(q) && has_addends(q, x)

+    ensures 

+        i < j < q.len() && q[i as int] + q[j as int] == x

 {

+    unimplemented!()

+}

+

+spec fn is_valid_index<T>(q: Seq<T>, i: usize) -> bool {

+    0 <= i < q.len()

+}

+

+spec fn are_ordered_indices<T>(q: Seq<T>, i: usize, j: usize) -> bool {

+    0 <= i < j < q.len()

+}

+

+spec fn are_addends_indices(q: Seq<int>, x: int, i: usize, j: usize) -> bool

+    recommends 

+        is_valid_index(q, i) && is_valid_index(q, j)

+{

+    q[i as int] + q[j as int] == x

+}

+

+spec fn has_addends_in_indices_range(q: Seq<int>, x: int, i: usize, j: usize) -> bool

+    recommends 

+        are_ordered_indices(q, i, j)

+{

+    has_addends(q.subrange(i as int, (j + 1) as int), x)

+}

+

+spec fn loop_inv(q: Seq<int>, x: int, i: usize, j: usize, sum: int) -> bool {

+    are_ordered_indices(q, i, j) &&

+    has_addends_in_indices_range(q, x, i, j) &&

+    are_addends_indices(q, sum, i, j)

+}

+

+proof fn loop_inv_when_sum_is_bigger(q: Seq<int>, x: int, i: usize, j: usize, sum: int)

+    requires 

+        has_addends(q, x),

+        sorted(q),

+        sum > x,

+        loop_inv(q, x, i, j, sum)

+    ensures 

+        has_addends_in_indices_range(q, x, i, j - 1)

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_1.rs
@@ -1,15 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn PlusOne(x: int) -> (y: int)

-    requires x >= 0

-    ensures y > 0

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn PlusOne(x: int) -> (y: int)

+    requires(x >= 0)

+    ensures(y > 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_3.rs
@@ -1,51 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method IntDiv (m: int, n: int) -> d: int, r: int

-    requires n > 0

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that d is the result, and r the

-

-

-

-

-method IntDiv (m : int, n : int) returns (d : int, r : int),

-            m == n * d + r and 0 <= r < n

+pub fn IntDiv(m: int, n: int) -> (d: int, r: int)

+    requires(n > 0)

+    ensures(|result: (int, int)| m == n * result.0 + result.1 && 0 <= result.1 && result.1 < n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_4.rs
@@ -1,67 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method ArraySum (a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len() == b.len()

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-method ArraySum (a : array<int>, b : array<int>) returns (c : array<int>),

-            c.len() == a.len() and 

-        forall i : int :: 0 <= i < c.len() ==> c[i] == a[i] + b[i]

+pub fn ArraySum(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len() && 

+        forall|i: int| 0 <= i < c.len() ==> c[i] == a[i] + b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_6.rs
@@ -1,94 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    

-

-

-

-

-

-

-

-

-method IsSorted (a: Vec<int>) -> (isSorted: bool)

-    requires and

-

-             clauses

-

-

-

-

-    

-

-

-

-

-

-

-

-

-method IsSorted (a : array<int>) returns (isSorted : bool)

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-

-

-

-

-

-

-

-

-            clauses for the method header Euclid below.  Your,

-            isSorted <==> forall j : int :: 1 <= j < a.len() ==> a[j-1] <= a[j]

+pub fn IsSorted(a: &[i32]) -> (isSorted: bool)

+    ensures

+        isSorted <==> forall|j: int| 1 <= j < a.len() ==> a[j as int - 1] <= a[j as int]

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_7.rs
@@ -1,106 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method IsPrime (m: int) -> (isPrime: bool)

-    requires and

-

-             clauses

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method IsPrime (m : int) returns (isPrime : bool),

-             m > 0

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-

-

-

-

-

-

-

-

-            clauses for the method header Euclid below.  Your,

-            isPrime <==> (m > 1 and forall j : int :: 2 <= j < m ==> m % j != 0) 

-

-            states that "isPrime is true iff m > 1 and not divisible by [2, m-1)"

+pub fn IsPrime(m: int) -> (isPrime: bool)

+    requires(m > 0)

+    ensures(isPrime <==> (m > 1 && forall|j: int| 2 <= j < m ==> m % j != 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_8.rs
@@ -1,127 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method Reverse (a: Vec<int>) -> (aRev: Vec<int>)

-    requires and

-

-             clauses

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method Reverse (a : array<int>) returns (aRev : array<int>)

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-

-

-

-

-

-

-

-

-            clauses for the method header Euclid below.  Your,

-            aRev.len() == a.len(),

-            forall i : int :: 0 <= i < a.len() ==> a[i] == aRev[aRev.len()-i-1],

-            fresh(aRev)

+pub fn Reverse(a: &[i32]) -> (aRev: Vec<i32>)

+    requires(true)

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: int| 0 <= i < a.len() ==> a[i as usize] == result[(result.len() - i - 1) as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_9.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_9.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_spec_task_9.rs
@@ -1,148 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(which swaps elements i and j in array a).

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-method NoDups (a: Vec<int>) -> (noDups: bool)

-    requires and

-

-             clauses

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-             clause allows

-

-

-             clause allows

-

-

-             forall j : int :: 0 < j < a.len() ==> a[j-1] <= a[j]

-    ensures clause(s) asserting that d is the result, and r the

-

-

-

-

-

-

-

-

-

-            clause(s) asserting that the return value has the same

-

-

-

-

-

-

-

-

-

-

-

-            clauses for the method header Euclid below.  Your,

-            clause to imply a lack of duplicates.

-

-

-

-

-

-

-

-            clause to imply a lack of duplicates.

-

-method NoDups (a : array<int>) returns (noDups : bool),

-            noDups <==> forall j : int :: 1 <= j < a.len() ==> a[j-1] != a[j]

+pub fn NoDups(a: &[int]) -> (noDups: bool)

+    requires(

+        forall|j: int| 0 < j < a.len() ==> a[j-1] <= a[j]

+    )

+    ensures(|noDups: bool|

+        noDups <==> forall|j: int| 1 <= j < a.len() ==> a[j-1] != a[j]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_spec_task_1.rs
@@ -1,16 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn A8Q1(y0: int, x: int) -> (z: int)

-    requires y0 >= 0;

+spec fn power(a: int, n: int) -> int

+    recommends 0 <= n

+{

+    unimplemented!()

+}

 

-    ensures z==power(x,y0);

+pub fn A8Q1(y0: int, x: int) -> (z: int)

+    requires y0 >= 0

+    ensures z == power(x, y0)

 {

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn simple(y: int) -> (x: int)

-    requires y==6;

-    ensures x==7;

+pub fn simple(y: int) -> (x: int)

+    requires(y == 6)

+    ensures(x == 7)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question2_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Two(x: int) -> (y: int)

+pub fn Two(x: int) -> (y: int)

     ensures y == x + 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_1.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M1(x: int, y: int) -> (r: int)

-    ensures r == x*y

+pub fn M1(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

 {

 }

 

+pub fn A1(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/cs357_tmp_tmpn4fsvwzs_lab7_question5_spec_task_2.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn A1(x: int, y: int) -> (r: int)

-    ensures r == x + y

+pub fn A1(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_spec_task_1.rs
@@ -1,14 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn binSearch(a: Vec<int>, K: int) -> (b: bool)

-    requires isSorted(a)

-    ensures b == exists i:nat :: i < a.len() and a[i] == K

+

+spec fn is_sorted(a: &[i32]) -> bool {

+    forall|i: nat| i < a.len() - 1 ==> a[i as int] <= a[(i + 1) as int]

+}

+

+

+pub fn bin_search(a: &[i32], k: i32) -> (b: bool)

+    requires(is_sorted(a))

+    ensures(b == exists|i: nat| i < a.len() && a[i as int] == k)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_spec_task_1.rs
@@ -1,14 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

-

-fn ComputeFib(n: nat) -> (f: nat)

-    ensures f == fib(n);

+spec fn fib(n: nat) -> nat

 {

+  if n == 0 { 0 }

+  else if n == 1 { 1 }

+  else { fib((n - 1) as nat) + fib((n - 2) as nat) }

 }

 

+pub fn ComputeFib(n: nat) -> (f: nat)

+    ensures(f == fib(n))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_spec_task_1.rs
@@ -1,26 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(a: Vec<int>, key: int) -> (i: int)

-    requires a != null;

-

-    ensures 0 <= i ==> (

-                       i < a.len() and 

-

-                       a[i] == key and 

-

-                       forall|k: int| 0 <= k < i ==> a[k] != key

-                      );

-

-            i < 0 ==> 

-

-           forall|k: int| 0 <= k < a.len() ==> a[k] != key;

+pub fn find(a: &[i32], key: i32) -> (i: i32)

+    requires(

+        true

+    )

+    ensures(|i: i32| 

+        (0 <= i ==> (i < a.len() && 

+                     a[i as usize] == key && 

+                     forall|k: usize| 0 <= k < i ==> a[k] != key)) &&

+        (i < 0 ==> forall|k: usize| 0 <= k < a.len() ==> a[k] != key)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_spec_task_1.rs
@@ -1,22 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn correct_pair(pair: (int, int), nums: Seq<int>, target: int) -> bool {

-    var (i, j) := pair;

-  and 0 <= i < nums.len()

-  and 0 <= j < nums.len()

-  and i != j

-  and nums[i] + nums[j] == target

+    let (i, j) = pair;

+    && 0 <= i < nums.len()

+    && 0 <= j < nums.len()

+    && i != j

+    && nums[i] + nums[j] == target

 }

 

-fn twoSum(nums: Seq<int>, target: int) -> pair: (int, int)

-    requires exists|i: int, j: int| correct_pair((i, j), nums, target)

-    ensures correct_pair(pair, nums, target)

+pub fn twoSum(nums: Seq<int>, target: int) -> (pair: (int, int))

+    requires(exists|i: int, j: int| correct_pair((i, j), nums, target))

+    ensures(correct_pair(pair, nums, target))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_1.rs
@@ -1,36 +1,32 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn palindromic(s: String, i: int, j: int)

-  requires 0 <= i <= j <= |s|

+spec fn palindromic(s: Seq<char>, i: int, j: int) -> bool

+    recommends 0 <= i <= j <= s.len()

 {

-  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))

+    j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))

 }

 

-

-

-

-

-lemma lemma_palindromic_contains(s: string, lo: int, hi: int, lo': int, hi': int)

-  requires 0 <= lo <= lo' <= hi' <= hi <= |s|

-  requires lo + hi == lo' + hi'

-  requires palindromic(s, lo, hi)

-  ensures palindromic(s, lo', hi') -> bool {

-    if lo < lo' {

-    lemma_palindromic_contains(s, lo + 1, hi - 1, lo', hi');

+proof fn lemma_palindromic_contains(s: Seq<char>, lo: int, hi: int, lo_prime: int, hi_prime: int)

+    requires 

+        0 <= lo <= lo_prime <= hi_prime <= hi <= s.len(),

+        lo + hi == lo_prime + hi_prime,

+        palindromic(s, lo, hi)

+    ensures palindromic(s, lo_prime, hi_prime)

+{

+    if lo < lo_prime {

+        lemma_palindromic_contains(s, lo + 1, hi - 1, lo_prime, hi_prime);

+    }

 }

 

-fn expand_from_center(s: String, i0: int, j0: int) -> lo: int, hi: int

-    requires 0 <= i0 <= j0 <= s.len(),

-             palindromic(s, i0, j0)

-    ensures 0 <= lo <= hi <= s.len() and palindromic(s, lo, hi),

-            forall|i: int, j  0 <= i <= j <= .len()s| and palindromic(s: int, i: int, j)

-    and i + j == i0 + j0

+pub fn expand_from_center(s: Seq<char>, i0: int, j0: int) -> (lo: int, hi: int)

+    requires 

+        0 <= i0 <= j0 <= s.len(),

+        palindromic(s, i0, j0)

+    ensures 

+        0 <= lo <= hi <= s.len() && palindromic(s, lo, hi),

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == i0 + j0 ==> j - i <= hi - lo

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_spec_task_2.rs
@@ -1,37 +1,87 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn palindromic(s: String, i: int, j: int)

-  requires 0 <= i <= j <= |s|

-{

-  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))

-}

 

 

 

 

 

-lemma lemma_palindromic_contains(s: string, lo: int, hi: int, lo': int, hi': int)

-  requires 0 <= lo <= lo' <= hi' <= hi <= |s|

-  requires lo + hi == lo' + hi'

-  requires palindromic(s, lo, hi)

-  ensures palindromic(s, lo', hi') -> bool {

-    if lo < lo' {

-    lemma_palindromic_contains(s, lo + 1, hi - 1, lo', hi');

+

+

+

+

+

+spec fn palindromic(s: &str, i: int, j: int) -> bool

+    recommends 0 <= i <= j <= s.len()

+{

+    j - i < 2 || (s[i as usize] == s[(j-1) as usize] && palindromic(s, i+1, j-1))

 }

 

-fn expand_from_center(s: String, i0: int, j0: int) -> lo: int, hi: int

-    requires 0 <= i0 <= j0 <= s.len(),

-             palindromic(s, i0, j0)

-    ensures 0 <= lo <= hi <= s.len() and palindromic(s, lo, hi),

-            forall|i: int, j  0 <= i <= j <= .len()s| and palindromic(s: int, i: int, j)

-    and i + j == i0 + j0

+

+proof fn lemma_palindromic_contains(s: &str, lo: int, hi: int, lo_: int, hi_: int)

+    requires 0 <= lo <= lo_ <= hi_ <= hi <= s.len(),

+             lo + hi == lo_ + hi_,

+             palindromic(s, lo, hi)

+    ensures palindromic(s, lo_, hi_)

 {

 }

 

+

+pub fn expand_from_center(s: &str, i0: int, j0: int) -> (lo: int, hi: int)

+    requires(0 <= i0 <= j0 <= s.len()),

+    requires(palindromic(s, i0, j0)),

+    ensures(|result| {

+        let (lo, hi) = result;

+        0 <= lo <= hi <= s.len() && palindromic(s, lo, hi)

+    }),

+    ensures(|result| {

+        let (lo, hi) = result;

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) && i + j == i0 + j0 ==> j - i <= hi - lo

+    })

+{

+}

+

+

+

+pub fn longestPalindrome(s: &str) -> (ans: String, lo: int, hi: int)

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        0 <= lo <= hi <= s.len() && ans == s.substring(lo as usize, hi as usize)

+    }),

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        palindromic(s, lo, hi)

+    }),

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo

+    })

+{

+}

+

+pub fn longestPalindrome_(s: &str) -> (ans: String, lo: int, hi: int)

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        0 <= lo <= hi <= s.len() && ans == s.substring(lo as usize, hi as usize)

+    }),

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        palindromic(s, lo, hi)

+    }),

+    ensures(|result| {

+        let (ans, lo, hi) = result;

+        forall|i: int, j: int| 0 <= i <= j <= s.len() && palindromic(s, i, j) ==> j - i <= hi - lo

+    })

+{

+}

+

+pub fn insert_bogus_chars(s: &str, bogus: char) -> (s_: String)

+    ensures(|s_| s_.len() == 2 * s.len() + 1),

+    ensures(|s_| forall|i: int| 0 <= i <= s.len() ==> s_[(i * 2) as usize] == bogus),

+    ensures(|s_| forall|i: int| 0 <= i < s.len() ==> s_[(i * 2 + 1) as usize] == s[i as usize])

+{

+}

+

+pub fn argmax(a: &[int], start: int) -> (res: (int, int))

+    requires(0 <= start < a.len()),

+    ensures(|res| start <= res.0 < a.len() && a[res.0 as usize] == res.1),

+    ensures(|res| forall|i: int| start <= i < a.len() ==> a[i as usize] <= res.1)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_ex3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_ex3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_ex3_spec_task_1.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BadSort(a: String) -> (b: String)

-    requires forall|i: int| 0<=i<a.len() ==> a[i] in

+pub fn BadSort(a: String) -> (b: String)

+    requires(

+        forall|i: int| 0 <= i < a.len() ==> a[i] in {}

+    )

+    ensures(sortedbad(b))

+    ensures(multiset(b[..]) == multiset(a[..]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p1_spec_task_1.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumArray(xs: Vec<int>) -> (s: int)

-    ensures s == Sum(xs[..])

-{

+spec fn Sum(xs: Seq<int>) -> int {

+    if xs.len() == 0 { 0 } else { Sum(xs.subrange(0, xs.len() - 1)) + xs[xs.len() - 1] }

 }

 

+pub fn SumArray(xs: &[int]) -> (s: int)

+    ensures(s == Sum(xs@))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_1.rs
@@ -1,14 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn absx(x: Vec<int>) -> (y: Vec<int>)

-    ensures y.len() == x.len(),

-            forall|i: int| 0 <= i < y.len() ==>  y[i] == abs(x[i])

+spec fn abs(x: int) -> nat {

+    if x < 0 { -x } else { x }

+}

+

+pub fn absx(x: &[i32]) -> (y: Vec<i32>)

+    ensures

+        y.len() == x.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == abs(x[i] as int),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p2_spec_task_2.rs
@@ -1,15 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn absx(x: Vec<int>) -> (y: Vec<int>)

-    ensures y.len() == x.len(),

-            forall|i: int| 0 <= i < y.len() ==>  y[i] == abs(x[i])

+spec fn abs(x: int) -> nat {

+    if x < 0 { -x } else { x }

+}

+

+pub fn absx(x: &[int]) -> (y: Vec<int>)

+    ensures

+        y.len() == x.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == abs(x[i]),

 {

 }

 

+pub fn main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p3_spec_task_2.rs
@@ -1,30 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn max(x: Vec<nat>) -> (y: nat) 

-

-requires x.Length > 0

-

-ensures forall j :: 0 <= j < x.Length ==> y >= x[j]

-

-ensures y in x[..]

+pub fn max(x: &[nat]) -> (y: nat)

+    requires(

+        x.len() > 0

+    )

+    ensures(|y: nat|

+        forall|j: int| 0 <= j < x.len() ==> y >= x[j] &&

+        exists|k: int| 0 <= k < x.len() && y == x[k]

+    )

 {

 }

 

-

-

-

-method Main()

-    requires x.len() > 0

-

-    ensures forall|j: int| 0 <= j < x.len() ==> y >= x[j]

-

-            y in x[..]

+pub fn main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_1.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn single(x: Vec<int>, y: Vec<int>) -> (b: Vec<int>)

-    requires x.len() > 0,

-             y.len() > 0

-

-    ensures b[..] == x[..] + y[..]

+pub fn single(x: &[i32], y: &[i32]) -> Vec<i32>

+    requires(

+        x.len() > 0,

+        y.len() > 0,

+    )

+    ensures(|result: Vec<i32>| 

+        result@ == x@ + y@

+    )

 {

-}

-

+    todo!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p4_spec_task_2.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn single(x: Vec<int>, y: Vec<int>) -> (b: Vec<int>)

-    requires x.len() > 0,

-             y.len() > 0

+pub fn single(x: &[int], y: &[int]) -> (b: Vec<int>)

+    requires(x.len() > 0)

+    requires(y.len() > 0)

+    ensures(b@ == x@ + y@)

+{

+}

 

-    ensures b[..] == x[..] + y[..]

+pub fn main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-duck_tmp_tmplawbgxjo_p6_spec_task_1.rs
@@ -1,14 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn FilterVowelsArray(xs: Vec<char>) -> (ys: Vec<char>)

-    ensures fresh(ys),

-            FilterVowels(xs[..]) == ys[..]

+const vowels: Set<char> = set!['a', 'e', 'i', 'o', 'u'];

+

+spec fn FilterVowels(xs: Seq<char>) -> Seq<char>

+{

+    if xs.len() == 0 {

+        seq![]

+    } else if vowels.contains(xs[xs.len() as int - 1]) {

+        FilterVowels(xs.subrange(0, xs.len() as int - 1)).add(seq![xs[xs.len() as int - 1]])

+    } else {

+        FilterVowels(xs.subrange(0, xs.len() as int - 1))

+    }

+}

+

+pub fn FilterVowelsArray(xs: &[char]) -> (ys: Vec<char>)

+    ensures(FilterVowels(xs@) == ys@)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_appendArray_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_appendArray_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_appendArray_spec_task_1.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn appendArray(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    ensures c.len() == a.len() + b.len(),

-            forall|i: int| 0 <= i < a.len() ==> a[i] == c[i],

-            forall|i: int| 0 <= i < b.len() ==> b[i] == c[a.len() + i]

+pub fn appendArray(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(true)

+    ensures(|c: Vec<i32>| c.len() == a.len() + b.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> a[i] == c[i])

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i < b.len() ==> b[i] == c[a.len() + i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_1.rs
@@ -1,14 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn verifyNeg(a: &[i32], idx: usize) -> nat

+    requires 0 <= idx <= a.len()

+    decreases idx

+{

+    if idx == 0 { 0 }

+    else { verifyNeg(a, idx - 1) + (if a[idx - 1] < 0 { 1 } else { 0 }) }

+}

 

-verus! {

 

-fn CountNeg(a: Vec<int>) -> (cnt: nat)

+pub fn CountNeg(a: &[i32]) -> (cnt: nat)

     ensures cnt == verifyNeg(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_countNeg_spec_task_2.rs
@@ -1,14 +1,18 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountNeg(a: Vec<int>) -> (cnt: nat)

-    ensures cnt == verifyNeg(a, a.len())

+spec fn verifyNeg(a: &[int], idx: int) -> nat

+    recommends 0 <= idx <= a.len()

 {

+    if idx == 0 { 0 }

+    else { verifyNeg(a, idx - 1) + if a[idx as usize - 1] < 0 { 1 } else { 0 } }

 }

 

+pub fn CountNeg(a: &[int]) -> (cnt: usize)

+    ensures cnt == verifyNeg(a, a.len() as int)

+{

+    unimplemented!()

+}

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Filter(a: Seq<char>, b: set<char>) -> (c: set<char>)

-    ensures forall|x: int| x in a and x in b <==> x in c

+pub fn Filter(a: Seq<char>, b: Set<char>) -> (c: Set<char>)

+    ensures(forall|x: char| a.contains(x) && b.contains(x) <==> c.contains(x))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_filter_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Filter(a: Seq<char>, b: set<char>) -> (c: set<char>)

-    ensures forall|x: int| x in a and x in b <==> x in c

+pub fn filter(a: Seq<char>, b: Set<char>) -> (c: Set<char>)

+    ensures(forall|x: char| a.contains(x) && b.contains(x) <==> c.contains(x))

 {

 }

 

+pub fn tester_filter()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firstE(a: Vec<char>) -> (x: int)

-    ensures if 'e' in a[..] then 0 <= x < a.len() and a[x] == 'e' and forall|i | 0 <= i < x: int| a[i] != 'e' else x == -1

+pub fn firstE(a: &[char]) -> (x: i32)

+    ensures(if a@.contains('e') then 0 <= x < a.len() && a[x as usize] == 'e' && forall|i: usize| 0 <= i < x ==> a[i] != 'e' else x == -1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_firstE_spec_task_2.rs
@@ -1,14 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn firstE(a: Vec<char>) -> (x: int)

-    ensures if 'e' in a[..] then 0 <= x < a.len() and a[x] == 'e' and forall|i | 0 <= i < x: int| a[i] != 'e' else x == -1

+pub fn firstE(a: &[char]) -> (x: i32)

+    ensures(

+        if a.contains(&'e') {

+            0 <= x < a.len() && a[x as usize] == 'e' && forall|i: usize| 0 <= i < x ==> a[i] != 'e'

+        } else {

+            x == -1

+        }

+    )

 {

 }

 

+pub fn Main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxArray(a: Vec<int>) -> (max: int)

-    requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= max,

-            exists|i: int| 0 <= i < a.len() and a[i] == max

+pub fn max_array(a: &[i32]) -> (max: i32)

+    requires(

+        a.len() > 0

+    )

+    ensures(|max: i32|

+        forall|i: usize| 0 <= i < a.len() ==> a[i] <= max &&

+        exists|i: usize| 0 <= i < a.len() && a[i] == max

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_maxArray_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxArray(a: Vec<int>) -> (max: int)

-    requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> a[i] <= max,

-            exists|i: int| 0 <= i < a.len() and a[i] == max

+pub fn max_array(a: &[i32]) -> (max: i32)

+    requires(a.len() > 0)

+    ensures(forall|i: usize| 0 <= i < a.len() ==> a[i] <= max)

+    ensures(exists|i: usize| 0 <= i < a.len() && a[i] == max)

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac1_ex1_spec_task_1.rs
@@ -1,25 +1,20 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn acheck(a: Vec<int>, n: int)

-reads a

-requires n >= 1

+

+spec fn acheck(a: &[int], n: int) -> bool

+    recommends n >= 1

 {

-	a.Length % 2 == 0 && 

-	forall i :: 0 <= i < a.Length ==> 

-		if i % n == 0 then a[i] == 0 else a[i] != 0

+    a.len() % 2 == 0 && 

+    forall|i: int| 0 <= i < a.len() ==> 

+        if i % n == 0 { a[i as usize] == 0 } else { a[i as usize] != 0 }

 }

 

 

 

-

-method Main() -> bool {

-    

+pub fn Main()

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_1.rs
@@ -1,16 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn GetTriple(a: Vec<int>) -> (index: int)

-    ensures 0 <= index < a.len() - 2 or index == a.len(),

-            index == a.len() <==> !triple(a),

-            0 <= index < a.len() - 2 <==> triple(a),

-            0 <= index < a.len() - 2 ==> a[index] == a[index + 1] == a[index + 2]

+

+spec fn triple(a: &[int]) -> bool {

+    exists|i: int| 0 <= i < a.len() - 2 && a[i] == a[i + 1] && a[i + 1] == a[i + 2]

+}

+

+

+

+pub fn GetTriple(a: &[int]) -> (index: int)

+    ensures

+        0 <= index < a.len() - 2 || index == a.len(),

+    ensures

+        index == a.len() <==> !triple(a),

+    ensures

+        0 <= index < a.len() - 2 <==> triple(a),

+    ensures

+        0 <= index < a.len() - 2 ==> a[index] == a[index + 1] && a[index + 1] == a[index + 2],

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_prac4_ex2_spec_task_2.rs
@@ -1,21 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn triple(a: Vec<int>) -> bool {

-    

+

+spec fn triple(a: &[int]) -> bool {

+    exists|i: int| 0 <= i < a.len() - 2 && a[i] == a[i + 1] && a[i + 1] == a[i + 2]

 }

 

-fn GetTriple(a: Vec<int>) -> (index: int)

-    ensures 0 <= index < a.len() - 2 or index == a.len(),

-            index == a.len() <==> !triple(a),

-            0 <= index < a.len() - 2 <==> triple(a),

-            0 <= index < a.len() - 2 ==> a[index] == a[index + 1] == a[index + 2]

+

+pub fn GetTriple(a: &[int]) -> (index: usize)

+    ensures

+        0 <= index < a.len() - 2 || index == a.len(),

+    ensures

+        index == a.len() <==> !triple(a),

+    ensures

+        0 <= index < a.len() - 2 <==> triple(a),

+    ensures

+        0 <= index < a.len() - 2 ==> a[index as int] == a[index as int + 1] && a[index as int + 1] == a[index as int + 2],

 {

 }

 

+

+pub fn TesterGetTriple() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_1.rs
@@ -1,17 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a == old(a),

-            b.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> b[i] == a[a.len() - i - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| result.len() == a.len())

+    ensures(|result: Vec<char>| forall|i: usize| 0 <= i < a.len() ==> result[i] == a[a.len() - i - 1])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercise_tmp_tmpouftptir_reverse_spec_task_2.rs
@@ -1,17 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Reverse(a: Vec<char>) -> (b: Vec<char>)

-    requires a.len() > 0

-    ensures a == old(a),

-            b.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> b[i] == a[a.len() - i - 1]

+pub fn reverse(a: &[char]) -> Vec<char>

+    requires(a.len() > 0)

+    ensures(|result: Vec<char>| result.len() == a.len())

+    ensures(|result: Vec<char>| forall|i: usize| 0 <= i < a.len() ==> result[i] == a[a.len() - i - 1])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_1.rs
@@ -1,25 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(nums: Vec<int>) -> num_length: int)

-  modifies nums

-  requires forall i, j | 0 <= i < j < nums.Length: : nums[i] <= nums[j]

-  ensures nums.Length == old(nums).Length

-  ensures 0 <= num_length <= nums.Length

-  ensures forall i, j | 0 <= i < j < num_length: : nums[i] != nums[j]

-  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..]

-    requires forall|i: int, j | 0 <= i < j < nums.len(): int| nums[i] <= nums[j]

-    ensures nums.len() == old(nums).len(),

-            0 <= num_length <= nums.len(),

-            forall|i: int, j | 0 <= i < j < num_length: int| nums[i] != nums[j],

-            forall|i | 0 <= i < num_length: int| nums[i] in old(nums[..]),

-            forall|i | 0 <= i < nums.len(): int| old(nums[i]) in nums[..num_length]

+pub fn remove_duplicates(nums: &mut [i32]) -> (num_length: usize)

+    requires forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

+    ensures 

+        nums.len() == old(nums).len(),

+        0 <= num_length <= nums.len(),

+        forall|i: int, j: int| 0 <= i < j < num_length ==> nums[i] != nums[j],

+        forall|i: int| 0 <= i < num_length ==> old(nums)[i as int] == nums[i as int],

+        forall|i: int| 0 <= i < nums.len() ==> exists|k: int| 0 <= k < num_length && old(nums)[i] == nums[k]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_2.rs
@@ -1,25 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(nums: Vec<int>) -> num_length: int)

-  modifies nums

-  requires forall i, j | 0 <= i < j < nums.Length: : nums[i] <= nums[j]

-  ensures nums.Length == old(nums).Length

-  ensures 0 <= num_length <= nums.Length

-  ensures forall i, j | 0 <= i < j < num_length: : nums[i] != nums[j]

-  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..]

-    requires forall|i: int, j | 0 <= i < j < nums.len(): int| nums[i] <= nums[j]

-    ensures nums.len() == old(nums).len(),

-            0 <= num_length <= nums.len(),

-            forall|i: int, j | 0 <= i < j < num_length: int| nums[i] != nums[j],

-            forall|i | 0 <= i < num_length: int| nums[i] in old(nums[..]),

-            forall|i | 0 <= i < nums.len(): int| old(nums[i]) in nums[..num_length]

+pub fn remove_duplicates(nums: &mut [i32]) -> (num_length: usize)

+    requires

+        forall|i: usize, j: usize| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

+    ensures

+        nums.len() == old(nums).len(),

+        0 <= num_length <= nums.len(),

+        forall|i: usize, j: usize| 0 <= i < j < num_length ==> nums[i] != nums[j],

+        forall|i: usize| 0 <= i < num_length ==> old(nums)[i as int] == nums[i],

+        forall|i: usize| 0 <= i < nums.len() ==> exists|k: usize| 0 <= k < num_length && old(nums)[i as int] == nums[k]

 {

 }

 

+pub fn testing()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_spec_task_3.rs
@@ -1,25 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(nums: Vec<int>) -> num_length: int)

-  modifies nums

-  requires forall i, j | 0 <= i < j < nums.Length: : nums[i] <= nums[j]

-  ensures nums.Length == old(nums).Length

-  ensures 0 <= num_length <= nums.Length

-  ensures forall i, j | 0 <= i < j < num_length: : nums[i] != nums[j]

-  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..]

-    requires forall|i: int, j | 0 <= i < j < nums.len(): int| nums[i] <= nums[j]

-    ensures nums.len() == old(nums).len(),

-            0 <= num_length <= nums.len(),

-            forall|i: int, j | 0 <= i < j < num_length: int| nums[i] != nums[j],

-            forall|i | 0 <= i < num_length: int| nums[i] in old(nums[..]),

-            forall|i | 0 <= i < nums.len(): int| old(nums[i]) in nums[..num_length]

+pub fn remove_duplicates(nums: &mut [i32]) -> (num_length: usize)

+    requires

+        forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] <= nums[j]

+    ensures

+        nums.len() == old(nums).len(),

+        0 <= num_length <= nums.len(),

+        forall|i: int, j: int| 0 <= i < j < num_length ==> nums[i] != nums[j],

+        forall|i: int| 0 <= i < num_length ==> old(nums).contains(nums[i]),

+        forall|i: int| 0 <= i < old(nums).len() ==> nums[..num_length].contains(old(nums)[i])

 {

 }

 

+pub fn testing() {

+}

+

+pub fn main() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_1.rs
@@ -1,15 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(N: int, a: Vec<int>) -> sum: int, max: int

-    requires 0 <= N and a.len() == N and (forall|k: int| 0 <= k and k < N ==> 0 <= a[k]);

-    ensures sum <= N * max;

+pub fn M(N: int, a: &[int]) -> (sum: int, max: int)

+    requires(

+        0 <= N && a.len() == N && (forall|k: int| 0 <= k && k < N ==> 0 <= a[k])

+    )

+    ensures(|result: (int, int)| 

+        result.0 <= N * result.1

+    )

 {

-}

-

+    unimplemented!()

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_spec_task_2.rs
@@ -1,15 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(N: int, a: Vec<int>) -> sum: int, max: int

-    requires 0 <= N and a.len() == N and (forall|k: int| 0 <= k and k < N ==> 0 <= a[k]);

-    ensures sum <= N * max;

+pub fn M(N: int, a: &[int]) -> (sum: int, max: int)

+    requires(

+        0 <= N && a.len() == N && (forall|k: int| 0 <= k && k < N ==> 0 <= a[k as usize])

+    )

+    ensures(|result: (int, int)| 

+        result.0 <= N * result.1

+    )

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_2.rs
@@ -1,14 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

 }

 

+pub fn Mul(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_3.rs
@@ -1,14 +1,21 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

 }

 

+pub fn Mul(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

+{

+}

+

+pub fn Main()

+{

+}

+

+pub fn TestAdd(x: int, y: int)

+{

+}

+

+pub fn TestMul(x: int, y: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_4.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

 }

 

+pub fn TestAdd(x: int, y: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_spec_task_5.rs
@@ -1,14 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Add(x: int, y: int) -> (r: int)

-    ensures r == x+y;

+pub fn Add(x: int, y: int) -> (r: int)

+    ensures(r == x + y)

 {

 }

 

+pub fn Mul(x: int, y: int) -> (r: int)

+    ensures(r == x * y)

+{

+}

+

+pub fn TestMul(x: int, y: int) {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_spec_task_1.rs
@@ -1,15 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxSegSum(a: Seq<int>) -> k: int, m: int

-    ensures 0 <= k <= m <= a.len(),

-            forall|p: int, q: int| 0 <= p <= q <= a.len() ==> Sum(a, p, q) <= Sum(a, k, m)

+spec fn Sum(a: Seq<int>, s: int, t: int) -> int

+    recommends 0 <= s <= t <= a.len()

 {

+    if s == t { 0 } else { Sum(a, s, t-1) + a[t-1] }

 }

 

+pub fn MaxSegSum(a: Seq<int>) -> (k: int, m: int)

+    ensures 

+        0 <= k <= m <= a.len(),

+        forall|p: int, q: int| 0 <= p <= q <= a.len() ==> Sum(a, p, q) <= Sum(a, k, m)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_spec_task_1.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFactorial(n: int) -> (u: int)

-    requires 1 <= n;

-    ensures u == Factorial(n);

-{

+spec fn factorial(n: nat) -> nat {

+    if n == 0 { 1 } else { n * factorial((n - 1) as nat) }

 }

 

+pub fn compute_factorial(n: int) -> (u: int)

+    requires 1 <= n,

+    ensures u == factorial(n as nat),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Maximum(values: Seq<int>) -> (max: int)

-    requires values != []

-    ensures max in values,

-            forall|i  0 <= i < .len()values|: int| values[i] <= max

+pub fn Maximum(values: Seq<int>) -> (max: int)

+    requires(values != Seq::<int>::empty())

+    ensures(values.contains(max))

+    ensures(forall|i: int| 0 <= i < values.len() ==> values[i] <= max)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures 0 <= y,

-            x < 0 ==> y == -x,

-            x >= 0 ==> y == x

+pub fn abs(x: i32) -> (y: i32)

+    ensures(0 <= y)

+    ensures(x < 0 ==> y == -x)

+    ensures(x >= 0 ==> y == x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_2.rs
@@ -1,16 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures 0 <= y,

-            x < 0 ==> y == -x,

-            x >= 0 ==> y == x

+pub fn Abs(x: int) -> (y: int)

+    ensures(0 <= y)

+    ensures(x < 0 ==> y == -x)

+    ensures(x >= 0 ==> y == x)

 {

 }

 

+pub fn TestingAbs()

+{

+}

+

+pub fn TestingAbs()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_3.rs
@@ -1,16 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures 0 <= y,

-            x < 0 ==> y == -x,

-            x >= 0 ==> y == x

+pub fn Abs(x: int) -> (y: int)

+    ensures(0 <= y)

+    ensures(x < 0 ==> y == -x)

+    ensures(x >= 0 ==> y == x)

 {

 }

 

-}
+

+

+pub fn TestingAbs2()

+{

+}

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_4.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a,

-            c >= b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a)

+    ensures(c >= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_assertions_spec_task_5.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a,

-            c >= b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a)

+    ensures(c >= b)

 {

 }

 

+pub fn TestingMax() {

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_3.rs
@@ -1,14 +1,33 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn abs(x: int) -> int

+{

+    if x < 0 { -x } else { x }

+}

 

-verus! {

 

-fn Abs(x: int) -> (y: int)

-    ensures abs(x) == y

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+pub fn Abs(x: int) -> (y: int)

+    ensures(abs(x) == y)

 {

 }

 

-}
+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-learn_tmp_tmpn94ir40q_R01_functions_spec_task_4.rs
@@ -1,14 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-fn TestDouble(val: int) -> (val2: int)

+

+pub open spec fn Double(val: int) -> int {

+    2 * val

+}

+

+

+

+pub fn TestDouble(val: int) -> (val2: int)

     ensures val2 == Double(val)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_expt_spec_task_1.rs
@@ -1,14 +1,20 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Expt(b: int, n: nat) -> int

+    requires n >= 0

+{

+    if n == 0 { 1 } else { b * Expt(b, n - 1) }

+}

 

-verus! {

 

-fn expt(b: int, n: nat) -> (res: int)

-    ensures res == Expt(b, n)

+pub fn expt(b: int, n: nat) -> (res: int)

+    ensures(res == Expt(b, n))

 {

 }

 

+

+

+  ensures Expt(x, a) * Expt(x, b) == Expt(x, a + b)

+pub fn distributive(x: int, a: nat, b: nat)

+    ensures(Expt(x, a) * Expt(x, b) == Expt(x, a + b))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_factorial_spec_task_1.rs
@@ -1,14 +1,10 @@
+spec fn fact(n: nat) -> nat

+    ensures |result: nat| result >= 1

+{

+    if n == 0 { 1 } else { n * fact((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn factorial(n: nat) -> (res: nat)

+pub fn factorial(n: nat) -> (res: nat)

     ensures res == fact(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_1.rs
@@ -1,15 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures a >= b ==> c == a,

-            b >= a ==> c == b

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(a >= b ==> c == a),

+    ensures(b >= a ==> c == b),

 {

 }

 

-}
+

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(a >= b ==> c == a),

+    ensures(b >= a ==> c == b),

+{

+}

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-programs_tmp_tmpcwodh6qh_src_max_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures a >= b ==> c == a,

-            b >= a ==> c == b

+pub fn max(a: i32, b: i32) -> (c: i32)

+    ensures(a >= b ==> c == a)

+    ensures(b >= a ==> c == b)

 {

 }

 

+pub fn max_test()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_101_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_101_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_101_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn KthElement(arr: Vec<int>, k: int) -> (result: int)

-    requires 1 <= k <= arr.len()

-    ensures result == arr[k - 1]

+pub fn kth_element(arr: &[i32], k: i32) -> (result: i32)

+    requires(1 <= k <= arr.len())

+    ensures(result == arr[(k - 1) as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_105_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_105_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_105_spec_task_1.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountTrue(a: Vec<bool>) -> (result: int)

-    requires a != null

-    ensures result == countTo(a, a.len())

+spec fn countTo(a: &[bool], n: int) -> int

+    recommends 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else { countTo(a, n-1) + (if a[n-1] { 1 } else { 0 }) }

 }

 

+

+pub fn CountTrue(a: &[bool]) -> (result: int)

+    ensures(result == countTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_106_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_106_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_106_spec_task_1.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AppendArrayToSeq(s: Seq<int>, a: Vec<int>) -> (r: Seq<int>)

-    requires a != null

-    ensures r.len() == s.len() + a.len(),

-            forall|i: int| 0 <= i < s.len() ==> r[i] == s[i],

-            forall|i: int| 0 <= i < a.len() ==> r[s.len() + i] == a[i]

+pub fn append_array_to_seq(s: Seq<int>, a: &[int]) -> (r: Seq<int>)

+    requires(

+        true

+    )

+    ensures(|result: Seq<int>| {

+        &&& result.len() == s.len() + a.len()

+        &&& forall|i: int| 0 <= i < s.len() ==> result[i] == s[i]

+        &&& forall|i: int| 0 <= i < a.len() ==> result[s.len() + i] == a[i]

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_113_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_113_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_113_spec_task_1.rs
@@ -1,18 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool

+{

     48 <= c as int <= 57

 }

 

-fn IsInteger(s: String) -> (result: bool)

-    ensures result <==> (s.len() > 0) and (forall|i: int| 0 <= i < s.len() ==> IsDigit(s[i]))

+

+

+pub fn is_integer(s: &str) -> (result: bool)

+    ensures

+        result <==> (s.len() > 0) && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_126_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_126_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_126_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfCommonDivisors(a: int, b: int) -> (sum: int)

-    requires a > 0 and b > 0

-    ensures sum >= 0,

-            forall|d: int| 1 <= d <= a and 1 <= d <= b and a % d == 0 and b % d == 0 ==> sum >= d

+pub fn SumOfCommonDivisors(a: int, b: int) -> (sum: int)

+    requires(a > 0 && b > 0)

+    ensures(sum >= 0)

+    ensures(forall|d: int| 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_127_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_127_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_127_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Multiply(a: int, b: int) -> (result: int)

-    ensures result == a * b

+pub fn multiply(a: int, b: int) -> (result: int)

+    ensures(result == a * b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_133_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_133_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_133_spec_task_1.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfNegatives(a: Vec<int>) -> (result: int)

-    ensures result == sumNegativesTo(a, a.len())

+spec fn sumNegativesTo(a: &[int], n: int) -> int

+    requires 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else if a[n-1] < 0 { sumNegativesTo(a, n-1) + a[n-1] } else { sumNegativesTo(a, n-1) }

 }

 

+

+pub fn SumOfNegatives(a: &[int]) -> (result: int)

+    ensures(result == sumNegativesTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_135_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_135_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_135_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthHexagonalNumber(n: int) -> (hexNum: int)

-    requires n >= 0

-    ensures hexNum == n * ((2 * n) - 1)

+pub fn nth_hexagonal_number(n: int) -> (hexNum: int)

+    requires(n >= 0)

+    ensures(hexNum == n * ((2 * n) - 1))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_142_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_142_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_142_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountIdenticalPositions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

-    requires a.len() == b.len() and b.len() == c.len()

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < a.len() and a[i] == b[i] and b[i] == c[i]|

+pub fn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

+    requires(a.len() == b.len() && b.len() == c.len())

+    ensures(count >= 0)

+    ensures(count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_143_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_143_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_143_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountArrays(arrays: Seq<Vec<int>>) -> (count: int)

-    ensures count >= 0,

-            count == arrays.len()

+pub fn count_arrays(arrays: Seq<&[i32]>) -> (count: i32)

+    requires()

+    ensures(count >= 0)

+    ensures(count == arrays.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_145_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_145_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_145_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() > 1

-    ensures forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] - a[j] <= diff

+pub fn max_difference(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 1)

+    ensures(forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] - a[j] <= diff)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_14_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_14_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_14_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TriangularPrismVolume(base: int, height: int, length: int) -> (volume: int)

-    requires base > 0,

-             height > 0,

-             length > 0

-    ensures volume == (base * height * length) / 2

+pub fn triangular_prism_volume(base: int, height: int, length: int) -> (volume: int)

+    requires(base > 0)

+    requires(height > 0)

+    requires(length > 0)

+    ensures(|volume: int| volume == (base * height * length) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_170_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_170_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_170_spec_task_1.rs
@@ -1,16 +1,19 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumInRange(a: Vec<int>, start: int, end: int) -> (sum: int)

-    requires a != null,

-             0 <= start and start <= end and end <= a.len()

-    ensures sum == sumTo(a, start, end)

+spec fn sumTo(a: &[int], start: int, end: int) -> int

+    recommends(

+        0 <= start && start <= end && end <= a.len()

+    )

 {

+    if start == end { 0 } else { sumTo(a, start, (end-1) as int) + a[(end-1) as int] }

 }

 

+

+pub fn SumInRange(a: &[int], start: int, end: int) -> (sum: int)

+    requires(

+        0 <= start && start <= end && end <= a.len()

+    )

+    ensures(|sum: int| 

+        sum == sumTo(a, start, end)

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_171_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_171_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_171_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PentagonPerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 5 * side

+pub fn PentagonPerimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 5 * side)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_17_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_17_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_17_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 4 * side

+pub fn square_perimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 4 * side)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_18_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_18_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_18_spec_task_1.rs
@@ -1,16 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveChars(s1: String, s2: String) -> (v: String)

-    ensures v.len() <= s1.len(),

-            forall|i: int| 0 <= i < v.len() ==> (v[i] in s1) and !(v[i] in s2),

-            forall|i: int| 0 <= i < s1.len() ==> (s1[i] in s2) or (s1[i] in v)

+pub fn remove_chars(s1: &str, s2: &str) -> (v: String)

+    requires(

+        true

+    )

+    ensures(|v: String|

+        v.len() <= s1.len() &&

+        (forall|i: usize| 0 <= i < v.len() ==> s1.contains(v.chars().nth(i).unwrap()) && !s2.contains(v.chars().nth(i).unwrap())) &&

+        (forall|i: usize| 0 <= i < s1.len() ==> s2.contains(s1.chars().nth(i).unwrap()) || v.contains(s1.chars().nth(i).unwrap()))

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_227_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_227_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_227_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinOfThree(a: int, b: int, c: int) -> (min: int)

-    ensures min <= a and min <= b and min <= c,

-            (min == a) | (min == b) .len()| (min == c)

+pub fn min_of_three(a: int, b: int, c: int) -> (min: int)

+    ensures(min <= a && min <= b && min <= c)

+    ensures((min == a) || (min == b) || (min == c))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_230_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_230_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_230_spec_task_1.rs
@@ -1,15 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceBlanksWithChar(s: String, ch: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == ' ' ==> v[i] == ch) and (s[i] != ' ' ==> v[i] == s[i])

+pub fn replace_blanks_with_char(s: &str, ch: char) -> (v: String)

+    ensures(

+        v.len() == s.len()

+    )

+    ensures(

+        forall|i: usize| 0 <= i < s.len() ==> 

+            (s.as_bytes()[i] == b' ' ==> v.as_bytes()[i] == ch as u8) && 

+            (s.as_bytes()[i] != b' ' ==> v.as_bytes()[i] == s.as_bytes()[i])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_234_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_234_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_234_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeVolume(size: int) -> (volume: int)

-    requires size > 0

-    ensures volume == size * size * size

+pub fn CubeVolume(size: int) -> (volume: int)

+    requires(size > 0)

+    ensures(volume == size * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_238_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_238_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_238_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountNonEmptySubstrings(s: String) -> (count: int)

-    ensures count >= 0,

-            count == (s.len() * (s.len() + 1)) / 2

+pub fn count_non_empty_substrings(s: &str) -> (count: i32)

+    ensures(count >= 0),

+    ensures(count == (s.len() * (s.len() + 1)) / 2),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_240_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_240_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_240_spec_task_1.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceLastElement(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

-    requires first.len() > 0

-    ensures result.len() == first.len() - 1 + second.len(),

-            forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

-            forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1]

+pub fn ReplaceLastElement(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

+    requires

+        first.len() > 0,

+    ensures

+        result.len() == first.len() - 1 + second.len(),

+        forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

+        forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_242_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_242_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_242_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountCharacters(s: String) -> (count: int)

-    ensures count >= 0,

-            count == s.len()

+pub fn count_characters(s: &str) -> (count: i32)

+    ensures(count >= 0)

+    ensures(count == s.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_251_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_251_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_251_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn InsertBeforeEach(s: Seq<String>, x: String) -> (v: Seq<String>)

-    ensures v.len() == 2 * s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[2*i] == x and v[2*i + 1] == s[i]

+pub fn insert_before_each(s: Seq<String>, x: String) -> (v: Seq<String>)

+    ensures(v.len() == 2 * s.len())

+    ensures(forall|i: int| 0 <= i < s.len() ==> v[2*i] == x && v[2*i + 1] == s[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_257_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_257_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_257_spec_task_1.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(a: int, b: int) -> (result: Seq<int>)

-    ensures result.len() == 2,

-            result[0] == b,

-            result[1] == a

+pub fn swap(a: int, b: int) -> (result: Seq<int>)

+    ensures

+        result.len() == 2,

+        result[0] == b,

+        result[1] == a,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_261_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_261_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_261_spec_task_1.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivision(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_division(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_262_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_262_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_262_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitArray(arr: Vec<int>, L: int) -> firstPart: Seq<int>, secondPart: Seq<int>

+pub fn SplitArray(arr: &[int], L: int) -> (firstPart: Seq<int>, secondPart: Seq<int>)

     requires 0 <= L <= arr.len()

-    ensures firstPart.len() == L,

-            secondPart.len() == arr.len() - L,

-            firstPart + secondPart == arr[..]

+    ensures |firstPart| == L

+    ensures |secondPart| == arr.len() - L

+    ensures firstPart + secondPart == arr@

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_264_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_264_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_264_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DogYears(humanYears: int) -> (dogYears: int)

-    requires humanYears >= 0

-    ensures dogYears == 7 * humanYears

+pub fn DogYears(humanYears: int) -> (dogYears: int)

+    requires(humanYears >= 0)

+    ensures(dogYears == 7 * humanYears)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_266_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_266_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_266_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LateralSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 4 * size * size

+pub fn LateralSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 4 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_267_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_267_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_267_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfSquaresOfFirstNOddNumbers(n: int) -> (sum: int)

-    requires n >= 0

-    ensures sum == (n * (2 * n - 1) * (2 * n + 1)) / 3

+pub fn sum_of_squares_of_first_n_odd_numbers(n: int) -> (sum: int)

+    requires(n >= 0)

+    ensures(sum == (n * (2 * n - 1) * (2 * n + 1)) / 3)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_268_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_268_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_268_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StarNumber(n: int) -> (star: int)

+pub fn star_number(n: int) -> (star: int)

     requires n >= 0

     ensures star == 6 * n * (n - 1) + 1

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_269_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_269_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_269_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AsciiValue(c: char) -> (ascii: int)

-    ensures ascii == c as int

+pub fn AsciiValue(c: char) -> (ascii: int)

+    ensures(ascii == c as int)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_273_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_273_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_273_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SubtractSequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn subtract_sequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_279_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_279_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_279_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthDecagonalNumber(n: int) -> (decagonal: int)

-    requires n >= 0

-    ensures decagonal == 4 * n * n - 3 * n

+pub fn nth_decagonal_number(n: int) -> (decagonal: int)

+    requires(n >= 0)

+    ensures(decagonal == 4 * n * n - 3 * n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_282_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_282_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_282_spec_task_1.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseSubtraction(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len()

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn element_wise_subtraction(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_284_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_284_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_284_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllElementsEqual(a: Vec<int>, n: int) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> a[i] == n,

-            !result ==> exists|i: int| 0 <= i < a.len() and a[i] != n

+pub fn all_elements_equal(a: &[i32], n: i32) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: usize| 0 <= i < a.len() ==> a[i] == n)

+    ensures(!result ==> exists|i: usize| 0 <= i < a.len() && a[i] != n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_290_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_290_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_290_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxLengthList(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

-    requires lists.len() > 0

-    ensures forall|l: int| l in lists ==> l.len() <= maxList.len(),

-            maxList in lists

+pub fn max_length_list(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

+    requires(lists.len() > 0)

+    ensures(forall|l: Seq<int>| lists.contains(l) ==> l.len() <= maxList.len())

+    ensures(lists.contains(maxList))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_292_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_292_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_292_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(a: int, b: int) -> (result: int)

-    requires b != 0

-    ensures result == a / b

+pub fn quotient(a: int, b: int) -> (result: int)

+    requires(b != 0)

+    ensures(result == a / b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_304_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_304_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_304_spec_task_1.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementAtIndexAfterRotation(l: Seq<int>, n: int, index: int) -> (element: int)

-    requires n >= 0,

-             0 <= index < l.len()

-    ensures element == l[(index - n + l.len()) % l.len()]

+pub fn element_at_index_after_rotation(l: Seq<int>, n: int, index: int) -> (element: int)

+    requires 

+        n >= 0,

+        0 <= index < l.len(),

+    ensures |element: int|

+        element == l[(index - n + l.len()) % l.len()],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_307_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_307_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_307_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DeepCopySeq(s: Seq<int>) -> (copy: Seq<int>)

-    ensures copy.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i]

+pub fn deep_copy_seq(s: Seq<int>) -> (copy: Seq<int>)

+    ensures

+        copy.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_309_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_309_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_309_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (maxValue: int)

-    ensures maxValue == a or maxValue == b,

-            maxValue >= a and maxValue >= b

+pub fn Max(a: int, b: int) -> (maxValue: int)

+    ensures(maxValue == a || maxValue == b)

+    ensures(maxValue >= a && maxValue >= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_310_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_310_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_310_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ToCharArray(s: String) -> (a: Vec<char>)

-    ensures a.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> a[i] == s[i]

+pub fn to_char_array(s: &str) -> Vec<char>

+    ensures(|result: Vec<char>| result.len() == s.len())

+    ensures(|result: Vec<char>| forall|i: usize| 0 <= i < s.len() ==> result[i] == s.chars().nth(i).unwrap())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_396_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_396_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_396_spec_task_1.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StartAndEndWithSameChar(s: String) -> (result: bool)

-    requires s.len() > 0

-    ensures result <==> s[0] == s[s.len() - 1]

+pub fn start_and_end_with_same_char(s: &str) -> (result: bool)

+    requires

+        s.len() > 0,

+    ensures

+        result <==> s@[0] == s@[s@.len() - 1],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_397_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_397_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_397_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianOfThree(a: int, b: int, c: int) -> (median: int)

-    ensures median == a | median == b .len()| median == c,

-            (median >= a and median <= b) | (median >= b and median <= a) .len() (median >= a and median <= c) .len() (median >= c and median <= a) .len() (median >= b and median <= c) .len()| (median >= c and median <= b)

+pub fn median_of_three(a: int, b: int, c: int) -> (median: int)

+    ensures(median == a || median == b || median == c)

+    ensures((median >= a && median <= b) || (median >= b && median <= a) || (median >= a && median <= c) || (median >= c && median <= a) || (median >= b && median <= c) || (median >= c && median <= b))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_399_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_399_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_399_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BitwiseXOR(a: Seq<bv32>, b: Seq<bv32>) -> (result: Seq<bv32>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i]

+pub fn BitwiseXOR(a: Seq<u32>, b: Seq<u32>) -> (result: Seq<u32>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<u32>| result.len() == a.len())

+    ensures(|result: Seq<u32>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_3_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsNonPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (exists|k: int| 2 <= k < n and n % k == 0)

+pub fn is_non_prime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (exists|k: int| 2 <= k < n && n % k == 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_401_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_401_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_401_spec_task_1.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IndexWiseAddition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

-    requires a.len() > 0 and b.len() > 0,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len(),

-            forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j]

+pub fn index_wise_addition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

+    requires(a.len() > 0 && b.len() > 0)

+    requires(a.len() == b.len())

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len())

+    ensures(result.len() == a.len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_404_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_404_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_404_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(a: int, b: int) -> (minValue: int)

-    ensures minValue == a or minValue == b,

-            minValue <= a and minValue <= b

+pub fn Min(a: int, b: int) -> (minValue: int)

+    ensures(minValue == a || minValue == b)

+    ensures(minValue <= a && minValue <= b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_406_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_406_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_406_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsOdd(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 1

+pub fn is_odd(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_412_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_412_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_412_spec_task_1.rs
@@ -1,13 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

+pub fn remove_odd_numbers(arr: &[int]) -> (even_list: Vec<int>)

+    ensures forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i]) && arr@.contains(even_list[i]),

+    ensures forall|i: int| 0 <= i < arr.len() && is_even(arr[i]) ==> even_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_414_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_414_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_414_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AnyValueExists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < seq1.len() and seq1[i] in seq2)

+pub fn AnyValueExists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < seq1.len() && seq2.contains(seq1[i])))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_424_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_424_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_424_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ExtractRearChars(l: Seq<String>) -> (r: Seq<char>)

-    requires forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]

+pub fn extract_rear_chars(l: Seq<&str>) -> (r: Seq<char>)

+    requires(

+        forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

+    )

+    ensures(|r: Seq<char>| 

+        r.len() == l.len() &&

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i].get_char(l[i].len() - 1)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_426_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_426_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_426_spec_task_1.rs
@@ -1,13 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 != 0

 }

 

+pub fn filter_odd_numbers(arr: &[i32]) -> Vec<i32>

+    ensures(

+        forall|i: int| 0 <= i < result.len() ==> is_odd(result[i] as int) && arr@.contains(result[i])

+    ),

+    ensures(

+        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> result@.contains(arr[i])

+    ),

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_431_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_431_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_431_spec_task_1.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasCommonElement(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    requires a != null and b != null

-    ensures result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() and a[i] == b[j],

-            !result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() ==> a[i] != b[j]

+pub fn HasCommonElement(a: &[i32], b: &[i32]) -> (result: bool)

+    requires(

+        true

+    )

+    ensures(|result: bool|

+        result ==> exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i as int] == b[j as int]

+    )

+    ensures(|result: bool|

+        !result ==> forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i as int] != b[j as int]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_432_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_432_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_432_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianLength(a: int, b: int) -> (median: int)

-    requires a > 0 and b > 0

-    ensures median == (a + b) / 2

+pub fn median_length(a: i32, b: i32) -> (median: i32)

+    requires(a > 0 && b > 0)

+    ensures(median == (a + b) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_433_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_433_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_433_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsGreater(n: int, a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i],

-            !result ==> exists|i: int| 0 <= i < a.len() and n <= a[i]

+pub fn is_greater(n: int, a: &[int]) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i])

+    ensures(!result ==> exists|i: int| 0 <= i < a.len() && n <= a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_435_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_435_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_435_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastDigit(n: int) -> (d: int)

+pub fn last_digit(n: int) -> (d: int)

     requires n >= 0

-    ensures 0 <= d < 10,

-            n % 10 == d

+    ensures 0 <= d < 10

+    ensures n % 10 == d

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_436_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_436_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_436_spec_task_1.rs
@@ -1,13 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsNegative(n: int) -> bool {

+spec fn is_negative(n: int) -> bool {

     n < 0

 }

 

+pub fn find_negative_numbers(arr: &[i32]) -> (negative_list: Vec<i32>)

+    ensures

+

+        forall|i: int| 0 <= i < negative_list.len() ==> is_negative(negative_list[i] as int) && arr@.contains(negative_list[i]),

+

+        forall|i: int| 0 <= i < arr.len() && is_negative(arr[i] as int) ==> negative_list@.contains(arr[i])

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_441_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_441_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_441_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 6 * size * size

+pub fn CubeSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 6 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_445_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_445_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_445_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultiplyElements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i]

+pub fn multiply_elements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_447_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_447_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_447_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeElements(a: Vec<int>) -> (cubed: Vec<int>)

-    ensures cubed.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i]

+pub fn CubeElements(a: &[i32]) -> (cubed: Vec<i32>)

+    requires(true)

+    ensures(|cubed: Vec<i32>| cubed.len() == a.len())

+    ensures(|cubed: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_452_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_452_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_452_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) and (costPrice <= sellingPrice ==> loss == 0)

+pub fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

+    requires(costPrice >= 0 && sellingPrice >= 0)

+    ensures((costPrice > sellingPrice) ==> (loss == costPrice - sellingPrice) && (costPrice <= sellingPrice) ==> (loss == 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_454_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_454_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_454_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsZ(s: String) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < s.len() and (s[i] == 'z' or s[i] == 'Z'))

+pub fn contains_z(s: &str) -> (result: bool)

+    ensures(result <==> (exists|i: usize| 0 <= i < s.len() && (s[i] == 'z' || s[i] == 'Z')))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_455_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_455_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_455_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MonthHas31Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month in

+pub fn MonthHas31Days(month: int) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> month in {1, 3, 5, 7, 8, 10, 12})

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_457_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_457_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_457_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinLengthSublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

-    requires s.len() > 0

-    ensures minSublist in s,

-            forall|sublist: int| sublist in s ==> minSublist.len() <= sublist.len()

+pub fn min_length_sublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

+    requires(s.len() > 0)

+    ensures(s.contains(minSublist))

+    ensures(forall|sublist: Seq<int>| s.contains(sublist) ==> minSublist.len() <= sublist.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_458_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_458_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_458_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RectangleArea(length: int, width: int) -> (area: int)

-    requires length > 0,

-             width > 0

-    ensures area == length * width

+pub fn rectangle_area(length: int, width: int) -> (area: int)

+    requires(length > 0)

+    requires(width > 0)

+    ensures(area == length * width)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_460_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_460_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_460_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn GetFirstElements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

-    requires forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0

-    ensures result.len() == lst.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0]

+pub fn get_first_elements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

+    requires(

+        forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0

+    )

+    ensures(|result: Seq<int>| 

+        result.len() == lst.len() &&

+        forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_461_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_461_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_461_spec_task_1.rs
@@ -1,19 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub open spec fn is_upper_case(c: char) -> bool

+{

     65 <= c as int <= 90

 }

 

-fn CountUppercase(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsUpperCase(s[i])|

+

+

+pub fn count_uppercase(s: &str) -> (count: int)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s.len()).filter(|i: int| is_upper_case(s.index(*i)))).len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_470_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_470_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_470_spec_task_1.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PairwiseAddition(a: Vec<int>) -> (result: Vec<int>)

-    requires a != null,

-             a.len() % 2 == 0

-    ensures result != null,

-            result.len() == a.len() / 2,

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

+pub fn PairwiseAddition(a: &[i32]) -> Vec<i32>

+    requires a.len() % 2 == 0

+    ensures |result: Vec<i32>| result.len() == a.len() / 2

+    ensures |result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_472_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_472_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_472_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsConsecutiveNumbers(a: Vec<int>) -> (result: bool)

-    requires a.len()>0

-    ensures result <==> (exists|i: int| 0 <= i < a.len() - 1 and a[i] + 1 == a[i + 1])

+pub fn contains_consecutive_numbers(a: &[i32]) -> (result: bool)

+    requires(a.len() > 0)

+    ensures(result <==> (exists|i: usize| 0 <= i < a.len() - 1 && a[i] + 1 == a[i + 1]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_474_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_474_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_474_spec_task_1.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceChars(s: String, oldChar: char, newChar: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == oldChar ==> v[i] == newChar) and (s[i] != oldChar ==> v[i] == s[i])

+pub fn replace_chars(s: &str, old_char: char, new_char: char) -> (v: String)

+    requires(s.len() <= usize::MAX)

+    ensures(|v: String| v.len() == s.len())

+    ensures(|v: String| forall|i: usize| 0 <= i < s.len() ==> 

+        (s.get_char(i) == old_char ==> v.get_char(i) == new_char) && 

+        (s.get_char(i) != old_char ==> v.get_char(i) == s.get_char(i)))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_476_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_476_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_476_spec_task_1.rs
@@ -1,15 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumMinMax(a: Vec<int>) -> (sum: int)

-    requires a.len() > 0

-    ensures sum == Max(a[..]) + Min(a[..])

+pub fn SumMinMax(a: &[i32]) -> i32

+    requires

+        a.len() > 0,

+    ensures |sum: i32|

+        sum == Max(a) + Min(a),

 {

 }

 

+pub fn Min(a: &[i32]) -> i32

+    requires

+        a.len() > 0,

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let minPrefix = Min(&a[..a.len()-1]);

+        if a[a.len()-1] <= minPrefix { a[a.len()-1] } else { Min(&a[..a.len()-1]) }

+    }

+}

+

+pub fn Max(a: &[i32]) -> i32

+    requires

+        a.len() > 0,

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let maxPrefix = Max(&a[..a.len()-1]);

+        if a[a.len()-1] >= maxPrefix { a[a.len()-1] } else { Max(&a[..a.len()-1]) }

+    }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_477_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_477_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_477_spec_task_1.rs
@@ -1,22 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub open spec fn is_upper_case(c: char) -> bool

+{

     65 <= c as int <= 90

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub open spec fn is_upper_lower_pair(C: char, c: char) -> bool

+{

     (C as int) == (c as int) - 32

 }

 

-fn ToLowercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

+

+pub open spec fn shift32(c: char) -> char

 {

+    ((c as int + 32) % 128) as char

 }

 

+

+pub fn to_lowercase(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if is_upper_case(s[i]) { 

+                is_upper_lower_pair(s[i], v[i]) 

+            } else { 

+                v[i] == s[i] 

+            }

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_554_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_554_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_554_spec_task_1.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 == 1

 }

 

+pub fn find_odd_numbers(arr: &[i32]) -> (odd_list: Vec<i32>)

+    ensures 

+        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i] as int) && exists|j: int| 0 <= j < arr.len() && arr[j] == odd_list[i],

+        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> exists|j: int| 0 <= j < odd_list.len() && odd_list[j] == arr[i]

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_555_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_555_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_555_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceSumCubesAndSumNumbers(n: int) -> (diff: int)

-    requires n >= 0

-    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2

+pub fn difference_sum_cubes_and_sum_numbers(n: int) -> (diff: int)

+    requires(n >= 0)

+    ensures(diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_557_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_557_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_557_spec_task_1.rs
@@ -1,28 +1,42 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub open spec fn IsLowerCase(c: char) -> bool

+{

     97 <= c as int <= 122

 }

-spec fn IsUpperCase(c: char) -> bool {

+

+

+pub open spec fn IsUpperCase(c: char) -> bool

+{

     65 <= c as int <= 90

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+

+pub open spec fn IsLowerUpperPair(c: char, C: char) -> bool

+{

     (c as int) == (C as int) + 32

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub open spec fn IsUpperLowerPair(C: char, c: char) -> bool

+{

     (C as int) == (c as int) - 32

 }

 

-fn ToggleCase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

+

+pub open spec fn ShiftMinus32(c: char) -> char

 {

+    ((c as int - 32) % 128) as char

 }

 

+

+pub open spec fn Shift32(c: char) -> char

+{

+    ((c as int + 32) % 128) as char

+}

+

+

+pub fn ToggleCase(s: &str) -> (v: String)

+    ensures(|v| == |s|)

+    ensures(forall|i: int| 0 <= i < |s| ==> if IsLowerCase(s[i]) { IsLowerUpperPair(s[i], v[i]) } else if IsUpperCase(s[i]) { IsUpperLowerPair(s[i], v[i]) } else { v[i] == s[i] })

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_565_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_565_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_565_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitStringIntoChars(s: String) -> (v: Seq<char>)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[i] == s[i]

+pub fn split_string_into_chars(s: &str) -> (v: Vec<char>)

+    ensures

+        v.len() == s.len(),

+        forall|i: usize| 0 <= i < s.len() ==> v[i] == s.chars().nth(i).unwrap(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_566_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_566_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_566_spec_task_1.rs
@@ -1,16 +1,49 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfDigits(number: nat) -> (sum: nat)

-    requires number >= 0

-    ensures sum >= 0,

-            sum == SumDigits(number)

+pub fn SumOfDigits(number: nat) -> (sum: nat)

+    requires(number >= 0)

+    ensures(sum >= 0)

+    ensures(sum == SumDigits(number))

 {

 }

 

+proof fn X(x: nat)

+    ensures(Power10(NumberOfDigits(x)) > x)

+{

+}

+

+proof fn NumberIdentity(number: nat, pmax: nat)

+    requires(pmax == Power10(NumberOfDigits(number)))

+    ensures(number == number % pmax)

+{

+}

+

+spec fn Power10(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(n > 0 ==> r % 10 == 0)

+{

+    if (n == 0) { 1 } else { 10 * Power10(n-1) }

+}

+

+spec fn SumDigits(n: nat) -> nat

+{

+    let ndigits = NumberOfDigits(n);

+    let p = Power10(ndigits-1);

+    SumDigitsRecursive(n, p)

+}

+

+spec fn SumDigitsRecursive(n: nat, p: nat) -> (r: nat)

+{

+    if n == 0 || p == 0 {

+        0

+    } else {

+        let leftMostDigit = n/p;

+        let rest = n%p;

+        leftMostDigit + SumDigitsRecursive(rest, p/10)

+    }

+}

+

+spec fn NumberOfDigits(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(r == 1 <==> 0 <= n <= 9)

+{

+    if 0 <= n <= 9 { 1 } else { 1+NumberOfDigits(n/10) }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_567_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_567_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_567_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSorted(a: Vec<int>) -> (sorted: bool)

-    requires a.len() > 0

-    ensures sorted <== forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            !sorted ==> exists|i: int, j: int| 0 <= i < j < a.len() and a[i] > a[j]

+pub fn is_sorted(a: &[i32]) -> (sorted: bool)

+    requires(a.len() > 0)

+    ensures(sorted <== forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j])

+    ensures(!sorted ==> exists|i: usize, j: usize| 0 <= i < j < a.len() && a[i] > a[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_572_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_572_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_572_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(a: Vec<int>) -> (result: Seq<int>)

-    requires a != null

-    ensures forall|x: int| x in result <==> exists|i: int| 0 <= i < a.len() and a[i] == x,

-            forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]

+pub fn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)

+    requires(true)

+    ensures(forall|x: i32| result@.contains(x) <==> exists|i: usize| 0 <= i < a.len() && a[i] == x)

+    ensures(forall|i: usize, j: usize| 0 <= i < j < result@.len() ==> result@[i] != result@[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_573_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_573_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_573_spec_task_1.rs
@@ -1,13 +1,30 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn UniqueProduct(arr: Vec<int>) -> (product: int)

-    ensures product == SetProduct((set i | 0 <= i < arr.len() :: arr[i]))

+pub fn unique_product(arr: &[int]) -> (product: int)

+    ensures

+        product == set_product(Set::new(|i: int| 0 <= i < arr.len() ==> arr[i as usize]))

+{

+}

+

+spec fn set_product(s: Set<int>) -> int

+    decreases s.len()

+{

+    if s.is_empty() {

+        1

+    } else {

+        let x = s.choose();

+        x * set_product(s.remove(x))

+    }

+}

+

+proof fn set_product_lemma(s: Set<int>, x: int)

+    requires

+        s.contains(x)

+    ensures

+        set_product(s.remove(x)) * x == set_product(s)

+    decreases s.len()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_576_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_576_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_576_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)

-    ensures true <== (exists|i: int| 0 <= i <= main.len() - sub.len() and sub == main[i..i + sub.len()])

+pub fn is_sublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)

+    ensures(true <== (exists|i: int| 0 <= i <= main.len() - sub.len() && sub == main.subrange(i, i + sub.len())))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_577_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_577_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_577_spec_task_1.rs
@@ -1,15 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub open spec fn Factorial(n: int) -> int

+    recommends n >= 0

+{

+    if n == 0 { 1 } else { n * Factorial(n-1) }

+}

 

-verus! {

 

-fn FactorialOfLastDigit(n: int) -> (fact: int)

+pub fn FactorialOfLastDigit(n: int) -> (fact: int)

     requires n >= 0

     ensures fact == Factorial(n % 10)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_578_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_578_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_578_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

-    requires s1.len() == s2.len() and s2.len() == s3.len()

-    ensures r.len() == 3 * s1.len(),

-            forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] and r[3*i + 1] == s2[i] and r[3*i + 2] == s3[i]

+pub fn interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

+    requires(s1.len() == s2.len() && s2.len() == s3.len())

+    ensures(|r: Seq<int>| r.len() == 3 * s1.len())

+    ensures(|r: Seq<int>| forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_581_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_581_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_581_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

-    requires baseEdge > 0,

-             height > 0

-    ensures area == baseEdge * baseEdge + 2 * baseEdge * height

+pub fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

+    requires(baseEdge > 0)

+    requires(height > 0)

+    ensures(|area: int| area == baseEdge * baseEdge + 2 * baseEdge * height)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_586_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_586_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_586_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitAndAppend(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0 and n < l.len()

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i + n) % l.len()]

+pub fn split_and_append(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0 && n < l.len())

+    ensures(|result: Seq<int>| result.len() == l.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < l.len() ==> result[i] == l[(i + n) % l.len()])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_587_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_587_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_587_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArrayToSeq(a: Vec<int>) -> (s: Seq<int>)

-    requires a != null

-    ensures s.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> s[i] == a[i]

+pub fn ArrayToSeq(a: &[i32]) -> (s: Vec<i32>)

+    requires(true)

+    ensures(|s| == a.len())

+    ensures(forall|i: usize| 0 <= i < a.len() ==> s[i] == a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_588_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_588_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_588_spec_task_1.rs
@@ -1,15 +1,31 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn DifferenceMinMax(a: Vec<int>) -> (diff: int)

-    requires a.len() > 0

-    ensures diff == Max(a[..]) - Min(a[..])

+pub fn difference_min_max(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 0)

+    ensures(|result: i32| result == max(a@) - min(a@))

 {

 }

 

+pub open spec fn min(a: Seq<i32>) -> i32

+    recommends(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let min_prefix = min(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] <= min_prefix { a[a.len() - 1] } else { min(a.subrange(0, a.len() - 1)) }

+    }

+}

+

+pub open spec fn max(a: Seq<i32>) -> i32

+    recommends(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let max_prefix = max(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] >= max_prefix { a[a.len() - 1] } else { max(a.subrange(0, a.len() - 1)) }

+    }

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_58_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_58_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_58_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOppositeSign(a: int, b: int) -> (result: bool)

-    ensures result <==> (a < 0 and b > 0) or (a > 0 and b < 0)

+pub fn has_opposite_sign(a: i32, b: i32) -> (result: bool)

+    ensures(result <==> (a < 0 && b > 0) || (a > 0 && b < 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_594_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_594_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_594_spec_task_1.rs
@@ -1,25 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+spec fn is_odd(n: int) -> bool

+{

     n % 2 != 0

 }

 

-fn FirstEvenOddDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() >= 2,

-             exists|i: int| 0 <= i < a.len() and IsEven(a[i]),

-             exists|i: int| 0 <= i < a.len() and IsOdd(a[i])

-    ensures exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and IsEven(a[i]) and IsOdd(a[j]) and diff == a[i] - a[j] and 

-        (forall|k: int| 0 <= k < i ==> IsOdd(a[k])) and (forall|k: int| 0 <= k < j ==> IsEven(a[k]))

+

+pub fn first_even_odd_difference(a: &[int]) -> (diff: int)

+    requires(

+        a.len() >= 2

+    )

+    requires(

+        exists|i: int| 0 <= i < a.len() && is_even(a[i as usize])

+    )

+    requires(

+        exists|i: int| 0 <= i < a.len() && is_odd(a[i as usize])

+    )

+    ensures(|diff: int|

+        exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && 

+        is_even(a[i as usize]) && is_odd(a[j as usize]) && diff == a[i as usize] - a[j as usize] && 

+        (forall|k: int| 0 <= k < i ==> is_odd(a[k as usize])) && (forall|k: int| 0 <= k < j ==> is_even(a[k as usize]))

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_598_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_598_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_598_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsArmstrong(n: int) -> (result: bool)

-    requires 100 <= n < 1000

-    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))

+pub fn IsArmstrong(n: int) -> (result: bool)

+    requires(100 <= n < 1000)

+    ensures(result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10))))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_59_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_59_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_59_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

-    requires n >= 0

-    ensures octagonalNumber == n * (3 * n - 2)

+pub fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

+    requires(n >= 0)

+    ensures(octagonalNumber == n * (3 * n - 2))

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_600_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_600_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_600_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsEven(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 0

+pub fn is_even(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_602_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_602_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_602_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstRepeatedChar(s: String) -> found: bool, c: char

-    ensures found ==> exists|i: int, j: int| 0 <= i < j < s.len() and s[i] == s[j] and s[i] == c and (forall|k: int, l: int| 0 <= k < l < j and s[k] == s[l] ==> k >= i),

-            !found ==> (forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j])

+pub fn find_first_repeated_char(s: &str) -> (found: bool, c: char)

+    ensures(found ==> exists|i: int, j: int| 0 <= i < j < s.len() && s[i] == s[j] && s[i] == c && (forall|k: int, l: int| 0 <= k < l < j && s[k] == s[l] ==> k >= i))

+    ensures(!found ==> (forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_603_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_603_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_603_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LucidNumbers(n: int) -> (lucid: Seq<int>)

-    requires n >= 0

-    ensures forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0,

-            forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n,

-            forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j]

+pub fn LucidNumbers(n: int) -> (lucid: Seq<int>)

+    requires(n >= 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n)

+    ensures(forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_605_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_605_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_605_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (forall|k: int| 2 <= k < n ==> n % k != 0)

+pub fn is_prime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (forall|k: int| 2 <= k < n >>= n % k != 0))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_610_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_610_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_610_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveElement(s: Vec<int>, k: int) -> (v: Vec<int>)

-    requires 0 <= k < s.len()

-    ensures v.len() == s.len() - 1,

-            forall|i: int| 0 <= i < k ==> v[i] == s[i],

-            forall|i: int| k <= i < v.len() ==> v[i] == s[i + 1]

+pub fn remove_element(s: &[i32], k: usize) -> Vec<i32>

+    requires(k < s.len())

+    ensures(|result: Vec<i32>| result.len() == s.len() - 1)

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < k ==> result[i] == s[i])

+    ensures(|result: Vec<i32>| forall|i: usize| k <= i < result.len() ==> result[i] == s[i + 1])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_616_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_616_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_616_spec_task_1.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseModulo(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i]

+pub fn element_wise_modulo(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires

+        a.len() == b.len(),

+        forall|i: usize| 0 <= i < b.len() ==> b[i] != 0,

+    ensures |result: Vec<i32>|

+        result.len() == a.len() &&

+        forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] % b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_618_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_618_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_618_spec_task_1.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_divide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_61_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_61_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_61_spec_task_1.rs
@@ -1,18 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn CountSubstringsWithSumOfDigitsEqualToLength(s: String) -> (count: int)

+

+pub fn count_substrings_with_sum_of_digits_equal_to_length(s: &str) -> (count: i32)

     ensures count >= 0

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_622_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_622_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_622_spec_task_1.rs
@@ -1,19 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMedian(a: Vec<int>, b: Vec<int>) -> (median: int)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             a.len() > 0,

-             forall|i: int| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1],

-             forall|i: int| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1]

-    ensures median == if (a.len() % 2 == 0) then (a[a.len() / 2 - 1] + b[0]) / 2 else a[a.len() / 2]

+pub fn find_median(a: &[i32], b: &[i32]) -> i32

+    requires(

+        a.len() == b.len() &&

+        a.len() > 0 &&

+        (forall|i: usize| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1]) &&

+        (forall|i: usize| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1])

+    )

+    ensures(|median: i32|

+        median == if a.len() % 2 == 0 { (a[a.len() / 2 - 1] + b[0]) / 2 } else { a[a.len() / 2] }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_623_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_623_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_623_spec_task_1.rs
@@ -1,16 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PowerOfListElements(l: Seq<int>, n: int) -> (result: Seq<int>)

-    requires n >= 0

-    ensures result.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> result[i] == Power(l[i], n)

+pub fn power_of_list_elements(l: Seq<int>, n: int) -> (result: Seq<int>)

+    requires(n >= 0)

+    ensures(|result| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> result[i] == power(l[i], n))

 {

 }

 

+spec fn power(base: int, exponent: int) -> int

+    recommends(exponent >= 0)

+    decreases(exponent)

+{

+    if exponent == 0 { 1 } else { base * power(base, exponent - 1) }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_624_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_624_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_624_spec_task_1.rs
@@ -1,22 +1,26 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub open spec fn is_lower_case(c: char) -> bool

+{

     97 <= c as int <= 122

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+

+pub open spec fn is_lower_upper_pair(c: char, C: char) -> bool

+{

     (c as int) == (C as int) + 32

 }

 

-fn ToUppercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]

+

+pub open spec fn shift_minus32(c: char) -> char

 {

+    ((c as int - 32) % 128) as char

 }

 

+

+pub fn to_uppercase(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if is_lower_case(s[i]) then is_lower_upper_pair(s[i], v[i]) else v[i] == s[i]

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_626_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_626_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_626_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

-    requires radius > 0

-    ensures area == radius * radius

+pub fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

+    requires(radius > 0)

+    ensures(area == radius * radius)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_627_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_627_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_627_spec_task_1.rs
@@ -1,18 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestMissingNumber(s: Seq<int>) -> (v: int)

-    requires forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],

-             forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

-    ensures 0 <= v,

-            v !in s,

-            forall|k: int| 0 <= k < v ==> k in s

+pub fn smallest_missing_number(s: &Vec<i32>) -> i32

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < s.len() ==> s[i] <= s[j]

+    )

+    requires(

+        forall|i: usize| 0 <= i < s.len() ==> s[i] >= 0

+    )

+    ensures(|v: i32|

+        0 <= v &&

+        !s.contains(v) &&

+        forall|k: i32| 0 <= k < v ==> s.contains(k)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_629_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_629_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_629_spec_task_1.rs
@@ -1,13 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

 

+

+

+pub fn find_even_numbers(arr: &[int]) -> Vec<int>

+    ensures(forall|i: int| 0 <= i < result.len() ==> is_even(result[i]) && arr@.contains(result[i]))

+    ensures(forall|i: int| 0 <= i < arr.len() && is_even(arr[i]) ==> result@.contains(arr[i]))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_62_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_62_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_62_spec_task_1.rs
@@ -1,16 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindSmallest(s: Vec<int>) -> (min: int)

-    requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> min <= s[i],

-            exists|i: int| 0 <= i < s.len() and min == s[i]

+pub fn find_smallest(s: &[i32]) -> (min: i32)

+    requires

+        s.len() > 0,

+    ensures |min: i32|

+        forall|i: usize| 0 <= i < s.len() ==> min <= s[i as int],

+    ensures |min: i32|

+        exists|i: usize| 0 <= i < s.len() && min == s[i as int],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_637_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_637_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_637_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures result <==> costPrice == sellingPrice

+pub fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

+    requires(costPrice >= 0 && sellingPrice >= 0)

+    ensures(result <==> costPrice == sellingPrice)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_641_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_641_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_641_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthNonagonalNumber(n: int) -> (number: int)

-    requires n >= 0

-    ensures number == n * (7 * n - 5) / 2

+pub fn NthNonagonalNumber(n: int) -> (number: int)

+    requires(n >= 0)

+    ensures(number == n * (7 * n - 5) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_69_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_69_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_69_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsSequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < list.len() and sub == list[i])

+pub fn contains_sequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < list.len() && sub == list[i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_70_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_70_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_70_spec_task_1.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllSequencesEqualLength(sequences: Seq<Seq<int>>) -> (result: bool)

-    ensures result <==> forall|i: int, j: int| 0 <= i < sequences.len() and 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len()

+pub fn all_sequences_equal_length(sequences: Seq<Seq<int>>) -> (result: bool)

+    ensures

+        result <==> (forall|i: int, j: int| 0 <= i < sequences.len() && 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_728_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_728_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_728_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddLists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i]

+pub fn add_lists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_732_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_732_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_732_spec_task_1.rs
@@ -1,19 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSpaceCommaDot(c: char) -> bool {

-    c == ' ' | c == ',' .len()| c == '.'

+pub open spec fn is_space_comma_dot(c: char) -> bool

+{

+    c == ' ' || c == ',' || c == '.'

 }

 

-fn ReplaceWithColon(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') and (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])

+

+

+pub fn replace_with_colon(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            (is_space_comma_dot(s[i as usize]) ==> v[i as usize] == ':') && 

+            (!is_space_comma_dot(s[i as usize]) ==> v[i as usize] == s[i as usize])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_733_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_733_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_733_spec_task_1.rs
@@ -1,18 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstOccurrence(arr: Vec<int>, target: int) -> (index: int)

-    requires arr != null,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures 0 <= index < arr.len() ==> arr[index] == target,

-            index == -1 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] != target,

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn find_first_occurrence(arr: &[i32], target: i32) -> (index: i32)

+    requires forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

+    ensures 0 <= index < arr.len() ==> arr[index] == target

+    ensures index == -1 ==> forall|i: usize| 0 <= i < arr.len() ==> arr[i] != target

+    ensures forall|i: usize| 0 <= i < arr.len() ==> arr[i] == old(arr)[i]

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_741_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_741_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_741_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllCharactersSame(s: String) -> (result: bool)

-    ensures result ==> forall|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() ==> s[i] == s[j],

-            !result ==> (s.len() > 1) and (exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] != s[j])

+pub fn all_characters_same(s: &str) -> (result: bool)

+    ensures(result ==> forall|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() ==> s.as_bytes()[i] == s.as_bytes()[j])

+    ensures(!result ==> (s.len() > 1) && (exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s.as_bytes()[i] != s.as_bytes()[j]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_743_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_743_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_743_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateRight(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i - n + l.len()) % l.len()]

+pub fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0)

+    ensures(|r| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_750_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_750_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_750_spec_task_1.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddTupleToList(l: seq<(int, int)>, t: (int, int)) -> r: seq<(int, int)>

-    ensures r.len() == l.len() + 1,

-            r[r.len() - 1] == t,

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]

+pub fn AddTupleToList(l: Seq<(int, int)>, t: (int, int)) -> (r: Seq<(int, int)>)

+    ensures

+        r.len() == l.len() + 1,

+        r[r.len() - 1] == t,

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_751_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_751_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_751_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMinHeap(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] and (2*i + 2 == a.len() or a[i] <= a[2*i + 2]),

-            !result ==> exists|i: int| 0 <= i < a.len() / 2 and (a[i] > a[2*i + 1] or (2*i + 2 != a.len() and a[i] > a[2*i + 2]))

+pub fn is_min_heap(a: &[i32]) -> bool

+    requires(true)

+    ensures(|result: bool| result ==> forall|i: usize| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.len() || a[i] <= a[2*i + 2]))

+    ensures(|result: bool| !result ==> exists|i: usize| 0 <= i < a.len() / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.len() && a[i] > a[2*i + 2])))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_755_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_755_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_755_spec_task_1.rs
@@ -1,18 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SecondSmallest(s: Vec<int>) -> (secondSmallest: int)

-    requires s.len() >= 2

-

-             exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] != s[i]

-    ensures exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] == secondSmallest,

-            forall|k: int|  0 <= k < s.len() and s[k] != min(s[..])  ==>  s[k] >= secondSmallest

+pub fn MinPair(s: Seq<int>) -> (r: int)

+    requires(s.len() == 2)

+    ensures(|r| s[0] <= s[1] <==> r == s[0])

+    ensures(|r| s[0] > s[1] ==> r == s[1])

 {

 }

 

+

+pub fn min(s: Seq<int>) -> (r: int)

+    requires(s.len() >= 2)

+    ensures(|r| forall|i: int| 0 <= i < s.len() ==> r <= s[i])

+{

+}

+

+

+pub fn SecondSmallest(s: &[int]) -> (secondSmallest: int)

+    requires(s.len() >= 2)

+    requires(exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] == min(s@) && s[j] != s[i])

+    ensures(|secondSmallest| exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] == min(s@) && s[j] == secondSmallest)

+    ensures(|secondSmallest| forall|k: usize| 0 <= k < s.len() && s[k] != min(s@) ==> s[k] >= secondSmallest)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_759_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_759_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_759_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDecimalWithTwoPrecision(s: String) -> (result: bool)

-    ensures result ==> (exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2),

-            !result ==> !(exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2)

+pub fn is_decimal_with_two_precision(s: &str) -> (result: bool)

+    ensures(result ==> (exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

+    ensures(!result ==> !(exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_760_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_760_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_760_spec_task_1.rs
@@ -1,16 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOnlyOneDistinctElement(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] == a[j],

-            !result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and a[i] != a[j]

+pub fn has_only_one_distinct_element(a: &[i32]) -> (result: bool)

+    ensures(

+        result ==> forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j]

+    )

+    ensures(

+        !result ==> exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_762_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_762_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_762_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMonthWith30Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month == 4 | month == 6 .len() month == 9 .len()| month == 11

+pub fn IsMonthWith30Days(month: int) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> month == 4 || month == 6 || month == 9 || month == 11)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_764_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_764_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_764_spec_task_1.rs
@@ -1,19 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

 spec fn IsDigit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn CountDigits(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsDigit(s[i])|

+pub fn CountDigits(s: &str) -> (count: i32)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s.len() as int).filter(|i: int| IsDigit(s[*i as usize]))).len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_769_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_769_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_769_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

-    ensures forall|x: int| x in diff <==> (x in a and x !in b),

-            forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]

+pub fn difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

+    ensures(forall|x: int| diff.contains(x) <==> (a.contains(x) && !b.contains(x))),

+    ensures(forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_770_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_770_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_770_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfFourthPowerOfOddNumbers(n: int) -> (sum: int)

-    requires n > 0

-    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15

+pub fn SumOfFourthPowerOfOddNumbers(n: int) -> (sum: int)

+    requires(n > 0)

+    ensures(sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_775_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_775_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_775_spec_task_1.rs
@@ -1,18 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(n: int) -> bool {

+pub fn is_odd(n: int) -> bool {

     n % 2 == 1

 }

 

-fn IsOddAtIndexOdd(a: Vec<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (IsOdd(i) ==> IsOdd(a[i]))

+pub fn is_odd_at_index_odd(a: &[int]) -> (result: bool)

+    ensures(result <==> (forall|i: int| 0 <= i < a.len() ==> (is_odd(i) ==> is_odd(a[i]))))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_776_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_776_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_776_spec_task_1.rs
@@ -1,19 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsVowel(c: char) -> bool {

-    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'

+pub open spec fn is_vowel(c: char) -> bool {

+    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 

+    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'

 }

 

-fn CountVowelNeighbors(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 1 <= i < s.len()-1 and IsVowel(s[i-1]) and IsVowel(s[i+1]) |

+

+pub fn count_vowel_neighbors(s: &str) -> (count: usize)

+    ensures(count >= 0)

+    ensures(count == Set::new(|i: int| 1 <= i < s.len() - 1 && is_vowel(s[i-1]) && is_vowel(s[i+1])).len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_77_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_77_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_77_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDivisibleBy11(n: int) -> (result: bool)

-    ensures result <==> n % 11 == 0

+pub fn is_divisible_by_11(n: int) -> (result: bool)

+    ensures(result <==> n % 11 == 0)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_1.rs
@@ -1,34 +1,45 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsEven(n: int) -> bool {

+spec fn IsEven(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+spec fn IsOdd(n: int) -> bool

+{

     n % 2 != 0

 }

-spec fn IsFirstEven(evenIndex: int, lst: Seq<int>) -> bool {

+

+spec fn IsFirstEven(evenIndex: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= evenIndex < lst.len(),

+        IsEven(lst[evenIndex])

+{

     forall|i: int| 0 <= i < evenIndex ==> IsOdd(lst[i])

 }

-spec fn IsFirstOdd(oddIndex: int, lst: Seq<int>) -> bool {

+

+spec fn IsFirstOdd(oddIndex: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= oddIndex < lst.len(),

+        IsOdd(lst[oddIndex])

+{

     forall|i: int| 0 <= i < oddIndex ==> IsEven(lst[i])

 }

 

-fn FirstEvenOddIndices(lst: Seq<int>) -> evenIndex: int, oddIndex: int

-    requires lst.len() >= 2,

-             exists|i: int| 0 <= i < lst.len() and IsEven(lst[i]),

-             exists|i: int| 0 <= i < lst.len() and IsOdd(lst[i])

-    ensures 0 <= evenIndex < lst.len(),

-            0 <= oddIndex < lst.len()

-

-            that it's the first, not just any,

-            IsEven(lst[evenIndex]) and IsFirstEven(evenIndex, lst),

-            IsOdd(lst[oddIndex]) and IsFirstOdd(oddIndex, lst)

+pub fn FirstEvenOddIndices(lst: Seq<int>) -> (evenIndex: int, oddIndex: int)

+    requires(

+        lst.len() >= 2,

+        exists|i: int| 0 <= i < lst.len() && IsEven(lst[i]),

+        exists|i: int| 0 <= i < lst.len() && IsOdd(lst[i])

+    )

+    ensures(|ret: (int, int)|

+        0 <= ret.0 < lst.len() &&

+        0 <= ret.1 < lst.len() &&

+        IsEven(lst[ret.0]) && IsFirstEven(ret.0, lst) &&

+        IsOdd(lst[ret.1]) && IsFirstOdd(ret.1, lst)

+    )

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_784_spec_task_2.rs
@@ -1,35 +1,51 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+spec fn is_odd(n: int) -> bool

+{

     n % 2 != 0

 }

-spec fn IsFirstEven(evenIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < evenIndex ==> IsOdd(lst[i])

-}

-spec fn IsFirstOdd(oddIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < oddIndex ==> IsEven(lst[i])

+

+

+spec fn is_first_even(even_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= even_index < lst.len(),

+        is_even(lst[even_index as int])

+{

+    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i])

 }

 

-fn FirstEvenOddIndices(lst: Seq<int>) -> evenIndex: int, oddIndex: int

-    requires lst.len() >= 2,

-             exists|i: int| 0 <= i < lst.len() and IsEven(lst[i]),

-             exists|i: int| 0 <= i < lst.len() and IsOdd(lst[i])

-    ensures 0 <= evenIndex < lst.len(),

-            0 <= oddIndex < lst.len()

 

-            that it's the first, not just any,

-            IsEven(lst[evenIndex]) and IsFirstEven(evenIndex, lst),

-            IsOdd(lst[oddIndex]) and IsFirstOdd(oddIndex, lst)

+spec fn is_first_odd(odd_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= odd_index < lst.len(),

+        is_odd(lst[odd_index as int])

+{

+    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i])

+}

+

+

+pub fn first_even_odd_indices(lst: Seq<int>) -> (even_index: int, odd_index: int)

+    requires(lst.len() >= 2)

+    requires(exists|i: int| 0 <= i < lst.len() && is_even(lst[i]))

+    requires(exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]))

+    ensures(0 <= even_index < lst.len())

+    ensures(0 <= odd_index < lst.len())

+    ensures(is_even(lst[even_index]) && is_first_even(even_index, lst))

+    ensures(is_odd(lst[odd_index]) && is_first_odd(odd_index, lst))

 {

 }

 

+

+pub fn product_even_odd(lst: Seq<int>) -> product: int

+    requires(lst.len() >= 2)

+    requires(exists|i: int| 0 <= i < lst.len() && is_even(lst[i]))

+    requires(exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]))

+    ensures(exists|i: int, j: int| 0 <= i < lst.len() && is_even(lst[i]) && is_first_even(i, lst) && 

+                           0 <= j < lst.len() && is_odd(lst[j]) && is_first_odd(j, lst) && product == lst[i] * lst[j])

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_790_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_790_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_790_spec_task_1.rs
@@ -1,18 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn IsEvenAtIndexEven(lst: Seq<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < lst.len() ==> (IsEven(i) ==> IsEven(lst[i]))

+

+pub fn is_even_at_index_even(lst: Seq<int>) -> (result: bool)

+    ensures

+        result <==> forall|i: int| 0 <= i < lst.len() ==> (is_even(i) ==> is_even(lst[i]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_792_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_792_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_792_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLists(lists: Seq<Seq<int>>) -> (count: int)

+pub fn count_lists(lists: Seq<Seq<int>>) -> (count: int)

     ensures count >= 0,

-            count == lists.len()

+    ensures count == lists.len(),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_793_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_793_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_793_spec_task_1.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastPosition(arr: Vec<int>, elem: int) -> (pos: int)

-    requires arr.len() > 0,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures pos == -1 | (0 <= pos < arr.len() and arr[pos] == elem and (pos <= arr.len() - 1 .len()| arr[pos + 1] > elem)),

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn last_position(arr: &mut [i32], elem: i32) -> (pos: i32)

+    requires(

+        arr.len() > 0,

+        forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

+    )

+    ensures(|pos: i32|

+        pos == -1 || (0 <= pos < arr.len() && arr[pos as usize] == elem && (pos <= arr.len() as i32 - 1 || arr[(pos + 1) as usize] > elem)),

+        forall|i: usize| 0 <= i < arr.len() ==> arr[i] == old(arr)[i]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_798_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_798_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_798_spec_task_1.rs
@@ -1,14 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sumTo(a: &[int], n: int) -> int

+    requires 0 <= n && n <= a.len()

+{

+    if n == 0 { 0 } else { sumTo(a, n-1) + a[n-1] }

+}

 

-verus! {

 

-fn ArraySum(a: Vec<int>) -> (result: int)

+

+pub fn ArraySum(a: &[int]) -> (result: int)

     ensures result == sumTo(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_799_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_799_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_799_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateLeftBits(n: bv32, d: int) -> (result: bv32)

-    requires 0 <= d < 32

-    ensures result == ((n << d) | (n >> (32 - d)))

+pub fn rotate_left_bits(n: u32, d: int) -> (result: u32)

+    requires(0 <= d < 32)

+    ensures(|result: u32| result == ((n << d) | (n >> (32 - d))))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_79_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_79_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_79_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsLengthOdd(s: String) -> (result: bool)

-    ensures result <==> s.len() % 2 == 1

+pub fn is_length_odd(s: &str) -> (result: bool)

+    ensures(result <==> s.len() % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_801_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_801_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_801_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountEqualNumbers(a: int, b: int, c: int) -> (count: int)

-    ensures count >= 0 and count <= 3,

-            (count == 3) <==> (a == b and b == c),

-            (count == 2) <==> ((a == b and b != c) | (a != b and b == c) .len()| (a == c and b != c)),

-            (count == 1) <==> (a != b and b != c and a != c)

+pub fn count_equal_numbers(a: int, b: int, c: int) -> (count: int)

+    ensures(count >= 0 && count <= 3)

+    ensures((count == 3) <==> (a == b && b == c))

+    ensures((count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c)))

+    ensures((count == 1) <==> (a != b && b != c && a != c))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_803_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_803_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_803_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPerfectSquare(n: int) -> (result: bool)

-    requires n >= 0

-    ensures result == true ==> (exists i: int :: 0 <= i <= n and i * i == n),

-            result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)

+pub fn is_perfect_square(n: int) -> (result: bool)

+    requires(n >= 0)

+    ensures(result == true ==> (exists|i: int| 0 <= i <= n && i * i == n))

+    ensures(result == false ==> (forall|a: int| 0 < a*a < n ==> a*a != n))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_804_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_804_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_804_spec_task_1.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+pub open spec fn IsEven(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn IsProductEven(a: Vec<int>) -> (result: bool)

-    ensures result <==> exists|i: int| 0 <= i < a.len() and IsEven(a[i])

+

+pub fn IsProductEven(a: &[int]) -> (result: bool)

+    ensures(result <==> exists|i: int| 0 <= i < a.len() && IsEven(a[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_807_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_807_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_807_spec_task_1.rs
@@ -1,20 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(x: int) -> bool {

+spec fn IsOdd(x: int) -> bool

+{

     x % 2 != 0

 }

 

-fn FindFirstOdd(a: Vec<int>) -> found: bool, index: int

-    requires a != null

-    ensures !found ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i]),

-            found ==> 0 <= index < a.len() and IsOdd(a[index]) and forall|i: int| 0 <= i < index ==> !IsOdd(a[i])

+

+pub fn FindFirstOdd(a: &[int]) -> (found: bool, index: int)

+    requires(true)

+    ensures(|result: (bool, int)| {

+        let (found, index) = result;

+        (!found ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i as usize])) &&

+        (found ==> 0 <= index < a.len() && IsOdd(a[index as usize]) && forall|i: int| 0 <= i < index ==> !IsOdd(a[i as usize]))

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_808_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_808_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_808_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsK(s: Seq<int>, k: int) -> (result: bool)

-    ensures result <==> k in s

+pub fn contains_k(s: Seq<int>, k: int) -> (result: bool)

+    ensures(result <==> s.contains(k))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_809_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_809_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_809_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSmaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

-    requires a.len() == b.len()

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i],

-            !result <==> exists|i: int| 0 <= i < a.len() and a[i] <= b[i]

+pub fn is_smaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

+    requires(a.len() == b.len())

+    ensures(result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i])

+    ensures(!result <==> exists|i: int| 0 <= i < a.len() && a[i] <= b[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_80_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_80_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_80_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TetrahedralNumber(n: int) -> (t: int)

-    requires n >= 0

-    ensures t == n * (n + 1) * (n + 2) / 6

+pub fn tetrahedral_number(n: int) -> (t: int)

+    requires(n >= 0)

+    ensures(t == n * (n + 1) * (n + 2) / 6)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_86_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_86_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_86_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CenteredHexagonalNumber(n: nat) -> (result: nat)

-    requires n >= 0

-    ensures result == 3 * n * (n - 1) + 1

+pub fn centered_hexagonal_number(n: nat) -> (result: nat)

+    requires(n >= 0)

+    ensures(result == 3 * n * (n - 1) + 1)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_89_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_89_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_89_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ClosestSmaller(n: int) -> (m: int)

-    requires n > 0

-    ensures m + 1 == n

+pub fn closest_smaller(n: int) -> (m: int)

+    requires(n > 0)

+    ensures(m + 1 == n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_8_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_8_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_8_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareElements(a: Vec<int>) -> (squared: Vec<int>)

-    ensures squared.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> squared[i] == a[i] * a[i]

+pub fn square_elements(a: &[i32]) -> (squared: Vec<i32>)

+    ensures(squared.len() == a.len())

+    ensures(forall|i: usize| 0 <= i < a.len() ==> squared[i] == a[i] * a[i])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_94_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_94_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_94_spec_task_1.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinSecondValueFirst(s: Vec<Seq<int>>) -> (firstOfMinSecond: int)

-    requires s.len() > 0,

-             forall|i: int| 0 <= i < s.len() ==> s[i].len() >= 2

-    ensures exists|i: int| 0 <= i < s.len() and firstOfMinSecond == s[i][0] and 

-        (forall|j: int| 0 <= j < s.len() ==> s[i][1] <= s[j][1])

+pub fn min_second_value_first(s: &[Vec<i32>]) -> i32

+    requires

+        s.len() > 0,

+        forall|i: usize| 0 <= i < s.len() ==> s[i].len() >= 2,

+    ensures

+        |result: i32| exists|i: usize| 0 <= i < s.len() && result == s[i][0] && 

+            (forall|j: usize| 0 <= j < s.len() ==> s[i][1] <= s[j][1]),

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_95_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_95_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-synthesis_task_id_95_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestListLength(s: Seq<Seq<int>>) -> (v: int)

-    requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> v <= s[i].len(),

-            exists|i: int| 0 <= i < s.len() and v == s[i].len()

+pub fn smallest_list_length(s: Seq<Seq<int>>) -> (v: int)

+    requires(s.len() > 0)

+    ensures(forall|i: int| 0 <= i < s.len() ==> v <= s[i].len())

+    ensures(exists|i: int| 0 <= i < s.len() && v == s[i].len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c >= b and (c == a or c == b)

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(c >= a && c >= b && (c == a || c == b))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex01_spec_task_2.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (c: int)

-    ensures c >= a and c >= b and (c == a or c == b)

+pub fn max(a: int, b: int) -> (c: int)

+    ensures(c >= a && c >= b && (c == a || c == b))

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    requires x < 0

-    ensures 0 < y,

-            y == -x

+pub fn Abs(x: int) -> (y: int)

+    requires(x < 0)

+    ensures(0 < y)

+    ensures(y == -x)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex02_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    requires x < 0

-    ensures 0 < y,

-            y == -x

+pub fn Abs(x: int) -> (y: int)

+    requires(x < 0)

+    ensures(0 < y)

+    ensures(y == -x)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex03_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex03_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex03_spec_task_1.rs
@@ -1,17 +1,17 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    requires x == -1

-    ensures 0 <= y,

-            0 <= x ==> y == x,

-            x < 0 ==> y == -x

+pub fn abs(x: int) -> (y: int)

+    requires(x == -1)

+    ensures(0 <= y)

+    ensures(0 <= x ==> y == x)

+    ensures(x < 0 ==> y == -x)

 {

 }

 

+

+pub fn abs(x: int) -> (y: int)

+    requires(x == -1)

+    ensures(0 <= y)

+    ensures(0 <= x ==> y == x)

+    ensures(x < 0 ==> y == -x)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_1.rs
@@ -1,14 +1,18 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat

+{

+	if n == 0 { 0 } else

+	if n == 1 { 1 } else {

+		fib((n - 1) as nat) + fib((n - 2) as nat)

+	}

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (b: nat)

-    ensures b == fib(n)

+

+

+pub fn ComputeFib(n: nat) -> (b: nat)

+	ensures(b == fib(n))

 {

 }

 

-}
+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex09_spec_task_2.rs
@@ -1,14 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn fib(n: nat) -> nat

+{

+    if n == 0 { 0 } else

+    if n == 1 { 1 } else {

+        fib((n - 1) as nat) + fib((n - 2) as nat)

+    }

+}

 

-verus! {

 

-fn ComputeFib(n: nat) -> (b: nat)

-    ensures b == fib(n)

+

+pub fn ComputeFib(n: nat) -> (b: nat)

+    ensures(b == fib(n))

 {

 }

 

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_1.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMax(a: Vec<int>) -> (max_idx: nat)

-    requires a.len() > 0

-    ensures 0 <= max_idx < a.len(),

-            forall|j: int| 0 <= j < a.len() ==> a[max_idx] >= a[j]

+pub fn find_max(a: &[i32]) -> usize

+    requires(

+        a.len() > 0

+    )

+    ensures(|max_idx: usize|

+        0 <= max_idx < a.len() &&

+        forall|j: usize| 0 <= j < a.len() ==> a[max_idx] >= a[j]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny-workout_tmp_tmp0abkw6f8_starter_ex12_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMax(a: Vec<int>) -> (max_idx: nat)

-    requires a.len() > 0

-    ensures 0 <= max_idx < a.len(),

-            forall|j: int| 0 <= j < a.len() ==> a[max_idx] >= a[j]

+pub fn find_max(a: &[i32]) -> usize

+    requires(a.len() > 0)

+    ensures(|max_idx: usize| 0 <= max_idx < a.len())

+    ensures(|max_idx: usize| forall|j: usize| 0 <= j < a.len() ==> a[max_idx] >= a[j])

 {

 }

 

+pub fn main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_spec_task_1.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TwoSum(nums: Vec<int>, target: int) -> r: (int, int)

-    ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() and 

-                       nums[r.0] + nums[r.1] == target and

-                       forall|i: int, j: int| 0 <= i < j < r.1 ==> nums[i] + nums[j] != target,

-            r.0 == -1 <==> forall|i: int, j: int| 0 <= i < j < nums.len() ==> nums[i] + nums[j] != target

+pub fn two_sum(nums: &[i32], target: i32) -> (i32, i32)

+    ensures(|r: (i32, i32)| 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.len() && 

+                                        nums[r.0 as usize] + nums[r.1 as usize] == target &&

+                                        forall|i: usize, j: usize| 0 <= i < j < r.1 ==> nums[i] + nums[j] != target)

+    ensures(|r: (i32, i32)| r.0 == -1 <==> forall|i: usize, j: usize| 0 <= i < j < nums.len() ==> nums[i] + nums[j] != target)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_spec_task_1.rs
@@ -1,18 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn sqrt(x: int, r: int) -> bool {

-    r*r <= x and (r+1)*(r+1) > x

+    r*r <= x && (r+1)*(r+1) > x

 }

 

-fn mySqrt(x: int) -> (res: int)

-    requires 0 <= x;

-    ensures sqrt(x, res);

+pub fn mySqrt(x: int) -> (res: int)

+    requires 0 <= x,

+    ensures sqrt(x, res),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_spec_task_1.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ClimbStairs(n: nat) -> (r: nat)

-    ensures r == Stairs(n)

-{

+spec fn stairs(n: nat) -> nat {

+    if n <= 1 { 1 } else { stairs(n - 2) + stairs(n - 1) }

 }

 

+pub fn climb_stairs(n: nat) -> (r: nat)

+    ensures r == stairs(n)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_3.rs
@@ -1,43 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn random(a: int, b: int) -> r: int)

-

-  ensures a <= b ==> a <= r <= b

-

-

-

-

-

-

-method swap<T>(a: array<T>, i: int, j: int)

-

-  requires 0 <= i < a.Length && 0 <= j < a.Length

-  modifies a

-  ensures a[i] == old(a[j]

-    requires a <= b,

-             a != null,

-             0 <= i < a.len() and 0 <= j < a.len()

-  modifies a

-    ensures a <= b ==> a <= r <= b

-

-

-

-

-

-

-method swap<T>(a: array<T>, i: int, j: int)

-

-            a[i] == old(a[j]),

-            a[j] == old(a[i]),

-            forall|m: int| 0 <= m < a.len() and m != i and m != j ==> a[m] == old(a[m]),

-            multiset(a[..]) == old(multiset(a[..]))

+pub fn random(a: int, b: int) -> (r: int)

+    ensures(a <= b ==> a <= r && r <= b)

 {

 }

 

+pub fn swap<T>(a: &mut Vec<T>, i: usize, j: usize)

+    requires(i < a.len() && j < a.len())

+    ensures(a[i as int] == old(a)[j as int])

+    ensures(a[j as int] == old(a)[i as int])

+    ensures(forall|m: int| 0 <= m < a.len() && m != i && m != j ==> a[m] == old(a)[m])

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

+{

+}

+

+pub fn getAllShuffledDataEntries<T>(m_dataEntries: &Vec<T>) -> (result: Vec<T>)

+    ensures(result.len() == m_dataEntries.len())

+    ensures(result@.to_multiset() == m_dataEntries@.to_multiset())

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_examples_tmp_tmp8qotd4ez_test_shuffle_spec_task_4.rs
@@ -1,52 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn random(a: int, b: int) -> r: int)

-

-  ensures a <= b ==> a <= r <= b

-

-

-

-

-

-  

-

-

-

-

-function set_of_seq<T>(s: seq<T>): set<T>

-{

-  set x: T | x in s :: x

-}

-

-

-

-  

-method getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: Seq<T>

-    requires a <= b,

-             m_workList.len() > 0

-

-    ensures a <= b ==> a <= r <= b

-

-

-

-

-

-  

-

-

-

-

-function set_of_seq<T>(s: seq<T>): set<T>,

-            set_of_seq(avoidSet) < set_of_seq(m_workList[..]) ==> e !in avoidSet

-

-            avoidSet < m_workList[..] ==> e in m_workList[..]

+pub fn random(a: int, b: int) -> (r: int)

+    ensures(a <= b ==> a <= r && r <= b)

 {

 }

 

+spec fn set_of_seq<T>(s: Seq<T>) -> Set<T>

+{

+    Set::new(|x: T| s.contains(x))

+}

+

+pub fn getRandomDataEntry<T>(m_workList: &[T], avoidSet: Seq<T>) -> (e: T)

+    requires(m_workList.len() > 0)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn Factorial(n: nat) -> nat {

+    if n == 0 { 1 } else { n * Factorial((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IterativeFactorial(n: nat) -> (result: nat)

+pub fn IterativeFactorial(n: nat) -> (result: nat)

     ensures result == Factorial(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_spec_task_1.rs
@@ -1,13 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn FibonacciIterative(n: nat) -> (f: nat)

-    ensures f == Fibonacci(n)

+spec fn fibonacci(n: nat) -> nat {

+    match n {

+        0 => 0,

+        1 => 1,

+        _ => fibonacci((n - 1) as nat) + fibonacci((n - 2) as nat),

+    }

+}

+

+pub fn fibonacci_iterative(n: nat) -> (f: nat)

+    ensures f == fibonacci(n)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp49a6ihvk_m4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp49a6ihvk_m4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp49a6ihvk_m4_spec_task_1.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Below(c: Color, d: Color) -> bool {

-    c == Red | c == d .len()| d == Blue

+enum Color {

+    Red,

+    White,

+    Blue,

 }

 

+spec fn below(c: Color, d: Color) -> bool {

+    c == Color::Red || c == d || d == Color::Blue

+}

+

+pub fn dutch_flag(a: &mut Vec<Color>)

+    requires(old(a).len() > 0)

+    ensures(forall|i: int, j: int| 0 <= i < j < a.len() ==> below(a[i], a[j]))

+    ensures(a@.to_multiset() == old(a)@.to_multiset())

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_1.rs
@@ -1,30 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Preserved(a: Vec<int>, left: nat, right: nat)

-    reads a

-    requires left <= right <= a.Length

+spec fn preserved(a_old: &[i32], a_new: &[i32], left: usize, right: usize) -> bool

+    recommends left <= right <= a_old.len() && a_old.len() == a_new.len()

 {

-    multiset(a[left..right]) == multiset(old(a[left..right]))

+    a_old.subrange(left as int, right as int).to_multiset() == a_new.subrange(left as int, right as int).to_multiset()

 }

 

-

-

-twostate predicate Sorted(a: array<int>)

-    reads a

+spec fn sorted(a_old: &[i32], a_new: &[i32]) -> bool

+    recommends a_old.len() == a_new.len()

 {

-    Ordered(a, 0, a.Length) && Preserved(a, 0, a.Length)

+    ordered(a_new, 0, a_new.len()) && preserved(a_old, a_new, 0, a_new.len())

 }

 

-

-

-method SelectionnSort(a: Vec<int>) -> bool {

-    

+pub fn selection_sort(a: &mut Vec<i32>)

+    ensures sorted(&old(a), a)

+{

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_SelectionSort_spec_task_2.rs
@@ -1,32 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Preserved(a: Vec<int>, left: nat, right: nat)

-    reads a

-    requires left <= right <= a.Length

+pub fn selection_sort(a: &mut [i32])

+    ensures(

+        sorted(a) && multiset(a@) == multiset(old(a)@)

+    )

 {

-    multiset(a[left..right]) == multiset(old(a[left..right]))

 }

 

-

-

-twostate predicate Sorted(a: array<int>)

-    reads a

-{

-    Ordered(a, 0, a.Length) && Preserved(a, 0, a.Length)

-}

-

-

-

-

-

- method SelectionSort(a: Vec<int>) -> bool {

-    

-}

-

+spec fn sorted(a: &[i32]) -> bool {

+    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_derangement_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_derangement_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_derangement_spec_task_1.rs
@@ -1,13 +1,36 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

+

+

 

 spec fn derangement(s: Seq<nat>) -> bool {

     forall|i: int| 0 <= i < s.len() ==> s[i] != i

 }

 

+

+

+

+

+spec fn multisetRange(n: nat) -> Multiset<nat> {

+    Seq::new(n, |i: int| i as nat).to_multiset()

+}

+

+

+

+

+

+pub fn test() {

+}

+

+

+

+pub fn end(links: Seq<nat>)

+    requires(links.len() > 0)

+    requires(permutation(links))

+    requires(derangement(links))

+    requires(distinct(links))

+{

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_minmax2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_minmax2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/dafny_tmp_tmp59p638nn_examples_minmax2_spec_task_1.rs
@@ -1,15 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceMinMax(a: Vec<int>) -> (diff: int)

-    requires a.len() > 0

-    ensures diff == (Max(a[..]) - Min(a[..]))

+pub fn DifferenceMinMax(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 0)

+    ensures(|diff: i32| diff == (Max(a) - Min(a)))

 {

 }

 

+pub spec fn Min(a: Seq<i32>) -> (m: i32)

+    requires(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let minPrefix = Min(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] <= minPrefix { a[a.len() - 1] } else { minPrefix }

+    }

+}

+

+pub spec fn Max(a: Seq<i32>) -> (m: i32)

+    requires(a.len() > 0)

+{

+    if a.len() == 1 { a[0] }

+    else {

+        let maxPrefix = Max(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] >= maxPrefix { a[a.len() - 1] } else { maxPrefix }

+    }

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_1.rs
@@ -1,48 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isSorted(a: Vec<real>, from: nat, to: nat)

-  requires 0 <= from <= to <= a.Length

-  reads a

+

+spec fn isSorted(a: &[f64], from: nat, to: nat) -> bool

+    recommends 0 <= from <= to <= a.len()

 {

-    forall i, j: : from <= i < j < to ==> a[i] <= a[j] 

+    forall|i: int, j: int| from <= i < j < to ==> a[i as usize] <= a[j as usize]

 }

 

 

-

-

-

-

-method selectionSort(a: array<real>)

-  modifies a

-  ensures isSorted(a, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..])) -> bool {

-    

-}

-

-fn selectionSort(a: Vec<real>, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..]))

+pub fn selectionSort(a: &mut Vec<f64>)

+    ensures isSorted(a, 0, a.len())

+    ensures a@.to_multiset() == old(a)@.to_multiset()

 {

 }

 

 

 

-

-

-

-

-

-method findMin(a: Vec<real>, from: nat, to: nat) -> (index: nat)

+pub fn findMin(a: &[f64], from: nat, to: nat) -> (index: nat)

     requires 0 <= from < to <= a.len()

-    ensures isSorted(a, 0, a.len()),

-            multiset(a[..]) == multiset(old(a[..])),

-            from <= index < to,

-            forall|k: int| from <= k < to ==> a[k] >= a[index]

+    ensures from <= index < to

+    ensures forall|k: int| from <= k < to ==> a[k as usize] >= a[index as usize]

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_2.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn findMin(a: Vec<real>, from: nat, to: nat) -> (index: nat)

-    requires 0 <= from < to <= a.len()

-    ensures from <= index < to,

-            forall|k: int| from <= k < to ==> a[k] >= a[index]

+pub fn findMin(a: &mut [f64], from: usize, to: usize) -> usize

+    requires

+        0 <= from < to <= a.len(),

+    ensures |index: usize|

+        from <= index < to &&

+        forall|k: usize| from <= k < to ==> a[k] >= a[index],

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_3.rs
@@ -1,49 +1,35 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn isSorted(a: Vec<real>, from: nat, to: nat)

-  requires 0 <= from <= to <= a.Length

-  reads a

+

+spec fn isSorted(a: &[f64], from: nat, to: nat) -> bool

+    recommends 

+        0 <= from <= to <= a.len()

 {

-    forall i, j: : from <= i < j < to ==> a[i] <= a[j] 

+    forall|i: int, j: int| from <= i < j < to ==> a[i as usize] <= a[j as usize]

 }

 

 

-

-

-

-

-method selectionSort(a: array<real>)

-  modifies a

-  ensures isSorted(a, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..])) -> bool {

-    

-}

-

-fn selectionSort(a: Vec<real>, 0, a.Length) 

-  ensures multiset(a[..]) == multiset(old(a[..]))

+pub fn selectionSort(a: &mut Vec<f64>)

+    ensures 

+        isSorted(a, 0, old(a).len()),

+        a@.to_multiset() == old(a)@.to_multiset()

 {

 }

 

 

 

-

-

-

-

-

-method findMin(a: Vec<real>, from: nat, to: nat) -> (index: nat)

-    requires 0 <= from < to <= a.len()

-    ensures isSorted(a, 0, a.len()),

-            multiset(a[..]) == multiset(old(a[..])),

-            from <= index < to,

-            forall|k: int| from <= k < to ==> a[k] >= a[index]

+pub fn findMin(a: &Vec<f64>, from: nat, to: nat) -> (index: nat)

+    requires 

+        0 <= from < to <= a.len()

+    ensures 

+        from <= index < to,

+        forall|k: int| from <= k < to ==> a[k as usize] >= a[index as usize]

 {

 }

 

+pub fn testSelectionSort() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_spec_task_4.rs
@@ -1,15 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn findMin(a: Vec<real>, from: nat, to: nat) -> (index: nat)

-    requires 0 <= from < to <= a.len()

-    ensures from <= index < to,

-            forall|k: int| from <= k < to ==> a[k] >= a[index]

+pub fn findMin(a: &mut Vec<f64>, from: usize, to: usize) -> (index: usize)

+    requires(

+        0 <= from < to <= a.len()

+    )

+    ensures(|index: usize|

+        from <= index < to &&

+        forall|k: usize| from <= k < to ==> a[k] >= a[index as int]

+    )

+{

+}

+

+pub fn testFindMin()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_1.rs
@@ -1,13 +1,3 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SqrSum(n: int) -> (s: int)

+pub fn SqrSum(n: int) -> (s: int)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_2.rs
@@ -1,13 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DivMod(a: int, b: int) -> q: int, r: int

+pub fn DivMod(a: int, b: int) -> (q: int, r: int)

 {

 }

 

+pub fn DivMod(a: int, b: int) -> (q: int, r: int)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_4.rs
@@ -1,16 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HoareTripleReqEns(i: int, k: int) -> (k': int)

-

-    requires k == i*i

-    ensures k' == (i+1)*(i+1)

+pub fn HoareTripleReqEns(i: int, k: int) -> (k': int)

+    requires(k == i*i)

+    ensures(k' == (i+1)*(i+1))

 {

 }

 

+proof fn L1(n: int)

+    requires(n >= 0)

+    ensures(SqrSumRec(n) == n*(n+1)*(2*n + 1)/6)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_7.rs
@@ -1,14 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn SqrSum1(n: int) -> (s: int)

-    requires n >= 0

-    ensures s == SqrSumRec(n)

+spec fn SqrSumRec(n: int) -> int

+    recommends n >= 0

+{

+    if n == 0 { 0 } else { n*n + SqrSumRec(n-1) }

+}

+

+pub fn SqrSum1(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == SqrSumRec(n))

+{

+}

+

+proof fn L1(n: int)

+    requires(n >= 0)

+    ensures(SqrSumRec(n) == n*(n+1)*(2*n + 1)/6)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_8.rs
@@ -1,16 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DivMod1(a: int, b: int) -> q: int, r: int

-    requires b > 0 and a >= 0

-    ensures a == b*q + r and 0 <= r < b

-

+pub fn DivMod1(a: int, b: int) -> (q: int, r: int)

+    requires(b > 0 && a >= 0)

+    ensures(|result: (int, int)| a == b*result.0 + result.1 && 0 <= result.1 < b)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_9.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_9.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_spec_task_9.rs
@@ -1,13 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SqrSum(n: int) -> (s: int)

+pub fn SqrSum(n: int) -> (s: int)

 {

 }

 

+pub fn DivMod(a: int, b: int) -> (q: int, r: int)

+{

+}

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_1.rs
@@ -1,24 +1,40 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

+spec fn isPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: Seq<char>, str: Seq<char>) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: Seq<char>, str: Seq<char>) -> (res: bool)

+    ensures

+        !res <==> isNotPrefixPred(pre, str),

+        res <==> isPrefixPred(pre, str)

 {

 }

 

-}
+

+

+

+

+

+

+

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_2.rs
@@ -1,30 +1,56 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

+spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

 {

 }

 

-}
+

+spec fn isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+spec fn isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+    ensures(res ==> isSubstringPred(sub, str))

+

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(!res <==> isNotSubstringPred(sub, str))

+{

+}

+

+

+

+

+

+

+

+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_3.rs
@@ -1,36 +1,69 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

 {

 }

 

-}
+

+spec fn isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+spec fn isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+    ensures(res ==> isSubstringPred(sub, str))

+

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(!res <==> isNotSubstringPred(sub, str))

+{

+}

+

+

+spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: String, str2: String) -> (found: bool)

+    ensures(found <==> haveCommonKSubstringPred(k, str1, str2))

+    ensures(!found <==> haveNotCommonKSubstringPred(k, str1, str2))

+{

+}

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal-verification_tmp_tmpoepcssay_strings3_spec_task_4.rs
@@ -1,36 +1,76 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn isPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() <= str.len()) and 

-	pre == str[..pre.len()]

-}

-spec fn isNotPrefixPred(pre: String, str: String) -> bool {

-    (pre.len() > str.len()) | 

-	pre != str[...len()pre|]

-}

-spec fn isSubstringPred(sub: String, str: String) -> bool {

-    (exists|i: int| 0 <= i <= str.len() and  isPrefixPred(sub, str[i..]))

-}

-spec fn isNotSubstringPred(sub: String, str: String) -> bool {

-    (forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub,str[i..]))

-}

-spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    exists|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k and isSubstringPred(str1[i1..j1],str2)

-}

-spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool {

-    forall|i1: int, j1: int| 0 <= i1 <= str1.len()- k and j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)

+spec fn isPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() <= str.len()) && 

+    pre == str.subrange(0, pre.len() as int)

 }

 

-fn isPrefix(pre: String, str: String) -> (res: bool)

-    ensures !res <==> isNotPrefixPred(pre,str),

-            res <==> isPrefixPred(pre,str)

+

+spec fn isNotPrefixPred(pre: String, str: String) -> bool

+{

+    (pre.len() > str.len()) || 

+    pre != str.subrange(0, pre.len() as int)

+}

+

+

+

+

+pub fn isPrefix(pre: String, str: String) -> (res: bool)

+    ensures(!res <==> isNotPrefixPred(pre, str))

+    ensures(res <==> isPrefixPred(pre, str))

 {

 }

 

+

+spec fn isSubstringPred(sub: String, str: String) -> bool

+{

+    exists|i: int| 0 <= i <= str.len() && isPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+spec fn isNotSubstringPred(sub: String, str: String) -> bool

+{

+    forall|i: int| 0 <= i <= str.len() ==> isNotPrefixPred(sub, str.subrange(i, str.len() as int))

+}

+

+

+

+

+pub fn isSubstring(sub: String, str: String) -> (res: bool)

+    ensures(res <==> isSubstringPred(sub, str))

+    ensures(res ==> isSubstringPred(sub, str))

+

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(isSubstringPred(sub, str) ==> res)

+    ensures(!res <==> isNotSubstringPred(sub, str))

+{

+}

+

+

+spec fn haveCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    exists|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k && isSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+spec fn haveNotCommonKSubstringPred(k: nat, str1: String, str2: String) -> bool

+{

+    forall|i1: int, j1: int| 0 <= i1 <= str1.len() - k && j1 == i1 + k ==> isNotSubstringPred(str1.subrange(i1, j1), str2)

+}

+

+

+

+

+pub fn haveCommonKSubstring(k: nat, str1: String, str2: String) -> (found: bool)

+    ensures(found <==> haveCommonKSubstringPred(k, str1, str2))

+    ensures(!found <==> haveNotCommonKSubstringPred(k, str1, str2))

+{

+}

+

+

+pub fn maxCommonSubstringLength(str1: String, str2: String) -> (len: nat)

+    requires(str1.len() <= str2.len())

+    ensures(forall|k: nat| len < k <= str1.len() ==> !haveCommonKSubstringPred(k, str1, str2))

+    ensures(haveCommonKSubstringPred(len, str1, str2))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_1.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PalVerify(a: Vec<char>) -> (yn: bool)

-    ensures yn == true ==> forall|i: int| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i -1],

-            yn == false ==> exists|i: int| 0 <= i < a.len()/2 and a[i] != a[a.len() - i -1],

-            forall|j: int| 0<=j<a.len() ==> a[j] == old(a[j])

+pub fn pal_verify(a: &[char]) -> (yn: bool)

+    ensures(yn == true ==> forall|i: usize| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i - 1])

+    ensures(yn == false ==> exists|i: usize| 0 <= i < a.len()/2 && a[i] != a[a.len() - i - 1])

+    ensures(forall|j: usize| 0 <= j < a.len() ==> a[j] == old(a)[j])

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_spec_task_2.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PalVerify(a: Vec<char>) -> (yn: bool)

-    ensures yn == true ==> forall|i: int| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i -1],

-            yn == false ==> exists|i: int| 0 <= i < a.len()/2 and a[i] != a[a.len() - i -1],

-            forall|j: int| 0<=j<a.len() ==> a[j] == old(a[j])

+pub fn pal_verify(a: &[char]) -> (yn: bool)

+    ensures(yn == true ==> forall|i: usize| 0 <= i < a.len()/2 ==> a[i] == a[a.len() - i - 1])

+    ensures(yn == false ==> exists|i: usize| 0 <= i < a.len()/2 && a[i] != a[a.len() - i - 1])

+    ensures(forall|j: usize| 0 <= j < a.len() ==> a[j] == old(a)[j])

 {

 }

 

+pub fn test()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Forbid42(x: int, y: int) -> (z: int)

-    requires y != 42;

-    ensures z == x/(42-y);

+pub fn Forbid42(x: int, y: int) -> (z: int)

+    requires(y != 42)

+    ensures(|z: int| z == x/(42-y))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_2.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Allow42(x: int, y: int) -> z: int, err: bool

-    ensures y != 42 ==> z == x/(42-y) and err == false;,

-            y == 42 ==> z == 0 and err == true;

+pub fn Allow42(x: int, y: int) -> (z: int, err: bool)

+    ensures(y != 42 ==> z == x/(42-y) && err == false)

+    ensures(y == 42 ==> z == 0 && err == true)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_spec_task_3.rs
@@ -1,15 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Forbid42(x: int, y: int) -> (z: int)

-    requires y != 42;

-    ensures z == x/(42-y);

+pub fn Forbid42(x: int, y: int) -> (z: int)

+    requires(y != 42)

+    ensures(z == x/(42-y))

 {

 }

 

+pub fn Allow42(x: int, y: int) -> (z: int, err: bool)

+    ensures(y != 42 ==> z == x/(42-y) && err == false)

+    ensures(y == 42 ==> z == 0 && err == true)

+{

+}

+

+pub fn TEST1()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_1.rs
@@ -1,21 +1,55 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn nomultiples(u: Seq<nat>) -> bool {

-    forall|j: int, k: int| 0<=j<k<u.len() ==> u[j] != u[k]

+spec fn bullspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    reccbull(s, u, 0)

 }

 

-fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> b: nat, c: nat

-    requires 0 < u.len() == s.len() <= 10,

-             nomultiples(u) and nomultiples(s);

-    ensures b >= 0 and c >= 0,

-            b == bullspec(s, u),

-            c == cowspec(s, u)

+spec fn cowspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    recccow(s, u, 0)

+}

+

+spec fn reccbull(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] == u[i] {

+        reccbull(s, u, i + 1) + 1

+    } else {

+        reccbull(s, u, i + 1)

+    }

+}

+

+spec fn recccow(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] != u[i] && u[i] in s {

+        recccow(s, u, i + 1) + 1

+    } else {

+        recccow(s, u, i + 1)

+    }

+}

+

+spec fn nomultiples(u: Seq<nat>) -> bool {

+    forall|j: int, k: int| 0 <= j < k < u.len() ==> u[j] != u[k]

+}

+

+pub fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> (b: nat, c: nat)

+    requires

+        0 < u.len() == s.len() <= 10,

+        nomultiples(u) && nomultiples(s),

+    ensures

+        b >= 0 && c >= 0,

+        b == bullspec(s, u),

+        c == cowspec(s, u),

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_spec_task_2.rs
@@ -1,22 +1,57 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn nomultiples(u: Seq<nat>) -> bool {

-    forall|j: int, k: int| 0<=j<k<u.len() ==> u[j] != u[k]

+spec fn bullspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    reccbull(s, u, 0)

 }

 

-fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> b: nat, c: nat

+spec fn cowspec(s: Seq<nat>, u: Seq<nat>) -> nat

+    recommends 0 <= u.len() == s.len() && nomultiples(u)

+{

+    recccow(s, u, 0)

+}

+

+spec fn reccbull(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] == u[i] {

+        reccbull(s, u, i + 1) + 1

+    } else {

+        reccbull(s, u, i + 1)

+    }

+}

+

+spec fn recccow(s: Seq<nat>, u: Seq<nat>, i: int) -> nat

+    recommends 0 <= i <= s.len() == u.len()

+{

+    if i == s.len() {

+        0

+    } else if s[i] != u[i] && u[i] in s {

+        recccow(s, u, i + 1) + 1

+    } else {

+        recccow(s, u, i + 1)

+    }

+}

+

+spec fn nomultiples(u: Seq<nat>) -> bool {

+    forall|j: int, k: int| 0 <= j < k < u.len() ==> u[j] != u[k]

+}

+

+pub fn BullsCows(s: Seq<nat>, u: Seq<nat>) -> (b: nat, c: nat)

     requires 0 < u.len() == s.len() <= 10,

-             nomultiples(u) and nomultiples(s);

-    ensures b >= 0 and c >= 0,

-            b == bullspec(s, u),

-            c == cowspec(s, u)

+    requires nomultiples(u) && nomultiples(s),

+    ensures b >= 0 && c >= 0,

+    ensures b == bullspec(s, u),

+    ensures c == cowspec(s, u),

 {

 }

 

+pub fn TEST() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_1.rs
@@ -1,18 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

-    requires 0 < s.len() and x < s.len() and y < s.len()

-    ensures t.len() == s.len(),

-            forall b:nat :: 0 <= b < s.len() and b != x and b != y ==> t[b] == s[b],

-            t[x] == s[y] and s[x] == t[y],

-            multiset(s) == multiset(t)

+pub fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

+    requires 

+        0 < s.len() && x < s.len() && y < s.len()

+    ensures 

+        |result|.len() == s.len(),

+        forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> result[b] == s[b],

+        result[x] == s[y] && s[x] == result[y],

+        result.to_multiset() == s.to_multiset()

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_2.rs
@@ -1,29 +1,56 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-spec fn below(first: Bases, second: Bases) -> bool {

-    first == second |

-    first == A .len() 

-    (first == C and (second ==  G .len() second == T)) .len() 

-    (first == G and second == T) .len()|

-    second == T

+

+

+pub fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

+    requires(

+        0 < s.len() && x < s.len() && y < s.len()

+    )

+    ensures(|t: Seq<Bases>|

+        t.len() == s.len() &&

+        (forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b]) &&

+        t[x] == s[y] && s[x] == t[y] &&

+        s.to_multiset() == t.to_multiset()

+    )

+{

 }

-spec fn bordered(s: Seq<Bases>) -> bool {

+

+

+

+

+

+

+

+spec fn below(first: Bases, second: Bases) -> bool

+{

+    first == second ||

+    first == Bases::A || 

+    (first == Bases::C && (second == Bases::G || second == Bases::T)) || 

+    (first == Bases::G && second == Bases::T) ||

+    second == Bases::T

+}

+

+

+

+

+

+spec fn bordered(s: Seq<Bases>) -> bool

+{

     forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])

 }

 

-fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

-    requires 0 < s.len() and x < s.len() and y < s.len()

-    ensures t.len() == s.len(),

-            forall b:nat :: 0 <= b < s.len() and b != x and b != y ==> t[b] == s[b],

-            t[x] == s[y] and s[x] == t[y],

-            multiset(s) == multiset(t)

+

+

+pub fn sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)

+    requires(0 < bases.len())

+    ensures(|sobases: Seq<Bases>|

+        sobases.len() == bases.len() &&

+        bordered(sobases) &&

+        bases.to_multiset() == sobases.to_multiset()

+    )

 {

 }

 

-}
+

+


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_3.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

-    requires 0 < s.len() and x < s.len() and y < s.len()

-    ensures t.len() == s.len(),

-            forall b:nat :: 0 <= b < s.len() and b != x and b != y ==> t[b] == s[b],

-            t[x] == s[y] and s[x] == t[y],

-            multiset(s) == multiset(t)

+pub fn exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

+    requires 0 < s.len() && x < s.len() && y < s.len()

+    ensures |t| == |s|

+    ensures forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b]

+    ensures t[x] == s[y] && s[x] == t[y]

+    ensures s.to_multiset() == t.to_multiset()

 {

 }

 

+pub fn tester_exchange()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_spec_task_4.rs
@@ -1,29 +1,55 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

 

-verus! {

 

-spec fn below(first: Bases, second: Bases) -> bool {

-    first == second |

-    first == A .len() 

-    (first == C and (second ==  G .len() second == T)) .len() 

-    (first == G and second == T) .len()|

-    second == T

+

+

+pub fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

+    requires(0 < s.len() && x < s.len() && y < s.len())

+    ensures(|t: Seq<Bases>| t.len() == s.len())

+    ensures(|t: Seq<Bases>| forall|b: nat| 0 <= b < s.len() && b != x && b != y ==> t[b] == s[b])

+    ensures(|t: Seq<Bases>| t[x] == s[y] && s[x] == t[y])

+    ensures(|t: Seq<Bases>| s.to_multiset() == t.to_multiset())

+{

 }

-spec fn bordered(s: Seq<Bases>) -> bool {

+

+

+

+

+

+

+

+spec fn below(first: Bases, second: Bases) -> bool

+{

+    first == second ||

+    first == Bases::A || 

+    (first == Bases::C && (second == Bases::G || second == Bases::T)) || 

+    (first == Bases::G && second == Bases::T) ||

+    second == Bases::T

+}

+

+

+

+

+

+spec fn bordered(s: Seq<Bases>) -> bool

+{

     forall|j: int, k: int| 0 <= j < k < s.len() ==> below(s[j], s[k])

 }

 

-fn Exchanger(s: Seq<Bases>, x: nat, y: nat) -> (t: Seq<Bases>)

-    requires 0 < s.len() and x < s.len() and y < s.len()

-    ensures t.len() == s.len(),

-            forall b:nat :: 0 <= b < s.len() and b != x and b != y ==> t[b] == s[b],

-            t[x] == s[y] and s[x] == t[y],

-            multiset(s) == multiset(t)

+

+

+pub fn Sorter(bases: Seq<Bases>) -> (sobases: Seq<Bases>)

+    requires(0 < bases.len())

+    ensures(|sobases: Seq<Bases>| sobases.len() == bases.len())

+    ensures(|sobases: Seq<Bases>| bordered(sobases))

+    ensures(|sobases: Seq<Bases>| bases.to_multiset() == sobases.to_multiset())

 {

 }

 

+

+

+

+

+pub fn Testsort()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_spec_task_1.rs
@@ -1,14 +1,11 @@
+spec fn fib(n: nat) -> nat

+{

+    if n == 0 { 0 } else

+    if n == 1 { 1 } else

+                    fib((n - 1) as nat) + fib((n - 2) as nat)

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeFib(n: nat) -> (b: nat)

+pub fn ComputeFib(n: nat) -> (b: nat)

     ensures b == fib(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_spec_task_1.rs
@@ -1,15 +1,16 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn do_algebra(operators: Seq<char>, operands: Seq<int>) -> (result: int)

-    requires operators != [] and operands != [] and operators.len() + 1 == operands.len(),

-             forall|i: int| 0 <= i < operands.len() ==> operands[i] >= 0

+spec fn pow(base: int, exponent: int) -> int

+    recommends exponent >= 0

 {

+    if exponent == 0 { 1 }

+    else if exponent % 2 == 0 { pow(base * base, exponent / 2) }

+    else { base * pow(base, exponent - 1) }

 }

 

+pub fn do_algebra(operators: Seq<char>, operands: Seq<int>) -> (result: int)

+    requires

+        operators.len() != 0 && operands.len() != 0 && operators.len() + 1 == operands.len(),

+        forall|i: int| 0 <= i < operands.len() ==> operands[i] >= 0,

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_spec_task_1.rs
@@ -1,14 +1,22 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sum(s: Seq<int>, n: nat) -> int

+    recommends n <= s.len()

+{

+    if s.len() == 0 || n == 0 {

+        0

+    } else {

+        s[0] + sum(s.subrange(1, s.len() as int), (n-1) as nat)

+    }

+}

 

-verus! {

-

-fn below_zero(ops: Seq<int>) -> (result: bool)

-    ensures result <==> exists n: nat :: n <= ops.len() and sum(ops, n) < 0

+proof fn sum_plus(s: Seq<int>, i: nat)

+    requires i < s.len()

+    ensures sum(s, i) + s[i as int] == sum(s, (i+1) as nat)

 {

 }

 

+pub fn below_zero(ops: Seq<int>) -> (result: bool)

+    ensures result <==> exists|n: nat| n <= ops.len() && sum(ops, n) < 0

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_1.rs
@@ -1,15 +1,17 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+pub open spec fn isMax(m: int, numbers: Seq<int>) -> bool

+{

+    numbers.contains(m) &&

+    forall|i: int| 0 <= i < numbers.len() ==> numbers[i] <= m

+}

 

-verus! {

 

-fn max(numbers: Seq<int>) -> (result: int)

-    requires numbers != []

-    ensures isMax(result, numbers)

+

+pub fn max(numbers: Seq<int>) -> (result: int)

+    requires

+        numbers.len() != 0,

+    ensures

+        isMax(result, numbers),

 {

 }

 

-}

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_spec_task_2.rs
@@ -1,16 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn rolling_max(numbers: Seq<int>) -> (result: Seq<int>)

-    requires numbers != []

-    ensures result.len() == numbers.len(),

-            forall|i: int| 0 < i < result.len() ==> isMax(result[i], numbers[0..(i+1)])

-{

+pub fn is_max(m: int, numbers: Seq<int>) -> bool {

+    numbers.contains(m) &&

+    forall|i: int| 0 <= i < numbers.len() ==> numbers[i] <= m

 }

 

+pub fn rolling_max(numbers: Seq<int>) -> (result: Seq<int>)

+    requires(

+        numbers.len() != 0

+    )

+    ensures(|result: Seq<int>| {

+        &&& result.len() == numbers.len()

+        &&& forall|i: int| 0 < i < result.len() ==> is_max(result[i], numbers.subrange(0, i + 1))

+    })

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_spec_task_1.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn buscar(a: Vec<int>, x: int) -> (r: int)

-    ensures r < 0 ==> forall|i: int| 0 <= i <a.len() ==> a[i] != x,

-            0 <= r < a.len() ==> a[r] == x

+pub fn buscar(a: &[int], x: int) -> (r: int)

+    ensures

+        r < 0 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x,

+        0 <= r < a.len() ==> a[r] == x,

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_spec_task_1.rs
@@ -1,14 +1,16 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn somaAteAberto(a: &[nat], i: nat) -> nat

+    recommends i <= a.len()

+{

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + somaAteAberto(a, i-1)

+    }

+}

 

-verus! {

-

-fn somatorio(a: Vec<nat>) -> (s: nat)

+pub fn somatorio(a: &[nat]) -> (s: nat)

     ensures s == somaAteAberto(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_1.rs
@@ -1,33 +1,22 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

-spec fn requires(valid_base(b))

-  requires (nitness(b, n))

-  ensures (nitness(b, sum))

-  ensures (nitness(b, carry)) -> bool {

-    

-}

 

-fn nit_increment(b: nat, n: nat) -> sum: nat, carry: nat)

-

-

-  requires (valid_base(b)

-    requires (valid_base(b)),

-             (nitness(b, n))

-    ensures (nitness(b, sum)),

-            (nitness(b, carry))

+pub fn nit_increment(b: nat, n: nat) -> (sum: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, sum))

+    ensures(nitness(b, carry))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_10.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_10.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_10.rs
@@ -1,32 +1,92 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

 

-fn max_nit(b: nat) -> (nmax: nat)

-    requires (valid_base(b))

-    ensures (nitness(b, nmax)),

-            (is_max_nit(b, nmax))

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

 {

 }

 

+pub fn nit_flip(b: nat, n: nat) -> (nf: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, nf))

+{

+}

+

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

+

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

+

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_add(b: nat, p: Seq<nat>, q: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    requires(bibble(b, q))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_increment(b: nat, p: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_flip(b: nat, p: Seq<nat>) -> (fp: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, fp))

+{

+}

+

+pub fn n_complement(b: nat, p: Seq<nat>) -> (com: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, com))

+{

+}

+

+pub fn Main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_2.rs
@@ -1,26 +1,25 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

 

-fn max_nit(b: nat) -> (nmax: nat)

-    requires (valid_base(b))

-    ensures (nitness(b, nmax)),

-            (is_max_nit(b, nmax))

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_3.rs
@@ -1,26 +1,32 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

 

-fn max_nit(b: nat) -> (nmax: nat)

-    requires (valid_base(b))

-    ensures (nitness(b, nmax)),

-            (is_max_nit(b, nmax))

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

+{

+}

+

+pub fn nit_flip(b: nat, n: nat) -> (nf: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, nf))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_4.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_4.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_4.rs
@@ -1,27 +1,24 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

 

-fn nit_add(b: nat, x: nat, y: nat) -> z: nat, carry: nat

-    requires (valid_base(b)),

-             (nitness(b, x)),

-             (nitness(b, y))

-    ensures (nitness(b, z)),

-            (nitness(b, carry))

-

-            (carry == 0 or carry == 1)

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_5.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_5.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_5.rs
@@ -1,27 +1,35 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

 

-fn nit_add(b: nat, x: nat, y: nat) -> z: nat, carry: nat

-    requires (valid_base(b)),

-             (nitness(b, x)),

-             (nitness(b, y))

-    ensures (nitness(b, z)),

-            (nitness(b, carry))

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

 

-            (carry == 0 or carry == 1)

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_6.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_6.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_6.rs
@@ -1,42 +1,49 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

+

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

 }

 

-fn nit_add(b: nat, x: nat, y: nat) -> z: nat, carry: nat

-    requires (valid_base(b)),

-             (nitness(b, x)),

-             (nitness(b, y))

-    ensures (nitness(b, z)),

-            (nitness(b, carry))

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

 

-            (carry == 0 or carry == 1)

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_add(b: nat, p: Seq<nat>, q: Seq<nat>) -> Seq<nat>

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    requires(bibble(b, q))

+    ensures(bibble(b, result))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_7.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_7.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_7.rs
@@ -1,37 +1,56 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

+

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

 }

 

-fn nit_add(b: nat, x: nat, y: nat) -> z: nat, carry: nat

-    requires (valid_base(b)),

-             (nitness(b, x)),

-             (nitness(b, y))

-    ensures (nitness(b, z)),

-            (nitness(b, carry))

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

 

-            (carry == 0 or carry == 1)

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_add(b: nat, p: Seq<nat>, q: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    requires(bibble(b, q))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_increment(b: nat, p: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, r))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_8.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_8.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_8.rs
@@ -1,41 +1,45 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

-}

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

+

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

+{

 }

 

-fn max_nit(b: nat) -> (nmax: nat)

-    requires (valid_base(b))

-    ensures (nitness(b, nmax)),

-            (is_max_nit(b, nmax))

+pub fn nit_flip(b: nat, n: nat) -> (nf: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, nf))

+{

+}

+

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_flip(b: nat, p: Seq<nat>) -> (fp: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, fp))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_9.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_9.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/nitwit_tmp_tmplm098gxz_nit_spec_task_9.rs
@@ -1,31 +1,88 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

 spec fn valid_base(b: nat) -> bool {

     b >= 2

 }

-spec fn nitness(b: nat, n: nat)

-  requires (valid_base(b)) -> bool {

+

+spec fn nitness(b: nat, n: nat) -> bool

+    recommends valid_base(b)

+{

     0 <= n < b

 }

+

 spec fn is_max_nit(b: nat, q: nat) -> bool {

     q == b - 1

 }

-spec fn bibble(b: nat, a: Seq<nat>) -> bool {

-    valid_base(b) and 

-  a.len() == 4 and 

-  forall|n: int| n in a ==> nitness(b, n)

+

+pub fn max_nit(b: nat) -> (nmax: nat)

+    requires(valid_base(b))

+    ensures(nitness(b, nmax))

+    ensures(is_max_nit(b, nmax))

+{

 }

 

-fn max_nit(b: nat) -> (nmax: nat)

-    requires (valid_base(b))

-    ensures (nitness(b, nmax)),

-            (is_max_nit(b, nmax))

+pub fn nit_flip(b: nat, n: nat) -> (nf: nat)

+    requires(valid_base(b))

+    requires(nitness(b, n))

+    ensures(nitness(b, nf))

+{

+}

+

+pub fn nit_add(b: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

+

+pub fn nit_add_three(b: nat, c: nat, x: nat, y: nat) -> (z: nat, carry: nat)

+    requires(valid_base(b))

+    requires(c == 0 || c == 1)

+    requires(nitness(b, x))

+    requires(nitness(b, y))

+    ensures(nitness(b, z))

+    ensures(nitness(b, carry))

+    ensures(carry == 0 || carry == 1)

+{

+}

+

+spec fn bibble(b: nat, a: Seq<nat>) -> bool {

+    valid_base(b) && 

+    a.len() == 4 && 

+    forall|n: nat| a.contains(n) ==> nitness(b, n)

+}

+

+pub fn bibble_add(b: nat, p: Seq<nat>, q: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    requires(bibble(b, q))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_increment(b: nat, p: Seq<nat>) -> (r: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, r))

+{

+}

+

+pub fn bibble_flip(b: nat, p: Seq<nat>) -> (fp: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, fp))

+{

+}

+

+pub fn n_complement(b: nat, p: Seq<nat>) -> (com: Seq<nat>)

+    requires(valid_base(b))

+    requires(bibble(b, p))

+    ensures(bibble(b, com))

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_1.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Ceiling7(n: nat) -> (k: nat)

-    requires n >= 0

-    ensures k == n-(n%7)

+pub fn ceiling7(n: nat) -> (k: nat)

+    requires(n >= 0)

+    ensures(k == n - (n % 7))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass1_ex6_spec_task_2.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Ceiling7(n: nat) -> (k: nat)

-    requires n >= 0

-    ensures k == n-(n%7)

+pub fn ceiling7(n: nat) -> (k: nat)

+    requires(n >= 0)

+    ensures(k == n - (n % 7))

 {

 }

 

+pub fn test7()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_1.rs
@@ -1,37 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn check(a: Vec<int>, seclar: int)

-requires a.Length > 0

-reads a

-{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-

-method SecondLargest(a:array<int>) -> (seclar: int)

-    requires a.len() > 0

-reads a,

-             a.len() > 0

-

-    ensures exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-            for the method 

-

-method SecondLargest(a:array<int>) returns (seclar:int),

-            exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])

+pub fn SecondLargest(a: &[i32]) -> (seclar: i32)

+    requires(a.len() > 0)

 {

-}

-

+    

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/se2011_tmp_tmp71eb82zt_ass2_ex2_spec_task_2.rs
@@ -1,37 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn check(a: Vec<int>, seclar: int)

-requires a.Length > 0

-reads a

-{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-

-method SecondLargest(a:array<int>) -> (seclar: int)

-    requires a.len() > 0

-reads a,

-             a.len() > 0

-

-    ensures exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

-

-

-

-

-

-            for the method 

-

-method SecondLargest(a:array<int>) returns (seclar:int),

-            exists|i: int| 0 <= i < a.len() and forall|j: int| (0 <= j < a.len() and j != i) ==> (a[i] >= a[j]) and (seclar <= a[i]) and ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])

+pub fn SecondLargest(a: &[i32]) -> (seclar: i32)

+    requires(a.len() > 0)

 {

 }

 

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_1.rs
@@ -1,20 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn find_min_index(a: Vec<int>, s: int, e: int) -> (min_i: int)

-    requires a.len() > 0,

-             0 <= s < a.len(),

-             e <= a.len(),

-             e > s

-    ensures min_i >= s,

-            min_i < e,

-            forall k: int :: s <= k < e ==> a[min_i] <= a[k]

+pub fn find_min_index(a: &[i32], s: usize, e: usize) -> (min_i: usize)

+    requires(

+        a.len() > 0,

+        s < a.len(),

+        e <= a.len(),

+        e > s,

+    )

+    ensures(|min_i: usize|

+        min_i >= s &&

+        min_i < e &&

+        forall|k: usize| s <= k && k < e ==> a[min_i as int] <= a[k as int]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/software_analysis_tmp_tmpmt6bo9sf_ss_spec_task_2.rs
@@ -1,41 +1,44 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn is_sorted(ss: Seq<int>) -> bool {

-    forall i, j: int:: 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]

-}

-spec fn is_permutation(a: Seq<int>, b: Seq<int>) -> bool {

-    a.len() == b.len()  and 

-    ((a.len() == 0 and b.len() == 0) |  

-    exists i,j : int :: 0<=i<.len()a and  0<=j<.len()b  and a[i] == b[j] and is_permutation(a[0..i] + if i < .len()a then a[i+1..] else [], b[0..j] + if j < .len()b| then  b[j+1..] else []))

-}

-spec fn is_permutation(a: Seq<int>, b: Seq<int>, j: int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))

-

-

-

-

-

-

-

-

-predicate is_permutation2(a: Seq<int>, b: Seq<int>) -> bool {

-    multiset(a) == multiset(b)

-}

-

-fn find_min_index(a: Vec<int>, s: int, e: int) -> (min_i: int)

-    requires a.len() > 0,

-             0 <= s < a.len(),

-             e <= a.len(),

-             e > s

-    ensures min_i >= s,

-            min_i < e,

-            forall k: int :: s <= k < e ==> a[min_i] <= a[k]

+pub fn find_min_index(a: &[i32], s: usize, e: usize) -> (min_i: usize)

+    requires(

+        a.len() > 0,

+        s < a.len(),

+        e <= a.len(),

+        e > s,

+    )

+    ensures(|min_i: usize|

+        min_i >= s &&

+        min_i < e &&

+        forall|k: usize| s <= k < e ==> a[min_i] <= a[k]

+    )

 {

 }

 

+pub open spec fn is_sorted(ss: Seq<i32>) -> bool

+{

+    forall|i: int, j: int| 0 <= i <= j < ss.len() ==> ss[i] <= ss[j]

+}

+

+pub open spec fn is_permutation(a: Seq<i32>, b: Seq<i32>) -> bool

+{

+    a.len() == b.len() &&

+    ((a.len() == 0 && b.len() == 0) ||

+    exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j] && 

+    is_permutation(a.subrange(0, i) + (if i < a.len() { a.subrange(i+1, a.len() as int) } else { seq![] }), 

+                   b.subrange(0, j) + (if j < b.len() { b.subrange(j+1, b.len() as int) } else { seq![] })))

+}

+

+pub open spec fn is_permutation2(a: Seq<i32>, b: Seq<i32>) -> bool

+{

+    a.to_multiset() == b.to_multiset()

+}

+

+pub fn selection_sort(ns: &mut [i32])

+    requires(

+        old(ns).len() >= 0,

+    )

+    ensures(

+        is_sorted(ns@),

+        is_permutation2(old(ns)@, ns@),

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_1.rs
@@ -1,29 +1,34 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn divides(f: nat, i: nat)

-  requires 1<=f

+

+spec fn divides(f: nat, i: nat) -> bool

+    recommends 1 <= f

 {

-  i % f == 0

+    i % f == 0

+}

+

+

+

+spec fn IsPrime(i: nat) -> bool

+{

+    &&& 1 < i

+    &&& forall|f: nat| 1 < f < i ==> !divides(f, i)

 }

 

 

 

 

-predicate IsPrime(i:nat) -> bool {

-    and 1<i

-  and ( forall|f: int| 1 < f < i ==> !divides(f, i) )

-}

 

-fn test_prime(i: nat) -> (result: bool)

-    requires 1<i

-    ensures result == IsPrime(i)

+

+

+pub fn test_prime(i: nat) -> (result: bool)

+    requires(1 < i)

+    ensures(result == IsPrime(i))

 {

 }

 

+

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_spec_task_2.rs
@@ -1,28 +1,29 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn divides(f: nat, i: nat)

-  requires 1<=f

+

+spec fn divides(f: nat, i: nat) -> bool

+    recommends 1 <= f

 {

-  i % f == 0

+    i % f == 0

 }

 

 

+spec fn IsPrime(i: nat) -> bool

+{

+    1 < i && (forall|f: nat| 1 < f < i >>= !divides(f, i))

+}

 

 

-predicate IsPrime(i:nat) -> bool {

-    and 1<i

-  and ( forall|f: int| 1 < f < i ==> !divides(f, i) )

+pub fn test_prime(i: nat) -> (result: bool)

+    requires(1 < i)

+    ensures(result == IsPrime(i))

+{

 }

 

-fn test_prime(i: nat) -> (result: bool)

-    requires 1<i

-    ensures result == IsPrime(i)

+

+pub fn Main()

 {

 }

 


================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_1.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn merge_sort(input: Seq<int>) -> (output: Seq<int>)

-    ensures SortSpec(input, output)

+pub fn merge_sort(input: Seq<int>) -> (output: Seq<int>)

+    ensures(SortSpec(input, output))

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_2.rs
@@ -1,27 +1,28 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSorted(s: Seq<int>) -> bool {

+spec fn is_sorted(s: Seq<int>) -> bool

+{

     forall|i: int| 0 <= i < s.len()-1 ==> s[i] <= s[i+1]

 }

-spec fn SortSpec(input: Seq<int>, output: Seq<int>) -> bool {

-    and IsSorted(output)

-  and multiset(output) == multiset(input)

+

+

+spec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool

+{

+    && is_sorted(output)

+    && output.to_multiset() == input.to_multiset()

 }

 

-fn merge(a: Seq<int>, b: Seq<int>) -> (output: Seq<int>)

-    requires IsSorted(a),

-             IsSorted(b)

 

-    ensures IsSorted(output),

-            SortSpec(a+b, output)

-

+pub fn merge(a: Seq<int>, b: Seq<int>) -> (output: Seq<int>)

+    requires(is_sorted(a))

+    requires(is_sorted(b))

+    ensures(sort_spec(a + b, output))

 {

 }

 

+

+pub fn merge(a: Seq<int>, b: Seq<int>) -> (output: Seq<int>)

+    requires(is_sorted(a))

+    requires(is_sorted(b))

+    ensures(sort_spec(a + b, output))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_3.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_3.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_spec_task_3.rs
@@ -1,22 +1,18 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSorted(s: Seq<int>) -> bool {

+spec fn is_sorted(s: Seq<int>) -> bool

+{

     forall|i: int| 0 <= i < s.len()-1 ==> s[i] <= s[i+1]

 }

-spec fn SortSpec(input: Seq<int>, output: Seq<int>) -> bool {

-    and IsSorted(output)

-  and multiset(output) == multiset(input)

+

+

+spec fn sort_spec(input: Seq<int>, output: Seq<int>) -> bool

+{

+    &&& is_sorted(output)

+    &&& output.to_multiset() == input.to_multiset()

 }

 

-fn fast_sort(input: Seq<int>) -> output: Seq<int>, output

-    ensures SortSpec(input, output)

+

+pub fn fast_sort(input: Seq<int>) -> (output: Seq<int>)

+

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_spec_task_1.rs
@@ -1,14 +1,16 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Somatorio(a: Vec<nat>) -> (s: nat)

-    ensures s == SomaAte(a,a.len())

+spec fn SomaAte(a: &[nat], i: nat) -> nat

+    recommends 0 <= i <= a.len()

 {

+    if i == 0 {

+        0

+    } else {

+        a[i-1] + SomaAte(a, i-1)

+    }

 }

 

+

+pub fn Somatorio(a: &[nat]) -> (s: nat)

+    ensures(s == SomaAte(a, a.len()))

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_spec_task_1.rs
@@ -1,14 +1,8 @@
+spec fn Fat(n: nat) -> nat {

+    if n == 0 { 1 } else { n * Fat((n - 1) as nat) }

+}

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Fatorial(n: nat) -> (r: nat)

+pub fn Fatorial(n: nat) -> (r: nat)

     ensures r == Fat(n)

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/tangent-finder_tmp_tmpgyzf44ve_circles_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/tangent-finder_tmp_tmpgyzf44ve_circles_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/tangent-finder_tmp_tmpgyzf44ve_circles_spec_task_1.rs
@@ -1,17 +1,15 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Tangent(r: Vec<int>, x: Vec<int>) -> (b: bool)

-    requires forall|i: int, j: int| 0 <= i <= j < x.len() ==> x[i] <= x[j]

-             forall|i: int, j: int| (0 <= i < r.len() and 0 <= j < x.len()) ==> (r[i] >= 0 and x[j] >= 0)

-    ensures !b ==> forall|i: int, j: int| 0 <= i< r.len() and 0 <= j < x.len() ==> r[i] != x[j],

-            b ==> exists|i: int, j: int| 0 <= i< r.len() and 0 <= j < x.len() and r[i] == x[j]

+pub fn tangent(r: &[i32], x: &[i32]) -> bool

+    requires(

+        forall|i: usize, j: usize| 0 <= i <= j < x.len() ==> x[i] <= x[j]

+    )

+    requires(

+        forall|i: usize, j: usize| (0 <= i < r.len() && 0 <= j < x.len()) ==> (r[i] >= 0 && x[j] >= 0)

+    )

+    ensures(|b: bool|

+        !b ==> forall|i: usize, j: usize| 0 <= i < r.len() && 0 <= j < x.len() ==> r[i] != x[j]

+    )

+    ensures(|b: bool|

+        b ==> exists|i: usize, j: usize| 0 <= i < r.len() && 0 <= j < x.len() && r[i] == x[j]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_1.rs
@@ -1,13 +1,75 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn notin(y: nat, x: Vec<nat>, x: Seq<nat>) -> bool {

-    forall|i: int| 0 <= i < x.len() ==> y != x[i]

+pub fn sum(X_val: &[i32], X_crd: &[usize],

+           v_val: &[i32], v_crd: &[usize], kX: usize, kV: usize, pX_end: usize, pV_end: usize) -> i32

+    requires(

+        X_val.len() == X_crd.len() &&

+        pX_end <= X_crd.len() &&

+        kX <= X_crd.len() &&

+        v_val.len() == v_crd.len() &&

+        pV_end <= v_crd.len() &&

+        kV <= v_crd.len()

+    )

+{

 }

 

+

+pub fn min(x: usize, y: usize) -> usize

+{

+}

+

+

+pub fn notin(y: usize, x: &[usize]) -> bool

+{

+}

+

+

+pub fn notin_seq(y: usize, x: &[usize]) -> bool

+{

+}

+

+

+pub fn index_seq(x: usize, y: &[usize]) -> usize

+    ensures(|i: usize| 

+        (i >= y.len() ==> notin_seq(x, y)) &&

+        (i < y.len() ==> y[i as int] == x)

+    )

+{

+}

+

+

+pub fn index(x: usize, y: &[usize]) -> usize

+    ensures(|i: usize|

+        (i >= y.len() ==> notin(x, y)) &&

+        (i < y.len() ==> y[i as int] == x)

+    )

+{

+}

+

+

+pub fn DSpMSpV(X_val: &[i32], X_crd: &[usize], X_pos: &[usize],

+               X_crd1: &[usize], X_len: usize,

+               v_val: &[i32], v_crd: &[usize]) -> Vec<i32>

+    requires(

+        X_pos.len() >= 1 &&

+        X_val.len() == X_crd.len() &&

+        (forall|i: usize, j: usize| 0 <= i && i < j && j < X_pos.len() ==> X_pos[i as int] <= X_pos[j as int]) &&

+        (forall|i: usize| 0 <= i && i < X_pos.len() ==> X_pos[i as int] <= X_val.len()) &&

+        X_len >= X_crd1.len() &&

+        (forall|i: usize| 0 <= i && i < X_crd1.len() ==> X_crd1[i as int] < X_len) &&

+        X_crd1.len() < X_pos.len() &&

+        (forall|i: usize, j: usize| 0 <= i && i < j && j < X_crd1.len() ==> X_crd1[i as int] < X_crd1[j as int]) &&

+        v_val.len() == v_crd.len()

+    )

+    ensures(|y: Vec<i32>|

+        y.len() == X_len &&

+        (forall|i: usize| 0 <= i && i < y.len() ==>

+            y[i as int] == 

+                if index(i, X_crd1) < X_crd1.len() {

+                    sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1) as int], 0, X_pos[(index(i, X_crd1)+1) as int], v_val.len())

+                } else {

+                    0

+                }

+        )

+    )

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_spec_task_2.rs
@@ -1,58 +1,85 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn notin(y: nat, x: Vec<nat>, x: Seq<nat>) -> bool {

-    forall|i: int| 0 <= i < x.len() ==> y != x[i]

-}

-

-fn DSpMSpV(X_val: Vec<int>, X_crd: Vec<nat>, X_pos: Vec<nat>, X_crd1: Vec<nat>, X_len: nat, v_val: Vec<int>, v_crd: Vec<nat>) -> y: Vec<int>, j: : 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];

-  requires forall i :: 0 <= i < X_pos.Length ==> 0 <= X_pos[i] <= X_val.Length

-

-  requires X_len >= X_crd1.Length

-  requires forall i :: 0 <= i < X_crd1.Length ==> X_crd1[i] < X_len

-

-  requires X_crd1.Length < X_pos.Length

-  requires forall i, j: : 0 <= i < j < X_crd1.Length ==> X_crd1[i] < X_crd1[j]

-

-

-  requires v_val.Length == v_crd.Length

-

-  ensures y.Length == X_len

-  ensures forall i :: 0 <= i < y.Length ==> 

-    y[i] == 

-      if index(i, X_crd1) < X_crd1.Length then 

-        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)

-      else 0

-  {

+pub fn sum(X_val: &[i32], X_crd: &[usize],

+           v_val: &[i32], v_crd: &[usize], kX: usize, kV: usize, pX_end: usize, pV_end: usize) -> i32

+    requires(

+        X_val.len() == X_crd.len() &&

+        pX_end <= X_crd.len() &&

+        kX <= X_crd.len() &&

+        v_val.len() == v_crd.len() &&

+        pV_end <= v_crd.len() &&

+        kV <= v_crd.len()

+    )

+{

 }

 

 

 

-

-method Main(

-    requires X_pos.len() >= 1,

-             X_val.len() == X_crd.len(),

-             forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j];,

-             forall|i: int| 0 <= i < X_pos.len() ==> 0 <= X_pos[i] <= X_val.len(),

-             X_len >= X_crd1.len(),

-             forall|i: int| 0 <= i < X_crd1.len() ==> X_crd1[i] < X_len,

-             X_crd1.len() < X_pos.len(),

-             forall|i: int, j: int| 0 <= i < j < X_crd1.len() ==> X_crd1[i] < X_crd1[j]

-

-

-             v_val.len() == v_crd.len()

-    ensures y.len() == X_len,

-            forall|i: int| 0 <= i < y.len() ==> 

-    y[i] == 

-      if index(i, X_crd1) < X_crd1.len() then 

-        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.len())

-      else 0

+pub fn min(x: usize, y: usize) -> usize

 {

 }

 

+

+

+pub fn notin(y: usize, x: &[usize]) -> bool

+{

+}

+

+

+

+pub fn notin_seq(y: usize, x: &[usize]) -> bool

+{

+}

+

+

+

+pub fn index_seq(x: usize, y: &[usize]) -> usize

+    ensures(|result: usize|

+        (result >= y.len() ==> notin_seq(x, y)) &&

+        (result < y.len() ==> y[result] == x)

+    )

+{

+}

+

+

+

+pub fn index(x: usize, y: &[usize]) -> usize

+    ensures(|result: usize|

+        (result >= y.len() ==> notin(x, y)) &&

+        (result < y.len() ==> y[result] == x)

+    )

+{

+}

+

+

+

+pub fn DSpMSpV(X_val: &[i32], X_crd: &[usize], X_pos: &[usize],

+               X_crd1: &[usize], X_len: usize,

+               v_val: &[i32], v_crd: &[usize]) -> Vec<i32>

+    requires(

+        X_pos.len() >= 1 &&

+        X_val.len() == X_crd.len() &&

+        (forall|i: usize, j: usize| 0 <= i && i < j && j < X_pos.len() ==> X_pos[i] <= X_pos[j]) &&

+        (forall|i: usize| 0 <= i && i < X_pos.len() ==> X_pos[i] <= X_val.len()) &&

+        X_len >= X_crd1.len() &&

+        (forall|i: usize| 0 <= i && i < X_crd1.len() ==> X_crd1[i] < X_len) &&

+        X_crd1.len() < X_pos.len() &&

+        (forall|i: usize, j: usize| 0 <= i && i < j && j < X_crd1.len() ==> X_crd1[i] < X_crd1[j]) &&

+        v_val.len() == v_crd.len()

+    )

+    ensures(|result: Vec<i32>|

+        result.len() == X_len &&

+        (forall|i: usize| 0 <= i && i < result.len() ==>

+            result[i] == 

+                if index(i, X_crd1) < X_crd1.len() then 

+                    sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.len())

+                else 0

+        )

+    )

+{

+}

+

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_1.rs
@@ -1,21 +1,37 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn SpMV(X_val: Vec<int>, X_crd: Vec<nat>, X_pos: Vec<nat>, v: Vec<int>) -> (y: Vec<int>)

-    requires X_crd.len() >= 1,

-             X_crd.len() == X_val.len();,

-             forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j];,

-             forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

-             forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

-             X_pos.len() >= 1

-    ensures y.len() + 1 == X_pos.len(),

-            forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])

+spec fn sum(X_val: &[int], X_crd: &[nat], v: &[int], b: int, k: int) -> int

+    recommends

+        X_val.len() >= b >= 0,

+        k <= X_val.len(),

+        X_val.len() == X_crd.len(),

+        forall|i: int| 0 <= i < X_crd.len() ==> 0 <= X_crd[i] < v.len(),

+    decreases k - b

 {

+    if k <= b {

+        0

+    } else {

+        sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]

+    }

+}

+

+pub fn SpMV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], v: &[int]) -> (y: Vec<int>)

+    requires(

+        X_crd.len() >= 1,

+        X_crd.len() == X_val.len(),

+        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],

+        forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

+        forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

+        X_pos.len() >= 1,

+    )

+    ensures(

+        y.len() + 1 == X_pos.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1]),

+    )

+{

+    unimplemented!()

 }

 

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/veri-sparse_tmp_tmp15fywna6_dafny_spmv_spec_task_2.rs
@@ -1,21 +1,39 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn SpMV(X_val: Vec<int>, X_crd: Vec<nat>, X_pos: Vec<nat>, v: Vec<int>) -> (y: Vec<int>)

-    requires X_crd.len() >= 1,

-             X_crd.len() == X_val.len();,

-             forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j];,

-             forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

-             forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

-             X_pos.len() >= 1

-    ensures y.len() + 1 == X_pos.len(),

-            forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])

+spec fn sum(X_val: &[int], X_crd: &[nat], v: &[int], b: int, k: int) -> int

+    recommends

+        X_val.len() >= b >= 0,

+        k <= X_val.len(),

+        X_val.len() == X_crd.len(),

+        forall|i: int| 0 <= i < X_crd.len() ==> 0 <= X_crd[i] < v.len(),

+    decreases k - b,

+{

+    if k <= b {

+        0

+    } else {

+        sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b] as int]

+    }

+}

+

+pub fn SpMV(X_val: &[int], X_crd: &[nat], X_pos: &[nat], v: &[int]) -> (y: Vec<int>)

+    requires(

+        X_crd.len() >= 1,

+        X_crd.len() == X_val.len(),

+        forall|i: int, j: int| 0 <= i < j < X_pos.len() ==> X_pos[i] <= X_pos[j],

+        forall|i: int| 0 <= i < X_crd.len() ==> X_crd[i] < v.len(),

+        forall|i: int| 0 <= i < X_pos.len() ==> X_pos[i] <= X_val.len(),

+        X_pos.len() >= 1,

+    )

+    ensures(

+        y.len() + 1 == X_pos.len(),

+        forall|i: int| 0 <= i < y.len() ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1]),

+    )

 {

 }

 

+pub fn Main() {

+}

+

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/verified-isort_tmp_tmp7hhb8ei__dafny_isort_spec_task_1.rs
@@ -1,13 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

 spec fn sorted(a: Seq<nat>) -> bool {

     true

 }

 

+pub fn Isort(a: &mut [nat])

+    ensures sorted(a@)

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_1.rs
@@ -1,19 +1,24 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn longestZero(a: Vec<int>) -> sz: int, pos: int

-    requires 1 <= a.len()

-    ensures 0 <= sz <= a.len(),

-            0 <= pos < a.len(),

-            pos + sz <= a.len(),

-            forall i:int  :: pos <= i < pos + sz ==> a[i] == 0,

-            forall|i: int, j: int| (0 <= i < j < a.len() and getSize(i, j) > sz) ==> exists|k: int| i <= k <= j and a[k] != 0

+spec fn getSize(i: int, j: int) -> int

 {

+    j - i + 1    

 }

 

+

+

+

+

+

+

+pub fn longestZero(a: &[int]) -> (sz: int, pos: int)

+    requires(1 <= a.len())

+    ensures(|result: (int, int)| {

+        let (sz, pos) = result;

+        0 <= sz <= a.len() &&

+        0 <= pos < a.len() &&

+        pos + sz <= a.len() &&

+        (forall|i: int| pos <= i < pos + sz ==> a[i as usize] == 0) &&

+        (forall|i: int, j: int| (0 <= i < j < a.len() && getSize(i, j) > sz) ==> exists|k: int| i <= k <= j && a[k as usize] != 0)

+    })

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_2.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_2.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/verified-using-dafny_tmp_tmp7jatpjyn_longestZero_spec_task_2.rs
@@ -1,19 +1,30 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+fn getSize(i: int, j: int) -> int

+{

+    j - i + 1    

+}

 

-verus! {

 

-fn longestZero(a: Vec<int>) -> sz: int, pos: int

-    requires 1 <= a.len()

-    ensures 0 <= sz <= a.len(),

-            0 <= pos < a.len(),

-            pos + sz <= a.len(),

-            forall i:int  :: pos <= i < pos + sz ==> a[i] == 0,

-            forall|i: int, j: int| (0 <= i < j < a.len() and getSize(i, j) > sz) ==> exists|k: int| i <= k <= j and a[k] != 0

+

+

+

+

+

+pub fn longestZero(a: &[int]) -> (sz: int, pos: int)

+    requires(1 <= a.len())

+    ensures(|result: (int, int)| {

+        let (sz, pos) = result;

+        0 <= sz <= a.len() &&

+        0 <= pos < a.len() &&

+        pos + sz <= a.len() &&

+        (forall|i: int| pos <= i < pos + sz ==> a[i] == 0) &&

+        (forall|i: int, j: int| (0 <= i < j < a.len() && getSize(i, j) > sz) ==> exists|k: int| i <= k <= j && a[k] != 0)

+    })

 {

 }

 

+

+

+pub fn Main()

+{

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_Verificacion_torneo_spec_task_1.rs
@@ -1,16 +1,19 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn torneo(Valores: array?<real>, i: int, j: int, k: int) -> pos_padre: int, pos_madre: int

-    requires Valores != null and Valores.len() >= 20 and Valores.len() < 50 and i >= 0 and j >= 0 and k >= 0,

-             i < Valores.len() and j < Valores.len() and k < Valores.len() and i != j and j != k and k != i

-    ensures exists p, q, r | p in

+pub fn torneo(valores: &[f64], i: usize, j: usize, k: usize) -> (pos_padre: usize, pos_madre: usize)

+    requires(

+        valores.len() >= 20 && valores.len() < 50 && 

+        i < valores.len() && j < valores.len() && k < valores.len() && 

+        i != j && j != k && k != i

+    )

+    ensures(|result: (usize, usize)| {

+        let (pos_padre, pos_madre) = result;

+        exists|p: usize, q: usize, r: usize| {

+            &&& (p == i || p == j || p == k)

+            &&& (q == i || q == j || q == k)

+            &&& (r == i || r == j || r == k)

+            &&& p != q && q != r && p != r

+            &&& valores[p] >= valores[q] && valores[q] >= valores[r]

+            &&& pos_padre == p && pos_madre == q

+        }

+    })

 {

-}

-

 }

================================================================================
Comparing translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec_task_1.rs
================================================================================
--- verus_specs_no_llm/translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec_task_1.rs
+++ verus_specs/translations/atomizer_supported_tasks_dep_only/vfag_tmp_tmpc29dxm1j_sumar_componentes_spec_task_1.rs
@@ -1,15 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn suma_componentes(V: array?<int>) -> (suma: int)

-    requires V != null

-    ensures suma == suma_aux(V, 0)

+pub fn suma_componentes(V: &[i32]) -> (suma: i32)

+    requires(V.len() >= 0)

+    ensures(|result: i32| result == suma_aux(V, 0))

 {

 }

 

+spec fn suma_aux(V: &[i32], n: int) -> int

+    requires(V.len() >= 0)

+    requires(0 <= n <= V.len())

+    decreases(V.len() - n)

+{

+    if n == V.len() {

+        0

+    } else {

+        V[n] + suma_aux(V, n + 1)

+    }

 }

================================================================================
Comparing translations/clover/Clover_abs_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_abs_spec.rs
+++ verus_specs/translations/clover/Clover_abs_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Abs(x: int) -> (y: int)

-    ensures x>=0 ==> x==y,

-            x<0 ==> x+y==0

+pub fn abs(x: int) -> (y: int)

+    ensures(x >= 0 ==> x == y)

+    ensures(x < 0 ==> x + y == 0)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_all_digits_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_all_digits_spec.rs
+++ verus_specs/translations/clover/Clover_all_digits_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn allDigits(s: String) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < s.len() ==> s[i] in "0123456789")

+pub fn allDigits(s: &str) -> (result: bool)

+    ensures(result <==> (forall|i: int| 0 <= i < s.len() ==> "0123456789".contains(s[i as usize])))

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_array_append_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_array_append_spec.rs
+++ verus_specs/translations/clover/Clover_array_append_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn append(a: Vec<int>, b: int) -> (c: Vec<int>)

-    ensures a[..] + [b] == c[..]

+pub fn append(a: &[int], b: int) -> (c: Vec<int>)

+    ensures(a@ + [b] == c@)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_array_concat_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_array_concat_spec.rs
+++ verus_specs/translations/clover/Clover_array_concat_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn concat(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    ensures c.len()==b.len()+a.len(),

-            forall|k: int| 0 <= k < a.len() ==> c[k] == a[k],

-            forall|k: int| 0 <= k < b.len() ==> c[k+a.len()] == b[k]

+pub fn concat(a: &[i32], b: &[i32]) -> Vec<i32>

+    ensures(|result: Vec<i32>| result.len() == b.len() + a.len())

+    ensures(|result: Vec<i32>| forall|k: usize| 0 <= k < a.len() ==> result[k] == a[k])

+    ensures(|result: Vec<i32>| forall|k: usize| 0 <= k < b.len() ==> result[k + a.len()] == b[k])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_array_product_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_array_product_spec.rs
+++ verus_specs/translations/clover/Clover_array_product_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arrayProduct(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] * b[i]==c[i]

+pub fn arrayProduct(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i && i < a.len() ==> a[i] * b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_array_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_array_sum_spec.rs
+++ verus_specs/translations/clover/Clover_array_sum_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn arraySum(a: Vec<int>, b: Vec<int>) -> (c: Vec<int>)

-    requires a.len()==b.len()

-    ensures c.len()==a.len(),

-            forall|i: int| 0 <= i< a.len()==> a[i] + b[i]==c[i]

+pub fn arraySum(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|c: Vec<i32>| c.len() == a.len())

+    ensures(|c: Vec<i32>| forall|i: usize| 0 <= i && i < a.len() ==> a[i] + b[i] == c[i])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_avg_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_avg_spec.rs
+++ verus_specs/translations/clover/Clover_avg_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeAvg(a: int, b: int) -> (avg: int)

-    ensures avg == (a+b)/2

+pub fn compute_avg(a: int, b: int) -> (avg: int)

+    ensures(avg == (a + b) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_below_zero_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_below_zero_spec.rs
+++ verus_specs/translations/clover/Clover_below_zero_spec.rs
@@ -1,18 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn below_zero(operations: Seq<int>) -> s: Vec<int>, result: bool

-    ensures s.len() == operations.len() + 1,

-            s[0]==0,

-            forall|i: int| 0 <= i < s.len()-1 ==> s[i+1]==s[i]+operations[i],

-            result == true ==> (exists|i: int| 1 <= i <= operations.len() and s[i] < 0),

-            result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

+pub fn below_zero(operations: Seq<int>) -> (s: Vec<int>, result: bool)

+    ensures

+        s.len() == operations.len() + 1,

+        s[0] == 0,

+        forall|i: int| 0 <= i < s.len() - 1 ==> s[i + 1] == s[i] + operations[i],

+        result == true ==> (exists|i: int| 1 <= i <= operations.len() && s[i] < 0),

+        result == false ==> forall|i: int| 0 <= i < s.len() ==> s[i] >= 0,

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_binary_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_binary_search_spec.rs
+++ verus_specs/translations/clover/Clover_binary_search_spec.rs
@@ -1,18 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, key: int) -> (n: int)

-    requires forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j]

-    ensures 0<= n <=a.len(),

-            forall|i: int| 0<= i < n ==> a[i] < key,

-            n == a.len() ==> forall|i: int| 0 <= i < a.len() ==> a[i] < key,

-            forall|i: int| n<= i < a.len() ==> a[i]>=key

+pub fn binary_search(a: &[i32], key: i32) -> (n: usize)

+    requires(

+        forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    ensures(|n: usize|

+        0 <= n <= a.len() &&

+        (forall|i: usize| 0 <= i < n ==> a[i] < key) &&

+        (n == a.len() ==> forall|i: usize| 0 <= i < a.len() ==> a[i] < key) &&

+        (forall|i: usize| n <= i < a.len() ==> a[i] >= key)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_cal_ans_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_cal_ans_spec.rs
+++ verus_specs/translations/clover/Clover_cal_ans_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalDiv() -> x: int, y: int

-    ensures x==191/7,

-            y==191%7

+pub fn CalDiv() -> (x: int, y: int)

+    ensures(x == 191 / 7)

+    ensures(y == 191 % 7)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_cal_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_cal_sum_spec.rs
+++ verus_specs/translations/clover/Clover_cal_sum_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Sum(N: int) -> (s: int)

-    requires N >= 0

-    ensures s == N * (N + 1) / 2

+pub fn sum(n: int) -> (s: int)

+    requires(n >= 0)

+    ensures(s == n * (n + 1) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_canyon_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_canyon_search_spec.rs
+++ verus_specs/translations/clover/Clover_canyon_search_spec.rs
@@ -1,18 +1,18 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CanyonSearch(a: Vec<int>, b: Vec<int>) -> (d: nat)

-    requires a.len() !=0 and b.len()!=0,

-             forall|i: int, j: int| 0<=i<j<a.len() ==> a[i]<=a[j],

-             forall|i: int, j: int| 0<=i<j<b.len() ==> b[i]<=b[j]

-    ensures exists|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() and d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j]),

-            forall|i: int, j: int| 0<=i<a.len() and 0<=j<b.len() ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])

+pub fn canyon_search(a: &[i32], b: &[i32]) -> (d: nat)

+    requires(

+        a.len() != 0 && b.len() != 0

+    )

+    requires(

+        forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

+    )

+    requires(

+        forall|i: int, j: int| 0 <= i < j < b.len() ==> b[i] <= b[j]

+    )

+    ensures(|d: nat|

+        exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() && d == if a[i] < b[j] { (b[j] - a[i]) as nat } else { (a[i] - b[j]) as nat }

+    )

+    ensures(|d: nat|

+        forall|i: int, j: int| 0 <= i < a.len() && 0 <= j < b.len() ==> d <= if a[i] < b[j] { (b[j] - a[i]) as nat } else { (a[i] - b[j]) as nat }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_convert_map_key_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_convert_map_key_spec.rs
+++ verus_specs/translations/clover/Clover_convert_map_key_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn convert_map_key(inputs: map<nat, bool>, f: nat->nat) -> r: map<nat, bool>

-    requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)

-    ensures forall|k: int| k in inputs <==> f(k) in r,

-            forall|k: int| k in inputs ==> r[f(k)] == inputs[k]

+pub fn convert_map_key(inputs: Map<nat, bool>, f: spec_fn(nat) -> nat) -> (r: Map<nat, bool>)

+    requires(

+        forall|n1: nat, n2: nat| n1 != n2 ==> f(n1) != f(n2)

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) <==> r.contains_key(f(k))

+    )

+    ensures(|r: Map<nat, bool>|

+        forall|k: nat| inputs.contains_key(k) ==> r[f(k)] == inputs[k]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_copy_part_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_copy_part_spec.rs
+++ verus_specs/translations/clover/Clover_copy_part_spec.rs
@@ -1,19 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn copy(src: Vec<int>, sStart: nat, dest: Vec<int>, dStart: nat, len: nat) -> (r: Vec<int>)

-    requires src.len() >= sStart + len,

-             dest.len() >= dStart + len

-    ensures r.len() == dest.len(),

-            r[..dStart] == dest[..dStart],

-            r[dStart + len..] == dest[dStart + len..],

-            r[dStart..len+dStart] == src[sStart..len+sStart]

+pub fn copy(src: &[i32], sStart: usize, dest: &[i32], dStart: usize, len: usize) -> Vec<i32>

+    requires 

+        src.len() >= sStart + len,

+        dest.len() >= dStart + len,

+    ensures |r: Vec<i32>|

+        r.len() == dest.len() &&

+        r.subrange(0, dStart as int) == dest.subrange(0, dStart as int) &&

+        r.subrange((dStart + len) as int, dest.len() as int) == dest.subrange((dStart + len) as int, dest.len() as int) &&

+        r.subrange(dStart as int, (len + dStart) as int) == src.subrange(sStart as int, (len + sStart) as int)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_count_lessthan_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_count_lessthan_spec.rs
+++ verus_specs/translations/clover/Clover_count_lessthan_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLessThan(numbers: set<int>, threshold: int) -> (count: int)

-    ensures count == set i .len() i in numbers and i < threshold|

+pub fn count_less_than(numbers: Set<int>, threshold: int) -> (count: int)

+    ensures count == (numbers.filter(|i: int| *i < threshold)).len()

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_double_quadruple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_double_quadruple_spec.rs
+++ verus_specs/translations/clover/Clover_double_quadruple_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DoubleQuadruple(x: int) -> a: int, b: int

-    ensures a == 2 * x and b == 4 * x

+pub fn DoubleQuadruple(x: int) -> (a: int, b: int)

+    ensures(a == 2 * x && b == 4 * x)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_even_list_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_even_list_spec.rs
+++ verus_specs/translations/clover/Clover_even_list_spec.rs
@@ -1,14 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindEvenNumbers(arr: Vec<int>) -> (evenNumbers: Vec<int>)

-    ensures forall x

+pub fn find_even_numbers(arr: &[i32]) -> Vec<i32>

+    ensures(forall|x: i32| arr.contains(&x) && (x % 2 == 0) ==> result@.contains(&x))

+    ensures(forall|x: i32| !arr.contains(&x) ==> !result@.contains(&x))

+    ensures(forall|k: int| 0 <= k < result@.len() ==> result@[k] % 2 == 0)

+    ensures(forall|k: int, l: int| 0 <= k < l < result@.len() ==>

+        exists|n: int, m: int| 0 <= n < m < arr@.len() && result@[k] == arr@[n] && result@[l] == arr@[m])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_find_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_find_spec.rs
+++ verus_specs/translations/clover/Clover_find_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Find(a: Vec<int>, key: int) -> (index: int)

-    ensures -1<=index<a.len(),

-            index!=-1 ==> a[index]==key and (forall|i: int| 0 <= i < index ==> a[i] != key),

-            index == -1 ==> (forall|i: int|0 <= i < a.len() ==> a[i] != key)

+pub fn find(a: &[i32], key: i32) -> (index: i32)

+    ensures(

+        -1 <= index < a.len(),

+        index != -1 ==> a[index as int] == key && forall|i: int| 0 <= i < index ==> a[i] != key,

+        index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != key,

+    )

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_integer_square_root_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_integer_square_root_spec.rs
+++ verus_specs/translations/clover/Clover_integer_square_root_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareRoot(N: nat) -> (r: nat)

-    ensures r*r <= N < (r+1)*(r+1)

+pub fn square_root(n: nat) -> (r: nat)

+    ensures(r * r <= n < (r + 1) * (r + 1))

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_is_even_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_is_even_spec.rs
+++ verus_specs/translations/clover/Clover_is_even_spec.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ComputeIsEven(x: int) -> (is_even: bool)

-    ensures (x % 2 == 0)==is_even

+pub fn compute_is_even(x: int) -> (is_even: bool)

+    ensures

+        (x % 2 == 0) == is_even

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_is_palindrome_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_is_palindrome_spec.rs
+++ verus_specs/translations/clover/Clover_is_palindrome_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPalindrome(x: Seq<char>) -> (result: bool)

-    ensures result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1])

+pub fn is_palindrome(x: Seq<char>) -> (result: bool)

+    ensures(result <==> (forall|i: int| 0 <= i < x.len() ==> x[i] == x[x.len() - i - 1]))

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_linear_search1_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_linear_search1_spec.rs
+++ verus_specs/translations/clover/Clover_linear_search1_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    ensures 0<=n<=a.len(),

-            n==a.len() or a[n]==e,

-            forall|i: int|0<=i < n ==> e!=a[i]

+pub fn linear_search(a: &[i32], e: i32) -> n: usize

+    ensures(n <= a.len())

+    ensures(n == a.len() || a[n as int] == e)

+    ensures(forall|i: int| 0 <= i < n ==> e != a[i])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_linear_search2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_linear_search2_spec.rs
+++ verus_specs/translations/clover/Clover_linear_search2_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LinearSearch(a: Vec<int>, e: int) -> (n: int)

-    requires exists|i: int|0<=i<a.len() and a[i]==e

-    ensures 0<=n<a.len() and a[n]==e,

-            forall|k: int| 0 <= k < n ==> a[k]!=e

+pub fn linear_search(a: &[int], e: int) -> (n: int)

+    requires(exists|i: int| 0 <= i < a.len() && a[i] == e)

+    ensures(|n: int| 0 <= n < a.len() && a[n] == e)

+    ensures(|n: int| forall|k: int| 0 <= k < n ==> a[k] != e)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_longest_prefix_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_longest_prefix_spec.rs
+++ verus_specs/translations/clover/Clover_longest_prefix_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LongestCommonPrefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

-    ensures prefix.len() <= str1.len() and prefix == str1[0..prefix.len()]and prefix.len() <= str2.len() and prefix == str2[0..prefix.len()],

-            prefix.len()==str1.len() | .len()prefix==.len()str2 .len() (str1[.len()prefix]!=str2[.len()prefix|])

+pub fn longest_common_prefix(str1: Seq<char>, str2: Seq<char>) -> (prefix: Seq<char>)

+    ensures(|prefix| <= |str1| && prefix == str1.subrange(0, |prefix| as int) && |prefix| <= |str2| && prefix == str2.subrange(0, |prefix| as int))

+    ensures(|prefix| == |str1| || |prefix| == |str2| || (str1[|prefix| as int] != str2[|prefix| as int]))

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_match_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_match_spec.rs
+++ verus_specs/translations/clover/Clover_match_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Match(s: String, p: String) -> (b: bool)

-    requires s.len() == p.len()

-    ensures b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] or p[n] == '?'

+pub fn Match(s: &str, p: &str) -> (b: bool)

+    requires(s.len() == p.len())

+    ensures(b <==> forall|n: int| 0 <= n < s.len() ==> s[n] == p[n] || p[n] == '?')

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_max_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_max_array_spec.rs
+++ verus_specs/translations/clover/Clover_max_array_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn maxArray(a: Vec<int>) -> (m: int)

-    requires a.len() >= 1

-    ensures forall|k: int| 0 <= k < a.len() ==> m >= a[k],

-            exists|k: int| 0 <= k < a.len() and m == a[k]

+pub fn maxArray(a: &[i32]) -> (m: i32)

+    requires(a.len() >= 1)

+    ensures(forall|k: usize| 0 <= k < a.len() ==> m >= a[k])

+    ensures(exists|k: usize| 0 <= k < a.len() && m == a[k])

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_min_array_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_min_array_spec.rs
+++ verus_specs/translations/clover/Clover_min_array_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn minArray(a: Vec<int>) -> (r: int)

+pub fn minArray(a: &[i32]) -> (r: i32)

     requires a.len() > 0

-    ensures forall|i: int| 0 <= i < a.len() ==> r <= a[i],

-            exists|i: int| 0 <= i < a.len() and r == a[i]

+    ensures forall|i: usize| 0 <= i < a.len() ==> r <= a[i]

+    ensures exists|i: usize| 0 <= i < a.len() && r == a[i]

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_min_of_two_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_min_of_two_spec.rs
+++ verus_specs/translations/clover/Clover_min_of_two_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(x: int, y: int) -> (z: int)

-    ensures x<=y ==> z==x,

-            x>y ==> z==y

+pub fn Min(x: int, y: int) -> (z: int)

+    ensures(x <= y ==> z == x)

+    ensures(x > y ==> z == y)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_multi_return_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_multi_return_spec.rs
+++ verus_specs/translations/clover/Clover_multi_return_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultipleReturns(x: int, y: int) -> more: int, less: int

-    ensures more == x+y,

-            less == x-y

+pub fn MultipleReturns(x: int, y: int) -> (more: int, less: int)

+    ensures 

+        more == x + y,

+        less == x - y,

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_online_max_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_online_max_spec.rs
+++ verus_specs/translations/clover/Clover_online_max_spec.rs
@@ -1,20 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn onlineMax(a: Vec<int>, x: int) -> ghost m: int, p: int

-    requires 1<=x<a.len(),

-             a.len()!=0

-    ensures x<=p<a.len(),

-            forall|i: int|0<=i<x==> a[i]<=m,

-            exists|i: int|0<=i<x and a[i]==m,

-            x<=p<a.len()-1 ==> (forall|i: int|0<=i<p ==> a[i]<a[p]),

-            (forall|i: int|x<=i<a.len() and a[i]<=m) ==> p==a.len()-1

+pub fn onlineMax(a: &[int], x: int) -> (ghost m: int, p: int)

+    requires(1 <= x < a.len())

+    requires(a.len() != 0)

+    ensures(|ret: (int, int)| x <= ret.1 < a.len())

+    ensures(|ret: (int, int)| forall|i: int| 0 <= i < x ==> a[i] <= ret.0)

+    ensures(|ret: (int, int)| exists|i: int| 0 <= i < x && a[i] == ret.0)

+    ensures(|ret: (int, int)| x <= ret.1 < a.len() - 1 ==> (forall|i: int| 0 <= i < ret.1 ==> a[i] < a[ret.1]))

+    ensures(|ret: (int, int)| (forall|i: int| x <= i < a.len() && a[i] <= ret.0) ==> ret.1 == a.len() - 1)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_quotient_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_quotient_spec.rs
+++ verus_specs/translations/clover/Clover_quotient_spec.rs
@@ -1,15 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(x: nat, y: nat) -> r: int, q: int

-    requires y != 0

-    ensures q * y + r == x and 0 <= r < y and 0 <= q

+pub fn quotient(x: nat, y: nat) -> (r: int, q: int)

+    requires(y != 0)

+    ensures(|result: (int, int)| {

+        let (r, q) = result;

+        q * y + r == x && 0 <= r < y && 0 <= q

+    })

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_remove_front_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_remove_front_spec.rs
+++ verus_specs/translations/clover/Clover_remove_front_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn remove_front(a: Vec<int>) -> (c: Vec<int>)

-    requires a.len()>0

-    ensures a[1..] == c[..]

+pub fn remove_front(a: &[i32]) -> (c: Vec<i32>)

+    requires(a.len() > 0)

+    ensures(a.subrange(1, a.len() as int) =~= c@)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_return_seven_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_return_seven_spec.rs
+++ verus_specs/translations/clover/Clover_return_seven_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn M(x: int) -> (seven: int)

-    ensures seven==7

+pub fn M(x: int) -> (seven: int)

+    ensures seven == 7

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_rotate_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_rotate_spec.rs
+++ verus_specs/translations/clover/Clover_rotate_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn rotate(a: Vec<int>, offset: int) -> (b: Vec<int>)

-    requires 0<=offset

-    ensures b.len()==a.len(),

-            forall|i: int|0<=i<a.len() ==>  b[i]==a[(i+offset)%a.len()]

+pub fn rotate(a: &[i32], offset: i32) -> Vec<i32>

+    requires(0 <= offset)

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> result[i] == a[(i + offset as usize) % a.len()])

 {

-}

-

+    unimplemented!()

 }

================================================================================
Comparing translations/clover/Clover_slope_search_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_slope_search_spec.rs
+++ verus_specs/translations/clover/Clover_slope_search_spec.rs
@@ -1,18 +1,23 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SlopeSearch(a: array2<int>, key: int) -> m: int, n: int

-    requires forall|i: int, j: int, j': int|0<=i<a.Length0 and 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j'],

-             forall|i: int, i': int, j: int|0<=i<i'<a.Length0 and 0<=j<a.Length1 ==> a[i,j]<=a[i',j],

-             exists|i: int, j: int| 0<=i<a.Length0 and 0<=j<a.Length1 and a[i,j]==key

-    ensures 0<=m<a.Length0 and 0<=n<a.Length1,

-            a[m,n]==key

+pub fn SlopeSearch(a: &Array2<i32>, key: i32) -> (m: i32, n: i32)

+    requires(

+        forall|i: usize, j: usize, j_prime: usize| 

+            0 <= i < a.len0() && 0 <= j < j_prime && j_prime < a.len1() ==> 

+            a.index((i, j)) <= a.index((i, j_prime))

+    )

+    requires(

+        forall|i: usize, i_prime: usize, j: usize| 

+            0 <= i < i_prime && i_prime < a.len0() && 0 <= j < a.len1() ==> 

+            a.index((i, j)) <= a.index((i_prime, j))

+    )

+    requires(

+        exists|i: usize, j: usize| 

+            0 <= i < a.len0() && 0 <= j < a.len1() && a.index((i, j)) == key

+    )

+    ensures(

+        0 <= m < a.len0() && 0 <= n < a.len1()

+    )

+    ensures(

+        a.index((m as usize, n as usize)) == key

+    )

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_swap_arith_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_swap_arith_spec.rs
+++ verus_specs/translations/clover/Clover_swap_arith_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapArithmetic(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn swap_arithmetic(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_swap_bitvector_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_swap_bitvector_spec.rs
+++ verus_specs/translations/clover/Clover_swap_bitvector_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapBitvectors(X: bv8, Y: bv8) -> x: bv8, y: bv8

-    ensures x==Y,

-            y==X

+pub fn swap_bitvectors(X: u8, Y: u8) -> (x: u8, y: u8)

+    ensures(x == Y)

+    ensures(y == X)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_swap_sim_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_swap_sim_spec.rs
+++ verus_specs/translations/clover/Clover_swap_sim_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SwapSimultaneous(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn SwapSimultaneous(X: int, Y: int) -> (x: int, y: int)

+    ensures(x == Y),

+    ensures(y == X),

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_swap_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_swap_spec.rs
+++ verus_specs/translations/clover/Clover_swap_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(X: int, Y: int) -> x: int, y: int

-    ensures x==Y,

-            y==X

+pub fn Swap(X: int, Y: int) -> (x: int, y: int)

+    ensures

+        x == Y,

+        y == X,

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_triple2_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_triple2_spec.rs
+++ verus_specs/translations/clover/Clover_triple2_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_triple3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_triple3_spec.rs
+++ verus_specs/translations/clover/Clover_triple3_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_triple4_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_triple4_spec.rs
+++ verus_specs/translations/clover/Clover_triple4_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_triple_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_triple_spec.rs
+++ verus_specs/translations/clover/Clover_triple_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Triple(x: int) -> (r: int)

-    ensures r==3*x

+pub fn triple(x: int) -> (r: int)

+    ensures(r == 3 * x)

 {

-}

-

 }

================================================================================
Comparing translations/clover/Clover_two_sum_spec.rs
================================================================================
--- verus_specs_no_llm/translations/clover/Clover_two_sum_spec.rs
+++ verus_specs/translations/clover/Clover_two_sum_spec.rs
@@ -1,18 +1,17 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn twoSum(nums: Vec<int>, target: int) -> i: int, j: int

-    requires nums.len() > 1,

-             exists|i: int, j: int|0 <= i < j < nums.len() and  nums[i] + nums[j] == target

-    ensures 0 <= i < j < nums.len() and nums[i] + nums[j] == target,

-            forall|ii: int, jj: int| (0 <= ii < i and ii < jj < nums.len())  ==> nums[ii] + nums[jj] != target,

-            forall|jj: int| i < jj < j ==> nums[i] + nums[jj] != target

+pub fn twoSum(nums: &[i32], target: i32) -> (i: usize, j: usize)

+    requires(nums.len() > 1)

+    requires(exists|i: usize, j: usize| 0 <= i < j < nums.len() && nums[i] + nums[j] == target)

+    ensures(|result: (usize, usize)| {

+        let (i, j) = result;

+        0 <= i < j < nums.len() && nums[i] + nums[j] == target

+    })

+    ensures(|result: (usize, usize)| {

+        let (i, j) = result;

+        forall|ii: usize, jj: usize| (0 <= ii < i && ii < jj < nums.len()) ==> nums[ii] + nums[jj] != target

+    })

+    ensures(|result: (usize, usize)| {

+        let (i, j) = result;

+        forall|jj: usize| i < jj < j ==> nums[i] + nums[jj] != target

+    })

 {

-}

-

 }

================================================================================
Comparing translations/first_8/630-dafny_tmp_tmpz2kokaiq_Solution_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/630-dafny_tmp_tmpz2kokaiq_Solution_no_hints.rs
+++ verus_specs/translations/first_8/630-dafny_tmp_tmpz2kokaiq_Solution_no_hints.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BinarySearch(a: Vec<int>, x: int) -> (index: int)

-    requires sorted(a)

-    ensures 0 <= index < a.len() ==> a[index] == x,

-            index == -1 ==> forall i : int :: 0 <= i < a.len() ==> a[i] != x

-{

+spec fn sorted(a: &[int]) -> bool {

+    forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j]

 }

 

+pub fn BinarySearch(a: &[int], x: int) -> (index: int)

+    requires(sorted(a))

+    ensures(0 <= index < a.len() ==> a[index] == x)

+    ensures(index == -1 ==> forall|i: int| 0 <= i < a.len() ==> a[i] != x)

+{

 }

================================================================================
Comparing translations/first_8/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_no_hints.rs
+++ verus_specs/translations/first_8/AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_no_hints.rs
@@ -1,31 +1,108 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn Sorted(q: Seq<int>) -> bool {

+

+spec fn sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

-spec fn Inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {

-    (i <= a1.len()) and (i <= a2.len()) and (i+mid <= a.len()) and

-    (a1[..i] == a[..i]) and (a2[..i] == a[mid..(i+mid)])

-}

-spec fn InvSorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

-    i <= c.len() and j <= d.len() and i + j <= b.len() and

-	((i+j > 0 and i < c.len()) ==> (b[j + i - 1] <= c[i])) and

-	((i+j > 0 and j < d.len()) ==> (b[j + i - 1] <= d[j])) and

-	Sorted(b[..i+j])

-}

-spec fn InvSubSet(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

-    i <= c.len() and j <= d.len() and i + j <= b.len() and

-	multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])

+

+

+pub fn merge_sort(a: &[int]) -> (b: Vec<int>)

+    ensures

+        b.len() == a.len() && sorted(b@) && a@.to_multiset() == b@.to_multiset()

+{

 }

 

-fn MergeSort(a: Vec<int>) -> (b: Vec<int>)

-    ensures b.len() == a.len() and Sorted(b[..]) and multiset(a[..]) == multiset(b[..])

+

+spec fn inv(a: Seq<int>, a1: Seq<int>, a2: Seq<int>, i: nat, mid: nat) -> bool {

+    (i <= a1.len()) && (i <= a2.len()) && (i + mid <= a.len()) &&

+    (a1.subrange(0, i as int) == a.subrange(0, i as int)) && (a2.subrange(0, i as int) == a.subrange(mid as int, (i + mid) as int))

+}

+

+

+pub fn merge(b: &mut [int], c: &[int], d: &[int])

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@)

+    ensures

+        sorted(b@) && b@.to_multiset() == c@.to_multiset() + d@.to_multiset()

+{

+}

+

+

+pub fn merge_loop(b: &mut [int], c: &[int], d: &[int], i0: usize, j0: usize) -> (i: usize, j: usize)

+    requires

+        b.len() == c.len() + d.len(),

+        sorted(c@) && sorted(d@),

+        i0 <= c.len() && j0 <= d.len() && i0 + j0 <= b.len(),

+        inv_sub_set(b@, c@, d@, i0, j0),

+        inv_sorted(b@, c@, d@, i0, j0),

+        i0 + j0 < b.len()

+    ensures

+        i <= c.len() && j <= d.len() && i + j <= b.len(),

+        inv_sub_set(b@, c@, d@, i, j),

+        inv_sorted(b@, c@, d@, i, j),

+        0 <= c.len() - i < c.len() - i0 || (c.len() - i == c.len() - i0 && 0 <= d.len() - j < d.len() - j0)

+{

+}

+

+

+spec fn inv_sorted(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

+    i <= c.len() && j <= d.len() && i + j <= b.len() &&

+    ((i + j > 0 && i < c.len()) ==> (b[(j + i - 1) as int] <= c[i as int])) &&

+    ((i + j > 0 && j < d.len()) ==> (b[(j + i - 1) as int] <= d[j as int])) &&

+    sorted(b.subrange(0, (i + j) as int))

+}

+

+

+spec fn inv_sub_set(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat) -> bool {

+    i <= c.len() && j <= d.len() && i + j <= b.len() &&

+    b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+}

+

+

+proof fn lemma_multisets_equals(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat)

+    requires

+        i == c.len(),

+        j == d.len(),

+        i + j == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+    ensures

+        b.to_multiset() == c.to_multiset() + d.to_multiset()

+{

+}

+

+

+proof fn lemma_inv_subset_take_value_from_c(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat)

+    requires

+        i < c.len(),

+        j <= d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[(i + j) as int] == c[i as int]

+    ensures

+        b.subrange(0, (i + j + 1) as int).to_multiset() == c.subrange(0, (i + 1) as int).to_multiset() + d.subrange(0, j as int).to_multiset()

+{

+}

+

+

+proof fn lemma_inv_subset_take_value_from_d(b: Seq<int>, c: Seq<int>, d: Seq<int>, i: nat, j: nat)

+    requires

+        i <= c.len(),

+        j < d.len(),

+        i + j < b.len(),

+        c.len() + d.len() == b.len(),

+        b.subrange(0, (i + j) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, j as int).to_multiset(),

+        b[(i + j) as int] == d[j as int]

+    ensures

+        b.subrange(0, (i + j + 1) as int).to_multiset() == c.subrange(0, i as int).to_multiset() + d.subrange(0, (j + 1) as int).to_multiset()

+{

+}

+

+

+pub fn main()

 {

 }

 


================================================================================
Comparing translations/first_8/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_no_hints.rs
+++ verus_specs/translations/first_8/BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_no_hints.rs
@@ -1,35 +1,92 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn BinarySearchTree(tree: Tree) -> bool {

-    match tree

-  case Empty => true

-  case Node(_,_,_) =>

-    (tree.left == Empty | tree.left.value < tree.value)

-    and (tree.right == Empty .len()| tree.right.value > tree.value)

-    and BinarySearchTree(tree.left) and BinarySearchTree(tree.right)

-    and minValue(tree.right, tree.value) and maxValue(tree.left, tree.value)

-}

-spec fn maxValue(tree: Tree, max: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (max > v) and maxValue(left, max) and maxValue(right, max)

-}

-spec fn minValue(tree: Tree, min: int) -> bool {

-    match tree

-  case Empty => true

-  case Node(left,v,right) => (min < v) and minValue(left, min) and minValue(right, min)

+pub enum Tree {

+    Empty,

+    Node { left: Box<Tree>, value: int, right: Box<Tree> }

 }

 

-fn GetMin(tree: Tree) -> (res: int)

-    requires BinarySearchTree(tree)

-    ensures minValue(tree, res)

+

+pub spec fn BinarySearchTree(tree: Tree) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value, right } => {

+            ((*left == Tree::Empty) || (left.get_Node_value() < value))

+            && ((*right == Tree::Empty) || (right.get_Node_value() > value))

+            && BinarySearchTree(*left) && BinarySearchTree(*right)

+            && minValue(*right, value) && maxValue(*left, value)

+        }

+    }

+}

+

+

+pub spec fn maxValue(tree: Tree, max: int) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => (max > v) && maxValue(*left, max) && maxValue(*right, max)

+    }

+}

+

+

+pub spec fn minValue(tree: Tree, min: int) -> bool {

+    match tree {

+        Tree::Empty => true,

+        Tree::Node { left, value: v, right } => (min < v) && minValue(*left, min) && minValue(*right, min)

+    }

+}

+

+

+pub fn GetMin(tree: Tree) -> (res: int)

+    requires(BinarySearchTree(tree))

+    ensures(minValue(tree, res))

 {

 }

 

+

+pub fn GetMax(tree: Tree) -> (res: int)

+    requires(BinarySearchTree(tree))

+    ensures(maxValue(tree, res))

+{

+}

+

+

+pub fn insert(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(BinarySearchTree(res))

+{

+}

+

+

+pub fn insertRecursion(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(res != Tree::Empty ==> BinarySearchTree(res))

+    ensures(forall |x: int| minValue(tree, x) && x < value ==> minValue(res, x))

+    ensures(forall |x: int| maxValue(tree, x) && x > value ==> maxValue(res, x))

+{

+}

+

+

+pub fn delete(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(BinarySearchTree(res))

+    ensures(res != Tree::Empty ==> BinarySearchTree(res))

+{

+}

+

+

+pub fn deleteRecursion(tree: Tree, value: int) -> (res: Tree)

+    requires(BinarySearchTree(tree))

+    ensures(BinarySearchTree(res))

+    ensures(res != Tree::Empty ==> BinarySearchTree(res))

+{

+}

+

+

+pub fn Inorder(tree: Tree) {

+}

+

+

+pub fn Postorder(tree: Tree) {

+}

+

+

+pub fn Main() {

 }

================================================================================
Comparing translations/first_8/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_no_hints.rs
+++ verus_specs/translations/first_8/assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_no_hints.rs
@@ -1,61 +1,54 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

+pub fn Main() {

+    

+}

 

 spec fn Sorted(q: Seq<int>) -> bool {

     forall|i: int, j: int| 0 <= i <= j < q.len() ==> q[i] <= q[j]

 }

+

 spec fn HasAddends(q: Seq<int>, x: int) -> bool {

-    exists|i: int, j: int| 0 <= i < j < q.len() and q[i] + q[j] == x

-}

-spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat)

-	requires IsValidIndex(q, i) && IsValidIndex(q, j) -> bool {

-    q[i] + q[j] == x

-}

-spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat)

-	requires AreOreredIndices(q, i, j) -> bool {

-    HasAddends(q[i..(j + 1)], x)

-}

-spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

-    AreOreredIndices(q, i, j) and

-	HasAddendsInIndicesRange(q, x, i, j) and

-	AreAddendsIndices(q, sum, i, j)

+    exists|i: int, j: int| 0 <= i < j < q.len() && q[i] + q[j] == x

 }

 

-fn Main()

+pub fn FindAddends(q: Seq<int>, x: int) -> (i: nat, j: nat)

+    requires(Sorted(q) && HasAddends(q, x))

+    ensures(i < j < q.len() && q[i as int] + q[j as int] == x)

 {

-	var q: = [1, 2, 4, 5, 6, 7, 10, 23];

-	var i, j: = FindAddends(q, 10);

-	print "Searching for addends of 10 in q == [1, 2, 4, 5, 6, 7, 10, 23]: \n";

-	print "Found that q[";

-	print i;

-	print "] + q[";

-	print j;

-	print "] == ";

-	print q[i];

-	print " + ";

-	print q[j];

-	print " == 10";

+    

 }

 

-predicate Sorted(q: seq<int>)

-{

-	forall i, j: : 0 <= i <= j < |q| ==> q[i] <= q[j] 

+spec fn IsValidIndex<T>(q: Seq<T>, i: nat) -> bool {

+    0 <= i < q.len()

 }

 

-predicate HasAddends(q: seq<int>, x: int)

-{

-	exists i, j: : 0 <= i < j < |q| && q[i] + q[j] == x

+spec fn AreOreredIndices<T>(q: Seq<T>, i: nat, j: nat) -> bool {

+    0 <= i < j < q.len()

 }

 

-method FindAddends(q: seq<int>, x: int) -> i: nat, j: nat

-    requires Sorted(q) and HasAddends(q, x)

-    ensures i < j < q.len() and q[i]+q[j] == x

+spec fn AreAddendsIndices(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+    requires(IsValidIndex(q, i) && IsValidIndex(q, j))

 {

+    q[i as int] + q[j as int] == x

 }

 

+spec fn HasAddendsInIndicesRange(q: Seq<int>, x: int, i: nat, j: nat) -> bool

+    requires(AreOreredIndices(q, i, j))

+{

+    HasAddends(q.subrange(i as int, (j + 1) as int), x)

+}

+

+spec fn LoopInv(q: Seq<int>, x: int, i: nat, j: nat, sum: int) -> bool {

+    AreOreredIndices(q, i, j) &&

+    HasAddendsInIndicesRange(q, x, i, j) &&

+    AreAddendsIndices(q, sum, i, j)

+}

+

+proof fn LoopInvWhenSumIsBigger(q: Seq<int>, x: int, i: nat, j: nat, sum: int)

+    requires(HasAddends(q, x))

+    requires(Sorted(q))

+    requires(sum > x)

+    requires(LoopInv(q, x, i, j, sum))

+    ensures(HasAddendsInIndicesRange(q, x, i, j - 1))

+{

+    

 }

================================================================================
Comparing translations/first_8/bbfny_tmp_tmpw4m0jvl0_enjoying_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/bbfny_tmp_tmpw4m0jvl0_enjoying_no_hints.rs
+++ verus_specs/translations/first_8/bbfny_tmp_tmpw4m0jvl0_enjoying_no_hints.rs
@@ -1,15 +1,87 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultipleReturns(x: int, y: int) -> more: int, less: int

-    requires 0 < y

-    ensures less < x < more

+pub fn MultipleReturns(x: int, y: int) -> (more: int, less: int)

+    requires(0 < y)

+    ensures(|result: (int, int)| result.1 < x < result.0)

 {

 }

 

+

+pub fn Max(a: int, b: int) -> (c: int)

+    ensures(|result: int| a <= result && b <= result)

+    ensures(|result: int| a == result || b == result)

+{

+}

+

+

+pub fn Testing() {

+    let x = Max(3, 15);

+}

+

+

+spec fn max(a: int, b: int) -> int

+{

+}

+

+

+pub fn Testing_prime() {

+}

+

+

+spec fn abs(x: int) -> int

+{

+    if x < 0 { -x } else { x }

+}

+

+

+pub fn Abs(x: int) -> (y: int)

+    ensures(|result: int| result == abs(x))

+{

+}

+

+

+pub fn m(n: nat) {

+    let mut i = 0;

+    while i != n {

+        i = i + 1;

+    }

+}

+

+

+spec fn fib(n: nat) -> nat

+    decreases(n)

+{

+    if n == 0 {

+        0

+    } else if n == 1 {

+        1

+    } else {

+        fib((n - 1) as nat) + fib((n - 2) as nat)

+    }

+}

+

+

+pub fn Find(a: &[int], key: int) -> (index: int)

+    ensures(|result: int| 0 <= result ==> result < a.len() && a[result] == key)

+    ensures(|result: int| result < 0 ==> forall|k: int| 0 <= k < a.len() ==> a[k] != key)

+{

+}

+

+

+pub fn FindMax(a: &[int]) -> (i: int)

+    requires(a.len() >= 1)

+    ensures(|result: int| 0 <= result < a.len())

+    ensures(|result: int| forall|k: int| 0 <= k < a.len() ==> a[k] <= a[result])

+{

+}

+

+

+spec fn sorted(a: &[int]) -> bool

+{

+    forall|j: int, k: int| 0 <= j < k < a.len() ==> a[j] < a[k]

+}

+

+

+spec fn sorted_prime(a: Option<&[int]>) -> bool

+{

+    forall|j: int, k: int| a.is_some() && 0 <= j < k < a.unwrap().len() ==> a.unwrap()[j] <= a.unwrap()[k]

 }

================================================================================
Comparing translations/first_8/circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_no_hints.rs
================================================================================
--- verus_specs_no_llm/translations/first_8/circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_no_hints.rs
+++ verus_specs/translations/first_8/circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_no_hints.rs
@@ -1,182 +1,101 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn Valid() -> bool {

-    0 <= counter <= circularQueue.len() and

-    0 <= front and

-    0 <= rear and

-    Content == circularQueue[..]

+struct Queue {

+    circularQueue: Vec<i32>,

+    rear: usize,

+    front: usize,

+    counter: usize,

+    ghost Content: Seq<i32>,

 }

 

-fn insert(item: int)

-     requires rear <= circularQueue.Length

-     ensures (front == 0 && rear == 0 && circularQueue.Length == 1) ==>

-         (

-           Content == [item] &&

-           |Content| == 1

-         )

-  {}

+impl Queue {

+    spec fn Valid(&self) -> bool {

+        0 <= self.counter <= self.circularQueue.len() &&

+        0 <= self.front &&

+        0 <= self.rear &&

+        self.Content == self.circularQueue@

+    }

 

+    pub fn new() -> (result: Self)

+        ensures(result.circularQueue.len() == 0)

+        ensures(result.front == 0 && result.rear == 0)

+        ensures(result.Content == Seq::empty())

+        ensures(result.counter == 0)

+    {

+    }

 

+    pub fn insert(&mut self, item: i32)

+        requires(self.rear <= self.circularQueue.len())

+        ensures((self.front == 0 && self.rear == 0 && self.circularQueue.len() == 1) ==>

+            (

+                self.Content == seq![item] &&

+                self.Content.len() == 1

+            ))

+    {

+    }

 

+    pub fn auxInsertEmptyQueue(&mut self, item: i32)

+        requires(self.front == 0 && self.rear == 0 && self.circularQueue.len() == 0)

+        ensures(self.circularQueue.len() == 1)

+        ensures(self.Content == seq![item])

+        ensures(self.Content.len() == 1)

+        ensures(self.rear == 1)

+        ensures(self.counter == old(self).counter + 1)

+        ensures(self.front == 0)

+    {

+    }

 

+    pub fn auxInsertEndQueue(&mut self, item: i32)

+        requires(self.front == 0 && self.rear == self.circularQueue.len() && self.circularQueue.len() >= 1)

+        ensures(self.Content == old(self).Content + seq![item])

+        ensures(self.Content.len() == old(self).Content.len() + 1)

+        ensures(self.front == 0)

+        ensures(self.rear == old(self).rear + 1)

+        ensures(self.counter == old(self).counter + 1)

+    {

+    }

 

+    pub fn auxInsertSpaceQueue(&mut self, item: i32)

+        requires(self.rear < self.front && self.front < self.circularQueue.len())

+        ensures(self.rear == old(self).rear + 1)

+        ensures(self.counter == old(self).counter + 1)

+        ensures(self.Content == old(self).Content.subrange(0, old(self).rear as int) + seq![item] + old(self).Content.subrange((old(self).rear + 1) as int, old(self).circularQueue.len() as int))

+        ensures(self.Content.len() == old(self).Content.len() + 1)

+    {

+    }

 

+    pub fn auxInsertInitQueue(&mut self, item: i32)

+    {

+    }

 

+    pub fn auxInsertBetweenQueue(&mut self, item: i32)

+    {

+    }

 

+    pub fn remove(&mut self) -> (item: i32)

+        requires(self.front < self.circularQueue.len())

+        requires(self.circularQueue.len() > 0)

+        ensures(self.rear <= old(self).Content.len())

+        ensures(self.circularQueue.len() > 0)

+        ensures(item == old(self).Content[old(self).front as int])

+        ensures(self.front == (old(self).front + 1) % self.circularQueue.len())

+        ensures(old(self).front < self.rear ==> self.Content == old(self).Content.subrange(old(self).front as int, self.rear as int))

+        ensures(old(self).front > self.rear ==> self.Content == old(self).Content.subrange(0, self.rear as int) + old(self).Content.subrange(old(self).front as int, old(self).Content.len() as int))

+    {

+    }

 

+    pub fn size(&self) -> (size: usize)

+        ensures(size == self.counter)

+    {

+    }

 

+    pub fn isEmpty(&self) -> (isEmpty: bool)

+        ensures(isEmpty == true ==> self.counter == 0)

+        ensures(isEmpty == false ==> self.counter != 0)

+    {

+    }

 

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-    

-

-

-  method auxInsertEmptyQueue(item:int)

-    requires front == 0 && rear == 0 && circularQueue.Length == 0

-    ensures circularQueue.Length == 1

-    ensures Content == [item]

-    ensures |Content| == 1

-    ensures rear == 1

-    ensures counter == old(counter) + 1

-    ensures front == 0

-  {}

-

-

-  method auxInsertEndQueue(item:int)

-    requires front == 0 && rear == circularQueue.Length && circularQueue.Length >= 1

-    ensures Content == old(Content) + [item]

-    ensures |Content| == old(|Content|) + 1

-    ensures front == 0

-    ensures rear == old(rear) + 1

-    ensures counter == old(counter) + 1

-  {}

-

-

-  method auxInsertSpaceQueue(item:int)

-    requires rear < front && front < circularQueue.Length

-    ensures rear == old(rear) + 1

-    ensures counter == old(counter) + 1

-    ensures Content == old(Content[0..rear]) + [item] + old(Content[rear+1..circularQueue.Length])

-    ensures |Content| == old(|Content|) + 1

-  {}

-

-

-  method auxInsertInitQueue(item:int)

-  {}

-

-

-  method auxInsertBetweenQueue(item:int)

-  {}

-

-

-  method remove() -> (item: int)

-    requires rear <= circularQueue.len(),

-             front == 0 and rear == 0 and circularQueue.len() == 0,

-             front == 0 and rear == circularQueue.len() and circularQueue.len() >= 1,

-             rear < front and front < circularQueue.len(),

-             front < circularQueue.len(),

-             circularQueue.len() > 0

-    ensures (front == 0 and rear == 0 and circularQueue.len() == 1) ==>

-         (

-           Content == [item] and

-           Content.len() == 1

-         ),

-            circularQueue.len() != 0 ==>

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-            circularQueue.len() == 1,

-            Content == [item],

-            Content.len() == 1,

-            rear == 1,

-            counter == old(counter) + 1,

-            front == 0,

-            Content == old(Content) + [item],

-            Content.len() == old(Content.len()) + 1,

-            front == 0,

-            rear == old(rear) + 1,

-            counter == old(counter) + 1,

-            rear == old(rear) + 1,

-            counter == old(counter) + 1,

-            Content == old(Content[0..rear]) + [item] + old(Content[rear+1..circularQueue.len()]),

-            Content.len() == old(Content.len()) + 1,

-            rear <= old(Content).len(),

-            circularQueue.len() > 0,

-            item == old(Content)[old(front)],

-            front == (old(front) + 1) % circularQueue.len(),

-            old(front) < rear ==> Content == old(Content)[old(front)..rear],

-            old(front) > rear ==> Content == old(Content)[0 .. rear] + old(Content)[old(front)..old(Content).len()]

-{

-}

-

+    pub fn contains(&self, item: i32) -> (contains: bool)

+        ensures(contains == true ==> self.circularQueue@.contains(item))

+        ensures(contains == false ==> !self.circularQueue@.contains(item))

+    {

+    }

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_101_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_101_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_101_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn KthElement(arr: Vec<int>, k: int) -> (result: int)

-    requires 1 <= k <= arr.len()

-    ensures result == arr[k - 1]

+pub fn kth_element(arr: &[i32], k: i32) -> (result: i32)

+    requires(1 <= k <= arr.len())

+    ensures(result == arr[(k - 1) as usize])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_105_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_105_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_105_spec.rs
@@ -1,15 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountTrue(a: Vec<bool>) -> (result: int)

-    requires a != null

-    ensures result == countTo(a, a.len())

+spec fn countTo(a: &[bool], n: int) -> int

+    recommends 0 <= n <= a.len()

 {

+    if n == 0 { 0 } else { countTo(a, n-1) + if a[n-1] { 1 } else { 0 } }

 }

 

+

+pub fn CountTrue(a: &[bool]) -> (result: int)

+    ensures(result == countTo(a, a.len() as int))

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_106_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_106_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_106_spec.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AppendArrayToSeq(s: Seq<int>, a: Vec<int>) -> (r: Seq<int>)

-    requires a != null

-    ensures r.len() == s.len() + a.len(),

-            forall|i: int| 0 <= i < s.len() ==> r[i] == s[i],

-            forall|i: int| 0 <= i < a.len() ==> r[s.len() + i] == a[i]

+pub fn append_array_to_seq(s: Seq<int>, a: &[int]) -> (r: Seq<int>)

+    requires(

+        true

+    )

+    ensures(|result: Seq<int>| {

+        &&& result.len() == s.len() + a.len()

+        &&& forall|i: int| 0 <= i < s.len() ==> result[i] == s[i]

+        &&& forall|i: int| 0 <= i < a.len() ==> result[s.len() + i] == a[i]

+    })

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_113_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_113_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_113_spec.rs
@@ -1,18 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn IsInteger(s: String) -> (result: bool)

-    ensures result <==> (s.len() > 0) and (forall|i: int| 0 <= i < s.len() ==> IsDigit(s[i]))

+

+pub fn is_integer(s: &str) -> (result: bool)

+    ensures(result <==> (s.len() > 0) && (forall|i: int| 0 <= i < s.len() ==> is_digit(s[i as usize])))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_126_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_126_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_126_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfCommonDivisors(a: int, b: int) -> (sum: int)

-    requires a > 0 and b > 0

-    ensures sum >= 0,

-            forall|d: int| 1 <= d <= a and 1 <= d <= b and a % d == 0 and b % d == 0 ==> sum >= d

+pub fn sum_of_common_divisors(a: int, b: int) -> (sum: int)

+    requires(a > 0 && b > 0)

+    ensures(sum >= 0)

+    ensures(forall|d: int| 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_127_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_127_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_127_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Multiply(a: int, b: int) -> (result: int)

-    ensures result == a * b

+pub fn multiply(a: int, b: int) -> (result: int)

+    ensures(result == a * b)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_133_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_133_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_133_spec.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfNegatives(a: Vec<int>) -> (result: int)

-    ensures result == sumNegativesTo(a, a.len())

+spec fn sumNegativesTo(a: &[int], n: int) -> int

+    recommends 0 <= n && n <= a.len()

 {

+    if n == 0 { 0 } else if a[n-1] < 0 { sumNegativesTo(a, n-1) + a[n-1] } else { sumNegativesTo(a, n-1) }

 }

 

+

+pub fn SumOfNegatives(a: &[int]) -> (result: int)

+    ensures(result == sumNegativesTo(a, a.len()))

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_135_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_135_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_135_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthHexagonalNumber(n: int) -> (hexNum: int)

+pub fn nth_hexagonal_number(n: int) -> (hexNum: int)

     requires n >= 0

     ensures hexNum == n * ((2 * n) - 1)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_142_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_142_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_142_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountIdenticalPositions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

-    requires a.len() == b.len() and b.len() == c.len()

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < a.len() and a[i] == b[i] and b[i] == c[i]|

+pub fn count_identical_positions(a: Seq<int>, b: Seq<int>, c: Seq<int>) -> (count: int)

+    requires(a.len() == b.len() && b.len() == c.len())

+    ensures(count >= 0)

+    ensures(count == Set::<int>::new(|i: int| 0 <= i < a.len() && a[i] == b[i] && b[i] == c[i]).len())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_143_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_143_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_143_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountArrays(arrays: Seq<Vec<int>>) -> (count: int)

+pub fn count_arrays(arrays: Seq<&[int]>) -> (count: int)

     ensures count >= 0,

-            count == arrays.len()

+    ensures count == arrays.len(),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_145_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_145_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_145_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() > 1

-    ensures forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] - a[j] <= diff

+pub fn max_difference(a: &[i32]) -> (diff: i32)

+    requires(a.len() > 1)

+    ensures(forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] - a[j] <= diff)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_14_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_14_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_14_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TriangularPrismVolume(base: int, height: int, length: int) -> (volume: int)

-    requires base > 0,

-             height > 0,

-             length > 0

-    ensures volume == (base * height * length) / 2

+pub fn triangular_prism_volume(base: int, height: int, length: int) -> (volume: int)

+    requires(base > 0)

+    requires(height > 0)

+    requires(length > 0)

+    ensures(|volume: int| volume == (base * height * length) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_170_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_170_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_170_spec.rs
@@ -1,16 +1,14 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumInRange(a: Vec<int>, start: int, end: int) -> (sum: int)

-    requires a != null,

-             0 <= start and start <= end and end <= a.len()

-    ensures sum == sumTo(a, start, end)

+spec fn sumTo(a: &[int], start: int, end: int) -> int

+    requires 0 <= start && start <= end && end <= a.len()

+    decreases end - start

 {

+    if start == end { 0 } else { sumTo(a, start, (end-1) as int) + a[(end-1) as int] }

 }

 

+

+pub fn SumInRange(a: &[int], start: int, end: int) -> (sum: int)

+    requires(0 <= start && start <= end && end <= a.len())

+    ensures(sum == sumTo(a, start, end))

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_171_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_171_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_171_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PentagonPerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 5 * side

+pub fn pentagon_perimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 5 * side)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_17_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_17_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_17_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePerimeter(side: int) -> (perimeter: int)

-    requires side > 0

-    ensures perimeter == 4 * side

+pub fn square_perimeter(side: int) -> (perimeter: int)

+    requires(side > 0)

+    ensures(perimeter == 4 * side)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_18_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_18_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_18_spec.rs
@@ -1,16 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveChars(s1: String, s2: String) -> (v: String)

-    ensures v.len() <= s1.len(),

-            forall|i: int| 0 <= i < v.len() ==> (v[i] in s1) and !(v[i] in s2),

-            forall|i: int| 0 <= i < s1.len() ==> (s1[i] in s2) or (s1[i] in v)

+pub fn remove_chars(s1: &str, s2: &str) -> (v: String)

+    requires(

+        true

+    )

+    ensures(|v: String|

+        v.len() <= s1.len() &&

+        forall|i: usize| 0 <= i < v.len() ==> s1.contains(v.chars().nth(i).unwrap()) && !s2.contains(v.chars().nth(i).unwrap()) &&

+        forall|i: usize| 0 <= i < s1.len() ==> s2.contains(s1.chars().nth(i).unwrap()) || v.contains(s1.chars().nth(i).unwrap())

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_227_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_227_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_227_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinOfThree(a: int, b: int, c: int) -> (min: int)

-    ensures min <= a and min <= b and min <= c,

-            (min == a) | (min == b) .len()| (min == c)

+pub fn min_of_three(a: int, b: int, c: int) -> (min: int)

+    ensures

+        min <= a && min <= b && min <= c,

+        (min == a) || (min == b) || (min == c),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_230_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_230_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_230_spec.rs
@@ -1,15 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceBlanksWithChar(s: String, ch: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == ' ' ==> v[i] == ch) and (s[i] != ' ' ==> v[i] == s[i])

+pub fn replace_blanks_with_char(s: &str, ch: char) -> (v: String)

+    ensures(

+        v.len() == s.len() &&

+        forall|i: usize| 0 <= i < s.len() ==> 

+            (s.as_bytes()[i] == b' ' ==> v.as_bytes()[i] == ch as u8) &&

+            (s.as_bytes()[i] != b' ' ==> v.as_bytes()[i] == s.as_bytes()[i])

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_234_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_234_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_234_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeVolume(size: int) -> (volume: int)

-    requires size > 0

-    ensures volume == size * size * size

+pub fn CubeVolume(size: int) -> (volume: int)

+    requires(size > 0)

+    ensures(volume == size * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_238_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_238_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_238_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountNonEmptySubstrings(s: String) -> (count: int)

-    ensures count >= 0,

-            count == (s.len() * (s.len() + 1)) / 2

+pub fn count_non_empty_substrings(s: &str) -> (count: i32)

+    ensures(count >= 0)

+    ensures(count == (s.len() * (s.len() + 1)) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_240_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_240_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_240_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceLastElement(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

-    requires first.len() > 0

-    ensures result.len() == first.len() - 1 + second.len(),

-            forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

-            forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1]

+pub fn replace_last_element(first: Seq<int>, second: Seq<int>) -> (result: Seq<int>)

+    requires

+        first.len() > 0,

+    ensures

+        result.len() == first.len() - 1 + second.len(),

+        forall|i: int| 0 <= i < first.len() - 1 ==> result[i] == first[i],

+        forall|i: int| first.len() - 1 <= i < result.len() ==> result[i] == second[i - first.len() + 1],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_242_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_242_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_242_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountCharacters(s: String) -> (count: int)

-    ensures count >= 0,

-            count == s.len()

+pub fn count_characters(s: &str) -> (count: usize)

+    ensures(count >= 0)

+    ensures(count == s.len())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_251_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_251_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_251_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn InsertBeforeEach(s: Seq<String>, x: String) -> (v: Seq<String>)

-    ensures v.len() == 2 * s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[2*i] == x and v[2*i + 1] == s[i]

+pub fn insert_before_each(s: Seq<String>, x: String) -> (v: Seq<String>)

+    ensures(|v| == 2 * |s|)

+    ensures(forall|i: int| 0 <= i < |s| ==> v[2*i] == x && v[2*i + 1] == s[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_257_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_257_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_257_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Swap(a: int, b: int) -> (result: Seq<int>)

-    ensures result.len() == 2,

-            result[0] == b,

-            result[1] == a

+pub fn swap(a: int, b: int) -> (result: Seq<int>)

+    ensures

+        result.len() == 2,

+        result[0] == b,

+        result[1] == a,

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_261_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_261_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_261_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivision(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_division(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_262_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_262_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_262_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitArray(arr: Vec<int>, L: int) -> firstPart: Seq<int>, secondPart: Seq<int>

+pub fn SplitArray(arr: &[int], L: int) -> (firstPart: Seq<int>, secondPart: Seq<int>)

     requires 0 <= L <= arr.len()

-    ensures firstPart.len() == L,

-            secondPart.len() == arr.len() - L,

-            firstPart + secondPart == arr[..]

+    ensures |firstPart| == L

+    ensures |secondPart| == arr.len() - L

+    ensures firstPart + secondPart == arr@

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_264_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_264_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_264_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DogYears(humanYears: int) -> (dogYears: int)

-    requires humanYears >= 0

-    ensures dogYears == 7 * humanYears

+pub fn DogYears(humanYears: int) -> (dogYears: int)

+    requires(humanYears >= 0)

+    ensures(dogYears == 7 * humanYears)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_266_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_266_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_266_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LateralSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 4 * size * size

+pub fn LateralSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 4 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_267_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_267_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_267_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfSquaresOfFirstNOddNumbers(n: int) -> (sum: int)

-    requires n >= 0

-    ensures sum == (n * (2 * n - 1) * (2 * n + 1)) / 3

+pub fn sum_of_squares_of_first_n_odd_numbers(n: int) -> (sum: int)

+    requires(n >= 0)

+    ensures(sum == (n * (2 * n - 1) * (2 * n + 1)) / 3)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_268_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_268_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_268_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StarNumber(n: int) -> (star: int)

-    requires n >= 0

-    ensures star == 6 * n * (n - 1) + 1

+pub fn star_number(n: int) -> (star: int)

+    requires(n >= 0)

+    ensures(star == 6 * n * (n - 1) + 1)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_269_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_269_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_269_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AsciiValue(c: char) -> (ascii: int)

-    ensures ascii == c as int

+pub fn ascii_value(c: char) -> (ascii: i32)

+    ensures ascii == c as i32

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_273_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_273_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_273_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SubtractSequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn subtract_sequences(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_279_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_279_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_279_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthDecagonalNumber(n: int) -> (decagonal: int)

-    requires n >= 0

-    ensures decagonal == 4 * n * n - 3 * n

+pub fn NthDecagonalNumber(n: int) -> (decagonal: int)

+    requires(n >= 0)

+    ensures(|decagonal: int| decagonal == 4 * n * n - 3 * n)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_282_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_282_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_282_spec.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseSubtraction(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len()

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] - b[i]

+pub fn element_wise_subtraction(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires(a.len() == b.len())

+    ensures(|result: Vec<i32>| result.len() == a.len())

+    ensures(|result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] - b[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_284_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_284_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_284_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllElementsEqual(a: Vec<int>, n: int) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> a[i] == n,

-            !result ==> exists|i: int| 0 <= i < a.len() and a[i] != n

+pub fn all_elements_equal(a: &[i32], n: i32) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: usize| 0 <= i < a.len() ==> a[i] == n)

+    ensures(!result ==> exists|i: usize| 0 <= i < a.len() && a[i] != n)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_290_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_290_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_290_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MaxLengthList(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

-    requires lists.len() > 0

-    ensures forall|l: int| l in lists ==> l.len() <= maxList.len(),

-            maxList in lists

+pub fn max_length_list(lists: Seq<Seq<int>>) -> (maxList: Seq<int>)

+    requires(lists.len() > 0)

+    ensures(forall|l: Seq<int>| lists.contains(l) ==> l.len() <= maxList.len())

+    ensures(lists.contains(maxList))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_292_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_292_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_292_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Quotient(a: int, b: int) -> (result: int)

-    requires b != 0

-    ensures result == a / b

+pub fn quotient(a: int, b: int) -> (result: int)

+    requires(b != 0)

+    ensures(result == a / b)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_304_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_304_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_304_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementAtIndexAfterRotation(l: Seq<int>, n: int, index: int) -> (element: int)

-    requires n >= 0,

-             0 <= index < l.len()

-    ensures element == l[(index - n + l.len()) % l.len()]

+pub fn element_at_index_after_rotation(l: Seq<int>, n: int, index: int) -> (element: int)

+    requires 

+        n >= 0,

+        0 <= index < l.len(),

+    ensures |element: int|

+        element == l[(index - n + l.len()) % l.len()],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_307_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_307_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_307_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DeepCopySeq(s: Seq<int>) -> (copy: Seq<int>)

-    ensures copy.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i]

+pub fn deep_copy_seq(s: Seq<int>) -> (copy: Seq<int>)

+    ensures

+        copy.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> copy[i] == s[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_309_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_309_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_309_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Max(a: int, b: int) -> (maxValue: int)

-    ensures maxValue == a or maxValue == b,

-            maxValue >= a and maxValue >= b

+pub fn Max(a: int, b: int) -> (maxValue: int)

+    ensures(maxValue == a || maxValue == b)

+    ensures(maxValue >= a && maxValue >= b)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_310_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_310_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_310_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ToCharArray(s: String) -> (a: Vec<char>)

-    ensures a.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> a[i] == s[i]

+pub fn ToCharArray(s: &str) -> (a: Vec<char>)

+    ensures(a.len() == s.len())

+    ensures(forall|i: usize| 0 <= i < s.len() ==> a[i] == s.chars().nth(i).unwrap())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_396_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_396_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_396_spec.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn StartAndEndWithSameChar(s: String) -> (result: bool)

-    requires s.len() > 0

-    ensures result <==> s[0] == s[s.len() - 1]

+pub fn start_and_end_with_same_char(s: &str) -> (result: bool)

+    requires

+        s.len() > 0,

+    ensures

+        result <==> s@[0] == s@[s@.len() - 1],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_397_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_397_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_397_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianOfThree(a: int, b: int, c: int) -> (median: int)

-    ensures median == a | median == b .len()| median == c,

-            (median >= a and median <= b) | (median >= b and median <= a) .len() (median >= a and median <= c) .len() (median >= c and median <= a) .len() (median >= b and median <= c) .len()| (median >= c and median <= b)

+pub fn median_of_three(a: int, b: int, c: int) -> (median: int)

+    ensures(median == a || median == b || median == c),

+    ensures((median >= a && median <= b) || (median >= b && median <= a) || (median >= a && median <= c) || (median >= c && median <= a) || (median >= b && median <= c) || (median >= c && median <= b)),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_399_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_399_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_399_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn BitwiseXOR(a: Seq<bv32>, b: Seq<bv32>) -> (result: Seq<bv32>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i]

+pub fn bitwise_xor(a: Seq<u32>, b: Seq<u32>) -> (result: Seq<u32>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<u32>| result.len() == a.len())

+    ensures(|result: Seq<u32>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] ^ b[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_3_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_3_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_3_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsNonPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (exists|k: int| 2 <= k < n and n % k == 0)

+pub fn is_non_prime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (exists|k: int| 2 <= k < n && n % k == 0))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_401_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_401_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_401_spec.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IndexWiseAddition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

-    requires a.len() > 0 and b.len() > 0,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len(),

-            forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j]

+pub fn IndexWiseAddition(a: Seq<Seq<int>>, b: Seq<Seq<int>>) -> (result: Seq<Seq<int>>)

+    requires(a.len() > 0 && b.len() > 0)

+    requires(a.len() == b.len())

+    requires(forall|i: int| 0 <= i < a.len() ==> a[i].len() == b[i].len())

+    ensures(result.len() == a.len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> result[i].len() == a[i].len())

+    ensures(forall|i: int| 0 <= i < result.len() ==> forall|j: int| 0 <= j < result[i].len() ==> result[i][j] == a[i][j] + b[i][j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_404_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_404_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_404_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Min(a: int, b: int) -> (minValue: int)

-    ensures minValue == a or minValue == b,

-            minValue <= a and minValue <= b

+pub fn Min(a: int, b: int) -> (minValue: int)

+    ensures(minValue == a || minValue == b)

+    ensures(minValue <= a && minValue <= b)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_406_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_406_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_406_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsOdd(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 1

+pub fn is_odd(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_412_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_412_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_412_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

 

+pub fn remove_odd_numbers(arr: &[i32]) -> (even_list: Vec<i32>)

+    ensures

+        forall|i: int| 0 <= i < even_list.len() ==> is_even(even_list[i] as int) && arr@.contains(even_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_even(arr[i] as int) ==> even_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_414_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_414_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_414_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AnyValueExists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < seq1.len() and seq1[i] in seq2)

+pub fn any_value_exists(seq1: Seq<int>, seq2: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < seq1.len() && seq2.contains(seq1[i])))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_424_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_424_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_424_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ExtractRearChars(l: Seq<String>) -> (r: Seq<char>)

-    requires forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]

+pub fn extract_rear_chars(l: Seq<Seq<char>>) -> (r: Seq<char>)

+    requires(

+        forall|i: int| 0 <= i < l.len() ==> l[i].len() > 0

+    )

+    ensures(|r: Seq<char>|

+        r.len() == l.len() &&

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i][l[i].len() - 1]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_426_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_426_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_426_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 != 0

 }

 

+pub fn filter_odd_numbers(arr: &[i32]) -> (odd_list: Vec<i32>)

+    ensures

+        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i] as int) && arr@.contains(odd_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i] as int) ==> odd_list@.contains(arr[i]),

+{

+}

+

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_431_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_431_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_431_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasCommonElement(a: Vec<int>, b: Vec<int>) -> (result: bool)

-    requires a != null and b != null

-    ensures result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() and a[i] == b[j],

-            !result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < b.len() ==> a[i] != b[j]

+pub fn has_common_element(a: &[i32], b: &[i32]) -> bool

+    requires(a.len() > 0 && b.len() > 0)

+    ensures(|result: bool| result ==> exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() && a[i] == b[j])

+    ensures(|result: bool| !result ==> forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < b.len() ==> a[i] != b[j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_432_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_432_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_432_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MedianLength(a: int, b: int) -> (median: int)

-    requires a > 0 and b > 0

-    ensures median == (a + b) / 2

+pub fn median_length(a: int, b: int) -> (median: int)

+    requires(a > 0 && b > 0)

+    ensures(median == (a + b) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_433_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_433_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_433_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsGreater(n: int, a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i],

-            !result ==> exists|i: int| 0 <= i < a.len() and n <= a[i]

+pub fn IsGreater(n: int, a: &[int]) -> (result: bool)

+    requires(true)

+    ensures(result ==> forall|i: int| 0 <= i < a.len() ==> n > a[i as usize])

+    ensures(!result ==> exists|i: int| 0 <= i < a.len() && n <= a[i as usize])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_435_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_435_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_435_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastDigit(n: int) -> (d: int)

+pub fn last_digit(n: int) -> (d: int)

     requires n >= 0

-    ensures 0 <= d < 10,

-            n % 10 == d

+    ensures 0 <= d < 10

+    ensures n % 10 == d

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_436_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_436_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_436_spec.rs
@@ -1,13 +1,12 @@
+use vstd::prelude::*;

 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsNegative(n: int) -> bool {

+spec fn is_negative(n: int) -> bool {

     n < 0

 }

 

+pub fn find_negative_numbers(arr: &[i32]) -> (negative_list: Vec<i32>)

+    ensures

+        forall|i: int| 0 <= i < negative_list.len() ==> is_negative(negative_list[i] as int) && exists|j: int| 0 <= j < arr.len() && arr[j] == negative_list[i],

+        forall|i: int| 0 <= i < arr.len() && is_negative(arr[i] as int) ==> exists|j: int| 0 <= j < negative_list.len() && negative_list[j] == arr[i]

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_441_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_441_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_441_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeSurfaceArea(size: int) -> (area: int)

-    requires size > 0

-    ensures area == 6 * size * size

+pub fn CubeSurfaceArea(size: int) -> (area: int)

+    requires(size > 0)

+    ensures(area == 6 * size * size)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_445_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_445_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_445_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MultiplyElements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i]

+pub fn multiply_elements(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] * b[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_447_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_447_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_447_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CubeElements(a: Vec<int>) -> (cubed: Vec<int>)

-    ensures cubed.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i]

+pub fn CubeElements(a: &[i32]) -> (cubed: Vec<i32>)

+    requires(true)

+    ensures(|cubed: Vec<i32>| cubed.len() == a.len())

+    ensures(|cubed: Vec<i32>| forall|i: usize| 0 <= i < a.len() ==> cubed[i] == a[i] * a[i] * a[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_452_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_452_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_452_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) and (costPrice <= sellingPrice ==> loss == 0)

+pub fn CalculateLoss(costPrice: int, sellingPrice: int) -> (loss: int)

+    requires(costPrice >= 0 && sellingPrice >= 0)

+    ensures((costPrice > sellingPrice ==> loss == costPrice - sellingPrice) && (costPrice <= sellingPrice ==> loss == 0))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_454_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_454_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_454_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsZ(s: String) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < s.len() and (s[i] == 'z' or s[i] == 'Z'))

+pub fn contains_z(s: &str) -> (result: bool)

+    ensures(result <==> (exists|i: usize| 0 <= i < s.len() && (s[i] == 'z' || s[i] == 'Z')))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_455_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_455_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_455_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MonthHas31Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month in

+pub fn MonthHas31Days(month: int) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> month in {1, 3, 5, 7, 8, 10, 12})

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_457_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_457_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_457_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinLengthSublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

-    requires s.len() > 0

-    ensures minSublist in s,

-            forall|sublist: int| sublist in s ==> minSublist.len() <= sublist.len()

+pub fn min_length_sublist(s: Seq<Seq<int>>) -> (minSublist: Seq<int>)

+    requires(s.len() > 0)

+    ensures(s.contains(minSublist))

+    ensures(forall|sublist: Seq<int>| s.contains(sublist) ==> minSublist.len() <= sublist.len())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_458_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_458_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_458_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RectangleArea(length: int, width: int) -> (area: int)

-    requires length > 0,

-             width > 0

-    ensures area == length * width

+pub fn RectangleArea(length: int, width: int) -> (area: int)

+    requires(length > 0)

+    requires(width > 0)

+    ensures(|area: int| area == length * width)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_460_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_460_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_460_spec.rs
@@ -1,16 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn GetFirstElements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

-    requires forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0

-    ensures result.len() == lst.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0]

+pub fn get_first_elements(lst: Seq<Seq<int>>) -> (result: Seq<int>)

+    requires

+        forall|i: int| 0 <= i < lst.len() ==> lst[i].len() > 0,

+    ensures

+        |result: Seq<int>| result.len() == lst.len(),

+        |result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == lst[i][0],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_461_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_461_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_461_spec.rs
@@ -1,19 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub closed spec fn is_upper_case(c: char) -> bool {

     65 <= c as int <= 90

 }

 

-fn CountUppercase(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsUpperCase(s[i])|

+

+pub fn count_uppercase(s: &str) -> (count: i32)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s.len() as int).filter(|i: int| is_upper_case(s[*i as usize]))).len() as i32,

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_470_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_470_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_470_spec.rs
@@ -1,18 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PairwiseAddition(a: Vec<int>) -> (result: Vec<int>)

-    requires a != null,

-             a.len() % 2 == 0

-    ensures result != null,

-            result.len() == a.len() / 2,

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

+pub fn pairwise_addition(a: &[i32]) -> Vec<i32>

+    requires a.len() % 2 == 0

+    ensures |result: Vec<i32>| result.len() == a.len() / 2

+    ensures |result: Vec<i32>| forall|i: usize| 0 <= i < result.len() ==> result[i] == a[2*i] + a[2*i + 1]

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_472_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_472_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_472_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsConsecutiveNumbers(a: Vec<int>) -> (result: bool)

-    requires a.len()>0

-    ensures result <==> (exists|i: int| 0 <= i < a.len() - 1 and a[i] + 1 == a[i + 1])

+pub fn contains_consecutive_numbers(a: &[i32]) -> (result: bool)

+    requires(a.len() > 0)

+    ensures(result <==> (exists|i: usize| 0 <= i < a.len() - 1 && a[i] + 1 == a[i + 1]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_474_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_474_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_474_spec.rs
@@ -1,15 +1,13 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ReplaceChars(s: String, oldChar: char, newChar: char) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (s[i] == oldChar ==> v[i] == newChar) and (s[i] != oldChar ==> v[i] == s[i])

+pub fn replace_chars(s: &str, old_char: char, new_char: char) -> (v: String)

+    requires(

+        s.is_ascii()

+    )

+    ensures(|v: String|

+        v.len() == s.len() &&

+        forall|i: int| 0 <= i < s.len() ==> 

+            (s[i] == old_char ==> v[i] == new_char) && 

+            (s[i] != old_char ==> v[i] == s[i])

+    )

 {

-}

-

+    unimplemented!()

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_476_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_476_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_476_spec.rs
@@ -1,15 +1,27 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumMinMax(a: Vec<int>) -> (sum: int)

-    requires a.len() > 0

-    ensures sum == Max(a[..]) + Min(a[..])

+pub fn SumMinMax(a: &[i32]) -> i32

+    requires(a.len() > 0)

+    ensures(|sum: i32| sum == Max(a) + Min(a))

 {

 }

 

+pub fn Min(a: &[i32]) -> i32

+    requires(a.len() > 0)

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let minPrefix = Min(&a[..a.len()-1]);

+        if a[a.len()-1] <= minPrefix { a[a.len()-1] } else { Min(&a[..a.len()-1]) }

+    }

+}

+

+pub fn Max(a: &[i32]) -> i32

+    requires(a.len() > 0)

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let maxPrefix = Max(&a[..a.len()-1]);

+        if a[a.len()-1] >= maxPrefix { a[a.len()-1] } else { Max(&a[..a.len()-1]) }

+    }

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_477_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_477_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_477_spec.rs
@@ -1,22 +1,27 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsUpperCase(c: char) -> bool {

+pub open spec fn is_upper_case(c: char) -> bool {

     65 <= c as int <= 90

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub open spec fn is_upper_lower_pair(C: char, c: char) -> bool {

     (C as int) == (c as int) - 32

 }

 

-fn ToLowercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

-{

+

+pub open spec fn shift32(c: char) -> char {

+    ((c as int + 32) % 128) as char

 }

 

+

+pub fn to_lowercase(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if is_upper_case(s[i]) { 

+                is_upper_lower_pair(s[i], v[i]) 

+            } else { 

+                v[i] == s[i] 

+            }

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_554_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_554_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_554_spec.rs
@@ -1,13 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-spec fn IsOdd(n: int) -> bool {

+spec fn is_odd(n: int) -> bool {

     n % 2 == 1

 }

 

+pub fn find_odd_numbers(arr: &[int]) -> (odd_list: Vec<int>)

+    ensures

+        forall|i: int| 0 <= i < odd_list.len() ==> is_odd(odd_list[i]) && arr@.contains(odd_list[i]),

+        forall|i: int| 0 <= i < arr.len() && is_odd(arr[i]) ==> odd_list@.contains(arr[i])

+{

+}

+

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_555_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_555_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_555_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceSumCubesAndSumNumbers(n: int) -> (diff: int)

-    requires n >= 0

-    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2

+pub fn difference_sum_cubes_and_sum_numbers(n: int) -> (diff: int)

+    requires(n >= 0)

+    ensures(diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_557_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_557_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_557_spec.rs
@@ -1,28 +1,44 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub open spec fn is_lower_case(c: char) -> bool {

     97 <= c as int <= 122

 }

-spec fn IsUpperCase(c: char) -> bool {

+

+

+pub open spec fn is_upper_case(c: char) -> bool {

     65 <= c as int <= 90

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+

+pub open spec fn is_lower_upper_pair(c: char, C: char) -> bool {

     (c as int) == (C as int) + 32

 }

-spec fn IsUpperLowerPair(C: char, c: char) -> bool {

+

+

+pub open spec fn is_upper_lower_pair(C: char, c: char) -> bool {

     (C as int) == (c as int) - 32

 }

 

-fn ToggleCase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]

-{

+

+pub open spec fn shift_minus32(c: char) -> char {

+    ((c as int - 32) % 128) as char

 }

 

+

+pub open spec fn shift32(c: char) -> char {

+    ((c as int + 32) % 128) as char

+}

+

+

+pub fn toggle_case(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            if is_lower_case(s[i as usize]) {

+                is_lower_upper_pair(s[i as usize], v[i as usize])

+            } else if is_upper_case(s[i as usize]) {

+                is_upper_lower_pair(s[i as usize], v[i as usize])

+            } else {

+                v[i as usize] == s[i as usize]

+            }

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_565_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_565_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_565_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitStringIntoChars(s: String) -> (v: Seq<char>)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> v[i] == s[i]

+pub fn split_string_into_chars(s: &str) -> (v: Vec<char>)

+    ensures

+        v.len() == s.len(),

+        forall|i: usize| 0 <= i < s.len() ==> v[i] == s.chars().nth(i).unwrap(),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_566_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_566_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_566_spec.rs
@@ -1,16 +1,77 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfDigits(number: nat) -> (sum: nat)

-    requires number >= 0

-    ensures sum >= 0,

-            sum == SumDigits(number)

+pub fn SumOfDigits(number: nat) -> (sum: nat)

+    requires(number >= 0)

+    ensures(sum >= 0)

+    ensures(sum == SumDigits(number))

 {

 }

 

+proof fn X(x: nat)

+    ensures(Power10(NumberOfDigits(x)) > x)

+{

+}

+

+proof fn NumberIdentity(number: nat, pmax: nat)

+    requires(pmax == Power10(NumberOfDigits(number)))

+    ensures(number == number % pmax)

+{

+}

+

+proof fn InIntValues(n: nat)

+    ensures(IntValues(n).contains(0))

+    ensures(IntValues(n).contains(n))

+    ensures(IntValues(n).contains(n/10))

+{

+}

+

+spec fn IntValues(n: int) -> (r: Seq<int>)

+    requires(n >= 0)

+    ensures(r.contains(0))

+    ensures(r.contains(n))

+    ensures(r.contains(n/10))

+{

+    if n == 0 { seq![0] }

+    else { seq![n] + IntValues(n/10) }

+}

+

+spec fn Power10(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(n > 0 ==> r % 10 == 0)

+{

+    if (n == 0) { 1 } else { 10 * Power10(n-1) }

+}

+

+spec fn NumberToSeq(number: int) -> Seq<int>

+    requires(number >= 0)

+{

+    if number == 0 { seq![] }

+    else { seq![number % 10] + NumberToSeq(number/10) }

+}

+

+spec fn Sum(digits: Seq<int>) -> int

+{

+    if digits.len() == 0 { 0 } else { digits[0] + Sum(digits.subrange(1, digits.len() as int)) }

+}

+

+spec fn SumDigits(n: nat) -> nat

+{

+    let ndigits = NumberOfDigits(n);

+    let p = Power10(ndigits-1);

+    SumDigitsRecursive(n, p)

+}

+

+spec fn SumDigitsRecursive(n: nat, p: nat) -> (r: nat)

+{

+    if n == 0 || p == 0 { 0 }

+    else {

+        let leftMostDigit = n/p;

+        let rest = n%p;

+        leftMostDigit + SumDigitsRecursive(rest, p/10)

+    }

+}

+

+spec fn NumberOfDigits(n: nat) -> (r: nat)

+    ensures(r >= 1)

+    ensures(r == 1 <==> (0 <= n <= 9))

+{

+    if 0 <= n <= 9 { 1 } else { 1 + NumberOfDigits(n/10) }

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_567_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_567_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_567_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSorted(a: Vec<int>) -> (sorted: bool)

-    requires a.len() > 0

-    ensures sorted <== forall|i: int, j: int| 0 <= i < j < a.len() ==> a[i] <= a[j],

-            !sorted ==> exists|i: int, j: int| 0 <= i < j < a.len() and a[i] > a[j]

+pub fn is_sorted(a: &[i32]) -> (sorted: bool)

+    requires(a.len() > 0)

+    ensures(sorted <== forall|i: usize, j: usize| 0 <= i < j < a.len() ==> a[i] <= a[j])

+    ensures(!sorted ==> exists|i: usize, j: usize| 0 <= i < j < a.len() && a[i] > a[j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_572_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_572_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_572_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveDuplicates(a: Vec<int>) -> (result: Seq<int>)

-    requires a != null

-    ensures forall|x: int| x in result <==> exists|i: int| 0 <= i < a.len() and a[i] == x,

-            forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j]

+pub fn remove_duplicates(a: &[i32]) -> (result: Vec<i32>)

+    requires(true)

+    ensures(forall|x: i32| result@.contains(x) <==> exists|i: usize| 0 <= i < a.len() && a[i] == x)

+    ensures(forall|i: usize, j: usize| 0 <= i < j < result@.len() ==> result@[i] != result@[j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_573_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_573_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_573_spec.rs
@@ -1,14 +1,34 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

-fn UniqueProduct(arr: Vec<int>) -> (product: int)

-    ensures product == SetProduct((set i | 0 <= i < arr.len() :: arr[i]))

+pub fn UniqueProduct(arr: &[int]) -> (product: int)

+    ensures(product == SetProduct(Set::new(|i: int| 0 <= i < arr.len() ==> arr[i as usize])))

 {

 }

 

+spec fn SetProduct(s: Set<int>) -> int

+{

+    if s == Set::empty() {

+        1

+    } else {

+        let x = s.choose();

+        x * SetProduct(s.remove(x))

+    }

+}

+

+proof fn SetProductLemma(s: Set<int>, x: int)

+    requires(s.contains(x))

+    ensures(SetProduct(s.remove(x)) * x == SetProduct(s))

+{

+    if s != Set::empty() {

+        let y = s.choose();

+        if y == x {

+        } else {

+            SetProductLemma(s.remove(y), x);

+            SetProductLemma(s.remove(x), y);

+        }

+    }

+}

+

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_576_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_576_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_576_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)

-    ensures true <== (exists|i: int| 0 <= i <= main.len() - sub.len() and sub == main[i..i + sub.len()])

+pub fn is_sublist(sub: Seq<int>, main: Seq<int>) -> (result: bool)

+    ensures(true <== (exists|i: int| 0 <= i <= main.len() - sub.len() && sub == main.subrange(i, i + sub.len())))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_577_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_577_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_577_spec.rs
@@ -1,15 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn Factorial(n: int) -> int

+    recommends n >= 0

+{

+    if n == 0 { 1 } else { n * Factorial(n-1) }

+}

 

-verus! {

 

-fn FactorialOfLastDigit(n: int) -> (fact: int)

+pub fn FactorialOfLastDigit(n: int) -> (fact: int)

     requires n >= 0

     ensures fact == Factorial(n % 10)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_578_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_578_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_578_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

-    requires s1.len() == s2.len() and s2.len() == s3.len()

-    ensures r.len() == 3 * s1.len(),

-            forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] and r[3*i + 1] == s2[i] and r[3*i + 2] == s3[i]

+pub fn interleave(s1: Seq<int>, s2: Seq<int>, s3: Seq<int>) -> (r: Seq<int>)

+    requires(s1.len() == s2.len() && s2.len() == s3.len())

+    ensures(|r| r.len() == 3 * s1.len())

+    ensures(|r| forall|i: int| 0 <= i < s1.len() ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_581_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_581_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_581_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

-    requires baseEdge > 0,

-             height > 0

-    ensures area == baseEdge * baseEdge + 2 * baseEdge * height

+pub fn SquarePyramidSurfaceArea(baseEdge: int, height: int) -> (area: int)

+    requires(baseEdge > 0)

+    requires(height > 0)

+    ensures(|area: int| area == baseEdge * baseEdge + 2 * baseEdge * height)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_586_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_586_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_586_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SplitAndAppend(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0 and n < l.len()

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i + n) % l.len()]

+pub fn split_and_append(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0 && n < l.len())

+    ensures(|r: Seq<int>| r.len() == l.len())

+    ensures(|r: Seq<int>| forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i + n) % l.len()])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_587_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_587_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_587_spec.rs
@@ -1,16 +1,10 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ArrayToSeq(a: Vec<int>) -> (s: Seq<int>)

-    requires a != null

-    ensures s.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> s[i] == a[i]

+pub fn ArrayToSeq(a: &[i32]) -> (s: Vec<i32>)

+    requires(

+        true

+    )

+    ensures(|s: Vec<i32>| 

+        s.len() == a.len() &&

+        forall|i: usize| 0 <= i < a.len() ==> s[i] == a[i]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_588_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_588_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_588_spec.rs
@@ -1,15 +1,39 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn DifferenceMinMax(a: Vec<int>) -> (diff: int)

-    requires a.len() > 0

-    ensures diff == Max(a[..]) - Min(a[..])

+pub fn DifferenceMinMax(a: &[i32]) -> (diff: i32)

+    requires

+        a.len() > 0,

+    ensures |diff: i32|

+        diff == Max(a@) - Min(a@),

 {

 }

 

+pub open spec fn Min(a: Seq<i32>) -> i32

+    recommends

+        a.len() > 0,

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let minPrefix = Min(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] <= minPrefix {

+            a[a.len() - 1]

+        } else {

+            Min(a.subrange(0, a.len() - 1))

+        }

+    }

+}

+

+pub open spec fn Max(a: Seq<i32>) -> i32

+    recommends

+        a.len() > 0,

+{

+    if a.len() == 1 {

+        a[0]

+    } else {

+        let maxPrefix = Max(a.subrange(0, a.len() - 1));

+        if a[a.len() - 1] >= maxPrefix {

+            a[a.len() - 1]

+        } else {

+            Max(a.subrange(0, a.len() - 1))

+        }

+    }

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_58_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_58_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_58_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOppositeSign(a: int, b: int) -> (result: bool)

-    ensures result <==> (a < 0 and b > 0) or (a > 0 and b < 0)

+pub fn has_opposite_sign(a: i32, b: i32) -> bool

+    ensures(|result: bool| result <==> (a < 0 && b > 0) || (a > 0 && b < 0))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_594_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_594_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_594_spec.rs
@@ -1,25 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+pub open spec fn is_even(n: int) -> bool {

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+pub open spec fn is_odd(n: int) -> bool {

     n % 2 != 0

 }

 

-fn FirstEvenOddDifference(a: Vec<int>) -> (diff: int)

-    requires a.len() >= 2,

-             exists|i: int| 0 <= i < a.len() and IsEven(a[i]),

-             exists|i: int| 0 <= i < a.len() and IsOdd(a[i])

-    ensures exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and IsEven(a[i]) and IsOdd(a[j]) and diff == a[i] - a[j] and 

-        (forall|k: int| 0 <= k < i ==> IsOdd(a[k])) and (forall|k: int| 0 <= k < j ==> IsEven(a[k]))

+

+pub fn first_even_odd_difference(a: &[int]) -> (diff: int)

+    requires 

+        a.len() >= 2,

+        exists|i: int| 0 <= i < a.len() && is_even(a[i as usize]),

+        exists|i: int| 0 <= i < a.len() && is_odd(a[i as usize]),

+    ensures 

+        exists|i: int, j: int| 0 <= i < a.len() && 0 <= j < a.len() && is_even(a[i as usize]) && is_odd(a[j as usize]) && diff == a[i as usize] - a[j as usize] && 

+            (forall|k: int| 0 <= k < i ==> is_odd(a[k as usize])) && (forall|k: int| 0 <= k < j ==> is_even(a[k as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_598_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_598_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_598_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsArmstrong(n: int) -> (result: bool)

-    requires 100 <= n < 1000

-    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))

+pub fn IsArmstrong(n: int) -> (result: bool)

+    requires(100 <= n < 1000)

+    ensures(result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10))))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_59_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_59_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_59_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

-    requires n >= 0

-    ensures octagonalNumber == n * (3 * n - 2)

+pub fn NthOctagonalNumber(n: int) -> (octagonalNumber: int)

+    requires(n >= 0)

+    ensures(octagonalNumber == n * (3 * n - 2))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_600_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_600_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_600_spec.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsEven(n: int) -> (result: bool)

-    ensures result <==> n % 2 == 0

+pub fn is_even(n: int) -> (result: bool)

+    ensures(result <==> n % 2 == 0)

 {

-}

-

+    todo!()

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_602_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_602_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_602_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstRepeatedChar(s: String) -> found: bool, c: char

-    ensures found ==> exists|i: int, j: int| 0 <= i < j < s.len() and s[i] == s[j] and s[i] == c and (forall|k: int, l: int| 0 <= k < l < j and s[k] == s[l] ==> k >= i),

-            !found ==> (forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j])

+pub fn find_first_repeated_char(s: &str) -> (found: bool, c: char)

+    ensures(found ==> exists|i: int, j: int| 0 <= i < j < s.len() && s[i] == s[j] && s[i] == c && (forall|k: int, l: int| 0 <= k < l < j && s[k] == s[l] ==> k >= i))

+    ensures(!found ==> (forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] != s[j]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_603_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_603_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_603_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LucidNumbers(n: int) -> (lucid: Seq<int>)

-    requires n >= 0

-    ensures forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0,

-            forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n,

-            forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j]

+pub fn LucidNumbers(n: int) -> (lucid: Seq<int>)

+    requires(n >= 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] % 3 == 0)

+    ensures(forall|i: int| 0 <= i < lucid.len() ==> lucid[i] <= n)

+    ensures(forall|i: int, j: int| 0 <= i < j < lucid.len() ==> lucid[i] < lucid[j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_605_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_605_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_605_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPrime(n: int) -> (result: bool)

-    requires n >= 2

-    ensures result <==> (forall|k: int| 2 <= k < n ==> n % k != 0)

+pub fn is_prime(n: int) -> (result: bool)

+    requires(n >= 2)

+    ensures(result <==> (forall|k: int| 2 <= k < n >>= n % k != 0))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_610_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_610_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_610_spec.rs
@@ -1,17 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RemoveElement(s: Vec<int>, k: int) -> (v: Vec<int>)

-    requires 0 <= k < s.len()

-    ensures v.len() == s.len() - 1,

-            forall|i: int| 0 <= i < k ==> v[i] == s[i],

-            forall|i: int| k <= i < v.len() ==> v[i] == s[i + 1]

+pub fn remove_element(s: &[i32], k: usize) -> Vec<i32>

+    requires k < s.len()

+    ensures |result: Vec<i32>| result.len() == s.len() - 1

+    ensures |result: Vec<i32>| forall|i: usize| 0 <= i < k ==> result[i] == s[i]

+    ensures |result: Vec<i32>| forall|i: usize| k <= i < result.len() ==> result[i] == s[i + 1]

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_616_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_616_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_616_spec.rs
@@ -1,19 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseModulo(a: Vec<int>, b: Vec<int>) -> (result: Vec<int>)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result != null,

-            result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] % b[i]

+pub fn element_wise_modulo(a: &[i32], b: &[i32]) -> Vec<i32>

+    requires

+        a.len() == b.len(),

+        forall|i: usize| 0 <= i < b.len() ==> b[i] != 0,

+    ensures |result: Vec<i32>|

+        result.len() == a.len() &&

+        forall|i: usize| 0 <= i < result.len() ==> result[i] == a[i] % b[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_618_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_618_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_618_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ElementWiseDivide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len(),

-             forall|i: int| 0 <= i < b.len() ==> b[i] != 0

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i]

+pub fn element_wise_divide(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires

+        a.len() == b.len(),

+        forall|i: int| 0 <= i < b.len() ==> b[i] != 0,

+    ensures

+        result.len() == a.len(),

+        forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] / b[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_61_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_61_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_61_spec.rs
@@ -1,18 +1,10 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn CountSubstringsWithSumOfDigitsEqualToLength(s: String) -> (count: int)

+

+pub fn count_substrings_with_sum_of_digits_equal_to_length(s: &str) -> (count: i32)

     ensures count >= 0

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_622_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_622_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_622_spec.rs
@@ -1,19 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindMedian(a: Vec<int>, b: Vec<int>) -> (median: int)

-    requires a != null and b != null,

-             a.len() == b.len(),

-             a.len() > 0,

-             forall|i: int| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1],

-             forall|i: int| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1]

-    ensures median == if (a.len() % 2 == 0) then (a[a.len() / 2 - 1] + b[0]) / 2 else a[a.len() / 2]

+pub fn find_median(a: &[i32], b: &[i32]) -> i32

+    requires(

+        a.len() == b.len() &&

+        a.len() > 0 &&

+        forall|i: usize| 0 <= i < a.len() - 1 ==> a[i] <= a[i + 1] &&

+        forall|i: usize| 0 <= i < b.len() - 1 ==> b[i] <= b[i + 1]

+    )

+    ensures(|median: i32|

+        median == if a.len() % 2 == 0 { (a[a.len() / 2 - 1] + b[0]) / 2 } else { a[a.len() / 2] }

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_623_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_623_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_623_spec.rs
@@ -1,16 +1,16 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn PowerOfListElements(l: Seq<int>, n: int) -> (result: Seq<int>)

-    requires n >= 0

-    ensures result.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> result[i] == Power(l[i], n)

+pub fn power_of_list_elements(l: Seq<int>, n: int) -> (result: Seq<int>)

+    requires(n >= 0)

+    ensures(|result| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> result[i] == power(l[i], n))

 {

 }

 

+spec fn power(base: int, exponent: int) -> int

+    recommends(exponent >= 0)

+{

+    if exponent == 0 {

+        1

+    } else {

+        base * power(base, exponent - 1)

+    }

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_624_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_624_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_624_spec.rs
@@ -1,22 +1,26 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsLowerCase(c: char) -> bool {

+pub fn is_lower_case(c: char) -> bool {

     97 <= c as int <= 122

 }

-spec fn IsLowerUpperPair(c: char, C: char) -> bool {

+

+pub fn is_lower_upper_pair(c: char, C: char) -> bool {

     (c as int) == (C as int) + 32

 }

 

-fn ToUppercase(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]

-{

+pub fn shift_minus_32(c: char) -> char {

+    ((c as int - 32) % 128) as char

 }

 

+pub fn to_uppercase(s: &str) -> (v: String)

+    ensures(

+        v.len() == s.len()

+    )

+    ensures(

+        forall|i: usize| 0 <= i < s.len() ==> 

+            if is_lower_case(s[i]) { 

+                is_lower_upper_pair(s[i], v[i]) 

+            } else { 

+                v[i] == s[i] 

+            }

+    )

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_626_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_626_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_626_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

-    requires radius > 0

-    ensures area == radius * radius

+pub fn AreaOfLargestTriangleInSemicircle(radius: int) -> (area: int)

+    requires(radius > 0)

+    ensures(area == radius * radius)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_627_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_627_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_627_spec.rs
@@ -1,18 +1,14 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestMissingNumber(s: Seq<int>) -> (v: int)

-    requires forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j],

-             forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

-    ensures 0 <= v,

-            v !in s,

-            forall|k: int| 0 <= k < v ==> k in s

+pub fn smallest_missing_number(s: &Vec<int>) -> (v: int)

+    requires(

+        forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]

+    )

+    requires(

+        forall|i: int| 0 <= i < s.len() ==> s[i] >= 0

+    )

+    ensures(|v: int|

+        0 <= v &&

+        !(s.contains(v)) &&

+        forall|k: int| 0 <= k < v ==> s.contains(k)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_629_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_629_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_629_spec.rs
@@ -1,8 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+use vstd::prelude::*;

 

 verus! {

 

@@ -10,4 +6,15 @@
     n % 2 == 0

 }

 

+pub fn FindEvenNumbers(arr: &[int]) -> (evenList: Seq<int>)

+    requires()

+    ensures(

+        forall|i: int| 0 <= i < evenList.len() ==> IsEven(evenList[i]) && arr@.contains(evenList[i])

+    )

+    ensures(

+        forall|i: int| 0 <= i < arr.len() && IsEven(arr[i]) ==> evenList.contains(arr[i])

+    )

+{

+}

+

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_62_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_62_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_62_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindSmallest(s: Vec<int>) -> (min: int)

+pub fn find_smallest(s: &[i32]) -> (min: i32)

     requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> min <= s[i],

-            exists|i: int| 0 <= i < s.len() and min == s[i]

+    ensures forall|i: usize| 0 <= i < s.len() ==> min <= s[i]

+    ensures exists|i: usize| 0 <= i < s.len() && min == s[i]

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_637_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_637_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_637_spec.rs
@@ -1,15 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

-    requires costPrice >= 0 and sellingPrice >= 0

-    ensures result <==> costPrice == sellingPrice

+pub fn IsBreakEven(costPrice: int, sellingPrice: int) -> (result: bool)

+    requires

+        costPrice >= 0 && sellingPrice >= 0,

+    ensures

+        result <==> costPrice == sellingPrice,

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_641_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_641_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_641_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn NthNonagonalNumber(n: int) -> (number: int)

-    requires n >= 0

-    ensures number == n * (7 * n - 5) / 2

+pub fn NthNonagonalNumber(n: int) -> (number: int)

+    requires(n >= 0)

+    ensures(number == n * (7 * n - 5) / 2)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_69_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_69_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_69_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsSequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

-    ensures result <==> (exists|i: int| 0 <= i < list.len() and sub == list[i])

+pub fn contains_sequence(list: Seq<Seq<int>>, sub: Seq<int>) -> (result: bool)

+    ensures(result <==> (exists|i: int| 0 <= i < list.len() && sub == list[i]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_70_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_70_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_70_spec.rs
@@ -1,14 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllSequencesEqualLength(sequences: Seq<Seq<int>>) -> (result: bool)

-    ensures result <==> forall|i: int, j: int| 0 <= i < sequences.len() and 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len()

+pub fn all_sequences_equal_length(sequences: Seq<Seq<int>>) -> (result: bool)

+    ensures

+        result <==> (forall|i: int, j: int| 0 <= i < sequences.len() && 0 <= j < sequences.len() ==> sequences[i].len() == sequences[j].len())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_728_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_728_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_728_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddLists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

-    requires a.len() == b.len()

-    ensures result.len() == a.len(),

-            forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i]

+pub fn AddLists(a: Seq<int>, b: Seq<int>) -> (result: Seq<int>)

+    requires(a.len() == b.len())

+    ensures(|result: Seq<int>| result.len() == a.len())

+    ensures(|result: Seq<int>| forall|i: int| 0 <= i < result.len() ==> result[i] == a[i] + b[i])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_732_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_732_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_732_spec.rs
@@ -1,19 +1,15 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsSpaceCommaDot(c: char) -> bool {

-    c == ' ' | c == ',' .len()| c == '.'

+pub open spec fn is_space_comma_dot(c: char) -> bool

+{

+    c == ' ' || c == ',' || c == '.'

 }

 

-fn ReplaceWithColon(s: String) -> (v: String)

-    ensures v.len() == s.len(),

-            forall|i: int| 0 <= i < s.len() ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') and (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])

+

+pub fn replace_with_colon(s: &str) -> (v: String)

+    ensures

+        v.len() == s.len(),

+        forall|i: int| 0 <= i < s.len() ==> 

+            (is_space_comma_dot(s[i as usize]) ==> v[i as usize] == ':') && 

+            (!is_space_comma_dot(s[i as usize]) ==> v[i as usize] == s[i as usize])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_733_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_733_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_733_spec.rs
@@ -1,18 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn FindFirstOccurrence(arr: Vec<int>, target: int) -> (index: int)

-    requires arr != null,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures 0 <= index < arr.len() ==> arr[index] == target,

-            index == -1 ==> forall|i: int| 0 <= i < arr.len() ==> arr[i] != target,

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn find_first_occurrence(arr: &[i32], target: i32) -> (index: i32)

+    requires forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

+    ensures |index: i32| 0 <= index < arr.len() ==> arr[index as usize] == target

+    ensures |index: i32| index == -1 ==> forall|i: usize| 0 <= i < arr.len() ==> arr[i] != target

+    ensures |index: i32| forall|i: usize| 0 <= i < arr.len() ==> arr[i] == old(arr)[i]

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_741_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_741_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_741_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AllCharactersSame(s: String) -> (result: bool)

-    ensures result ==> forall|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() ==> s[i] == s[j],

-            !result ==> (s.len() > 1) and (exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] != s[j])

+pub fn AllCharactersSame(s: &str) -> (result: bool)

+    ensures(result ==> forall|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() ==> s[i] == s[j])

+    ensures(!result ==> (s.len() > 1) && (exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] != s[j]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_743_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_743_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_743_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateRight(l: Seq<int>, n: int) -> (r: Seq<int>)

-    requires n >= 0

-    ensures r.len() == l.len(),

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[(i - n + l.len()) % l.len()]

+pub fn rotate_right(l: Seq<int>, n: int) -> (r: Seq<int>)

+    requires(n >= 0)

+    ensures(|r| == |l|)

+    ensures(forall|i: int| 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_750_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_750_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_750_spec.rs
@@ -1,16 +1,7 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn AddTupleToList(l: seq<(int, int)>, t: (int, int)) -> r: seq<(int, int)>

-    ensures r.len() == l.len() + 1,

-            r[r.len() - 1] == t,

-            forall|i: int| 0 <= i < l.len() ==> r[i] == l[i]

+pub fn AddTupleToList(l: Seq<(int, int)>, t: (int, int)) -> (r: Seq<(int, int)>)

+    ensures

+        r.len() == l.len() + 1,

+        r[r.len() - 1] == t,

+        forall|i: int| 0 <= i < l.len() ==> r[i] == l[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_751_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_751_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_751_spec.rs
@@ -1,16 +1,12 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMinHeap(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] and (2*i + 2 == a.len() or a[i] <= a[2*i + 2]),

-            !result ==> exists|i: int| 0 <= i < a.len() / 2 and (a[i] > a[2*i + 1] or (2*i + 2 != a.len() and a[i] > a[2*i + 2]))

+pub fn is_min_heap(a: &[int]) -> (result: bool)

+    requires(

+        true

+    )

+    ensures(|result: bool|

+        result ==> forall|i: int| 0 <= i < a.len() / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.len() || a[i] <= a[2*i + 2])

+    )

+    ensures(|result: bool|

+        !result ==> exists|i: int| 0 <= i < a.len() / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.len() && a[i] > a[2*i + 2]))

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_755_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_755_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_755_spec.rs
@@ -1,18 +1,23 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SecondSmallest(s: Vec<int>) -> (secondSmallest: int)

-    requires s.len() >= 2

-

-             exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] != s[i]

-    ensures exists|i: int, j: int| 0 <= i < s.len() and 0 <= j < s.len() and i != j and s[i] == min(s[..]) and s[j] == secondSmallest,

-            forall|k: int|  0 <= k < s.len() and s[k] != min(s[..])  ==>  s[k] >= secondSmallest

+pub fn MinPair(s: Seq<int>) -> (r: int)

+    requires(s.len() == 2)

+    ensures(|r| s[0] <= s[1] <==> r == s[0])

+    ensures(|r| s[0] > s[1] ==> r == s[1])

 {

 }

 

+

+pub fn min(s: Seq<int>) -> (r: int)

+    requires(s.len() >= 2)

+    ensures(|r| forall|i: int| 0 <= i < s.len() ==> r <= s[i])

+{

+}

+

+

+pub fn SecondSmallest(s: &[int]) -> (secondSmallest: int)

+    requires(s.len() >= 2)

+    requires(exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] == min(s@) && s[j] != s[i])

+    ensures(|secondSmallest| exists|i: usize, j: usize| 0 <= i < s.len() && 0 <= j < s.len() && i != j && s[i] == min(s@) && s[j] == secondSmallest)

+    ensures(|secondSmallest| forall|k: usize| 0 <= k < s.len() && s[k] != min(s@) ==> s[k] >= secondSmallest)

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_759_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_759_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_759_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDecimalWithTwoPrecision(s: String) -> (result: bool)

-    ensures result ==> (exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2),

-            !result ==> !(exists|i: int| 0 <= i < s.len() and s[i] == '.' and s.len() - i - 1 == 2)

+pub fn is_decimal_with_two_precision(s: &str) -> (result: bool)

+    ensures(result ==> (exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

+    ensures(!result ==> !(exists|i: usize| 0 <= i < s.len() && s.as_bytes()[i] == b'.' && s.len() - i - 1 == 2))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_760_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_760_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_760_spec.rs
@@ -1,16 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn HasOnlyOneDistinctElement(a: Vec<int>) -> (result: bool)

-    requires a != null

-    ensures result ==> forall|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() ==> a[i] == a[j],

-            !result ==> exists|i: int, j: int| 0 <= i < a.len() and 0 <= j < a.len() and a[i] != a[j]

+pub fn HasOnlyOneDistinctElement(a: &[i32]) -> (result: bool)

+    ensures(result ==> forall|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() ==> a[i] == a[j])

+    ensures(!result ==> exists|i: usize, j: usize| 0 <= i < a.len() && 0 <= j < a.len() && a[i] != a[j])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_762_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_762_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_762_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsMonthWith30Days(month: int) -> (result: bool)

-    requires 1 <= month <= 12

-    ensures result <==> month == 4 | month == 6 .len() month == 9 .len()| month == 11

+pub fn IsMonthWith30Days(month: int) -> (result: bool)

+    requires(1 <= month <= 12)

+    ensures(result <==> month == 4 || month == 6 || month == 9 || month == 11)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_764_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_764_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_764_spec.rs
@@ -1,19 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsDigit(c: char) -> bool {

+pub open spec fn is_digit(c: char) -> bool {

     48 <= c as int <= 57

 }

 

-fn CountDigits(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 0 <= i < s.len() and IsDigit(s[i])|

+

+pub fn count_digits(s: &str) -> (count: i32)

+    ensures

+        count >= 0,

+        count == (set_int_range(0, s@.len()).filter(|i: int| is_digit(s@[i]))).len(),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_769_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_769_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_769_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn Difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

-    ensures forall|x: int| x in diff <==> (x in a and x !in b),

-            forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]

+pub fn difference(a: Seq<int>, b: Seq<int>) -> (diff: Seq<int>)

+    ensures(forall|x: int| diff.contains(x) <==> (a.contains(x) && !b.contains(x))),

+    ensures(forall|i: int, j: int| 0 <= i < j < diff.len() ==> diff[i] != diff[j]),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_770_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_770_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_770_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SumOfFourthPowerOfOddNumbers(n: int) -> (sum: int)

-    requires n > 0

-    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15

+pub fn sum_of_fourth_power_of_odd_numbers(n: int) -> (sum: int)

+    requires(n > 0)

+    ensures(sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n - 14 * n + 7) / 15)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_775_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_775_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_775_spec.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(n: int) -> bool {

+pub open spec fn IsOdd(n: int) -> bool

+{

     n % 2 == 1

 }

 

-fn IsOddAtIndexOdd(a: Vec<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (IsOdd(i) ==> IsOdd(a[i]))

+

+pub fn IsOddAtIndexOdd(a: &[i32]) -> (result: bool)

+    ensures result <==> forall|i: int| 0 <= i < a.len() ==> (IsOdd(i) ==> IsOdd(a[i] as int))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_776_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_776_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_776_spec.rs
@@ -1,19 +1,21 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsVowel(c: char) -> bool {

-    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'

+pub open spec fn is_vowel(c: char) -> bool {

+    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || 

+    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'

 }

 

-fn CountVowelNeighbors(s: String) -> (count: int)

-    ensures count >= 0,

-            count ==  set i: int .len() 1 <= i < s.len()-1 and IsVowel(s[i-1]) and IsVowel(s[i+1]) |

+

+pub fn count_vowel_neighbors(s: &str) -> (count: i32)

+    requires(

+        s.len() <= i32::MAX

+    )

+    ensures(

+        count >= 0 &&

+        count == (set_int_range(1, s.len() as int - 1).filter(

+            |i: int| 1 <= i < s.len() - 1 && 

+                    is_vowel(s@[i-1]) && 

+                    is_vowel(s@[i+1])

+        ).len() as i32)

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_77_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_77_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_77_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsDivisibleBy11(n: int) -> (result: bool)

-    ensures result <==> n % 11 == 0

+pub fn is_divisible_by_11(n: int) -> (result: bool)

+    ensures(result <==> n % 11 == 0)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_784_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_784_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_784_spec.rs
@@ -1,35 +1,51 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

-spec fn IsOdd(n: int) -> bool {

+

+

+spec fn is_odd(n: int) -> bool

+{

     n % 2 != 0

 }

-spec fn IsFirstEven(evenIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < evenIndex ==> IsOdd(lst[i])

-}

-spec fn IsFirstOdd(oddIndex: int, lst: Seq<int>) -> bool {

-    forall|i: int| 0 <= i < oddIndex ==> IsEven(lst[i])

+

+

+spec fn is_first_even(even_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= even_index < lst.len(),

+        is_even(lst[even_index as int])

+{

+    forall|i: int| 0 <= i < even_index ==> is_odd(lst[i])

 }

 

-fn FirstEvenOddIndices(lst: Seq<int>) -> evenIndex: int, oddIndex: int

-    requires lst.len() >= 2,

-             exists|i: int| 0 <= i < lst.len() and IsEven(lst[i]),

-             exists|i: int| 0 <= i < lst.len() and IsOdd(lst[i])

-    ensures 0 <= evenIndex < lst.len(),

-            0 <= oddIndex < lst.len()

 

-            that it's the first, not just any,

-            IsEven(lst[evenIndex]) and IsFirstEven(evenIndex, lst),

-            IsOdd(lst[oddIndex]) and IsFirstOdd(oddIndex, lst)

+spec fn is_first_odd(odd_index: int, lst: Seq<int>) -> bool

+    recommends

+        0 <= odd_index < lst.len(),

+        is_odd(lst[odd_index as int])

+{

+    forall|i: int| 0 <= i < odd_index ==> is_even(lst[i])

+}

+

+

+pub fn first_even_odd_indices(lst: Seq<int>) -> (even_index: int, odd_index: int)

+    requires(lst.len() >= 2)

+    requires(exists|i: int| 0 <= i < lst.len() && is_even(lst[i]))

+    requires(exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]))

+    ensures(0 <= even_index < lst.len())

+    ensures(0 <= odd_index < lst.len())

+    ensures(is_even(lst[even_index]) && is_first_even(even_index, lst))

+    ensures(is_odd(lst[odd_index]) && is_first_odd(odd_index, lst))

 {

 }

 

+

+pub fn product_even_odd(lst: Seq<int>) -> (product: int)

+    requires(lst.len() >= 2)

+    requires(exists|i: int| 0 <= i < lst.len() && is_even(lst[i]))

+    requires(exists|i: int| 0 <= i < lst.len() && is_odd(lst[i]))

+    ensures(exists|i: int, j: int| 0 <= i < lst.len() && is_even(lst[i]) && is_first_even(i, lst) && 

+                           0 <= j < lst.len() && is_odd(lst[j]) && is_first_odd(j, lst) && product == lst[i] * lst[j])

+{

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_790_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_790_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_790_spec.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn IsEvenAtIndexEven(lst: Seq<int>) -> (result: bool)

-    ensures result <==> forall|i: int| 0 <= i < lst.len() ==> (IsEven(i) ==> IsEven(lst[i]))

+

+pub fn is_even_at_index_even(lst: Seq<int>) -> (result: bool)

+    ensures(result <==> forall|i: int| 0 <= i < lst.len() ==> (is_even(i) ==> is_even(lst[i])))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_792_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_792_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_792_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountLists(lists: Seq<Seq<int>>) -> (count: int)

+pub fn count_lists(lists: Seq<Seq<int>>) -> (count: int)

     ensures count >= 0,

-            count == lists.len()

+    ensures count == lists.len(),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_793_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_793_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_793_spec.rs
@@ -1,17 +1,11 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn LastPosition(arr: Vec<int>, elem: int) -> (pos: int)

-    requires arr.len() > 0,

-             forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

-    ensures pos == -1 | (0 <= pos < arr.len() and arr[pos] == elem and (pos <= arr.len() - 1 .len()| arr[pos + 1] > elem)),

-            forall|i: int| 0 <= i < arr.len() ==> arr[i] == old(arr[i])

+pub fn last_position(arr: &mut [i32], elem: i32) -> (pos: i32)

+    requires(

+        arr.len() > 0,

+        forall|i: usize, j: usize| 0 <= i < j < arr.len() ==> arr[i] <= arr[j]

+    )

+    ensures(|pos: i32|

+        pos == -1 || (0 <= pos < arr.len() && arr[pos as usize] == elem && (pos <= arr.len() as i32 - 1 || arr[(pos + 1) as usize] > elem)),

+        forall|i: usize| 0 <= i < arr.len() ==> arr[i] == old(arr)[i]

+    )

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_798_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_798_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_798_spec.rs
@@ -1,14 +1,12 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

+spec fn sumTo(a: &[int], n: int) -> int

+    requires 0 <= n && n <= a.len()

+{

+    if n == 0 { 0 } else { sumTo(a, n-1) + a[n-1] }

+}

 

-verus! {

 

-fn ArraySum(a: Vec<int>) -> (result: int)

+pub fn ArraySum(a: &[int]) -> (result: int)

     ensures result == sumTo(a, a.len())

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_799_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_799_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_799_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn RotateLeftBits(n: bv32, d: int) -> (result: bv32)

-    requires 0 <= d < 32

-    ensures result == ((n << d) | (n >> (32 - d)))

+pub fn rotate_left_bits(n: u32, d: int) -> (result: u32)

+    requires(0 <= d < 32)

+    ensures(|result: u32| result == ((n << d) | (n >> (32 - d))))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_79_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_79_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_79_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsLengthOdd(s: String) -> (result: bool)

-    ensures result <==> s.len() % 2 == 1

+pub fn is_length_odd(s: &str) -> (result: bool)

+    ensures(result <==> s.len() % 2 == 1)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_801_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_801_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_801_spec.rs
@@ -1,17 +1,8 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CountEqualNumbers(a: int, b: int, c: int) -> (count: int)

-    ensures count >= 0 and count <= 3,

-            (count == 3) <==> (a == b and b == c),

-            (count == 2) <==> ((a == b and b != c) | (a != b and b == c) .len()| (a == c and b != c)),

-            (count == 1) <==> (a != b and b != c and a != c)

+pub fn count_equal_numbers(a: int, b: int, c: int) -> (count: int)

+    ensures

+        count >= 0 && count <= 3,

+        (count == 3) <==> (a == b && b == c),

+        (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c)),

+        (count == 1) <==> (a != b && b != c && a != c),

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_803_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_803_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_803_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsPerfectSquare(n: int) -> (result: bool)

-    requires n >= 0

-    ensures result == true ==> (exists i: int :: 0 <= i <= n and i * i == n),

-            result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)

+pub fn is_perfect_square(n: int) -> (result: bool)

+    requires(n >= 0)

+    ensures(result == true ==> (exists|i: int| 0 <= i <= n && i * i == n))

+    ensures(result == false ==> (forall|a: int| 0 < a*a < n ==> a*a != n))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_804_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_804_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_804_spec.rs
@@ -1,18 +1,11 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsEven(n: int) -> bool {

+spec fn is_even(n: int) -> bool

+{

     n % 2 == 0

 }

 

-fn IsProductEven(a: Vec<int>) -> (result: bool)

-    ensures result <==> exists|i: int| 0 <= i < a.len() and IsEven(a[i])

+

+pub fn is_product_even(a: &[int]) -> (result: bool)

+    ensures(result <==> exists|i: int| 0 <= i < a.len() && is_even(a[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_807_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_807_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_807_spec.rs
@@ -1,20 +1,13 @@
 

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-spec fn IsOdd(x: int) -> bool {

+spec fn IsOdd(x: int) -> bool

+{

     x % 2 != 0

 }

 

-fn FindFirstOdd(a: Vec<int>) -> found: bool, index: int

-    requires a != null

-    ensures !found ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i]),

-            found ==> 0 <= index < a.len() and IsOdd(a[index]) and forall|i: int| 0 <= i < index ==> !IsOdd(a[i])

+

+pub fn FindFirstOdd(a: &[int]) -> (found: bool, index: int)

+    requires(a.len() >= 0)

+    ensures(|result: (bool, int)| !result.0 ==> forall|i: int| 0 <= i < a.len() ==> !IsOdd(a[i as usize]))

+    ensures(|result: (bool, int)| result.0 ==> 0 <= result.1 < a.len() && IsOdd(a[result.1 as usize]) && forall|i: int| 0 <= i < result.1 ==> !IsOdd(a[i as usize]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_808_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_808_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_808_spec.rs
@@ -1,14 +1,4 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ContainsK(s: Seq<int>, k: int) -> (result: bool)

-    ensures result <==> k in s

+pub fn contains_k(s: Seq<int>, k: int) -> (result: bool)

+    ensures(result <==> s.contains(k))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_809_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_809_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_809_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn IsSmaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

-    requires a.len() == b.len()

-    ensures result <==> forall|i: int| 0 <= i < a.len() ==> a[i] > b[i],

-            !result <==> exists|i: int| 0 <= i < a.len() and a[i] <= b[i]

+pub fn is_smaller(a: Seq<int>, b: Seq<int>) -> (result: bool)

+    requires(a.len() == b.len())

+    ensures(result <==> (forall|i: int| 0 <= i < a.len() ==> a[i] > b[i]))

+    ensures(!result <==> (exists|i: int| 0 <= i < a.len() && a[i] <= b[i]))

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_80_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_80_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_80_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn TetrahedralNumber(n: int) -> (t: int)

-    requires n >= 0

-    ensures t == n * (n + 1) * (n + 2) / 6

+pub fn tetrahedral_number(n: int) -> (t: int)

+    requires(n >= 0)

+    ensures(t == n * (n + 1) * (n + 2) / 6)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_86_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_86_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_86_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn CenteredHexagonalNumber(n: nat) -> (result: nat)

-    requires n >= 0

-    ensures result == 3 * n * (n - 1) + 1

+pub fn centered_hexagonal_number(n: nat) -> (result: nat)

+    requires(n >= 0)

+    ensures(result == 3 * n * (n - 1) + 1)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_89_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_89_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_89_spec.rs
@@ -1,15 +1,5 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn ClosestSmaller(n: int) -> (m: int)

-    requires n > 0

-    ensures m + 1 == n

+pub fn closest_smaller(n: int) -> (m: int)

+    requires(n > 0)

+    ensures(m + 1 == n)

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_8_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_8_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_8_spec.rs
@@ -1,15 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SquareElements(a: Vec<int>) -> (squared: Vec<int>)

-    ensures squared.len() == a.len(),

-            forall|i: int| 0 <= i < a.len() ==> squared[i] == a[i] * a[i]

+pub fn square_elements(a: &[i32]) -> (squared: Vec<i32>)

+    ensures

+        squared.len() == a.len(),

+        forall|i: usize| 0 <= i < a.len() ==> squared[i] == a[i] * a[i],

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_94_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_94_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_94_spec.rs
@@ -1,17 +1,9 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn MinSecondValueFirst(s: Vec<Seq<int>>) -> (firstOfMinSecond: int)

-    requires s.len() > 0,

-             forall|i: int| 0 <= i < s.len() ==> s[i].len() >= 2

-    ensures exists|i: int| 0 <= i < s.len() and firstOfMinSecond == s[i][0] and 

-        (forall|j: int| 0 <= j < s.len() ==> s[i][1] <= s[j][1])

+pub fn min_second_value_first(s: &[Vec<i32>]) -> (firstOfMinSecond: i32)

+    requires 

+        s.len() > 0,

+        forall|i: usize| 0 <= i < s.len() ==> s[i].len() >= 2,

+    ensures |firstOfMinSecond: i32|

+        exists|i: usize| 0 <= i < s.len() && firstOfMinSecond == s[i][0] && 

+            (forall|j: usize| 0 <= j < s.len() ==> s[i][1] <= s[j][1])

 {

-}

-

 }

================================================================================
Comparing translations/synthesis_task/dafny-synthesis_task_id_95_spec.rs
================================================================================
--- verus_specs_no_llm/translations/synthesis_task/dafny-synthesis_task_id_95_spec.rs
+++ verus_specs/translations/synthesis_task/dafny-synthesis_task_id_95_spec.rs
@@ -1,16 +1,6 @@
-

-#[allow(unused_imports)]

-use builtin::*;

-#[allow(unused_imports)]

-use builtin_macros::*;

-

-verus! {

-

-fn SmallestListLength(s: Seq<Seq<int>>) -> (v: int)

-    requires s.len() > 0

-    ensures forall|i: int| 0 <= i < s.len() ==> v <= s[i].len(),

-            exists|i: int| 0 <= i < s.len() and v == s[i].len()

+pub fn smallest_list_length(s: Seq<Seq<int>>) -> (v: int)

+    requires(s.len() > 0)

+    ensures(forall|i: int| 0 <= i < s.len() ==> v <= s[i].len())

+    ensures(exists|i: int| 0 <= i < s.len() && v == s[i].len())

 {

-}

-

 }
