{
  "skeleton": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n//ATOM_PLACEHOLDER_abs\n\n/** Call abs */\n//ATOM_PLACEHOLDER_foo\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n//ATOM_PLACEHOLDER_max\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n//ATOM_PLACEHOLDER_ex1\n\n/**\n *  Infinite loop.\n */\n//ATOM_PLACEHOLDER_foo2\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n//ATOM_PLACEHOLDER_find\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n//ATOM_PLACEHOLDER_isPalindrome\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\n//ATOM_PLACEHOLDER_sorted\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n//ATOM_PLACEHOLDER_unique\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */\n//ATOM_PLACEHOLDER_Main\n\n\n\n\n\n",
  "atoms": {
    "ex1": [
      [],
      "// SPEC \nmethod ex1(n: int)\n    requires true\n    ensures true\n{\n}\n\n/**\n *  Infinite loop.\n */\n",
      "method"
    ]
  },
  "placeholder_mapping": {
    "//ATOM_PLACEHOLDER_ex1": "ex1"
  }
}