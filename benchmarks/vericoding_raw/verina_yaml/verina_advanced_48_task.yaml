vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def mergeSort (list : List Int) (h_precond : mergeSort_precond (list)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    -- Implementation using insertion sort instead of merge sort
    -- for simplicity and to avoid termination issues
  
    -- Helper to insert an element into a sorted list
    let rec insert (x : Int) (sorted : List Int) : List Int :=
      match sorted with
      | [] => [x]
      | y :: ys =>
          if x ≤ y then
            x :: sorted
          else
            y :: insert x ys
    termination_by sorted.length
  
    -- Main insertion sort function
    let rec sort (l : List Int) : List Int :=
      match l with
      | [] => []
      | x :: xs =>
          let sortedRest := sort xs
          insert x sortedRest
    termination_by l.length
  
    sort list
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def mergeSort_precond (list : List Int) : Prop :=
    True

  @[reducible, simp]
  def mergeSort_postcond (list : List Int) (result: List Int) (h_precond : mergeSort_precond (list)) : Prop :=
    List.Pairwise (· ≤ ·) result ∧ List.isPerm list result

  theorem mergeSort_spec_satisfied (list: List Int) (h_precond : mergeSort_precond (list)) :
      mergeSort_postcond (list) (mergeSort (list) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-