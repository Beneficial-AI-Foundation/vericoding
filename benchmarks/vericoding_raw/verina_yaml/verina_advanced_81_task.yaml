vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def uniqueSorted (arr : List Int) (h_precond : uniqueSorted_precond (arr)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    let rec insert (x : Int) (sorted : List Int) : List Int :=
    match sorted with
    | [] =>
      [x]
    | head :: tail =>
      if x <= head then
        x :: head :: tail
      else
        head :: insert x tail
  
  let rec insertionSort (xs : List Int) : List Int :=
    match xs with
    | [] =>
      []
    | h :: t =>
      let sortedTail := insertionSort t
      insert h sortedTail
  
  let removeDups : List Int → List Int
  | xs =>
    let rec aux (remaining : List Int) (seen : List Int) (acc : List Int) : List Int :=
      match remaining with
      | [] =>
        acc.reverse
      | h :: t =>
        if h ∈ seen then
          aux t seen acc
        else
          aux t (h :: seen) (h :: acc)
    aux xs [] []
  
  insertionSort (removeDups arr)
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def uniqueSorted_precond (arr : List Int) : Prop :=
    True

  @[reducible, simp]
  def uniqueSorted_postcond (arr : List Int) (result: List Int) (h_precond : uniqueSorted_precond (arr)) : Prop :=
    List.isPerm arr.eraseDups result ∧ List.Pairwise (· ≤ ·) result

  theorem uniqueSorted_spec_satisfied (arr: List Int) (h_precond : uniqueSorted_precond (arr)) :
      uniqueSorted_postcond (arr) (uniqueSorted (arr) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-