vc-description: |-
  /--
  -----Description-----
  This task requires writing a Lean 4 method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, "aaabbc" becomes [(’a’, 3), (’b’, 2), (’c’, 1)].

  The resulting encoded list must satisfy the following properties:
  1. No pair has a zero or negative run-length.
  2. Consecutive pairs in the encoding list must not have the same character.
  3. Decoding the output should return the original string.

  -----Input-----
  The input is a single string, `s`.

  -----Output-----
  The output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def runLengthEncode (s : String) (h_precond : runLengthEncode_precond (s)) : List (Char × Nat) :=

vc-implementation: |-
  -- <vc-implementation>
    let chars := s.data
  
    let rec encodeAux (acc : List (Char × Nat)) (rest : List Char) : List (Char × Nat) :=
      match rest with
      | [] => acc.reverse
      | h :: t =>
        match acc with
        | (ch, count) :: accTail =>
          if ch = h then
            encodeAux ((ch, count + 1) :: accTail) t
          else
            encodeAux ((h, 1) :: (ch, count) :: accTail) t
        | [] =>
          encodeAux ([(h, 1)]) t
  
    let encoded := encodeAux [] chars
    encoded
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def runLengthEncode_precond (s : String) : Prop :=
    True

  def decodeRLE (lst : List (Char × Nat)) : String :=
    match lst with
    | [] => ""
    | (ch, cnt) :: tail =>
      let repeated := String.mk (List.replicate cnt ch)
      repeated ++ decodeRLE tail
  @[reducible, simp]
  def runLengthEncode_postcond (s : String) (result: List (Char × Nat)) (h_precond : runLengthEncode_precond (s)) : Prop :=
    (∀ pair ∈ result, pair.snd > 0) ∧
    (∀ i : Nat, i < result.length - 1 → (result[i]!).fst ≠ (result[i+1]!).fst) ∧
    decodeRLE result = s

  theorem runLengthEncode_spec_satisfied (s: String) (h_precond : runLengthEncode_precond (s)) :
      runLengthEncode_postcond (s) (runLengthEncode (s) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-