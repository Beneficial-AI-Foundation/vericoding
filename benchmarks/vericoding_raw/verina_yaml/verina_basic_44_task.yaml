vc-description: |-
  /--
  -----Description----- 
  This task requires writing a Lean 4 method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.

  -----Input-----
  The input consists of:
  a: An array of integers.

  -----Output-----
  The output is a Boolean value:
  Returns true if, for every odd index in the array, the corresponding element is odd.
  Returns false if there is at least one odd index where the corresponding element is not odd.

  -----Note-----
  There are no preconditions; the method will work for any array of integers.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  def isOdd (n : Int) : Bool :=
    n % 2 == 1
  -- </vc-helpers>

vc-signature: |-
  def isOddAtIndexOdd (a : Array Int) (h_precond : isOddAtIndexOdd_precond (a)) : Bool :=

vc-implementation: |-
  -- <vc-implementation>
    -- First create pairs of (index, value) for all elements in the array
    let indexedArray := a.mapIdx fun i x => (i, x)
  
    -- Check if all elements at odd indices are odd numbers
    indexedArray.all fun (i, x) => !(isOdd i) || isOdd x
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def isOddAtIndexOdd_precond (a : Array Int) : Prop :=
    True

  @[reducible, simp]
  def isOddAtIndexOdd_postcond (a : Array Int) (result: Bool) (h_precond : isOddAtIndexOdd_precond (a)) :=
    result ↔ (∀ i, (hi : i < a.size) → isOdd i → isOdd (a[i]))

  theorem isOddAtIndexOdd_spec_satisfied (a: Array Int) (h_precond : isOddAtIndexOdd_precond (a)) :
      isOddAtIndexOdd_postcond (a) (isOddAtIndexOdd (a) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    unfold isOddAtIndexOdd isOddAtIndexOdd_postcond
    simp_all
    constructor
    · intro h
      intro i hi h_odd
      -- Since the function returns true, all elements in satisfy the predicate
      have h_all_odd : (a.mapIdx (fun j x => (j, x))).all (fun (i, x) => !(isOdd i) || isOdd x) = true := by
        simp_all
      -- Apply the property of Array.all
      rw [Array.all_iff_forall] at h_all_odd
      simp_all
      have h_sat_i : !(isOdd i) || isOdd a[i] := by
        simp
        apply h_all_odd i hi
      simp [h_odd] at h_sat_i
      exact h_sat_i
    · intro h
      apply Array.all_iff_forall.mpr
      intro i hi
      simp
      intro hi'
      have h_sat : isOdd i → isOdd a[i] := by
        apply h i hi'
      rw [Decidable.imp_iff_not_or] at h_sat
      simp at h_sat
      exact h_sat
  -- </vc-proof>

vc-postamble: |-