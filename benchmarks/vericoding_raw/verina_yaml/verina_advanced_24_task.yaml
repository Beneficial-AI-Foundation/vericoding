vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def lengthOfLIS (nums : List Int) (h_precond : lengthOfLIS_precond (nums)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    let rec lisHelper (dp : List Int) (x : Int) : List Int :=
      let rec replace (l : List Int) (acc : List Int) : List Int :=
        match l with
        | [] => (acc.reverse ++ [x])
        | y :: ys => if x ≤ y then acc.reverse ++ (x :: ys) else replace ys (y :: acc)
      replace dp []
  
    let finalDP := nums.foldl lisHelper []
    finalDP.length
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def lengthOfLIS_precond (nums : List Int) : Prop :=
    True

  @[reducible, simp]
  def lengthOfLIS_postcond (nums : List Int) (result: Int) (h_precond : lengthOfLIS_precond (nums)) : Prop :=
    -- Helper function to check strictly increasing
    let rec isStrictlyIncreasing (l : List Int) : Bool :=
      match l with
      | [] | [_] => true
      | x :: y :: rest => x < y && isStrictlyIncreasing (y :: rest)
  
    -- Generate all subsequences
    let rec subsequences (xs : List Int) : List (List Int) :=
      match xs with
      | [] => [[]]
      | x :: xs' =>
        let rest := subsequences xs'
        rest ++ rest.map (fun r => x :: r)
  
    let allIncreasing := subsequences nums |>.filter (fun l => isStrictlyIncreasing l)
  
    allIncreasing.any (fun l => l.length = result) ∧
    allIncreasing.all (fun l => l.length ≤ result)

  theorem lengthOfLIS_spec_satisfied (nums: List Int) (h_precond : lengthOfLIS_precond (nums)) :
      lengthOfLIS_postcond (nums) (lengthOfLIS (nums) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-