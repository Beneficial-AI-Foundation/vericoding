vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    match sequence with
    | []      => 0  -- If no elements are provided (should not happen according to the problem)
    | x :: xs =>
        let (_, maxSoFar) :=
          xs.foldl (fun (acc : Int × Int) (x : Int) =>
            let (cur, maxSoFar) := acc
            let newCur := if cur + x >= x then cur + x else x
            let newMax := if maxSoFar >= newCur then maxSoFar else newCur
            (newCur, newMax)
          ) (x, x)
        maxSoFar
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def task_code_precond (sequence : List Int) : Prop :=
    True

  @[reducible, simp]
  def task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=
    let subArrays :=
      List.range (sequence.length + 1) |>.flatMap (fun start =>
        List.range (sequence.length - start + 1) |>.map (fun len =>
          sequence.drop start |>.take len))
    let subArraySums := subArrays.filter (· ≠ []) |>.map (·.sum)
    subArraySums.contains result ∧ subArraySums.all (· ≤ result)

  theorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :
      task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-