vc-description: |-
  /--
  -----Description----- 
  You are given a natural number array nums and a natural number k.
  The frequency of an element x is the number of times it occurs in an array.
  An array is called good if the frequency of each element in this array is less than or equal to k.
  Return the length of the longest good subarray of nums.
  A subarray is a contiguous non-empty sequence of elements within an array.

  -----Input-----
  The input consists of an array of natural numbers nums and a natural number k:
  nums: an array of natural numbers.
  k: a natural number

  -----Output-----
  The output is a natural number:
  Return the length of the longest good subarray of nums.
  -/

vc-preamble: |-
  import Std.Data.HashMap
  open Std

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def longestGoodSubarray (nums : List Nat) (k : Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Nat :=

vc-implementation: |-
  -- <vc-implementation>
    Id.run do
      let arr := nums.toArray
      let mut left := 0
      let mut maxLen := 0
      let mut freq : HashMap Nat Nat := {}
  
      for right in [0:arr.size] do
        let num := arr[right]!
        let count := freq.getD num 0
        freq := freq.insert num (count + 1)
  
        -- If any frequency > k, shrink the window from the left
        while freq.toList.any (fun (_, v) => v > k) do
          let lnum := arr[left]!
          let lcount := freq.getD lnum 0
          if lcount = 1 then
            freq := freq.erase lnum
          else
            freq := freq.insert lnum (lcount - 1)
          left := left + 1
  
        maxLen := max maxLen (right - left + 1)
  
      return maxLen
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible]
  def longestGoodSubarray_precond (nums : List Nat) (k : Nat) : Prop :=
    True

  @[reducible]
  def longestGoodSubarray_postcond (nums : List Nat) (k : Nat) (result: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) : Prop :=
    let subArrays :=
      List.range (nums.length + 1) |>.flatMap (fun start =>
        List.range (nums.length - start + 1) |>.map (fun len =>
          nums.drop start |>.take len))
    let subArrayFreqs := subArrays.map (fun arr => arr.map (fun x => arr.count x))
    let validSubArrays := subArrayFreqs.filter (fun arr => arr.all (fun x => x ≤ k))
  
    (nums = [] ∧ result = 0) ∨
    (nums ≠ [] ∧
      validSubArrays.any (fun arr => arr.length = result) ∧
      validSubArrays.all (fun arr => arr.length ≤ result))

  theorem longestGoodSubarray_spec_satisfied (nums: List Nat) (k: Nat) (h_precond : longestGoodSubarray_precond (nums) (k)) :
      longestGoodSubarray_postcond (nums) (k) (longestGoodSubarray (nums) (k) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-