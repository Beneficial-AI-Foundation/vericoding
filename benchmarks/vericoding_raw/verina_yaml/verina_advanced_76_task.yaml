vc-description: |-

vc-preamble: |-
  import Std
  open Std

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def topKFrequent (nums : List Int) (k : Nat) (h_precond : topKFrequent_precond (nums) (k)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    let freqMap : HashMap Int Nat :=
      nums.foldl (init := {}) fun acc n =>
        let oldVal := match acc.toList.find? (fun (key, _) => key == n) with
                      | some (_, c) => c
                      | none        => 0
        acc.insert n (oldVal + 1)
    let sorted := freqMap.toList.foldl
      (fun acc pair =>
        let (x, cx) := pair
        let rec insertSorted (xs : List (Int × Nat)) : List (Int × Nat) :=
          match xs with
          | [] => [pair]
          | (y, cy) :: ys =>
            if cx > cy then
              pair :: (y, cy) :: ys
            else
              (y, cy) :: insertSorted ys
        insertSorted acc
      ) []
  
    sorted.take k |>.map (fun (n, _) => n)
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible]
  def topKFrequent_precond (nums : List Int) (k : Nat) : Prop :=
    k ≤ nums.eraseDups.length

  @[reducible]
  def topKFrequent_postcond (nums : List Int) (k : Nat) (result: List Int) (h_precond : topKFrequent_precond (nums) (k)) : Prop :=
    -- Result contains exactly k elements
    result.length = k ∧
  
    -- All elements in result appear in the original list
    result.all (· ∈ nums) ∧
  
    -- All elements in result are distinct
    List.Pairwise (· ≠ ·) result ∧
  
    -- For any element in result and any element not in result, the frequency of the
    -- element in result is greater or equal
    (result.all (fun x =>
      nums.all (fun y =>
        y ∉ result →
          nums.count x > nums.count y ∨
          (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)
      ))) ∧
  
    -- Elements in result are ordered by decreasing frequency
    List.Pairwise (fun (x, i) (y, j) =>
      i < j → nums.count x > nums.count y ∨
      (nums.count x == nums.count y ∧ nums.idxOf x < nums.idxOf y)
    ) result.zipIdx

  theorem topKFrequent_spec_satisfied (nums: List Int) (k: Nat) (h_precond : topKFrequent_precond (nums) (k)) :
      topKFrequent_postcond (nums) (k) (topKFrequent (nums) (k) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-