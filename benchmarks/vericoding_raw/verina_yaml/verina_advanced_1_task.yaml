vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  def filterlist (x : Int) (nums : List Int) : List Int :=
    let rec aux (lst : List Int) : List Int :=
      match lst with
      | []      => []
      | y :: ys => if y = x then y :: aux ys else aux ys
    aux nums
  -- </vc-helpers>

vc-signature: |-
  def FindSingleNumber (nums : List Int) (h_precond : FindSingleNumber_precond (nums)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    let rec findUnique (remaining : List Int) : Int :=
      match remaining with
      | [] =>
        0
      | x :: xs =>
        let filtered : List Int :=
          filterlist x nums
        let count : Nat :=
          filtered.length
        if count = 1 then
          x
        else
          findUnique xs
    findUnique nums
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible]
  def FindSingleNumber_precond (nums : List Int) : Prop :=
    let numsCount := nums.map (fun x => nums.count x)
    numsCount.all (fun count => count = 1 ∨ count = 2) ∧ numsCount.count 1 = 1

  @[reducible]
  def FindSingleNumber_postcond (nums : List Int) (result: Int) (h_precond : FindSingleNumber_precond (nums)) : Prop :=
    (nums.length > 0)
    ∧
    ((filterlist result nums).length = 1)
    ∧
    (∀ (x : Int),
      x ∈ nums →
      (x = result) ∨ ((filterlist x nums).length = 2))

  theorem FindSingleNumber_spec_satisfied (nums: List Int) (h_precond : FindSingleNumber_precond (nums)) :
      FindSingleNumber_postcond (nums) (FindSingleNumber (nums) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-