vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def rotateRight (l : List Int) (n : Nat) (h_precond : rotateRight_precond (l) (n)) : List Int :=

vc-implementation: |-
  -- <vc-implementation>
    let len := l.length
    if len = 0 then l
    else
      (List.range len).map (fun i : Nat =>
        let idx_int : Int := ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)
        let idx_nat : Nat := Int.toNat idx_int
        l.getD idx_nat (l.headD 0)
      )
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def rotateRight_precond (l : List Int) (n : Nat) : Prop :=
    True

  @[reducible, simp]
  def rotateRight_postcond (l : List Int) (n : Nat) (result: List Int) (h_precond : rotateRight_precond (l) (n)) :=
    result.length = l.length ∧
    (∀ i : Nat, i < l.length →
      let len := l.length
      let rotated_index := Int.toNat ((Int.ofNat i - Int.ofNat n + Int.ofNat len) % Int.ofNat len)
      result[i]? = l[rotated_index]?)

  theorem rotateRight_spec_satisfied (l: List Int) (n: Nat) (h_precond : rotateRight_precond (l) (n)) :
      rotateRight_postcond (l) (n) (rotateRight (l) (n) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-