vc-description: |-
  /--
  -----Description----- 
  This task requires writing a Lean 4 method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.

  -----Input-----
  The input consists of:
  a: An array of integers (the array may be empty or non-empty).

  -----Output-----
  The output is a Boolean value:
  Returns true if there is at least one index where an element plus one equals the following element.
  Returns false if the array does not contain any consecutive numbers.

  -----Note-----
  There are no additional preconditions; the method will function correctly regardless of the array's size.
  -/

vc-preamble: |-
  import Mathlib

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def containsConsecutiveNumbers (a : Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) : Bool :=

vc-implementation: |-
  -- <vc-implementation>
    if a.size ≤ 1 then
      false
    else
      let withIndices := a.mapIdx (fun i x => (i, x))
      withIndices.any (fun (i, x) =>
        i < a.size - 1 && x + 1 == a[i+1]!)
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def containsConsecutiveNumbers_precond (a : Array Int) : Prop :=
    True

  @[reducible, simp]
  def containsConsecutiveNumbers_postcond (a : Array Int) (result: Bool) (h_precond : containsConsecutiveNumbers_precond (a)) :=
    (∃ i, i < a.size - 1 ∧ a[i]! + 1 = a[i + 1]!) ↔ result

  theorem containsConsecutiveNumbers_spec_satisfied (a: Array Int) (h_precond : containsConsecutiveNumbers_precond (a)) :
      containsConsecutiveNumbers_postcond (a) (containsConsecutiveNumbers (a) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    unfold containsConsecutiveNumbers containsConsecutiveNumbers_postcond
    constructor
    · simp_all
      intro i hi hconsec
      have hi' : 1 + i < a.size := by
          rw [Nat.add_comm]
          exact Nat.add_lt_of_lt_sub hi
      have hi'' : i < a.size := by
        have : i < 1 + i := by
          simp [Nat.lt_add_of_pos_left]
        exact Nat.lt_trans this hi'
      constructor
      · exact Nat.lt_of_add_right_lt hi'
      · apply Array.any_iff_exists.mpr
        simp
        exists i
        simp [hi, hi'']
        have : a[i]! = a[i] := by
          exact getElem!_pos a i hi''
        rw [←this]
        exact hconsec
    · simp
      intro ha h
      have h' := Array.any_iff_exists.mp h
      simp at h'
      rcases h' with ⟨i, hi, ⟨hi', hconsec⟩⟩
      have : a[i]! = a[i] := by
        exact getElem!_pos a i hi
      exists i
      rw [this]
      simp_all
  -- </vc-proof>

vc-postamble: |-