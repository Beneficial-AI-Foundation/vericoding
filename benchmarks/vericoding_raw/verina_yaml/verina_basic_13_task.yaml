vc-description: |-

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def cubeElements (a : Array Int) (h_precond : cubeElements_precond (a)) : Array Int :=

vc-implementation: |-
  -- <vc-implementation>
    a.map (fun x => x * x * x)
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def cubeElements_precond (a : Array Int) : Prop :=
    True

  @[reducible, simp]
  def cubeElements_postcond (a : Array Int) (result: Array Int) (h_precond : cubeElements_precond (a)) :=
    (result.size = a.size) ∧
    (∀ i, i < a.size → result[i]! = a[i]! * a[i]! * a[i]!)

  theorem cubeElements_spec_satisfied (a: Array Int) (h_precond : cubeElements_precond (a)) :
      cubeElements_postcond (a) (cubeElements (a) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    unfold cubeElements cubeElements_postcond
    simp_all
    intro i hi
    have h_maplen : (Array.map (fun x => x * x * x) a).size = a.size := by
      apply Array.size_map
    have h1 : (Array.map (fun x => x * x * x) a)[i] = (fun x => x * x * x) a[i] := by
      apply Array.getElem_map
    have h_eq : (Array.map (fun x => x * x * x) a)[i] = (Array.map (fun x => x * x * x) a)[i]! := by
      have hi' : i < (Array.map (fun x => x * x * x) a).size := by
        simp only [hi, h_maplen]
      rw [Array.getElem!_eq_getD]
      simp [hi', hi]
    rw [← h_eq]
    simp only [h1]
    have h_eq' : a[i] = a[i]! := by
      have hi_a : i < a.size := by
        simp only [hi]
      rw [Array.getElem!_eq_getD]
      simp [hi_a]
    simp only [h_eq']
  -- </vc-proof>

vc-postamble: |-