vc-description: |-
  /--
  function_signature: "def rolling_max(numbers: List[int]) -> Tuple[int, int]"
  docstring: |
    From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
  test_cases:
    - input: [1, 2, 3, 2, 3, 4, 2]
      expected_output: [1, 2, 3, 3, 3, 4, 4]
  -/

vc-preamble: |-
  import Imports.AllImports

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-code: |-
  def implementation (numbers: List Int) : List Int :=
  -- <vc-code>
  let rec rolling_max (numbers: List Int) (results: List Int) (acc: Int) : List Int :=
    match numbers with
    | [] => results
    | n :: ns =>
      let new_acc := max acc n
      let new_results := results ++ [new_acc]
      rolling_max ns new_results new_acc
  rolling_max numbers [] 0
  -- </vc-code>
  
  #test implementation [1, 2, 3, 2, 3, 4, 2] = [1, 2, 3, 3, 3, 4, 4]

vc-spec: |-
  def problem_spec
  -- function signature
  (implementation: List Int → List Int)
  -- inputs
  (numbers: List Int) :=
  -- spec
  let spec (result: List Int) :=
  result.length = numbers.length ∧
  ∀ i, i < numbers.length →
  (result[i]! ∈ numbers.take (i + 1) ∧
  ∀ j, j ≤ i → numbers[j]! ≤ result[i]!);
  -- program termination
  ∃ result, implementation numbers = result ∧
  spec result
  
  theorem correctness
  (numbers: List Int)
  : problem_spec implementation numbers
  :=
  -- <vc-proof>
  by
  unfold problem_spec
  let result := implementation numbers
  use result
  simp [result]
  simp [implementation]
  apply And.intro
  induction numbers
  simp
  simp [implementation.rolling_max]
  rename_i head tail ih
  unfold implementation.rolling_max
  simp
  -- At this point we will have to
  -- strengthen the induction hypothesis
  -- to prove the correctness of the implementation
  sorry
  sorry
  -- </vc-proof>

vc-postamble: |-
  #test implementation [1, 2, 3, 2, 3, 4, 2] = [1, 2, 3, 3, 3, 4, 4]
  
  

