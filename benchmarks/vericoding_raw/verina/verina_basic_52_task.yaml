vc-description: |-
  /--
  -----Description-----  
  This task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.

  -----Input-----  
  The input consists of:  
  • a: An array of integers. This array can be empty or non-empty.

  -----Output-----  
  The output is an array of integers that:  
  • Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).  
  • Has the same size as the input array.  
  • Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.

  -----Note-----  
  The implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  def swap (a : Array Int) (i j : Nat) : Array Int :=
    let temp := a[i]!
    let a₁ := a.set! i (a[j]!)
    a₁.set! j temp
  
  def bubbleInner (j i : Nat) (a : Array Int) : Array Int :=
    if j < i then
      let a' := if a[j]! > a[j+1]! then swap a j (j+1) else a
      bubbleInner (j+1) i a'
    else
      a
  
  def bubbleOuter (i : Nat) (a : Array Int) : Array Int :=
    if i > 0 then
      let a' := bubbleInner 0 i a
      bubbleOuter (i - 1) a'
    else
      a
  -- </vc-helpers>

vc-signature: |-
  def BubbleSort (a : Array Int) (h_precond : BubbleSort_precond (a)) : Array Int :=

vc-implementation: |-
  -- <vc-implementation>
    if a.size = 0 then a else bubbleOuter (a.size - 1) a
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def BubbleSort_precond (a : Array Int) : Prop :=
    True

  @[reducible, simp]
  def BubbleSort_postcond (a : Array Int) (result: Array Int) (h_precond : BubbleSort_precond (a)) :=
    List.Pairwise (· ≤ ·) result.toList ∧ List.isPerm result.toList a.toList

  theorem BubbleSort_spec_satisfied (a: Array Int) (h_precond : BubbleSort_precond (a)) :
      BubbleSort_postcond (a) (BubbleSort (a) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "a": "#[5, 4, 3, 2, 1]"
          },
          "expected": "#[1, 2, 3, 4, 5]",
          "unexpected": [
              "#[5, 4, 3, 2, 1]",
              "#[2, 3, 1, 4, 5]"
          ]
      },
      {
          "input": {
              "a": "#[1, 2, 3, 4, 5]"
          },
          "expected": "#[1, 2, 3, 4, 5]",
          "unexpected": [
              "#[5, 4, 3, 2, 1]",
              "#[1, 3, 2, 4, 5]"
          ]
      },
      {
          "input": {
              "a": "#[3, 1, 2, 1, 5]"
          },
          "expected": "#[1, 1, 2, 3, 5]",
          "unexpected": [
              "#[1, 2, 3, 1, 5]",
              "#[3, 1, 2, 5, 1]"
          ]
      },
      {
          "input": {
              "a": "#[10]"
          },
          "expected": "#[10]",
          "unexpected": [
              "#[0]",
              "#[10, 10]"
          ]
      },
      {
          "input": {
              "a": "#[4, 4, 4, 2, 2, 8]"
          },
          "expected": "#[2, 2, 4, 4, 4, 8]",
          "unexpected": [
              "#[2, 4, 4, 2, 4, 8]",
              "#[4, 2, 4, 2, 4, 8]",
              "#[2, 4, 2, 4, 4, 8]"
          ]
      }
  ]
  -/
