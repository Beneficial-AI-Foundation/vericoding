vc-description: |-
  /--
  -----Description-----
  This task requires writing a Lean 4 function that calculates how much water can be trapped between elevations after it rains. The input is a list of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.

  -----Input-----
  - height: A list of natural numbers representing elevations.

  -----Output-----
  - A natural number: total units of water that can be trapped.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def trapRainWater (height : List Nat) (h_precond : trapRainWater_precond (height)) : Nat :=

vc-implementation: |-
  -- <vc-implementation>
    Id.run do
      let mut left := 0
      let mut right := height.length - 1
      let mut leftMax := 0
      let mut rightMax := 0
      let mut water := 0
  
      while left < right do
        let hLeft := height[left]!
        let hRight := height[right]!
  
        if hLeft < hRight then
          if hLeft >= leftMax then
            leftMax := hLeft
          else
            water := water + (leftMax - hLeft)
          left := left + 1
        else
          if hRight >= rightMax then
            rightMax := hRight
          else
            water := water + (rightMax - hRight)
          right := right - 1
  
      return water
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def trapRainWater_precond (height : List Nat) : Prop :=
    True

  @[reducible, simp]
  def trapRainWater_postcond (height : List Nat) (result: Nat) (h_precond : trapRainWater_precond (height)) : Prop :=
    let waterAt := List.range height.length |>.map (fun i =>
      let lmax := List.take (i+1) height |>.foldl Nat.max 0
      let rmax := List.drop i height |>.foldl Nat.max 0
      Nat.min lmax rmax - height[i]!)
  
    result - (waterAt.foldl (· + ·) 0) = 0 ∧ (waterAt.foldl (· + ·) 0) ≤ result

  theorem trapRainWater_spec_satisfied (height: List Nat) (h_precond : trapRainWater_precond (height)) :
      trapRainWater_postcond (height) (trapRainWater (height) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "height": "[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]"
          },
          "expected": 6,
          "unexpected": [
              5,
              7
          ]
      },
      {
          "input": {
              "height": "[4, 2, 0, 3, 2, 5]"
          },
          "expected": 9,
          "unexpected": [
              8
          ]
      },
      {
          "input": {
              "height": "[1, 0, 2]"
          },
          "expected": 1,
          "unexpected": [
              0,
              2
          ]
      },
      {
          "input": {
              "height": "[3, 0, 1, 3, 0, 5]"
          },
          "expected": 8,
          "unexpected": [
              6
          ]
      },
      {
          "input": {
              "height": "[0, 1, 2, 3, 4, 5]"
          },
          "expected": 0,
          "unexpected": [
              1
          ]
      },
      {
          "input": {
              "height": "[]"
          },
          "expected": 0,
          "unexpected": [
              1
          ]
      }
  ]
  -/
