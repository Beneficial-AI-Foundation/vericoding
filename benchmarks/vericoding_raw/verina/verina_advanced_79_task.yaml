vc-description: |-
  /--
  -----Description-----
  This task requires writing a Lean 4 method that implementing the "Two Sum" problem. Given a list of integers 
  and a target integer, the function should return the indices of the two numbers that add up to 
  the target. If no valid pair exists, the function should return none. And the indices returned must 
  be within the bounds of the list. If multiple pair exists, return the first pair.

  -----Input-----
  - nums: A list of integers.
  - target: An integer representing the target sum.

  -----Output-----
  - An option type containing a pair of natural numbers (indices) such that 
    nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def twoSum (nums : List Int) (target : Int) (h_precond : twoSum_precond (nums) (target)) : Option (Nat × Nat) :=

vc-implementation: |-
  -- <vc-implementation>
    let rec outer (lst : List Int) (i : Nat)
              : Option (Nat × Nat) :=
          match lst with
          | [] =>
              none
          | x :: xs =>
              let rec inner (lst' : List Int) (j : Nat)
                      : Option Nat :=
                  match lst' with
                  | [] =>
                      none
                  | y :: ys =>
                      if x + y = target then
                          some j
                      else
                          inner ys (j + 1)
              match inner xs (i + 1) with
              | some j =>
                  some (i, j)
              | none =>
                  outer xs (i + 1)
          outer nums 0
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible]
  def twoSum_precond (nums : List Int) (target : Int) : Prop :=
    True

  @[reducible]
  def twoSum_postcond (nums : List Int) (target : Int) (result: Option (Nat × Nat)) (h_precond : twoSum_precond (nums) (target)) : Prop :=
      match result with
      | none => List.Pairwise (· + · ≠ target) nums
      | some (i, j) =>
          i < j ∧
          j < nums.length ∧
          nums[i]! + nums[j]! = target ∧
          -- i must be the first i
          List.Pairwise (fun a b => a + b ≠ target) (nums.take i) ∧
          List.all (nums.take i) (fun a => List.all (nums.drop i) (fun b => a + b ≠ target) ) ∧
          -- j must be the first j
          List.all (nums.drop (j + 1)) (fun a => a + nums[j]! ≠ target)

  theorem twoSum_spec_satisfied (nums: List Int) (target: Int) (h_precond : twoSum_precond (nums) (target)) :
      twoSum_postcond (nums) (target) (twoSum (nums) (target) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "nums": "[2, 7, 11, 15]",
              "target": 9
          },
          "expected": "some (0, 1)",
          "unexpected": [
              "some (1, 2)",
              "none"
          ]
      },
      {
          "input": {
              "nums": "[3, 2, 4]",
              "target": 6
          },
          "expected": "some (1, 2)",
          "unexpected": [
              "some (0, 2)",
              "none"
          ]
      },
      {
          "input": {
              "nums": "[3, 3]",
              "target": 6
          },
          "expected": "some (0, 1)",
          "unexpected": [
              "some (1, 1)",
              "none"
          ]
      },
      {
          "input": {
              "nums": "[1, 2, 3]",
              "target": 7
          },
          "expected": "none",
          "unexpected": [
              "some (0, 2)"
          ]
      },
      {
          "input": {
              "nums": "[0, 4, 3, 0]",
              "target": 0
          },
          "expected": "some (0, 3)",
          "unexpected": [
              "some (1, 2)",
              "none"
          ]
      }
  ]
  -/
