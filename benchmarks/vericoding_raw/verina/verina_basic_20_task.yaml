vc-description: |-
  /--
  -----Description----- 
  This task requires writing a Lean 4 method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.

  -----Input-----
  The input consists of:
  arr: An array of integers.

  -----Output-----
  The output is an integer:
  Returns the product of all unique integers from the input array.

  -----Note-----
  The order in which the unique integers are multiplied does not affect the final product.
  -/

vc-preamble: |-
  import Std.Data.HashSet

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def uniqueProduct (arr : Array Int) (h_precond : uniqueProduct_precond (arr)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    let rec loop (i : Nat) (seen : Std.HashSet Int) (product : Int) : Int :=
      if i < arr.size then
        let x := arr[i]!
        if seen.contains x then
          loop (i + 1) seen product
        else
          loop (i + 1) (seen.insert x) (product * x)
      else
        product
    loop 0 Std.HashSet.empty 1
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def uniqueProduct_precond (arr : Array Int) : Prop :=
    True

  @[reducible, simp]
  def uniqueProduct_postcond (arr : Array Int) (result: Int) (h_precond : uniqueProduct_precond (arr)) :=
    result - (arr.toList.eraseDups.foldl (· * ·) 1) = 0 ∧
    (arr.toList.eraseDups.foldl (· * ·) 1) - result = 0

  theorem uniqueProduct_spec_satisfied (arr: Array Int) (h_precond : uniqueProduct_precond (arr)) :
      uniqueProduct_postcond (arr) (uniqueProduct (arr) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /-
  -- Invalid Inputs
  []
  -- Tests
  [
      {
          "input": {
              "arr": "#[2, 3, 2, 4]"
          },
          "expected": 24,
          "unexpected": [
              12,
              30,
              0
          ]
      },
      {
          "input": {
              "arr": "#[5, 5, 5, 5]"
          },
          "expected": 5,
          "unexpected": [
              25,
              0,
              10
          ]
      },
      {
          "input": {
              "arr": "#[]"
          },
          "expected": 1,
          "unexpected": [
              0,
              -1,
              2
          ]
      },
      {
          "input": {
              "arr": "#[1, 2, 3]"
          },
          "expected": 6,
          "unexpected": [
              5,
              7,
              2
          ]
      },
      {
          "input": {
              "arr": "#[0, 2, 3]"
          },
          "expected": 0,
          "unexpected": [
              1,
              -1,
              10
          ]
      },
      {
          "input": {
              "arr": "#[-1, -2, -1, -3]"
          },
          "expected": -6,
          "unexpected": [
              -1,
              6,
              -3
          ]
      },
      {
          "input": {
              "arr": "#[10, 10, 20, 20, 30]"
          },
          "expected": 6000,
          "unexpected": [
              600,
              0,
              5000
          ]
      }
  ]
  -/
