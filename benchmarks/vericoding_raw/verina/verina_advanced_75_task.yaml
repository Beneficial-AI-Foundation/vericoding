vc-description: |-
  /--
  -----Description-----
  Given a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.

  The algorithm uses dynamic programming (Kadane’s Algorithm) to solve the problem:
  1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.
  2. For each subsequent element, update:
       cur = max(element, cur + element)
       maxSoFar = max(maxSoFar, cur)
  3. Return maxSoFar as the answer.

  -----Input-----
  The input is provided as a list of integers:
    sequence: A list of n integers.

  -----Output-----
  The output is a single integer representing the maximum subarray sum.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def task_code (sequence : List Int) (h_precond : task_code_precond (sequence)) : Int :=

vc-implementation: |-
  -- <vc-implementation>
    match sequence with
    | []      => 0  -- If no elements are provided (should not happen according to the problem)
    | x :: xs =>
        let (_, maxSoFar) :=
          xs.foldl (fun (acc : Int × Int) (x : Int) =>
            let (cur, maxSoFar) := acc
            let newCur := if cur + x >= x then cur + x else x
            let newMax := if maxSoFar >= newCur then maxSoFar else newCur
            (newCur, newMax)
          ) (x, x)
        maxSoFar
  -- </vc-implementation>
  
vc-condition: |-
  @[reducible, simp]
  def task_code_precond (sequence : List Int) : Prop :=
    True

  @[reducible, simp]
  def task_code_postcond (sequence : List Int) (result: Int) (h_precond : task_code_precond (sequence)) : Prop :=
    let subArrays :=
      List.range (sequence.length + 1) |>.flatMap (fun start =>
        List.range (sequence.length - start + 1) |>.map (fun len =>
          sequence.drop start |>.take len))
    let subArraySums := subArrays.filter (· ≠ []) |>.map (·.sum)
    subArraySums.contains result ∧ subArraySums.all (· ≤ result)

  theorem task_code_spec_satisfied (sequence: List Int) (h_precond : task_code_precond (sequence)) :
      task_code_postcond (sequence) (task_code (sequence) h_precond) h_precond := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-
  /--
  -- Reject Inputs
  []
  -- Test
  [
      {
          "input": {
              "sequence": "[10, -4, 3, 1, 5, 6, -35, 12, 21, -1]"
          },
          "expected": 33,
          "unexpected": [
              32,
              34,
              0
          ]
      },
      {
          "input": {
              "sequence": "[2, 1, -4, 3, 4, -4, 6, 5, -5, 1]"
          },
          "expected": 14,
          "unexpected": [
              13,
              15,
              0
          ]
      },
      {
          "input": {
              "sequence": "[-1, -2, -3, -4, -5]"
          },
          "expected": -1,
          "unexpected": [
              -2,
              0,
              1
          ]
      },
      {
          "input": {
              "sequence": "[7]"
          },
          "expected": 7,
          "unexpected": [
              0,
              1,
              -7
          ]
      },
      {
          "input": {
              "sequence": "[1, 2, 3, 4, 5]"
          },
          "expected": 15,
          "unexpected": [
              14,
              16,
              0
          ]
      }
  ]
  -/
