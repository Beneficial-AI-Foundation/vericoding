vc-preamble: |-
  // ex2

  // this was me playing around to try and get an ensures for the method 
  /*predicate method check(a: array<int>, seclar:int)
  requires a.Length > 0
  reads a
  { ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-spec: |-
  method SecondLargest(a:array<int>) returns (seclar:int)
  requires a.Length > 0
  //ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])

vc-code: |-
  {
      // if length = 1, return first element
      if a.Length == 1
      { seclar := a[0]; }
      else 
      {
          var l, s, i: int := 0, 0, 0;

          // set initial largest and second largest
          if a[1] > a[0]
          { l := a[1]; s := a[0]; }
          else 
          { l := a[0]; s := a[1]; }

          while i < a.Length
          invariant 0 <= i <= a.Length
          invariant forall j :: (0 <= j < i) ==> l >= a[j]
          invariant s <= l
          {
              if a[i] > l                     // check if curr is greater then largest and set l and s
              { s := l; l := a[i]; }
              if a[i] > s && a[i] < l         // check if curr is greater than s and set s
              { s := a[i]; }
              if s == l && s > a[i]           // check s is not the same as l
              { s := a[i]; }
              i := i+1;
          }
          seclar := s;
      }
  }

vc-postamble: |-

