vc-preamble: |-
  method random(a: int, b: int) returns (r: int)
  //  requires a <= b
    ensures a <= b ==> a <= r <= b

  function set_of_seq<T>(s: seq<T>): set<T>
  {
    set x: T | x in s :: x
  }

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-spec: |-
  method getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: seq<T>) returns (e: T)
    requires m_workList.Length > 0
    ensures set_of_seq(avoidSet) < set_of_seq(m_workList[..]) ==> e !in avoidSet
    ensures avoidSet < m_workList[..] ==> e in m_workList[..]

vc-code: |-
  {
    var k := m_workList.Length - 1;

    while (k >= 0)
    {
      var i := random(0, k);
      assert i >= 0 && i <= k;

      e := m_workList[i];
      if (e !in avoidSet) {
        return e;
      }

      k := k - 1;
    }
    assume false;
    return m_workList[0];
  }

vc-postamble: |-
  lemma eqMultiset_t<T>(t: T, s1: seq<T>, s2: seq<T>)
    requires multiset(s1) == multiset(s2)
    ensures t in s1 <==> t in s2
  {
    calc <==> {
      t in s1;
      t in multiset(s1);
      // Not necessary:
  //    t in multiset(s2);
  //    t in s2;
    }
  /*  
    if (t in s1) {
      assert t in multiset(s1);
    }
    else {
      assert t !in multiset(s1);
    }
  */
  }

  lemma eqMultiset<T>(s1: seq<T>, s2: seq<T>)
    requires multiset(s1) == multiset(s2)
    ensures forall t :: t in s1 <==> t in s2
  {
    forall t {
      eqMultiset_t(t, s1, s2);
    }
  }

  lemma in_set_of_seq<T>(x: T, s: seq<T>)
    ensures x in s <==> x in set_of_seq(s)

  lemma subset_set_of_seq<T>(s1: seq<T>, s2: seq<T>)
    requires set_of_seq(s1) <= set_of_seq(s2)
    ensures forall x :: x in s1 ==> x in s2

