vc-preamble: |-
  predicate SplitPoint(a: array<int>, n: int)
      reads a
      requires 0 <= n <= n

  {
      forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]
  }

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-spec: |-
  method SelectionSort(a: array<int>)
      modifies a
      ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]
      ensures multiset(a[..]) == old(multiset(a[..]))

vc-code: |-
  {
      var n := 0;
      while n != a.Length 
          invariant 0 <= n <= a.Length
          invariant forall i,j :: 0 <= i < j < n ==> a[i] <= a[j]
          // invariant forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]
          invariant SplitPoint(a, n)
          invariant multiset(a[..]) == old(multiset(a[..]))
      {
          var mindex, m := n, n;
          while m != a.Length 
              invariant n <= m <= a.Length && n <= mindex < a.Length
              invariant forall i :: n <= i < m ==> a[mindex] <= a[i]
          {
              if a[m] < a[mindex] {
                  mindex := m;
              }
              m := m +  1;
          }
          a[n], a[mindex] := a[mindex], a[n];
          assert forall i,j :: 0 <= i < j < n ==> a[i] <= a[j];
          n := n + 1;
      }
  }

vc-postamble: |-
  twostate predicate SwapFrame(a: array<int>, lo: int, hi: int)
      requires 0 <= lo <= hi <= a.Length
      reads a
  {
      (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))
  }

