vc-preamble: |-
  /* 
  * Formal specification and verification of a dynamic programming algorithm for calculating C(n, k).
  * FEUP, MIEIC, MFES, 2020/21.
  */

  // Initial recursive definition of C(n, k), based on the Pascal equality.
  function comb(n: nat, k: nat): nat 
    requires 0 <= k <= n
  {
    if k == 0 || k == n then 1 else comb(n-1, k) + comb(n-1, k-1)  
  }

vc-helpers: |-

vc-spec: |-
  method Comb(n: nat, k: nat) returns (res: nat)
    requires 0 <= k <= n
    ensures res == comb(n, k)

vc-code: |-
  {
    var maxj := n - k;
    var c := new nat[1 + maxj];
    forall i | 0 <= i <= maxj {
         c[i] := 1;
    }
    var i := 1;
    while i <= k 
      invariant 1 <= i <= k + 1
      invariant forall j :: 0 <= j <= maxj ==> c[j] == comb(j + i - 1, i - 1)
    {
      var j := 1;
      while j <= maxj
          invariant 1 <= j <= maxj + 1
          invariant forall j' :: 0 <= j' < j ==> c[j'] == comb(j' + i, i)
          invariant forall j' :: j <= j' <= maxj ==> c[j'] == comb(j' + i - 1, i - 1)
      {
        c[j] := c[j] + c[j-1];
        j := j+1;
      } 
      i := i + 1;
    }
    return c[maxj];
  }

vc-postamble: |-
  lemma combProps(n: nat, k: nat)
     requires 0 <= k <= n
     ensures comb(n, k) == comb(n, n-k)
  {
    assume false;
  }

