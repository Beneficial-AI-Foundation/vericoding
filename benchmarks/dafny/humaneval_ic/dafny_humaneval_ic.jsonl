{"id": "HumanEval_119", "vc-description": "Given a list of exactly two strings containing only '(' and ')' characters, determine if it's possible to concatenate them in some order to create a balanced parentheses string. Return 'Yes' if either concatenation order produces a balanced string, 'No' otherwise.", "vc-preamble": "// ======= TASK =======\n// Given a list of exactly two strings containing only '(' and ')' characters,\n// determine if it's possible to concatenate them in some order to create a\n// balanced parentheses string. Return 'Yes' if either concatenation order\n// produces a balanced string, 'No' otherwise.\n\n// ======= SPEC REQUIREMENTS =======\npredicate valid_paren_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')'\n}\n\nfunction is_balanced_helper(s: string, depth: int): int\n{\n    if |s| == 0 then depth\n    else if s[0] == '(' then is_balanced_helper(s[1..], depth + 1)\n    else if s[0] == ')' then \n        if depth > 0 then is_balanced_helper(s[1..], depth - 1)\n        else -1\n    else is_balanced_helper(s[1..], depth)\n}\n\nfunction is_balanced(s: string): bool\n{\n    is_balanced_helper(s, 0) == 0\n}\n\npredicate ValidInput(lst: seq<string>)\n{\n    |lst| == 2 && valid_paren_string(lst[0]) && valid_paren_string(lst[1])\n}\n\npredicate CorrectOutput(lst: seq<string>, result: string)\n    requires ValidInput(lst)\n{\n    (result == \"Yes\" || result == \"No\") &&\n    (result == \"Yes\" <==> (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])))\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod match_parens(lst: seq<string>) returns (result: string)\n    requires ValidInput(lst)\n    ensures CorrectOutput(lst, result)", "vc-code": "{\n    var combined := lst[0] + lst[1];\n    if is_balanced(combined) {\n        result := \"Yes\";\n    } else {\n        var option1 := lst[0] + lst[1];\n        var option2 := lst[1] + lst[0];\n\n        if is_balanced(option1) || is_balanced(option2) {\n            result := \"Yes\";\n        } else {\n            result := \"No\";\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_5", "vc-description": "This verification task involves implementing a method that inserts a delimiter between every two consecutive elements in a sequence of integers. The method should handle edge cases like empty sequences or single-element sequences, and for longer sequences, it should produce a result with alternating original elements and delimiters.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers and a delimiter integer, insert the delimiter between every two consecutive elements in the list.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(numbers: seq<int>, delimiter: int)\n{\n    true // Any sequence and delimiter are valid inputs\n}\n\npredicate ValidOutput(numbers: seq<int>, delimiter: int, result: seq<int>)\n{\n    if |numbers| <= 1 then\n        result == numbers\n    else\n        |result| == 2 * |numbers| - 1 &&\n        (forall i :: 0 <= i < |numbers| ==> result[2 * i] == numbers[i]) &&\n        (forall i :: 0 <= i < |numbers| - 1 ==> result[2 * i + 1] == delimiter)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod InsertDelimiter(numbers: seq<int>, delimiter: int) returns (result: seq<int>)\n    requires ValidInput(numbers, delimiter)\n    ensures ValidOutput(numbers, delimiter, result)", "vc-code": "{\n    if |numbers| <= 1 {\n        return numbers;\n    }\n    \n    result := [];\n    for i := 0 to |numbers|\n        invariant 0 <= i <= |numbers|\n        invariant if i == 0 then |result| == 0\n                 else if i == 1 then |result| == 1 && result == [numbers[0]]\n                 else |result| == 2 * i - 1\n        invariant forall j :: 0 <= j < i ==> j < |numbers| && result[2 * j] == numbers[j]\n        invariant forall j :: 0 <= j < i - 1 ==> result[2 * j + 1] == delimiter\n    {\n        if i == 0 {\n            result := result + [numbers[i]];\n        } else {\n            result := result + [delimiter, numbers[i]];\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_53", "vc-description": "This verification task implements a simple addition function that takes two integers as input and returns their sum. The implementation should correctly add the two input integers and satisfy the postcondition that the result equals the mathematical sum of the inputs.", "vc-preamble": "// ======= TASK =======\n// Implement a function that takes two integers as input and returns their sum.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(x: int, y: int)\n{\n    true\n}\n\nfunction CorrectSum(x: int, y: int): int\n{\n    x + y\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod add(x: int, y: int) returns (result: int)\n    requires ValidInput(x, y)\n    ensures result == CorrectSum(x, y)", "vc-code": "{\n    result := x + y;\n}", "vc-postamble": ""}
{"id": "HumanEval_4", "vc-description": "This task implements the calculation of Mean Absolute Deviation (MAD) for a sequence of floating-point numbers. The MAD is defined as the average of the absolute deviations from the arithmetic mean of the data set.\n\nThe implementation should calculate the arithmetic mean, compute absolute deviations from this mean for each element, and then return the average of these absolute deviations while ensuring the result is non-negative.", "vc-preamble": "// ======= TASK =======\n// Given a list of floating-point numbers, calculate the Mean Absolute Deviation (MAD) around the arithmetic mean.\n// The Mean Absolute Deviation is defined as: MAD = (1/n) × Σ|x_i - mean|\n// Where n is the number of elements, x_i is each element, and mean is the arithmetic mean of all elements.\n\n// ======= SPEC REQUIREMENTS =======\nfunction sum(numbers: seq<real>): real\n{\n    if |numbers| == 0 then 0.0\n    else numbers[0] + sum(numbers[1..])\n}\n\nfunction abs(x: real): real\n{\n    if x >= 0.0 then x else -x\n}\n\npredicate ValidInput(numbers: seq<real>)\n{\n    |numbers| > 0\n}\n\nfunction ArithmeticMean(numbers: seq<real>): real\n    requires ValidInput(numbers)\n{\n    sum(numbers) / (|numbers| as real)\n}\n\nfunction AbsoluteDeviations(numbers: seq<real>): seq<real>\n    requires ValidInput(numbers)\n{\n    seq(|numbers|, i requires 0 <= i < |numbers| => abs(numbers[i] - ArithmeticMean(numbers)))\n}\n\nfunction MAD(numbers: seq<real>): real\n    requires ValidInput(numbers)\n{\n    sum(AbsoluteDeviations(numbers)) / (|numbers| as real)\n}", "vc-helpers": "// ======= HELPERS =======\nlemma sum_non_negative(numbers: seq<real>)\n    requires forall i :: 0 <= i < |numbers| ==> numbers[i] >= 0.0\n    ensures sum(numbers) >= 0.0\n{\n    if |numbers| == 0 {\n        // Base case: empty sequence has sum 0.0\n    } else {\n        // Inductive case: numbers[0] >= 0.0 and sum(numbers[1..]) >= 0.0\n        sum_non_negative(numbers[1..]);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod mean_absolute_deviation(numbers: seq<real>) returns (result: real)\n    requires ValidInput(numbers)\n    ensures result >= 0.0\n    ensures result == MAD(numbers)", "vc-code": "{\n    // Calculate the mean of the numbers\n    var mean := sum(numbers) / (|numbers| as real);\n\n    // Calculate the absolute deviations from the mean\n    var absolute_deviations: seq<real> := [];\n    for i := 0 to |numbers|\n        invariant 0 <= i <= |numbers|\n        invariant |absolute_deviations| == i\n        invariant forall j :: 0 <= j < i ==> absolute_deviations[j] == abs(numbers[j] - mean)\n        invariant forall j :: 0 <= j < i ==> absolute_deviations[j] >= 0.0\n    {\n        var tmpCall1 := abs(numbers[i] - mean);\n        absolute_deviations := absolute_deviations + [tmpCall1];\n    }\n\n    // Return the mean of the absolute deviations\n    assert |absolute_deviations| == |numbers| > 0;\n    assert forall j :: 0 <= j < |absolute_deviations| ==> absolute_deviations[j] >= 0.0;\n    sum_non_negative(absolute_deviations);\n    assert sum(absolute_deviations) >= 0.0;\n    result := sum(absolute_deviations) / (|absolute_deviations| as real);\n\n    // Prove the postcondition\n    assert absolute_deviations == seq(|numbers|, i requires 0 <= i < |numbers| => abs(numbers[i] - mean));\n    assert result == sum(seq(|numbers|, i requires 0 <= i < |numbers| => abs(numbers[i] - mean))) / (|numbers| as real);\n}", "vc-postamble": ""}
{"id": "HumanEval_72", "vc-description": "This task determines if an object will fly based on two conditions: the given list of numbers must be palindromic, and the sum of all elements must be within a specified weight limit. The implementation needs to check both conditions and return true only if both are satisfied.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers and a maximum weight, determine if an object will fly.\n// An object flies if the list is palindromic and the sum of elements is within the weight limit.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_palindrome(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nfunction sum_elements(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + sum_elements(s[1..])\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod will_it_fly(q: seq<int>, w: int) returns (result: bool)\n    ensures result == (is_palindrome(q) && sum_elements(q) <= w)", "vc-code": "{\n    var is_balanced := is_palindrome(q);\n    var total_sum := sum_elements(q);\n    var is_within_weight := total_sum <= w;\n    result := is_balanced && is_within_weight;\n}", "vc-postamble": ""}
{"id": "HumanEval_14", "vc-description": "Given a string, return a list of all its prefixes ordered from shortest to longest. A prefix is a substring that starts from the beginning of the original string.", "vc-preamble": "// ======= TASK =======\n// Given a string, return a list of all its prefixes ordered from shortest to longest.\n// A prefix is a substring that starts from the beginning of the original string.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidPrefixes(s: string, result: seq<string>)\n{\n    |result| == |s| &&\n    forall i :: 0 <= i < |result| ==> result[i] == s[0..i+1]\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod all_prefixes(s: string) returns (result: seq<string>)\n    ensures ValidPrefixes(s, result)", "vc-code": "{\n    result := [];\n    var i := 1;\n    while i <= |s|\n        invariant 1 <= i <= |s| + 1\n        invariant |result| == i - 1\n        invariant forall j :: 0 <= j < |result| ==> result[j] == s[0..j+1]\n    {\n        result := result + [s[0..i]];\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_45", "vc-description": "This task involves calculating the area of a triangle given the length of its base and height using the standard formula: Area = (base × height) ÷ 2. The implementation should handle non-negative inputs and ensure the result is also non-negative.", "vc-preamble": "// ======= TASK =======\n// Calculate the area of a triangle given the length of its base and height.\n// Formula: Area = (base × height) ÷ 2\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(base: real, height: real)\n{\n    base >= 0.0 && height >= 0.0\n}\n\nfunction TriangleAreaFormula(base: real, height: real): real\n{\n    (base * height) / 2.0\n}", "vc-helpers": "// ======= HELPERS =======\nfunction triangle_area(a: real, h: real): real\n    requires a >= 0.0\n    requires h >= 0.0\n    ensures triangle_area(a, h) >= 0.0\n    ensures triangle_area(a, h) == (a * h) / 2.0\n    ensures (a == 0.0 || h == 0.0) ==> triangle_area(a, h) == 0.0\n{\n    (a * h) / 2.0\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod CalculateTriangleArea(base: real, height: real) returns (area: real)\n    requires ValidInput(base, height)\n    ensures area >= 0.0\n    ensures area == TriangleAreaFormula(base, height)\n    ensures (base == 0.0 || height == 0.0) ==> area == 0.0", "vc-code": "{\n    area := triangle_area(base, height);\n}", "vc-postamble": ""}
{"id": "HumanEval_139", "vc-description": "Compute the special factorial of a positive integer n, defined as the product of all factorials from 1! to n!: special_factorial(n) = n! × (n-1)! × (n-2)! × ... × 1!. The implementation should use an iterative approach with proper loop invariants to ensure correctness.", "vc-preamble": "// ======= TASK =======\n// Compute the special factorial of a positive integer n, defined as the product of all factorials from 1! to n!:\n// special_factorial(n) = n! × (n-1)! × (n-2)! × ... × 1!\n\n// ======= SPEC REQUIREMENTS =======\nfunction factorial_func(num: int): int\n    requires num >= 0\n{\n    if num <= 1 then 1 else num * factorial_func(num - 1)\n}\n\nfunction special_factorial_func(n: int): int\n    requires n >= 0\n{\n    if n <= 0 then 1\n    else special_factorial_func(n - 1) * factorial_func(n)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod factorial(num: int) returns (result: int)\n    requires num >= 0\n    ensures result == factorial_func(num)\n    ensures result > 0\n{\n    if num <= 1 {\n        return 1;\n    }\n    result := 1;\n    var i := 2;\n    while i <= num\n        invariant 2 <= i <= num + 1\n        invariant result == factorial_func(i - 1)\n        invariant result > 0\n    {\n        result := result * i;\n        i := i + 1;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod special_factorial(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == special_factorial_func(n)\n    ensures result > 0", "vc-code": "{\n    if n <= 0 {\n        return 1;\n    }\n\n    result := 1;\n    var i := 1;\n    while i <= n\n        invariant 1 <= i <= n + 1\n        invariant result == special_factorial_func(i - 1)\n        invariant result > 0\n    {\n        var fact := factorial(i);\n        result := result * fact;\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_22", "vc-description": "Given a list containing values of various types, return a new list containing only the integer values. In Python, booleans are considered integers (True=1, False=0), so they should be included in the result. The task requires implementing a function that filters a sequence of mixed-type values to extract only integers and boolean values (converted to 0/1).", "vc-preamble": "// ======= TASK =======\n// Given a list containing values of various types, return a new list containing only the integer values.\n// In Python, booleans are considered integers (True=1, False=0), so they should be included in the result.\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Value = IntVal(i: int) | BoolVal(b: bool) | StringVal(s: string) | RealVal(r: real) | OtherVal\n\npredicate ValidInput(values: seq<Value>)\n{\n    true  // All sequences of Value are valid input\n}\n\nfunction IntegerValues(values: seq<Value>) : seq<int>\n{\n    if |values| == 0 then []\n    else \n        match values[0]\n        case IntVal(i) => [i] + IntegerValues(values[1..])\n        case BoolVal(b) => [if b then 1 else 0] + IntegerValues(values[1..])\n        case _ => IntegerValues(values[1..])\n}\n\npredicate ValidOutput(input: seq<Value>, output: seq<int>)\n{\n    output == IntegerValues(input)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nfunction filter_integers(values: seq<Value>) : seq<int>\n    requires ValidInput(values)\n    ensures ValidOutput(values, filter_integers(values))\n    ensures |filter_integers(values)| <= |values|\n    ensures forall x :: x in filter_integers(values) ==> \n        exists i :: 0 <= i < |values| && (values[i] == IntVal(x) || (values[i].BoolVal? && x == (if values[i].b then 1 else 0)))\n    ensures forall i :: 0 <= i < |values| && values[i].IntVal? ==> values[i].i in filter_integers(values)\n    ensures forall i :: 0 <= i < |values| && values[i].BoolVal? ==> (if values[i].b then 1 else 0) in filter_integers(values)", "vc-code": "{\n    if |values| == 0 then []\n    else \n        match values[0]\n        case IntVal(i) => [i] + filter_integers(values[1..])\n        case BoolVal(b) => [if b then 1 else 0] + filter_integers(values[1..])\n        case _ => filter_integers(values[1..])\n}", "vc-postamble": ""}
{"id": "HumanEval_78", "vc-description": "This task involves counting hexadecimal digits that represent prime numbers in a given hexadecimal string. The prime hexadecimal digits are: 2, 3, 5, 7, B (decimal 11), and D (decimal 13). The implementation should iterate through the string and count occurrences of these specific characters.", "vc-preamble": "// ======= TASK =======\n// Given a hexadecimal string, count how many hexadecimal digits represent prime numbers.\n// Prime hexadecimal digits are: 2, 3, 5, 7, B (decimal 11), D (decimal 13).\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_hex_char(c: char)\n{\n    c in \"0123456789ABCDEF\"\n}\n\npredicate is_valid_hex_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> is_hex_char(s[i])\n}\n\npredicate is_prime_hex_digit(c: char)\n{\n    c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'\n}\n\nfunction count_prime_hex_digits(s: string): int\n{\n    if |s| == 0 then 0\n    else (if is_prime_hex_digit(s[0]) then 1 else 0) + count_prime_hex_digits(s[1..])\n}", "vc-helpers": "// ======= HELPERS =======\nlemma append_count_lemma(s: string, c: char)\n    ensures count_prime_hex_digits(s + [c]) == count_prime_hex_digits(s) + (if is_prime_hex_digit(c) then 1 else 0)\n{\n    if |s| == 0 {\n        assert s + [c] == [c];\n        assert count_prime_hex_digits([c]) == (if is_prime_hex_digit(c) then 1 else 0) + count_prime_hex_digits([]);\n    } else {\n        assert s + [c] == [s[0]] + s[1..] + [c];\n        assert s + [c] == [s[0]] + (s[1..] + [c]);\n        append_count_lemma(s[1..], c);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod hex_key(num: string) returns (count: int)\n    requires is_valid_hex_string(num)\n    ensures count >= 0\n    ensures count <= |num|\n    ensures count == count_prime_hex_digits(num)", "vc-code": "{\n    count := 0;\n    var i := 0;\n    while i < |num|\n        invariant 0 <= i <= |num|\n        invariant count >= 0\n        invariant count <= i\n        invariant count == count_prime_hex_digits(num[0..i])\n    {\n        var digit := num[i];\n        assert num[0..i+1] == num[0..i] + [digit];\n        append_count_lemma(num[0..i], digit);\n        if is_prime_hex_digit(digit)\n        {\n            count := count + 1;\n        }\n        i := i + 1;\n    }\n    assert i == |num|;\n    assert num[0..i] == num;\n}", "vc-postamble": ""}
{"id": "HumanEval_96", "vc-description": "This verification task involves implementing a function that returns all prime numbers strictly less than a given non-negative integer n, in ascending order. The implementation should correctly identify prime numbers using a helper method and build the result sequence while maintaining the sorted order.", "vc-preamble": "// ======= TASK =======\n// Given a non-negative integer n, return an array containing all prime numbers \n// that are strictly less than n, in ascending order.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_prime_number(num: int)\n{\n    num >= 2 && forall k :: 2 <= k < num ==> num % k != 0\n}\n\n// ======= HELPERS =======\nmethod is_prime(num: int) returns (prime: bool)\n    requires num >= 0\n    ensures prime == is_prime_number(num)\n{\n    if num < 2 {\n        prime := false;\n    } else if num == 2 {\n        prime := true;\n    } else if num % 2 == 0 {\n        prime := false;\n    } else {\n        prime := true;\n        var i := 3;\n        while i * i <= num\n            invariant 3 <= i\n            invariant i % 2 == 1\n            invariant prime == (forall k :: 3 <= k < i && k % 2 == 1 ==> num % k != 0)\n            invariant prime ==> (forall k :: 2 <= k < i ==> num % k != 0)\n            invariant !prime ==> (exists k :: 2 <= k < num && num % k == 0)\n        {\n            if num % i == 0 {\n                prime := false;\n                break;\n            }\n            i := i + 2;\n        }\n\n        if prime {\n            assert forall k :: 2 <= k < i ==> num % k != 0;\n            assert i * i > num;\n            assert forall k :: i <= k < num ==> k >= i;\n            assert forall k :: i <= k < num ==> k * k >= i * i > num;\n            assert forall k :: i <= k < num ==> k > num / k;\n            assert forall k :: i <= k < num ==> (num % k == 0 ==> num % (num / k) == 0 && 2 <= num / k < i);\n            assert forall k :: 2 <= k < num ==> num % k != 0;\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "method count_up_to(n: int) returns (result: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |result| ==> is_prime_number(result[i])\n    ensures forall i :: 0 <= i < |result| ==> result[i] < n\n    ensures forall p :: 2 <= p < n && is_prime_number(p) ==> p in result\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]", "vc-code": "{\n    result := [];\n    if n <= 2 {\n        return;\n    }\n    var i := 2;\n    while i < n\n        invariant 2 <= i\n        invariant i <= n\n        invariant forall k :: 0 <= k < |result| ==> is_prime_number(result[k])\n        invariant forall k :: 0 <= k < |result| ==> result[k] < n\n        invariant forall k :: 0 <= k < |result| ==> result[k] < i\n        invariant forall p :: 2 <= p < i && is_prime_number(p) ==> p in result\n        invariant forall k, j :: 0 <= k < j < |result| ==> result[k] < result[j]\n    {\n        var is_prime_result := is_prime(i);\n        if is_prime_result {\n            result := result + [i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_100", "vc-description": "This verification task implements a method to create a pile of stones with n levels. The first level contains n stones, and each subsequent level contains the next number with the same parity (odd/even) as n. This creates an arithmetic sequence where each level has 2 more stones than the previous level.", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, create a pile with n levels of stones where the first level\n// contains n stones and each subsequent level contains the next number of the same parity\n// (odd/even) as n. Return a sequence representing the number of stones in each level.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int)\n{\n    n > 0\n}\n\npredicate ValidPile(pile: seq<int>, n: int)\n{\n    && |pile| == n\n    && (n > 0 ==> |pile| > 0 && pile[0] == n)\n    && (forall i :: 0 <= i < |pile| ==> pile[i] == n + 2 * i)\n    && (forall i :: 0 <= i < |pile| - 1 ==> pile[i+1] == pile[i] + 2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod make_a_pile(n: int) returns (pile: seq<int>)\n    requires ValidInput(n)\n    ensures ValidPile(pile, n)", "vc-code": "{\n    pile := [];\n    var current_stones := n;\n    var i := 0;\n\n    while i < n\n        invariant 0 <= i <= n\n        invariant |pile| == i\n        invariant current_stones == n + 2 * i\n        invariant forall j :: 0 <= j < i ==> pile[j] == n + 2 * j\n    {\n        pile := pile + [current_stones];\n        current_stones := current_stones + 2;\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_3", "vc-description": "Given a list of integers representing bank account operations (positive for deposits, negative for withdrawals), determine if the account balance ever drops below zero. The account starts with a balance of zero.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers representing bank account operations (positive for deposits, \n// negative for withdrawals), determine if the account balance ever drops below zero. \n// The account starts with a balance of zero.\n\n// ======= SPEC REQUIREMENTS =======\nfunction sum_prefix(ops: seq<int>, len: nat): int\n  requires len <= |ops|\n{\n  if len == 0 then 0\n  else sum_prefix(ops, len-1) + ops[len-1]\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod below_zero(operations: seq<int>) returns (result: bool)\n  ensures result <==> (exists i :: 0 < i <= |operations| && sum_prefix(operations, i) < 0)", "vc-code": "{\n    var balance := 0;\n\n    for i := 0 to |operations|\n      invariant balance == sum_prefix(operations, i)\n      invariant forall j :: 0 < j <= i ==> sum_prefix(operations, j) >= 0\n    {\n        balance := balance + operations[i];\n        if balance < 0 {\n            assert balance == sum_prefix(operations, i+1);\n            assert 0 < i+1 <= |operations|;\n            assert sum_prefix(operations, i+1) < 0;\n            return true;\n        }\n    }\n\n    return false;\n}", "vc-postamble": ""}
{"id": "HumanEval_12", "vc-description": "This task involves finding the longest string in a sequence of strings. If multiple strings have the same maximum length, the method should return the first one that appears in the list. If the list is empty, it should return None using an Option type.", "vc-preamble": "// ======= TASK =======\n// Given a list of strings, return the longest string. If multiple strings have the same maximum length, \n// return the first one that appears in the list. If the list is empty, return None.\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Option<T> = Some(value: T) | None\n\npredicate ValidResult(strings: seq<string>, result: Option<string>)\n{\n    if |strings| == 0 then\n        result == None\n    else\n        result.Some? &&\n        exists i :: 0 <= i < |strings| && strings[i] == result.value &&\n        (forall s :: s in strings ==> |result.value| >= |s|) &&\n        (forall j :: 0 <= j < i ==> |strings[j]| < |result.value|)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod longest(strings: seq<string>) returns (result: Option<string>)\n    ensures ValidResult(strings, result)", "vc-code": "{\n    if |strings| == 0 {\n        result := None;\n    } else {\n        result := Some(strings[0]);\n        var bestIndex := 0;\n        for i := 1 to |strings|\n            invariant result.Some?\n            invariant 0 <= bestIndex < i\n            invariant strings[bestIndex] == result.value\n            invariant forall s :: s in strings[0..i] ==> |result.value| >= |s|\n            invariant forall j :: 0 <= j < bestIndex ==> |strings[j]| < |result.value|\n        {\n            if |strings[i]| > |result.value| {\n                result := Some(strings[i]);\n                bestIndex := i;\n            }\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_43", "vc-description": "Given a list of integers, determine if there exist two distinct elements at different positions that sum to zero. This task requires implementing an efficient algorithm to check for the existence of such a pair.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, determine if there exist two distinct elements at different positions that sum to zero.\n\n// ======= SPEC REQUIREMENTS =======\npredicate HasPairSumToZero(l: seq<int>)\n{\n    exists i, j :: 0 <= i < j < |l| && l[i] + l[j] == 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod pairs_sum_to_zero(l: seq<int>) returns (result: bool)\n    ensures result == HasPairSumToZero(l)", "vc-code": "{\n    var seen: set<int> := {};\n    var i := 0;\n\n    while i < |l|\n        invariant 0 <= i <= |l|\n        invariant seen == set k | 0 <= k < i :: l[k]\n        invariant forall k1, k2 :: 0 <= k1 < k2 < i ==> l[k1] + l[k2] != 0\n    {\n        var num := l[i];\n        if -num in seen {\n            assert exists k :: 0 <= k < i && l[k] == -num;\n            assert exists k :: 0 <= k < i && l[k] + l[i] == 0;\n            return true;\n        }\n        seen := seen + {num};\n        i := i + 1;\n    }\n\n    return false;\n}", "vc-postamble": ""}
{"id": "HumanEval_142", "vc-description": "Transform each element in a list of integers based on its index position: square elements at indices that are multiples of 3, cube elements at indices that are multiples of 4 but not 3, and leave other elements unchanged. Return the sum of all transformed elements.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, transform each element based on its index:\n// - If index is a multiple of 3: square the element\n// - If index is a multiple of 4 but not a multiple of 3: cube the element  \n// - Otherwise: keep the element unchanged\n// Return the sum of all transformed elements.\n\n// ======= SPEC REQUIREMENTS =======\nfunction transform_element(value: int, index: int): int\n{\n    if index % 3 == 0 then value * value\n    else if index % 4 == 0 then value * value * value\n    else value\n}\n\nfunction sum_partial(lst: seq<int>, n: int): int\n    requires 0 <= n <= |lst|\n{\n    if n == 0 then 0\n    else sum_partial(lst, n-1) + transform_element(lst[n-1], n-1)\n}\n\nfunction sum_transformed(lst: seq<int>): int\n{\n    sum_partial(lst, |lst|)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod sum_squares(lst: seq<int>) returns (result: int)\n    ensures result == sum_transformed(lst)", "vc-code": "{\n    if |lst| == 0 {\n        result := 0;\n        return;\n    }\n\n    result := 0;\n    var i := 0;\n    while i < |lst|\n        invariant 0 <= i <= |lst|\n        invariant result == sum_partial(lst, i)\n    {\n        var value := lst[i];\n        if i % 3 == 0 {\n            result := result + value * value;\n        } else if i % 4 == 0 {\n            result := result + value * value * value;\n        } else {\n            result := result + value;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_51", "vc-description": "This verification task involves removing all vowels (both lowercase and uppercase) from a given string and returning the resulting string. Vowels are defined as the characters: a, e, i, o, u, A, E, I, O, U. The implementation must preserve the order of non-vowel characters and ensure the result contains only characters from the original string that are not vowels.", "vc-preamble": "// ======= TASK =======\n// Given a string, remove all vowels (both lowercase and uppercase) and return the resulting string.\n// Vowels are defined as: a, e, i, o, u, A, E, I, O, U\n\n// ======= SPEC REQUIREMENTS =======\npredicate IsVowel(c: char) {\n    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n}\n\npredicate ValidResult(text: string, result: string) {\n    && |result| <= |text|\n    && (forall i :: 0 <= i < |result| ==> !IsVowel(result[i]))\n    && (forall i, j :: 0 <= i < j < |result| ==> \n        (exists k, l :: 0 <= k < l < |text| && text[k] == result[i] && text[l] == result[j] &&\n        !IsVowel(text[k]) && !IsVowel(text[l])))\n    && ((forall i :: 0 <= i < |text| ==> IsVowel(text[i])) ==> result == \"\")\n    && (forall i :: 0 <= i < |text| && !IsVowel(text[i]) ==> text[i] in result)\n    && (forall c :: c in result ==> c in text && !IsVowel(c))\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod remove_vowels(text: string) returns (result: string)\n    ensures ValidResult(text, result)", "vc-code": "{\n    var vowels := {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    var filtered := \"\";\n\n    var i := 0;\n    while i < |text|\n        invariant 0 <= i <= |text|\n        invariant |filtered| <= i\n        invariant forall j :: 0 <= j < |filtered| ==> !IsVowel(filtered[j])\n        invariant forall j :: 0 <= j < i && !IsVowel(text[j]) ==> text[j] in filtered\n        invariant forall c :: c in filtered ==> c in text[0..i] && !IsVowel(c)\n        invariant forall j, k :: 0 <= j < k < |filtered| ==> \n            (exists m, n :: 0 <= m < n < i && text[m] == filtered[j] && text[n] == filtered[k] &&\n            !IsVowel(text[m]) && !IsVowel(text[n]))\n        invariant (forall j :: 0 <= j < i ==> IsVowel(text[j])) ==> filtered == \"\"\n    {\n        var c := text[i];\n        if !(c in vowels) {\n            filtered := filtered + [c];\n        }\n        i := i + 1;\n    }\n\n    result := filtered;\n}", "vc-postamble": ""}
{"id": "HumanEval_124", "vc-description": "Implement a function to validate date strings according to specific formatting and validity rules. The date must be in \"mm-dd-yyyy\" format with exactly two hyphens as separators, contain only numeric components, have a valid month (1-12), and have a valid day for the given month (considering different month lengths including February with 29 days maximum).", "vc-preamble": "// ======= TASK =======\n// Validate a date string according to specific rules:\n// 1. Date string must not be empty\n// 2. Format must be exactly \"mm-dd-yyyy\" (using hyphens as separators)  \n// 3. Month must be between 1 and 12 (inclusive)\n// 4. Day must be valid for the given month (1-31 for months 1,3,5,7,8,10,12; 1-30 for months 4,6,9,11; 1-29 for month 2)\n// 5. All components (month, day, year) must be numeric\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidDateFormat(date: string)\n{\n    |date| > 0 &&\n    count_char(date, '-') == 2 &&\n    (var parts := split_by_hyphen(date);\n     |parts| == 3 &&\n     |parts[0]| > 0 && |parts[1]| > 0 && |parts[2]| > 0 &&\n     is_numeric(parts[0]) && is_numeric(parts[1]) && is_numeric(parts[2]) &&\n     (var month := string_to_int(parts[0]);\n      var day := string_to_int(parts[1]);\n      1 <= month <= 12 &&\n      (if month in {1, 3, 5, 7, 8, 10, 12} then 1 <= day <= 31\n       else if month in {4, 6, 9, 11} then 1 <= day <= 30\n       else 1 <= day <= 29)))\n}\n\n// ======= HELPERS =======\nfunction count_char(s: string, c: char): nat\n{\n    if |s| == 0 then 0\n    else if s[0] == c then 1 + count_char(s[1..], c)\n    else count_char(s[1..], c)\n}\n\nfunction is_digit(c: char): bool\n{\n    '0' <= c <= '9'\n}\n\nfunction is_numeric(s: string): bool\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> is_digit(s[i]))\n}\n\nfunction char_to_int(c: char): nat\n    requires is_digit(c)\n{\n    c as nat - '0' as nat\n}\n\nfunction string_to_int(s: string): nat\n    requires is_numeric(s)\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then char_to_int(s[0])\n    else string_to_int(s[..|s|-1]) * 10 + char_to_int(s[|s|-1])\n}\n\nfunction find_first_hyphen(s: string, start: nat): nat\n    requires start <= |s|\n    ensures find_first_hyphen(s, start) >= start\n    ensures find_first_hyphen(s, start) <= |s|\n    ensures find_first_hyphen(s, start) < |s| ==> s[find_first_hyphen(s, start)] == '-'\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == '-' then start\n    else find_first_hyphen(s, start + 1)\n}\n\nfunction split_by_hyphen(s: string): seq<string>\n{\n    var first_hyphen := find_first_hyphen(s, 0);\n    if first_hyphen >= |s| then [s]\n    else \n        var tmpCall1 := find_first_hyphen(s, first_hyphen + 1);\n        var second_hyphen := tmpCall1;\n        if second_hyphen >= |s| then [s[..first_hyphen], s[first_hyphen+1..]]\n        else \n            [s[..first_hyphen], s[first_hyphen+1..second_hyphen], s[second_hyphen+1..]]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nfunction valid_date(date: string): bool\n    ensures valid_date(date) == ValidDateFormat(date)", "vc-code": "{\n    if |date| == 0 then false\n    else\n        var hyphen_count := count_char(date, '-');\n        if hyphen_count != 2 then false\n        else\n            var parts := split_by_hyphen(date);\n            if |parts| != 3 then false\n            else\n                var month_str := parts[0];\n                var day_str := parts[1];\n                var year_str := parts[2];\n\n                if |month_str| == 0 || |day_str| == 0 || |year_str| == 0 then false\n                else if !is_numeric(month_str) || !is_numeric(day_str) || !is_numeric(year_str) then false\n                else\n                    var month := string_to_int(month_str);\n                    var day := string_to_int(day_str);\n                    var year := string_to_int(year_str);\n\n                    if month < 1 || month > 12 then false\n                    else\n                        if month in {1, 3, 5, 7, 8, 10, 12} then\n                            day >= 1 && day <= 31\n                        else if month in {4, 6, 9, 11} then\n                            day >= 1 && day <= 30\n                        else\n                            day >= 1 && day <= 29\n}", "vc-postamble": ""}
{"id": "HumanEval_151", "vc-description": "This verification task implements a function that computes the sum of squares of all positive odd integers in a list containing both integers and real numbers. The function should ignore negative numbers and non-integers, returning 0 for an empty list.\n\nThe implementation needs to handle a mixed datatype that can represent both integers and reals, properly identify positive odd integers (including reals that represent integers), and maintain correctness through loop invariants.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers, return the sum of squares of all positive odd integers in the list. \n// Ignore negative numbers and non-integers. Return 0 for an empty list.\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Number = Int(i: int) | Real(r: real)\n\nfunction IsInteger(r: real): bool\n{\n    r == r.Floor as real\n}\n\npredicate IsPositiveOddInteger(n: Number)\n{\n    match n\n    case Int(i) => i > 0 && i % 2 == 1\n    case Real(r) => IsInteger(r) && r > 0.0 && (r.Floor as int) % 2 == 1\n}\n\nfunction SquareValue(n: Number): int\n    requires IsPositiveOddInteger(n)\n    ensures SquareValue(n) > 0\n{\n    match n\n    case Int(i) => i * i\n    case Real(r) => (r.Floor as int) * (r.Floor as int)\n}\n\nfunction SumOfSquares(lst: seq<Number>, i: nat): int\n    requires i <= |lst|\n    ensures SumOfSquares(lst, i) >= 0\n{\n    if i == 0 then 0\n    else if IsPositiveOddInteger(lst[i-1]) then\n        SquareValue(lst[i-1]) + SumOfSquares(lst, i-1)\n    else\n        SumOfSquares(lst, i-1)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod double_the_difference(lst: seq<Number>) returns (result: int)\n    ensures result >= 0\n    ensures result == SumOfSquares(lst, |lst|)\n    ensures |lst| == 0 ==> result == 0", "vc-code": "{\n    result := 0;\n    for i := 0 to |lst|\n        invariant result == SumOfSquares(lst, i)\n    {\n        match lst[i]\n        case Int(n) =>\n            if n > 0 && n % 2 == 1 {\n                result := result + n * n;\n            }\n        case Real(r) =>\n            if IsInteger(r) && r > 0.0 && (r.Floor as int) % 2 == 1 {\n                result := result + (r.Floor as int) * (r.Floor as int);\n            }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_107", "vc-description": "This verification task implements a function to count even and odd palindromic integers in the range [1, n] inclusive. A palindromic integer reads the same forwards and backwards (e.g., 121, 7, 1331). The function should return a tuple (even_count, odd_count) representing the counts of even and odd palindromic integers respectively.", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, count the number of even and odd palindromic integers in the range [1, n] inclusive.\n// A palindromic integer reads the same forwards and backwards (e.g., 121, 7, 1331).\n// Return a tuple (even_count, odd_count) where even_count is the number of even palindromic integers\n// and odd_count is the number of odd palindromic integers in [1, n].\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: nat)\n{\n    n >= 1\n}\n\nfunction DigitsOf(n: nat): seq<nat>\n    requires n >= 0\n{\n    if n < 10 then [n]\n    else DigitsOf(n / 10) + [n % 10]\n}\n\nfunction ReverseSeq<T>(s: seq<T>): seq<T>\n{\n    if |s| <= 1 then s\n    else ReverseSeq(s[1..]) + [s[0]]\n}\n\nfunction IsPalindrome(n: nat): bool\n    requires n >= 0\n{\n    var digits := DigitsOf(n);\n    digits == ReverseSeq(digits)\n}\n\nfunction CountPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) then 1 + CountPalindromesInRange(start + 1, end)\n    else CountPalindromesInRange(start + 1, end)\n}\n\nfunction CountEvenPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) && start % 2 == 0 then 1 + CountEvenPalindromesInRange(start + 1, end)\n    else CountEvenPalindromesInRange(start + 1, end)\n}\n\nfunction CountOddPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) && start % 2 == 1 then 1 + CountOddPalindromesInRange(start + 1, end)\n    else CountOddPalindromesInRange(start + 1, end)\n}", "vc-helpers": "// ======= HELPERS =======\nfunction CountPalindromes(n: nat, current: nat, even_count: nat, odd_count: nat): (nat, nat)\n    requires current >= 1\n    requires n >= 1\n    requires current <= n + 1\n    decreases n - current + 1\n    ensures CountPalindromes(n, current, even_count, odd_count).0 >= even_count\n    ensures CountPalindromes(n, current, even_count, odd_count).1 >= odd_count\n    ensures CountPalindromes(n, current, even_count, odd_count).0 == even_count + CountEvenPalindromesInRange(current, n)\n    ensures CountPalindromes(n, current, even_count, odd_count).1 == odd_count + CountOddPalindromesInRange(current, n)\n    ensures CountPalindromes(n, current, even_count, odd_count).0 + CountPalindromes(n, current, even_count, odd_count).1 == even_count + odd_count + CountPalindromesInRange(current, n)\n{\n    if current > n then\n        (even_count, odd_count)\n    else if IsPalindrome(current) then\n        if current % 2 == 0 then\n            CountPalindromes(n, current + 1, even_count + 1, odd_count)\n        else\n            CountPalindromes(n, current + 1, even_count, odd_count + 1)\n    else\n        CountPalindromes(n, current + 1, even_count, odd_count)\n}", "vc-spec": "// ======= MAIN METHOD =======\nfunction even_odd_palindrome(n: nat): (nat, nat)\n    requires ValidInput(n)\n    ensures even_odd_palindrome(n).0 >= 0\n    ensures even_odd_palindrome(n).1 >= 0\n    ensures even_odd_palindrome(n).0 == CountEvenPalindromesInRange(1, n)\n    ensures even_odd_palindrome(n).1 == CountOddPalindromesInRange(1, n)\n    ensures even_odd_palindrome(n).0 + even_odd_palindrome(n).1 == CountPalindromesInRange(1, n)", "vc-code": "{\n    var result := CountPalindromes(n, 1, 0, 0);\n    result\n}", "vc-postamble": ""}
{"id": "HumanEval_89", "vc-description": "This verification task implements a string encryption algorithm that shifts each alphabetic character forward by 4 positions in the alphabet with wraparound. The implementation should preserve the case of letters and leave non-alphabetic characters unchanged.", "vc-preamble": "// ======= TASK =======\n// Encrypts a string by shifting each alphabetic character forward by 4 positions in the alphabet.\n// The shift wraps around (after 'z' comes 'a', after 'Z' comes 'A').\n// Non-alphabetic characters remain unchanged. Case of letters is preserved.\n\n// ======= SPEC REQUIREMENTS =======\n\n// ======= HELPERS =======\n\n// ======= MAIN METHOD =======", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method encrypt(s: string) returns (result: string)\n    requires |s| >= 0\n    ensures |result| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (\n        if 'a' <= s[i] <= 'z' then\n            result[i] == (((s[i] as int - 'a' as int + 4) % 26) + 'a' as int) as char\n        else if 'A' <= s[i] <= 'Z' then\n            result[i] == (((s[i] as int - 'A' as int + 4) % 26) + 'A' as int) as char\n        else\n            result[i] == s[i]\n    )", "vc-code": "{\n    var encrypted := [];\n    var shift := 4;\n\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant |encrypted| == i\n        invariant forall j :: 0 <= j < i ==> (\n            if 'a' <= s[j] <= 'z' then\n                encrypted[j] == (((s[j] as int - 'a' as int + 4) % 26) + 'a' as int) as char\n            else if 'A' <= s[j] <= 'Z' then\n                encrypted[j] == (((s[j] as int - 'A' as int + 4) % 26) + 'A' as int) as char\n            else\n                encrypted[j] == s[j]\n        )\n    {\n        var c := s[i];\n\n        if 'a' <= c && c <= 'z' {\n            var shifted_pos := (c as int - 'a' as int + shift) % 26;\n            var new_char := (shifted_pos + 'a' as int) as char;\n            encrypted := encrypted + [new_char];\n        } else if 'A' <= c && c <= 'Z' {\n            var shifted_pos := (c as int - 'A' as int + shift) % 26;\n            var new_char := (shifted_pos + 'A' as int) as char;\n            encrypted := encrypted + [new_char];\n        } else {\n            encrypted := encrypted + [c];\n        }\n    }\n\n    result := encrypted;\n}", "vc-postamble": ""}
{"id": "HumanEval_47", "vc-description": "This verification task implements a median function for a sequence of real numbers. For odd-length lists, it returns the middle element after sorting. For even-length lists, it returns the average of the two middle elements after sorting.\n\nThe implementation uses helper functions for insertion sort and includes comprehensive specifications to ensure the sorted list preserves the original multiset and maintains proper ordering.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers, return the median value. For odd-length lists, return the middle element after sorting. \n// For even-length lists, return the average of the two middle elements after sorting.\n\n// ======= SPEC REQUIREMENTS =======\nfunction InsertSorted(x: real, sorted: seq<real>): seq<real>\n{\n    if |sorted| == 0 then [x]\n    else if x <= sorted[0] then [x] + sorted\n    else [sorted[0]] + InsertSorted(x, sorted[1..])\n}\n\nfunction Sort(s: seq<real>): seq<real>\n{\n    if |s| == 0 then []\n    else InsertSorted(s[0], Sort(s[1..]))\n}\n\npredicate IsSorted(s: seq<real>) {\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction Multiset(s: seq<real>): multiset<real> {\n    if |s| == 0 then multiset{}\n    else multiset{s[0]} + Multiset(s[1..])\n}\n\npredicate ValidInput(l: seq<real>) {\n    |l| > 0\n}\n\nfunction MedianValue(l: seq<real>): real\n    requires ValidInput(l)\n{\n    var sorted_list := Sort(l);\n    var n := |sorted_list|;\n    if n % 2 == 1 then\n        sorted_list[n / 2]\n    else\n        (sorted_list[n / 2 - 1] + sorted_list[n / 2]) / 2.0\n}", "vc-helpers": "// ======= HELPERS =======\nlemma InsertSortedPreservesOrder(x: real, sorted: seq<real>)\n    requires IsSorted(sorted)\n    ensures IsSorted(InsertSorted(x, sorted))\n{\n    if |sorted| == 0 {\n    } else if x <= sorted[0] {\n    } else {\n        InsertSortedPreservesOrder(x, sorted[1..]);\n        var result := InsertSorted(x, sorted[1..]);\n        assert IsSorted(result);\n        // Need to show that sorted[0] <= all elements in result\n        if |result| > 0 {\n            assert sorted[0] <= result[0];\n        }\n        assert IsSorted([sorted[0]] + result);\n    }\n}\n\nlemma SortProducesOrder(s: seq<real>)\n    ensures IsSorted(Sort(s))\n{\n    if |s| == 0 {\n    } else {\n        SortProducesOrder(s[1..]);\n        InsertSortedPreservesOrder(s[0], Sort(s[1..]));\n    }\n}\n\nlemma InsertSortedPreservesMultiset(x: real, sorted: seq<real>)\n    ensures Multiset(InsertSorted(x, sorted)) == multiset{x} + Multiset(sorted)\n{\n    if |sorted| == 0 {\n    } else if x <= sorted[0] {\n    } else {\n        InsertSortedPreservesMultiset(x, sorted[1..]);\n    }\n}\n\nlemma SortPreservesMultiset(s: seq<real>)\n    ensures Multiset(Sort(s)) == Multiset(s)\n{\n    if |s| == 0 {\n    } else {\n        SortPreservesMultiset(s[1..]);\n        InsertSortedPreservesMultiset(s[0], Sort(s[1..]));\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod median(l: seq<real>) returns (result: real)\n    requires ValidInput(l)\n    ensures result == MedianValue(l)\n    ensures var sorted_list := Sort(l);\n            var n := |sorted_list|;\n            n % 2 == 1 ==> result == sorted_list[n / 2]\n    ensures var sorted_list := Sort(l);\n            var n := |sorted_list|;\n            n % 2 == 0 ==> result == (sorted_list[n / 2 - 1] + sorted_list[n / 2]) / 2.0\n    ensures IsSorted(Sort(l))\n    ensures Multiset(Sort(l)) == Multiset(l)\n    ensures |l| == 1 ==> result == l[0]", "vc-code": "{\n    SortProducesOrder(l);\n    SortPreservesMultiset(l);\n\n    var sorted_list := Sort(l);\n    var n := |sorted_list|;\n\n    if n % 2 == 1 {\n        result := sorted_list[n / 2];\n    } else {\n        var mid1 := sorted_list[n / 2 - 1];\n        var mid2 := sorted_list[n / 2];\n        result := (mid1 + mid2) / 2.0;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_162", "vc-description": "This verification task implements a string to MD5 hash conversion function. The method takes a string input and returns an Option type containing either None (for empty input) or Some with a valid 32-character lowercase hexadecimal MD5 hash string.", "vc-preamble": "// ======= TASK =======\n// Convert a string to its MD5 hash representation as a lowercase hexadecimal string.\n// Return None if the input string is empty, otherwise return Some(hash_string).\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Option<T> = None | Some(value: T)\n\npredicate isValidMD5Hash(s: string)\n{\n    |s| == 32 && forall i :: 0 <= i < |s| ==> s[i] in \"0123456789abcdef\"\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod string_to_md5(text: string) returns (result: Option<string>)\n    ensures text == \"\" ==> result == None\n    ensures text != \"\" ==> result.Some? && isValidMD5Hash(result.value)\n    ensures text != \"\" ==> |result.value| == 32", "vc-code": "{\n    if text == \"\" {\n        result := None;\n    } else {\n        // Stub implementation returns a valid MD5 hash placeholder\n        result := Some(\"00000000000000000000000000000000\");\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_65", "vc-description": "This verification task implements a circular right shift operation on the digits of an integer. Given an integer x and a shift amount, the method performs a circular right shift on the digits of x and returns the result as a string. A circular right shift moves digits from the end to the beginning. If the shift amount exceeds the number of digits in x, the method returns the digits of x in reversed order instead.", "vc-preamble": "// ======= TASK =======\n// Given an integer x and a shift amount, perform a circular right shift on the digits of x \n// and return the result as a string. A circular right shift moves digits from the end to the \n// beginning. If the shift amount exceeds the number of digits in x, return the digits of x \n// in reversed order instead.\n\n// ======= SPEC REQUIREMENTS =======\nfunction intToString(x: int): string\n    requires x >= 0\n    ensures |intToString(x)| >= 1\n    ensures forall i :: 0 <= i < |intToString(x)| ==> '0' <= intToString(x)[i] <= '9'\n{\n    if x == 0 then \"0\"\n    else intToStringHelper(x, \"\")\n}\n\nfunction intToStringHelper(x: int, acc: string): string\n    requires x >= 0\n    requires forall i :: 0 <= i < |acc| ==> '0' <= acc[i] <= '9'\n    ensures forall i :: 0 <= i < |intToStringHelper(x, acc)| ==> '0' <= intToStringHelper(x, acc)[i] <= '9'\n    ensures x > 0 ==> |intToStringHelper(x, acc)| > |acc|\n{\n    if x == 0 then acc\n    else intToStringHelper(x / 10, [((x % 10) + '0' as int) as char] + acc)\n}\n\nfunction reverseString(s: string): string\n    ensures |reverseString(s)| == |s|\n    ensures forall i :: 0 <= i < |s| ==> reverseString(s)[i] == s[|s| - 1 - i]\n{\n    if |s| <= 1 then s\n    else reverseString(s[1..]) + [s[0]]\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod circular_shift(x: int, shift: int) returns (result: string)\n    ensures |result| == |intToString(if x < 0 then -x else x)|\n    ensures shift > |intToString(if x < 0 then -x else x)| ==> \n            result == reverseString(intToString(if x < 0 then -x else x))\n    ensures shift <= |intToString(if x < 0 then -x else x)| && |intToString(if x < 0 then -x else x)| > 0 ==>\n            (var digits := intToString(if x < 0 then -x else x);\n             var n := |digits|;\n             var normalizedShift := shift % n;\n             normalizedShift == 0 ==> result == digits)\n    ensures shift <= |intToString(if x < 0 then -x else x)| && |intToString(if x < 0 then -x else x)| > 0 ==>\n            (var digits := intToString(if x < 0 then -x else x);\n             var n := |digits|;\n             var normalizedShift := shift % n;\n             normalizedShift > 0 ==> result == digits[n - normalizedShift..] + digits[..n - normalizedShift])\n    ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'", "vc-code": "{\n    // Convert to string to work with digits, handle negative numbers\n    var digits := intToString(if x < 0 then -x else x);\n    var n := |digits|;\n\n    // If shift is greater than number of digits, return reversed digits\n    if shift > n {\n        result := reverseString(digits);\n        return;\n    }\n\n    // Handle case where shift is 0 or n is 0\n    if shift == 0 || n == 0 {\n        result := digits;\n        return;\n    }\n\n    // Normalize shift to be within range [0, n)\n    var normalizedShift := shift % n;\n\n    // If normalized shift is 0, return original\n    if normalizedShift == 0 {\n        result := digits;\n        return;\n    }\n\n    // Perform circular right shift\n    // Right shift by 'shift' means taking last 'shift' digits and moving them to front\n    var lastPart := digits[n - normalizedShift..];\n    var firstPart := digits[..n - normalizedShift];\n    result := lastPart + firstPart;\n}", "vc-postamble": ""}
{"id": "HumanEval_25", "vc-description": "Given a positive integer n, return a list of its prime factors in ascending order. Each prime factor should appear in the list as many times as it divides n (i.e., according to its multiplicity in the prime factorization).", "vc-preamble": "predicate isPrime(n: int)\n{\n    n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nfunction product(factors: seq<int>): int\n{\n    if |factors| == 0 then 1\n    else factors[0] * product(factors[1..])\n}\n\npredicate isNonDecreasing(factors: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |factors| ==> factors[i] <= factors[j]\n}", "vc-helpers": "lemma ProductAppend(factors: seq<int>, x: int)\n    ensures product(factors + [x]) == product(factors) * x\n{\n    if |factors| == 0 {\n        assert factors + [x] == [x];\n        assert product([x]) == x * product([]) == x * 1 == x;\n        assert product(factors) * x == 1 * x == x;\n    } else {\n        assert (factors + [x])[0] == factors[0];\n        assert (factors + [x])[1..] == factors[1..] + [x];\n        ProductAppend(factors[1..], x);\n        assert product(factors[1..] + [x]) == product(factors[1..]) * x;\n        assert product(factors + [x]) == factors[0] * product(factors[1..] + [x]);\n        assert product(factors + [x]) == factors[0] * product(factors[1..]) * x;\n        assert product(factors + [x]) == product(factors) * x;\n    }\n}", "vc-spec": "method factorize(n: int) returns (factors: seq<int>)\n    ensures n <= 1 ==> |factors| == 0\n    ensures n > 1 ==> product(factors) == n\n    ensures forall i :: 0 <= i < |factors| ==> isPrime(factors[i])\n    ensures isNonDecreasing(factors)\n    ensures forall i :: 0 <= i < |factors| ==> factors[i] >= 2", "vc-code": "{\n    factors := [];\n\n    if n <= 1 {\n        return;\n    }\n\n    var current := n;\n\n    // Handle factor 2\n    while current % 2 == 0\n        decreases current\n        invariant current >= 1\n        invariant product(factors) * current == n\n        invariant forall i :: 0 <= i < |factors| ==> isPrime(factors[i])\n        invariant forall i :: 0 <= i < |factors| ==> factors[i] == 2\n        invariant isNonDecreasing(factors)\n        invariant forall i :: 0 <= i < |factors| ==> factors[i] >= 2\n    {\n        ProductAppend(factors, 2);\n        factors := factors + [2];\n        current := current / 2;\n    }\n\n    // Handle odd factors starting from 3\n    var factor := 3;\n    while factor * factor <= current\n        invariant factor >= 3\n        invariant factor % 2 == 1\n        invariant current >= 1\n        invariant product(factors) * current == n\n        invariant forall k :: 2 <= k < factor ==> current % k != 0\n        invariant forall i :: 0 <= i < |factors| ==> isPrime(factors[i])\n        invariant isNonDecreasing(factors)\n        invariant forall i :: 0 <= i < |factors| ==> factors[i] >= 2\n        invariant forall i :: 0 <= i < |factors| ==> factors[i] <= factor\n    {\n        if current % factor == 0 {\n            // Check if factor is prime\n            assert forall k :: 2 <= k < factor ==> factor % k != 0;\n            assert isPrime(factor);\n        }\n\n        while current % factor == 0\n            decreases current\n            invariant current >= 1\n            invariant factor >= 3\n            invariant forall k :: 2 <= k < factor ==> current % k != 0\n            invariant isPrime(factor)\n            invariant product(factors) * current == n\n            invariant forall i :: 0 <= i < |factors| ==> isPrime(factors[i])\n            invariant isNonDecreasing(factors)\n            invariant forall i :: 0 <= i < |factors| ==> factors[i] >= 2\n            invariant forall i :: 0 <= i < |factors| ==> factors[i] <= factor\n        {\n            ProductAppend(factors, factor);\n            factors := factors + [factor];\n            current := current / factor;\n        }\n        factor := factor + 2;\n    }\n\n    // If current > 1, it's a prime factor\n    if current > 1 {\n        assert forall k :: 2 <= k < current ==> current % k != 0;\n        assert isPrime(current);\n        ProductAppend(factors, current);\n        factors := factors + [current];\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_74", "vc-description": "This task implements a function that compares two lists of strings by their total character count. Given two lists of strings, the function should return the list that has the smaller total character count across all its strings. If both lists have the same total character count, return the first list.", "vc-preamble": "// ======= TASK =======\n// Given two lists of strings, return the list that has the smaller total character count \n// across all its strings. If both lists have the same total character count, return the first list.\n\n// ======= SPEC REQUIREMENTS =======\nfunction total_chars(lst: seq<string>): nat\n{\n    if |lst| == 0 then 0\n    else |lst[0]| + total_chars(lst[1..])\n}", "vc-helpers": "// ======= HELPERS =======\nlemma total_chars_prefix(lst: seq<string>, i: nat)\n    requires 0 <= i < |lst|\n    ensures total_chars(lst[..i+1]) == total_chars(lst[..i]) + |lst[i]|\n{\n    if i == 0 {\n        assert lst[..1] == [lst[0]];\n        assert total_chars(lst[..1]) == |lst[0]| + total_chars([]);\n        assert total_chars([]) == 0;\n    } else {\n        assert lst[..i+1] == [lst[0]] + (lst[1..])[..i];\n        assert lst[..i] == [lst[0]] + (lst[1..])[..i-1];\n        assert lst[i] == (lst[1..])[i-1];\n        total_chars_prefix(lst[1..], i-1);\n        assert total_chars((lst[1..])[..i]) == total_chars((lst[1..])[..i-1]) + |(lst[1..])[i-1]|;\n        assert total_chars(lst[..i+1]) == |lst[0]| + total_chars((lst[1..])[..i]);\n        assert total_chars(lst[..i]) == |lst[0]| + total_chars((lst[1..])[..i-1]);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod total_match(lst1: seq<string>, lst2: seq<string>) returns (result: seq<string>)\n    ensures result == lst1 || result == lst2\n    ensures total_chars(lst1) <= total_chars(lst2) ==> result == lst1\n    ensures total_chars(lst1) > total_chars(lst2) ==> result == lst2", "vc-code": "{\n    var total_chars_lst1 := 0;\n    var i := 0;\n    while i < |lst1|\n        invariant 0 <= i <= |lst1|\n        invariant total_chars_lst1 == total_chars(lst1[..i])\n    {\n        total_chars_prefix(lst1, i);\n        total_chars_lst1 := total_chars_lst1 + |lst1[i]|;\n        i := i + 1;\n    }\n\n    var total_chars_lst2 := 0;\n    i := 0;\n    while i < |lst2|\n        invariant 0 <= i <= |lst2|\n        invariant total_chars_lst2 == total_chars(lst2[..i])\n    {\n        total_chars_prefix(lst2, i);\n        total_chars_lst2 := total_chars_lst2 + |lst2[i]|;\n        i := i + 1;\n    }\n\n    assert lst1[..|lst1|] == lst1;\n    assert lst2[..|lst2|] == lst2;\n    assert total_chars_lst1 == total_chars(lst1);\n    assert total_chars_lst2 == total_chars(lst2);\n\n    if total_chars_lst1 <= total_chars_lst2 {\n        result := lst1;\n    } else {\n        result := lst2;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_106", "vc-description": "This task requires implementing a method that generates a sequence of natural numbers based on position-dependent calculations. For each position i (0-indexed), if (i+1) is even, the element should be the factorial of (i+1); if (i+1) is odd, the element should be the sum of integers from 1 to (i+1).", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, return a list of length n where each element at position i (0-indexed) \n// is calculated as follows: if (i+1) is even, use factorial of (i+1); if (i+1) is odd, use sum of \n// integers from 1 to (i+1).\n\n// ======= SPEC REQUIREMENTS =======\nfunction factorial(n: nat): nat\n{\n    if n <= 1 then 1 else n * factorial(n - 1)\n}\n\nfunction sum_range(n: nat): nat\n{\n    if n == 0 then 0 else n + sum_range(n - 1)\n}\n\npredicate ValidResult(n: nat, result: seq<nat>)\n{\n    |result| == n &&\n    forall i :: 0 <= i < n ==> \n        (if (i + 1) % 2 == 0 then result[i] == factorial(i + 1)\n         else result[i] == sum_range(i + 1))\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod f(n: nat) returns (result: seq<nat>)\n    ensures ValidResult(n, result)", "vc-code": "{\n    result := [];\n\n    for i := 1 to n + 1 \n        invariant |result| == i - 1\n        invariant forall k :: 0 <= k < i - 1 ==> \n            (if (k + 1) % 2 == 0 then result[k] == factorial(k + 1)\n             else result[k] == sum_range(k + 1))\n    {\n        if i % 2 == 0 {  // i is even\n            // Calculate factorial of i\n            var fact: nat := 1;\n            for j := 1 to i + 1 \n                invariant fact == factorial(j - 1)\n            {\n                fact := fact * j;\n            }\n            result := result + [fact];\n        } else {  // i is odd\n            // Calculate sum from 1 to i\n            var sum_val: nat := 0;\n            for j := 1 to i + 1 \n                invariant sum_val == sum_range(j - 1)\n            {\n                sum_val := sum_val + j;\n            }\n            result := result + [sum_val];\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_6", "vc-description": "This verification task implements a parser for nested parentheses strings. Given a string containing groups of nested parentheses separated by spaces, the goal is to find the maximum nesting depth for each group independently. The implementation must correctly split the input by spaces, calculate nesting depths, and return a sequence of maximum depths corresponding to each group.", "vc-preamble": "// ======= TASK =======\n// Given a string containing multiple groups of nested parentheses separated by spaces,\n// find the maximum nesting depth for each group. The input string contains only\n// parentheses '(', ')', and spaces ' '. Groups are separated by spaces, and each\n// group's maximum nesting depth is calculated independently.\n\n// ======= SPEC REQUIREMENTS =======\nfunction SplitBySpacesResult(s: string): seq<string>\n    requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    ensures forall i :: 0 <= i < |SplitBySpacesResult(s)| ==> forall j :: 0 <= j < |SplitBySpacesResult(s)[i]| ==> SplitBySpacesResult(s)[i][j] == '(' || SplitBySpacesResult(s)[i][j] == ')'\n    ensures |s| == 0 ==> |SplitBySpacesResult(s)| == 0\n{\n    if |s| == 0 then []\n    else\n        var groups := [];\n        var current_group := \"\";\n        var i := 0;\n        SplitBySpacesHelper(s, i, current_group, groups)\n}\n\nfunction MaxNestingDepth(group: string): int\n    requires forall i :: 0 <= i < |group| ==> group[i] == '(' || group[i] == ')'\n    ensures MaxNestingDepth(group) >= 0\n{\n    MaxNestingDepthHelper(group, 0, 0, 0)\n}\n\n// ======= HELPERS =======\nfunction SplitBySpacesHelper(s: string, i: int, current_group: string, groups: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    requires forall k :: 0 <= k < |s| ==> s[k] == '(' || s[k] == ')' || s[k] == ' '\n    requires forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'\n    requires forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'\n    ensures forall k :: 0 <= k < |SplitBySpacesHelper(s, i, current_group, groups)| ==> forall j :: 0 <= j < |SplitBySpacesHelper(s, i, current_group, groups)[k]| ==> SplitBySpacesHelper(s, i, current_group, groups)[k][j] == '(' || SplitBySpacesHelper(s, i, current_group, groups)[k][j] == ')'\n    decreases |s| - i\n{\n    if i == |s| then\n        if |current_group| > 0 then groups + [current_group] else groups\n    else if s[i] == ' ' then\n        if |current_group| > 0 then\n            SplitBySpacesHelper(s, i + 1, \"\", groups + [current_group])\n        else\n            SplitBySpacesHelper(s, i + 1, current_group, groups)\n    else\n        SplitBySpacesHelper(s, i + 1, current_group + [s[i]], groups)\n}\n\nfunction MaxNestingDepthHelper(group: string, index: int, current_depth: int, max_depth: int): int\n    requires 0 <= index <= |group|\n    requires max_depth >= 0\n    decreases |group| - index\n    ensures MaxNestingDepthHelper(group, index, current_depth, max_depth) >= 0\n{\n    if index == |group| then max_depth\n    else if group[index] == '(' then\n        var new_current := current_depth + 1;\n        var new_max := if new_current > max_depth then new_current else max_depth;\n        MaxNestingDepthHelper(group, index + 1, new_current, new_max)\n    else if group[index] == ')' then\n        MaxNestingDepthHelper(group, index + 1, current_depth - 1, max_depth)\n    else\n        MaxNestingDepthHelper(group, index + 1, current_depth, max_depth)\n}\n\nmethod SplitBySpaces(s: string) returns (groups: seq<string>)\n    requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    ensures forall i :: 0 <= i < |groups| ==> ' ' !in groups[i]\n    ensures forall i :: 0 <= i < |groups| ==> forall j :: 0 <= j < |groups[i]| ==> groups[i][j] == '(' || groups[i][j] == ')'\n    ensures |s| == 0 ==> |groups| == 0\n    ensures groups == SplitBySpacesResult(s)\n{\n    groups := [];\n    var current_group := \"\";\n\n    if |s| == 0 {\n        return;\n    }\n\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant ' ' !in current_group\n        invariant forall k :: 0 <= k < |groups| ==> ' ' !in groups[k]\n        invariant forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'\n        invariant forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'\n        invariant SplitBySpacesResult(s) == SplitBySpacesHelper(s, i, current_group, groups)\n    {\n        if s[i] == ' ' {\n            if |current_group| > 0 {\n                groups := groups + [current_group];\n                current_group := \"\";\n            }\n        } else {\n            current_group := current_group + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if |current_group| > 0 {\n        groups := groups + [current_group];\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod parse_nested_parens(paren_string: string) returns (result: seq<int>)\n    requires forall i :: 0 <= i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '\n    ensures |result| == |SplitBySpacesResult(paren_string)|\n    ensures forall i :: 0 <= i < |result| ==> result[i] >= 0\n    ensures |paren_string| == 0 ==> |result| == 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] == MaxNestingDepth(SplitBySpacesResult(paren_string)[i])", "vc-code": "{\n    result := [];\n\n    if |paren_string| == 0 {\n        return;\n    }\n\n    var groups := SplitBySpaces(paren_string);\n    assert groups == SplitBySpacesResult(paren_string);\n\n    var i := 0;\n    while i < |groups|\n        invariant 0 <= i <= |groups|\n        invariant |result| == i\n        invariant forall k :: 0 <= k < i ==> result[k] >= 0\n        invariant forall k :: 0 <= k < i ==> result[k] == MaxNestingDepth(groups[k])\n        invariant groups == SplitBySpacesResult(paren_string)\n    {\n        var group := groups[i];\n        var current_depth := 0;\n        var max_depth := 0;\n\n        var j := 0;\n        while j < |group|\n            invariant 0 <= j <= |group|\n            invariant max_depth >= 0\n            invariant MaxNestingDepth(group) == MaxNestingDepthHelper(group, j, current_depth, max_depth)\n        {\n            if group[j] == '(' {\n                current_depth := current_depth + 1;\n                if current_depth > max_depth {\n                    max_depth := current_depth;\n                }\n            } else if group[j] == ')' {\n                current_depth := current_depth - 1;\n            }\n            j := j + 1;\n        }\n\n        assert max_depth == MaxNestingDepth(group);\n        result := result + [max_depth];\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_60", "vc-description": "This verification task implements the computation of the sum of all integers from 1 to n inclusive, where n is a positive integer. The expected implementation should use the well-known mathematical formula n*(n+1)/2 for efficiency.", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, compute the sum of all integers from 1 to n inclusive.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int)\n{\n    n >= 1\n}\n\nfunction SumFromOneToN(n: int): int\n    requires n >= 1\n{\n    n * (n + 1) / 2\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "method sum_to_n(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == SumFromOneToN(n)", "vc-code": "{\n    result := n * (n + 1) / 2;\n}", "vc-postamble": ""}
{"id": "HumanEval_52", "vc-description": "This verification task implements a method to check if all integers in a given list are strictly less than a specified threshold value. The method should return true if and only if every element in the sequence satisfies the threshold condition.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers and a threshold integer, determine if all numbers \n// in the list are strictly less than the threshold.\n\n// ======= SPEC REQUIREMENTS =======\npredicate BelowThreshold(l: seq<int>, t: int)\n{\n    forall i :: 0 <= i < |l| ==> l[i] < t\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod CheckBelowThreshold(l: seq<int>, t: int) returns (result: bool)\n    ensures result == BelowThreshold(l, t)", "vc-code": "{\n    result := forall i :: 0 <= i < |l| ==> l[i] < t;\n}", "vc-postamble": ""}
{"id": "HumanEval_41", "vc-description": "Given n cars moving left-to-right and n cars moving right-to-left on a straight infinite road, all at the same speed, calculate the total number of collisions. Cars pass through each other when they collide and continue moving. Each left-moving car will collide with each right-moving car exactly once, resulting in n * n total collisions.", "vc-preamble": "// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int)\n{\n    n >= 0\n}\n\nfunction CollisionCount(n: int): int\n    requires ValidInput(n)\n{\n    n * n\n}\n\npredicate ValidResult(n: int, result: int)\n    requires ValidInput(n)\n{\n    result == CollisionCount(n) && result >= 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "method car_race_collision(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures ValidResult(n, result)", "vc-code": "{\n    result := n * n;\n}", "vc-postamble": ""}
{"id": "HumanEval_68", "vc-description": "This verification task implements a function that finds the smallest even value in an array of non-negative integers and returns it along with its index. If multiple occurrences of the same smallest even value exist, it should return the one with the smallest index. If no even values exist or the array is empty, it returns an empty list.\n\nThe implementation must correctly handle edge cases and maintain loop invariants to prove that the returned result satisfies all the postconditions, including finding the true minimum even value and the earliest index for that value.", "vc-preamble": "// ======= TASK =======\n// Given an array of non-negative integers, find the smallest even value and return it along with its index.\n// If multiple occurrences of the same smallest even value exist, return the one with the smallest index.\n// If no even values exist or the array is empty, return an empty list.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(arr: seq<int>)\n{\n    forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n}\n\npredicate HasEvenValue(arr: seq<int>)\n{\n    exists i :: 0 <= i < |arr| && arr[i] % 2 == 0\n}\n\nfunction SmallestEvenValue(arr: seq<int>): int\n    requires HasEvenValue(arr)\n{\n    SmallestEvenValueHelper(arr, 0, -1)\n}\n\nfunction SmallestEvenValueHelper(arr: seq<int>, index: int, current_min: int): int\n    requires 0 <= index <= |arr|\n    decreases |arr| - index\n{\n    if index >= |arr| then current_min\n    else if arr[index] % 2 == 0 then\n        if current_min == -1 || arr[index] < current_min then\n            SmallestEvenValueHelper(arr, index + 1, arr[index])\n        else\n            SmallestEvenValueHelper(arr, index + 1, current_min)\n    else\n        SmallestEvenValueHelper(arr, index + 1, current_min)\n}\n\nfunction FirstIndexOfValue(arr: seq<int>, value: int): int\n    requires exists i :: 0 <= i < |arr| && arr[i] == value\n    decreases |arr|\n{\n    if |arr| > 0 && arr[0] == value then 0\n    else 1 + FirstIndexOfValue(arr[1..], value)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod pluck(arr: seq<int>) returns (result: seq<int>)\n    requires ValidInput(arr)\n    ensures |arr| == 0 ==> |result| == 0\n    ensures !HasEvenValue(arr) ==> |result| == 0\n    ensures HasEvenValue(arr) ==> |result| == 2\n    ensures |result| == 2 ==> 0 <= result[1] < |arr|\n    ensures |result| == 2 ==> arr[result[1]] == result[0]\n    ensures |result| == 2 ==> result[0] % 2 == 0\n    ensures |result| == 2 ==> forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 ==> result[0] <= arr[i]\n    ensures |result| == 2 ==> forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 && arr[i] == result[0] ==> result[1] <= i", "vc-code": "{\n    if |arr| == 0 {\n        return [];\n    }\n\n    var smallest_even: int := -1;\n    var smallest_index: int := -1;\n    var found_even := false;\n\n    for i := 0 to |arr|\n        invariant found_even ==> 0 <= smallest_index < |arr|\n        invariant found_even ==> arr[smallest_index] == smallest_even\n        invariant found_even ==> smallest_even % 2 == 0\n        invariant found_even ==> forall j :: 0 <= j < i && arr[j] % 2 == 0 ==> smallest_even <= arr[j]\n        invariant found_even ==> forall j :: 0 <= j < i && arr[j] % 2 == 0 && arr[j] == smallest_even ==> smallest_index <= j\n        invariant !found_even ==> forall j :: 0 <= j < i ==> arr[j] % 2 != 0\n        invariant found_even <==> exists j :: 0 <= j < i && arr[j] % 2 == 0\n    {\n        if arr[i] % 2 == 0 {\n            if !found_even || arr[i] < smallest_even {\n                smallest_even := arr[i];\n                smallest_index := i;\n                found_even := true;\n            } else if arr[i] == smallest_even && i < smallest_index {\n                smallest_index := i;\n            }\n        }\n    }\n\n    if !found_even {\n        return [];\n    }\n\n    return [smallest_even, smallest_index];\n}", "vc-postamble": ""}
{"id": "HumanEval_67", "vc-description": "Given a string containing quantities of apples and oranges and the total number of fruits, calculate the number of mangoes. The basket contains only apples, oranges, and mangoes. The implementation must extract numbers from the input string, sum them up, and subtract from the total to find the number of mangoes.", "vc-preamble": "// ======= TASK =======\n// Given a string containing quantities of apples and oranges and the total number of fruits,\n// calculate the number of mangoes. The basket contains only apples, oranges, and mangoes.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int) {\n    n >= 0\n}\n\nfunction sum_of_numbers_in_string(s: string): int\n{\n    var numbers := extract_numbers_from_string(s);\n    sum_sequence(numbers)\n}\n\nfunction extract_numbers_from_string(s: string): seq<int>\n{\n    extract_numbers_helper(s, 0, 0, false, [])\n}\n\nfunction sum_sequence(numbers: seq<int>): int\n{\n    if |numbers| == 0 then 0\n    else numbers[0] + sum_sequence(numbers[1..])\n}", "vc-helpers": "// ======= HELPERS =======\nfunction extract_numbers_helper(s: string, i: int, current_number: int, in_number: bool, numbers: seq<int>): seq<int>\n    decreases |s| - i\n    requires 0 <= i <= |s|\n    requires current_number >= 0\n{\n    if i == |s| then\n        if in_number then numbers + [current_number] else numbers\n    else\n        var c := s[i];\n        if '0' <= c <= '9' then\n            var digit := c as int - '0' as int;\n            extract_numbers_helper(s, i + 1, current_number * 10 + digit, true, numbers)\n        else\n            if in_number then\n                extract_numbers_helper(s, i + 1, 0, false, numbers + [current_number])\n            else\n                extract_numbers_helper(s, i + 1, 0, false, numbers)\n}\n\nmethod extract_numbers_from_string_imperative(s: string) returns (numbers: seq<int>)\n    ensures numbers == extract_numbers_from_string(s)\n{\n    numbers := [];\n    var current_number := 0;\n    var in_number := false;\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant current_number >= 0\n        invariant !in_number ==> current_number == 0\n        invariant extract_numbers_helper(s, i, current_number, in_number, numbers) == extract_numbers_from_string(s)\n    {\n        var c := s[i];\n        if '0' <= c <= '9' {\n            var digit := c as int - '0' as int;\n            current_number := current_number * 10 + digit;\n            in_number := true;\n        } else {\n            if in_number {\n                numbers := numbers + [current_number];\n                current_number := 0;\n                in_number := false;\n            }\n        }\n        i := i + 1;\n    }\n\n    if in_number {\n        numbers := numbers + [current_number];\n    }\n\n    assert numbers == extract_numbers_from_string(s);\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod fruit_distribution(s: string, n: int) returns (mangoes: int)\n    requires ValidInput(n)\n    ensures mangoes == n - sum_of_numbers_in_string(s)\n    ensures mangoes >= 0 <==> n >= sum_of_numbers_in_string(s)", "vc-code": "{\n    var numbers := extract_numbers_from_string_imperative(s);\n    var total_apples_oranges := sum_sequence(numbers);\n    assert numbers == extract_numbers_from_string(s);\n    assert total_apples_oranges == sum_of_numbers_in_string(s);\n    mangoes := n - total_apples_oranges;\n}", "vc-postamble": ""}
{"id": "HumanEval_108", "vc-description": "Given an array of integers, count how many elements have a positive sum of digits. For digit sum calculation: positive numbers sum all digits normally, negative numbers have the first digit as negative and remaining digits as positive, and zero has digit sum 0. Return the count of numbers whose digit sum is greater than 0.", "vc-preamble": "// ======= TASK =======\n// Given an array of integers, count how many elements have a positive sum of digits.\n// For digit sum calculation:\n// - Positive numbers: sum all digits normally\n// - Negative numbers: the first digit is negative, remaining digits are positive\n// - Zero: digit sum is 0\n// Return the count of numbers whose digit sum is greater than 0.\n\n// ======= SPEC REQUIREMENTS =======\nfunction digitSumFunc(n: int): int\n{\n    if n == 0 then 0\n    else if n > 0 then sumOfDigitsPos(n)\n    else sumOfDigitsPos(-n) - 2 * firstDigit(-n)\n}\n\nfunction sumOfDigitsPos(n: nat): nat\n    requires n >= 0\n    ensures n > 0 ==> sumOfDigitsPos(n) > 0\n{\n    if n == 0 then 0\n    else (n % 10) + sumOfDigitsPos(n / 10)\n}\n\nfunction firstDigit(n: nat): nat\n    requires n > 0\n{\n    if n < 10 then n\n    else firstDigit(n / 10)\n}\n\npredicate ValidInput(arr: seq<int>)\n{\n    true\n}\n\npredicate ValidOutput(arr: seq<int>, count: int)\n{\n    0 <= count <= |arr| && count == |set i | 0 <= i < |arr| && digitSumFunc(arr[i]) > 0|\n}", "vc-helpers": "// ======= HELPERS =======\nmethod digitSum(n: int) returns (result: int)\n    ensures result == digitSumFunc(n)\n    ensures n == 0 ==> result == 0\n    ensures n > 0 ==> result > 0\n{\n    if n == 0 {\n        result := 0;\n    } else if n > 0 {\n        var abs_n := n;\n        var sum := 0;\n        while abs_n > 0 \n            invariant abs_n >= 0\n            invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(n)\n        {\n            sum := sum + (abs_n % 10);\n            abs_n := abs_n / 10;\n        }\n        result := sum;\n    } else {\n        var abs_n := -n;\n        var sum := 0;\n        var first_digit := 0;\n        var temp := abs_n;\n\n        // Get first digit\n        while temp >= 10\n            invariant temp > 0\n            invariant firstDigit(temp) == firstDigit(abs_n)\n        {\n            temp := temp / 10;\n        }\n        first_digit := temp;\n\n        // Sum all digits\n        while abs_n > 0 \n            invariant abs_n >= 0\n            invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(-n)\n        {\n            sum := sum + (abs_n % 10);\n            abs_n := abs_n / 10;\n        }\n        result := sum - 2 * first_digit;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod count_nums(arr: seq<int>) returns (count: int)\n    requires ValidInput(arr)\n    ensures ValidOutput(arr, count)", "vc-code": "{\n    count := 0;\n    var i := 0;\n    while i < |arr|\n        invariant 0 <= i <= |arr|\n        invariant 0 <= count <= i\n        invariant count == |set j | 0 <= j < i && digitSumFunc(arr[j]) > 0|\n    {\n        var ds := digitSum(arr[i]);\n        assert ds == digitSumFunc(arr[i]);\n\n        var old_set := set j | 0 <= j < i && digitSumFunc(arr[j]) > 0;\n        var new_set := set j | 0 <= j < i + 1 && digitSumFunc(arr[j]) > 0;\n\n        if ds > 0 {\n            assert digitSumFunc(arr[i]) > 0;\n            assert new_set == old_set + {i};\n            assert |new_set| == |old_set| + 1;\n            count := count + 1;\n        } else {\n            assert digitSumFunc(arr[i]) <= 0;\n            assert i !in old_set;\n            assert new_set == old_set;\n            assert |new_set| == |old_set|;\n        }\n\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_54", "vc-description": "This task involves determining if two strings contain exactly the same set of unique characters, regardless of character frequency or order. The implementation should compare the set of characters in each string and return true if they are identical sets.", "vc-preamble": "// ======= TASK =======\n// Given two strings, determine if they contain exactly the same set of unique characters, \n// regardless of character frequency or order.\n\n// ======= SPEC REQUIREMENTS =======\nfunction CharSet(s: string): set<char>\n{\n    set c | c in s\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod same_chars(s0: string, s1: string) returns (result: bool)\n    ensures result == (CharSet(s0) == CharSet(s1))", "vc-code": "{\n    var set0 := set c | c in s0;\n    var set1 := set c | c in s1;\n    result := set0 == set1;\n}", "vc-postamble": ""}
{"id": "HumanEval_113", "vc-description": "Given a list of strings containing only digits, count the odd digits (1,3,5,7,9) in each string and return formatted messages where the count is embedded in a template message. The task involves string processing, digit counting, and message formatting with proper verification of loop invariants and postconditions.", "vc-preamble": "// ======= TASK =======\n// Given a list of strings containing only digits, count the odd digits (1,3,5,7,9) in each string\n// and return formatted messages where 'i' in the template \"the number of odd elements in the string i of the input.\"\n// is replaced with the count of odd digits.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_all_digits(s: string)\n{\n  forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction count_odd_digits(s: string): int\n  requires is_all_digits(s)\n  ensures count_odd_digits(s) >= 0\n  ensures count_odd_digits(s) <= |s|\n{\n    if |s| == 0 then 0\n    else\n        var digit := s[0] as int - '0' as int;\n        var is_odd := if digit % 2 == 1 then 1 else 0;\n        is_odd + count_odd_digits(s[1..])\n}\n\nfunction int_to_string_func(n: int): string\n  requires n >= 0\n{\n  if n == 0 then \"0\"\n  else int_to_string_rec(n, \"\")\n}\n\nfunction format_message(count: int): string\n  requires count >= 0\n{\n  var count_str := int_to_string_func(count);\n  \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n}", "vc-helpers": "// ======= HELPERS =======\nfunction int_to_string_rec(n: int, acc: string): string\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then acc\n  else\n    var digit := n % 10;\n    var digit_char := ('0' as int + digit) as char;\n    int_to_string_rec(n / 10, [digit_char] + acc)\n}\n\nmethod int_to_string(n: int) returns (s: string)\n  requires n >= 0\n  ensures s == int_to_string_func(n)\n{\n    if n == 0 {\n        s := \"0\";\n    } else {\n        s := \"\";\n        var temp := n;\n        while temp > 0\n          decreases temp\n          invariant temp >= 0\n          invariant int_to_string_rec(temp, s) == int_to_string_rec(n, \"\")\n        {\n            var digit := temp % 10;\n            var digit_char := ('0' as int + digit) as char;\n            s := [digit_char] + s;\n            temp := temp / 10;\n        }\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod odd_count(lst: seq<string>) returns (result: seq<string>)\n  requires forall i :: 0 <= i < |lst| ==> is_all_digits(lst[i])\n  ensures |result| == |lst|\n  ensures forall i :: 0 <= i < |lst| ==> \n    result[i] == format_message(count_odd_digits(lst[i]))", "vc-code": "{\n    result := [];\n    for i := 0 to |lst|\n      invariant 0 <= i <= |lst|\n      invariant |result| == i\n      invariant forall j :: 0 <= j < i ==> result[j] == format_message(count_odd_digits(lst[j]))\n    {\n        var count := count_odd_digits(lst[i]);\n        var count_str := int_to_string(count);\n        var message := \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\";\n        result := result + [message];\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_23", "vc-description": "Implement a function that returns the length of a given string. The function should handle empty strings and return 0 for them. For non-empty strings, it should return the count of characters.", "vc-preamble": "// ======= TASK =======\n// Implement a function that returns the length of a given string.\n// The function should handle empty strings and return 0 for them.\n// For non-empty strings, it should return the count of characters.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(s: string)\n{\n    true\n}\n\nfunction CorrectLength(s: string): int\n{\n    |s|\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nfunction strlen(s: string): int\n    requires ValidInput(s)\n    ensures strlen(s) >= 0\n    ensures strlen(s) == CorrectLength(s)", "vc-code": "{\n    |s|\n}", "vc-postamble": ""}
{"id": "HumanEval_56", "vc-description": "This verification task implements a bracket matching algorithm that determines if a string containing only \"<\" and \">\" characters has properly nested brackets. Every opening bracket \"<\" must have a corresponding closing bracket \">\" and they must be correctly nested, meaning at no point should the number of closing brackets exceed the number of opening brackets in any prefix.", "vc-preamble": "// ======= TASK =======\n// Given a string containing only \"<\" and \">\" characters, determine if every opening bracket \"<\" \n// has a corresponding closing bracket \">\" and they are properly nested.\n\n// ======= SPEC REQUIREMENTS =======\nfunction count_brackets_prefix(s: string, end: int, bracket: char): int\n    requires 0 <= end <= |s|\n    requires bracket == '<' || bracket == '>'\n{\n    if end == 0 then 0\n    else if s[end-1] == bracket then 1 + count_brackets_prefix(s, end-1, bracket)\n    else count_brackets_prefix(s, end-1, bracket)\n}\n\npredicate ValidBracketString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '<' || s[i] == '>'\n}\n\npredicate ProperlyNested(brackets: string)\n    requires ValidBracketString(brackets)\n{\n    // At every prefix, opening brackets >= closing brackets\n    (forall k :: 0 <= k <= |brackets| ==> \n        count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>')) &&\n    // Total opening brackets == total closing brackets\n    count_brackets_prefix(brackets, |brackets|, '<') == count_brackets_prefix(brackets, |brackets|, '>')\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod correct_bracketing(brackets: string) returns (result: bool)\n    requires ValidBracketString(brackets)\n    ensures result <==> ProperlyNested(brackets)", "vc-code": "{\n    var counter := 0;\n    var i := 0;\n\n    while i < |brackets|\n        invariant 0 <= i <= |brackets|\n        invariant counter == count_brackets_prefix(brackets, i, '<') - count_brackets_prefix(brackets, i, '>')\n        invariant forall k :: 0 <= k <= i ==> count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>')\n    {\n        if brackets[i] == '<' {\n            counter := counter + 1;\n        } else if brackets[i] == '>' {\n            counter := counter - 1;\n            if counter < 0 {\n                assert count_brackets_prefix(brackets, i+1, '<') < count_brackets_prefix(brackets, i+1, '>');\n                assert !(forall k :: 0 <= k <= |brackets| ==> count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>'));\n                result := false;\n                return;\n            }\n        }\n        i := i + 1;\n    }\n\n    result := counter == 0;\n}", "vc-postamble": ""}
{"id": "HumanEval_152", "vc-description": "This verification task involves implementing a function that compares two arrays of equal length representing actual game scores and guessed scores. The implementation should calculate how far off each guess was from the actual result by computing the absolute difference between corresponding elements.", "vc-preamble": "// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(game: seq<int>, guess: seq<int>)\n{\n  |game| == |guess|\n}\n\npredicate ValidOutput(game: seq<int>, guess: seq<int>, result: seq<int>)\n  requires |game| == |guess|\n{\n  && |result| == |game|\n  && (forall i :: 0 <= i < |game| ==> result[i] == abs(game[i] - guess[i]))\n  && (forall i :: 0 <= i < |result| ==> result[i] >= 0)\n}", "vc-helpers": "// ======= HELPERS =======\nfunction abs(x: int): int\n{\n  if x >= 0 then x else -x\n}", "vc-spec": "// ======= MAIN METHOD =======\nfunction compare(game: seq<int>, guess: seq<int>): seq<int>\n  requires ValidInput(game, guess)\n  ensures ValidOutput(game, guess, compare(game, guess))", "vc-code": "{\n  seq(|game|, i requires 0 <= i < |game| => \n    var diff := game[i] - guess[i];\n    if diff >= 0 then diff else -diff\n  )\n}", "vc-postamble": ""}
{"id": "HumanEval_138", "vc-description": "This verification task determines whether a given positive integer n can be expressed as the sum of exactly 4 positive even numbers. The key insight is that the minimum sum is 8 (2+2+2+2), and only even numbers can be expressed this way since the sum of 4 even numbers is always even.", "vc-preamble": "// ======= TASK =======\n// Determine whether a given positive integer n can be expressed as the sum of exactly 4 positive even numbers.\n// The minimum sum is 8 (2+2+2+2), and only even numbers can be expressed this way.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int)\n{\n    n > 0\n}\n\npredicate CanBeSumOfFourPositiveEvens(n: int)\n{\n    n % 2 == 0 && n >= 8\n}\n\n// ======= HELPERS =======", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod is_equal_to_sum_even(n: int) returns (result: bool)\n    requires ValidInput(n)\n    ensures result == CanBeSumOfFourPositiveEvens(n)", "vc-code": "{\n    result := n % 2 == 0 && n >= 8;\n}", "vc-postamble": ""}
{"id": "HumanEval_55", "vc-description": "This task involves computing the n-th Fibonacci number using 1-based indexing, where fib(1) = 1 and fib(2) = 1. The implementation should efficiently calculate the result for positive integers n.\n\nThe solution uses an iterative approach with loop invariants to maintain correctness while avoiding the exponential time complexity of a naive recursive implementation.", "vc-preamble": "// ======= TASK =======\n// Compute the n-th Fibonacci number using 1-based indexing, where fib(1) = 1, fib(2) = 1.\n// Input: A positive integer n. Output: The n-th Fibonacci number.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int) {\n    n > 0\n}\n\nfunction fib_spec(n: int): int\n    requires n > 0\n{\n    if n == 1 then 1\n    else if n == 2 then 1\n    else fib_spec(n-1) + fib_spec(n-2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod fib(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == fib_spec(n)\n    ensures result > 0", "vc-code": "{\n    if n == 1 || n == 2 {\n        return 1;\n    }\n\n    var a := 1;\n    var b := 1;\n    var i := 3;\n\n    while i <= n\n        decreases n - i\n        invariant i >= 3 && i <= n + 1\n        invariant a == fib_spec(i-2)\n        invariant b == fib_spec(i-1)\n    {\n        var temp := a + b;\n        a := b;\n        b := temp;\n        i := i + 1;\n    }\n\n    return b;\n}", "vc-postamble": ""}
{"id": "HumanEval_147", "vc-description": "This verification task involves counting valid triples from a special array. Given a positive integer n, create an array where each element a[i] = i² - i + 1 for positions 1 to n. The goal is to count the number of triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3.\n\nThe implementation uses the mathematical insight that elements can be categorized by their modulo 3 value, and valid triples must either come from all elements with the same modulo value.", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, create an array a of length n where a[i] = i² - i + 1 \n// for each position i from 1 to n. Count the number of triples (a[i], a[j], a[k]) \n// where i < j < k and the sum a[i] + a[j] + a[k] is divisible by 3.\n\n// ======= SPEC REQUIREMENTS =======\nfunction array_element(i: int): int\n  requires i >= 1\n{\n  i * i - i + 1\n}\n\nfunction count_elements_mod_0(n: int): int\n  requires n >= 0\n  ensures count_elements_mod_0(n) >= 0\n{\n  if n == 0 then 0\n  else if n % 3 == 2 then 1 + count_elements_mod_0(n - 1)\n  else count_elements_mod_0(n - 1)\n}\n\nfunction count_elements_mod_1(n: int): int\n  requires n >= 0\n  ensures count_elements_mod_1(n) >= 0\n{\n  if n == 0 then 0\n  else if n % 3 != 2 then 1 + count_elements_mod_1(n - 1)\n  else count_elements_mod_1(n - 1)\n}\n\nfunction combination(n: int, k: int): int\n  requires n >= 0 && k >= 0\n  ensures combination(n, k) >= 0\n  ensures k > n ==> combination(n, k) == 0\n  ensures k == 0 || k == n ==> combination(n, k) == 1\n  ensures k == 1 ==> combination(n, k) == n\n  ensures k == 2 && n >= 2 ==> combination(n, k) == n * (n - 1) / 2\n  ensures k == 3 && n >= 3 ==> combination(n, k) == n * (n - 1) * (n - 2) / 6\n{\n  if k > n || k < 0 then 0\n  else if k == 0 || k == n then 1\n  else if k == 1 then n\n  else if k == 2 then n * (n - 1) / 2\n  else if k == 3 then n * (n - 1) * (n - 2) / 6\n  else 0\n}\n\nfunction count_valid_triples(n: int): int\n  requires n >= 1\n{\n  var count_0 := count_elements_mod_0(n);\n  var count_1 := count_elements_mod_1(n);\n  combination(count_0, 3) + combination(count_1, 3)\n}\n\npredicate ValidInput(n: int)\n{\n  n >= 1\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod get_max_triples(n: int) returns (result: int)\n  requires ValidInput(n)\n  ensures result >= 0\n  ensures result == count_valid_triples(n)", "vc-code": "{\n  var count_0 := 0;\n  var count_1 := 0;\n\n  var i := 1;\n  while i <= n\n    invariant 1 <= i <= n + 1\n    invariant count_0 >= 0 && count_1 >= 0\n    invariant count_0 + count_1 == i - 1\n    invariant count_0 == count_elements_mod_0(i - 1)\n    invariant count_1 == count_elements_mod_1(i - 1)\n  {\n    if i % 3 == 2 {\n      count_0 := count_0 + 1;\n    } else {\n      count_1 := count_1 + 1;\n    }\n    i := i + 1;\n  }\n\n  var triples_0 := combination(count_0, 3);\n  var triples_1 := combination(count_1, 3);\n\n  result := triples_0 + triples_1;\n}", "vc-postamble": ""}
{"id": "HumanEval_28", "vc-description": "This task involves implementing string concatenation. Given a sequence of strings, return a single string that is the concatenation of all strings in the list in order. The implementation should match the behavior of a recursive specification function.", "vc-preamble": "// ======= TASK =======\n// Given a list of strings, return a single string that is the concatenation \n// of all strings in the list in order.\n\n// ======= SPEC REQUIREMENTS =======\nfunction concat_strings(strings: seq<string>, index: nat): string\n    requires index <= |strings|\n    decreases |strings| - index\n{\n    if index == |strings| then \"\"\n    else strings[index] + concat_strings(strings, index + 1)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod concatenate(strings: seq<string>) returns (result: string)\n    ensures result == concat_strings(strings, 0)\n    ensures |strings| == 0 ==> result == \"\"", "vc-code": "{\n    result := \"\";\n    for i := 0 to |strings|\n        invariant result + concat_strings(strings, i) == concat_strings(strings, 0)\n    {\n        result := result + strings[i];\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_31", "vc-description": "This verification task involves implementing a method to determine if a positive integer is a prime number. A prime number is defined as a natural number greater than 1 that has exactly two distinct positive divisors: 1 and itself.\n\nThe implementation should efficiently check for primality by testing divisibility up to the square root of the input number, with optimizations for even numbers.", "vc-preamble": "// ======= TASK =======\n// Given a positive integer n, determine if it is a prime number. A prime number \n// is a natural number greater than 1 that has exactly two distinct positive divisors: 1 and itself.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_prime_number(n: int)\n{\n    n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod is_prime(n: int) returns (result: bool)\n    ensures result <==> is_prime_number(n)", "vc-code": "{\n    // Numbers less than 2 are not prime\n    if n < 2 {\n        return false;\n    }\n\n    // 2 is the only even prime number\n    if n == 2 {\n        return true;\n    }\n\n    // All other even numbers are not prime\n    if n % 2 == 0 {\n        return false;\n    }\n\n    // Check odd divisors from 3 up to sqrt(n)\n    var i := 3;\n    while i * i <= n\n        invariant i >= 3 && i % 2 == 1\n        invariant forall k :: 2 <= k < i ==> n % k != 0\n        invariant n >= 2 && n % 2 != 0\n    {\n        if n % i == 0 {\n            return false;\n        }\n        i := i + 2;\n    }\n\n    // At this point, we know n has no divisors from 2 to i-1\n    // and i * i > n, so any divisor >= i would have a corresponding divisor < i\n    return true;\n}", "vc-postamble": ""}
{"id": "HumanEval_91", "vc-description": "This verification task involves implementing a method to count the number of sentences that start with the word \"I\". Sentences are separated by '.', '?' or '!' characters. The implementation should parse the input string into sentences, trim whitespace from each sentence, extract the first word, and check if it equals \"I\".\n\nThe expected implementation should use the provided helper functions to split sentences, trim whitespace, and count sentences starting with \"I\", ensuring the result matches the functional specification.", "vc-preamble": "// ======= TASK =======\n// Given a string, count the number of sentences that start with the word \"I\". \n// Sentences are separated by '.', '?' or '!'.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(s: string) { true }\n\nfunction starts_with_I(s: string): bool\n{\n    var trimmed := trim(s);\n    if |trimmed| == 0 then false\n    else\n        var first_word := get_first_word(trimmed);\n        first_word == \"I\"\n}\n\nfunction get_first_word(s: string): string\n    requires |s| > 0\n    decreases |s|\n{\n    get_first_word_helper(s, 0)\n}\n\nfunction split_sentences(S: string): seq<string>\n    ensures forall i :: 0 <= i < |split_sentences(S)| ==> |split_sentences(S)[i]| >= 0\n{\n    if |S| == 0 then []\n    else\n        var sentences := [];\n        var current := \"\";\n        var i := 0;\n        split_sentences_helper(S, i, current, sentences)\n}\n\nfunction count_sentences_starting_with_I(S: string): int\n    ensures count_sentences_starting_with_I(S) >= 0\n    ensures S == \"\" ==> count_sentences_starting_with_I(S) == 0\n    ensures count_sentences_starting_with_I(S) <= |split_sentences(S)|\n{\n    var sentences := split_sentences(S);\n    count_bored_sentences(sentences)\n}\n\n// ======= HELPERS =======\nfunction get_first_word_helper(s: string, i: int): string\n    requires 0 <= i <= |s|\n    requires |s| > 0\n    decreases |s| - i\n{\n    if i == |s| || s[i] == ' ' then s[0..i]\n    else get_first_word_helper(s, i + 1)\n}\n\nfunction split_sentences_helper(S: string, i: int, current: string, sentences: seq<string>): seq<string>\n    requires 0 <= i <= |S|\n    ensures forall j :: 0 <= j < |split_sentences_helper(S, i, current, sentences)| ==> |split_sentences_helper(S, i, current, sentences)[j]| >= 0\n    decreases |S| - i\n{\n    if i == |S| then\n        if |current| > 0 then sentences + [current] else sentences\n    else if S[i] == '.' || S[i] == '?' || S[i] == '!' then\n        var new_sentences := if |current| > 0 then sentences + [current] else sentences;\n        split_sentences_helper(S, i + 1, \"\", new_sentences)\n    else\n        split_sentences_helper(S, i + 1, current + [S[i]], sentences)\n}\n\nfunction trim(s: string): string\n    ensures |trim(s)| <= |s|\n{\n    trim_left(trim_right(s))\n}\n\nfunction trim_left(s: string): string\n    ensures |trim_left(s)| <= |s|\n    decreases |s|\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' then trim_left(s[1..])\n    else s\n}\n\nfunction trim_right(s: string): string\n    ensures |trim_right(s)| <= |s|\n    decreases |s|\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == ' ' then trim_right(s[..|s|-1])\n    else s\n}\n\nfunction count_bored_sentences(sentences: seq<string>): int\n    requires forall i :: 0 <= i < |sentences| ==> |sentences[i]| >= 0\n    ensures count_bored_sentences(sentences) >= 0\n    ensures count_bored_sentences(sentences) <= |sentences|\n    ensures count_bored_sentences(sentences) == |set i | 0 <= i < |sentences| && starts_with_I(sentences[i])|\n    decreases |sentences|\n{\n    if |sentences| == 0 then 0\n    else\n        var count := if starts_with_I(sentences[0]) then 1 else 0;\n        var rest_count := count_bored_sentences(sentences[1..]);\n\n        var full_set := set i | 0 <= i < |sentences| && starts_with_I(sentences[i]);\n        var first_set := if starts_with_I(sentences[0]) then {0} else {};\n        var rest_set := set i | 1 <= i < |sentences| && starts_with_I(sentences[i]);\n        var tail_set := set j | 0 <= j < |sentences[1..]| && starts_with_I(sentences[1..][j]);\n\n        assert full_set == first_set + rest_set;\n        assert forall j :: 0 <= j < |sentences[1..]| ==> sentences[1..][j] == sentences[j+1];\n        assert forall i :: i in rest_set ==> (i-1) in tail_set;\n        assert forall j :: j in tail_set ==> (j+1) in rest_set;\n\n        var f := map i | i in rest_set :: i-1;\n        var g := map j | j in tail_set :: j+1;\n        assert forall i :: i in rest_set ==> f[i] in tail_set;\n        assert forall j :: j in tail_set ==> g[j] in rest_set;\n        assert forall i :: i in rest_set ==> g[f[i]] == i;\n        assert forall j :: j in tail_set ==> f[g[j]] == j;\n\n        assert |rest_set| == |tail_set|;\n        assert |full_set| == |first_set| + |tail_set|;\n\n        count + rest_count\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod CountSentencesStartingWithI(S: string) returns (count: int)\n    requires ValidInput(S)\n    ensures count >= 0\n    ensures S == \"\" ==> count == 0\n    ensures count <= |split_sentences(S)|\n    ensures count == count_sentences_starting_with_I(S)\n    ensures count == |set i | 0 <= i < |split_sentences(S)| && starts_with_I(split_sentences(S)[i])|", "vc-code": "{\n    count := count_sentences_starting_with_I(S);\n}", "vc-postamble": ""}
{"id": "HumanEval_69", "vc-description": "This verification task involves finding the greatest integer in a list whose frequency is greater than or equal to its own value. Given a non-empty list of positive integers, the implementation should return this greatest qualifying integer, or -1 if no such integer exists.\n\nThe task requires building a frequency map for all elements in the list, then identifying which elements have frequencies meeting the criteria, and finally selecting the maximum among those valid elements.", "vc-preamble": "// ======= TASK =======\n// Given a non-empty list of positive integers, find the greatest integer whose frequency \n// in the list is greater than or equal to its own value. If no such integer exists, return -1.\n\n// ======= SPEC REQUIREMENTS =======\nfunction count(s: seq<int>, x: int): int\n{\n    |set i | 0 <= i < |s| && s[i] == x|\n}\n\nfunction max_seq(s: seq<int>): int\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> s[i] <= max_seq(s)\n    ensures max_seq(s) in s\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= max_seq(s[1..]) then s[0]\n    else max_seq(s[1..])\n}\n\npredicate ValidInput(lst: seq<int>)\n{\n    |lst| > 0 && forall i :: 0 <= i < |lst| ==> lst[i] > 0\n}\n\npredicate ValidResult(lst: seq<int>, result: int)\n    requires ValidInput(lst)\n{\n    var frequency := map x | x in lst :: x := count(lst, x);\n    if result == -1 then\n        forall x :: x in frequency ==> frequency[x] < x\n    else\n        result > 0 &&\n        result in frequency && \n        frequency[result] >= result &&\n        forall y :: y in frequency && frequency[y] >= y ==> y <= result\n}", "vc-helpers": "// ======= HELPERS =======\nlemma count_append_lemma(s: seq<int>, elem: int, x: int)\n    ensures count(s + [elem], x) == count(s, x) + (if x == elem then 1 else 0)\n{\n    var s' := s + [elem];\n    var original_indices := set i | 0 <= i < |s| && s[i] == x;\n    var new_indices := set i | 0 <= i < |s'| && s'[i] == x;\n\n    assert forall i :: 0 <= i < |s| ==> s'[i] == s[i];\n    assert original_indices == set i | 0 <= i < |s| && s'[i] == x;\n\n    if x == elem {\n        assert s'[|s|] == elem == x;\n        assert new_indices == original_indices + {|s|};\n        assert |s| !in original_indices;\n        assert |new_indices| == |original_indices| + 1;\n    } else {\n        assert s'[|s|] == elem != x;\n        assert new_indices == original_indices;\n        assert |new_indices| == |original_indices|;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod search(lst: seq<int>) returns (result: int)\n    requires ValidInput(lst)\n    ensures ValidResult(lst, result)", "vc-code": "{\n    var frequency: map<int, int> := map[];\n    var i := 0;\n    while i < |lst|\n        invariant 0 <= i <= |lst|\n        invariant forall x :: x in frequency <==> x in lst[..i]\n        invariant forall x :: x in frequency ==> frequency[x] == count(lst[..i], x)\n        invariant forall x :: x in frequency ==> frequency[x] > 0\n    {\n        var num := lst[i];\n\n        assert lst[..i+1] == lst[..i] + [num];\n        count_append_lemma(lst[..i], num, num);\n        assert count(lst[..i+1], num) == count(lst[..i], num) + 1;\n        forall x | x != num \n            ensures count(lst[..i+1], x) == count(lst[..i], x)\n        {\n            count_append_lemma(lst[..i], num, x);\n        }\n\n        if num in frequency {\n            frequency := frequency[num := frequency[num] + 1];\n        } else {\n            frequency := frequency[num := 1];\n            assert count(lst[..i], num) == 0;\n        }\n        i := i + 1;\n    }\n\n    assert lst[..|lst|] == lst;\n    assert forall x :: x in frequency <==> x in lst;\n    assert forall x :: x in frequency ==> frequency[x] == count(lst, x);\n\n    var validNumbers: seq<int> := [];\n    var keys := frequency.Keys;\n\n    while keys != {}\n        invariant forall x :: x in validNumbers ==> x in frequency && frequency[x] >= x\n        invariant forall x :: x in frequency && frequency[x] >= x && x !in keys ==> x in validNumbers\n        invariant forall x :: x in validNumbers ==> x > 0\n        invariant keys <= frequency.Keys\n        decreases |keys|\n    {\n        var num :| num in keys;\n        keys := keys - {num};\n        assert num in frequency;\n\n        if frequency[num] >= num {\n            validNumbers := validNumbers + [num];\n        }\n    }\n\n    assert forall x :: x in validNumbers <==> (x in frequency && frequency[x] >= x);\n\n    if |validNumbers| > 0 {\n        result := max_seq(validNumbers);\n        assert result in validNumbers;\n        assert result in frequency && frequency[result] >= result;\n        assert forall y :: y in frequency && frequency[y] >= y ==> y <= result;\n    } else {\n        result := -1;\n        assert forall x :: x in frequency ==> frequency[x] < x;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_92", "vc-description": "This verification task involves implementing a function that checks if three real numbers satisfy two conditions: all three must be integers, and one of the numbers must equal the sum of the other two. The function should return true only if both conditions are met, false otherwise.", "vc-preamble": "// ======= TASK =======\n// Given three real numbers, return True if all three are integers and one number \n// equals the sum of the other two. Otherwise, return False.\n\n// ======= SPEC REQUIREMENTS =======\npredicate IsInteger(x: real)\n{\n    x == x.Floor as real\n}\n\npredicate AllIntegers(x: real, y: real, z: real)\n{\n    IsInteger(x) && IsInteger(y) && IsInteger(z)\n}\n\npredicate OneEqualsSumOfOtherTwo(x: real, y: real, z: real)\n{\n    x == y + z || y == x + z || z == x + y\n}\n\npredicate ValidResult(x: real, y: real, z: real, result: bool)\n{\n    result <==> (AllIntegers(x, y, z) && OneEqualsSumOfOtherTwo(x, y, z))\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod any_int(x: real, y: real, z: real) returns (result: bool)\n    ensures ValidResult(x, y, z, result)", "vc-code": "{\n    var xIsInt := IsInteger(x);\n    var yIsInt := IsInteger(y);\n    var zIsInt := IsInteger(z);\n\n    if xIsInt && yIsInt && zIsInt {\n        result := OneEqualsSumOfOtherTwo(x, y, z);\n    } else {\n        result := false;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_110", "vc-description": "This task involves determining if it's possible to exchange elements between two non-empty lists of integers such that the first list contains only even numbers. The method should return \"YES\" if such an exchange is possible, \"NO\" otherwise.\n\nThe key insight is that we need at least as many even numbers across both lists as the length of the first list to make the first list contain only even numbers.", "vc-preamble": "// ======= TASK =======\n// Given two non-empty lists of numbers, determine if it's possible to exchange\n// elements between them such that the first list contains only even numbers.\n// Return \"YES\" if possible, \"NO\" otherwise.\n\n// ======= SPEC REQUIREMENTS =======\nfunction countEven(lst: seq<int>): int\n    ensures countEven(lst) >= 0\n    ensures countEven(lst) <= |lst|\n{\n    if |lst| == 0 then 0\n    else if lst[0] % 2 == 0 then 1 + countEven(lst[1..])\n    else countEven(lst[1..])\n}\n\npredicate ValidInput(lst1: seq<int>, lst2: seq<int>)\n{\n    |lst1| > 0 && |lst2| > 0\n}\n\npredicate CanExchange(lst1: seq<int>, lst2: seq<int>)\n{\n    countEven(lst1) + countEven(lst2) >= |lst1|\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod exchange(lst1: seq<int>, lst2: seq<int>) returns (result: string)\n    requires ValidInput(lst1, lst2)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanExchange(lst1, lst2)", "vc-code": "{\n    var tmpCall1 := countEven(lst1);\n    var tmpCall2 := countEven(lst2);\n    var totalEven := tmpCall1 + tmpCall2;\n    if totalEven >= |lst1| {\n        result := \"YES\";\n    } else {\n        result := \"NO\";\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_49", "vc-description": "This verification task involves implementing efficient modular exponentiation to compute 2^n mod p. The method should use binary exponentiation (repeated squaring) for optimal O(log n) time complexity, maintaining appropriate loop invariants to prove correctness.", "vc-preamble": "// ======= TASK =======\n// Compute 2^n modulo p using efficient modular exponentiation.\n// Input: n (non-negative integer exponent), p (positive integer modulus)\n// Output: Integer result of 2^n mod p\n\n// ======= SPEC REQUIREMENTS =======\nfunction power(base: int, exp: nat): int\n{\n    if exp == 0 then 1\n    else base * power(base, exp - 1)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod modp(n: int, p: int) returns (result: int)\n    requires n >= 0 && p > 0\n    ensures result >= 0 && result < p\n    ensures result == power(2, n) % p", "vc-code": "{\n    if n == 0 {\n        return 1 % p;\n    }\n\n    var base := 2 % p;\n    var exp := n;\n    result := 1 % p;\n\n    while exp > 0 \n        invariant result >= 0 && base >= 0\n        invariant result < p && base < p\n        invariant exp >= 0\n        invariant (result * power(base, exp)) % p == power(2, n) % p\n    {\n        if exp % 2 == 1 {\n            result := (result * base) % p;\n        }\n        base := (base * base) % p;\n        exp := exp / 2;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_137", "vc-description": "This verification task implements a function that compares two values of different types (integers, reals, or strings representing real numbers) and returns the larger one in its original format. If the values are numerically equal, the function returns None. The challenge is handling different value types while maintaining their original representation in the result.", "vc-preamble": "// ======= TASK =======\n// Create a function that compares two values and returns the larger one in its original format.\n// Values can be integers, reals, or strings representing real numbers (with '.' or ',' as decimal separators).\n// Return None if the values are numerically equal.\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Value = Int(i: int) | Real(r: real) | Str(s: string)\n\ndatatype Option<T> = None | Some(value: T)\n\npredicate IsValidNumericString(s: string)\n{\n    true\n}\n\nfunction ValueToReal(v: Value): real\n    requires v.Str? ==> IsValidNumericString(v.s)\n{\n    match v {\n        case Int(i) => i as real\n        case Real(r) => r\n        case Str(s) => StringToReal(s)\n    }\n}\n\nfunction StringToReal(s: string): real\n    requires IsValidNumericString(s)\n{\n    0.0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "method compare_one(a: Value, b: Value) returns (result: Option<Value>)\n    requires (a.Str? ==> IsValidNumericString(a.s))\n    requires (b.Str? ==> IsValidNumericString(b.s))\n    ensures ValueToReal(a) == ValueToReal(b) <==> result == None\n    ensures ValueToReal(a) > ValueToReal(b) <==> result == Some(a)\n    ensures ValueToReal(b) > ValueToReal(a) <==> result == Some(b)\n    ensures result.Some? ==> (result.value == a || result.value == b)", "vc-code": "{\n    var num_a := ValueToReal(a);\n    var num_b := ValueToReal(b);\n\n    if num_a == num_b {\n        result := None;\n    } else if num_a > num_b {\n        result := Some(a);\n    } else {\n        result := Some(b);\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_146", "vc-description": "Count the numbers in an array that satisfy all three conditions: 1) Greater than 10, 2) First digit is odd (1, 3, 5, 7, 9), and 3) Last digit is odd (1, 3, 5, 7, 9).", "vc-preamble": "// ======= TASK =======\n// Count the numbers in an array that satisfy all three conditions:\n// 1. Greater than 10\n// 2. First digit is odd (1, 3, 5, 7, 9)\n// 3. Last digit is odd (1, 3, 5, 7, 9)\n\n// ======= SPEC REQUIREMENTS =======\nfunction FirstDigit(n: int): int\n  requires n > 0\n{\n  if n < 10 then n else FirstDigit(n / 10)\n}\n\nfunction LastDigit(n: int): int\n  requires n > 0\n{\n  n % 10\n}\n\nfunction IsOdd(n: int): bool\n{\n  n == 1 || n == 3 || n == 5 || n == 7 || n == 9\n}\n\npredicate SatisfiesCondition(n: int)\n{\n  n > 10 && IsOdd(FirstDigit(n)) && IsOdd(LastDigit(n))\n}\n\npredicate ValidInput(nums: seq<int>)\n{\n  true\n}", "vc-helpers": "// ======= HELPERS =======\nfunction CountHelper(nums: seq<int>, index: int): int\n  requires 0 <= index <= |nums|\n  decreases |nums| - index\n  ensures CountHelper(nums, index) >= 0\n  ensures CountHelper(nums, index) <= |nums| - index\n{\n  if index == |nums| then 0\n  else\n    var current := nums[index];\n    var contribution := if SatisfiesCondition(current) then 1 else 0;\n    contribution + CountHelper(nums, index + 1)\n}\n\nlemma CountHelperCorrectness(nums: seq<int>, index: int)\n  requires 0 <= index <= |nums|\n  ensures CountHelper(nums, index) == |set i | index <= i < |nums| && SatisfiesCondition(nums[i])|\n  decreases |nums| - index\n{\n  if index == |nums| {\n    assert (set i | index <= i < |nums| && SatisfiesCondition(nums[i])) == {};\n  } else {\n    CountHelperCorrectness(nums, index + 1);\n    var setWithIndex := set i | index <= i < |nums| && SatisfiesCondition(nums[i]);\n    var setWithoutIndex := set i | index + 1 <= i < |nums| && SatisfiesCondition(nums[i]);\n\n    if SatisfiesCondition(nums[index]) {\n      assert setWithIndex == {index} + setWithoutIndex;\n      assert index !in setWithoutIndex;\n      assert |setWithIndex| == 1 + |setWithoutIndex|;\n    } else {\n      assert setWithIndex == setWithoutIndex;\n    }\n  }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod SpecialFilter(nums: seq<int>) returns (count: int)\n  requires ValidInput(nums)\n  ensures count >= 0\n  ensures count <= |nums|\n  ensures count == |set i | 0 <= i < |nums| && SatisfiesCondition(nums[i])|\n  ensures nums == [] ==> count == 0\n  ensures forall i :: 0 <= i < |nums| && SatisfiesCondition(nums[i]) ==> nums[i] > 10 && IsOdd(FirstDigit(nums[i])) && IsOdd(LastDigit(nums[i]))", "vc-code": "{\n  CountHelperCorrectness(nums, 0);\n  count := CountHelper(nums, 0);\n}", "vc-postamble": ""}
{"id": "HumanEval_125", "vc-description": "This verification task implements a string processing function that applies rules in a specific order. Given a string, it first checks if the string contains whitespace and splits on whitespace if so. If there's no whitespace but the string contains commas, it splits on commas. Otherwise, it counts the lowercase letters that are at odd positions in the alphabet (b, d, f, h, etc.).\n\nThe implementation uses a datatype to represent either a sequence of strings (for splitting results) or an integer count, with helper functions for each operation and appropriate specifications ensuring correctness.", "vc-preamble": "// ======= TASK =======\n// Given a string, apply rules in order:\n// 1. If contains whitespace, return list of words split on whitespace\n// 2. If no whitespace but contains commas, return list split on commas\n// 3. If neither, return count of lowercase letters at odd alphabet positions\n\n// ======= SPEC REQUIREMENTS =======\ndatatype SplitResult = StringSeq(words: seq<string>) | Count(value: int)\n\nfunction contains_space(txt: string): bool\n{\n    exists i :: 0 <= i < |txt| && txt[i] == ' '\n}\n\nfunction contains_comma(txt: string): bool\n{\n    exists i :: 0 <= i < |txt| && txt[i] == ','\n}", "vc-helpers": "// ======= HELPERS =======\nfunction split_on_whitespace(txt: string): seq<string>\n    ensures forall w :: w in split_on_whitespace(txt) ==> |w| > 0\n    ensures forall w :: w in split_on_whitespace(txt) ==> forall c :: c in w ==> c != ' '\n    decreases |txt|\n{\n    if |txt| == 0 then\n        []\n    else\n        split_on_whitespace_helper(txt, 0, [], \"\")\n}\n\nfunction split_on_whitespace_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>\n    requires 0 <= i <= |txt|\n    requires forall w :: w in result ==> |w| > 0\n    requires forall w :: w in result ==> forall c :: c in w ==> c != ' '\n    requires forall c :: c in current_word ==> c != ' '\n    ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> |w| > 0\n    ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> forall c :: c in w ==> c != ' '\n    decreases |txt| - i\n{\n    if i == |txt| then\n        if |current_word| > 0 then\n            result + [current_word]\n        else\n            result\n    else if txt[i] == ' ' then\n        if |current_word| > 0 then\n            split_on_whitespace_helper(txt, i + 1, result + [current_word], \"\")\n        else\n            split_on_whitespace_helper(txt, i + 1, result, \"\")\n    else\n        split_on_whitespace_helper(txt, i + 1, result, current_word + [txt[i]])\n}\n\nfunction split_on_comma(txt: string): seq<string>\n    ensures |split_on_comma(txt)| > 0\n    decreases |txt|\n{\n    if |txt| == 0 then\n        [\"\"]\n    else\n        split_on_comma_helper(txt, 0, [], \"\")\n}\n\nfunction split_on_comma_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>\n    requires 0 <= i <= |txt|\n    ensures |split_on_comma_helper(txt, i, result, current_word)| > 0\n    decreases |txt| - i\n{\n    if i == |txt| then\n        result + [current_word]\n    else if txt[i] == ',' then\n        split_on_comma_helper(txt, i + 1, result + [current_word], \"\")\n    else\n        split_on_comma_helper(txt, i + 1, result, current_word + [txt[i]])\n}\n\nfunction count_odd_position_lowercase(txt: string): int\n    ensures count_odd_position_lowercase(txt) >= 0\n    ensures count_odd_position_lowercase(txt) <= |txt|\n{\n    count_odd_position_lowercase_helper(txt, 0)\n}\n\nfunction count_odd_position_lowercase_helper(txt: string, i: int): int\n    requires 0 <= i <= |txt|\n    ensures count_odd_position_lowercase_helper(txt, i) >= 0\n    ensures count_odd_position_lowercase_helper(txt, i) <= |txt| - i\n    decreases |txt| - i\n{\n    if i == |txt| then\n        0\n    else\n        var c := txt[i];\n        var count_rest := count_odd_position_lowercase_helper(txt, i + 1);\n        if 'a' <= c <= 'z' && (c as int - 'a' as int) % 2 == 1 then\n            1 + count_rest\n        else\n            count_rest\n}", "vc-spec": "// ======= MAIN METHOD =======\nfunction split_words(txt: string): SplitResult\n    ensures (contains_space(txt) ==> split_words(txt).StringSeq?) &&\n            (!contains_space(txt) && contains_comma(txt) ==> split_words(txt).StringSeq?) &&\n            (!contains_space(txt) && !contains_comma(txt) ==> split_words(txt).Count?)\n    ensures contains_space(txt) ==> split_words(txt) == StringSeq(split_on_whitespace(txt))\n    ensures !contains_space(txt) && contains_comma(txt) ==> split_words(txt) == StringSeq(split_on_comma(txt))\n    ensures !contains_space(txt) && !contains_comma(txt) ==> split_words(txt) == Count(count_odd_position_lowercase(txt))\n    ensures split_words(txt).StringSeq? ==> |split_words(txt).words| >= 0\n    ensures split_words(txt).Count? ==> split_words(txt).value >= 0\n    ensures contains_space(txt) ==> (forall w :: w in split_words(txt).words ==> |w| > 0)\n    ensures !contains_space(txt) && contains_comma(txt) ==> |split_words(txt).words| > 0", "vc-code": "{\n    if contains_space(txt) then\n        StringSeq(split_on_whitespace(txt))\n    else if contains_comma(txt) then\n        StringSeq(split_on_comma(txt))\n    else\n        Count(count_odd_position_lowercase(txt))\n}", "vc-postamble": ""}
{"id": "HumanEval_11", "vc-description": "This task implements a bitwise XOR operation on two binary strings of equal length. Given two strings containing only '0' and '1' characters, the method should return a new string where each position contains '0' if the corresponding characters in the input strings are the same, and '1' if they are different.", "vc-preamble": "// ======= TASK =======\n// Given two binary strings of equal length containing only '0' and '1' characters,\n// perform bitwise XOR operation on corresponding characters and return the result as a string.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_binary_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod string_xor(a: string, b: string) returns (result: string)\n    requires |a| == |b|\n    requires is_binary_string(a)\n    requires is_binary_string(b)\n    ensures |result| == |a|\n    ensures is_binary_string(result)\n    ensures forall i :: 0 <= i < |a| ==> \n        (a[i] == b[i] ==> result[i] == '0') &&\n        (a[i] != b[i] ==> result[i] == '1')", "vc-code": "{\n    result := \"\";\n    for i := 0 to |a|\n        invariant |result| == i\n        invariant is_binary_string(result)\n        invariant forall j :: 0 <= j < i ==> \n            (a[j] == b[j] ==> result[j] == '0') &&\n            (a[j] != b[j] ==> result[j] == '1')\n    {\n        if a[i] == b[i] {\n            result := result + \"0\";\n        } else {\n            result := result + \"1\";\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_122", "vc-description": "This verification task involves computing the sum of all elements that have at most two digits among the first k elements of an array. An element has at most two digits if its absolute value is between 0 and 99 (inclusive).", "vc-preamble": "// ======= TASK =======\n// Given an array of integers and an integer k, return the sum of all elements \n// that have at most two digits among the first k elements of the array.\n// An element has at most two digits if its absolute value is between 0 and 99 (inclusive).\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(arr: seq<int>, k: int) {\n  1 <= |arr| <= 100 && 1 <= k <= |arr|\n}\n\nfunction sum_valid_elements(arr: seq<int>, k: int): int\n  requires 0 <= k <= |arr|\n{\n  sum_valid_elements_up_to(arr, k)\n}\n\nfunction sum_valid_elements_up_to(arr: seq<int>, n: int): int\n  requires 0 <= n <= |arr|\n{\n  if n == 0 then 0\n  else \n    var current := if -99 <= arr[n-1] <= 99 then arr[n-1] else 0;\n    sum_valid_elements_up_to(arr, n-1) + current\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod add_elements(arr: seq<int>, k: int) returns (result: int)\n  requires ValidInput(arr, k)\n  ensures result == sum_valid_elements(arr, k)", "vc-code": "{\n  result := 0;\n  var i := 0;\n  while i < k\n    invariant 0 <= i <= k\n    invariant result == sum_valid_elements_up_to(arr, i)\n  {\n    if -99 <= arr[i] <= 99 {\n      result := result + arr[i];\n    }\n    i := i + 1;\n  }\n}", "vc-postamble": ""}
{"id": "HumanEval_109", "vc-description": "Given an array of unique integers, determine if it's possible to sort the array in non-decreasing order using only right shift operations. A right shift moves all elements one position to the right, with the last element moving to the first. The method should return True if the array is sortable via rotations, False otherwise, with empty arrays returning True.", "vc-preamble": "// ======= TASK =======\n// Given an array of unique integers, determine if it's possible to sort the array\n// in non-decreasing order using only right shift operations. A right shift moves\n// all elements one position to the right, with the last element moving to the first.\n// Return True if sortable, False otherwise. Empty arrays return True.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_sorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction rotate_right(arr: seq<int>, k: int): seq<int>\n    requires 0 <= k <= |arr|\n    ensures |rotate_right(arr, k)| == |arr|\n{\n    if |arr| == 0 then arr\n    else if k == 0 then arr\n    else arr[|arr|-k..] + arr[..|arr|-k]\n}\n\n// ======= HELPERS =======\nmethod quicksort(s: seq<int>) returns (sorted: seq<int>)\n    decreases |s|\n{\n    if |s| <= 1 {\n        sorted := s;\n    } else {\n        var pivot := s[0];\n        var smaller := [];\n        var greater := [];\n\n        var i := 1;\n        while i < |s|\n            invariant 1 <= i <= |s|\n            invariant |smaller| + |greater| == i - 1\n            invariant |smaller| < |s|\n            invariant |greater| < |s|\n        {\n            if s[i] < pivot {\n                smaller := smaller + [s[i]];\n            } else {\n                greater := greater + [s[i]];\n            }\n            i := i + 1;\n        }\n\n        var sorted_smaller := quicksort(smaller);\n        var sorted_greater := quicksort(greater);\n        sorted := sorted_smaller + [pivot] + sorted_greater;\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod move_one_ball(arr: seq<int>) returns (result: bool)\n    requires forall i, j :: 0 <= i < j < |arr| ==> arr[i] != arr[j]\n    ensures |arr| == 0 ==> result == true\n    ensures result == true ==> (|arr| == 0 || exists k :: 0 <= k < |arr| && is_sorted(rotate_right(arr, k)))\n    ensures result == false ==> forall k :: 0 <= k < |arr| ==> !is_sorted(rotate_right(arr, k))", "vc-code": "{\n    if |arr| == 0 {\n        result := true;\n        return;\n    }\n\n    var rotations := 0;\n    while rotations < |arr|\n        invariant 0 <= rotations <= |arr|\n        invariant forall k :: 0 <= k < rotations ==> !is_sorted(rotate_right(arr, k))\n    {\n        if is_sorted(rotate_right(arr, rotations)) {\n            result := true;\n            return;\n        }\n        rotations := rotations + 1;\n    }\n\n    result := false;\n}", "vc-postamble": ""}
{"id": "HumanEval_81", "vc-description": "Convert a list of numerical GPA values to corresponding letter grades using a specified grading scale. The grading scale maps GPA ranges to letter grades from A+ (4.0) down to E (0.0).", "vc-preamble": "// ======= TASK =======\n// Convert a list of numerical GPA values to corresponding letter grades using a specified grading scale.\n// The grading scale maps GPA ranges to letter grades from A+ (4.0) down to E (0.0).\n\n// ======= SPEC REQUIREMENTS =======\nfunction getLetterGrade(gpa: real): string\n{\n    if gpa == 4.0 then \"A+\"\n    else if gpa > 3.7 then \"A\"\n    else if gpa > 3.3 then \"A-\"\n    else if gpa > 3.0 then \"B+\"\n    else if gpa > 2.7 then \"B\"\n    else if gpa > 2.3 then \"B-\"\n    else if gpa > 2.0 then \"C+\"\n    else if gpa > 1.7 then \"C\"\n    else if gpa > 1.3 then \"C-\"\n    else if gpa > 1.0 then \"D+\"\n    else if gpa > 0.7 then \"D\"\n    else if gpa > 0.0 then \"D-\"\n    else \"E\"\n}\n\npredicate ValidLetterGrades(grades: seq<string>)\n{\n    forall grade :: grade in grades ==> grade in {\"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"D-\", \"E\"}\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod numerical_letter_grade(grades: seq<real>) returns (letter_grades: seq<string>)\n    ensures |letter_grades| == |grades|\n    ensures forall i :: 0 <= i < |grades| ==> letter_grades[i] == getLetterGrade(grades[i])\n    ensures ValidLetterGrades(letter_grades)", "vc-code": "{\n    letter_grades := [];\n\n    for i := 0 to |grades|\n        invariant |letter_grades| == i\n        invariant forall j :: 0 <= j < i ==> letter_grades[j] == getLetterGrade(grades[j])\n        invariant ValidLetterGrades(letter_grades)\n    {\n        var gpa := grades[i];\n        var grade: string;\n\n        if gpa == 4.0 {\n            grade := \"A+\";\n        } else if gpa > 3.7 {\n            grade := \"A\";\n        } else if gpa > 3.3 {\n            grade := \"A-\";\n        } else if gpa > 3.0 {\n            grade := \"B+\";\n        } else if gpa > 2.7 {\n            grade := \"B\";\n        } else if gpa > 2.3 {\n            grade := \"B-\";\n        } else if gpa > 2.0 {\n            grade := \"C+\";\n        } else if gpa > 1.7 {\n            grade := \"C\";\n        } else if gpa > 1.3 {\n            grade := \"C-\";\n        } else if gpa > 1.0 {\n            grade := \"D+\";\n        } else if gpa > 0.7 {\n            grade := \"D\";\n        } else if gpa > 0.0 {\n            grade := \"D-\";\n        } else {\n            grade := \"E\";\n        }\n\n        letter_grades := letter_grades + [grade];\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_9", "vc-description": "This verification task implements a rolling maximum function that takes a list of integers and returns a list where each element represents the maximum value encountered from the beginning of the list up to and including the current position.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, return a list where each element represents \n// the maximum value encountered from the beginning of the list up to and \n// including the current position.\n\n// ======= SPEC REQUIREMENTS =======\nfunction max_up_to(numbers: seq<int>, index: int): int\n    requires 0 <= index < |numbers|\n{\n    if index == 0 then numbers[0]\n    else \n        var prev_max := max_up_to(numbers, index - 1);\n        if numbers[index] > prev_max then numbers[index] else prev_max\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod rolling_max(numbers: seq<int>) returns (result: seq<int>)\n    ensures |result| == |numbers|\n    ensures |numbers| == 0 ==> |result| == 0\n    ensures |numbers| > 0 ==> |result| > 0\n    ensures forall i :: 0 <= i < |result| ==> \n        result[i] == max_up_to(numbers, i)\n    ensures forall i :: 0 <= i < |result| ==> \n        forall j :: 0 <= j <= i ==> numbers[j] <= result[i]\n    ensures forall i :: 0 <= i < |result| ==> \n        exists j :: 0 <= j <= i && numbers[j] == result[i]", "vc-code": "{\n    if |numbers| == 0 {\n        return [];\n    }\n\n    result := [];\n    var current_max := numbers[0];\n\n    for i := 0 to |numbers|\n        invariant |result| == i\n        invariant i > 0 ==> current_max == max_up_to(numbers, i - 1)\n        invariant forall k :: 0 <= k < i ==> result[k] == max_up_to(numbers, k)\n        invariant forall k :: 0 <= k < i ==> \n            forall j :: 0 <= j <= k ==> numbers[j] <= result[k]\n        invariant forall k :: 0 <= k < i ==> \n            exists j :: 0 <= j <= k && numbers[j] == result[k]\n    {\n        current_max := if current_max > numbers[i] then current_max else numbers[i];\n        result := result + [current_max];\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_66", "vc-description": "This task involves calculating the sum of ASCII values of all uppercase letters in a string. The function should return 0 for empty strings and only consider characters from 'A' to 'Z' as uppercase. The implementation needs to be verified with an iterative method that maintains proper loop invariants.", "vc-preamble": "// ======= TASK =======\n// Given a string, calculate the sum of ASCII values of all uppercase letters in the string.\n// Empty string returns 0. Only characters from 'A' to 'Z' are considered uppercase.\n\n// ======= SPEC REQUIREMENTS =======\nfunction sumOfUppercaseASCII(s: string): int\n    ensures sumOfUppercaseASCII(s) >= 0\n{\n    if |s| == 0 then 0\n    else \n        var c := s[0];\n        var rest := sumOfUppercaseASCII(s[1..]);\n        if 'A' <= c && c <= 'Z' then (c as int) + rest\n        else rest\n}", "vc-helpers": "// ======= HELPERS =======\nlemma sumOfUppercaseASCII_lemma(s: string, c: char)\n    ensures sumOfUppercaseASCII(s + [c]) == \n            if 'A' <= c && c <= 'Z' then sumOfUppercaseASCII(s) + (c as int)\n            else sumOfUppercaseASCII(s)\n{\n    if |s| == 0 {\n        assert s + [c] == [c];\n        assert sumOfUppercaseASCII([c]) == (if 'A' <= c && c <= 'Z' then (c as int) else 0);\n        assert sumOfUppercaseASCII(s) == 0;\n    } else {\n        assert (s + [c])[0] == s[0];\n        assert (s + [c])[1..] == s[1..] + [c];\n        sumOfUppercaseASCII_lemma(s[1..], c);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod digitSum(s: string) returns (result: int)\n    ensures result >= 0\n    ensures result == sumOfUppercaseASCII(s)", "vc-code": "{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant result == sumOfUppercaseASCII(s[..i])\n        invariant result >= 0\n    {\n        var c := s[i];\n        if 'A' <= c && c <= 'Z' {\n            result := result + (c as int);\n        }\n        i := i + 1;\n\n        // Help the verifier by asserting the relationship\n        assert s[..i] == s[..i-1] + [s[i-1]];\n        sumOfUppercaseASCII_lemma(s[..i-1], s[i-1]);\n    }\n    assert i == |s|;\n    assert s[..i] == s;\n}", "vc-postamble": ""}
{"id": "HumanEval_115", "vc-description": "This verification task involves implementing a solution to determine the minimum number of bucket operations needed to empty all wells in a 2D binary grid. Each row represents a well, each 1 represents a unit of water, and each bucket has a fixed capacity. The implementation must correctly calculate the total number of bucket trips required across all wells.", "vc-preamble": "// ======= TASK =======\n// Given a 2D binary grid where each row represents a well and each 1 represents a unit of water,\n// determine the minimum number of bucket operations needed to empty all wells.\n// Each bucket has the same capacity and can extract up to that many units of water per operation.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(grid: seq<seq<int>>, capacity: int)\n{\n    capacity > 0 &&\n    (forall i :: 0 <= i < |grid| ==> forall j :: 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1) &&\n    (forall i :: 0 <= i < |grid| ==> |grid[i]| == if |grid| > 0 then |grid[0]| else 0)\n}\n\nfunction sum_water(well: seq<int>): int\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n{\n    if |well| == 0 then 0\n    else well[0] + sum_water(well[1..])\n}\n\nfunction trips_for_well(well: seq<int>, capacity: int): int\n    requires capacity > 0\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n{\n    var water_units := sum_water(well);\n    if water_units == 0 then 0\n    else (water_units + capacity - 1) / capacity\n}\n\nfunction sum_of_trips(grid: seq<seq<int>>, capacity: int): int\n    requires capacity > 0\n    requires forall i :: 0 <= i < |grid| ==> forall j :: 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1\n    requires forall i :: 0 <= i < |grid| ==> |grid[i]| == if |grid| > 0 then |grid[0]| else 0\n{\n    if |grid| == 0 then 0\n    else trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..], capacity)\n}", "vc-helpers": "// ======= HELPERS =======\nlemma sum_water_slice_lemma(well: seq<int>, j: int)\n    requires 0 <= j < |well|\n    requires forall k :: 0 <= k < |well| ==> well[k] == 0 || well[k] == 1\n    ensures sum_water(well[..j+1]) == sum_water(well[..j]) + well[j]\n{\n    if j == 0 {\n        assert well[..1] == [well[0]];\n        assert well[..0] == [];\n        assert sum_water(well[..0]) == 0;\n        assert sum_water(well[..1]) == well[0] + sum_water([]);\n        assert sum_water(well[..1]) == well[0] + 0;\n        assert sum_water(well[..1]) == well[0];\n    } else {\n        assert well[..j+1] == well[..j] + [well[j]];\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[..j+1])[1..]);\n        assert (well[..j+1])[1..] == well[1..j+1];\n        assert well[1..j+1] == (well[1..])[..j];\n        sum_water_slice_lemma(well[1..], j-1);\n        assert sum_water((well[1..])[..j]) == sum_water((well[1..])[..j-1]) + (well[1..])[j-1];\n        assert (well[1..])[j-1] == well[j];\n        assert sum_water(well[..j]) == well[0] + sum_water((well[..j])[1..]);\n        assert (well[..j])[1..] == well[1..j];\n        assert well[1..j] == (well[1..])[..j-1];\n        assert sum_water(well[..j]) == well[0] + sum_water((well[1..])[..j-1]);\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[1..])[..j]);\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[1..])[..j-1]) + well[j];\n        assert sum_water(well[..j+1]) == sum_water(well[..j]) + well[j];\n    }\n}\n\nlemma sum_water_full_slice_lemma(well: seq<int>)\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n    ensures sum_water(well[..|well|]) == sum_water(well)\n{\n    assert well[..|well|] == well;\n}\n\nlemma sum_of_trips_slice_lemma(grid: seq<seq<int>>, i: int, capacity: int)\n    requires capacity > 0\n    requires 0 <= i < |grid|\n    requires forall k :: 0 <= k < |grid| ==> forall j :: 0 <= j < |grid[k]| ==> grid[k][j] == 0 || grid[k][j] == 1\n    requires forall k :: 0 <= k < |grid| ==> |grid[k]| == if |grid| > 0 then |grid[0]| else 0\n    ensures sum_of_trips(grid[..i+1], capacity) == sum_of_trips(grid[..i], capacity) + trips_for_well(grid[i], capacity)\n{\n    if i == 0 {\n        assert grid[..1] == [grid[0]];\n        assert grid[..0] == [];\n        assert sum_of_trips(grid[..0], capacity) == 0;\n        assert sum_of_trips(grid[..1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips([], capacity);\n        assert sum_of_trips(grid[..1], capacity) == trips_for_well(grid[0], capacity) + 0;\n    } else {\n        assert grid[..i+1] == [grid[0]] + grid[1..i+1];\n        assert sum_of_trips(grid[..i+1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..i+1], capacity);\n        assert grid[1..i+1] == (grid[1..])[..i];\n        sum_of_trips_slice_lemma(grid[1..], i-1, capacity);\n        assert sum_of_trips((grid[1..])[..i], capacity) == sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well((grid[1..])[i-1], capacity);\n        assert (grid[1..])[i-1] == grid[i];\n        assert grid[..i] == [grid[0]] + grid[1..i];\n        assert sum_of_trips(grid[..i], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..i], capacity);\n        assert grid[1..i] == (grid[1..])[..i-1];\n        assert sum_of_trips(grid[..i], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips((grid[1..])[..i-1], capacity);\n        assert sum_of_trips(grid[1..i+1], capacity) == sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well(grid[i], capacity);\n        assert sum_of_trips(grid[..i+1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well(grid[i], capacity);\n        assert sum_of_trips(grid[..i+1], capacity) == sum_of_trips(grid[..i], capacity) + trips_for_well(grid[i], capacity);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod max_fill(grid: seq<seq<int>>, capacity: int) returns (result: int)\n    requires ValidInput(grid, capacity)\n    ensures result >= 0\n    ensures result == sum_of_trips(grid, capacity)", "vc-code": "{\n    result := 0;\n\n    for i := 0 to |grid|\n        invariant 0 <= i <= |grid|\n        invariant result >= 0\n        invariant result == sum_of_trips(grid[..i], capacity)\n    {\n        var water_units := 0;\n\n        for j := 0 to |grid[i]|\n            invariant 0 <= j <= |grid[i]|\n            invariant water_units >= 0\n            invariant water_units == sum_water(grid[i][..j])\n        {\n            if j < |grid[i]| {\n                sum_water_slice_lemma(grid[i], j);\n                water_units := water_units + grid[i][j];\n            }\n        }\n\n        var trips_needed := 0;\n        if water_units > 0 {\n            trips_needed := (water_units + capacity - 1) / capacity;\n        }\n\n        sum_water_full_slice_lemma(grid[i]);\n        assert water_units == sum_water(grid[i]);\n        assert trips_needed == trips_for_well(grid[i], capacity);\n\n        result := result + trips_needed;\n\n        sum_of_trips_slice_lemma(grid, i, capacity);\n        assert result == sum_of_trips(grid[..i], capacity) + trips_for_well(grid[i], capacity);\n        assert result == sum_of_trips(grid[..i+1], capacity);\n    }\n\n    assert grid[..|grid|] == grid;\n}", "vc-postamble": ""}
{"id": "HumanEval_40", "vc-description": "This verification task involves implementing a method to determine if there exist three distinct elements at different positions in a list of integers that sum to zero. The implementation should exhaustively check all possible combinations of three indices and return true if any triple sums to zero.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, determine if there exist three distinct elements \n// (at different positions) in the list that sum to zero.\n\n// ======= SPEC REQUIREMENTS =======\npredicate HasTripleSumToZero(l: seq<int>)\n{\n    exists i, j, k :: 0 <= i < j < k < |l| && l[i] + l[j] + l[k] == 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod triples_sum_to_zero(l: seq<int>) returns (result: bool)\n    ensures result == HasTripleSumToZero(l)", "vc-code": "{\n    // Need at least 3 elements to form a triple\n    if |l| < 3 {\n        return false;\n    }\n\n    // Check all possible combinations of three distinct indices\n    var i := 0;\n    while i < |l|\n        invariant 0 <= i <= |l|\n        invariant forall ii, jj, kk :: 0 <= ii < jj < kk < |l| && ii < i ==> l[ii] + l[jj] + l[kk] != 0\n    {\n        var j := i + 1;\n        while j < |l|\n            invariant i + 1 <= j <= |l|\n            invariant forall ii, jj, kk :: 0 <= ii < jj < kk < |l| && ii < i ==> l[ii] + l[jj] + l[kk] != 0\n            invariant forall jj, kk :: i < jj < kk < |l| && jj < j ==> l[i] + l[jj] + l[kk] != 0\n        {\n            var k := j + 1;\n            while k < |l|\n                invariant j + 1 <= k <= |l|\n                invariant forall ii, jj, kk :: 0 <= ii < jj < kk < |l| && ii < i ==> l[ii] + l[jj] + l[kk] != 0\n                invariant forall jj, kk :: i < jj < kk < |l| && jj < j ==> l[i] + l[jj] + l[kk] != 0\n                invariant forall kk :: j < kk < |l| && kk < k ==> l[i] + l[j] + l[kk] != 0\n            {\n                if l[i] + l[j] + l[k] == 0 {\n                    return true;\n                }\n                k := k + 1;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n\n    return false;\n}", "vc-postamble": ""}
{"id": "HumanEval_88", "vc-description": "This verification task implements a conditional sorting algorithm for arrays of non-negative integers. The sorting order is determined by the sum of the first and last elements: if the sum is odd, the array is sorted in ascending order; if the sum is even, it's sorted in descending order. The implementation must return a sorted copy without modifying the original array and preserve all elements (multiset equality).", "vc-preamble": "// ======= TASK =======\n// Given an array of non-negative integers, return a sorted copy of the array.\n// The sorting order depends on the sum of the first and last elements:\n// - If the sum is odd: sort in ascending order  \n// - If the sum is even: sort in descending order\n// - Return a copy without modifying the original array\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(arr: seq<int>)\n{\n    forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n}\n\npredicate IsAscendingSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\npredicate IsDescendingSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]\n}\n\npredicate ShouldSortAscending(arr: seq<int>)\n{\n    |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 1\n}\n\npredicate ShouldSortDescending(arr: seq<int>)\n{\n    |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 0\n}\n\npredicate CorrectlySorted(arr: seq<int>, result: seq<int>)\n{\n    (|arr| <= 1 ==> result == arr) &&\n    (ShouldSortAscending(arr) ==> IsAscendingSorted(result)) &&\n    (ShouldSortDescending(arr) ==> IsDescendingSorted(result))\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SortAscending(arr: seq<int>) returns (result: seq<int>)\n    ensures multiset(result) == multiset(arr)\n    ensures IsAscendingSorted(result)\n{\n    result := arr;\n    var i := 0;\n    while i < |result|\n        invariant 0 <= i <= |result|\n        invariant |result| == |arr|\n        invariant multiset(result) == multiset(arr)\n        invariant forall p, q :: 0 <= p < q < i ==> result[p] <= result[q]\n        invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] <= result[q]\n        decreases |result| - i\n    {\n        var j := i + 1;\n        while j < |result|\n            invariant i < j <= |result|\n            invariant |result| == |arr|\n            invariant multiset(result) == multiset(arr)\n            invariant forall p, q :: 0 <= p < q < i ==> result[p] <= result[q]\n            invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] <= result[q]\n            invariant forall q :: i < q < j ==> result[i] <= result[q]\n        {\n            if result[j] < result[i] {\n                result := result[i := result[j]][j := result[i]];\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\n\nmethod SortDescending(arr: seq<int>) returns (result: seq<int>)\n    ensures multiset(result) == multiset(arr)\n    ensures IsDescendingSorted(result)\n{\n    result := arr;\n    var i := 0;\n    while i < |result|\n        invariant 0 <= i <= |result|\n        invariant |result| == |arr|\n        invariant multiset(result) == multiset(arr)\n        invariant forall p, q :: 0 <= p < q < i ==> result[p] >= result[q]\n        invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] >= result[q]\n        decreases |result| - i\n    {\n        var j := i + 1;\n        while j < |result|\n            invariant i < j <= |result|\n            invariant |result| == |arr|\n            invariant multiset(result) == multiset(arr)\n            invariant forall p, q :: 0 <= p < q < i ==> result[p] >= result[q]\n            invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] >= result[q]\n            invariant forall q :: i < q < j ==> result[i] >= result[q]\n        {\n            if result[j] > result[i] {\n                result := result[i := result[j]][j := result[i]];\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod sort_array(arr: seq<int>) returns (result: seq<int>)\n    requires ValidInput(arr)\n    ensures multiset(result) == multiset(arr)\n    ensures CorrectlySorted(arr, result)", "vc-code": "{\n    if |arr| <= 1 {\n        result := arr;\n    } else if ShouldSortAscending(arr) {\n        result := SortAscending(arr);\n    } else {\n        result := SortDescending(arr);\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_27", "vc-description": "This verification task involves implementing a string case-flipping function that converts all lowercase letters to uppercase and all uppercase letters to lowercase, while leaving non-alphabetic characters unchanged. The implementation should process each character in the input string and return a new string with the appropriate case transformations.", "vc-preamble": "// ======= TASK =======\n// Given a string, convert all lowercase letters to uppercase and all uppercase letters to lowercase. \n// Non-alphabetic characters remain unchanged.\n\n// ======= SPEC REQUIREMENTS =======\npredicate IsLowercase(c: char) {\n    'a' <= c <= 'z'\n}\n\npredicate IsUppercase(c: char) {\n    'A' <= c <= 'Z'\n}\n\nfunction FlipChar(c: char): char {\n    if IsLowercase(c) then c - 'a' + 'A'\n    else if IsUppercase(c) then c - 'A' + 'a'\n    else c\n}\n\npredicate ValidFlipCase(s: string, result: string) {\n    |result| == |s| &&\n    forall i :: 0 <= i < |s| ==> result[i] == FlipChar(s[i])\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod flip_case(s: string) returns (result: string)\n    ensures ValidFlipCase(s, result)", "vc-code": "{\n    result := \"\";\n    for i := 0 to |s|\n        invariant |result| == i\n        invariant forall j :: 0 <= j < i ==> result[j] == FlipChar(s[j])\n    {\n        var c := s[i];\n        if 'a' <= c && c <= 'z' {\n            result := result + [c - 'a' + 'A'];\n        } else if 'A' <= c && c <= 'Z' {\n            result := result + [c - 'A' + 'a'];\n        } else {\n            result := result + [c];\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_155", "vc-description": "This verification task implements a function to count the number of even and odd digits in the absolute value of an integer. The function should return a tuple containing the count of even digits and the count of odd digits.\n\nThe implementation uses helper functions to define digit counting operations and ensures correctness through loop invariants that maintain the relationship between processed and remaining digits.", "vc-preamble": "// ======= TASK =======\n// Given an integer, count the number of even digits and odd digits in its absolute value.\n// Return a tuple (even_count, odd_count).\n\n// ======= SPEC REQUIREMENTS =======\nfunction abs_value(x: int): int\n{\n    if x < 0 then -x else x\n}\n\nfunction count_digits(n: nat): nat\n    requires n >= 0\n{\n    if n < 10 then 1 else 1 + count_digits(n / 10)\n}\n\nfunction is_even_digit(d: nat): bool\n    requires d < 10\n{\n    d % 2 == 0\n}\n\nfunction count_even_digits(n: nat): nat\n    requires n >= 0\n    decreases n\n{\n    if n < 10 then\n        if is_even_digit(n) then 1 else 0\n    else\n        (if is_even_digit(n % 10) then 1 else 0) + count_even_digits(n / 10)\n}\n\nfunction count_odd_digits(n: nat): nat\n    requires n >= 0\n    decreases n\n{\n    if n < 10 then\n        if !is_even_digit(n) then 1 else 0\n    else\n        (if !is_even_digit(n % 10) then 1 else 0) + count_odd_digits(n / 10)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod even_odd_count(num: int) returns (even_count: int, odd_count: int)\n    ensures even_count >= 0 && odd_count >= 0\n    ensures even_count + odd_count >= 1\n    ensures var abs_num := abs_value(num);\n            even_count == count_even_digits(abs_num) &&\n            odd_count == count_odd_digits(abs_num)\n    ensures even_count + odd_count == count_digits(abs_value(num))\n    ensures num == 0 ==> (even_count == 1 && odd_count == 0)\n    ensures abs_value(num) == abs_value(-num) ==> \n            (even_count == count_even_digits(abs_value(-num)) && \n             odd_count == count_odd_digits(abs_value(-num)))", "vc-code": "{\n    var abs_num := abs_value(num);\n\n    if abs_num == 0 {\n        even_count := 1;\n        odd_count := 0;\n        return;\n    }\n\n    even_count := 0;\n    odd_count := 0;\n\n    var remaining := abs_num;\n    while remaining > 0\n        invariant remaining >= 0\n        invariant even_count >= 0 && odd_count >= 0\n        invariant remaining == 0 ==> even_count + odd_count == count_digits(abs_num)\n        invariant remaining > 0 ==> even_count + odd_count + count_digits(remaining) == count_digits(abs_num)\n        invariant remaining == 0 ==> even_count == count_even_digits(abs_num)\n        invariant remaining > 0 ==> even_count + count_even_digits(remaining) == count_even_digits(abs_num)\n        invariant remaining == 0 ==> odd_count == count_odd_digits(abs_num)\n        invariant remaining > 0 ==> odd_count + count_odd_digits(remaining) == count_odd_digits(abs_num)\n        decreases remaining\n    {\n        var digit := remaining % 10;\n        if digit % 2 == 0 {\n            even_count := even_count + 1;\n        } else {\n            odd_count := odd_count + 1;\n        }\n        remaining := remaining / 10;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_73", "vc-description": "This verification task involves finding the minimum number of elements that must be changed to make an array palindromic. A palindromic array reads the same forwards and backwards. The solution should count the number of mismatched pairs between corresponding positions from the start and end of the array.", "vc-preamble": "// ======= TASK =======\n// Given an array of integers, find the minimum number of elements that must be changed \n// to make the array palindromic (reads the same forwards and backwards). You can change \n// any element to any other integer value.\n\n// ======= SPEC REQUIREMENTS =======\nfunction count_mismatched_pairs(arr: seq<int>): int\n{\n    count_mismatched_pairs_up_to(arr, |arr| / 2)\n}\n\nfunction count_mismatched_pairs_up_to(arr: seq<int>, limit: int): int\n    requires 0 <= limit <= |arr| / 2\n{\n    if limit == 0 then 0\n    else \n        (if arr[limit-1] != arr[|arr| - limit] then 1 else 0) + \n        count_mismatched_pairs_up_to(arr, limit - 1)\n}\n\npredicate can_make_palindromic_with_changes(arr: seq<int>, num_changes: int)\n{\n    num_changes >= 0 && num_changes >= count_mismatched_pairs(arr)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod smallest_change(arr: seq<int>) returns (changes: int)\n    ensures changes >= 0\n    ensures changes <= |arr| / 2\n    ensures changes == count_mismatched_pairs(arr)\n    ensures (|arr| <= 1) ==> (changes == 0)\n    ensures forall c :: 0 <= c < changes ==> !can_make_palindromic_with_changes(arr, c)\n    ensures can_make_palindromic_with_changes(arr, changes)", "vc-code": "{\n    var n := |arr|;\n    changes := 0;\n\n    var i := 0;\n    while i < n / 2\n        invariant 0 <= i <= n / 2\n        invariant changes >= 0\n        invariant changes <= i\n        invariant changes == count_mismatched_pairs_up_to(arr, i)\n    {\n        if arr[i] != arr[n - 1 - i] {\n            changes := changes + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_2", "vc-description": "This task implements a function to extract the decimal (fractional) part of a positive floating point number. Given a number like 3.5, it should return 0.5, and for 1.25, it should return 0.25. The implementation involves subtracting the floor (integer part) from the original number.", "vc-preamble": "// ======= TASK =======\n// Given a positive floating point number, return its decimal part (the fractional component \n// remaining after removing the integer part). For example, 3.5 returns 0.5, 1.25 returns 0.25.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(number: real)\n{\n    number >= 0.0\n}\n\npredicate ValidOutput(result: real, input: real)\n{\n    0.0 <= result < 1.0 && result == input - Floor(input)\n}\n\n// ======= HELPERS =======\nfunction Floor(x: real): real\n    ensures Floor(x) <= x < Floor(x) + 1.0\n{\n    if x >= 0.0 then\n        FloorNonnegative(x)\n    else\n        -CeilNonnegative(-x)\n}\n\nfunction FloorNonnegative(x: real): real\n    requires x >= 0.0\n    ensures FloorNonnegative(x) <= x < FloorNonnegative(x) + 1.0\n    ensures FloorNonnegative(x) >= 0.0\n{\n    FloorHelper(x, 0)\n}\n\nfunction FloorHelper(x: real, n: int): real\n    requires x >= 0.0\n    requires n >= 0\n    ensures FloorHelper(x, n) <= x + n as real < FloorHelper(x, n) + 1.0\n    ensures FloorHelper(x, n) >= n as real\n    decreases x\n{\n    if x < 1.0 then \n        n as real\n    else \n        FloorHelper(x - 1.0, n + 1)\n}\n\nfunction CeilNonnegative(x: real): real\n    requires x >= 0.0\n    ensures CeilNonnegative(x) >= x\n    ensures x > 0.0 ==> CeilNonnegative(x) < x + 1.0\n{\n    if x == 0.0 then \n        0.0\n    else if FloorNonnegative(x) == x then\n        x\n    else\n        FloorNonnegative(x) + 1.0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nfunction truncate_number(number: real): real\n    requires ValidInput(number)\n    ensures ValidOutput(truncate_number(number), number)", "vc-code": "{\n    number - Floor(number)\n}", "vc-postamble": ""}
{"id": "HumanEval_16", "vc-description": "Count the number of distinct characters in a string, ignoring case differences. The implementation should return an integer representing the count of unique characters, treating 'A' and 'a' as the same character through case-insensitive comparison.", "vc-preamble": "// ======= TASK =======\n// Count the number of distinct characters in a string, ignoring case differences.\n// Input: A string\n// Output: Integer representing the count of unique characters\n// Case-insensitive comparison (treat 'A' and 'a' as the same character)\n\n// ======= SPEC REQUIREMENTS =======\nfunction to_lower_char(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod count_distinct_characters(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count <= |s|\n    ensures count == |set i | 0 <= i < |s| :: to_lower_char(s[i])|", "vc-code": "{\n    var i := 0;\n    var chars := {};\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant chars == set j | 0 <= j < i :: to_lower_char(s[j])\n        invariant |chars| <= i\n    {\n        chars := chars + {to_lower_char(s[i])};\n        i := i + 1;\n    }\n    count := |chars|;\n}", "vc-postamble": ""}
{"id": "HumanEval_102", "vc-description": "This task involves implementing a method to find the largest even integer in a given range [x, y] inclusive, where x and y are positive integers. If no even integer exists in the range, the method should return -1.", "vc-preamble": "// ======= TASK =======\n// Given two positive integers x and y, find the largest even integer in the range [x, y] inclusive.\n// If no even integer exists in this range, return -1.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(x: int, y: int) {\n    x > 0 && y > 0\n}\n\npredicate NoEvenInRange(x: int, y: int) {\n    forall i :: x <= i <= y ==> i % 2 != 0\n}\n\npredicate IsLargestEvenInRange(x: int, y: int, result: int) {\n    result % 2 == 0 && \n    x <= result <= y && \n    (forall i :: x <= i <= y && i % 2 == 0 ==> i <= result)\n}\n\npredicate CorrectResult(x: int, y: int, result: int) {\n    if x > y then \n        result == -1\n    else\n        (result == -1 && NoEvenInRange(x, y)) ||\n        IsLargestEvenInRange(x, y, result)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod ChooseNum(x: int, y: int) returns (result: int)\n    requires ValidInput(x, y)\n    ensures CorrectResult(x, y, result)", "vc-code": "{\n    if x > y {\n        result := -1;\n    } else if y % 2 == 0 {\n        result := y;\n    } else if y - 1 >= x {\n        result := y - 1;\n    } else {\n        result := -1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_153", "vc-description": "Given a class name (string) and a list of extension names (strings), find the \"strongest\" extension and return the result in the format \"ClassName.StrongestExtensionName\". The strength of an extension is calculated as: (number of uppercase letters) - (number of lowercase letters). Choose the extension with the highest strength value. If multiple extensions have the same highest strength, choose the first one that appears in the list.", "vc-preamble": "// ======= TASK =======\n// Given a class name (string) and a list of extension names (strings), find the \"strongest\" extension \n// and return the result in the format \"ClassName.StrongestExtensionName\".\n// The strength of an extension is calculated as: (number of uppercase letters) - (number of lowercase letters).\n// Choose the extension with the highest strength value. If multiple extensions have the same highest strength, \n// choose the first one that appears in the list.\n\n// ======= SPEC REQUIREMENTS =======\nfunction count_upper(s: string): int\n{\n    if |s| == 0 then 0\n    else (if 'A' <= s[0] <= 'Z' then 1 else 0) + count_upper(s[1..])\n}\n\nfunction count_lower(s: string): int\n{\n    if |s| == 0 then 0\n    else (if 'a' <= s[0] <= 'z' then 1 else 0) + count_lower(s[1..])\n}\n\nfunction strength(s: string): int\n{\n    count_upper(s) - count_lower(s)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod Strongest_Extension(class_name: string, extensions: seq<string>) returns (result: string)\n    requires |extensions| > 0\n    ensures exists i :: 0 <= i < |extensions| && result == class_name + \".\" + extensions[i] &&\n            (forall j :: 0 <= j < |extensions| ==> strength(extensions[i]) >= strength(extensions[j])) &&\n            (forall j :: 0 <= j < i ==> strength(extensions[j]) < strength(extensions[i]))", "vc-code": "{\n    var strongest_idx := 0;\n    var max_strength := strength(extensions[0]);\n\n    for i := 1 to |extensions| \n        invariant 0 <= strongest_idx < i <= |extensions|\n        invariant max_strength == strength(extensions[strongest_idx])\n        invariant forall j :: 0 <= j < i ==> strength(extensions[j]) <= max_strength\n        invariant forall j :: 0 <= j < strongest_idx ==> strength(extensions[j]) < max_strength\n    {\n        var current_strength := strength(extensions[i]);\n        if current_strength > max_strength {\n            max_strength := current_strength;\n            strongest_idx := i;\n        }\n    }\n\n    result := class_name + \".\" + extensions[strongest_idx];\n}", "vc-postamble": ""}
{"id": "HumanEval_94", "vc-description": "This verification task involves implementing a method that finds the largest prime number in a given list of integers and returns the sum of its digits. If no prime number exists in the list, the method should return 0. The implementation requires helper functions for prime checking and digit sum calculation.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, find the largest prime number in the list and return the sum of its digits.\n// If no prime exists in the list, return 0.\n\n// ======= SPEC REQUIREMENTS =======\nfunction is_prime_pure(n: int): bool\n{\n    n >= 2 && (forall k :: 2 <= k < n ==> n % k != 0)\n}\n\nfunction sum_of_digits_pure(n: int): int\n    requires n >= 0\n{\n    if n < 10 then n else (n % 10) + sum_of_digits_pure(n / 10)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod is_prime(n: int) returns (prime: bool)\n    ensures prime == is_prime_pure(n)\n{\n    if n < 2 {\n        return false;\n    }\n    if n == 2 {\n        return true;\n    }\n    if n % 2 == 0 {\n        return false;\n    }\n\n    var i := 3;\n    while i * i <= n\n        invariant 3 <= i\n        invariant i % 2 == 1\n        invariant forall k :: 2 <= k < i ==> n % k != 0\n        invariant n >= 2\n    {\n        if n % i == 0 {\n            return false;\n        }\n        i := i + 2;\n    }\n\n    assert forall k :: 2 <= k < n ==> n % k != 0 by {\n        forall k | 2 <= k < n \n        ensures n % k != 0\n        {\n            if k < i {\n                // Already covered by loop invariant\n            } else {\n                assert k >= i;\n                assert i * i > n;\n                if n % k == 0 {\n                    var m := n / k;\n                    assert n == k * m;\n                    assert m >= 1;\n                    if m == 1 {\n                        assert n == k;\n                        assert k < n;\n                        assert false;\n                    } else {\n                        assert m >= 2;\n                        assert k * m == n;\n                        assert k >= i;\n                        assert i * i > n;\n                        assert k * m < k * k;\n                        assert m < k;\n                        assert m < i;\n                        assert n % m == 0;\n                        assert false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nfunction sum_of_digits(n: int): int\n    requires n >= 0\n    ensures sum_of_digits(n) == sum_of_digits_pure(n)\n    ensures sum_of_digits(n) >= 0\n{\n    if n < 10 then n\n    else (n % 10) + sum_of_digits(n / 10)\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod skjkasdkd(lst: seq<int>) returns (result: int)\n    ensures result >= 0\n    ensures (forall x :: x in lst ==> !is_prime_pure(x)) ==> result == 0\n    ensures (exists x :: x in lst && is_prime_pure(x)) ==> \n        (exists largest :: largest in lst && is_prime_pure(largest) && \n         (forall y :: y in lst && is_prime_pure(y) ==> y <= largest) &&\n         result == sum_of_digits_pure(largest))", "vc-code": "{\n    var primes: seq<int> := [];\n    var i := 0;\n    while i < |lst|\n        invariant 0 <= i <= |lst|\n        invariant forall j :: 0 <= j < |primes| ==> primes[j] in lst && is_prime_pure(primes[j])\n        invariant forall x :: x in lst[..i] && is_prime_pure(x) ==> x in primes\n    {\n        var prime_check := is_prime(lst[i]);\n        if prime_check {\n            primes := primes + [lst[i]];\n        }\n        i := i + 1;\n    }\n\n    if |primes| == 0 {\n        assert forall x :: x in lst ==> !is_prime_pure(x);\n        return 0;\n    }\n\n    var largest_prime := primes[0];\n    i := 1;\n    while i < |primes|\n        invariant 1 <= i <= |primes|\n        invariant largest_prime in primes\n        invariant forall j :: 0 <= j < i ==> primes[j] <= largest_prime\n    {\n        if primes[i] > largest_prime {\n            largest_prime := primes[i];\n        }\n        i := i + 1;\n    }\n\n    assert largest_prime in lst && is_prime_pure(largest_prime);\n    assert forall y :: y in lst && is_prime_pure(y) ==> y <= largest_prime;\n    assert largest_prime >= 2;\n    return sum_of_digits(largest_prime);\n}", "vc-postamble": ""}
{"id": "HumanEval_112", "vc-description": "This task implements a string filtering and palindrome checking function. Given two strings s and c, it removes all characters from string s that appear anywhere in string c, then determines if the resulting string is a palindrome (reads the same forwards and backwards). The method returns a tuple containing the filtered string and a boolean indicating whether it's a palindrome.", "vc-preamble": "// ======= TASK =======\n// Given two strings s and c, remove all characters from string s that appear \n// anywhere in string c. Then determine if the resulting string is a palindrome \n// (reads the same forwards and backwards). Return a tuple containing the \n// filtered string and a boolean indicating whether it's a palindrome.\n\n// ======= SPEC REQUIREMENTS =======\nfunction filter_chars(s: seq<char>, c: seq<char>): seq<char>\n{\n    if |s| == 0 then []\n    else if s[0] in c then filter_chars(s[1..], c)\n    else [s[0]] + filter_chars(s[1..], c)\n}\n\nfunction reverse(s: seq<char>): seq<char>\n{\n    if |s| == 0 then []\n    else reverse(s[1..]) + [s[0]]\n}", "vc-helpers": "// ======= HELPERS =======\nlemma filter_chars_append_lemma(s: seq<char>, ch: char, c: seq<char>)\n    ensures filter_chars(s + [ch], c) == \n        (if ch in c then filter_chars(s, c) else filter_chars(s, c) + [ch])\n{\n    if |s| == 0 {\n        // Base case: s is empty\n        assert s + [ch] == [ch];\n        if ch in c {\n            assert filter_chars([ch], c) == filter_chars(s, c);\n        } else {\n            assert filter_chars([ch], c) == [ch];\n            assert filter_chars(s, c) + [ch] == [] + [ch] == [ch];\n        }\n    } else {\n        // Recursive case\n        assert s + [ch] == [s[0]] + (s[1..] + [ch]);\n        filter_chars_append_lemma(s[1..], ch, c);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod reverse_delete(s: seq<char>, c: seq<char>) returns (result: (seq<char>, bool))\n    ensures result.0 == filter_chars(s, c)\n    ensures result.1 == (result.0 == reverse(result.0))\n    ensures |result.0| <= |s|\n    ensures forall i :: 0 <= i < |result.0| ==> result.0[i] !in c\n    ensures forall i :: 0 <= i < |result.0| ==> result.0[i] in s", "vc-code": "{\n    // Filter out characters that appear in c\n    var filtered := [];\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant filtered == filter_chars(s[..i], c)\n        invariant |filtered| <= i\n        invariant forall j :: 0 <= j < |filtered| ==> filtered[j] !in c\n        invariant forall j :: 0 <= j < |filtered| ==> filtered[j] in s[..i]\n    {\n        if s[i] !in c {\n            filtered := filtered + [s[i]];\n        }\n        assert s[..(i+1)] == s[..i] + [s[i]];\n        filter_chars_append_lemma(s[..i], s[i], c);\n        assert filtered == filter_chars(s[..(i+1)], c);\n    }\n\n    assert s[..|s|] == s;\n    assert filtered == filter_chars(s, c);\n\n    // Check if palindrome\n    var is_palindrome := filtered == reverse(filtered);\n\n    result := (filtered, is_palindrome);\n}", "vc-postamble": ""}
{"id": "HumanEval_46", "vc-description": "This task implements an iterative solution to compute the n-th element of the Fib4 sequence. The Fib4 sequence is defined with base cases fib4(0)=0, fib4(1)=0, fib4(2)=2, fib4(3)=0, and for n≥4, fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\nThe implementation must be iterative and efficient, using a sliding window approach to maintain the last 4 values instead of recursion, while proving equivalence to the recursive specification.", "vc-preamble": "// ======= TASK =======\n// Compute the n-th element of the Fib4 sequence, defined as:\n// fib4(0) = 0, fib4(1) = 0, fib4(2) = 2, fib4(3) = 0\n// fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) for n >= 4\n// The solution must be iterative and efficient.\n\n// ======= SPEC REQUIREMENTS =======\nfunction fib4_func(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0\n    else if n == 1 then 0\n    else if n == 2 then 2\n    else if n == 3 then 0\n    else fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod fib4(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == fib4_func(n)\n    ensures n == 0 ==> result == 0\n    ensures n == 1 ==> result == 0\n    ensures n == 2 ==> result == 2\n    ensures n == 3 ==> result == 0\n    ensures n >= 4 ==> result == fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4)", "vc-code": "{\n    // Base cases\n    if n == 0 {\n        result := 0;\n    } else if n == 1 {\n        result := 0;\n    } else if n == 2 {\n        result := 2;\n    } else if n == 3 {\n        result := 0;\n    } else {\n        // For n >= 4, use iterative approach\n        // Keep track of the last 4 values\n        var a := 0;  // fib4(0)\n        var b := 0;  // fib4(1)\n        var c := 2;  // fib4(2)\n        var d := 0;  // fib4(3)\n\n        // Compute fib4(4) through fib4(n)\n        var i := 4;\n        while i <= n\n            invariant 4 <= i <= n + 1\n            invariant i == 4 ==> (a == fib4_func(0) && b == fib4_func(1) && c == fib4_func(2) && d == fib4_func(3))\n            invariant i > 4 ==> (a == fib4_func(i-4) && b == fib4_func(i-3) && c == fib4_func(i-2) && d == fib4_func(i-1))\n        {\n            var next_val := a + b + c + d;\n            // Shift the window: move everything one position left\n            a := b;\n            b := c;\n            c := d;\n            d := next_val;\n            i := i + 1;\n        }\n\n        result := d;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_63", "vc-description": "This verification task involves implementing the FibFib sequence, which is a modified Fibonacci sequence. The FibFib sequence is defined with base cases fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1, and for n >= 3, fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3). The expected implementation should efficiently compute the n-th element using dynamic programming rather than naive recursion.", "vc-preamble": "// ======= TASK =======\n// Compute the n-th element of the FibFib sequence, which is defined by:\n// fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1\n// fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3) for n >= 3\n\n// ======= SPEC REQUIREMENTS =======\nfunction fibfib_spec(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0\n    else if n == 1 then 0\n    else if n == 2 then 1\n    else fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod fibfib(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == fibfib_spec(n)\n    ensures n == 0 ==> result == 0\n    ensures n == 1 ==> result == 0\n    ensures n == 2 ==> result == 1\n    ensures n >= 3 ==> result == fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3)", "vc-code": "{\n    // Handle base cases\n    if n == 0 {\n        result := 0;\n    } else if n == 1 {\n        result := 0;\n    } else if n == 2 {\n        result := 1;\n    } else {\n        // Use dynamic programming for efficiency\n        // Keep track of the last three values\n        var a := 0;  // fibfib(0)\n        var b := 0;  // fibfib(1)\n        var c := 1;  // fibfib(2)\n\n        // Compute iteratively from 3 to n\n        var i := 3;\n        while i <= n\n            invariant 3 <= i <= n + 1\n            invariant a == fibfib_spec(i-3)\n            invariant b == fibfib_spec(i-2)\n            invariant c == fibfib_spec(i-1)\n        {\n            var next_val := a + b + c;\n            a := b;\n            b := c;\n            c := next_val;\n            i := i + 1;\n        }\n\n        result := c;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_7", "vc-description": "This task implements a string filtering function that takes a list of strings and a substring, returning a new list containing only the strings that contain the given substring. The filtering should preserve the original order of matching strings and be case-sensitive.", "vc-preamble": "// ======= TASK =======\n// Given a list of strings and a substring, return a new list containing only the strings that contain the given substring.\n// The filtering should preserve the original order of matching strings and be case-sensitive.\n\n// ======= SPEC REQUIREMENTS =======\nfunction contains_substring(s: string, sub: string): bool\n{\n    if |sub| == 0 then true\n    else if |sub| > |s| then false\n    else exists i {:trigger s[i..i+|sub|]} :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub\n}\n\nfunction filter_sequence(strings: seq<string>, substring: string): seq<string>\n{\n    filter_sequence_helper(strings, substring, |strings|)\n}\n\nfunction filter_sequence_helper(strings: seq<string>, substring: string, n: int): seq<string>\n    requires 0 <= n <= |strings|\n{\n    if n == 0 then []\n    else if contains_substring(strings[n-1], substring) then\n        filter_sequence_helper(strings, substring, n-1) + [strings[n-1]]\n    else\n        filter_sequence_helper(strings, substring, n-1)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)\n    ensures |result| <= |strings|\n    ensures forall i :: 0 <= i < |result| ==> result[i] in strings\n    ensures forall i :: 0 <= i < |result| ==> contains_substring(result[i], substring)\n    ensures forall i :: 0 <= i < |strings| && contains_substring(strings[i], substring) ==> strings[i] in result\n    ensures forall i, j :: 0 <= i < j < |result| ==> \n        exists k1, k2 :: 0 <= k1 < k2 < |strings| && result[i] == strings[k1] && result[j] == strings[k2]\n    ensures forall s :: s in result <==> (s in strings && contains_substring(s, substring))\n    ensures result == filter_sequence(strings, substring)", "vc-code": "{\n    result := [];\n    for i := 0 to |strings|\n        invariant 0 <= i <= |strings|\n        invariant |result| <= i\n        invariant forall k :: 0 <= k < |result| ==> result[k] in strings\n        invariant forall k :: 0 <= k < |result| ==> contains_substring(result[k], substring)\n        invariant forall k :: 0 <= k < i && contains_substring(strings[k], substring) ==> strings[k] in result\n        invariant forall k1, k2 :: 0 <= k1 < k2 < |result| ==> \n            exists idx1, idx2 :: 0 <= idx1 < idx2 < i && result[k1] == strings[idx1] && result[k2] == strings[idx2]\n        invariant forall s :: s in result <==> (s in strings && contains_substring(s, substring) && exists idx :: 0 <= idx < i && s == strings[idx])\n        invariant result == filter_sequence_helper(strings, substring, i)\n    {\n        if contains_substring(strings[i], substring) {\n            result := result + [strings[i]];\n        }\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_161", "vc-description": "This task involves implementing a string transformation method that applies one of two operations based on whether the string contains letters. If the string has at least one letter, swap the case of each letter (lowercase ↔ uppercase) while keeping non-letters unchanged. If the string contains no letters, reverse the entire string.", "vc-preamble": "// ======= TASK =======\n// Given a string, apply one of two transformations:\n// 1. If the string contains at least one letter: swap the case of each letter (lowercase ↔ uppercase), keep non-letters unchanged\n// 2. If the string contains no letters: reverse the entire string\n\n// ======= SPEC REQUIREMENTS =======\nfunction hasLetter(s: string): bool\n{\n    exists i :: 0 <= i < |s| && (('A' <= s[i] <= 'Z') || ('a' <= s[i] <= 'z'))\n}\n\nfunction reverseString(s: string): string\n    ensures |reverseString(s)| == |s|\n{\n    if |s| == 0 then s else s[|s|-1..] + reverseString(s[..|s|-1])\n}\n\nfunction swapCase(c: char): char\n{\n    if 'A' <= c <= 'Z' then (c as int + 32) as char\n    else if 'a' <= c <= 'z' then (c as int - 32) as char\n    else c\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(s: string) returns (result: string)\n    ensures if hasLetter(s) then\n        |result| == |s| && \n        (forall i :: 0 <= i < |s| ==> result[i] == swapCase(s[i]))\n    else\n        result == reverseString(s)\n    ensures |result| == |s|", "vc-code": "{\n    if hasLetter(s) {\n        var chars := [];\n        var i := 0;\n\n        while i < |s|\n            invariant 0 <= i <= |s|\n            invariant |chars| == i\n            invariant forall j :: 0 <= j < i ==> chars[j] == swapCase(s[j])\n        {\n            if 'A' <= s[i] <= 'Z'\n            {\n                // Convert uppercase to lowercase\n                var tmpCall1 := (s[i] as int + 32) as char;\n                chars := chars + [tmpCall1];\n            }\n            else if 'a' <= s[i] <= 'z'\n            {\n                // Convert lowercase to uppercase  \n                var tmpCall2 := (s[i] as int - 32) as char;\n                chars := chars + [tmpCall2];\n            }\n            else\n            {\n                // Keep other characters unchanged\n                chars := chars + [s[i]];\n            }\n            i := i + 1;\n        }\n\n        result := chars;\n    } else {\n        result := reverseString(s);\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_80", "vc-description": "This task involves determining if a string is \"happy\". A string is considered happy if it has a length of at least 3 characters and in every substring of 3 consecutive characters, all characters are distinct (no duplicates). The implementation should efficiently check this condition and return the appropriate boolean result.", "vc-preamble": "// ======= TASK =======\n// Given a string s, determine if it is \"happy\". A string is happy if and only if:\n// 1. Its length is at least 3, AND\n// 2. In every substring of 3 consecutive characters, all characters are distinct (no duplicates)\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidLength(s: string)\n{\n    |s| >= 3\n}\n\npredicate AllWindowsDistinct(s: string)\n{\n    forall i :: 0 <= i <= |s| - 3 ==> s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2]\n}\n\npredicate IsHappy(s: string)\n{\n    ValidLength(s) && AllWindowsDistinct(s)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod is_happy(s: string) returns (result: bool)\n    ensures result == IsHappy(s)", "vc-code": "{\n    if |s| < 3 {\n        return false;\n    }\n\n    var i := 0;\n    while i <= |s| - 3 \n        invariant 0 <= i <= |s| - 2\n        invariant forall j :: 0 <= j < i ==> s[j] != s[j+1] && s[j] != s[j+2] && s[j+1] != s[j+2]\n    {\n        if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {\n            return false;\n        }\n        i := i + 1;\n    }\n\n    return true;\n}", "vc-postamble": ""}
{"id": "HumanEval_57", "vc-description": "This verification task implements a function to determine if a list of numbers is monotonic. A list is monotonic if it is either entirely non-decreasing (monotonically increasing) or entirely non-increasing (monotonically decreasing). Empty lists and single-element lists are considered monotonic, and lists with equal consecutive elements are allowed.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers, determine if the list is monotonic. A list is monotonic \n// if it is either entirely non-decreasing (monotonically increasing) or entirely \n// non-increasing (monotonically decreasing). Empty lists and single-element lists \n// are considered monotonic. Lists with equal consecutive elements are allowed.\n\n// ======= SPEC REQUIREMENTS =======\nfunction monotonic(l: seq<int>): bool\n    ensures |l| <= 1 ==> monotonic(l) == true\n    ensures |l| > 1 ==> monotonic(l) == (\n        (forall i :: 0 <= i < |l| - 1 ==> l[i] <= l[i + 1]) ||\n        (forall i :: 0 <= i < |l| - 1 ==> l[i] >= l[i + 1])\n    )\n{\n    if |l| <= 1 then true\n    else\n        var increasing := forall i :: 0 <= i < |l| - 1 ==> l[i] <= l[i + 1];\n        var decreasing := forall i :: 0 <= i < |l| - 1 ==> l[i] >= l[i + 1];\n        increasing || decreasing\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod IsMonotonic(l: seq<int>) returns (result: bool)\n    ensures result == monotonic(l)", "vc-code": "{\n    if |l| <= 1 {\n        return true;\n    }\n    \n    var increasing := true;\n    var decreasing := true;\n    \n    var i := 0;\n    while i < |l| - 1\n        invariant 0 <= i <= |l| - 1\n        invariant increasing == (forall j :: 0 <= j < i ==> l[j] <= l[j + 1])\n        invariant decreasing == (forall j :: 0 <= j < i ==> l[j] >= l[j + 1])\n    {\n        if l[i] > l[i + 1] {\n            increasing := false;\n        }\n        if l[i] < l[i + 1] {\n            decreasing := false;\n        }\n        i := i + 1;\n    }\n    \n    result := increasing || decreasing;\n}", "vc-postamble": ""}
{"id": "HumanEval_144", "vc-description": "This verification challenge involves implementing a method that determines if the product of two fractions is a whole number. Given two fractions represented as strings in the format \"numerator/denominator\", the task is to multiply them and check if the result is an integer (i.e., the numerator of the product is divisible by the denominator).\n\nThe implementation must correctly parse the fraction strings, extract numerators and denominators, perform the multiplication, and check divisibility while maintaining all verification conditions.", "vc-preamble": "// ======= TASK =======\n// Given two fractions represented as strings in the format \"numerator/denominator\",\n// determine if their product is a whole number. Input consists of two strings x and n,\n// each representing a valid fraction where both numerator and denominator are positive\n// integers and denominators are never zero. Return true if x * n equals a whole number,\n// false otherwise.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidFraction(s: string)\n{\n    |s| > 0 && \n    (exists i :: 0 <= i < |s| && s[i] == '/') &&\n    (forall j :: 0 <= j < |s| ==> (s[j] == '/' || ('0' <= s[j] <= '9'))) &&\n    (exists k :: 0 <= k < |s| && s[k] == '/' && \n        |s[0..k]| > 0 && |s[k+1..]| > 0 &&\n        StringToInt(s[0..k]) > 0 && StringToInt(s[k+1..]) > 0) &&\n    (forall i :: 0 <= i < |s| && s[i] == '/' ==> \n        |s[0..i]| > 0 && |s[i+1..]| > 0 &&\n        StringToInt(s[0..i]) > 0 && StringToInt(s[i+1..]) > 0)\n}\n\nfunction GetNumerator(s: string): int\n    requires ValidFraction(s)\n{\n    var slash_pos := FindSlash(s);\n    StringToInt(s[0..slash_pos])\n}\n\nfunction GetDenominator(s: string): int\n    requires ValidFraction(s)\n    ensures GetDenominator(s) > 0\n{\n    var slash_pos := FindSlash(s);\n    StringToInt(s[slash_pos+1..])\n}\n\nfunction FindSlash(s: string): int\n    requires exists i :: 0 <= i < |s| && s[i] == '/'\n    ensures 0 <= FindSlash(s) < |s|\n    ensures s[FindSlash(s)] == '/'\n{\n    FindSlashHelper(s, 0)\n}\n\nfunction StringToInt(s: string): int\n{\n    StringToIntHelper(s, 0)\n}\n\nfunction CharToInt(c: char): int\n{\n    if c == '0' then 0\n    else if c == '1' then 1\n    else if c == '2' then 2\n    else if c == '3' then 3\n    else if c == '4' then 4\n    else if c == '5' then 5\n    else if c == '6' then 6\n    else if c == '7' then 7\n    else if c == '8' then 8\n    else if c == '9' then 9\n    else 0\n}", "vc-helpers": "// ======= HELPERS =======\nfunction FindSlashHelper(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires exists i :: pos <= i < |s| && s[i] == '/'\n    ensures pos <= FindSlashHelper(s, pos) < |s|\n    ensures s[FindSlashHelper(s, pos)] == '/'\n    decreases |s| - pos\n{\n    if pos < |s| && s[pos] == '/' then pos\n    else FindSlashHelper(s, pos + 1)\n}\n\nfunction StringToIntHelper(s: string, acc: int): int\n{\n    if |s| == 0 then acc\n    else StringToIntHelper(s[1..], acc * 10 + CharToInt(s[0]))\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod simplify(x: string, n: string) returns (result: bool)\n    requires |x| > 0 && |n| > 0\n    requires exists i :: 0 <= i < |x| && x[i] == '/'\n    requires exists j :: 0 <= j < |n| && n[j] == '/'\n    requires forall i :: 0 <= i < |x| ==> (x[i] == '/' || ('0' <= x[i] <= '9'))\n    requires forall j :: 0 <= j < |n| ==> (n[j] == '/' || ('0' <= n[j] <= '9'))\n    requires ValidFraction(x)\n    requires ValidFraction(n)\n    ensures result <==> (GetNumerator(x) * GetNumerator(n)) % (GetDenominator(x) * GetDenominator(n)) == 0", "vc-code": "{\n    // Find the '/' in x\n    var x_slash_pos := 0;\n    while x_slash_pos < |x| && x[x_slash_pos] != '/'\n        invariant x_slash_pos <= |x|\n    {\n        x_slash_pos := x_slash_pos + 1;\n    }\n\n    // Find the '/' in n\n    var n_slash_pos := 0;\n    while n_slash_pos < |n| && n[n_slash_pos] != '/'\n        invariant n_slash_pos <= |n|\n    {\n        n_slash_pos := n_slash_pos + 1;\n    }\n\n    // Extract parts\n    var x_num_str := x[0..x_slash_pos];\n    var x_den_str := x[x_slash_pos+1..];\n    var n_num_str := n[0..n_slash_pos];\n    var n_den_str := n[n_slash_pos+1..];\n\n    // Convert to integers\n    var x_num := StringToInt(x_num_str);\n    var x_den := StringToInt(x_den_str);\n    var n_num := StringToInt(n_num_str);\n    var n_den := StringToInt(n_den_str);\n\n    // Multiply fractions: (x_num/x_den) * (n_num/n_den) = (x_num * n_num) / (x_den * n_den)\n    var result_num := x_num * n_num;\n    var result_den := x_den * n_den;\n\n    // Check if the result is a whole number (numerator divisible by denominator)\n    result := result_num % result_den == 0;\n}", "vc-postamble": ""}
{"id": "HumanEval_59", "vc-description": "This verification task implements an algorithm to find the largest prime factor of a composite integer n (where n > 1 and n is not prime). The algorithm uses trial division, first removing all factors of 2, then checking odd factors up to the square root of the remaining number.\n\nThe implementation must ensure that the returned result is indeed a prime number, divides n, and is the largest such prime factor among all factors of n.", "vc-preamble": "// ======= TASK =======\n// Given a composite integer n (where n > 1 and n is not prime), find and return its largest prime factor.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_prime(n: int)\n{\n    n > 1 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nfunction power_of_2_factor(n: int, current: int): int\n    requires n > 0 && current > 0\n    decreases current\n{\n    if current % 2 != 0 then 1\n    else 2 * power_of_2_factor(n, current / 2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod largest_prime_factor(n: int) returns (result: int)\n    requires n > 1\n    requires !is_prime(n)\n    ensures result > 1\n    ensures n % result == 0\n    ensures forall k :: k > result && n % k == 0 ==> !is_prime(k)\n    ensures is_prime(result)", "vc-code": "{\n    var largest_factor := 1;\n    var current_n := n;\n\n    while current_n % 2 == 0\n        invariant current_n > 0\n        invariant current_n * power_of_2_factor(n, n / current_n) == n\n        decreases current_n\n    {\n        largest_factor := 2;\n        current_n := current_n / 2;\n    }\n\n    var factor := 3;\n    while factor * factor <= current_n\n        invariant factor >= 3\n        invariant factor % 2 == 1\n        invariant current_n > 0\n        invariant largest_factor >= 1\n        invariant largest_factor > 1 ==> n % largest_factor == 0\n        invariant largest_factor > 1 ==> is_prime(largest_factor)\n        invariant forall k :: 1 < k < factor && n % k == 0 ==> k <= largest_factor\n        invariant forall k :: largest_factor < k < factor && n % k == 0 ==> !is_prime(k)\n        invariant current_n > 1 ==> forall k :: 2 <= k < factor && current_n % k == 0 ==> false\n        decreases current_n - factor + 1\n    {\n        while current_n % factor == 0\n            invariant current_n > 0\n            invariant factor >= 3\n            invariant is_prime(factor)\n            decreases current_n\n        {\n            largest_factor := factor;\n            current_n := current_n / factor;\n        }\n        factor := factor + 2;\n    }\n\n    if current_n > 1 {\n        largest_factor := current_n;\n    }\n\n    result := largest_factor;\n}", "vc-postamble": ""}
{"id": "HumanEval_35", "vc-description": "Find and return the maximum element in a given list of numbers. The list must be non-empty, and the maximum element is the largest value present in the list, which must be an actual element of the list.", "vc-preamble": "// ======= TASK =======\n// Find and return the maximum element in a given list of numbers.\n// The list must be non-empty. The maximum element is the largest value\n// present in the list, and it must be an actual element of the list.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(l: seq<int>)\n{\n    |l| > 0\n}\n\npredicate IsMaxElement(l: seq<int>, max_val: int)\n{\n    max_val in l && forall i :: 0 <= i < |l| ==> l[i] <= max_val\n}", "vc-helpers": "function max_element_func(l: seq<int>): int\n    requires |l| > 0\n    ensures max_element_func(l) in l\n    ensures forall i :: 0 <= i < |l| ==> l[i] <= max_element_func(l)\n{\n    if |l| == 1 then l[0]\n    else\n        var rest_max := max_element_func(l[1..]);\n        if l[0] > rest_max then l[0] else rest_max\n}", "vc-spec": "method FindMaxElement(l: seq<int>) returns (max_val: int)\n    requires ValidInput(l)\n    ensures IsMaxElement(l, max_val)", "vc-code": "{\n    max_val := max_element_func(l);\n}", "vc-postamble": ""}
{"id": "HumanEval_157", "vc-description": "This verification task involves implementing a method to determine if three positive numbers representing triangle side lengths form a right-angled triangle. The implementation must check both that the sides form a valid triangle (positive lengths satisfying triangle inequality) and that they satisfy the Pythagorean theorem.", "vc-preamble": "// ======= TASK =======\n// Given three positive numbers representing triangle side lengths, determine if they form a right-angled triangle.\n// A right-angled triangle satisfies the Pythagorean theorem: the sum of squares of the two shorter sides equals\n// the square of the longest side. All sides must be positive and satisfy the triangle inequality.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidTriangle(a: real, b: real, c: real)\n{\n    a > 0.0 && b > 0.0 && c > 0.0 &&\n    a + b > c && a + c > b && b + c > a\n}\n\npredicate IsRightTriangle(a: real, b: real, c: real)\n{\n    a * a + b * b == c * c || \n    a * a + c * c == b * b || \n    b * b + c * c == a * a\n}\n\npredicate ValidRightTriangle(a: real, b: real, c: real)\n{\n    ValidTriangle(a, b, c) && IsRightTriangle(a, b, c)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod right_angle_triangle(a: real, b: real, c: real) returns (result: bool)\n    ensures result <==> ValidRightTriangle(a, b, c)", "vc-code": "{\n    // First check if the sides can form a valid triangle\n    // Triangle inequality: sum of any two sides must be greater than the third side\n    if a + b <= c || a + c <= b || b + c <= a {\n        return false;\n    }\n\n    // Check if any side is non-positive\n    if a <= 0.0 || b <= 0.0 || c <= 0.0 {\n        return false;\n    }\n\n    // At this point we know ValidTriangle(a, b, c) is true\n    assert ValidTriangle(a, b, c);\n\n    // Find the longest side (hypotenuse)\n    var hypotenuse: real;\n    var side1: real;\n    var side2: real;\n\n    if a >= b && a >= c {\n        hypotenuse := a;\n        side1 := b;\n        side2 := c;\n        assert hypotenuse == a && side1 == b && side2 == c;\n        assert side1 * side1 + side2 * side2 == hypotenuse * hypotenuse <==> b * b + c * c == a * a;\n    } else if b >= a && b >= c {\n        hypotenuse := b;\n        side1 := a;\n        side2 := c;\n        assert hypotenuse == b && side1 == a && side2 == c;\n        assert side1 * side1 + side2 * side2 == hypotenuse * hypotenuse <==> a * a + c * c == b * b;\n    } else {\n        hypotenuse := c;\n        side1 := a;\n        side2 := b;\n        assert hypotenuse == c && side1 == a && side2 == b;\n        assert side1 * side1 + side2 * side2 == hypotenuse * hypotenuse <==> a * a + b * b == c * c;\n    }\n\n    // Apply Pythagorean theorem: side1² + side2² = hypotenuse²\n    var is_right := side1 * side1 + side2 * side2 == hypotenuse * hypotenuse;\n    \n    // Help Dafny understand the equivalence\n    assert is_right ==> IsRightTriangle(a, b, c);\n    assert !is_right ==> !IsRightTriangle(a, b, c);\n    \n    return is_right;\n}", "vc-postamble": ""}
{"id": "HumanEval_20", "vc-description": "Given a list of numbers with at least two elements, find the pair of numbers with the smallest absolute difference between them. Return the pair as a tuple ordered from smaller to larger value. The implementation uses nested loops to compare all pairs and track the minimum difference found.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers with at least two elements, find the pair of numbers \n// with the smallest absolute difference between them. Return the pair as a tuple \n// ordered from smaller to larger value.\n\n// ======= SPEC REQUIREMENTS =======\nfunction AbsDiff(x: real, y: real): real\n{\n  if x >= y then x - y else y - x\n}\n\npredicate ValidInput(numbers: seq<real>)\n{\n  |numbers| >= 2\n}\n\npredicate IsOptimalPair(numbers: seq<real>, pair: (real, real))\n{\n  pair.0 in numbers &&\n  pair.1 in numbers &&\n  pair.0 <= pair.1 &&\n  forall i, j :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j ==>\n    AbsDiff(numbers[i], numbers[j]) >= AbsDiff(pair.0, pair.1)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod find_closest_elements(numbers: seq<real>) returns (result: (real, real))\n  requires ValidInput(numbers)\n  ensures IsOptimalPair(numbers, result)", "vc-code": "{\n  var min_diff := AbsDiff(numbers[0], numbers[1]);\n  var closest_pair := (numbers[0], numbers[1]);\n\n  for i := 0 to |numbers| - 1\n    invariant closest_pair.0 in numbers\n    invariant closest_pair.1 in numbers\n    invariant min_diff == AbsDiff(closest_pair.0, closest_pair.1)\n    invariant forall k, l :: 0 <= k < |numbers| && 0 <= l < |numbers| && k != l && k < i ==>\n      AbsDiff(numbers[k], numbers[l]) >= min_diff\n  {\n    for j := i + 1 to |numbers|\n      invariant closest_pair.0 in numbers\n      invariant closest_pair.1 in numbers\n      invariant min_diff == AbsDiff(closest_pair.0, closest_pair.1)\n      invariant forall k, l :: 0 <= k < |numbers| && 0 <= l < |numbers| && k != l && \n                ((k < i) || (k == i && i < l < j)) ==>\n        AbsDiff(numbers[k], numbers[l]) >= min_diff\n    {\n      var diff := AbsDiff(numbers[i], numbers[j]);\n      if diff < min_diff {\n        min_diff := diff;\n        closest_pair := (numbers[i], numbers[j]);\n      }\n    }\n  }\n\n  if closest_pair.0 <= closest_pair.1 {\n    result := closest_pair;\n  } else {\n    result := (closest_pair.1, closest_pair.0);\n  }\n}", "vc-postamble": ""}
{"id": "HumanEval_140", "vc-description": "This verification task involves implementing a string transformation method that replaces spaces according to specific rules: individual spaces or pairs of consecutive spaces become underscores (one per space), while sequences of more than 2 consecutive spaces become a single dash. The implementation must preserve the order of non-space characters and satisfy several correctness predicates.", "vc-preamble": "// ======= TASK =======\n// Given a string, transform all spaces according to these rules:\n// - Replace each individual space or pair of consecutive spaces with underscores (one underscore per space)\n// - Replace any sequence of more than 2 consecutive spaces with a single dash \"-\"\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(text: string)\n{\n    true\n}\n\npredicate IsSpaceSequence(text: string, start: int, end: int)\n    requires 0 <= start <= end < |text|\n{\n    (forall k :: start <= k <= end ==> text[k] == ' ') &&\n    (start == 0 || text[start-1] != ' ') &&\n    (end == |text|-1 || text[end+1] != ' ')\n}\n\npredicate ValidResult(text: string, result: string)\n{\n    |result| <= |text| &&\n    (text == \"\" ==> result == \"\") &&\n    (forall i :: 0 <= i < |result| ==> result[i] != ' ') &&\n    (forall i :: 0 <= i < |result| ==> result[i] == '_' || result[i] == '-' || result[i] in text) &&\n    ((forall i :: 0 <= i < |text| ==> text[i] != ' ') ==> result == text) &&\n    (forall i :: 0 <= i < |text| && text[i] != ' ' ==> text[i] in result)\n}\n\npredicate PreservesOrder(text: string, result: string)\n{\n    forall i, j :: 0 <= i < j < |text| && text[i] != ' ' && text[j] != ' ' ==>\n        exists i', j' :: 0 <= i' < j' < |result| && result[i'] == text[i] && result[j'] == text[j]\n}\n\npredicate CorrectSpaceTransformation(text: string, result: string)\n{\n    (forall start, end :: 0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end) ==>\n        (end - start + 1 <= 2 ==> exists pos :: 0 <= pos < |result| - (end - start) && \n            (forall i :: pos <= i <= pos + (end - start) ==> result[i] == '_')) &&\n        (end - start + 1 > 2 ==> exists pos :: 0 <= pos < |result| && result[pos] == '-')) &&\n    (forall i :: 0 <= i < |result| && result[i] == '_' ==> \n        exists start, end :: 0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end) && end - start + 1 <= 2) &&\n    (forall i :: 0 <= i < |result| && result[i] == '-' ==> \n        exists start, end :: 0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end) && end - start + 1 > 2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod fix_spaces(text: string) returns (result: string)\n    requires ValidInput(text)\n    ensures ValidResult(text, result)\n    ensures PreservesOrder(text, result)\n    ensures CorrectSpaceTransformation(text, result)", "vc-code": "{\n    if |text| == 0 {\n        return text;\n    }\n\n    var resultSeq: seq<char> := [];\n    var i := 0;\n\n    while i < |text|\n        invariant 0 <= i <= |text|\n        invariant |resultSeq| <= i\n        invariant forall j :: 0 <= j < |resultSeq| ==> resultSeq[j] != ' '\n        invariant forall j :: 0 <= j < |resultSeq| ==> resultSeq[j] == '_' || resultSeq[j] == '-' || resultSeq[j] in text\n        invariant forall k :: 0 <= k < i && text[k] != ' ' ==> text[k] in resultSeq\n        invariant (forall k :: 0 <= k < i ==> text[k] != ' ') ==> resultSeq == text[0..i]\n    {\n        if text[i] == ' ' {\n            // Count consecutive spaces\n            var spaceCount := 0;\n            var j := i;\n            while j < |text| && text[j] == ' '\n                invariant i <= j <= |text|\n                invariant spaceCount == j - i\n                invariant forall k :: i <= k < j ==> text[k] == ' '\n            {\n                spaceCount := spaceCount + 1;\n                j := j + 1;\n            }\n\n            // Replace based on count\n            if spaceCount > 2 {\n                resultSeq := resultSeq + ['-'];\n            } else {\n                var k := 0;\n                var initLen := |resultSeq|;\n                while k < spaceCount\n                    invariant 0 <= k <= spaceCount\n                    invariant |resultSeq| == initLen + k\n                    invariant forall m :: initLen <= m < |resultSeq| ==> resultSeq[m] == '_'\n                    invariant forall m :: 0 <= m < initLen ==> resultSeq[m] != ' '\n                    invariant forall m :: 0 <= m < initLen ==> resultSeq[m] == '_' || resultSeq[m] == '-' || resultSeq[m] in text\n                    invariant forall l :: 0 <= l < i && text[l] != ' ' ==> text[l] in resultSeq[0..initLen]\n                {\n                    resultSeq := resultSeq + ['_'];\n                    k := k + 1;\n                }\n            }\n\n            i := j;\n        } else {\n            resultSeq := resultSeq + [text[i]];\n            i := i + 1;\n        }\n    }\n\n    return resultSeq;\n}", "vc-postamble": ""}
{"id": "HumanEval_134", "vc-description": "This verification task involves implementing a method to determine if the last character of a string is an alphabetical character that stands alone (not part of a word). A \"word\" is defined as a group of characters separated by spaces. The method should return true if the last character is a letter AND is not part of a word, false otherwise. A standalone letter is either the entire string (single character) or a letter preceded by a space.", "vc-preamble": "// ======= TASK =======\n// Determine if the last character of a string is an alphabetical character that stands alone\n// (not part of a word). A \"word\" is defined as a group of characters separated by spaces.\n// Return True if the last character is a letter AND is not part of a word, False otherwise.\n// A standalone letter is either the entire string (single character) or a letter preceded by a space.\n\n// ======= SPEC REQUIREMENTS =======\npredicate IsAlpha(c: char)\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\npredicate ValidLastCharIsStandaloneLetter(txt: string)\n{\n    |txt| > 0 && IsAlpha(txt[|txt| - 1]) && (|txt| == 1 || txt[|txt| - 2] == ' ')\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod check_if_last_char_is_a_letter(txt: string) returns (result: bool)\n    ensures result == ValidLastCharIsStandaloneLetter(txt)", "vc-code": "{\n    // Check if string is empty\n    if |txt| == 0 {\n        return false;\n    }\n\n    // Get the last character\n    var lastChar := txt[|txt| - 1];\n\n    // Check if last character is alphabetical\n    if !IsAlpha(lastChar) {\n        return false;\n    }\n\n    // If string has only one character, it's not part of a word\n    if |txt| == 1 {\n        return true;\n    }\n\n    // Check if the character before the last one is a space\n    // This ensures the last character is not part of a word\n    return txt[|txt| - 2] == ' ';\n}", "vc-postamble": ""}
{"id": "HumanEval_44", "vc-description": "This verification task implements a function to convert an integer from base 10 to a specified base (where base < 10) and return its string representation. The implementation should correctly handle the conversion process by repeatedly dividing by the target base to extract digits, then reversing the resulting digit sequence to produce the final string representation.", "vc-preamble": "// ======= TASK =======\n// Convert an integer from base 10 to a specified base and return the string representation.\n// Input: x (integer in base 10), base (target base where base < 10)\n// Output: String representation of x in the specified base\n\n// ======= SPEC REQUIREMENTS =======\nfunction power_of_base(base: int, exp: int): int\n  requires base >= 2\n  requires exp >= 0\n  ensures power_of_base(base, exp) > 0\n{\n  if exp == 0 then 1 else base * power_of_base(base, exp - 1)\n}\n\nfunction digits_to_int(digits: seq<char>, base: int): int\n  requires base >= 2\n  requires forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base\n{\n  if |digits| == 0 then 0\n  else (digits[0] as int) - ('0' as int) + base * digits_to_int(digits[1..], base)\n}\n\nfunction string_to_int_in_base(s: string, base: int): int\n  requires base >= 2\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9' && (s[i] as int) - ('0' as int) < base\n  ensures string_to_int_in_base(s, base) >= 0\n{\n  if |s| == 1 then\n    (s[0] as int) - ('0' as int)\n  else\n    string_to_int_in_base(s[..|s|-1], base) * base + ((s[|s|-1] as int) - ('0' as int))\n}", "vc-helpers": "// ======= HELPERS =======\nlemma digits_reversal_lemma(digits: seq<char>, reversed: seq<char>, base: int)\n  requires base >= 2\n  requires |digits| == |reversed| > 0\n  requires forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base\n  requires forall i :: 0 <= i < |reversed| ==> reversed[i] == digits[|digits| - 1 - i]\n  ensures string_to_int_in_base(reversed, base) == digits_to_int(digits, base)\n{\n  if |digits| == 1 {\n    assert reversed[0] == digits[0];\n  } else {\n    var tail_digits := digits[1..];\n    var head_reversed := reversed[..|reversed|-1];\n\n    assert |tail_digits| == |head_reversed|;\n    assert forall i :: 0 <= i < |tail_digits| ==> head_reversed[i] == tail_digits[|tail_digits| - 1 - i];\n\n    digits_reversal_lemma(tail_digits, head_reversed, base);\n\n    assert string_to_int_in_base(reversed, base) == \n           string_to_int_in_base(head_reversed, base) * base + ((reversed[|reversed|-1] as int) - ('0' as int));\n    assert digits_to_int(digits, base) == \n           ((digits[0] as int) - ('0' as int)) + base * digits_to_int(tail_digits, base);\n    assert string_to_int_in_base(head_reversed, base) == digits_to_int(tail_digits, base);\n    assert reversed[|reversed|-1] == digits[0];\n  }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod change_base(x: int, base: int) returns (result: string)\n  requires base >= 2 && base < 10\n  requires x >= 0\n  ensures x == 0 ==> result == \"0\"\n  ensures x > 0 ==> |result| > 0 && result[0] != '0'\n  ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9' && (result[i] as int) - ('0' as int) < base\n  ensures x > 0 ==> string_to_int_in_base(result, base) == x", "vc-code": "{\n  if x == 0 {\n    return \"0\";\n  }\n\n  var digits: seq<char> := [];\n  var temp := x;\n\n  while temp > 0\n    invariant temp >= 0\n    invariant forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base\n    invariant x == temp * power_of_base(base, |digits|) + digits_to_int(digits, base)\n    decreases temp\n  {\n    var digit := temp % base;\n    var digit_char := ('0' as int + digit) as char;\n    digits := digits + [digit_char];\n    temp := temp / base;\n  }\n\n  assert temp == 0;\n  assert x == digits_to_int(digits, base);\n  assert |digits| > 0;\n  assert digits[|digits|-1] != '0';\n\n  var reversed_digits: seq<char> := [];\n  var i := |digits| - 1;\n  while i >= 0\n    invariant -1 <= i < |digits|\n    invariant |reversed_digits| == |digits| - 1 - i\n    invariant forall j :: 0 <= j < |reversed_digits| ==> reversed_digits[j] == digits[|digits| - 1 - j]\n    invariant forall j :: 0 <= j < |reversed_digits| ==> '0' <= reversed_digits[j] <= '9' && (reversed_digits[j] as int) - ('0' as int) < base\n    decreases i + 1\n  {\n    reversed_digits := reversed_digits + [digits[i]];\n    i := i - 1;\n  }\n\n  assert |reversed_digits| == |digits|;\n  assert |reversed_digits| > 0;\n  assert reversed_digits[0] == digits[|digits|-1];\n  assert reversed_digits[0] != '0';\n\n  digits_reversal_lemma(digits, reversed_digits, base);\n  assert string_to_int_in_base(reversed_digits, base) == x;\n\n  result := reversed_digits;\n}", "vc-postamble": ""}
{"id": "HumanEval_121", "vc-description": "This task requires implementing a method that calculates the sum of all odd numbers located at even-indexed positions in a non-empty sequence of integers. The positions are 0-indexed, so we consider positions 0, 2, 4, etc.", "vc-preamble": "// ======= TASK =======\n// Given a non-empty list of integers, return the sum of all odd numbers \n// that are located at even-indexed positions (0, 2, 4, ...).\n\n// ======= SPEC REQUIREMENTS =======\nfunction SumOddAtEvenPositions(lst: seq<int>, pos: int): int\n    requires 0 <= pos\n    decreases |lst| - pos\n{\n    if pos >= |lst| then 0\n    else if lst[pos] % 2 == 1 then lst[pos] + SumOddAtEvenPositions(lst, pos + 2)\n    else SumOddAtEvenPositions(lst, pos + 2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solution(lst: seq<int>) returns (result: int)\n    requires |lst| > 0\n    ensures result == SumOddAtEvenPositions(lst, 0)", "vc-code": "{\n    result := 0;\n    var i := 0;\n    while i < |lst|\n        invariant 0 <= i\n        invariant i % 2 == 0\n        invariant result + SumOddAtEvenPositions(lst, i) == SumOddAtEvenPositions(lst, 0)\n    {\n        if lst[i] % 2 == 1 {\n            result := result + lst[i];\n        }\n        i := i + 2;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_126", "vc-description": "This verification task checks if a list of non-negative integers satisfies two conditions: (1) the list is sorted in non-decreasing (ascending) order, and (2) no number appears more than twice in the list. The implementation uses helper functions to check these conditions efficiently and returns true if both are met, false otherwise.", "vc-preamble": "// ======= TASK =======\n// Given a list of non-negative integers, return True if both conditions are met:\n// 1. The list is sorted in non-decreasing (ascending) order\n// 2. No number appears more than twice in the list\n// Otherwise, return False.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(lst: seq<int>)\n{\n    forall i :: 0 <= i < |lst| ==> lst[i] >= 0\n}\n\npredicate IsSortedAscending(lst: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |lst| ==> lst[i] <= lst[j]\n}\n\npredicate NoMoreThanTwoDuplicates(lst: seq<int>)\n{\n    forall i :: 0 <= i < |lst| ==> count_occurrences(lst, lst[i]) <= 2\n}\n\npredicate ValidList(lst: seq<int>)\n{\n    ValidInput(lst) && IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)\n}", "vc-helpers": "// ======= HELPERS =======\nfunction count_occurrences(lst: seq<int>, value: int): int\n    ensures count_occurrences(lst, value) >= 0\n    ensures count_occurrences(lst, value) <= |lst|\n    ensures count_occurrences(lst, value) == 0 <==> value !in lst\n{\n    if |lst| == 0 then 0\n    else if lst[0] == value then 1 + count_occurrences(lst[1..], value)\n    else count_occurrences(lst[1..], value)\n}\n\nfunction has_more_than_two_occurrences(lst: seq<int>, index: int): bool\n    requires 0 <= index <= |lst|\n    ensures has_more_than_two_occurrences(lst, index) == (exists i :: index <= i < |lst| && count_occurrences(lst, lst[i]) > 2)\n    decreases |lst| - index\n{\n    if index == |lst| then false\n    else if count_occurrences(lst, lst[index]) > 2 then true\n    else has_more_than_two_occurrences(lst, index + 1)\n}\n\nfunction is_sorted_ascending(lst: seq<int>, index: int): bool\n    requires 0 <= index <= |lst|\n    ensures is_sorted_ascending(lst, index) == (forall i, j :: index <= i < j < |lst| ==> lst[i] <= lst[j])\n    decreases |lst| - index\n{\n    if index >= |lst| - 1 then true\n    else if lst[index] > lst[index + 1] then false\n    else is_sorted_ascending(lst, index + 1)\n}\n\nfunction is_sorted(lst: seq<int>): bool\n    requires ValidInput(lst)\n    ensures |lst| <= 1 ==> is_sorted(lst) == true\n    ensures is_sorted(lst) == (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst))\n{\n    if |lst| <= 1 then true\n    else if !is_sorted_ascending(lst, 0) then false\n    else !has_more_than_two_occurrences(lst, 0)\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod CheckValidList(lst: seq<int>) returns (result: bool)\n    requires ValidInput(lst)\n    ensures result == ValidList(lst)\n    ensures result == (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst))", "vc-code": "{\n    result := is_sorted(lst);\n}", "vc-postamble": ""}
{"id": "HumanEval_42", "vc-description": "This task implements a function to increment each element in a list of integers by 1. Given a sequence of integers, the function should return a new sequence where each element is the corresponding element from the input sequence plus one.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, return a new list where each element is incremented by 1.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(l: seq<int>)\n{\n    true\n}\n\npredicate CorrectOutput(l: seq<int>, result: seq<int>)\n{\n    |result| == |l| && \n    forall i :: 0 <= i < |l| ==> result[i] == l[i] + 1\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod incr_list(l: seq<int>) returns (result: seq<int>)\n    requires ValidInput(l)\n    ensures CorrectOutput(l, result)", "vc-code": "{\n    var tmpCall1 := seq(|l|, i requires 0 <= i < |l| => l[i] + 1);\n    result := tmpCall1;\n}", "vc-postamble": ""}
{"id": "HumanEval_159", "vc-description": "This verification task involves implementing a method that calculates carrot consumption for a rabbit. Given the number of carrots already eaten, the number of additional carrots needed, and the number of carrots remaining in stock, the method should return the total carrots that will be eaten and how many carrots will be left. The rabbit will eat as many carrots as possible from the remaining stock, up to the number needed.", "vc-preamble": "// ======= TASK =======\n// Given the number of carrots already eaten, the number of additional carrots needed,\n// and the number of carrots remaining in stock, calculate the total carrots that will be\n// eaten and how many carrots will be left. The rabbit will eat as many carrots as possible\n// from the remaining stock, up to the number needed.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(number: int, need: int, remaining: int)\n{\n    0 <= number <= 1000 && 0 <= need <= 1000 && 0 <= remaining <= 1000\n}\n\nfunction CanEat(need: int, remaining: int): int\n{\n    if need <= remaining then need else remaining\n}\n\nfunction TotalEaten(number: int, need: int, remaining: int): int\n{\n    number + CanEat(need, remaining)\n}\n\nfunction CarrotsLeft(need: int, remaining: int): int\n{\n    remaining - CanEat(need, remaining)\n}\n\npredicate ValidResult(result: seq<int>, number: int, need: int, remaining: int)\n{\n    |result| == 2 &&\n    result[0] == TotalEaten(number, need, remaining) &&\n    result[1] == CarrotsLeft(need, remaining) &&\n    result[0] >= number &&\n    result[1] >= 0 &&\n    result[1] <= remaining\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod eat(number: int, need: int, remaining: int) returns (result: seq<int>)\n    requires ValidInput(number, need, remaining)\n    ensures ValidResult(result, number, need, remaining)", "vc-code": "{\n    var can_eat := CanEat(need, remaining);\n    var total_eaten := number + can_eat;\n    var carrots_left := remaining - can_eat;\n    result := [total_eaten, carrots_left];\n}", "vc-postamble": ""}
{"id": "HumanEval_75", "vc-description": "This verification task implements a method to determine if a given integer (less than 100) is the product of exactly 3 prime numbers, counting repetitions. The method performs prime factorization and checks if exactly 3 prime factors (with repetitions) multiply to the original number.\n\nThe expected implementation uses trial division to find all prime factors, starting with factors of 2, then checking odd numbers up to the square root, and finally handling any remaining prime factor greater than the square root.", "vc-preamble": "// ======= TASK =======\n// Given an integer a where a < 100, determine if a is the product of exactly 3 prime numbers (counting repetitions).\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_prime_number(n: int)\n{\n  n >= 2 && forall k: int :: 2 <= k < n ==> n % k != 0\n}\n\n// ======= HELPERS =======\nfunction seq_product(factors: seq<int>): int\n  decreases |factors|\n{\n  if |factors| == 0 then 1\n  else factors[0] * seq_product(factors[1..])\n}\n\nfunction power(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nlemma seq_product_append_lemma(s: seq<int>, x: int)\n  ensures seq_product(s + [x]) == seq_product(s) * x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n    assert seq_product([x]) == x;\n    assert seq_product(s) == 1;\n  } else {\n    assert s == [s[0]] + s[1..];\n    assert s + [x] == [s[0]] + (s[1..] + [x]);\n    seq_product_append_lemma(s[1..], x);\n    assert seq_product(s[1..] + [x]) == seq_product(s[1..]) * x;\n    assert seq_product(s + [x]) == s[0] * seq_product(s[1..] + [x]);\n    assert seq_product(s + [x]) == s[0] * (seq_product(s[1..]) * x);\n    assert seq_product(s + [x]) == (s[0] * seq_product(s[1..])) * x;\n    assert seq_product(s + [x]) == seq_product(s) * x;\n  }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod is_multiply_prime(a: int) returns (result: bool)\n  requires a >= 0 && a < 100\n  ensures a < 8 ==> result == false\n  ensures result == true <==> (exists p1: int, p2: int, p3: int :: \n    p1 >= 2 && p2 >= 2 && p3 >= 2 && \n    is_prime_number(p1) && is_prime_number(p2) && is_prime_number(p3) &&\n    a == p1 * p2 * p3)", "vc-code": "{\n  if a < 8 {\n    result := false;\n    return;\n  }\n\n  var prime_factors: seq<int> := [];\n  var temp := a;\n  var original_temp := temp;\n\n  // Count factors of 2\n  while temp % 2 == 0\n    invariant temp >= 1\n    invariant original_temp == a\n    invariant temp * seq_product(prime_factors) == original_temp\n    invariant forall x :: x in prime_factors ==> is_prime_number(x)\n    invariant forall x :: x in prime_factors ==> x == 2\n    decreases temp\n  {\n    seq_product_append_lemma(prime_factors, 2);\n    prime_factors := prime_factors + [2];\n    temp := temp / 2;\n  }\n\n  // Check odd factors\n  var i := 3;\n  while i * i <= temp\n    invariant i >= 3 && i % 2 == 1\n    invariant temp >= 1\n    invariant original_temp == a\n    invariant temp * seq_product(prime_factors) == original_temp\n    invariant forall x :: x in prime_factors ==> is_prime_number(x)\n    invariant forall k :: 3 <= k < i && k % 2 == 1 ==> temp % k != 0\n    invariant temp % 2 != 0 || temp == 1\n    decreases temp - i * i + 1\n  {\n    if temp % i == 0 && is_prime_number(i) {\n      while temp % i == 0\n        invariant temp >= 1\n        invariant original_temp == a\n        invariant temp * seq_product(prime_factors) == original_temp\n        invariant forall x :: x in prime_factors ==> is_prime_number(x)\n        invariant is_prime_number(i)\n        decreases temp\n      {\n        seq_product_append_lemma(prime_factors, i);\n        prime_factors := prime_factors + [i];\n        temp := temp / i;\n      }\n    }\n    i := i + 2;\n  }\n\n  // If temp > 1, it's a prime factor\n  if temp > 1 {\n    // temp must be prime since it has no factors from 2 to sqrt(temp)\n    assert temp >= 2;\n    assert forall k :: 2 <= k < temp && k * k <= temp ==> temp % k != 0;\n    assert forall k :: 2 <= k * k <= temp ==> temp % k != 0;\n    // For any k in [2, temp), either k*k > temp (so k > sqrt(temp)) or temp % k != 0\n    assert forall k :: 2 <= k < temp ==> (k * k > temp || temp % k != 0);\n    // If k*k > temp, then k > sqrt(temp), and if temp % k == 0, then temp/k < k, \n    // but temp/k >= 2 would be a factor smaller than sqrt(temp), contradicting our loop\n    assert is_prime_number(temp);\n    seq_product_append_lemma(prime_factors, temp);\n    prime_factors := prime_factors + [temp];\n    temp := 1;\n  }\n\n  result := |prime_factors| == 3;\n\n  if result {\n    assert |prime_factors| == 3;\n    assert forall x :: x in prime_factors ==> is_prime_number(x);\n    assert seq_product(prime_factors) == a;\n    assert prime_factors[0] >= 2 && prime_factors[1] >= 2 && prime_factors[2] >= 2;\n    assert is_prime_number(prime_factors[0]) && is_prime_number(prime_factors[1]) && is_prime_number(prime_factors[2]);\n    assert a == prime_factors[0] * prime_factors[1] * prime_factors[2];\n  }\n}", "vc-postamble": ""}
{"id": "HumanEval_97", "vc-description": "This task implements a function to compute the product of the unit digits of two integers. The unit digit is defined as the ones place digit of the absolute value of a number. Given two integers (which can be positive, negative, or zero), the method should return the product of their respective unit digits.", "vc-preamble": "// ======= TASK =======\n// Given two integers (positive, negative, or zero), return the product of their unit digits.\n// The unit digit is the ones place digit of the absolute value of the number.\n\n// ======= SPEC REQUIREMENTS =======\nfunction UnitDigit(n: int): int\n{\n    (if n >= 0 then n else -n) % 10\n}\n\nfunction ProductOfUnitDigits(a: int, b: int): int\n{\n    UnitDigit(a) * UnitDigit(b)\n}\n\npredicate ValidResult(result: int)\n{\n    result >= 0 && result <= 81\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "method multiply(a: int, b: int) returns (result: int)\n    ensures result == ProductOfUnitDigits(a, b)\n    ensures ValidResult(result)", "vc-code": "{\n    var unit_a := UnitDigit(a);\n    var unit_b := UnitDigit(b);\n    result := unit_a * unit_b;\n}", "vc-postamble": ""}
{"id": "HumanEval_30", "vc-description": "This task implements a function to filter positive numbers from a list of integers. The function should return a new sequence containing only the positive numbers (greater than 0) while preserving their original order from the input sequence.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, return a new list containing only the positive numbers \n// (numbers greater than 0) in their original order.\n\n// ======= SPEC REQUIREMENTS =======\npredicate IsPositive(x: int)\n{\n    x > 0\n}\n\npredicate AllPositive(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> IsPositive(s[i])\n}\n\npredicate AllElementsFromOriginal(result: seq<int>, original: seq<int>)\n{\n    forall x :: x in result ==> x in original\n}\n\npredicate ContainsAllPositives(result: seq<int>, original: seq<int>)\n{\n    forall i :: 0 <= i < |original| && IsPositive(original[i]) ==> original[i] in result\n}\n\npredicate PreservesOrder(result: seq<int>, original: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |result| ==> \n        (exists k1, k2 :: 0 <= k1 < k2 < |original| && original[k1] == result[i] && original[k2] == result[j] &&\n        forall k :: k1 < k < k2 ==> !IsPositive(original[k]))\n}\n\nfunction CountPositives(s: seq<int>): int\n{\n    |set x | x in s && IsPositive(x)|\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod get_positive(l: seq<int>) returns (result: seq<int>)\n    ensures AllPositive(result)\n    ensures AllElementsFromOriginal(result, l)\n    ensures ContainsAllPositives(result, l)\n    ensures |result| == CountPositives(l)\n    ensures PreservesOrder(result, l)", "vc-code": "{\n    result := [];\n    var i := 0;\n    while i < |l|\n        invariant 0 <= i <= |l|\n        invariant AllPositive(result)\n        invariant AllElementsFromOriginal(result, l)\n        invariant ContainsAllPositives(result, l[..i])\n        invariant forall x :: x in result ==> exists j :: 0 <= j < i && l[j] == x\n        invariant PreservesOrder(result, l[..i])\n        invariant (set x | x in result) == (set x | x in l[..i] && IsPositive(x))\n        invariant |result| == CountPositives(l[..i])\n    {\n        if IsPositive(l[i]) && l[i] !in result {\n            result := result + [l[i]];\n        }\n        i := i + 1;\n    }\n\n    assert l[..i] == l;\n    assert (set x | x in result) == (set x | x in l && IsPositive(x));\n}", "vc-postamble": ""}
{"id": "HumanEval_128", "vc-description": "This task implements a function that calculates the sum of absolute values of all elements in an array, multiplied by the product of signs of all elements. The sign function returns 1 for positive numbers, -1 for negative numbers, and 0 for zero. If the array is empty, the function returns None; otherwise, it returns Some with the computed result.", "vc-preamble": "// ======= TASK =======\n// Given an array of integers, calculate the sum of absolute values of all elements\n// multiplied by the product of signs of all elements (where sign is 1 for positive,\n// -1 for negative, 0 for zero). Return None if the array is empty.\n\n// ======= SPEC REQUIREMENTS =======\ndatatype Option<T> = None | Some(value: T)\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}\n\nfunction sign(x: int): int\n{\n    if x > 0 then 1 else if x < 0 then -1 else 0\n}\n\nfunction sum_of_magnitudes(arr: seq<int>): int\n{\n    if |arr| == 0 then 0 else abs(arr[0]) + sum_of_magnitudes(arr[1..])\n}\n\nfunction product_of_signs(arr: seq<int>): int\n{\n    if |arr| == 0 then 1 else sign(arr[0]) * product_of_signs(arr[1..])\n}", "vc-helpers": "// ======= HELPERS =======\nlemma sum_of_magnitudes_append(arr: seq<int>, i: int)\n    requires 0 <= i < |arr|\n    ensures sum_of_magnitudes(arr[0..i+1]) == sum_of_magnitudes(arr[0..i]) + abs(arr[i])\n{\n    if i == 0 {\n        assert arr[0..1] == [arr[0]];\n        assert arr[0..0] == [];\n    } else {\n        sum_of_magnitudes_append(arr[1..], i-1);\n        assert arr[1..][0..i-1] == arr[1..i];\n        assert arr[1..][0..i] == arr[1..i+1];\n        assert sum_of_magnitudes(arr[1..i+1]) == sum_of_magnitudes(arr[1..i]) + abs(arr[i]);\n        assert sum_of_magnitudes(arr[0..i+1]) == abs(arr[0]) + sum_of_magnitudes(arr[1..i+1]);\n        assert sum_of_magnitudes(arr[0..i]) == abs(arr[0]) + sum_of_magnitudes(arr[1..i]);\n    }\n}\n\nlemma product_of_signs_append(arr: seq<int>, i: int)\n    requires 0 <= i < |arr|\n    ensures product_of_signs(arr[0..i+1]) == product_of_signs(arr[0..i]) * sign(arr[i])\n{\n    if i == 0 {\n        assert arr[0..1] == [arr[0]];\n        assert arr[0..0] == [];\n    } else {\n        product_of_signs_append(arr[1..], i-1);\n        assert arr[1..][0..i-1] == arr[1..i];\n        assert arr[1..][0..i] == arr[1..i+1];\n        assert product_of_signs(arr[1..i+1]) == product_of_signs(arr[1..i]) * sign(arr[i]);\n        assert product_of_signs(arr[0..i+1]) == sign(arr[0]) * product_of_signs(arr[1..i+1]);\n        assert product_of_signs(arr[0..i]) == sign(arr[0]) * product_of_signs(arr[1..i]);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod prod_signs(arr: seq<int>) returns (result: Option<int>)\n    ensures |arr| == 0 ==> result == None\n    ensures |arr| > 0 ==> result == Some(sum_of_magnitudes(arr) * product_of_signs(arr))", "vc-code": "{\n    if |arr| == 0 {\n        result := None;\n        return;\n    }\n\n    var sum_of_magnitudes_local := 0;\n    var product_of_signs_local := 1;\n\n    for i := 0 to |arr|\n        invariant 0 <= i <= |arr|\n        invariant sum_of_magnitudes_local == sum_of_magnitudes(arr[0..i])\n        invariant product_of_signs_local == product_of_signs(arr[0..i])\n    {\n        sum_of_magnitudes_append(arr, i);\n        product_of_signs_append(arr, i);\n        sum_of_magnitudes_local := sum_of_magnitudes_local + abs(arr[i]);\n        product_of_signs_local := product_of_signs_local * sign(arr[i]);\n    }\n\n    assert arr[0..|arr|] == arr;\n    result := Some(sum_of_magnitudes_local * product_of_signs_local);\n}", "vc-postamble": ""}
{"id": "HumanEval_48", "vc-description": "Determine if a given string is a palindrome (reads the same forwards and backwards). The comparison should be case-insensitive, requiring implementation of a case conversion function and a palindrome checking predicate.", "vc-preamble": "// ======= TASK =======\n// Determine if a given string is a palindrome (reads the same forwards and backwards).\n// The comparison should be case-insensitive.\n\n// ======= SPEC REQUIREMENTS =======\nfunction to_lower(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}\n\npredicate IsPalindrome(text: string)\n{\n    forall i :: 0 <= i < |text| ==> to_lower(text[i]) == to_lower(text[|text| - 1 - i])\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod is_palindrome(text: string) returns (result: bool)\n  ensures result <==> IsPalindrome(text)", "vc-code": "{\n    var n := |text|;\n    result := true;\n    var i := 0;\n    while i < n / 2\n      invariant 0 <= i <= n / 2\n      invariant result <==> (forall j :: 0 <= j < i ==> to_lower(text[j]) == to_lower(text[n - 1 - j]))\n    {\n        if to_lower(text[i]) != to_lower(text[n - 1 - i]) {\n            result := false;\n            return;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_0", "vc-description": "This verification task involves implementing a method to determine if any two numbers in a given list have an absolute difference less than a specified threshold. The implementation uses nested loops to compare all pairs of elements and returns true as soon as a close pair is found, or false if no such pair exists.", "vc-preamble": "// ======= TASK =======\n// Given a list of numbers and a threshold value, determine if any two numbers \n// in the list have an absolute difference less than the threshold.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(numbers: seq<real>, threshold: real)\n{\n    true\n}\n\nfunction AbsDiff(a: real, b: real): real\n{\n    if a >= b then a - b else b - a\n}\n\npredicate HasCloseElements(numbers: seq<real>, threshold: real)\n{\n    exists i, j :: 0 <= i < j < |numbers| && AbsDiff(numbers[i], numbers[j]) < threshold\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "method has_close_elements(numbers: seq<real>, threshold: real) returns (result: bool)\n    requires ValidInput(numbers, threshold)\n    ensures result == HasCloseElements(numbers, threshold)", "vc-code": "{\n    result := false;\n    var i := 0;\n    while i < |numbers|\n        invariant 0 <= i <= |numbers|\n        invariant result ==> HasCloseElements(numbers, threshold)\n        invariant !result ==> (forall i', j' :: 0 <= i' < i && i' < j' < |numbers| ==> AbsDiff(numbers[i'], numbers[j']) >= threshold)\n    {\n        var j := i + 1;\n        while j < |numbers|\n            invariant i + 1 <= j <= |numbers|\n            invariant result ==> HasCloseElements(numbers, threshold)\n            invariant !result ==> (forall i', j' :: 0 <= i' < i && i' < j' < |numbers| ==> AbsDiff(numbers[i'], numbers[j']) >= threshold)\n            invariant !result ==> (forall j' :: i < j' < j ==> AbsDiff(numbers[i], numbers[j']) >= threshold)\n        {\n            var diff := AbsDiff(numbers[i], numbers[j]);\n            if diff < threshold {\n                result := true;\n                return;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_62", "vc-description": "This task involves computing the derivative of a polynomial given its coefficients. Given a sequence of coefficients where xs[i] represents the coefficient of x^i, the method should return the derivative coefficients where [a₀, a₁, a₂, ...] becomes [a₁, 2a₂, 3a₃, ...].", "vc-preamble": "// ======= TASK =======\n// Given a list of coefficients representing a polynomial where xs[i] is the coefficient of x^i,\n// compute the derivative of the polynomial and return it in the same coefficient format.\n// The derivative transforms coefficients: [a₀, a₁, a₂, ...] becomes [a₁, 2a₂, 3a₃, ...]\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(xs: seq<int>)\n{\n    true  // Any sequence of coefficients is valid input\n}\n\nfunction DerivativeLength(xs: seq<int>): nat\n{\n    if |xs| <= 1 then 0 else |xs| - 1\n}\n\npredicate CorrectDerivativeCoefficients(xs: seq<int>, result: seq<int>)\n{\n    |xs| <= 1 ==> result == [] &&\n    |xs| > 1 ==> (|result| == |xs| - 1 && \n                  forall j :: 0 <= j < |result| ==> result[j] == (j + 1) * xs[j + 1])\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod derivative(xs: seq<int>) returns (result: seq<int>)\n    requires ValidInput(xs)\n    ensures CorrectDerivativeCoefficients(xs, result)\n    ensures |result| == DerivativeLength(xs)", "vc-code": "{\n    if |xs| <= 1 {\n        return [];\n    }\n\n    result := [];\n    var i := 1;\n    while i < |xs|\n        invariant 1 <= i <= |xs|\n        invariant |result| == i - 1\n        invariant forall j :: 0 <= j < |result| ==> result[j] == (j + 1) * xs[j + 1]\n    {\n        result := result + [i * xs[i]];\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_93", "vc-description": "Implement a message encoding algorithm that applies two transformations to each character: first replace vowels with letters appearing 2 positions later in the alphabet, then swap the case of all letters. Spaces are preserved unchanged, and the input contains only letters and spaces.", "vc-preamble": "// ======= TASK =======\n// Encode a message by applying two transformations to each character:\n// 1. Replace vowels (a, e, i, o, u) with the letter that appears 2 positions later in the alphabet\n// 2. Swap the case of all letters (uppercase ↔ lowercase)\n// Apply both transformations: first replace vowels, then swap case of the result.\n// Spaces are preserved unchanged. Assume input contains only letters and spaces.\n\n// ======= SPEC REQUIREMENTS =======\npredicate isVowel(c: char)\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nfunction getVowelReplacement(c: char): char\n    requires isVowel(c)\n{\n    match c\n        case 'a' => 'c'\n        case 'e' => 'g' \n        case 'i' => 'k'\n        case 'o' => 'q'\n        case 'u' => 'w'\n        case 'A' => 'C'\n        case 'E' => 'G'\n        case 'I' => 'K'\n        case 'O' => 'Q'\n        case 'U' => 'W'\n}\n\nfunction swapCase(c: char): char\n{\n    if 'a' <= c <= 'z' then\n        (c as int - 'a' as int + 'A' as int) as char\n    else if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod encode(message: string) returns (result: string)\n    requires forall i :: 0 <= i < |message| ==> (('a' <= message[i] <= 'z') || ('A' <= message[i] <= 'Z') || message[i] == ' ')\n    ensures |result| == |message|\n    ensures forall i :: 0 <= i < |message| ==> \n        if message[i] == ' ' then result[i] == ' '\n        else if isVowel(message[i]) then result[i] == swapCase(getVowelReplacement(message[i]))\n        else result[i] == swapCase(message[i])", "vc-code": "{\n    result := \"\";\n    var i := 0;\n\n    while i < |message|\n        invariant 0 <= i <= |message|\n        invariant |result| == i\n        invariant forall j :: 0 <= j < i ==> \n            if message[j] == ' ' then result[j] == ' '\n            else if isVowel(message[j]) then result[j] == swapCase(getVowelReplacement(message[j]))\n            else result[j] == swapCase(message[j])\n    {\n        var c := message[i];\n        if c == ' ' {\n            result := result + [' '];\n        } else if isVowel(c) {\n            var replacement := getVowelReplacement(c);\n            var swapped := swapCase(replacement);\n            result := result + [swapped];\n        } else {\n            var swapped := swapCase(c);\n            result := result + [swapped];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": ""}
{"id": "HumanEval_82", "vc-description": "This task verifies a function that determines whether a string's length is a prime number. A prime number is defined as an integer greater than or equal to 2 that has no divisors other than 1 and itself.", "vc-preamble": "// ======= TASK =======\n// Given a string, determine if its length is a prime number.\n// A prime number is an integer greater than or equal to 2 that has no divisors other than 1 and itself.\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_prime_number(n: int)\n{\n    n >= 2 && (forall k :: 2 <= k < n ==> n % k != 0)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod is_prime(n: int) returns (result: bool)\n    ensures result <==> is_prime_number(n)\n{\n    if n < 2 {\n        result := false;\n        return;\n    }\n    if n == 2 {\n        result := true;\n        return;\n    }\n    if n % 2 == 0 {\n        result := false;\n        return;\n    }\n\n    // Check odd divisors up to sqrt(n)\n    var i := 3;\n    while i * i <= n\n        invariant 3 <= i\n        invariant i % 2 == 1\n        invariant forall k :: 2 <= k < i ==> n % k != 0\n    {\n        if n % i == 0 {\n            result := false;\n            return;\n        }\n        i := i + 2;\n    }\n\n    assert forall k :: 2 <= k < n && k * k <= n ==> n % k != 0;\n    assert forall k :: 2 <= k < n ==> (k * k <= n || k * k > n);\n    assert forall k :: 2 <= k < n && k * k > n ==> (n % k != 0 <==> n % (n / k) != 0);\n    assert forall k :: 2 <= k < n ==> n % k != 0;\n\n    result := true;\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod prime_length(s: string) returns (result: bool)\n    ensures result <==> is_prime_number(|s|)", "vc-code": "{\n    var length := |s|;\n    result := is_prime(length);\n}", "vc-postamble": ""}
{"id": "HumanEval_103", "vc-description": "Given two positive integers n and m, compute the average of all integers in the range [n, m] (inclusive).\nRound the result to the nearest integer using banker's rounding (round half to even) and return the binary representation as a string prefixed with \"0b\". If n > m, return \"-1\".", "vc-preamble": "// ======= TASK =======\n// Given two positive integers n and m, compute the average of all integers in the range [n, m] (inclusive).\n// Round the result to the nearest integer using banker's rounding (round half to even).\n// Return the binary representation as a string prefixed with \"0b\".\n// If n > m, return \"-1\".\n\n// ======= SPEC REQUIREMENTS =======\nfunction IntToBinary(n: nat): string\n{\n    if n == 0 then \"0\"\n    else IntToBinaryHelper(n)\n}\n\nfunction IntToBinaryHelper(n: nat): string\n    requires n > 0\n{\n    if n == 1 then \"1\" \n    else IntToBinaryHelper(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod rounded_avg(n: int, m: int) returns (result: string)\n    requires n > 0 && m > 0\n    ensures n > m ==> result == \"-1\"\n    ensures n <= m ==> |result| >= 3 && result[0..2] == \"0b\"\n    ensures n <= m ==> (\n        var count := m - n + 1;\n        var total_sum := count * (n + m) / 2;\n        var quotient := total_sum / count;\n        var remainder := total_sum % count;\n        var rounded := if remainder * 2 < count then quotient\n                      else if remainder * 2 > count then quotient + 1\n                      else if quotient % 2 == 0 then quotient\n                      else quotient + 1;\n        result == \"0b\" + IntToBinary(rounded)\n    )", "vc-code": "{\n    if n > m {\n        result := \"-1\";\n        return;\n    }\n\n    var count := m - n + 1;\n    var total_sum := count * (n + m) / 2;\n\n    var quotient := total_sum / count;\n    var remainder := total_sum % count;\n\n    var rounded: int;\n    if remainder * 2 < count {\n        rounded := quotient;\n    } else if remainder * 2 > count {\n        rounded := quotient + 1;\n    } else {\n        if quotient % 2 == 0 {\n            rounded := quotient;\n        } else {\n            rounded := quotient + 1;\n        }\n    }\n\n    var tmpCall1 := IntToBinary(rounded);\n    result := \"0b\" + tmpCall1;\n}", "vc-postamble": ""}
{"id": "HumanEval_83", "vc-description": "Count n-digit positive integers that start with 1 OR end with 1 using inclusion-exclusion principle. The task requires implementing a function that uses the inclusion-exclusion principle to count numbers that either start with 1, end with 1, or both, avoiding double-counting those that satisfy both conditions.", "vc-preamble": "// ======= TASK =======\n// Count n-digit positive integers that start with 1 OR end with 1 using inclusion-exclusion principle\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int) {\n  n >= 1\n}\n\nfunction power(base: int, exp: int): int\n  requires exp >= 0\n  ensures base >= 0 ==> power(base, exp) >= 0\n  ensures base > 0 ==> power(base, exp) > 0\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nfunction CountStartsWith1(n: int): int\n  requires n >= 1\n  ensures CountStartsWith1(n) == power(10, n - 1)\n{\n  power(10, n - 1)\n}\n\nfunction CountEndsWith1(n: int): int\n  requires n >= 1\n  ensures n == 1 ==> CountEndsWith1(n) == 1\n  ensures n >= 2 ==> CountEndsWith1(n) == 9 * power(10, n - 2)\n{\n  if n == 1 then 1\n  else 9 * power(10, n - 2)\n}\n\nfunction CountStartsAndEndsWith1(n: int): int\n  requires n >= 1\n  ensures n == 1 ==> CountStartsAndEndsWith1(n) == 1\n  ensures n == 2 ==> CountStartsAndEndsWith1(n) == 1\n  ensures n >= 3 ==> CountStartsAndEndsWith1(n) == power(10, n - 2)\n{\n  if n <= 2 then 1\n  else power(10, n - 2)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nfunction starts_one_ends(n: int): int\n  requires ValidInput(n)\n  ensures starts_one_ends(n) == CountStartsWith1(n) + CountEndsWith1(n) - CountStartsAndEndsWith1(n)\n  ensures starts_one_ends(n) >= 0", "vc-code": "{\n  CountStartsWith1(n) + CountEndsWith1(n) - CountStartsAndEndsWith1(n)\n}", "vc-postamble": ""}
{"id": "HumanEval_135", "vc-description": "The task is to find the largest index in an array of distinct integers where an element is smaller than the element immediately before it. If no such index exists (i.e., the array is non-decreasing), return -1. The implementation should scan from right to left to efficiently find the largest such index.", "vc-preamble": "// ======= TASK =======\n// Given an array of distinct integers, find the largest index where an element \n// is smaller than the element immediately before it. Return -1 if no such index exists.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(arr: seq<int>) {\n    forall i, j :: 0 <= i < j < |arr| ==> arr[i] != arr[j]\n}\n\npredicate HasDecreaseAt(arr: seq<int>, i: int) {\n    1 <= i < |arr| && arr[i] < arr[i-1]\n}\n\npredicate IsLargestDecreaseIndex(arr: seq<int>, result: int) {\n    HasDecreaseAt(arr, result) && \n    (forall j :: result < j < |arr| ==> arr[j] >= arr[j-1])\n}\n\npredicate IsNonDecreasing(arr: seq<int>) {\n    forall i :: 1 <= i < |arr| ==> arr[i] >= arr[i-1]\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod can_arrange(arr: seq<int>) returns (result: int)\n    requires ValidInput(arr)\n    ensures result == -1 || (0 < result < |arr|)\n    ensures result == -1 ==> IsNonDecreasing(arr)\n    ensures result != -1 ==> IsLargestDecreaseIndex(arr, result)\n    ensures result != -1 ==> (exists i :: HasDecreaseAt(arr, i))", "vc-code": "{\n    if |arr| <= 1 {\n        return -1;\n    }\n\n    var i := |arr| - 1;\n    while i > 0\n        invariant 0 <= i < |arr|\n        invariant forall j :: i < j < |arr| ==> arr[j] >= arr[j-1]\n    {\n        if arr[i] < arr[i - 1] {\n            return i;\n        }\n        i := i - 1;\n    }\n    return -1;\n}", "vc-postamble": ""}
{"id": "HumanEval_13", "vc-description": "This task involves implementing the greatest common divisor (GCD) function for two integers. The GCD is the largest positive integer that divides both numbers without remainder, with special cases for zero values.\n\nThe implementation should use the Euclidean algorithm, which repeatedly applies the property that GCD(a,b) = GCD(b, a mod b) until one operand becomes zero.", "vc-preamble": "// ======= TASK =======\n// Find the greatest common divisor (GCD) of two integers.\n// The GCD is the largest positive integer that divides both numbers without remainder.\n// Special cases: GCD(0, 0) = 0, GCD(0, n) = |n| for n != 0.\n\n// ======= SPEC REQUIREMENTS =======\nfunction abs(x: int): nat\n{\n    if x >= 0 then x else -x\n}\n\npredicate divides(d: int, n: int)\n{\n    if d == 0 then n == 0 else n % d == 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod greatest_common_divisor(a: int, b: int) returns (result: nat)\n    ensures result > 0 <==> (a != 0 || b != 0)\n    ensures result == 0 <==> (a == 0 && b == 0)\n    ensures divides(result, a) && divides(result, b)\n    ensures forall d: int :: d > 0 && divides(d, a) && divides(d, b) ==> d <= result", "vc-code": "{\n    var x := abs(a);\n    var y := abs(b);\n\n    while y != 0\n        decreases y\n        invariant y >= 0\n        invariant forall d: int :: divides(d, x) && divides(d, y) <==> divides(d, abs(a)) && divides(d, abs(b))\n        invariant forall d: int :: divides(d, abs(a)) <==> divides(d, a)\n        invariant forall d: int :: divides(d, abs(b)) <==> divides(d, b)\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n\n    result := x;\n}", "vc-postamble": ""}
{"id": "HumanEval_8", "vc-description": "This verification task implements a method to compute both the sum and product of all integers in a given sequence. For an empty list, the method should return (0, 1) representing the empty sum and empty product respectively. The implementation uses iterative computation while maintaining loop invariants to ensure correctness.", "vc-preamble": "// ======= TASK =======\n// Given a list of integers, return a tuple containing the sum and product of all integers in the list.\n// For an empty list, return (0, 1) where 0 is the empty sum and 1 is the empty product.\n\n// ======= SPEC REQUIREMENTS =======\nfunction SumSeq(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + SumSeq(s[1..])\n}\n\nfunction ProductSeq(s: seq<int>): int\n{\n    if |s| == 0 then 1\n    else s[0] * ProductSeq(s[1..])\n}", "vc-helpers": "// ======= HELPERS =======\nlemma SumSeqAppend(s: seq<int>, x: int)\n    ensures SumSeq(s + [x]) == SumSeq(s) + x\n{\n    if |s| == 0 {\n        assert s + [x] == [x];\n        assert SumSeq([x]) == x + SumSeq([]);\n        assert SumSeq([]) == 0;\n    } else {\n        assert s == [s[0]] + s[1..];\n        assert s + [x] == [s[0]] + (s[1..] + [x]);\n        SumSeqAppend(s[1..], x);\n    }\n}\n\nlemma ProductSeqAppend(s: seq<int>, x: int)\n    ensures ProductSeq(s + [x]) == ProductSeq(s) * x\n{\n    if |s| == 0 {\n        assert s + [x] == [x];\n        assert ProductSeq([x]) == x * ProductSeq([]);\n        assert ProductSeq([]) == 1;\n    } else {\n        assert s == [s[0]] + s[1..];\n        assert s + [x] == [s[0]] + (s[1..] + [x]);\n        ProductSeqAppend(s[1..], x);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod sum_product(numbers: seq<int>) returns (sum: int, product: int)\n    ensures sum == SumSeq(numbers)\n    ensures product == ProductSeq(numbers)\n    ensures |numbers| == 0 ==> sum == 0 && product == 1", "vc-code": "{\n    if |numbers| == 0 {\n        sum := 0;\n        product := 1;\n        return;\n    }\n\n    sum := 0;\n    product := 1;\n\n    var i := 0;\n    while i < |numbers|\n        invariant 0 <= i <= |numbers|\n        invariant sum == SumSeq(numbers[..i])\n        invariant product == ProductSeq(numbers[..i])\n    {\n        assert numbers[..(i+1)] == numbers[..i] + [numbers[i]];\n        SumSeqAppend(numbers[..i], numbers[i]);\n        ProductSeqAppend(numbers[..i], numbers[i]);\n\n        sum := sum + numbers[i];\n        product := product * numbers[i];\n        i := i + 1;\n    }\n\n    assert i == |numbers|;\n    assert numbers[..i] == numbers;\n}", "vc-postamble": ""}
