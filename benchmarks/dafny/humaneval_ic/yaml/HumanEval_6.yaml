vc-description: |-
  This verification task implements a parser for nested parentheses strings. Given a string containing groups of nested parentheses separated by spaces, the goal is to find the maximum nesting depth for each group independently. The implementation must correctly split the input by spaces, calculate nesting depths, and return a sequence of maximum depths corresponding to each group.

vc-preamble: |-
  // ======= TASK =======
  // Given a string containing multiple groups of nested parentheses separated by spaces,
  // find the maximum nesting depth for each group. The input string contains only
  // parentheses '(', ')', and spaces ' '. Groups are separated by spaces, and each
  // group's maximum nesting depth is calculated independently.
  
  // ======= SPEC REQUIREMENTS =======
  function SplitBySpacesResult(s: string): seq<string>
      requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '
      ensures forall i :: 0 <= i < |SplitBySpacesResult(s)| ==> forall j :: 0 <= j < |SplitBySpacesResult(s)[i]| ==> SplitBySpacesResult(s)[i][j] == '(' || SplitBySpacesResult(s)[i][j] == ')'
      ensures |s| == 0 ==> |SplitBySpacesResult(s)| == 0
  {
      if |s| == 0 then []
      else
          var groups := [];
          var current_group := "";
          var i := 0;
          SplitBySpacesHelper(s, i, current_group, groups)
  }
  
  function MaxNestingDepth(group: string): int
      requires forall i :: 0 <= i < |group| ==> group[i] == '(' || group[i] == ')'
      ensures MaxNestingDepth(group) >= 0
  {
      MaxNestingDepthHelper(group, 0, 0, 0)
  }
  
  // ======= HELPERS =======
  function SplitBySpacesHelper(s: string, i: int, current_group: string, groups: seq<string>): seq<string>
      requires 0 <= i <= |s|
      requires forall k :: 0 <= k < |s| ==> s[k] == '(' || s[k] == ')' || s[k] == ' '
      requires forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'
      requires forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'
      ensures forall k :: 0 <= k < |SplitBySpacesHelper(s, i, current_group, groups)| ==> forall j :: 0 <= j < |SplitBySpacesHelper(s, i, current_group, groups)[k]| ==> SplitBySpacesHelper(s, i, current_group, groups)[k][j] == '(' || SplitBySpacesHelper(s, i, current_group, groups)[k][j] == ')'
      decreases |s| - i
  {
      if i == |s| then
          if |current_group| > 0 then groups + [current_group] else groups
      else if s[i] == ' ' then
          if |current_group| > 0 then
              SplitBySpacesHelper(s, i + 1, "", groups + [current_group])
          else
              SplitBySpacesHelper(s, i + 1, current_group, groups)
      else
          SplitBySpacesHelper(s, i + 1, current_group + [s[i]], groups)
  }
  
  function MaxNestingDepthHelper(group: string, index: int, current_depth: int, max_depth: int): int
      requires 0 <= index <= |group|
      requires max_depth >= 0
      decreases |group| - index
      ensures MaxNestingDepthHelper(group, index, current_depth, max_depth) >= 0
  {
      if index == |group| then max_depth
      else if group[index] == '(' then
          var new_current := current_depth + 1;
          var new_max := if new_current > max_depth then new_current else max_depth;
          MaxNestingDepthHelper(group, index + 1, new_current, new_max)
      else if group[index] == ')' then
          MaxNestingDepthHelper(group, index + 1, current_depth - 1, max_depth)
      else
          MaxNestingDepthHelper(group, index + 1, current_depth, max_depth)
  }
  
  method SplitBySpaces(s: string) returns (groups: seq<string>)
      requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '
      ensures forall i :: 0 <= i < |groups| ==> ' ' !in groups[i]
      ensures forall i :: 0 <= i < |groups| ==> forall j :: 0 <= j < |groups[i]| ==> groups[i][j] == '(' || groups[i][j] == ')'
      ensures |s| == 0 ==> |groups| == 0
      ensures groups == SplitBySpacesResult(s)
  {
      groups := [];
      var current_group := "";
  
      if |s| == 0 {
          return;
      }
  
      var i := 0;
      while i < |s|
          invariant 0 <= i <= |s|
          invariant ' ' !in current_group
          invariant forall k :: 0 <= k < |groups| ==> ' ' !in groups[k]
          invariant forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'
          invariant forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'
          invariant SplitBySpacesResult(s) == SplitBySpacesHelper(s, i, current_group, groups)
      {
          if s[i] == ' ' {
              if |current_group| > 0 {
                  groups := groups + [current_group];
                  current_group := "";
              }
          } else {
              current_group := current_group + [s[i]];
          }
          i := i + 1;
      }
  
      if |current_group| > 0 {
          groups := groups + [current_group];
      }
  }

vc-helpers: |-

vc-spec: |-
  // ======= MAIN METHOD =======
  method parse_nested_parens(paren_string: string) returns (result: seq<int>)
      requires forall i :: 0 <= i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '
      ensures |result| == |SplitBySpacesResult(paren_string)|
      ensures forall i :: 0 <= i < |result| ==> result[i] >= 0
      ensures |paren_string| == 0 ==> |result| == 0
      ensures forall i :: 0 <= i < |result| ==> result[i] == MaxNestingDepth(SplitBySpacesResult(paren_string)[i])

vc-code: |-
  {
      result := [];
  
      if |paren_string| == 0 {
          return;
      }
  
      var groups := SplitBySpaces(paren_string);
      assert groups == SplitBySpacesResult(paren_string);
  
      var i := 0;
      while i < |groups|
          invariant 0 <= i <= |groups|
          invariant |result| == i
          invariant forall k :: 0 <= k < i ==> result[k] >= 0
          invariant forall k :: 0 <= k < i ==> result[k] == MaxNestingDepth(groups[k])
          invariant groups == SplitBySpacesResult(paren_string)
      {
          var group := groups[i];
          var current_depth := 0;
          var max_depth := 0;
  
          var j := 0;
          while j < |group|
              invariant 0 <= j <= |group|
              invariant max_depth >= 0
              invariant MaxNestingDepth(group) == MaxNestingDepthHelper(group, j, current_depth, max_depth)
          {
              if group[j] == '(' {
                  current_depth := current_depth + 1;
                  if current_depth > max_depth {
                      max_depth := current_depth;
                  }
              } else if group[j] == ')' {
                  current_depth := current_depth - 1;
              }
              j := j + 1;
          }
  
          assert max_depth == MaxNestingDepth(group);
          result := result + [max_depth];
          i := i + 1;
      }
  }

vc-postamble: |-

