vc-description: |-
  This verification task implements an algorithm to find the largest prime factor of a composite integer n (where n > 1 and n is not prime). The algorithm uses trial division, first removing all factors of 2, then checking odd factors up to the square root of the remaining number.
  
  The implementation must ensure that the returned result is indeed a prime number, divides n, and is the largest such prime factor among all factors of n.

vc-preamble: |-
  // Given a composite integer n (where n > 1 and n is not prime), find and return its largest prime factor.
  
  predicate is_prime(n: int)
  {
      n > 1 && forall k :: 2 <= k < n ==> n % k != 0
  }
  
  function power_of_2_factor(n: int, current: int): int
      requires n > 0 && current > 0
      decreases current
  {
      if current % 2 != 0 then 1
      else 2 * power_of_2_factor(n, current / 2)
  }

vc-helpers: |-

vc-spec: |-
  method largest_prime_factor(n: int) returns (result: int)
      requires n > 1
      requires !is_prime(n)
      ensures result > 1
      ensures n % result == 0
      ensures forall k :: k > result && n % k == 0 ==> !is_prime(k)
      ensures is_prime(result)

vc-code: |-
  {
      var largest_factor := 1;
      var current_n := n;
  
      while current_n % 2 == 0
          invariant current_n > 0
          invariant current_n * power_of_2_factor(n, n / current_n) == n
          decreases current_n
      {
          largest_factor := 2;
          current_n := current_n / 2;
      }
  
      var factor := 3;
      while factor * factor <= current_n
          invariant factor >= 3
          invariant factor % 2 == 1
          invariant current_n > 0
          invariant largest_factor >= 1
          invariant largest_factor > 1 ==> n % largest_factor == 0
          invariant largest_factor > 1 ==> is_prime(largest_factor)
          invariant forall k :: 1 < k < factor && n % k == 0 ==> k <= largest_factor
          invariant forall k :: largest_factor < k < factor && n % k == 0 ==> !is_prime(k)
          invariant current_n > 1 ==> forall k :: 2 <= k < factor && current_n % k == 0 ==> false
          decreases current_n - factor + 1
      {
          while current_n % factor == 0
              invariant current_n > 0
              invariant factor >= 3
              invariant is_prime(factor)
              decreases current_n
          {
              largest_factor := factor;
              current_n := current_n / factor;
          }
          factor := factor + 2;
      }
  
      if current_n > 1 {
          largest_factor := current_n;
      }
  
      result := largest_factor;
  }

vc-postamble: |-

