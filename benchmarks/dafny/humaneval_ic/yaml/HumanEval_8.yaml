vc-description: |-
  This verification task implements a method to compute both the sum and product of all integers in a given sequence. For an empty list, the method should return (0, 1) representing the empty sum and empty product respectively. The implementation uses iterative computation while maintaining loop invariants to ensure correctness.

vc-preamble: |-
  // ======= TASK =======
  // Given a list of integers, return a tuple containing the sum and product of all integers in the list.
  // For an empty list, return (0, 1) where 0 is the empty sum and 1 is the empty product.
  
  // ======= SPEC REQUIREMENTS =======
  function SumSeq(s: seq<int>): int
  {
      if |s| == 0 then 0
      else s[0] + SumSeq(s[1..])
  }
  
  function ProductSeq(s: seq<int>): int
  {
      if |s| == 0 then 1
      else s[0] * ProductSeq(s[1..])
  }

vc-helpers: |-
  // ======= HELPERS =======
  lemma SumSeqAppend(s: seq<int>, x: int)
      ensures SumSeq(s + [x]) == SumSeq(s) + x
  {
      if |s| == 0 {
          assert s + [x] == [x];
          assert SumSeq([x]) == x + SumSeq([]);
          assert SumSeq([]) == 0;
      } else {
          assert s == [s[0]] + s[1..];
          assert s + [x] == [s[0]] + (s[1..] + [x]);
          SumSeqAppend(s[1..], x);
      }
  }
  
  lemma ProductSeqAppend(s: seq<int>, x: int)
      ensures ProductSeq(s + [x]) == ProductSeq(s) * x
  {
      if |s| == 0 {
          assert s + [x] == [x];
          assert ProductSeq([x]) == x * ProductSeq([]);
          assert ProductSeq([]) == 1;
      } else {
          assert s == [s[0]] + s[1..];
          assert s + [x] == [s[0]] + (s[1..] + [x]);
          ProductSeqAppend(s[1..], x);
      }
  }

vc-spec: |-
  // ======= MAIN METHOD =======
  method sum_product(numbers: seq<int>) returns (sum: int, product: int)
      ensures sum == SumSeq(numbers)
      ensures product == ProductSeq(numbers)
      ensures |numbers| == 0 ==> sum == 0 && product == 1

vc-code: |-
  {
      if |numbers| == 0 {
          sum := 0;
          product := 1;
          return;
      }
  
      sum := 0;
      product := 1;
  
      var i := 0;
      while i < |numbers|
          invariant 0 <= i <= |numbers|
          invariant sum == SumSeq(numbers[..i])
          invariant product == ProductSeq(numbers[..i])
      {
          assert numbers[..(i+1)] == numbers[..i] + [numbers[i]];
          SumSeqAppend(numbers[..i], numbers[i]);
          ProductSeqAppend(numbers[..i], numbers[i]);
  
          sum := sum + numbers[i];
          product := product * numbers[i];
          i := i + 1;
      }
  
      assert i == |numbers|;
      assert numbers[..i] == numbers;
  }

vc-postamble: |-

