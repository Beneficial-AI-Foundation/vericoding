vc-description: |-
  This verification task involves implementing a string transformation method that replaces spaces according to specific rules: individual spaces or pairs of consecutive spaces become underscores (one per space), while sequences of more than 2 consecutive spaces become a single dash. The implementation must preserve the order of non-space characters and satisfy several correctness predicates.

vc-preamble: |-
  // ======= TASK =======
  // Given a string, transform all spaces according to these rules:
  // - Replace each individual space or pair of consecutive spaces with underscores (one underscore per space)
  // - Replace any sequence of more than 2 consecutive spaces with a single dash "-"
  
  // ======= SPEC REQUIREMENTS =======
  predicate ValidInput(text: string)
  {
      true
  }
  
  predicate IsSpaceSequence(text: string, start: int, end: int)
      requires 0 <= start <= end < |text|
  {
      (forall k :: start <= k <= end ==> text[k] == ' ') &&
      (start == 0 || text[start-1] != ' ') &&
      (end == |text|-1 || text[end+1] != ' ')
  }
  
  predicate ValidResult(text: string, result: string)
  {
      |result| <= |text| &&
      (text == "" ==> result == "") &&
      (forall i :: 0 <= i < |result| ==> result[i] != ' ') &&
      (forall i :: 0 <= i < |result| ==> result[i] == '_' || result[i] == '-' || result[i] in text) &&
      ((forall i :: 0 <= i < |text| ==> text[i] != ' ') ==> result == text) &&
      (forall i :: 0 <= i < |text| && text[i] != ' ' ==> text[i] in result)
  }
  
  predicate PreservesOrder(text: string, result: string)
  {
      forall i, j :: 0 <= i < j < |text| && text[i] != ' ' && text[j] != ' ' ==>
          exists i', j' :: 0 <= i' < j' < |result| && result[i'] == text[i] && result[j'] == text[j]
  }
  
  predicate CorrectSpaceTransformation(text: string, result: string)
  {
      (forall start, end :: 0 <= start <= end < |text| && 
          IsSpaceSequence(text, start, end) ==>
          (end - start + 1 <= 2 ==> exists pos :: 0 <= pos < |result| - (end - start) && 
              (forall i :: pos <= i <= pos + (end - start) ==> result[i] == '_')) &&
          (end - start + 1 > 2 ==> exists pos :: 0 <= pos < |result| && result[pos] == '-')) &&
      (forall i :: 0 <= i < |result| && result[i] == '_' ==> 
          exists start, end :: 0 <= start <= end < |text| && 
          IsSpaceSequence(text, start, end) && end - start + 1 <= 2) &&
      (forall i :: 0 <= i < |result| && result[i] == '-' ==> 
          exists start, end :: 0 <= start <= end < |text| && 
          IsSpaceSequence(text, start, end) && end - start + 1 > 2)
  }

vc-helpers: |-
  // ======= HELPERS =======

vc-spec: |-
  // ======= MAIN METHOD =======
  method fix_spaces(text: string) returns (result: string)
      requires ValidInput(text)
      ensures ValidResult(text, result)
      ensures PreservesOrder(text, result)
      ensures CorrectSpaceTransformation(text, result)

vc-code: |-
  {
      if |text| == 0 {
          return text;
      }
  
      var resultSeq: seq<char> := [];
      var i := 0;
  
      while i < |text|
          invariant 0 <= i <= |text|
          invariant |resultSeq| <= i
          invariant forall j :: 0 <= j < |resultSeq| ==> resultSeq[j] != ' '
          invariant forall j :: 0 <= j < |resultSeq| ==> resultSeq[j] == '_' || resultSeq[j] == '-' || resultSeq[j] in text
          invariant forall k :: 0 <= k < i && text[k] != ' ' ==> text[k] in resultSeq
          invariant (forall k :: 0 <= k < i ==> text[k] != ' ') ==> resultSeq == text[0..i]
      {
          if text[i] == ' ' {
              // Count consecutive spaces
              var spaceCount := 0;
              var j := i;
              while j < |text| && text[j] == ' '
                  invariant i <= j <= |text|
                  invariant spaceCount == j - i
                  invariant forall k :: i <= k < j ==> text[k] == ' '
              {
                  spaceCount := spaceCount + 1;
                  j := j + 1;
              }
  
              // Replace based on count
              if spaceCount > 2 {
                  resultSeq := resultSeq + ['-'];
              } else {
                  var k := 0;
                  var initLen := |resultSeq|;
                  while k < spaceCount
                      invariant 0 <= k <= spaceCount
                      invariant |resultSeq| == initLen + k
                      invariant forall m :: initLen <= m < |resultSeq| ==> resultSeq[m] == '_'
                      invariant forall m :: 0 <= m < initLen ==> resultSeq[m] != ' '
                      invariant forall m :: 0 <= m < initLen ==> resultSeq[m] == '_' || resultSeq[m] == '-' || resultSeq[m] in text
                      invariant forall l :: 0 <= l < i && text[l] != ' ' ==> text[l] in resultSeq[0..initLen]
                  {
                      resultSeq := resultSeq + ['_'];
                      k := k + 1;
                  }
              }
  
              i := j;
          } else {
              resultSeq := resultSeq + [text[i]];
              i := i + 1;
          }
      }
  
      return resultSeq;
  }

vc-postamble: |-

