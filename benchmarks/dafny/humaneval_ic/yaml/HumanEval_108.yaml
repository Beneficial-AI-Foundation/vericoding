vc-description: |-
  Given an array of integers, count how many elements have a positive sum of digits. For digit sum calculation: positive numbers sum all digits normally, negative numbers have the first digit as negative and remaining digits as positive, and zero has digit sum 0. Return the count of numbers whose digit sum is greater than 0.

vc-preamble: |-
  // Given an array of integers, count how many elements have a positive sum of digits.
  // For digit sum calculation:
  // - Positive numbers: sum all digits normally
  // - Negative numbers: the first digit is negative, remaining digits are positive
  // - Zero: digit sum is 0
  // Return the count of numbers whose digit sum is greater than 0.
  
  function digitSumFunc(n: int): int
  {
      if n == 0 then 0
      else if n > 0 then sumOfDigitsPos(n)
      else sumOfDigitsPos(-n) - 2 * firstDigit(-n)
  }
  
  function sumOfDigitsPos(n: nat): nat
      requires n >= 0
      ensures n > 0 ==> sumOfDigitsPos(n) > 0
  {
      if n == 0 then 0
      else (n % 10) + sumOfDigitsPos(n / 10)
  }
  
  function firstDigit(n: nat): nat
      requires n > 0
  {
      if n < 10 then n
      else firstDigit(n / 10)
  }
  
  predicate ValidInput(arr: seq<int>)
  {
      true
  }
  
  predicate ValidOutput(arr: seq<int>, count: int)
  {
      0 <= count <= |arr| && count == |set i | 0 <= i < |arr| && digitSumFunc(arr[i]) > 0|
  }

vc-helpers: |-
  method digitSum(n: int) returns (result: int)
      ensures result == digitSumFunc(n)
      ensures n == 0 ==> result == 0
      ensures n > 0 ==> result > 0
  {
      if n == 0 {
          result := 0;
      } else if n > 0 {
          var abs_n := n;
          var sum := 0;
          while abs_n > 0 
              invariant abs_n >= 0
              invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(n)
          {
              sum := sum + (abs_n % 10);
              abs_n := abs_n / 10;
          }
          result := sum;
      } else {
          var abs_n := -n;
          var sum := 0;
          var first_digit := 0;
          var temp := abs_n;
  
          // Get first digit
          while temp >= 10
              invariant temp > 0
              invariant firstDigit(temp) == firstDigit(abs_n)
          {
              temp := temp / 10;
          }
          first_digit := temp;
  
          // Sum all digits
          while abs_n > 0 
              invariant abs_n >= 0
              invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(-n)
          {
              sum := sum + (abs_n % 10);
              abs_n := abs_n / 10;
          }
          result := sum - 2 * first_digit;
      }
  }

vc-spec: |-
  method count_nums(arr: seq<int>) returns (count: int)
      requires ValidInput(arr)
      ensures ValidOutput(arr, count)

vc-code: |-
  {
      count := 0;
      var i := 0;
      while i < |arr|
          invariant 0 <= i <= |arr|
          invariant 0 <= count <= i
          invariant count == |set j | 0 <= j < i && digitSumFunc(arr[j]) > 0|
      {
          var ds := digitSum(arr[i]);
          assert ds == digitSumFunc(arr[i]);
  
          var old_set := set j | 0 <= j < i && digitSumFunc(arr[j]) > 0;
          var new_set := set j | 0 <= j < i + 1 && digitSumFunc(arr[j]) > 0;
  
          if ds > 0 {
              assert digitSumFunc(arr[i]) > 0;
              assert new_set == old_set + {i};
              assert |new_set| == |old_set| + 1;
              count := count + 1;
          } else {
              assert digitSumFunc(arr[i]) <= 0;
              assert i !in old_set;
              assert new_set == old_set;
              assert |new_set| == |old_set|;
          }
  
          i := i + 1;
      }
  }

vc-postamble: |-

