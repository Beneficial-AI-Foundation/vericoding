vc-description: |-
  This verification task implements a string processing function that applies rules in a specific order. Given a string, it first checks if the string contains whitespace and splits on whitespace if so. If there's no whitespace but the string contains commas, it splits on commas. Otherwise, it counts the lowercase letters that are at odd positions in the alphabet (b, d, f, h, etc.).

  The implementation uses a datatype to represent either a sequence of strings (for splitting results) or an integer count, with helper functions for each operation and appropriate specifications ensuring correctness.

vc-preamble: |-
  // ======= TASK =======
  // Given a string, apply rules in order:
  // 1. If contains whitespace, return list of words split on whitespace
  // 2. If no whitespace but contains commas, return list split on commas
  // 3. If neither, return count of lowercase letters at odd alphabet positions

  // ======= SPEC REQUIREMENTS =======
  datatype SplitResult = StringSeq(words: seq<string>) | Count(value: int)

  function contains_space(txt: string): bool
  {
      exists i :: 0 <= i < |txt| && txt[i] == ' '
  }

  function contains_comma(txt: string): bool
  {
      exists i :: 0 <= i < |txt| && txt[i] == ','
  }

vc-helpers: |-
  // ======= HELPERS =======
  function split_on_whitespace(txt: string): seq<string>
      ensures forall w :: w in split_on_whitespace(txt) ==> |w| > 0
      ensures forall w :: w in split_on_whitespace(txt) ==> forall c :: c in w ==> c != ' '
      decreases |txt|
  {
      if |txt| == 0 then
          []
      else
          split_on_whitespace_helper(txt, 0, [], "")
  }

  function split_on_whitespace_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>
      requires 0 <= i <= |txt|
      requires forall w :: w in result ==> |w| > 0
      requires forall w :: w in result ==> forall c :: c in w ==> c != ' '
      requires forall c :: c in current_word ==> c != ' '
      ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> |w| > 0
      ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> forall c :: c in w ==> c != ' '
      decreases |txt| - i
  {
      if i == |txt| then
          if |current_word| > 0 then
              result + [current_word]
          else
              result
      else if txt[i] == ' ' then
          if |current_word| > 0 then
              split_on_whitespace_helper(txt, i + 1, result + [current_word], "")
          else
              split_on_whitespace_helper(txt, i + 1, result, "")
      else
          split_on_whitespace_helper(txt, i + 1, result, current_word + [txt[i]])
  }

  function split_on_comma(txt: string): seq<string>
      ensures |split_on_comma(txt)| > 0
      decreases |txt|
  {
      if |txt| == 0 then
          [""]
      else
          split_on_comma_helper(txt, 0, [], "")
  }

  function split_on_comma_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>
      requires 0 <= i <= |txt|
      ensures |split_on_comma_helper(txt, i, result, current_word)| > 0
      decreases |txt| - i
  {
      if i == |txt| then
          result + [current_word]
      else if txt[i] == ',' then
          split_on_comma_helper(txt, i + 1, result + [current_word], "")
      else
          split_on_comma_helper(txt, i + 1, result, current_word + [txt[i]])
  }

  function count_odd_position_lowercase(txt: string): int
      ensures count_odd_position_lowercase(txt) >= 0
      ensures count_odd_position_lowercase(txt) <= |txt|
  {
      count_odd_position_lowercase_helper(txt, 0)
  }

  function count_odd_position_lowercase_helper(txt: string, i: int): int
      requires 0 <= i <= |txt|
      ensures count_odd_position_lowercase_helper(txt, i) >= 0
      ensures count_odd_position_lowercase_helper(txt, i) <= |txt| - i
      decreases |txt| - i
  {
      if i == |txt| then
          0
      else
          var c := txt[i];
          var count_rest := count_odd_position_lowercase_helper(txt, i + 1);
          if 'a' <= c <= 'z' && (c as int - 'a' as int) % 2 == 1 then
              1 + count_rest
          else
              count_rest
  }

vc-spec: |-
  // ======= MAIN METHOD =======
  function split_words(txt: string): SplitResult
      ensures (contains_space(txt) ==> split_words(txt).StringSeq?) &&
              (!contains_space(txt) && contains_comma(txt) ==> split_words(txt).StringSeq?) &&
              (!contains_space(txt) && !contains_comma(txt) ==> split_words(txt).Count?)
      ensures contains_space(txt) ==> split_words(txt) == StringSeq(split_on_whitespace(txt))
      ensures !contains_space(txt) && contains_comma(txt) ==> split_words(txt) == StringSeq(split_on_comma(txt))
      ensures !contains_space(txt) && !contains_comma(txt) ==> split_words(txt) == Count(count_odd_position_lowercase(txt))
      ensures split_words(txt).StringSeq? ==> |split_words(txt).words| >= 0
      ensures split_words(txt).Count? ==> split_words(txt).value >= 0
      ensures contains_space(txt) ==> (forall w :: w in split_words(txt).words ==> |w| > 0)
      ensures !contains_space(txt) && contains_comma(txt) ==> |split_words(txt).words| > 0

vc-code: |-
  {
      if contains_space(txt) then
          StringSeq(split_on_whitespace(txt))
      else if contains_comma(txt) then
          StringSeq(split_on_comma(txt))
      else
          Count(count_odd_position_lowercase(txt))
  }

vc-postamble: |-
