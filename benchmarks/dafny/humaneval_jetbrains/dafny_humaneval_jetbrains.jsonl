{"id": "142-sum_squares", "vc-preamble": "function sum(s: seq<int>) : int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\nfunction square_seq(lst: seq<int>) : (sq : seq<int>)\n    ensures |sq| == |lst|\n{\n    seq(|lst|, i requires 0 <= i < |lst| => if i % 3 == 0 then lst[i] * lst[i] else (if i % 4 == 0 then lst[i] * lst[i] * lst[i] else lst[i]))\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def sum_squares(lst: List[int]) -> int\nThis function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n*/", "vc-spec": "method sum_squares(lst: seq<int>) returns (r : int)\n    // post-conditions-start\n    ensures r == sum(square_seq(lst))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "002-truncate", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def truncate_number(number: float) -> float\nGiven a positive floating point number, it can be decomposed into and integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1).\n*/", "vc-spec": "method truncate(x : real) returns (i : real)\n    // pre-conditions-start\n    requires x >= 0.0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures (0.0 <= x - i < 1.0)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "010-is_palindrome__make_palindrome", "vc-preamble": "function is_palindrome(s : string) : bool {\n    forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\nfunction starts_with(result : string, s : string) : bool {\n    |result| >= |s| && forall k :: 0 <= k < |s| ==> result[k] == s[k]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method make_palindrome(s: string) returns (result: string)\nProcess input. Ensures: the size is bounded; the result is a palindrome; ensures starts_with(result, s).\n*/", "vc-spec": "method make_palindrome(s: string) returns (result: string)\n    // post-conditions-start\n    ensures |result| <= 2 * |s|\n    ensures is_palindrome(result)\n    ensures starts_with(result, s)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method reverse(str: string) returns (rev: string)\n    // post-conditions-start\n    ensures |rev| == |str|\n    ensures forall k :: 0 <= k < |str| ==> rev[k] == str[|str| - 1 - k]\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "037-sort_even__sorted_even", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method sorted_even(a: seq<int>) returns (sorted: seq<int>)\nSort elements. Requires: requires size of asize of  > 0. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.\n*/", "vc-spec": "method sorted_even(a: seq<int>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |a| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |a|\n  ensures forall i, j :: 0 <= i < j && 2 * i < |sorted| && 2 * j < |sorted| ==>\n      sorted[2 * i] <= sorted[2 * j]\n      ensures forall i :: 0 <= i < |a| && i % 2 == 1 ==> sorted[i] == a[i]\n      ensures multiset(a) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |s| == |p|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "063-fibfib", "vc-preamble": "function fibfib(n: nat): nat\n  decreases n\n{\n  if n == 0 || n == 1 then 0\n  else if n == 2 then 1\n  else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def fibfib(n: int)\nThe FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Please write a function to efficiently compute the n-th element of the fibfib number sequence. Note(Meghana): While the specification asks for an efficient computation of fibfib, we cannot enforce this constraint currently.\n*/", "vc-spec": "method ComputeFibFib(n: nat) returns (result: nat)\n  // post-conditions-start\n  ensures result == fibfib(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "151-double_the_difference", "vc-preamble": "function sumc(s: seq<int>, p: seq<bool>) : int\n    requires |s| == |p|\n    {\n        if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])\n    }\nfunction add_conditon(lst: seq<int>) : (p : seq<bool>)\n    ensures |lst| == |p|\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => lst[i] >= 0 && lst[i] % 2 == 1)\n    }\nfunction square_seq(lst: seq<int>) : (sq : seq<int>)\n        ensures |sq| == |lst|\n        ensures forall i :: 0 <= i < |lst| ==> sq[i] == lst[i] * lst[i]\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => lst[i] * lst[i])\n    }", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def double_the_difference(numbers: List[float]) -> Int\nGiven a list of numbers, return the sum of squares of the numbers in the list that are odd. Ignore numbers that are negative or not integers.\n*/", "vc-spec": "method double_the_difference(lst: seq<int>) returns (r : int)\n    // post-conditions-start\n    ensures r == sumc(square_seq(lst), add_conditon(lst))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "122-add_elements__SumElementsWithAtMostTwoDigits", "vc-preamble": "function sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\nfunction select_at_most_two_digits_rec(arr: seq<int>): seq<int>\n  requires |arr| >= 0 && |arr| <= 100\n{\n  if |arr| == 0 then []\n  else if 0 <= arr[0] < 100 then [arr[0]] + select_at_most_two_digits_rec(arr[1..])\n  else select_at_most_two_digits_rec(arr[1..])\n}\nmethod select_at_most_two_digits(arr: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires |arr| > 0 && |arr| <= 100\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |result| ==> 0 <= result[i] < 100\n  ensures forall i :: 0 <= i < |result| ==> result[i] in arr\n  ensures result == select_at_most_two_digits_rec(arr)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SumElementsWithAtMostTwoDigits(arr: seq<int>, k: int) returns (s: int)\nCalculate sum. Requires: the size is bounded; the size is bounded. Ensures: selects only numbers with at most two digits.\n*/", "vc-spec": "method SumElementsWithAtMostTwoDigits(arr: seq<int>, k: int) returns (s: int)\n  // pre-conditions-start\n  requires |arr| > 0 && |arr| <= 100\n  requires 1 <= k <= |arr|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures var two_digits := select_at_most_two_digits_rec(arr[..k]);\n          s == sum(two_digits)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "134-check_if_last_char_is_a_letter", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def check_if_last_char_is_a_letter(txt: str) -> Bool\nCreate a function that returns True if the last character of a given string is an alphabetical character and is not a part of a word, and False otherwise. Note: \"word\" is a group of characters separated by space.\n*/", "vc-spec": "method check_if_last_char_is_a_letter(s: string) returns (b: bool)\n  // post-conditions-start\n  ensures b <==> |s| > 0 && is_alpha(s[|s| - 1]) && (|s| == 1 || s[|s| - 2] == ' ')\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_alpha(c: char) : bool {\n    'a' <= c <= 'z' || 'A' <= c <= 'Z'\n}\n// pure-end"}
{"id": "070-strange_sort_list__SortSeq", "vc-preamble": "method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\n    // post-conditions-start\n    ensures multiset(s) == multiset(sorted)\n    ensures |s| == |sorted| == |strange|\n    ensures forall i :: 0 <= i < |s| && i % 2 == 0 ==> strange[i] == sorted[i / 2]\n    ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> strange[i] == sorted[|s| - (i - 1) / 2 - 1]\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod strange_sort_list(s: seq<int>) returns (strange: seq<int>)\n    // post-conditions-start\n    ensures |s| == |strange|\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "018-how_many_times", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def how_many_times(string: str, substring: str) -> int\nFind how many times a given substring can be found in the original string. Count overlaping cases.\n*/", "vc-spec": "method how_many_times(s: string, substr: string) returns (times: int)\n    // post-condition-start\n    ensures times == |set i {:trigger} | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr|\n    // post-condition-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "050-encode_shift__encode_shift", "vc-preamble": "function encode_char(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= encode_char(c) <= 'z'\n  // post-conditions-end\n{\n  // impl-start\n  ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n  // impl-end\n}\nfunction decode_char(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= decode_char(c) <= 'z'\n  ensures encode_char(decode_char(c)) == c\n  // post-conditions-end\n{\n  // impl-start\n  ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method encode_shift(s: string) returns (t: string)\nEncode data. Requires: the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method encode_shift(s: string) returns (t: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == encode_char(s[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method decode_shift(s: string) returns (t: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == decode_char(s[i])\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "025-factorize", "vc-preamble": "function prod(s: seq<int>) : int {\n  if |s| == 0 then 1 else prod(s[..|s| - 1]) * s[|s| - 1]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def factorize(n: int) -> List[int]\nReturn list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization. Input number should be equal to the product of all factors\n*/", "vc-spec": "method factorize(n: nat) returns (factors: seq<nat>)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures prod(factors) == n\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "056-correct_bracketing", "vc-preamble": "function CalcBal(s: seq<int>, i: int, j: int) : int \n    requires 0 <= i <= j <= |s|\n{\n    if i == j then 0\n    else (if s[j - 1] == 0 then 1 else -1) + CalcBal(s, i, j - 1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def correct_bracketing(brackets: str) -> Bool\nbrackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket, i.e., (each open bracket is properly closed)\n*/", "vc-spec": "method correct_bracketing(s: seq<int>) returns (b: bool)\n    // pre-conditions-start\n    requires forall i :: 0 <= i < |s| ==> s[i] == 0 || s[i] == 1\n    // pre-conditions-end\n    // post-conditions-start\n    ensures (forall i :: 0 <= i <= |s| ==> CalcBal(s, 0, i) >= 0) ==> b\n    ensures b ==> (forall i :: 0 <= i <= |s| ==> CalcBal(s, 0, i) >= 0)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "062-derivative", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def derivative(xs: List Int) -> List Int\nxs represent coefficients of a polynomial. xs[0] + xs[1] * x + xs[2] * x^2 + .... Return derivative of this polynomial in the same form.\n*/", "vc-spec": "method derivative(xs: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires |xs| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == |xs| - 1\n  ensures forall i :: 0 <= i < |result| ==> result[i] == xs[i+1] * (i+1)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "007-filter_by_substring__checkSubstring", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method checkSubstring(s: string, sub: string) returns (result: bool)\nCheck condition.\n*/", "vc-spec": "method checkSubstring(s: string, sub: string) returns (result: bool)", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method filter_by_substring(strings: seq<string>, substring: string) returns (res : seq<string>)\n    // post-conditions-start\n    ensures |res| <= |strings|\n    ensures (forall s :: s in res ==> s in strings)\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "118-get_closest_vowel", "vc-preamble": "function IsVowel(c: char) : bool\n{\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\nfunction IsConsonant(c: char) : bool\n{\n  ('A' <= c <= 'Z' || 'a' <= c <= 'z') && !IsVowel(c)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def get_closest_vowel(s : str) -> str\nYou are given a word. Your task is to find the closest vowel that stands between two consonants from the right side of the word (case sensitive).\n*/", "vc-spec": "method get_closest_vowel(word: string) returns (result: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |word| ==> ('A' <= word[i] <= 'Z' || 'a' <= word[i] <= 'z')\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| <= 1\n  ensures |result| == 1 ==> IsVowel(result[0])\n  ensures |result| == 1 ==> exists i {:trigger word[i]} ::\n        1 <= i && i + 1 < |word|\n            && IsVowel(word[i]) && IsConsonant(word[i - 1]) && IsConsonant(word[i + 1])\n            && (forall j :: i < j < |word| - 1 ==> !IsVowel(word[j]) || !IsConsonant(word[j - 1]) || !IsConsonant(word[j + 1]))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "066-digitSum", "vc-preamble": "function upper_sum_rec(s: string): int\n  // post-conditions-start\n  ensures upper_sum_rec(s) >= 0\n  // post-conditions-end\n{\n  // impl-start\n  if |s| == 0 then\n    0\n  else\n    var remaining := upper_sum_rec(s[1..]);\n    to_int(s[0]) + remaining\n  // impl-end\n}\nfunction to_int(c: char): int\n    ensures 'A' <= c <= 'Z' ==> to_int(c) == c as int\n    ensures c < 'A' || c > 'Z' ==> to_int(c) == 0\n{\n    if 'A' <= c <= 'Z' then c as int else 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def digitSum(string: str) -> Nat\nWrite a function that takes a string as input and returns the sum of the upper characters only' ASCII codes.\n*/", "vc-spec": "method upper_sum(s: string) returns (res: int)\n    // post-conditions-start\n    ensures res == upper_sum_rec(s)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "149-sorted_list_sum__sort_lengths", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}\nmethod sort_strings(list: seq<string>) returns (sorted: seq<string>)\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method sort_lengths(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Requires: the condition holds for all values. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method sort_lengths(list: seq<string>) returns (sorted: seq<string>)\n    requires forall i : int :: 0 <= i < |list| ==> |list[i]| % 2 == 0\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\n    requires |list| > 0\n    ensures |sorted| <= |list|\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n    ensures multiset(sorted) <= multiset(list)\n{\n  assume{:axiom} false;\n}"}
{"id": "097-multiply", "vc-preamble": "function last_digit(n: int): int\n  // post-conditions-start\n  ensures n >= 0 ==> last_digit(n) == n % 10\n  ensures n < 0 ==> last_digit(n) == (-n) % 10\n  // post-conditions-end\n{\n  // impl-start\n  if n < 0 then (-n) % 10 else n % 10\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def multiply(a : Int, b : Int) -> Int\nComplete the function that takes two integers and returns the product of their unit digits. Assume the input is always valid.\n*/", "vc-spec": "method multiply(a: int, b: int) returns (c: int)\n  // pre-conditions-start\n  requires a >= 0\n  requires b >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures c == last_digit(a) * last_digit(b)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "038-encode_cyclic__decode_cyclic", "vc-preamble": "method encode_cyclic(s: seq<int>) returns (res: seq<int>) \n    // post-conditions-start\n    ensures |s| == |res|\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 2 ==> res[i] == s[i - 2])\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method decode_cyclic(s: seq<int>) returns (res: seq<int>)\nDecode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method decode_cyclic(s: seq<int>) returns (res: seq<int>)\n    // post-conditions-start\n    ensures |s| == |res|\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 2])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i - 1])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "059-largest-prime-factor__largest_prime_factor", "vc-preamble": "method is_prime(k: int) returns (result: bool)\n  // pre-conditions-start\n  requires k >= 2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result ==> forall i :: 2 <= i < k ==> k % i != 0\n  ensures !result ==> exists j :: 2 <= j < k && k % j == 0\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction is_prime_pred(k: int) : bool\n{\n  forall i :: 2 <= i < k ==> k % i != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method largest_prime_factor(n: int) returns (largest: int)\nProcess input. Requires: the result is at least the specified value. Ensures: returns the correct size/count.\n*/", "vc-spec": "method largest_prime_factor(n: int) returns (largest: int)\n  // pre-conditions-start\n  requires n >= 2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 1 <= largest <= n && (largest == 1 || (largest > 1 && is_prime_pred(largest)))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "033-sort_third__sort_third", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method sort_third(a: seq<int>) returns (sorted_even: seq<int>)\nSort elements. Requires: requires size of asize of  > 0. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.\n*/", "vc-spec": "method sort_third(a: seq<int>) returns (sorted_even: seq<int>)\n  // pre-conditions-start\n  requires |a| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted_even| == |a|\n  ensures forall i, j :: 0 <= i < j < |sorted_even| && i % 3 == 0 && j % 3 == 0 ==>\n      sorted_even[i] <= sorted_even[j]\n  ensures forall i :: 0 <= i < |a| && i % 3 != 0 ==> sorted_even[i] == a[i]\n  ensures multiset(a) == multiset(sorted_even)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |s| == |p|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "109-move_one_ball", "vc-preamble": "function is_sorted(a: seq<int>) : bool {\n  forall i, j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def move_one_ball(arr: List[int]) -> bool\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The numbers in the array will be randomly ordered. Your task is to determine if it is possible to get an array sorted in non-decreasing order by performing the following operation on the given array: You are allowed to perform right shift operation any number of times.\n*/", "vc-spec": "method move_one_ball(a: seq<int>) returns (can: bool)\n  // pre-conditions-start\n  requires |a| > 0\n  requires forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j]\n  // pre-conditions-end\n  // post-conditions-start\n  ensures can <==> exists i :: 0 <= i < |a| && is_sorted(a[i..] + a[..i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "092-any_int", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def any_int(a: float, b: float, c: float) -> bool\nCreate a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers. Returns false in any other cases.\n*/", "vc-spec": "method any_int(a: int, b: int, c: int) returns (r: bool)\n  // post-conditions-start\n  ensures r == (a == b + c || b == a + c || c == a + b)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "114-minSubArraySum", "vc-preamble": "function Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def minSubArraySum(nums : list[int]) -> int\nGiven an array of integers nums, find the minimum sum of any non-empty sub-array of nums.\n*/", "vc-spec": "method minSubArraySum(a: seq<int>) returns (s: int)\n  // post-conditions-start\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) >= s\n  ensures exists k, m :: 0 <= k <= m <= |a| && s == Sum(a, k, m)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "006-parse_nested_parens__parse_nested_parens", "vc-preamble": "method parse_paren_group(s : string) returns (max_depth : int)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')'\n    // pre-conditions-end\n    // post-conditions-start\n    ensures max_depth >= 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod split(s : string) returns (res : seq<string>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall s1 :: s1 in res ==> (forall i :: i >= 0 && i < |s1| ==> s1[i] == '(' || s1[i] == ')') && |s1| > 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method parse_nested_parens(paren_string: string) returns (res : seq<int>)\nParse input. Requires: the condition holds for all values. Ensures: the condition holds for all values.\n*/", "vc-spec": "method parse_nested_parens(paren_string: string) returns (res : seq<int>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall x :: x in res ==> x >= 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "145-order_by_points", "vc-preamble": "function digits_sum_pos(n: int): int\n  requires n >= 0\n{\n  if n < 10 then n else digits_sum_pos(n / 10) + n % 10\n}\nfunction digits_sum(n: int): int {\n  if n < 0 then digits_sum_pos(-n) else digits_sum_pos(n)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def order_by_points(nums: List[int]) -> List[int]\nWrite a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.\n*/", "vc-spec": "method order_by_points(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> digits_sum(sorted[i]) <= digits_sum(sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "081-numerical_letter_grade", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def numerical_letter_grade(grades: list[float]) -> list[str]\nIt is the last week of the semester and the teacher has to give the grades to students. The teacher has been making her own algorithm for grading. The only problem is, she has lost the code she used for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list of letter grades using the following table: GPA       |    Letter grade 4.0                A+ > 3.7                A > 3.3                A- > 3.0                B+ > 2.7                B > 2.3                B- > 2.0                C+ > 1.7                C > 1.3                C- > 1.0                D+ > 0.7                D > 0.0                D- 0.0                E Note: I have included a hypothesis that Float is hashable, not sure if this will mess up proving attempts but we can modify it if so. Reviewer: please think if there's a better way. Example: grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n*/", "vc-spec": "method numerical_letter_grade(grades: seq<real>) returns (letters: seq<string>)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |grades| ==> 0.0 <= grades[i] <= 4.0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |letters| == |grades|\n  ensures forall i :: 0 <= i < |grades| && grades[i] == 4.0 ==> letters[i] == \"A+\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] < 4.0 && grades[i] > 3.7 ==> letters[i] == \"A\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 3.7 && grades[i] > 3.3 ==> letters[i] == \"A-\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 3.3 && grades[i] > 3.0 ==> letters[i] == \"B+\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 3.0 && grades[i] > 2.7 ==> letters[i] == \"B\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 2.7 && grades[i] > 2.3 ==> letters[i] == \"B-\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 2.3 && grades[i] > 2.0 ==> letters[i] == \"C+\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 2.0 && grades[i] > 1.7 ==> letters[i] == \"C\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 1.7 && grades[i] > 1.3 ==> letters[i] == \"C-\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 1.3 && grades[i] > 1.0 ==> letters[i] == \"D+\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 1.0 && grades[i] > 0.7 ==> letters[i] == \"D\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] <= 0.7 && grades[i] > 0.0 ==> letters[i] == \"D-\"\n  ensures forall i :: 0 <= i < |grades| && grades[i] == 0.0 ==> letters[i] == \"E\"\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "161-solve__solve", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method solve(s: string) returns (t: string)\nProcess input. Ensures: returns the correct size/count; the condition holds for all values; there exists a value satisfying the condition.\n*/", "vc-spec": "method solve(s: string) returns (t: string)\n  // post-conditions-start \n  ensures |s| == |t|\n  ensures (forall i :: 0 <= i < |s| ==> !is_alpha(s[i])) ==> (forall i :: 0 <= i < |s| ==> s[i] == t[|t| - 1 - i])\n  ensures (exists i :: 0 <= i < |s| && is_alpha(s[i])) ==> \n    (forall i :: 0 <= i < |t| ==> if is_alpha(s[i]) then t[i] == flip_case(s[i]) else t[i] == s[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method reverse(s: string) returns (rev: string)\n  // pre-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // pre-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction is_alpha(c: char) : bool {\n  'a' <= c <= 'z' || 'A' <= c <= 'Z'\n}\n// pure-end\nfunction flip_case(c: char): (flipped: char)\n  requires is_alpha(c)\n  ensures is_alpha(flipped)\n{\n  if 'a' <= c <= 'z' then c - 'a' + 'A' else c - 'A' + 'a'\n}\n// pure-end"}
{"id": "040-triples-sum-to-zero", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def triples_sum_to_zero(numbers: List[int]) -> Bool\ntriples_sum_to_zero takes a list of integers as an input. it returns True if there are three distinct elements in the list that sum to zero, and False otherwise.\n*/", "vc-spec": "method triples_sum_to_zero(l : seq<int>) returns (result : bool)\n    // post-conditions-start\n    ensures result ==> exists i : int, j : int, k : int :: 0 <= i < |l| && 0 <= j < |l| && 0 <= k < |l| && i != j && j != k && i != k && l[i] + l[j] + l[k] == 0\n    ensures !result ==> forall i : int, j : int, k : int :: 0 <= i < |l| && 0 <= j < |l| && 0 <= k < |l| && i != j && j != k && i != k ==> l[i] + l[j] + l[k] != 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "094-skjkasdkd", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def sum_largest_prime(lst : list[int]) -> int\nYou are given a list of integers. You need to find the largest prime value and return the sum of its digits. Note(George): Modified to use List of nats because all examples are nats.\n*/", "vc-spec": "method skjkasdkd(lst: seq<nat>) returns (dsum: nat)\n  // pre-conditions-start\n  requires exists i :: 0 <= i < |lst| && is_prime(lst[i])\n  // pre-conditions-end\n  // post-conditions-start\n  ensures dsum == digits_sum(max_seq(filter_primes(lst)))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function digits_sum(x: nat): nat {\n  if x == 0 then 0 else x % 10 + digits_sum(x / 10)\n}\n// pure-end\nfunction max_seq(lst: seq<int>): (max: int)\n  // pre-conditions-start\n  requires |lst| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |lst| ==> lst[i] <= max\n  // post-conditions-end\n{\n  // impl-start\n  if |lst| == 1\n    then lst[0]\n    else\n      var suf := max_seq(lst[1..]);\n      max(lst[0], suf)\n  // impl-end\n}\nfunction filter_primes(lst: seq<int>): (primes: seq<int>)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |primes| ==> is_prime(primes[i])\n  ensures forall i :: 0 <= i < |lst| && is_prime(lst[i]) ==> lst[i] in primes\n  // post-conditions-end\n{\n  // impl-start\n  if |lst| == 0\n    then []\n    else\n      var tail := filter_primes(lst[1..]);\n      (if is_prime(lst[0]) then [lst[0]] else []) + tail\n  // impl-end\n}\n// pure-end\nfunction max(a: int, b: int): int\n  ensures max(a, b) == a || max(a, b) == b\n  ensures max(a, b) >= a && max(a, b) >= b\n{\n  if a > b then a else b\n}\n// pure-end\nfunction is_prime(k: int) : bool {\n  k != 1 && forall i :: 2 <= i < k ==> k % i != 0\n}\n// pure-end"}
{"id": "016-count_distinct_characters", "vc-preamble": "function contains_char(s: string, c: char): bool\n  decreases |s|\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z' || 'A' <= s[i] <= 'Z'\n  requires 'a' <= c <= 'z'\n{\n  if |s| == 0 then false else s[0] == c || s[0] == upper_char(c) || contains_char(s[1..], c)\n}\nfunction upper_char(c: char) : (C: char)\n  requires 'a' <= c <= 'z'\n  ensures 'A' <= C <= 'Z'\n{ c - 'a' + 'A' }", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def count_distinct_characters(string: str) -> int\nGiven a string, find out how many distinct characters (regardless of case) does it consist of\n*/", "vc-spec": "method count_distinct_characters(s: string) returns (count: int)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z' || 'A' <= s[i] <= 'Z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures count == |set c | 'a' <= c <= 'z' && contains_char(s, c)|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "029-filter_by_prefix", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def filter_by_prefix(strings: List[str], prefix: str) -> List[str]\nFilter an input list of strings only for ones that start with a given prefix.\n*/", "vc-spec": "method filter_by_prefix(xs: seq<string>, p: string) returns (filtered: seq<string>)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |filtered| ==> starts_with(filtered[i], p)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function starts_with(s: string, p: string): bool {\n  |p| == 0 || (|s| != 0 && |s| >= |p| && s[0] == p[0] && starts_with(s[1..], p[1..]))\n}\n// pure-end"}
{"id": "123-get_odd_collatz__next_odd_collatz_iter", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method next_odd_collatz_iter(n: nat) returns (next: nat)\nProcess input. Requires: requires n > 0. Ensures: returns the correct value; returns the correct value.\n*/", "vc-spec": "method next_odd_collatz_iter(n: nat) returns (next: nat)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures next % 2 == 1\n  ensures next == next_odd_collatz(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\n  decreases *\n  requires n > 1\n  ensures forall i :: 0 <= i < |odd_collatz| ==> odd_collatz[i] % 2 == 1\n  ensures forall i :: 1 <= i < |odd_collatz| ==> odd_collatz[i] == next_odd_collatz(odd_collatz[i - 1])\n{\n  assume{:axiom} false;\n}\nmethod get_odd_collatz(n: nat) returns (sorted: seq<int>)\n  decreases *\n  requires n > 1\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1\n{\n  assume{:axiom} false;\n}"}
{"id": "123-get_odd_collatz__get_odd_collatz_unsorted", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}\nmethod next_odd_collatz_iter(n: nat) returns (next: nat)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures next % 2 == 1\n  ensures next == next_odd_collatz(n)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\nSort elements. Requires: requires n > 1. Ensures: the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\n  decreases *\n  requires n > 1\n  ensures forall i :: 0 <= i < |odd_collatz| ==> odd_collatz[i] % 2 == 1\n  ensures forall i :: 1 <= i < |odd_collatz| ==> odd_collatz[i] == next_odd_collatz(odd_collatz[i - 1])", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method get_odd_collatz(n: nat) returns (sorted: seq<int>)\n  decreases *\n  requires n > 1\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1\n{\n  assume{:axiom} false;\n}"}
{"id": "122-add_elements__select_at_most_two_digits", "vc-preamble": "function sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\nfunction select_at_most_two_digits_rec(arr: seq<int>): seq<int>\n  requires |arr| >= 0 && |arr| <= 100\n{\n  if |arr| == 0 then []\n  else if 0 <= arr[0] < 100 then [arr[0]] + select_at_most_two_digits_rec(arr[1..])\n  else select_at_most_two_digits_rec(arr[1..])\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method select_at_most_two_digits(arr: seq<int>) returns (result: seq<int>)\nSelect elements. Requires: the size is bounded. Ensures: the condition holds for all values; the condition holds for all values; selects only numbers with at most two digits.\n*/", "vc-spec": "method select_at_most_two_digits(arr: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires |arr| > 0 && |arr| <= 100\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |result| ==> 0 <= result[i] < 100\n  ensures forall i :: 0 <= i < |result| ==> result[i] in arr\n  ensures result == select_at_most_two_digits_rec(arr)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SumElementsWithAtMostTwoDigits(arr: seq<int>, k: int) returns (s: int)\n  // pre-conditions-start\n  requires |arr| > 0 && |arr| <= 100\n  requires 1 <= k <= |arr|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures var two_digits := select_at_most_two_digits_rec(arr[..k]);\n          s == sum(two_digits)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "120-maximum__maximum", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method maximum(s: seq<int>, k: int) returns (result: seq<int>)\nProcess input. Requires: the size is bounded; the size is bounded; the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method maximum(s: seq<int>, k: int) returns (result: seq<int>)\n  // pre-conditions-start\n  requires 1 <= k <= |s|\n  requires 1 <= |s| <= 1000\n  requires forall x :: x in s ==> -1000 <= x <= 1000\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == k\n  ensures forall i, j :: 0 <= i < j < k ==> result[i] <= result[j]\n  ensures forall x :: x in result ==> x in s\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && s[i] == sorted[j]\n  ensures forall x :: x in s ==> x in sorted\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && sorted[i] == s[j]\n  ensures forall x :: x in sorted ==> x in s\n{\n  assume{:axiom} false;\n}"}
{"id": "024-largest-divisor", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def largest_divisor(n: int) -> int\nFor a given number n, find the largest number that divides n evenly, smaller than n\n*/", "vc-spec": "method largest_divisor(n: int) returns (d : int)\n  // pre-conditions-start\n  requires n > 1\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 1 <= d < n\n  ensures n % d == 0\n  ensures forall k :: d < k < n ==> n % k != 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "112-reverse_delete__reverse_delete", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method reverse_delete(s: string, chars: string) returns (res: string, is_palindrome: bool)\nReverse order. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values; the result is a palindrome.\n*/", "vc-spec": "method reverse_delete(s: string, chars: string) returns (res: string, is_palindrome: bool)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |res| ==> res[i] !in chars\n  ensures forall i :: 0 <= i < |res| ==> res[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] !in chars ==> s[i] in res\n  ensures is_palindrome <==> is_palindrome_pred(res)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method check_palindrome(s: string) returns (result: bool)\n  // post-conditions-start\n  ensures result <==> is_palindrome_pred(s)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction is_palindrome_pred(s : string) : bool {\n  forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\n// pure-end"}
{"id": "065-circular_shift__circular_shift", "vc-preamble": "type stringNat = s: string |\n  |s| > 0 && (|s| > 1 ==> s[0] != '0') &&\n  forall i | 0 <= i < |s| :: s[i] in \"0123456789\"\n  witness \"1\"\nfunction natToString(n: nat): stringNat {\n  match n\n    case 0 => \"0\" case 1 => \"1\" case 2 => \"2\" case 3 => \"3\" case 4 => \"4\"\n    case 5 => \"5\" case 6 => \"6\" case 7 => \"7\" case 8 => \"8\" case 9 => \"9\"\n    case _ => natToString(n / 10) + natToString(n % 10)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method circular_shift(a: nat, shift: nat) returns (shifted: string)\nProcess input. Ensures: returns the correct size/count; the condition holds for all values; returns the correct size/count.\n*/", "vc-spec": "method circular_shift(a: nat, shift: nat) returns (shifted: string)\n  // post-conditions-start\n  ensures |shifted| == |natToString(a)|\n  ensures var s := natToString(a); shift > |s| ==> forall i :: 0 <= i < |s| ==> shifted[i] == s[|s| - 1 - i]\n  ensures var s := natToString(a); shift <= |s| ==> shifted == s[|s| - shift..] + s[..|s| - shift]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method reverse(str: string) returns (rev: string)\n    // post-conditions-start\n    ensures |rev| == |str|\n    ensures forall k :: 0 <= k < |str| ==> rev[k] == str[|str| - 1 - k]\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "005-intersperse", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def intersperse(numbers: List[int], delimeter: int) -> List[int]\nInsert a number 'delimeter' between every two consecutive elements of input list `numbers'\n*/", "vc-spec": "method intersperse(numbers: seq<int>, delimeter: int) returns (res: seq<int>)\n  // post-conditions-start\n  ensures |numbers| != 0 ==> |numbers| * 2 - 1 == |res|\n  ensures |numbers| == 0 ==> |res| == 0\n  ensures forall i : int :: i >= 0 && i < |res| && i % 2 == 0 ==> res[i] == numbers[i / 2]\n  ensures forall i : int :: i >= 0 && i < |res| && i % 2 == 1 ==> res[i] == delimeter\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "057-monotonic", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def monotonic(numbers: List[int]) -> Bool\nReturn True if list elements are monotonically increasing or decreasing.\n*/", "vc-spec": "method monotonic(xs: seq<int>) returns (result: bool)\n  // pre-conditions-start\n  requires |xs| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result <==> (forall i, j :: 0 <= i < j < |xs| ==> xs[i] < xs[j]) || (forall i, j :: 0 <= i < j < |xs| ==> xs[i] > xs[j])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "116-sort_array", "vc-preamble": "function popcount(n: nat): nat {\n  if n == 0 then 0\n  else popcount(n / 2) + n % 2\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int\nPlease write a function that sorts an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.\n*/", "vc-spec": "method sort_array(s: seq<nat>) returns (sorted: seq<nat>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> popcount(sorted[i]) <= popcount(sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "026-remove_duplicates__remove_duplicates", "vc-preamble": "function count_rec(a: seq<int>, x: int): int {\n  if |a| == 0 then 0\n  else count_rec(a[1..], x) + (if a[0] == x then 1 else 0)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method remove_duplicates(a: seq<int>) returns (result: seq<int>)\nProcess input. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method remove_duplicates(a: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |a| ==> count_rec(a, a[i]) >= 1\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |result| ==> count_rec(a, result[i]) == 1\n  ensures forall i :: 0 <= i < |a| ==> (a[i] in result <==> count_rec(a, a[i]) == 1)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method count(a: seq<int>, x: int) returns (cnt: int)\n  // post-conditions-start\n  ensures cnt == |set i | 0 <= i < |a| && a[i] == x|\n  ensures cnt == count_rec(a, x)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "074-total_match__SumChars", "vc-preamble": "function sum_chars_rec(list: seq<string>): nat\n{\n  if |list| == 0 then 0\n  else |list[0]| + sum_chars_rec(list[1..])\n}\nmethod TotalMatch(list1: seq<string>, list2: seq<string>) returns (result: seq<string>)\n  // post-conditions-start\n  ensures |result| == |list1| || |result| == |list2|\n  ensures result == list1 || result == list2\n  ensures sum_chars_rec(result) <= sum_chars_rec(list1)\n  ensures sum_chars_rec(result) <= sum_chars_rec(list2)\n  ensures sum_chars_rec(list1) == sum_chars_rec(list2) ==> result == list1\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SumChars(list: seq<string>) returns (sum: nat)\nCalculate sum. Ensures: returns the sum of character lengths in all strings.\n*/", "vc-spec": "method SumChars(list: seq<string>) returns (sum: nat)\n  // post-conditions-start\n  ensures sum == sum_chars_rec(list)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "110-exchange", "vc-preamble": "function IsEven(n: int) : bool\n{\n  n % 2 == 0\n}\nfunction CountEvens(lst: seq<int>): nat\n{\n  // impl-start\n  if |lst| == 0 then 0\n  else (if IsEven(lst[0]) then 1 else 0) + CountEvens(lst[1..])\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def exchange(lst1: list[int], lst2: list[int]) -> str\nIn this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them to make lst1 a list of only even numbers. There is no limit on the number of exchanged elements between lst1 and lst2. If it is possible to exchange elements between the lst1 and lst2 to make all the elements of lst1 to be even, return \"YES\". Otherwise, return \"NO\". It is assumed that the input lists will be non-empty.\n*/", "vc-spec": "method Exchange(lst1: seq<int>, lst2: seq<int>) returns (result: string)\n  // pre-conditions-start\n  requires |lst1| > 0 && |lst2| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result == \"YES\" || result == \"NO\"\n  ensures result == \"YES\" ==> CountEvens(lst1) + CountEvens(lst2) >= |lst1|\n  ensures result == \"NO\" ==> CountEvens(lst1) + CountEvens(lst2) < |lst1|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "087-get_row__get_row", "vc-preamble": "type SortSeqState = seq<(int, int)>\nfunction less(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  x < u || (x == u && y > v)\n}\nfunction less_eq(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  (x == u && y == v) || less(a, b)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method get_row(lst: seq<seq<int>>, x: int) returns (pos: SortSeqState)\nRetrieve elements. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method get_row(lst: seq<seq<int>>, x: int) returns (pos: SortSeqState)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |pos| ==> (\n    var (a, b) := pos[i];\n    0 <= a < |lst| && 0 <= b < |lst[a]| && lst[a][b] == x\n  )\n  ensures forall i, j :: 0 <= i < |lst| && 0 <= j < |lst[i]| && lst[i][j] == x ==> (i, j) in pos\n  ensures forall i, j :: 0 <= i < j < |pos| ==> less_eq(pos[i], pos[j])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: SortSeqState) returns (sorted: SortSeqState)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> less_eq(sorted[i], sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "048-is-palindrome", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def is_palindrome(string: str) -> Bool\nChecks if given string is a palindrome\n*/", "vc-spec": "method is_palindrome(text : string) returns (result : bool)\n    // post-conditions-start\n    ensures result == (forall i : int :: i >= 0 && i < |text| ==> text[i] == text[|text| - i - 1])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "011-string_xor", "vc-preamble": "function represents_byte(a: char) : bool\n{\n    a in \"01\"\n}\nfunction char_xor(a: char, b: char): char\n    requires represents_byte(a)\n    requires represents_byte(b)\n{\n    if (a == b) then\n        '0'\n    else\n        '1'\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def string_xor(a: str, b: str) -> str\nInput are two strings a and b consisting only of 1s and 0s. Perform binary XOR on these inputs and return result also as a string.\n*/", "vc-spec": "method string_xor(a: string, b: string) returns (result: string)\n    // pre-conditions-start\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |a| ==> represents_byte(a[i])\n    requires forall i :: 0 <= i < |b| ==> represents_byte(b[i])\n    // pre-conditions-end\n    // post-conditions-start\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> represents_byte(result[i])\n    ensures forall i :: 0 <= i < |result| ==> result[i] == char_xor(a[i], b[i])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "034-unique__SortSeq", "vc-preamble": "method uniqueSorted(s: seq<int>) returns (result: seq<int>)\n    // pre-conditions-start\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod unique(s: seq<int>) returns (result: seq<int>)\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "128-prod_signs", "vc-preamble": "function abs(x: int): int\n  ensures abs(x) >= 0\n  ensures abs(x) == x || abs(x) == -x\n  ensures x >= 0 ==> abs(x) == x\n  ensures x < 0 ==> abs(x) == -x\n{\n  if x >= 0 then x else -x\n}\nfunction sum_abs(s: seq<int>) : int\n  ensures sum_abs(s) >= 0\n{\n  if |s| == 0 then 0 else abs(s[0]) + sum_abs(s[1..])\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def prod_signs(arr: List[int]) -> Optional[int]\nYou are given an array arr of integers and you need to return sum of magnitudes of integers multiplied by product of all signs of each number in the array, represented by 1, -1 or 0. Note: return None for empty arr.\n*/", "vc-spec": "method prod_signs(numbers: seq<int>) returns (s: int)\n  ensures abs(s) == sum_abs(numbers)\n  ensures |set i | 0 <= i < |numbers| && numbers[i] < 0| % 2 == 1 ==> s <= 0\n  ensures |set i | 0 <= i < |numbers| && numbers[i] < 0| % 2 == 0 ==> s >= 0", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "055-fib", "vc-preamble": "function fib(n: nat): nat\n  decreases n\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def fib(n: int) -> int\nReturn n-th Fibonacci number.\n*/", "vc-spec": "method ComputeFib(n: nat) returns (result: nat)\n  // post-conditions-start\n  ensures result == fib(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "030-get-positive", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def get_positive(l: list)\nReturn only positive numbers in the list.\n*/", "vc-spec": "method get_positive(l : seq<int>) returns (result : seq<int>)\n    // post-conditions-start\n    ensures forall i : int :: i >= 0 && i < |result| ==> result[i] > 0\n    ensures |result| <= |l|\n    ensures forall i1 :: i1 >= 0 && i1 < |l| ==> (l[i1] > 0 ==> exists i2 :: i2 >= 0 && i2 < |result| && result[i2] == l[i1])\n    ensures |result| == 0 || (forall i1 : int :: i1 >= 0 && i1 < |result| ==> (exists i2 :: i2 >= 0 && i2 < |l| && l[i2] == result[i1]))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "132-is_nested", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def is_nested(string: str) -> Bool\nCreate a function that takes a string as input which contains only parentheses. The function should return True if and only if there is a valid subsequence of parentheses where at least one parenthesis in the subsequence is nested.\n*/", "vc-spec": "method is_nested(s: seq<int>) returns (res: bool) \n    // post-conditions-start\n    ensures res == exists x, y, z, w :: 0 <= x < y < z < w < |s| && s[x] == 0 && s[y] == 0 && s[z] == 1 && s[w] == 1\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "050-encode_shift__decode_shift", "vc-preamble": "function encode_char(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= encode_char(c) <= 'z'\n  // post-conditions-end\n{\n  // impl-start\n  ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n  // impl-end\n}\nfunction decode_char(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= decode_char(c) <= 'z'\n  ensures encode_char(decode_char(c)) == c\n  // post-conditions-end\n{\n  // impl-start\n  ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n  // impl-end\n}\nmethod encode_shift(s: string) returns (t: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == encode_char(s[i])\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method decode_shift(s: string) returns (t: string)\nDecode data. Requires: the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method decode_shift(s: string) returns (t: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == decode_char(s[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "070-strange_sort_list__strange_sort_list", "vc-preamble": "method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\n    // post-conditions-start\n    ensures multiset(s) == multiset(sorted)\n    ensures |s| == |sorted| == |strange|\n    ensures forall i :: 0 <= i < |s| && i % 2 == 0 ==> strange[i] == sorted[i / 2]\n    ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> strange[i] == sorted[|s| - (i - 1) / 2 - 1]\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method strange_sort_list(s: seq<int>) returns (strange: seq<int>)\nSort elements. Ensures: returns the correct size/count.\n*/", "vc-spec": "method strange_sort_list(s: seq<int>) returns (strange: seq<int>)\n    // post-conditions-start\n    ensures |s| == |strange|\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "059-largest-prime-factor__is_prime", "vc-preamble": "function is_prime_pred(k: int) : bool\n{\n  forall i :: 2 <= i < k ==> k % i != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method is_prime(k: int) returns (result: bool)\nCheck if condition holds. Requires: the result is at least the specified value. Ensures: the condition holds for all values; there exists a value satisfying the condition.\n*/", "vc-spec": "method is_prime(k: int) returns (result: bool)\n  // pre-conditions-start\n  requires k >= 2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result ==> forall i :: 2 <= i < k ==> k % i != 0\n  ensures !result ==> exists j :: 2 <= j < k && k % j == 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method largest_prime_factor(n: int) returns (largest: int)\n  // pre-conditions-start\n  requires n >= 2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 1 <= largest <= n && (largest == 1 || (largest > 1 && is_prime_pred(largest)))\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "089-encrypt", "vc-preamble": "function rot_sym(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= rot_sym(c) <= 'z'\n  // post-conditions-end\n{\n  // impl-start\n  var alph := c as int - 'a' as int;\n  ((alph + 2 * 2) % 26 + 'a' as int) as char\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def encrypt(str : str) -> str\nCreate a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being rotated. The alphabet should be rotated in a manner such that the letters shift down by two multiplied to two places.\n*/", "vc-spec": "method encrypt(s: string) returns (r: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |r| == |s|\n  ensures forall i :: 0 <= i < |s| ==> r[i] == rot_sym(s[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "051-remove-vowels", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def remove_vowels(string: str) -> string\nremove_vowels is a function that takes string and returns string without vowels.\n*/", "vc-spec": "method remove_vowels(text : string) returns (s : string)\n    // post-conditions-start\n    ensures forall i : int :: i >= 0 && i < |s| ==> s[i] != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u'\n    ensures forall i : int :: i >= 0 && i < |s| ==> s[i] in text\n    ensures forall j : int :: j >= 0 && j < |text| && text[j] != 'a' && text[j] != 'e' && text[j] != 'i' && text[j] != 'o' && text[j] != 'u' ==> text[j] in s\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "009-rolling_max", "vc-preamble": "datatype Option<T> = None | Some(T)\nfunction getVal(mx : Option<int>) : int\n    requires exists i : int :: mx == Some(i)\n{\n    match mx {\n        case Some(n) => n\n    }\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def rolling_max(numbers: List[int]) -> Tuple[int, int]\nFrom a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n*/", "vc-spec": "method rolling_max(numbers: seq<int>) returns (result : seq<int>)\n    // post-conditions-start\n    ensures |numbers| == |result|\n    ensures forall i : int :: i >= 0 && i < |numbers| ==> numbers[i] <= result[i]\n    ensures forall i : int :: i >= 0 && i + 1 < |numbers| ==> result[i] <= result[i + 1]\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "052-below-threshold", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def below_threshold(numbers: List[Int], threshold: Int) -> bool\n*/", "vc-spec": "method below_threshold(l : seq<int>, t : int) returns (b : bool)\n    // post-conditions-start\n    ensures b == (forall i : int :: i >= 0 && i < |l| ==> l[i] < t)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "053-add", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def add(x: Int, y: Int) -> Int\n*/", "vc-spec": "method add(x: int, y: int) returns (z: int)\n  // post-conditions-start\n  ensures z == x + y\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "010-is_palindrome__reverse", "vc-preamble": "function is_palindrome(s : string) : bool {\n    forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\nfunction starts_with(result : string, s : string) : bool {\n    |result| >= |s| && forall k :: 0 <= k < |s| ==> result[k] == s[k]\n}\nmethod make_palindrome(s: string) returns (result: string)\n    // post-conditions-start\n    ensures |result| <= 2 * |s|\n    ensures is_palindrome(result)\n    ensures starts_with(result, s)\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method reverse(str: string) returns (rev: string)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method reverse(str: string) returns (rev: string)\n    // post-conditions-start\n    ensures |rev| == |str|\n    ensures forall k :: 0 <= k < |str| ==> rev[k] == str[|str| - 1 - k]\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "013-greatest_common_divisor", "vc-preamble": "// recursive version should be more promising", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def greatest_common_divisor(a: int, b: int) -> int\nReturn a greatest common divisor of two integers a and b\n*/", "vc-spec": "method greatest_common_divisor(a: int, b: int) returns (gcd: int)\n    // pre-conditions-start\n    requires a != 0 || b != 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures gcd != 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "004-mean_absolute_derivation", "vc-preamble": "function sum(s: seq<real>) : real {\n  if |s| == 0 then 0.0 else s[0] + sum(s[1..])\n}\nfunction abs(x: real) : real\n  ensures abs(x) >= 0.0\n{\n  if x >= 0.0 then x else -x\n}\nfunction mean(s: seq<real>) : real\n  requires |s| > 0\n{\n  sum(s) / |s| as real\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def mean_absolute_deviation(numbers: List[float]) -> float\nFor a given list of input numbers, calculate Mean Absolute Deviation around the mean of this dataset. Mean Absolute Deviation is the average absolute difference between each element and a centerpoint (mean in this case): MAD = average | x - x_mean |\n*/", "vc-spec": "method mean_absolute_derivation(numbers: seq<real>) returns (derivation: real)\n  // pre-conditions-start\n  requires |numbers| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures var m := mean(numbers);\n    derivation == mean(seq(|numbers|, i requires 0 <= i < |numbers| => abs(numbers[i] - m)))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "007-filter_by_substring__filter_by_substring", "vc-preamble": "method checkSubstring(s: string, sub: string) returns (result: bool)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method filter_by_substring(strings: seq<string>, substring: string) returns (res : seq<string>)\nFilter elements. Ensures: the size is bounded; the condition holds for all values.\n*/", "vc-spec": "method filter_by_substring(strings: seq<string>, substring: string) returns (res : seq<string>)\n    // post-conditions-start\n    ensures |res| <= |strings|\n    ensures (forall s :: s in res ==> s in strings)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "006-parse_nested_parens__parse_paren_group", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method parse_paren_group(s : string) returns (max_depth : int)\nParse input. Requires: the condition holds for all values. Ensures: the result is at least the specified value.\n*/", "vc-spec": "method parse_paren_group(s : string) returns (max_depth : int)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')'\n    // pre-conditions-end\n    // post-conditions-start\n    ensures max_depth >= 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method split(s : string) returns (res : seq<string>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall s1 :: s1 in res ==> (forall i :: i >= 0 && i < |s1| ==> s1[i] == '(' || s1[i] == ')') && |s1| > 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod parse_nested_parens(paren_string: string) returns (res : seq<int>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall x :: x in res ==> x >= 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "146_specialFilter", "vc-preamble": "function first_digit(n: int): int\n  requires n >= 0\n  ensures 0 <= first_digit(n) < 10\n{\n  if n < 10 then n else first_digit(n / 10)\n}\nfunction last_digit(n: int): int\n  requires n >= 0\n  ensures 0 <= last_digit(n) < 10\n  ensures last_digit(n) == n % 10\n{\n  n % 10\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method specialFilter(s: seq<int>) returns (r: seq<int>)\nWrite a function that takes an array of numbers as input and returns the number of elements in the array that are greater than 10 and both first and last digits of a number are odd (1, 3, 5, 7, 9).\n*/", "vc-spec": "method specialFilter(s: seq<int>) returns (r: seq<int>)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |r| ==> r[i] > 10\n  ensures forall x :: x in r ==> x in s\n  ensures forall i :: 0 <= i < |r| ==> first_digit(r[i]) % 2 == 1 && last_digit(r[i]) % 2 == 1\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "068-pluck", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def pluck(numbers: List[Int]) -> List[Int]\nGiven an array representing a branch of a tree that has non-negative integer nodes your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If multiple nodes with the same smallest even value are found return the node that has smallest index.\n*/", "vc-spec": "method PluckSmallestEven(nodes: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires |nodes| <= 10000\n  requires forall i :: 0 <= i < |nodes| ==> nodes[i] >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == 0 || |result| == 2\n  ensures |result| == 2 ==> 0 <= result[1] < |nodes| && nodes[result[1]] == result[0]\n  ensures |result| == 2 ==> result[0] % 2 == 0\n  ensures |result| == 2 ==> forall i :: 0 <= i < |nodes| && nodes[i] % 2 == 0 ==> result[0] <= nodes[i]\n  ensures |result| == 2 ==> forall i :: 0 <= i < result[1] ==> nodes[i] % 2 != 0 || nodes[i] > result[0]\n  ensures |result| == 0 ==> forall i :: 0 <= i < |nodes| ==> nodes[i] % 2 != 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "083-starts_one_ends", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def starts_one_ends(n: int) -> int\nGiven a positive integer n, return the count of the numbers of n-digit positive integers that start or end with 1. Note: For reviewer, I believe this is the most straightforward spec, and I am relying on Set cardianlity not being computable in general. The point of this problem is really to privide a formula. Note: But I guess a program that goes through each number and adds 1 will be the same as a program that computes in O(1) under this view.\n*/", "vc-spec": "method CountNumbersStartingOrEndingWithOne(n: nat) returns (count: nat)\n    // pre-conditions-start\n    requires n > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures n == 1 ==> count == 1\n    ensures n > 1 ==> count == 18 * Pow(10, n - 2)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function Pow(base: nat, exponent: nat): nat\n    ensures exponent == 0 ==> Pow(base, exponent) == 1\n    ensures exponent > 0 ==> Pow(base, exponent) == base * Pow(base, exponent-1)\n{\n    if exponent == 0 then 1 else base * Pow(base, exponent-1)\n}\n// pure-end"}
{"id": "034-unique__uniqueSorted", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method uniqueSorted(s: seq<int>) returns (result: seq<int>)\nSort elements. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method uniqueSorted(s: seq<int>) returns (result: seq<int>)\n    // pre-conditions-start\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method unique(s: seq<int>) returns (result: seq<int>)\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "130-tri", "vc-preamble": "function tri(n: nat): nat\n  decreases if n % 2 == 0 then 0 else n\n{\n  if n == 1 then 3\n  else if n % 2 == 0 then 1 + n / 2\n  else tri(n - 1) + tri(n - 2) + tri(n + 1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def tri(n: int) -> List[int]\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries. However, what people don't know is Tribonacci sequence. Tribonacci sequence is defined by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd. For example: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 You are given a non-negative integer number n, you have to a return a list of the first n + 1 numbers of the Tribonacci sequence.\n*/", "vc-spec": "method Tribonacci(n: nat) returns (result: seq<nat>)\n  // post-conditions-start\n  ensures |result| == n + 1\n  ensures forall i :: 0 <= i <= n ==> result[i] == tri(i)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "082-prime_length", "vc-preamble": "function IsPrime(n: int) : bool\n{\n  n > 1 &&\n  forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def prime_length(s: str) -> bool\nWrite a function that takes a string and returns True if the string length is a prime number or False otherwise\n*/", "vc-spec": "method PrimeLength(s: string) returns (p : bool)\n  // post-conditions-start\n  ensures p <==> IsPrime(|s|)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "158-find_max", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def find_max(words: List String) -> String\nWrite a function that accepts a list of strings. The list contains different words. Return the word with maximum number of unique characters. If multiple strings have maximum number of unique characters, return the one which comes first in lexicographical order.\n*/", "vc-spec": "method find_max(strings : seq<string>) returns (s : string)\n   // pre-conditions-start\n    requires |strings| > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures s in strings\n    ensures forall i : int :: 0 <= i < |strings| ==> |set c | c in s| >= |set c | c in strings[i]|\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "037-sort_even__SortSeqPred", "vc-preamble": "method sorted_even(a: seq<int>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |a| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |a|\n  ensures forall i, j :: 0 <= i < j && 2 * i < |sorted| && 2 * j < |sorted| ==>\n      sorted[2 * i] <= sorted[2 * j]\n      ensures forall i :: 0 <= i < |a| && i % 2 == 1 ==> sorted[i] == a[i]\n      ensures multiset(a) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; returns a sorted permutation of the input; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |s| == |p|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "003-below_zero", "vc-preamble": "function psum(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else psum(s[..(|s|)-1]) + s[ |s| - 1 ]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def below_zero(operations: List[int]) -> bool\nYou're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.\n*/", "vc-spec": "method below_zero(ops: seq<int>) returns (res : bool)\n    // post-conditions-start\n    ensures res ==> forall i : int :: 0 <= i <= |ops| ==> psum(ops[..i]) >= 0\n    ensures !res ==> exists i : int :: 0 <= i <= |ops| && psum(ops[..i]) < 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "041-car_race_collision", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def car_race_collision(x: Nat) -> Nat\nImagine a road that's a perfectly straight infinitely long line. n cars are driving left to right;  simultaneously, a different set of n cars are driving right to left.   The two sets of cars start out being very far from each other.  All cars move in the same speed.  Two cars are said to collide when a car that's moving left to right hits a car that's moving right to left. However, the cars are infinitely sturdy and strong; as a result, they continue moving in their trajectory as if they did not collide. This function outputs the number of such collisions.\n*/", "vc-spec": "method car_race_collision(n: int) returns (cnt: int)\n  // pre-conditions-start\n  requires n >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures cnt == n * n\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "126-is_sorted__is_sorted", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method is_sorted(a: seq<int>) returns (f: bool)\nSort elements. Ensures: the condition holds for all values.\n*/", "vc-spec": "method is_sorted(a: seq<int>) returns (f: bool)\n  // post-conditions-start\n  ensures f == forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> count_set(a, a[i]) <= 2\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)\n  // pre-conditions-start\n  requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n  requires 0 <= pos < |a|\n  requires a[pos] == x\n  requires pos == 0 || a[pos - 1] < x\n  // pre-conditions-end\n  // post-conditions-start\n  ensures count == count_set(a, x)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction count_set(a: seq<int>, x: int): int {\n  |set i | 0 <= i < |a| && a[i] == x|\n}\n// pure-end"}
{"id": "123-get_odd_collatz__get_odd_collatz", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}\nmethod next_odd_collatz_iter(n: nat) returns (next: nat)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures next % 2 == 1\n  ensures next == next_odd_collatz(n)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\n  decreases *\n  requires n > 1\n  ensures forall i :: 0 <= i < |odd_collatz| ==> odd_collatz[i] % 2 == 1\n  ensures forall i :: 1 <= i < |odd_collatz| ==> odd_collatz[i] == next_odd_collatz(odd_collatz[i - 1])\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method get_odd_collatz(n: nat) returns (sorted: seq<int>)\nRetrieve elements. Requires: requires n > 1. Ensures: the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method get_odd_collatz(n: nat) returns (sorted: seq<int>)\n  decreases *\n  requires n > 1\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "107-even_odd_palindrome", "vc-preamble": "function is_palindrome(n: nat) : bool {\n  var s := natToString(n);\n  forall i | 0 <= i < |s| :: s[i] == s[|s|-1-i]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def even_odd_palindrome(n: nat) -> (nat, nat)\nGiven a positive integer n, return a tuple that has the number of even and odd integer palindromes that fall within the range(1, n), inclusive.\n*/", "vc-spec": "method even_odd_palindrome(n: nat) returns (even: nat, odd: nat)\n  // post-conditions-start\n  ensures even == |set i | 0 <= i <= n && i % 2 == 0 && is_palindrome(i)|\n  ensures odd == |set i | 0 <= i <= n && i % 2 == 1 && is_palindrome(i)|", "vc-code": "{\n  assume false;\n}", "vc-postamble": "type stringNat = s: string |\n|s| > 0 && (|s| > 1 ==> s[0] != '0') &&\nforall i | 0 <= i < |s| :: s[i] in \"0123456789\"\nwitness \"1\"\nfunction natToString(n: nat): stringNat {\nmatch n\ncase 0 => \"0\" case 1 => \"1\" case 2 => \"2\" case 3 => \"3\" case 4 => \"4\"\ncase 5 => \"5\" case 6 => \"6\" case 7 => \"7\" case 8 => \"8\" case 9 => \"9\"\ncase _ => natToString(n / 10) + natToString(n % 10)\n}\n// pure-end\nfunction stringToNat(s: stringNat): nat\ndecreases |s|\n{\nif |s| == 1 then\n    match s[0]\n    case '0' => 0 case '1' => 1 case '2' => 2 case '3' => 3 case '4' => 4\n    case '5' => 5 case '6' => 6 case '7' => 7 case '8' => 8 case '9' => 9\nelse\n    stringToNat(s[..|s|-1])*10 + stringToNat(s[|s|-1..|s|])\n}\n// pure-end"}
{"id": "064-vowels_count", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def remove_vowels(string: str) -> Nat\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.\n*/", "vc-spec": "method vowel_count(s: string) returns (count: int)\n  // post-conditions-start\n  ensures count >= 0\n  ensures count == |(set i | 0 <= i < |s| && is_vowel(s[i]))| + if |s| > 0 && s[|s| - 1] == 'y' then 1 else 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_vowel(c: char): bool\n  ensures is_vowel(c) <==> c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n// pure-end"}
{"id": "046-fib4", "vc-preamble": "function fib4_rec(n: nat): nat\n  decreases n\n{\n  if n == 0 || n == 1 || n == 2 then 0\n  else if n == 3 then 1\n  else fib4_rec(n - 1) + fib4_rec(n - 2) + fib4_rec(n - 3) + fib4_rec(n - 4)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def fib4(n: int)\nThe Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fib4(0) -> 0 fib4(1) -> 0 fib4(2) -> 2 fib4(3) -> 0 fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4). Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n*/", "vc-spec": "method fib4(n: nat) returns (result: nat)\n  // post-conditions-start\n  ensures result == fib4_rec(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "105-by_length__SortReverseAndName", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\nSort elements. Ensures: the size is bounded; the condition holds for all values.\n*/", "vc-spec": "method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\n  // post-conditions-start\n  ensures |result| <= |arr|\n  ensures forall i :: 0 <= i < |result| ==>\n    result[i] in [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}\n// pure-end"}
{"id": "034-unique__unique", "vc-preamble": "method uniqueSorted(s: seq<int>) returns (result: seq<int>)\n    // pre-conditions-start\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method unique(s: seq<int>) returns (result: seq<int>)\nProcess input. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method unique(s: seq<int>) returns (result: seq<int>)\n    // post-conditions-start\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "006-parse_nested_parens__split", "vc-preamble": "method parse_paren_group(s : string) returns (max_depth : int)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')'\n    // pre-conditions-end\n    // post-conditions-start\n    ensures max_depth >= 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method split(s : string) returns (res : seq<string>)\nProcess input. Requires: the condition holds for all values. Ensures: the condition holds for all values.\n*/", "vc-spec": "method split(s : string) returns (res : seq<string>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall s1 :: s1 in res ==> (forall i :: i >= 0 && i < |s1| ==> s1[i] == '(' || s1[i] == ')') && |s1| > 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method parse_nested_parens(paren_string: string) returns (res : seq<int>)\n    // pre-conditions-start\n    requires forall i :: i >= 0 && i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall x :: x in res ==> x >= 0\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "021-rescale_to_unit", "vc-preamble": "function affine(x: real, shift: real, scale: real) : real\n    requires scale > 0.0\n{\n    (x + shift) / scale\n}\nfunction affine_seq(s: seq<real>, r: seq<real>, shift: real, scale: real) : bool\n  requires scale > 0.0\n  requires |r| == |s|\n{\n  forall i :: 0 <= i < |s| ==> r[i] == affine(s[i], shift, scale)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def rescale_to_unit(numbers: List[float]) -> List[float]\nGiven list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1\n*/", "vc-spec": "method rescale_to_unit(s: seq<real>) returns (r : seq<real>)\n  // pre-conditions-start\n  requires |s| >= 2\n  requires exists i, j : int :: (0 <= i < j < |s|) && s[i] != s[j]\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |r| == |s|\n  ensures forall i : int :: 0 <= i < |s| ==> 0.0 <= r[i] <= 1.0\n  ensures exists i : int :: 0 <= i < |s| && r[i] == 0.0\n  ensures exists i : int :: 0 <= i < |s| && r[i] == 1.0\n  ensures exists shift, scale :: scale > 0.0 && affine_seq(s, r, shift, scale)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "031-is-prime", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def is_prime(n)\nReturn true if a given number is prime, and false otherwise.\n*/", "vc-spec": "method is_prime(k: int) returns (result: bool)\n  // pre-conditions-start\n  requires k >= 2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result ==> forall i :: 2 <= i < k ==> k % i != 0\n  ensures !result ==> exists j :: 2 <= j < k && k % j == 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "080-is_happy", "vc-preamble": "function ThreeDistinct(s: string, i: int): bool\n    requires 0 < i < |s| - 1\n{\n    (s[i - 1] != s[i]) && (s[i] != s[i + 1]) && (s[i - 1] != s[i + 1])\n}\nfunction Happy(s: string) : bool\n{\n    |s| >= 3 &&\n    forall i :: 0 < i < |s| - 1 ==> ThreeDistinct(s, i)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def is_happy(s: str) -> bool\nYou are given a string s. Your task is to check if the string is happy or not. A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n*/", "vc-spec": "method IsHappy(s: string) returns (happy : bool)\n    // post-conditions-start\n    ensures happy <==> Happy(s)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "058-common", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def common(l1: List[Int], l2: List[Int]) -> List[Int]\nReturn sorted unique common elements for two lists.\n*/", "vc-spec": "method common(l1 : seq<int>, l2 : seq<int>) returns (c : set<int>)\n   // post-conditions-start\n    ensures forall i :: i in c ==> i in l1 && i in l2\n    ensures forall i :: i in l1 && i in l2 ==> i in c\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "033-sort_third__SortSeqPred", "vc-preamble": "method sort_third(a: seq<int>) returns (sorted_even: seq<int>)\n  // pre-conditions-start\n  requires |a| > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted_even| == |a|\n  ensures forall i, j :: 0 <= i < j < |sorted_even| && i % 3 == 0 && j % 3 == 0 ==>\n      sorted_even[i] <= sorted_even[j]\n  ensures forall i :: 0 <= i < |a| && i % 3 != 0 ==> sorted_even[i] == a[i]\n  ensures multiset(a) == multiset(sorted_even)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; returns a sorted permutation of the input; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n  // pre-conditions-start\n  requires |s| == |p|\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "163-generate_integers__generate_integers", "vc-preamble": "method min(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m <= a && m <= b\n{\n  assume{:axiom} false;\n}\nmethod max(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m >= a && m >= b\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method generate_integers(a : int, b : int) returns (result: seq<int>)\nGenerate elements. Ensures: the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method generate_integers(a : int, b : int) returns (result: seq<int>)\n  // post-conditions-start\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] % 2 == 0\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] in [2, 4, 6, 8]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "001-separate-paren-groups", "vc-preamble": "function ParenthesesDepth(s: string, i: int, j: int): int\n    decreases j - i \n    requires 0 <= i <= j <= |s|\n{\n    if i == j then\n        0\n    else if s[i] == '(' then\n        ParenthesesDepth(s, i+1, j) + 1\n    else if s[i] == ')' then\n        ParenthesesDepth(s, i+1, j) - 1\n    else\n        ParenthesesDepth(s, i+1, j)\n}\nfunction InnerDepthsPositive(s: string) : bool\n{\n    forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) > 0\n}\nfunction InnerDepthsNonnegative(s: string) : bool\n{\n    forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) >= 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def separate_paren_groups(paren_string: str) -> List[str]\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.\n*/", "vc-spec": "method separate_paren_groups(paren_string: string) returns (res : seq<string>)\n    // pre-conditions-start\n    requires ParenthesesDepth(paren_string, 0, |paren_string|) == 0\n    requires InnerDepthsNonnegative(paren_string)\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall k :: 0 <= k < |res| ==> ParenthesesDepth(res[k], 0, |res[k]|) == 0\n    ensures forall k :: 0 <= k < |res| ==> InnerDepthsPositive(res[k])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "108-count_nums", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def count_nums(arr: List[int]) -> int\nWrite a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.\n*/", "vc-spec": "method count_nums(s: seq<int>) returns (cnt: nat)\n  // post-conditions-start\n  ensures cnt == |set i | 0 <= i < |s| && digits_sum(s[i]) > 0|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function digits_sum(x: int): int\n  decreases abs(x)\n{\n  if abs(x) < 10 then x else x % 10 + digits_sum(x / 10)\n}\n// pure-end\nfunction abs(x: int): int\n  ensures abs(x) >= 0\n  ensures abs(x) == x || abs(x) == -x\n{\n  if x >= 0 then x else -x\n}\n// pure-end"}
{"id": "098-count_upper", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def count_upper(s : String) -> Int\nGiven a string s, count the number of uppercase vowels in even indices.\n*/", "vc-spec": "method count_upper(s: string) returns (cnt: int)\n  // post-conditions-start\n  ensures cnt == |set i | 0 <= i < |s| && i % 2 == 0 && is_upper_vowel(s[i])|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_upper_vowel(c: char) : bool {\n  c == 'A' || c == 'E' || c == 'U' || c == 'I' || c == 'O'\n}\n// pure-end"}
{"id": "038-encode_cyclic__encode_cyclic", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method encode_cyclic(s: seq<int>) returns (res: seq<int>)\nEncode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values; the condition holds for all values.\n*/", "vc-spec": "method encode_cyclic(s: seq<int>) returns (res: seq<int>) \n    // post-conditions-start\n    ensures |s| == |res|\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 2 ==> res[i] == s[i - 2])\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method decode_cyclic(s: seq<int>) returns (res: seq<int>)\n    // post-conditions-start\n    ensures |s| == |res|\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 2])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i - 1])\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "045-triangle_area", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def triangle_area(a: float, h: float) -> float\nGiven length of a side and high return area for a triangle.\n*/", "vc-spec": "method CalculateTriangleArea(a: real, h: real) returns (area: real)\n  // pre-conditions-start\n  requires h >= 0.0 && a >= 0.0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures area == (h * a) / 2.0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "095-check_dict_case", "vc-preamble": "function IsLowerCase(s: string) : bool\n{\n  forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\nfunction IsUpperCase(s: string) : bool\n{\n  forall i :: 0 <= i < |s| ==> 'A' <= s[i] <= 'Z'\n}\ntype DictCase = map<string, string>", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def check_dict_case(s : dict[str, str]) -> bool\nGiven a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False. The function should return False is the given dictionary is empty. Note(George): Modified the problem to use strings only for both keys and values.\n*/", "vc-spec": "method CheckDictCase(dict: DictCase) returns (result: bool)\n  // post-conditions-start\n  ensures dict == map[] ==> !result\n  ensures result ==> (forall k :: k in dict ==> IsLowerCase(k)) || (forall k :: k in dict ==> IsUpperCase(k))\n  ensures !result ==> dict == map[] || ((exists k :: k in dict && !IsLowerCase(k)) && (exists k :: k in dict && !IsUpperCase(k)))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "054-same-chars", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def same_chars(s0: string, s1: string) -> Bool\n*/", "vc-spec": "method same_chars(s0 : string, s1 : string) returns (b : bool)\n    // post-conditions-start\n    ensures b == ((set i | i in s0) == (set i | i in s1))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "100-make_a_pile", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def make_a_pile(n: int) -> List[int]\nGiven a positive integer n, you have to make a pile of n levels of stones. The first level has n stones. The number of stones in the next level is: Return the number of stones in each level in a list, where element at index i represents the number of stones in the level (i+1).\n*/", "vc-spec": "method make_a_pile(n: int) returns (pile: seq<int>)\n  // pre-conditions-start\n  requires n >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |pile| == n\n  ensures forall i :: 1 <= i < n ==> pile[i] == pile[i - 1] + 2\n  ensures n > 0 ==> pile[0] == n\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "012-longest", "vc-preamble": "datatype Option<T> = None | Some(T)\nfunction getVal(mx : Option<string>) : string\n    requires mx != None\n{\n    match mx {\n        case Some(n) => n\n    }\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def longest(strings: List[str]) -> Optional[str]\nOut of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.\n*/", "vc-spec": "method longest(strings: seq<string>) returns (result : Option<string>)\n  // post-conditions-start\n  ensures result == None <==> |strings| == 0\n  ensures result != None ==> forall s :: s in strings ==> |getVal(result)| >= |s|\n  ensures result != None ==> getVal(result) in strings \n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "078-hex_key", "vc-preamble": "function IsPrimeHexDigit(c: char): bool\n{\n  c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'\n}\nfunction count_prime_hex_digits_rec(num: seq<char>) : (count : int)\n  // post-conditions-start\n  ensures 0 <= count <= |num|\n  // post-conditions-end\n{\n  // impl-start\n  if |num| == 0 then 0\n  else (if IsPrimeHexDigit(num[0]) then 1 else 0) + count_prime_hex_digits_rec(num[1..])\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def hex_key(num: string) -> int\nYou have been tasked to write a function that receives a hexadecimal number as a string and counts the number of hexadecimal digits that are primes (prime number, or a prime, is a natural number greater than 1 that is not a product of two smaller natural numbers). Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. Prime numbers are 2, 3, 5, 7, 11, 13, 17,... So you have to determine a number of the following digits: 2, 3, 5, 7, B (=decimal 11), D (=decimal 13). Note: you may assume the input is always correct or empty string, and symbols A,B,C,D,E,F are always uppercase.\n*/", "vc-spec": "method count_prime_hex_digits(s: seq<char>) returns (count : int)\n    // post-conditions-start\n    ensures count == count_prime_hex_digits_rec(s)\n    ensures 0 <= count <= |s|\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "096-count_up_to", "vc-preamble": "function IsPrime(n: int) : bool\n{\n  n > 1 && forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def count_up_to(n : int) -> list[int]\nImplement a function that takes an non-negative integer and returns an array of the first n integers that are prime numbers and less than n.\n*/", "vc-spec": "method CountUpTo(n: int) returns (primes: seq<int>)\n  // pre-conditions-start\n  requires n >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |primes| ==> IsPrime(primes[i])\n  ensures forall i :: 0 <= i < |primes| ==> primes[i] < n\n  ensures forall p :: 2 <= p < n && IsPrime(p) <==> p in primes\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "087-get_row__SortSeq", "vc-preamble": "type SortSeqState = seq<(int, int)>\nfunction less(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  x < u || (x == u && y > v)\n}\nfunction less_eq(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  (x == u && y == v) || less(a, b)\n}\nmethod get_row(lst: seq<seq<int>>, x: int) returns (pos: SortSeqState)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |pos| ==> (\n    var (a, b) := pos[i];\n    0 <= a < |lst| && 0 <= b < |lst[a]| && lst[a][b] == x\n  )\n  ensures forall i, j :: 0 <= i < |lst| && 0 <= j < |lst[i]| && lst[i][j] == x ==> (i, j) in pos\n  ensures forall i, j :: 0 <= i < j < |pos| ==> less_eq(pos[i], pos[j])\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: SortSeqState) returns (sorted: SortSeqState)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method SortSeq(s: SortSeqState) returns (sorted: SortSeqState)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> less_eq(sorted[i], sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "088-sort_array__SortSeq", "vc-preamble": "method sort_array(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 == 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 != 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "077-iscube__is_cube", "vc-preamble": "method cube_root(N: nat) returns (r: nat)\n  // post-conditions-start\n  ensures cube(r) <= N < cube(r + 1)\n  ensures r <= N\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method is_cube(n: nat) returns (r: bool)\nCheck if condition holds. Ensures: if true, then there exists an integer r such that N = r; if false, then no integer r satisfies N = r.\n*/", "vc-spec": "method is_cube(n: nat) returns (r: bool)\n  // pre-conditions-start\n  // pre-conditions-end\n  // post-conditions-start\n  ensures r ==> exists r :: 0 <= r <= n && n == cube(r)\n  ensures !r ==> forall r :: 0 <= r <= n ==> n != cube(r)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function cube(n: int): int { n * n * n }\n// pure-end"}
{"id": "106-f", "vc-preamble": "function factorial_spec(n : int) : int\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then 1 else n * factorial_spec(n - 1)\n}\nfunction sum_spec(n : int) : int\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then 1 else n + sum_spec(n - 1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def f(n: int) -> List[int]\nImplement the function f that takes n as a parameter, and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even or the sum of numbers from 1 to i otherwise. i starts from 1. the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n*/", "vc-spec": "method f(n : int) returns (result : seq<int>)\n  // pre-conditions-start\n  requires n >= 1\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == n\n  ensures forall i : int :: i >= 0 && i < |result| && i % 2 == 0 ==> result[i] == factorial_spec(i)\n  ensures forall i : int :: i >= 0 && i < |result| && i % 2 != 0 ==> result[i] == sum_spec(i)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "060-sum_to_n", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def sum_to_n(n: Nat) -> Nat\nsum_to_n is a function that sums numbers from 1 to n.\n*/", "vc-spec": "method sum_to_n(n: int) returns (r : int)\n  // post-conditions-start\n  ensures r == n * (n + 1) / 2\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "120-maximum__SortSeq", "vc-preamble": "method maximum(s: seq<int>, k: int) returns (result: seq<int>)\n  // pre-conditions-start\n  requires 1 <= k <= |s|\n  requires 1 <= |s| <= 1000\n  requires forall x :: x in s ==> -1000 <= x <= 1000\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == k\n  ensures forall i, j :: 0 <= i < j < k ==> result[i] <= result[j]\n  ensures forall x :: x in result ==> x in s\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && s[i] == sorted[j]\n  ensures forall x :: x in s ==> x in sorted\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && sorted[i] == s[j]\n  ensures forall x :: x in sorted ==> x in s", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "105-by_length__reverse", "vc-preamble": "method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\n  // post-conditions-start\n  ensures |result| <= |arr|\n  ensures forall i :: 0 <= i < |result| ==>\n    result[i] in [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method reverse(s: seq<int>) returns (rev: seq<int>)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}\n// pure-end"}
{"id": "090-next_smallest", "vc-preamble": "datatype Option<T> = None | Some(T)\nfunction getVal(mx : Option<int>) : int\n    requires mx != None\n{\n    match mx {\n        case Some(n) => n\n    }\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def next_smallest(lst: List[int]) -> Optional[int]\nYou are given a list of integers. Write a function next_smallest() that returns the 2nd smallest element of the list. Return None if there is no such element. TODO(George): Remove this when being reviewed The spec is defined as: if result is none there is no second smallest element, which exists in a finite list iff there are at least two distinct elements in the list. If result is some x, then x is the second smallest element of the list, the spec obtains the sublist of elements smaller than the result, and checks that this sublist does not contain two distinct elements (they are all the same).\n*/", "vc-spec": "method rolling_max(s: seq<int>) returns (res: Option<int>) \n    // post-conditions-start\n    ensures res == None <==> |s| < 2\n    ensures res != None ==> exists x :: 0 <= x < |s| && s[x] == getVal(res)\n    ensures forall x, y :: 0 <= x < y < |s| ==> s[x] <= getVal(res) || s[y] <= getVal(res)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "043-pairs-sum-to-zero", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def pairs_sum_to_zero(numbers: List[int]) -> Bool\npairs_sum_to_zero takes a list of integers as an input. it returns True if there are two distinct elements in the list that sum to zero, and False otherwise.\n*/", "vc-spec": "method pairs_sum_to_zero(l : seq<int>) returns (result : bool)\n   // post-conditions-start\n    ensures result ==> exists i : int, j : int :: 0 <= i < |l| && 0 <= j < |l| && i != j && l[i] + l[j] == 0\n    ensures !result ==> forall i : int, j : int :: 0 <= i < |l| && 0 <= j < |l| && i != j ==> l[i] + l[j] != 0\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "161-solve__reverse", "vc-preamble": "method solve(s: string) returns (t: string)\n  // post-conditions-start \n  ensures |s| == |t|\n  ensures (forall i :: 0 <= i < |s| ==> !is_alpha(s[i])) ==> (forall i :: 0 <= i < |s| ==> s[i] == t[|t| - 1 - i])\n  ensures (exists i :: 0 <= i < |s| && is_alpha(s[i])) ==> \n    (forall i :: 0 <= i < |t| ==> if is_alpha(s[i]) then t[i] == flip_case(s[i]) else t[i] == s[i])\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method reverse(s: string) returns (rev: string)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method reverse(s: string) returns (rev: string)\n  // pre-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // pre-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_alpha(c: char) : bool {\n  'a' <= c <= 'z' || 'A' <= c <= 'Z'\n}\n// pure-end\nfunction flip_case(c: char): (flipped: char)\n  requires is_alpha(c)\n  ensures is_alpha(flipped)\n{\n  if 'a' <= c <= 'z' then c - 'a' + 'A' else c - 'A' + 'a'\n}\n// pure-end"}
{"id": "157-right_angle_triangle", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def right_angle_triangle(a: Nat, b: Nat, c: Nat) -> Bool\nGiven the lengths of the three sides of a triangle. Return True if the three sides form a right-angled triangle, False otherwise. A right-angled triangle is a triangle in which one angle is right angle or 90 degree.\n*/", "vc-spec": "method right_angle_triangle(a : int, b : int, c : int) returns (result : bool)\n  // post-conditions-start\n  ensures result == (a * a + b * b == c * c || a * a + c * c == b * b || b * b + c * c == a * a)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "102-choose_num", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def choose_num(x: int, y: int) -> int\nThis function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1.\n*/", "vc-spec": "method choose_num(x : int, y : int) returns (num : int)\n  // pre-conditions-start\n  requires 0 <= x && 0 <= y\n  // pre-conditions-end\n  // post-conditions-start\n  ensures num == -1 || (num >= x && num <= y)\n  ensures num == -1 || num % 2 == 0\n  ensures num == -1 || (forall i : int :: x <= i <= y && i % 2 == 0 ==> num >= i)\n  ensures num == -1 <==> x >= y\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "079-decimal_to_binary", "vc-preamble": "type stringBin = s: string |\n  |s| > 0 && (|s| > 1 ==> s[0] != '0') &&\n  forall i | 0 <= i < |s| :: s[i] in \"01\"\n  witness \"1\"", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def decimal_to_binary(decimal: nat) -> string\nYou will be given a number in decimal form and your task is to convert it to binary format. The function should return a string, with each character representing a binary number. Each character in the string will be '0' or '1'.\n*/", "vc-spec": "method decimal_to_binary(n: nat) returns (s: string)\n  // post-conditions-start\n  ensures |s| == |decimal_to_binary_helper(n)| + 4\n  ensures s[..2] == \"db\"\n  ensures s[|s| - 2..] == \"db\"\n  ensures s[2..|s| - 2] == decimal_to_binary_helper(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function decimal_to_binary_helper(n: nat): stringBin \n  // post-conditions-start\n  ensures binary_to_decimal(decimal_to_binary_helper(n)) == n\n  // post-conditions-end\n{\n  // impl-start\n  match n\n    case 0 => \"0\" case 1 => \"1\"\n    case _ => decimal_to_binary_helper(n / 2) + decimal_to_binary_helper(n % 2)\n  // impl-end\n}\n// pure-end\nfunction binary_to_decimal(s: stringBin): nat\n  decreases |s|\n{\n  if |s| == 1 then\n    match s[0]\n    case '0' => 0 case '1' => 1\n  else\n    binary_to_decimal(s[..|s|-1])*2 + binary_to_decimal(s[|s|-1..|s|])\n}\n// pure-end"}
{"id": "036-fizz_buzz__count7", "vc-preamble": "method fizz_buzz(n: nat) returns (result: nat)\n  // post-conditions-start\n  ensures result == sum(\n    seq(n, i requires 0 <= i < n => (if i % 11 == 0 || i % 13 == 0 then count7_r(i) else 0))\n  )\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method count7(x: nat) returns (count: nat)\nCount occurrences. Ensures: returns the correct value.\n*/", "vc-spec": "method count7(x: nat) returns (count: nat) \n  // post-conditions-start\n  ensures count == count7_r(x)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function count7_r(x: nat): nat {\n  var lst := if x % 10 == 7 then 1 else 0;\n  if x < 10 then lst else lst + count7_r(x / 10)\n}\n// pure-end\nfunction sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n// pure-end"}
{"id": "111-histogram", "vc-preamble": "type BiggestMap = map<int, int>", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def histogram(s : str) -> Dict[str, int]\nGiven a string representing a space separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count. If several letters have the same occurrence, return all of them.\n*/", "vc-spec": "method count(a: seq<int>) returns (biggest: BiggestMap)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |a| && a[i] in biggest ==>\n    biggest[a[i]] == |set j | 0 <= j < |a| && a[j] == a[i]|\n  ensures forall i, j :: 0 <= i < |a| && 0 <= j < |a| && a[i] in biggest ==>\n    biggest[a[i]] >= |set k | 0 <= k < |a| && a[k] == a[j]|\n  ensures forall i, j :: 0 <= i < |a| && 0 <= j < |a| && a[i] in biggest && a[j] in biggest ==>\n    biggest[a[i]] == biggest[a[j]]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "135_can_arrange", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method can_arrange(arr: seq<int>) returns (pos: int)\nCreate a function which returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1.\n*/", "vc-spec": "method can_arrange(arr: seq<int>) returns (pos: int)\n  // pre-conditions-start\n  requires |arr| > 0\n  requires forall i, j :: 0 <= i < j < |arr| ==> arr[i] != arr[j]\n  // pre-conditions-end\n  // post-conditions-start\n  ensures pos == -1 ==> forall i :: 1 <= i < |arr| ==> arr[i] >= arr[i - 1]\n  ensures pos >= 0 ==> 1 <= pos < |arr| && arr[pos] < arr[pos - 1]\n  ensures pos >= 0 ==> forall i :: pos < i < |arr| ==> arr[i] >= arr[i - 1]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "075-is_multiply_prime", "vc-preamble": "function Prime(p: nat) : bool\n{\n    p > 1 &&\n    forall k :: 1 < k < p ==> p % k != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def is_multiply_prime(a: int) -> bool\nWrite a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise. Knowing that (a) is less then 100.\n*/", "vc-spec": "method is_multiply_prime(x: nat) returns (ans : bool)\n    // pre-conditions-start\n    requires x > 1\n    // pre-conditions-end\n    // post-conditions-start\n    ensures ans <==> exists a: nat, b: nat, c: nat :: Prime(a) && Prime(b) && Prime(c) && x == a * b * c\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "026-remove_duplicates__count", "vc-preamble": "function count_rec(a: seq<int>, x: int): int {\n  if |a| == 0 then 0\n  else count_rec(a[1..], x) + (if a[0] == x then 1 else 0)\n}\nmethod remove_duplicates(a: seq<int>) returns (result: seq<int>)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |a| ==> count_rec(a, a[i]) >= 1\n  // pre-conditions-end\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |result| ==> count_rec(a, result[i]) == 1\n  ensures forall i :: 0 <= i < |a| ==> (a[i] in result <==> count_rec(a, a[i]) == 1)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method count(a: seq<int>, x: int) returns (cnt: int)\nCount occurrences. Ensures: returns the correct count; returns the correct count.\n*/", "vc-spec": "method count(a: seq<int>, x: int) returns (cnt: int)\n  // post-conditions-start\n  ensures cnt == |set i | 0 <= i < |a| && a[i] == x|\n  ensures cnt == count_rec(a, x)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "076-is_simple_power", "vc-preamble": "function power(x: nat, y: nat): nat {\n    if y == 0 then 1 else x * power(x, y-1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def is_simple_power(x: int, n: int) -> bool\nYour task is to write a function that returns true if a number x is a simple power of n and false in other cases. x is a simple power of n if n**int=x\n*/", "vc-spec": "method is_simple_power(x: nat, n: int) returns (ans : bool)\n    // pre-conditions-start\n    requires x > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures ans <==> exists y :: n == power(x, y)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "150-x_or_y", "vc-preamble": "function IsPrime(n: nat) : bool\n{\n  n > 1 &&\n  forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def x_or_y(int n, int x, int y) -> int\nA simple program which should return the value of x if n is a prime number and should return the value of y otherwise.\n*/", "vc-spec": "method x_or_y(n: nat, x: int, y: int) returns (result: int)\n  // post-conditions-start\n  ensures IsPrime(n) ==> result == x\n  ensures !IsPrime(n) ==> result == y\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "153-Strongest_Extension", "vc-preamble": "class Extension {\n    var name: string\n    var strength: int\n    constructor(n: string)\n        ensures name == n\n        ensures strength == CalculateStrength(n)\n    {\n        name := n;\n        strength := CalculateStrength(n);\n    }\n    static function CalculateStrength(s: string): int\n    {\n        CountUpperCase(s) - CountLowerCase(s)\n    }\n    static function CountUpperCase(s: string): int\n    {\n        if |s| == 0 then 0\n        else (if 'A' <= s[0] <= 'Z' then 1 else 0) + CountUpperCase(s[1..])\n    }\n    static function CountLowerCase(s: string): int\n    {\n        if |s| == 0 then 0\n        else (if 'a' <= s[0] <= 'z' then 1 else 0) + CountLowerCase(s[1..])\n    }\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def Strongest_Extension(class_name: String, extensions: List[String]) -> String\nYou will be given the name of a class (a string) and a list of extensions. The extensions are to be used to load additional classes to the class. The strength of the extension is as follows: Let CAP be the number of the uppercase letters in the extension's name, and let SM be the number of lowercase letters in the extension's name, the strength is given by the fraction CAP - SM. You should find the strongest extension and return a string in this format: ClassName.StrongestExtensionName. If there are two or more extensions with the same strength, you should choose the one that comes first in the list. For example, if you are given \"Slices\" as the class and a list of the extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension (its strength is -1).\n*/", "vc-spec": "method Strongest_Extension(className: string, extensions: seq<string>) returns (result: string)\n    // pre-conditions-start\n    requires |extensions| > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures |result| > |className|\n    ensures result[..|className|] == className\n    ensures result[|className|] == '.'\n    ensures var extName := result[|className| + 1..];\n               extName in extensions\n    ensures var extName := result[|className| + 1..];\n               forall i :: 0 <= i < |extensions| ==> Extension.CalculateStrength(extName) >= Extension.CalculateStrength(extensions[i])\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "105-by_length__SortSeq", "vc-preamble": "method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\n  // post-conditions-start\n  ensures |result| <= |arr|\n  ensures forall i :: 0 <= i < |result| ==>\n    result[i] in [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}\n// pure-end"}
{"id": "023-strlen", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def strlen(string: str) -> int\nReturn length of given string\n*/", "vc-spec": "method strlen(s: string) returns (len: int)\n  // post-conditions-start\n  ensures len == |s|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "154-cycpattern_check", "vc-preamble": "function IsSubstring(s: string, sub: string) : bool\n{\n  |s| >= |sub| && exists i {:trigger s[i..i+|sub|]} :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub\n}\nfunction RotateString(s: string, n: nat): string\n  requires 0 <= n <= |s|\n{\n  s[n..] + s[..n]\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def cycpattern_check(String a, String b) -> Bool\nYou are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word, else False\n*/", "vc-spec": "method CycpatternCheck(word: string, pattern: string) returns (result: bool)\n  // post-conditions-start\n  ensures result ==> exists i :: 0 <= i <= |pattern| && IsSubstring(word, RotateString(pattern, i))\n  ensures !result ==> forall i :: 0 <= i <= |pattern| ==> !IsSubstring(word, RotateString(pattern, i))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "000-has_close_elements", "vc-preamble": "function abs(val : real): real\n{\n  if (val < 0.0) then\n    -val\n  else\n    val\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def has_close_elements(numbers: List[float], threshold: float) -> bool\n*/", "vc-spec": "method has_close_elements(numbers: seq<real>, threshold: real) returns (flag : bool)\n  // pre-conditions-start\n  requires threshold > 0.0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures flag == (exists i: int, j: int :: i >= 0 && j >= 0 && i < |numbers| && j < |numbers| && i != j && abs(numbers[i] - numbers[j]) < threshold)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "042-incr-list", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def incr_list(numbers: List[Int]) -> List[Int]\nincr_list takes a list of integers as input and returns a new list where each element is incremented by 1.\n*/", "vc-spec": "method incr_list(l: seq<int>) returns (result: seq<int>)\n    // post-conditions-start\n    ensures |result| == |l|\n    ensures forall i :: 0 <= i < |l| ==> result[i] == l[i] + 1\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "084-solve", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def solve(n: int) -> str\nGiven a positive integer N, return the total sum of its digits in binary.\n*/", "vc-spec": "method solve(n: nat) returns (r: nat)\n  // post-conditions-start\n  ensures r == popcount(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function popcount(n: nat): nat {\n  if n == 0 then 0 else n % 2 + popcount(n / 2)\n}\n// pure-end"}
{"id": "074-total_match__TotalMatch", "vc-preamble": "function sum_chars_rec(list: seq<string>): nat\n{\n  if |list| == 0 then 0\n  else |list[0]| + sum_chars_rec(list[1..])\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method TotalMatch(list1: seq<string>, list2: seq<string>) returns (result: seq<string>)\nProcess input. Ensures: returns the correct size/count; returns the correct size/count; the result is at most the specified value; the result is at most the specified value; returns the correct value.\n*/", "vc-spec": "method TotalMatch(list1: seq<string>, list2: seq<string>) returns (result: seq<string>)\n  // post-conditions-start\n  ensures |result| == |list1| || |result| == |list2|\n  ensures result == list1 || result == list2\n  ensures sum_chars_rec(result) <= sum_chars_rec(list1)\n  ensures sum_chars_rec(result) <= sum_chars_rec(list2)\n  ensures sum_chars_rec(list1) == sum_chars_rec(list2) ==> result == list1\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SumChars(list: seq<string>) returns (sum: nat)\n  // post-conditions-start\n  ensures sum == sum_chars_rec(list)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "152-compare", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def compare(scores: List float, guesses: List float) -> List [float]\nI think we all remember that feeling when the result of some long-awaited event is finally known. The feelings and thoughts you have at that moment are definitely worth noting down and comparing. Your task is to determine if a person correctly guessed the results of a number of matches. You are given two arrays of scores and guesses of equal length, where each index shows a match. Return an array of the same length denoting how far off each guess was. If they have guessed correctly, the value is 0, and if not, the value is the absolute difference between the guess and the score.\n*/", "vc-spec": "method Compare(scores: array<int>, guesses: array<int>) returns (result: array<int>)\n  // pre-conditions-start\n  requires scores.Length == guesses.Length\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result.Length == scores.Length\n  ensures forall i :: 0 <= i < result.Length ==> result[i] == abs(scores[i] - guesses[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function abs(x: int): int\n    ensures 0 <= abs(x)\n{\n  if x < 0 then -x else x\n}\n// pure-end"}
{"id": "104-unique_digits", "vc-preamble": "function HasNoEvenDigit(n: int) : bool\n  decreases n\n{\n  n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && HasNoEvenDigit(n / 10)))\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def unique_digits(x: List[nat]) -> List[nat]\nGiven a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\n*/", "vc-spec": "method UniqueDigits(x: seq<int>) returns (result: seq<int>)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |result| ==> HasNoEvenDigit(result[i])\n  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]\n  ensures forall e :: e in x && HasNoEvenDigit(e) ==> e in result\n  ensures forall e :: e in result ==> e in x\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "115-max_fill", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int\nYou are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets. Constraints: * all wells have the same length * 1 <= grid.length <= 10^2 * 1 <= grid[:,1].length <= 10^2 * grid[i][j] -> 0 | 1 * 1 <= capacity <= 10\n*/", "vc-spec": "method max_fill(grid: seq<seq<nat>>, capacity: nat) returns (cnt: nat)\n  // pre-conditions-start\n  requires capacity > 0\n  requires forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1\n  // pre-conditions-end\n  // post-conditions-start\n  ensures cnt == sum(gen_seq(grid, capacity, |grid|))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function gen_seq(grid: seq<seq<nat>>, capacity: nat, len: nat): seq<int>\n  requires capacity > 0\n  requires len <= |grid|\n  requires forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1\n{\n  seq(len, j requires 0 <= j < len => (sum(grid[j]) + capacity - 1) / capacity)\n}\n// pure-end\nfunction sum(s: seq<int>) : int {\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n// pure-end"}
{"id": "073-smallest_change", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def smallest_change(arr: List[int]) -> int\nGiven an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.\n*/", "vc-spec": "method smallest_change(s: seq<int>) returns (c: int)\n  // post-conditions-start\n  ensures c == |set i | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i]|\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "138_is_equal_to_sum_even", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method is_equal_to_sum_even(n: int) returns (b : bool)\nEvaluate whether the given number n can be written as the sum of exactly 4 positive even numbers.\n*/", "vc-spec": "method is_equal_to_sum_even(n: int) returns (b : bool)\n  // post-conditions-start\n  ensures b <==> n % 2 == 0 && n >= 8 // 2 + 2 + 2 + (n - 6)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "127-intersection", "vc-preamble": "function IsPrime(n: nat) : bool\n{\n  n > 1 &&\n  forall k :: 2 <= k < n ==> n % k != 0\n}\nfunction min(a: int, b: int): int\n{\n  if a <= b then a else b\n}\nfunction max(a: int, b: int): int\n{\n  if a >= b then a else b\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def intersection(interval1: Tuple[Int, Int], interval2: Tuple[Int, Int]) -> str\nYou are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".\n*/", "vc-spec": "method Intersection(start1: int, end1: int, start2: int, end2: int) returns (result: string)\n  // pre-conditions-start\n  requires start1 <= end1 && start2 <= end2\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result == \"YES\" || result == \"NO\"\n  ensures result == \"YES\" <==>\n    (max(start1, start2) <= min(end1, end2) &&\n     IsPrime((min(end1, end2) - max(start1, start2) + 1) as nat))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method {:test} Main()\n{\n  var result1 := Intersection(1, 2, 2, 3);\n  assert result1 == \"NO\";\n  var result2 := Intersection(-1, 1, 0, 4);\n  // The intersection is [0, 1], which has length 2, a prime number\n  assert result2 == \"YES\";\n  var result3 := Intersection(-3, -1, -5, 5);\n  assert result3 == \"YES\";\n  print \"All tests passed!\\n\";\n}"}
{"id": "155_even_odd_count", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method even_odd_count(n: nat) returns (even: nat, odd: nat)\nGiven an integer, return a tuple that has the number of even and odd digits respectively.\n*/", "vc-spec": "method even_odd_count(n: nat) returns (even: nat, odd: nat)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures even == even_count(n)\n  ensures odd == odd_count(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function odd_count(n: nat): nat {\n  if n == 0 then 0\n  else odd_count(n / 10) + n % 2\n}\n// pure-end\nfunction even_count(n: nat): nat\n{\n  if n == 0 then 0\n  else even_count(n / 10) + (1 - n % 2)\n}\n// pure-end"}
{"id": "133-sum_squares", "vc-preamble": "function sum(s: seq<int>) : int\n    {\n        if |s| == 0 then 0 else s[0] + sum(s[1..])\n    }\nfunction ceil(f: real) : (c : int)\n    {\n        (f + 1.0).Floor\n    }\nfunction square_seq(lst: seq<real>) : (sq : seq<int>)\n        ensures |sq| == |lst|\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => ceil(lst[i]) * ceil(lst[i]))\n    }", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def sum_squares(lst: List[float]) -> int\nYou are given a list of numbers. You need to return the sum of squared numbers in the given list, round each element in the list to the upper int(Ceiling) first.\n*/", "vc-spec": "method sum_squares(lst: seq<real>) returns (r : int)\n    // post-conditions-start\n    ensures r == sum(square_seq(lst))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "149-sorted_list_sum__sort_strings", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method sort_strings(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Ensures: returns the correct size/count; returns a sorted permutation of the input.\n*/", "vc-spec": "method sort_strings(list: seq<string>) returns (sorted: seq<string>)\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method sort_lengths(list: seq<string>) returns (sorted: seq<string>)\n    requires forall i : int :: 0 <= i < |list| ==> |list[i]| % 2 == 0\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n{\n  assume{:axiom} false;\n}\nmethod sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\n    requires |list| > 0\n    ensures |sorted| <= |list|\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n    ensures multiset(sorted) <= multiset(list)\n{\n  assume{:axiom} false;\n}"}
{"id": "070-strange_sort_list__strange_sort_list_helper", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\nSort elements. Ensures: returns a sorted permutation of the input; returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.\n*/", "vc-spec": "method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\n    // post-conditions-start\n    ensures multiset(s) == multiset(sorted)\n    ensures |s| == |sorted| == |strange|\n    ensures forall i :: 0 <= i < |s| && i % 2 == 0 ==> strange[i] == sorted[i / 2]\n    ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> strange[i] == sorted[|s| - (i - 1) / 2 - 1]\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method strange_sort_list(s: seq<int>) returns (strange: seq<int>)\n    // post-conditions-start\n    ensures |s| == |strange|\n    // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "069-search", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def search(numbers: List[int]) -> int\nYou are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.\n*/", "vc-spec": "method freq(s: seq<int>, x: int) returns (count: int)\n    // post-conditions-start\n    ensures count == |(set i | 0 <= i < |s| && s[i] == x)|\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "112-reverse_delete__check_palindrome", "vc-preamble": "method reverse_delete(s: string, chars: string) returns (res: string, is_palindrome: bool)\n  // post-conditions-start\n  ensures forall i :: 0 <= i < |res| ==> res[i] !in chars\n  ensures forall i :: 0 <= i < |res| ==> res[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] !in chars ==> s[i] in res\n  ensures is_palindrome <==> is_palindrome_pred(res)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method check_palindrome(s: string) returns (result: bool)\nCheck condition. Ensures: the result is a palindrome.\n*/", "vc-spec": "method check_palindrome(s: string) returns (result: bool)\n  // post-conditions-start\n  ensures result <==> is_palindrome_pred(s)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_palindrome_pred(s : string) : bool {\n  forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\n// pure-end"}
{"id": "085-add", "vc-preamble": "function sumc(s: seq<int>, p: seq<bool>) : int\n    requires |s| == |p|\n    {\n        if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])\n    }\nfunction add_conditon(lst: seq<int>) : (p : seq<bool>)\n    ensures |lst| == |p|\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => i % 2 == 1 && lst[i] % 2 == 0)\n    }", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def solve(n: list[int]) -> int\nGiven a non-empty list of integers lst, add the even elements that are at odd indices.\n*/", "vc-spec": "method add(v: seq<int>) returns (r : int)\n    // post-conditions-start\n    ensures r == sumc(v, add_conditon(v))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "// pure-end"}
{"id": "077-iscube__cube_root", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method cube_root(N: nat) returns (r: nat)\nFind the integer cube root. Ensures: the result r is the largest integer such that r  N < (r+1); the result is at most N.\n*/", "vc-spec": "method cube_root(N: nat) returns (r: nat)\n  // post-conditions-start\n  ensures cube(r) <= N < cube(r + 1)\n  ensures r <= N\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method is_cube(n: nat) returns (r: bool)\n  // pre-conditions-start\n  // pre-conditions-end\n  // post-conditions-start\n  ensures r ==> exists r :: 0 <= r <= n && n == cube(r)\n  ensures !r ==> forall r :: 0 <= r <= n ==> n != cube(r)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction cube(n: int): int { n * n * n }\n// pure-end"}
{"id": "163-generate_integers__min", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method min(a : int, b : int) returns (m : int)\nProcess input. Ensures: returns the correct size/count; the result is at most the specified value.\n*/", "vc-spec": "method min(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m <= a && m <= b", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method max(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m >= a && m >= b\n{\n  assume{:axiom} false;\n}\nmethod generate_integers(a : int, b : int) returns (result: seq<int>)\n  // post-conditions-start\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] % 2 == 0\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] in [2, 4, 6, 8]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "163-generate_integers__max", "vc-preamble": "method min(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m <= a && m <= b\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method max(a : int, b : int) returns (m : int)\nProcess input. Ensures: returns the correct size/count; the result is at least the specified value.\n*/", "vc-spec": "method max(a : int, b : int) returns (m : int)\n  ensures m == a || m == b\n  ensures m >= a && m >= b", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method generate_integers(a : int, b : int) returns (result: seq<int>)\n  // post-conditions-start\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] % 2 == 0\n  ensures forall i : int :: i >= 0 && i < |result| ==> result[i] in [2, 4, 6, 8]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "027-flip_case", "vc-preamble": "function lower(c: char) : bool\n    {\n        'a' <= c <= 'z'\n    }\nfunction upper(c: char) : bool\n    {\n        'A' <= c <= 'Z'\n    }\nfunction alpha(c: char) : bool\n    {\n        lower(c) || upper(c)\n    }\nfunction flip_char(c: char) : (C: char)\n        ensures lower(c) <==> upper(C)\n        ensures upper(c) <==> lower(C)\n    {\n        if lower(c) then c - 'a' + 'A' else\n        if upper(c) then c + 'a' - 'A' else c\n    }", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def flip_case(string: str) -> str\nFor a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n*/", "vc-spec": "method flip_case(s: string) returns (S: string)\n    // post-conditions-start\n    ensures |S| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (lower(s[i]) <==> upper(S[i]))\n    ensures forall i :: 0 <= i < |s| ==> (upper(s[i]) <==> lower(S[i]))\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "049-modp", "vc-preamble": "function modp_rec(n: int, p: int): int\n  requires p > 0\n  requires n >= 0\n{\n    if n == 0 then 1 % p else (modp_rec(n - 1, p) * 2) % p\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def modp(n: Nat, p: Nat) -> Nat\nReturn 2^n modulo p (be aware of numerics).\n*/", "vc-spec": "method modp(n: int, p: int) returns (r: int)\n  // pre-conditions-start\n  requires p > 0\n  requires n >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures r == modp_rec(n, p)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "148-bf", "vc-preamble": "datatype Planet = Mercury | Venus | Earth | Mars | Jupiter | Saturn | Uranus | Neptune\ndatatype Option<T> = Some(value: T) | None\nfunction PlanetFromString(name: string): Option<Planet>\n  ensures PlanetFromString(name).Some? ==> 0 <= PlanetIndex(PlanetFromString(name).value) <= 7\n{\n  match name\n  case \"Mercury\" => Some(Mercury)\n  case \"Venus\" => Some(Venus)\n  case \"Earth\" => Some(Earth)\n  case \"Mars\" => Some(Mars)\n  case \"Jupiter\" => Some(Jupiter)\n  case \"Saturn\" => Some(Saturn)\n  case \"Uranus\" => Some(Uranus)\n  case \"Neptune\" => Some(Neptune)\n  case _ => None\n}\nfunction PlanetIndex(p: Planet): int\n{\n  match p\n  case Mercury => 0\n  case Venus => 1\n  case Earth => 2\n  case Mars => 3\n  case Jupiter => 4\n  case Saturn => 5\n  case Uranus => 6\n  case Neptune => 7\n}\nfunction GetPlanetsBetween(planet1: string, planet2: string): seq<string>\n  // post-conditions-start\n  ensures |GetPlanetsBetween(planet1, planet2)| <= 6\n  // post-conditions-end\n{\n  // impl-start\n  var p1 := PlanetFromString(planet1);\n  var p2 := PlanetFromString(planet2);\n  if p1.None? || p2.None? then\n    []\n  else\n    var i1 := PlanetIndex(p1.value);\n    var i2 := PlanetIndex(p2.value);\n    if i1 < i2 then\n      GetPlanetsBetweenIndices(i1 + 1, i2 - 1)\n    else if i1 > i2 then\n      GetPlanetsBetweenIndices(i2 + 1, i1 - 1)\n    else\n      []\n  // impl-end\n}\nfunction GetPlanetsBetweenIndices(start: int, end: int): seq<string>\n  // pre-conditions-start\n  requires 0 <= start <= 7 && 0 <= end <= 7\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |GetPlanetsBetweenIndices(start, end)| <= (if start <= end then end - start + 1 else 0)\n  // post-conditions-end\n  decreases if start <= end then end - start + 1 else 0\n{\n  // impl-start\n  if start > end then\n    []\n  else\n    match start\n    case 0 => [\"Mercury\"] + GetPlanetsBetweenIndices(1, end)\n    case 1 => [\"Venus\"] + GetPlanetsBetweenIndices(2, end)\n    case 2 => [\"Earth\"] + GetPlanetsBetweenIndices(3, end)\n    case 3 => [\"Mars\"] + GetPlanetsBetweenIndices(4, end)\n    case 4 => [\"Jupiter\"] + GetPlanetsBetweenIndices(5, end)\n    case 5 => [\"Saturn\"] + GetPlanetsBetweenIndices(6, end)\n    case 6 => [\"Uranus\"] + GetPlanetsBetweenIndices(7, end)\n    case 7 => [\"Neptune\"]\n  // impl-end\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def bf(planet1: str, planet2: str) -> List[str]\nThere are eight planets in our solar system: the closest to the Sun is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write a function that takes two planet names as strings planet1 and planet2. The function should return a tuple containing all planets whose orbits are located between the orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun. The function should return an empty tuple if planet1 or planet2 are not correct planet names.\n*/", "vc-spec": "method bf(start: int, end: int) returns (planets: seq<string>)\n    // pre-conditions-start\n    requires 0 <= start <= 7 && 0 <= end <= 7\n    // pre-conditions-end\n    // post-conditions-start\n    ensures |planets| <= (if start <= end then end - start + 1 else 0)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "088-sort_array__reverse", "vc-preamble": "method sort_array(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 == 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 != 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method reverse(s: seq<int>) returns (rev: seq<int>)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "014-all_prefixes", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def all_prefixes(string: str) -> List[str]\nReturn list of all prefixes from shortest to longest of the input string\n*/", "vc-spec": "method all_prefixes(s: string) returns (prefixes: seq<string>)\n    // post-conditions-start\n    ensures |prefixes| == |s|\n    ensures forall i :: 0 <= i < |prefixes| ==> s[..i+1] == prefixes[i]\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "088-sort_array__sort_array", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method sort_array(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: returns the correct size/count; returns the correct size/count; returns the correct size/count.\n*/", "vc-spec": "method sort_array(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures |sorted| == |s|\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 == 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]\n  ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 != 0 ==>\n    forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method reverse(s: seq<int>) returns (rev: seq<int>)\n  // post-conditions-start\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nmethod SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  // post-conditions-start\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}"}
{"id": "036-fizz_buzz__fizz_buzz", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: method fizz_buzz(n: nat) returns (result: nat)\nProcess input. Requires: returns the correct size/count. Ensures: returns the correct value.\n*/", "vc-spec": "method fizz_buzz(n: nat) returns (result: nat)\n  // post-conditions-start\n  ensures result == sum(\n    seq(n, i requires 0 <= i < n => (if i % 11 == 0 || i % 13 == 0 then count7_r(i) else 0))\n  )\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method count7(x: nat) returns (count: nat) \n  // post-conditions-start\n  ensures count == count7_r(x)\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}\nfunction count7_r(x: nat): nat {\n  var lst := if x % 10 == 7 then 1 else 0;\n  if x < 10 then lst else lst + count7_r(x / 10)\n}\n// pure-end\nfunction sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n// pure-end"}
{"id": "072-will_it_fly", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def will_it_fly(q: List[int], w: int) -> bool\nWrite a function that returns True if the object q will fly, and False otherwise. The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n*/", "vc-spec": "method will_it_fly(s: seq<int>, w: int) returns (result: bool)\n    // pre-conditions-start\n    requires |s| > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures result <==> is_palindrome_pred(s) && sum(s) <= w\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function is_palindrome_pred(s : seq<int>) : bool {\n    forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\n// pure-end\nfunction sum(s: seq<int>) : int {\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n// pure-end"}
{"id": "035-max-element", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def max_element(l: list)\nReturn maximum element in the list.\n*/", "vc-spec": "method max_element(l : seq<int>) returns (result : int)\n    // pre-conditions-start\n    requires |l| > 0\n    // pre-conditions-end\n    // post-conditions-start\n    ensures forall i : int :: i >= 0 && i < |l| ==> l[i] <= result\n    ensures exists i : int :: i >= 0 && i < |l| && l[i] == result\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "008-sum_product", "vc-preamble": "function sum(s: seq<int>) : int {\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\nfunction prod(s: seq<int>) : int {\n    if |s| == 0 then 1 else s[0] * prod(s[1..])\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def sum_product(numbers: List[int]) -> Tuple[int, int]\nFor a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.\n*/", "vc-spec": "method sum_product(numbers: seq<int>) returns (s : int, p : int)\n    // post-condition-start\n    ensures s == sum(numbers)\n    ensures p == prod(numbers)\n    // post-condition-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "121-solution", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def solution(lst: List[int]) -> int\nGiven a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n*/", "vc-spec": "method solution(numbers: seq<int>) returns (s: int)\n  // post-conditions-start\n  ensures s == sum(numbers, seq(|numbers|, i requires 0 <= i < |numbers| => i % 2 == 0 && numbers[i] % 2 == 1))\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function sum(s: seq<int>, p: seq<bool>) : int\n  requires |s| == |p|\n{\n  if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sum(s[1..], p[1..])\n}\n// pure-end"}
{"id": "149-sorted_list_sum__sorted_list_sum", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}\nmethod sort_strings(list: seq<string>) returns (sorted: seq<string>)\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n{\n  assume{:axiom} false;\n}\nmethod sort_lengths(list: seq<string>) returns (sorted: seq<string>)\n    requires forall i : int :: 0 <= i < |list| ==> |list[i]| % 2 == 0\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Requires: requires size of listsize of  > 0. Ensures: the size is bounded; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.\n*/", "vc-spec": "method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\n    requires |list| > 0\n    ensures |sorted| <= |list|\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n    ensures multiset(sorted) <= multiset(list)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "136-largest_smallest_integers", "vc-preamble": "datatype Option<T> = None | Some(value: T)\nfunction get_value(o: Option<int>): int\n  requires o.Some?\n  ensures get_value(o) == o.value\n{\n  o.value\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]\nCreate a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.\n*/", "vc-spec": "method largest_smallest_integers(arr: seq<int>) returns (a: Option<int>, b: Option<int>)\n  // post-conditions-start\n  ensures a.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n  ensures a.Some? ==> get_value(a) in arr && get_value(a) < 0\n  ensures a.Some? ==> forall i :: 0 <= i < |arr| && arr[i] < 0 ==> arr[i] <= get_value(a)\n  ensures b.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] <= 0\n  ensures b.Some? ==> get_value(b) in arr && get_value(b) > 0\n  ensures b.Some? ==> forall i :: 0 <= i < |arr| && arr[i] > 0 ==> arr[i] >= get_value(b)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "119-match_parens", "vc-preamble": "function CalcBal(s: seq<int>, i: int, j: int, acc: int) : int \n    requires 0 <= i <= j <= |s|\n{\n    if i == j then acc\n    else (if s[j - 1] == 0 then 1 else -1) + CalcBal(s, i, j - 1, acc)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def match_parens(l : list[str]) -> str\nYou are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only. Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good. A string S is considered to be good if and only if all parentheses in S are balanced. For example: the string '(())()' is good, while the string '())' is not. Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n*/", "vc-spec": "method checkFixed(s1: seq<int>, s2: seq<int>) returns (b: bool) \n    // pre-conditions-start\n    requires forall i :: 0 <= i < |s1| ==> s1[i] == 0 || s1[i] == 1\n    requires forall i :: 0 <= i < |s2| ==> s2[i] == 0 || s2[i] == 1\n    // pre-conditions-end\n    // post-conditions-start\n    ensures b ==> forall i :: 0 <= i <= |s1| ==> CalcBal(s1, 0, i, 0) >= 0\n    ensures b ==> forall i :: 0 <= i <= |s2| ==> CalcBal(s1, 0, |s1|, 0) + CalcBal(s2, 0, i, 0) >= 0\n    ensures !b ==> (exists i :: 0 <= i <= |s1| && CalcBal(s1, 0, i, 0) < 0) || (exists i :: 0 <= i <= |s2| && CalcBal(s1, 0, |s1|, 0) + CalcBal(s2, 0, i, 0) < 0)\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "065-circular_shift__reverse", "vc-preamble": "type stringNat = s: string |\n  |s| > 0 && (|s| > 1 ==> s[0] != '0') &&\n  forall i | 0 <= i < |s| :: s[i] in \"0123456789\"\n  witness \"1\"\nfunction natToString(n: nat): stringNat {\n  match n\n    case 0 => \"0\" case 1 => \"1\" case 2 => \"2\" case 3 => \"3\" case 4 => \"4\"\n    case 5 => \"5\" case 6 => \"6\" case 7 => \"7\" case 8 => \"8\" case 9 => \"9\"\n    case _ => natToString(n / 10) + natToString(n % 10)\n}\nmethod circular_shift(a: nat, shift: nat) returns (shifted: string)\n  // post-conditions-start\n  ensures |shifted| == |natToString(a)|\n  ensures var s := natToString(a); shift > |s| ==> forall i :: 0 <= i < |s| ==> shifted[i] == s[|s| - 1 - i]\n  ensures var s := natToString(a); shift <= |s| ==> shifted == s[|s| - shift..] + s[..|s| - shift]\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method reverse(str: string) returns (rev: string)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.\n*/", "vc-spec": "method reverse(str: string) returns (rev: string)\n    // post-conditions-start\n    ensures |rev| == |str|\n    ensures forall k :: 0 <= k < |str| ==> rev[k] == str[|str| - 1 - k]\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "020-find_closest_elements", "vc-preamble": "function dist(a: real, b: real) : (d : real)\n    ensures d >= 0.0\n    ensures (d == 0.0) <==> a == b\n{\n    if a < b then b - a else a - b\n}\nfunction des(s: seq<real>, a: int, b: int) : bool {\n    // distinct elements\n    0 <= a < |s| && 0 <= b < |s| && a != b\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def find_closest_elements(numbers: List[float]) -> Tuple[float, float]\nFrom a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).\n*/", "vc-spec": "method find_closest_elements(s: seq<real>) returns (l : real, h : real)\n    // pre-conditions-start\n    requires |s| >= 2\n    // pre-conditions-end\n    // post-conditions-start\n    ensures exists a, b : int :: des(s, a, b) && l == s[a] && h == s[b]\n    ensures forall a, b : int :: des(s, a, b) ==> dist(l, h) <= dist(s[a], s[b])\n    ensures l <= h\n    // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "159-eat", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def eat(number: Nat, need: Nat, remaining: Nat) -> List Nat\nYou're a hungry rabbit, and you already have eaten a certain number of carrots, but now you need to eat more carrots to complete the day's meals. you should return an array of [ total number of eaten carrots after your meals, the number of carrots left after your meals ] if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n*/", "vc-spec": "method eat(number : int, need : int, remaining : int) returns (result: seq<int>)\n  // pre-conditions-start\n  requires number >= 0 && need >= 0 && remaining >= 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |result| == 2\n  ensures remaining >= need ==> result[0] == number + need && result[1] == remaining - need\n  ensures remaining < need ==> result[0] == number + remaining && result[1] == 0\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "093-encode", "vc-preamble": "", "vc-helpers": "", "vc-description": "/*\nfunction_signature: def encode(s : str) -> str\nWrite a function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.\n*/", "vc-spec": "method encode(s: string) returns (t: string)\n  // pre-conditions-start\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z' || 'A' <= s[i] <= 'Z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| && is_vowel(s[i]) ==> t[i] == rot2(swap_case(s[i]))\n  ensures forall i :: 0 <= i < |s| && !is_vowel(s[i]) ==> t[i] == swap_case(s[i])\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function swap_case(c: char): char\n  // pre-conditions-start\n  requires 'a' <= c <= 'z' || 'A' <= c <= 'Z'\n  // pre-conditions-end\n  // post-conditions-start\n  ensures 'a' <= c <= 'z' ==> 'A' <= swap_case(c) <= 'Z'\n  ensures 'A' <= c <= 'Z' ==> 'a' <= swap_case(c) <= 'z'\n  ensures is_vowel(swap_case(c)) == is_vowel(c)\n  // post-conditions-end\n{\n  // impl-start\n  if 'a' <= c <= 'z' then\n    'A' + (c - 'a')\n  else\n    'a' + (c - 'A')\n  // impl-end\n}\n// pure-end\nfunction rot2(c: char): char\n  requires is_vowel(c)\n{\n    (c as int + 2) as char\n}\n// pure-end\nfunction is_vowel(c: char) : bool {\n    (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n    || (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n}\n// pure-end"}
{"id": "126-is_sorted__count_sorted", "vc-preamble": "method is_sorted(a: seq<int>) returns (f: bool)\n  // post-conditions-start\n  ensures f == forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> count_set(a, a[i]) <= 2\n  // post-conditions-end\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)\nCount occurrences. Requires: the condition holds for all values; the size is bounded; returns the correct value; returns the correct size/count. Ensures: returns the correct value.\n*/", "vc-spec": "method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)\n  // pre-conditions-start\n  requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n  requires 0 <= pos < |a|\n  requires a[pos] == x\n  requires pos == 0 || a[pos - 1] < x\n  // pre-conditions-end\n  // post-conditions-start\n  ensures count == count_set(a, x)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": "function count_set(a: seq<int>, x: int): int {\n  |set i | 0 <= i < |a| && a[i] == x|\n}\n// pure-end"}
{"id": "139-special_factorial", "vc-preamble": "function factorial(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else n * factorial(n - 1)\n}\nfunction special_factorial_rec(n: nat): nat\n  decreases n\n{\n  if n == 0 then 1 else factorial(n) * special_factorial_rec(n - 1)\n}", "vc-helpers": "", "vc-description": "\n/*\nfunction_signature: def special_factorial(n: int) -> int\nThe Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0. Please write a function that computes the Brazilian factorial.\n*/", "vc-spec": "method special_factorial(n: nat) returns (result: nat)\n  // pre-conditions-start\n  requires n > 0\n  // pre-conditions-end\n  // post-conditions-start\n  ensures result == special_factorial_rec(n)\n  // post-conditions-end", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
