{"id": "DV0000", "language": "dafny", "source": "verina", "source_id": "verina_advanced_1_task", "vc-description": "/*\nThis task requires writing a Dafny function that finds the single number in a non-empty list of integers, where every element appears exactly twice except for one element that appears only once. The function should return the integer that appears only once.\n\nInput: The input is a non-empty list of integers where each integer appears exactly twice except for one element that appears only once.\n\nOutput: The output is a single integer - the unique integer that appears exactly once in the list.\n*/", "vc-preamble": "// Helper function to count occurrences of an element in a sequence\nfunction CountOccurrences(nums: seq<int>, x: int): nat\n{\n    |set i | 0 <= i < |nums| && nums[i] == x|\n}\n\n// Helper function to filter elements equal to x (recursive implementation)\nfunction FilterEqual(nums: seq<int>, x: int): seq<int>\n{\n    if |nums| == 0 then []\n    else if nums[0] == x then [nums[0]] + FilterEqual(nums[1..], x)\n    else FilterEqual(nums[1..], x)\n}", "vc-helpers": "", "vc-spec": "method FindSingleNumber(nums: array<int>) returns (result: int)\n    requires \n        nums.Length > 0\n    requires\n        exists unique_elem :: CountOccurrences(nums[..], unique_elem) == 1\n    requires\n        forall elem :: elem in nums[..] ==> (CountOccurrences(nums[..], elem) == 1 || CountOccurrences(nums[..], elem) == 2)\n    ensures\n        CountOccurrences(nums[..], result) == 1\n    ensures\n        forall x :: x in nums[..] ==> (x == result || CountOccurrences(nums[..], x) == 2)", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0003", "language": "dafny", "source": "verina", "source_id": "verina_advanced_4_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the length of the longest increasing sequence in a given array. The method should return the length of the longest increasing subsequence, in which every element is strictly less than the latter element.\n\n-----Input-----\nThe input consists of an array:\na: The input array.\n\n-----Output-----\nThe output is an integer:\nReturns the length of the longest increasing subsequence, assuring that it is a subsequence of the input sequence and that every element in it is strictly less than the latter one.\n*/", "vc-preamble": "function IntMax(x: int, y: int): int\n{\n    if x < y then y else x\n}", "vc-helpers": "", "vc-spec": "method LongestIncreasingSubsequence(a: array<int>) returns (result: int)\n    ensures result >= 0\n    ensures result <= a.Length", "vc-code": "{\n    // TODO: implement\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0004", "language": "dafny", "source": "verina", "source_id": "verina_advanced_5_task", "vc-description": "/*\nThis task requires writing a Dafny method that adds two non-empty linked lists representing non-negative integers.\nThe digits are stored in reverse order (i.e., the first element is the least significant digit).\nEach node (list element) holds a single digit (ranging from 0 to 9). The function should add the two numbers and return the sum\nas a linked list, also in reverse order.\n\n-----Input-----\nThe input consists of:\n- l1: A list of natural numbers representing the digits of the first number in reverse order.\n- l2: A list of natural numbers representing the digits of the second number in reverse order.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a list of digits (in reverse order) representing the sum of the two input numbers.\n*/", "vc-preamble": "function ListToNat(l: seq<nat>): nat\n    decreases |l|\n{\n    if |l| == 0 then\n        0\n    else\n        l[0] + 10 * ListToNat(l[1..])\n}", "vc-helpers": "", "vc-spec": "method AddTwoNumbers(l1: array<nat>, l2: array<nat>) returns (result: array<nat>)\n    requires \n        l1.Length > 0 &&\n        l2.Length > 0 &&\n        (forall i :: 0 <= i < l1.Length ==> l1[i] < 10) &&\n        (forall i :: 0 <= i < l2.Length ==> l2[i] < 10) &&\n        (l1[l1.Length - 1] != 0 || (l1.Length == 1 && l1[0] == 0)) &&\n        (l2[l2.Length - 1] != 0 || (l2.Length == 1 && l2[0] == 0))\n    ensures\n        result.Length > 0 &&\n        ListToNat(result[..]) == ListToNat(l1[..]) + ListToNat(l2[..]) &&\n        (forall i :: 0 <= i < result.Length ==> result[i] < 10) &&\n        (result[result.Length - 1] != 0 || (l1.Length == 1 && l1[0] == 0 && l2.Length == 1 && l2[0] == 0 && result.Length == 1 && result[0] == 0))", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := new nat[1];\n}", "vc-postamble": ""}
{"id": "DV0005", "language": "dafny", "source": "verina", "source_id": "verina_advanced_6_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given string contains all 5 English vowels: a, e, i, o, u.\n\nThe check is case-insensitive, meaning that both uppercase and lowercase vowels count.\n\n-----Input-----\nThe input consists of a string:\ns: A string of alphabetic characters (may include uppercase and lowercase)\n\n-----Output-----\nThe output is true or false:\nReturns true if the input string contains all 5 vowels (a, e, i, o, u), false otherwise.\n*/", "vc-preamble": "function ToLower(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        (c as int + 32) as char\n    else\n        c\n}\n\nfunction NormalizeStr(s: string): seq<char>\n{\n    seq(|s|, i requires 0 <= i < |s| => ToLower(s[i]))\n}", "vc-helpers": "", "vc-spec": "method AllVowels(s: string) returns (result: bool)\n    ensures\n        result <==> (\n            'a' in NormalizeStr(s) &&\n            'e' in NormalizeStr(s) &&\n            'i' in NormalizeStr(s) &&\n            'o' in NormalizeStr(s) &&\n            'u' in NormalizeStr(s)\n        )", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0007", "language": "dafny", "source": "verina", "source_id": "verina_advanced_8_task", "vc-description": "/*\nThis task requires writing a Verus method that determines whether it is possible to complete a circular journey around a set of gas stations. Each gas station provides a certain amount of gas, and traveling from one station to the next consumes a certain amount of gas.\n\nYou start the journey at one of the gas stations with an empty tank. The goal is to find the starting station's index that allows completing the entire circuit once in the clockwise direction without running out of gas. If such a station exists, return its index. Otherwise, return -1.\n\nIf multiple solutions exist, return the one with the smallest starting gas station index.\n\nInput:\nThe input consists of two arrays:\n\ngas: An array of integers where gas[i] represents the amount of gas available at the ith station.\n\ncost: An array of integers where cost[i] is the amount of gas required to travel from station i to station i + 1.\n\nOutput:\nThe output is an integer:\nReturns the index of the starting gas station that allows a complete trip around the circuit. If it is not possible to complete the circuit, return -1.\n*/", "vc-preamble": "function CalculateAcc(gas: array<int>, cost: array<int>, start: int, steps: int): int\n    requires gas.Length == cost.Length\n    requires gas.Length > 0\n    requires 0 <= start < gas.Length\n    reads gas, cost\n    decreases steps\n{\n    if steps <= 0 then\n        0\n    else\n        var prev_acc := CalculateAcc(gas, cost, start, steps - 1);\n        var jdx := ((start + (steps - 1)) % gas.Length) % gas.Length;\n        prev_acc + gas[jdx] - cost[jdx]\n}\n\npredicate ValidStartingPoint(gas: array<int>, cost: array<int>, start: int)\n    requires gas.Length == cost.Length\n    requires gas.Length > 0\n    reads gas, cost\n{\n    0 <= start < gas.Length && \n    forall i {:trigger CalculateAcc(gas, cost, start, i + 1)} :: 0 <= i < gas.Length ==> CalculateAcc(gas, cost, start, i + 1) >= 0\n}", "vc-helpers": "", "vc-spec": "method CanCompleteCircuit(gas: array<int>, cost: array<int>) returns (result: int)\n    requires gas.Length == cost.Length\n    requires gas.Length > 0\n    ensures (result == -1) ==> (forall start :: 0 <= start < gas.Length ==> !ValidStartingPoint(gas, cost, start))\n    ensures (result >= 0) ==> (\n        0 <= result < gas.Length &&\n        ValidStartingPoint(gas, cost, result) &&\n        (forall start :: 0 <= start < result ==> !ValidStartingPoint(gas, cost, start))\n    )", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0008", "language": "dafny", "source": "verina", "source_id": "verina_advanced_9_task", "vc-description": "/*\nThis task requires writing a Dafny method of which given a number n and divisor d, it counts all the number that is smaller than\nn whose sum of digits is divisible by d.\n-----Input-----\nThe input consists of two nat:\nn: nat\nd: nat where d > 0\n\n-----Output-----\nThe output is a natural number:\nEnsure this match the count that satisfy the property.\n*/", "vc-preamble": "function SumOfDigits(x: nat): nat\n    decreases x\n{\n    if x == 0 then 0 else (x % 10) + SumOfDigits(x / 10)\n}\n\npredicate IsSumDivisibleBy(x: nat, d: nat)\n    requires d > 0\n{\n    (SumOfDigits(x) % d) == 0\n}", "vc-helpers": "", "vc-spec": "method CountSumDivisibleBy(n: nat, d: nat) returns (result: nat)\n    requires d > 0\n    ensures result <= n", "vc-code": "{\n    // TODO: implement\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0009", "language": "dafny", "source": "verina", "source_id": "verina_advanced_10_task", "vc-description": "/*\nThis task requires writing a Dafny method that decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:\n\\[ n = \\prod p^e \\]\nIn other words, it determines the exponent e for each prime p.\n\n-----Input-----\nThe input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.\nn: The natural number to be factorized.\nprimes: A list of primes to decompose n into.\n\n-----Output-----\nThe output is `seq<(nat, nat)>`:\nReturn a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.\n*/", "vc-preamble": "function pow(base: int, exp: nat): int\n{\n    if exp == 0 then 1 else base * pow(base, exp - 1)\n}\n\npredicate IsPrime(n: nat)\n{\n    true // Abstract predicate for prime numbers\n}\n\nfunction SpecFold(pairs: seq<(nat, nat)>, acc: int): int\n    decreases |pairs|\n{\n    if |pairs| == 0 then\n        acc\n    else\n        var p, e := pairs[0].0, pairs[0].1;\n        SpecFold(pairs[1..], acc * pow(p as int, e))\n}", "vc-helpers": "", "vc-spec": "method FindExponents(n: nat, primes: seq<nat>) returns (result: seq<(nat, nat)>)\n    requires forall i :: 0 <= i < |primes| ==> IsPrime(primes[i])\n    ensures n as int == SpecFold(result, 1)\n    ensures forall i :: 0 <= i < |result| ==> result[i].0 in primes\n    ensures forall p :: p in primes ==> \n        exists j :: 0 <= j < |result| && result[j].0 == p", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := [];\n}", "vc-postamble": ""}
{"id": "DV0010", "language": "dafny", "source": "verina", "source_id": "verina_advanced_11_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the **majority element** in a list of integers. A majority element is defined as an element that appears **strictly more than half** the number of times in the list.\n\nIf such an element exists, the method should return that element. Otherwise, it should return `-1`. The implementation must ensure that the result is either the majority element (if one exists) or `-1` (when no such element appears more than ⌊n/2⌋ times).\n\n**Input**\nThe input consists of a list of integers:\n- lst: A list of integers, which may include duplicates and negative numbers. The list may also be empty.\n\n**Output**\nThe output is a single integer:\n- If a majority element exists in the input list, return that element.\n- If no majority element exists, return `-1`.\n*/", "vc-preamble": "function CountOccurrences(x: int, lst: seq<int>): nat\n{\n    |set i | 0 <= i < |lst| && lst[i] == x|\n}", "vc-helpers": "", "vc-spec": "method FindMajorityElement(lst: array<int>) returns (result: int)\n    ensures var lst_seq := lst[..];\n            var n := |lst_seq|;\n            var majority := CountOccurrences(result, lst_seq) > n / 2 && \n                          forall x :: CountOccurrences(x, lst_seq) <= n / 2 || x == result;\n            (result == -1 ==> forall x :: CountOccurrences(x, lst_seq) <= n / 2) &&\n            (result != -1 ==> majority)", "vc-code": "{\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0011", "language": "dafny", "source": "verina", "source_id": "verina_advanced_12_task", "vc-description": "/*\nWrite a Dafny function that returns the first duplicate integer found in a list. The function should return the value of the first duplicate it encounters, scanning from left to right. If no duplicates exist, return -1.\n\nInput: lst: A sequence of integers.\nOutput: An integer representing the first duplicated value if any exists, otherwise -1.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method FirstDuplicate(lst: seq<int>) returns (result: int)\n    ensures\n        /* if result = -1, then lst does not contain any duplicates */\n        (result == -1 ==> forall i, j :: 0 <= i < j < |lst| ==> lst[i] != lst[j]) &&\n        /* if result is not -1, then it is the first duplicate in lst */\n        (result != -1 ==> \n            exists i, j :: (0 <= i < j < |lst| && lst[i] == lst[j] && lst[i] == result &&\n            forall k, l :: 0 <= k < l < |lst| && lst[k] == lst[l] && l <= i ==> k >= i))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := -1;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0012", "language": "dafny", "source": "verina", "source_id": "verina_advanced_13_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether there are any intersections between chords on a circle. The method should return true if at least one pair of chords intersects, and false otherwise.\n\nA chord is defined as a line segment connecting two distinct points on a circle. Two chords intersect if they cross each other inside the circle. The points are numbered from 1 to 2N in a clockwise direction, where N is the number of chords.\n\nConstraints\n\n- 2 ≤ N ≤ 2×10^5\n- 1 ≤ A_i,B_i ≤ 2N\n- A_1,…,A_N,B_1,…,B_N are all distinct\n- All input values are integers\n\nInput:\nThe input consists of two parameters:\nN: A natural number representing the number of chords (2 ≤ N ≤ 2×10^5).\nchords: A list of N pairs of natural numbers, where each pair represents the endpoints of a chord. All endpoint values are distinct and range from 1 to 2N.\n\nOutput:\nThe output is a boolean value:\n- Returns true if there exists at least one pair of intersecting chords.\n- Returns false if no chords intersect.\n*/", "vc-preamble": "predicate ChordIntersects(chord1: seq<nat>, chord2: seq<nat>)\n    requires |chord1| == 2 && |chord2| == 2\n{\n    var a1 := if chord1[0] < chord1[1] then chord1[0] else chord1[1];\n    var b1 := if chord1[0] > chord1[1] then chord1[0] else chord1[1];\n    var a2 := if chord2[0] < chord2[1] then chord2[0] else chord2[1];\n    var b2 := if chord2[0] > chord2[1] then chord2[0] else chord2[1];\n    (a1 < a2 && a2 < b1 && b1 < b2) || (a2 < a1 && a1 < b2 && b2 < b1)\n}", "vc-helpers": "", "vc-spec": "method HasChordIntersection(n: nat, chords: seq<seq<nat>>) returns (result: bool)\n    requires\n        n >= 2\n    requires\n        |chords| == n\n    requires\n        forall i :: 0 <= i < |chords| ==> (\n            |chords[i]| == 2 &&\n            chords[i][0] >= 1 && chords[i][0] <= 2 * n &&\n            chords[i][1] >= 1 && chords[i][1] <= 2 * n\n        )\n    requires\n        /* All endpoints are distinct */\n        forall i, j, k, l :: \n            (0 <= i < |chords| && 0 <= j < |chords| && \n            0 <= k < 2 && 0 <= l < 2 && \n            (i != j || k != l)) ==> chords[i][k] != chords[j][l]\n    ensures\n        result == exists i, j :: \n            0 <= i < |chords| && 0 <= j < |chords| && i != j &&\n            ChordIntersects(chords[i], chords[j])", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := false;\n}", "vc-postamble": ""}
{"id": "DV0013", "language": "dafny", "source": "verina", "source_id": "verina_advanced_14_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a natural number is a power of four. The method should return a boolean value that indicates whether the given natural number is a power of four. An integer n is a power of four, if there exists a natural number x such that n = 4^x.\n\n-----Input-----\nThe input consists of one natural number:\nn: A natural number.\n\n-----Output-----\nThe output is a boolean value:\nReturn a boolean value that indicates whether the given natural number is a power of four. Return \"true\" if it is a power of four. Otherwise, return \"false\".\n*/", "vc-preamble": "function Power(base: int, exp: nat): int\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}", "vc-helpers": "", "vc-spec": "method IfPowerOfFour(n: nat) returns (result: bool)\n    ensures result <==> (exists m: nat :: n == Power(4, m))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0014", "language": "dafny", "source": "verina", "source_id": "verina_advanced_15_task", "vc-description": "/*\nGiven an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exist, return false.\n\n-----Input-----\nThe input consists of a single list:\nnums: A list of integers.\n\n-----Output-----\nThe output is a boolean:\nReturns true if there exists a triplet (i, j, k) where i < j < k and nums[i] < nums[j] < nums[k]; otherwise, returns false.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IncreasingTriplet(nums: array<int>) returns (result: bool)\n    ensures\n        result ==> exists i: int, j: int, k: int :: \n            0 <= i < j && j < k < nums.Length && \n            nums[i] < nums[j] && nums[j] < nums[k]\n    ensures\n        !result ==> forall i: int, j: int, k: int :: \n            0 <= i < j && j < k < nums.Length ==> \n            !(nums[i] < nums[j] && nums[j] < nums[k])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0015", "language": "dafny", "source": "verina", "source_id": "verina_advanced_16_task", "vc-description": "/*\nImplement the insertion sort algorithm in Dafny. The method takes a single array of integers\nas input and returns a new array that contains the same integers in ascending order.\n\nImplementation must follow a standard insertion sort approach, placing each element into its correct position.\nThe resulting array must be sorted in ascending order.\nThe returned array must be a permutation of the input array (i.e., contain exactly the same elements).\n\nInput: A single array of integers, denoted as xs.\nOutput: An array of integers, sorted in ascending order.\n\nExample:\nInput:  [3, 1, 4, 2]\nOutput: [1, 2, 3, 4]\n*/", "vc-preamble": "/* Helper predicate to check if an array is sorted */\npredicate Sorted(v: array<int>)\n    reads v\n{\n    forall i, j :: 0 <= i < j < v.Length ==> v[i] <= v[j]\n}\n\n/* Helper predicate to check if two arrays are multiset equivalent */\npredicate MultisetEquivalent(v1: array<int>, v2: array<int>)\n    reads v1, v2\n{\n    /* This would typically involve checking that both arrays contain\n       the same elements with the same multiplicities */\n    true /* Placeholder - actual implementation would be more complex */\n}", "vc-helpers": "", "vc-spec": "method InsertionSort(xs: array<int>) returns (result: array<int>)\n    ensures Sorted(result)\n    ensures MultisetEquivalent(xs, result)", "vc-code": "{\n    // TODO: implement\n    result := new int[0];\n}", "vc-postamble": ""}
{"id": "DV0016", "language": "dafny", "source": "verina", "source_id": "verina_advanced_17_task", "vc-description": "/*\nThis task requires implementing the insertion sort algorithm to sort a list of integers in ascending order. The function should take a list of integers as input and return a new list containing the same elements sorted in non-decreasing order.\n\n-----Input-----\nThe input is:\n\nl: A list of integers to be sorted.\n\n-----Output-----\nThe output is:\n\nA list of integers that is sorted in non-decreasing order and is a permutation of the input list.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method insertion_sort(l: array<int>) returns (result: array<int>)\n    ensures\n        /* The result is sorted in non-decreasing order */\n        forall i, j :: 0 <= i < j < result.Length ==> result[i] <= result[j]\n    ensures\n        /* The result is a permutation of the input */\n        result.Length == l.Length && multiset(result[..]) == multiset(l[..])", "vc-code": "{\n    // TODO: implement\n    result := new int[l.Length];\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0017", "language": "dafny", "source": "verina", "source_id": "verina_advanced_18_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given number `n` is an Armstrong number (also known as a Narcissistic number). An Armstrong number is a number that is equal to the sum of its own digits raised to the power of the number of digits.\n\nInput: The input consists of one natural number:\n- `n: nat`: The number to check if it satisfies the Armstrong property.\n\nOutput: The output is a boolean value:\n- `bool`: Return `true` if `n` is an Armstrong number, otherwise return `false`.\n*/", "vc-preamble": "function CountDigits(n: nat): nat\n    decreases n\n{\n    if n == 0 then 1 else if n < 10 then 1 else 1 + CountDigits(n / 10)\n}\n\nfunction PowNat(base: nat, exp: nat): nat\n    decreases exp\n{\n    if exp == 0 then \n        1 \n    else \n        base * PowNat(base, exp - 1)\n}\n\nfunction SumPowers(n: nat, k: nat): nat\n    decreases n\n{\n    if n == 0 then 0 else PowNat(n % 10, k) + SumPowers(n / 10, k)\n}", "vc-helpers": "", "vc-spec": "method IsArmstrong(n: nat) returns (result: bool)\n    ensures \n        result == (n == SumPowers(n, CountDigits(n)))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0018", "language": "dafny", "source": "verina", "source_id": "verina_advanced_19_task", "vc-description": "/*\nThis task requires writing a Dafny method that checks whether a given string is a palindrome. A palindrome is a string that reads the same forwards and backwards. The function should ignore whitespace, punctuation, and capitalization when checking for palindromes.\n\n-----Input-----\nThe input consists of:\ns: A string to be checked.\n\n-----Output-----\nThe output is a boolean:\nReturns true if the input string is a palindrome when non-alphabetic characters are removed and letters are treated case-insensitively, and false otherwise.\n*/", "vc-preamble": "// Check if a character is an uppercase alphabet letter\npredicate IsUpperAlpha(c: char)\n{\n    'A' <= c <= 'Z'\n}\n\n// Check if a character is a lowercase alphabet letter  \npredicate IsLowerAlpha(c: char)\n{\n    'a' <= c <= 'z'\n}\n\n// Determine if a character is alphabetic\npredicate IsAlpha(c: char)\n{\n    IsUpperAlpha(c) || IsLowerAlpha(c)\n}\n\n// Convert a single character to lowercase (simplified for Dafny)\nfunction ToLower(c: char): char\n{\n    if IsUpperAlpha(c) then\n        // Simplified: assume conversion works for spec purposes\n        c // This would be the lowercase version in practice\n    else\n        c\n}\n\n// Normalize a character: keep only lowercase letters\nfunction NormalizeChar(c: char): seq<char>\n{\n    if IsAlpha(c) then\n        [ToLower(c)]\n    else\n        []\n}\n\n// Normalize a string into a sequence of lowercase alphabetic characters\nfunction NormalizeString(s: string): seq<char>\n{\n    if |s| == 0 then\n        []\n    else\n        NormalizeChar(s[0]) + NormalizeString(s[1..])\n}", "vc-helpers": "", "vc-spec": "method IsCleanPalindrome(s: string) returns (result: bool)\n    ensures result == (NormalizeString(s) == NormalizeString(s)[..|NormalizeString(s)|])", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0029", "language": "dafny", "source": "verina", "source_id": "verina_advanced_30_task", "vc-description": "/*\nThis task requires writing a Dafny method that computes the length of the longest strictly increasing contiguous subarray in a list of integers. A subarray is a sequence of consecutive elements, and it is strictly increasing if each element is greater than the previous one.\n\nThe method should correctly handle empty lists, lists with all equal elements, and long stretches of increasing numbers.\n\nInput:\nThe input consists of a single list:\nnums: A list of integers.\n\nOutput:\nThe output is a natural number:\nReturns the length of the longest strictly increasing contiguous subarray. If the list is empty, the method should return 0.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LongestIncreasingStreak(nums: array<int>) returns (result: nat)\n    ensures\n        (nums.Length == 0 ==> result == 0) &&\n        result <= nums.Length", "vc-code": "{\n    // TODO: implement\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0030", "language": "dafny", "source": "verina", "source_id": "verina_advanced_31_task", "vc-description": "/*\nThis task requires writing a Lean 4 function that finds the length of the longest strictly increasing subsequence in a list of integers. A subsequence is any sequence that can be derived from the list by deleting zero or more elements without changing the order of the remaining elements. The function must return the length of the longest possible such sequence.\n\n-----Input-----\nThe input consists of a single value:\nxs: A list of integers of type `List Int`.\n\n-----Output-----\nThe output is a natural number:\nReturns the length of the longest strictly increasing subsequence found in the list.\n*/", "vc-preamble": "/* Helper functions for generating subsequences and checking increasing property */\nghost predicate IsSubsequenceOf(subseq: seq<int>, s: seq<int>)\n{\n    exists indices: seq<int> ::\n        |indices| == |subseq| &&\n        |indices| >= 0 &&\n        (forall i :: 0 <= i < |indices| ==> indices[i] >= 0 && indices[i] < |s|) &&\n        (forall i :: 0 <= i < |indices| - 1 ==> indices[i] < indices[i + 1]) &&\n        (forall i :: 0 <= i < |subseq| ==> subseq[i] == s[indices[i]])\n}\n\nghost predicate IsStrictlyIncreasing(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| - 1 ==> s[i] < s[i + 1]\n}", "vc-helpers": "", "vc-spec": "method LongestIncreasingSubseqLength(xs: array<int>) returns (result: nat)\n    ensures\n        /* The result is the length of some strictly increasing subsequence */\n        exists subseq: seq<int> ::\n            IsSubsequenceOf(subseq, xs[..]) && \n            IsStrictlyIncreasing(subseq) && \n            |subseq| == result\n    ensures\n        /* No strictly increasing subsequence is longer than result */\n        forall subseq: seq<int> ::\n            (IsSubsequenceOf(subseq, xs[..]) && IsStrictlyIncreasing(subseq)) \n            ==> |subseq| <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0031", "language": "dafny", "source": "verina", "source_id": "verina_advanced_32_task", "vc-description": "/*\nThis test implements a function in Dafny that finds the length of the longest increasing subsequence in a list of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is one in which the elements are in strictly increasing order.\n\nInput: numbers: A list of integers.\n\nOutput: A natural number representing the length of the longest increasing subsequence in the input list. If the list is empty, the function returns 0.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LongestIncreasingSubsequence(numbers: array<int>) returns (result: nat)\n    ensures result <= numbers.Length", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0032", "language": "dafny", "source": "verina", "source_id": "verina_advanced_33_task", "vc-description": "/*\nThis task requires implementing the \"Longest Increasing Subsequence\" problem in Dafny.\nGiven a list of integers, the function should compute the length of the longest strictly increasing\nsubsequence. A subsequence is formed by deleting zero or more elements without changing the order.\nIf the list is empty, the function should return 0.\n\n-----Input-----\n- nums: A list of integers.\n\n-----Output-----\n- A natural number representing the length of the longest strictly increasing subsequence.\n- If there is no increasing subsequence, return 0.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LongestIncreasingSubsequence(nums: array<int>) returns (result: int)\n    ensures result >= 0\n    ensures nums.Length == 0 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0033", "language": "dafny", "source": "verina", "source_id": "verina_advanced_34_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the length of the longest strictly increasing subsequence from a given list of integers.\n\n-----Input-----\nThe input consists of a list of integers called nums\n\n-----Output-----\nThe output is an integer:\nReturns a number representing the length of the longest strictly increasing subsequence found in the input list.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LongestIncreasingSubsequence(nums: array<int>) returns (result: int)\n    ensures result >= 0\n    ensures result <= nums.Length", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0034", "language": "dafny", "source": "verina", "source_id": "verina_advanced_35_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the majority element in a sequence of integers. The majority element is the element that appears more than ⌊n/2⌋ times, where n is the sequence's length. You may assume that a majority element always exists in the input.\n\n-----Input-----\n- nums: A sequence of integers of length ≥ 1, containing a majority element.\n\n-----Output-----\n- An integer: the element that appears more than ⌊n/2⌋ times.\n*/", "vc-preamble": "function CountOccurrences(nums: seq<int>, x: int): nat\n    decreases |nums|\n{\n    if |nums| == 0 then\n        0\n    else\n        var first := nums[0];\n        var restCount := CountOccurrences(nums[1..], x);\n        if first == x then\n            restCount + 1\n        else\n            restCount\n}", "vc-helpers": "", "vc-spec": "method MajorityElement(nums: seq<int>) returns (result: int)\n    requires \n        |nums| > 0 &&\n        exists x :: CountOccurrences(nums, x) > |nums| / 2\n    ensures \n        CountOccurrences(nums, result) > |nums| / 2 &&\n        forall x :: x != result ==> CountOccurrences(nums, x) <= |nums| / 2", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0035", "language": "dafny", "source": "verina", "source_id": "verina_advanced_36_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the majority element in a list of natural numbers. The majority element is defined as the element that appears more than ⌊n / 2⌋ times in the list, where n is the total number of elements.\n\nYou may assume that the input list always contains a majority element.\n\nInput: The input consists of one list:\nxs: A list of natural numbers (array<nat>), where a majority element is guaranteed to exist.\n\nOutput: The output is a natural number:\nReturns the element that appears more than half the time in the input list.\n*/", "vc-preamble": "function CountMatches(xs: seq<nat>, x: nat): nat\n    decreases |xs|\n{\n    if |xs| == 0 then\n        0\n    else\n        var firstMatch: nat := if xs[0] == x then 1 else 0;\n        firstMatch + CountMatches(xs[1..], x)\n}", "vc-helpers": "", "vc-spec": "method MajorityElement(xs: array<nat>) returns (result: nat)\n    requires \n        xs.Length > 0\n    requires\n        exists x: nat :: CountMatches(xs[..], x) > xs.Length / 2\n    ensures\n        CountMatches(xs[..], result) > xs.Length / 2", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0036", "language": "dafny", "source": "verina", "source_id": "verina_advanced_37_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the majority element from a list of integers.\n\nThe majority element is the one that appears more than ⌊n / 2⌋ times in the list, where n is the list's length. You may assume that a majority element always exists in the input.\n\nInput: nums: A list of integers (with at least one majority element).\n\nOutput: Returns the majority element — the value that appears more than ⌊n / 2⌋ times.\n*/", "vc-preamble": "function CountOccurrences(nums: seq<int>, value: int): nat\n{\n    |set i | 0 <= i < |nums| && nums[i] == value|\n}", "vc-helpers": "", "vc-spec": "method MajorityElement(nums: array<int>) returns (result: int)\n    requires nums.Length > 0\n    ensures var numsSeq := nums[..];\n            var n := |numsSeq|;\n            CountOccurrences(numsSeq, result) > n / 2 &&\n            forall x: int :: x == result || CountOccurrences(numsSeq, x) <= n / 2", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0037", "language": "dafny", "source": "verina", "source_id": "verina_advanced_38_task", "vc-description": "/*\nThis task requires implementing a Dafny method that, given a list of intervals, returns the maximum amount that can be spanned after we removed one of the intervals\nYou may assume you'll receive at least one interval\n\nInput: The input consists of a list of ordered pairs of intervals.\nOutput: The output is an integer: Return the largest span that is possible after removing one of the intervals.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxCoverageAfterRemovingOne(intervals: array<(int, int)>) returns (result: int)\n    requires intervals.Length > 0\n    ensures result <= intervals.Length * 1000", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0038", "language": "dafny", "source": "verina", "source_id": "verina_advanced_39_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the maximum element from a non-empty array of natural numbers.\n\nInput: The input consists of lst: a non-empty array of natural numbers.\n\nOutput: The output is a natural number representing the largest element in the array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxOfList(lst: array<nat>) returns (result: nat)\n    requires lst.Length > 0\n    ensures exists i :: 0 <= i < lst.Length && lst[i] == result\n    ensures forall i :: 0 <= i < lst.Length ==> lst[i] <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0039", "language": "dafny", "source": "verina", "source_id": "verina_advanced_40_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the maximum element from a non-empty array of integers.\n\n-----Input-----\nThe input consists of:\nlst: a non-empty array of integers.\n\n-----Output-----\nThe output is:\nAn integer representing the largest element in the array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxOfList(lst: array<int>) returns (result: int)\n    requires lst.Length > 0\n    ensures exists i :: 0 <= i < lst.Length && lst[i] == result\n    ensures forall i :: 0 <= i < lst.Length ==> lst[i] <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0040", "language": "dafny", "source": "verina", "source_id": "verina_advanced_41_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the maximum among three given integers. The method should return the largest value, ensuring that the result is greater than or equal to each of the input numbers and that it is one of the provided integers.\n\n-----Input-----\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\n-----Output-----\nThe output is an integer:\nReturns the maximum of the three input numbers, assuring that the returned value is greater than or equal to a, b, and c, and that it matches one of these values.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxOfThree(a: int, b: int, c: int) returns (result: int)\n    ensures result >= a && result >= b && result >= c\n    ensures result == a || result == b || result == c", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0041", "language": "dafny", "source": "verina", "source_id": "verina_advanced_42_task", "vc-description": "/*\nThis task requires writing a Dafny method that takes a sequence of stock prices and returns the maximum profit achievable by buying on one day and selling on a later day.\n\nIf no profit is possible, the method should return 0.\n\n-----Input-----\nThe input consists of:\nprices: A sequence of natural numbers representing stock prices on each day.\n\n-----Output-----\nThe output is a natural number:\nReturns the maximum profit achievable with one transaction (buy once, sell once), or 0 if no profitable transaction is possible.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxProfit(prices: seq<nat>) returns (result: nat)\n    ensures\n        (result == 0 && |prices| == 0) ||\n        (exists i: int, j: int :: 0 <= i < j < |prices| && prices[j] >= prices[i] && prices[j] - prices[i] == result) ||\n        (forall i: int, j: int :: 0 <= i < j < |prices| ==> prices[j] < prices[i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0042", "language": "dafny", "source": "verina", "source_id": "verina_advanced_43_task", "vc-description": "/*\nThis task requires writing a Dafny method that given a 0-indexed integer array `nums` representing the scores of students in an exam. A teacher wants to select a non empty group of students such that the strength of group is maximized.\n\nThe strength of a group is defined as the product of the selected student scores.\n\nYou can choose any non-empty subset of students. The goal is to compute the maximum product of any such subset.\n\n\n----Input---\nnums: An non-empty list of integers.\n\n-----Output-----\n\nAn integer representing the maximum strength.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxStrength(nums: array<int>) returns (result: int)\n    requires nums.Length > 0\n    ensures\n        /* The result represents the maximum product of any non-empty subset of nums.\n           For simplicity, we ensure that the result is at least as large as one of the elements. */\n        exists i :: 0 <= i < nums.Length && result >= nums[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0043", "language": "dafny", "source": "verina", "source_id": "verina_advanced_44_task", "vc-description": "/*\nGiven an integer array arr and a positive integer k, this task requires writing a Dafny method that finds the\nmaximum sum of a subarray of arr, such that the length of the subarray is divisible by k.\nIf the array is empty, or generally if there exists no subarray with length divisible by k,\nthe default return value should be 0.\n\nInput:\nThe input consists of:\narr: The array of integers.\nk: An integer larger than 1.\n\nOutput:\nThe output is an integer:\nReturns the maximum positive integer x such that there exists a subarray where the sum equals x, and the length\nof the subarray is divisible by k.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MaxSubarraySumDivisibleByK(arr: array<int>, k: int) returns (result: int)\n    requires k > 0\n    ensures true // TODO: Add postcondition based on subarrays with length divisible by k", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0044", "language": "dafny", "source": "verina", "source_id": "verina_advanced_45_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the maximum subarray sum from a given array of integers.\nA subarray is a contiguous sequence of elements within the array.\nThe method should return the maximum sum that can be obtained from any subarray.\n\nInput:\nThe input is an array of integers:\nxs: An array of integers (can include negative numbers).\n\nOutput:\nThe output is an integer:\nReturns the maximum sum among all contiguous subarrays of xs.\nIf the array is empty, the result should be 0.\n*/", "vc-preamble": "function SpecSum(xs: array<int>, start: int, len: int): int\n    decreases len\n    reads xs\n{\n    if len <= 0 then\n        0\n    else if start < 0 || start >= xs.Length then\n        0\n    else\n        xs[start] + SpecSum(xs, start + 1, len - 1)\n}", "vc-helpers": "", "vc-spec": "method MaxSubarraySum(xs: array<int>) returns (result: int)\n    ensures xs.Length == 0 ==> result == 0\n    ensures xs.Length > 0 ==> \n        (exists start: int, len: int :: \n            0 <= start < xs.Length && \n            1 <= len <= xs.Length - start &&\n            result == SpecSum(xs, start, len)) &&\n        (forall start: int, len: int ::\n            0 <= start < xs.Length && \n            1 <= len <= xs.Length - start\n            ==> SpecSum(xs, start, len) <= result)", "vc-code": "{\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0045", "language": "dafny", "source": "verina", "source_id": "verina_advanced_46_task", "vc-description": "/*\nThis test implements a function in Dafny that finds the maximum sum of any contiguous subarray within an array of integers. A subarray is a continuous section of the original array. If all integers in the array are negative, the function should return 0 (representing the empty subarray).\n\nInput: numbers - An array of integers that may contain positive, negative, or zero values.\n\nOutput: An integer representing the maximum sum of any contiguous subarray. If the array is empty or contains only negative numbers, the function returns 0.\n*/", "vc-preamble": "function SubarraySum(numbers: array<int>, start: int, end: int): int\n    requires 0 <= start <= end <= numbers.Length\n    reads numbers\n    decreases end - start\n{\n    if start == end then 0\n    else numbers[start] + SubarraySum(numbers, start + 1, end)\n}", "vc-helpers": "", "vc-spec": "method MaxSubarraySum(numbers: array<int>) returns (result: int)\n    ensures result >= 0\n    ensures forall start: int, end: int :: \n        start <= end && 0 <= start && end <= numbers.Length\n        ==> SubarraySum(numbers, start, end) <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0047", "language": "dafny", "source": "verina", "source_id": "verina_advanced_48_task", "vc-description": "/*\nThis task requires implementing the merge sort algorithm in Dafny to sort a list of integers in ascending order. Merge sort is a divide-and-conquer algorithm that recursively splits the input list into two halves, sorts them separately, and then merges the sorted halves to produce the final sorted result.\n\nThe merge sort algorithm works as follows:\n1. If the list has one element or is empty, it is already sorted.\n2. Otherwise, divide the list into two roughly equal parts.\n3. Recursively sort both halves.\n4. Merge the two sorted halves to produce a single sorted list.\n\nThe key operation in merge sort is the merging step, which takes two sorted lists and combines them into a single sorted list by repeatedly taking the smaller of the two elements at the front of the lists.\n\nInput:\nThe input consists of one parameter:\nlist: A list of integers that needs to be sorted.\n\nOutput:\nThe output is a list of integers:\nReturns a new list containing all elements from the input list, sorted in ascending order.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MergeSort(list: seq<int>) returns (result: seq<int>)\n    ensures\n        |result| == |list| &&\n        (forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]) &&\n        multiset(result) == multiset(list)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0048", "language": "dafny", "source": "verina", "source_id": "verina_advanced_49_task", "vc-description": "/*\nImplement a Dafny method that merges two ascendingly sorted arrays of integers into one single sorted array (ascending). The resulting array must contain all elements from both input arrays, preserving their ascending order.\n\nInput:\nThe input consists of two arrays of integers:\narr1: A sorted array of integers (ascending)\narr2: Another sorted array of integers (ascending)\n\nOutput:\nThe output is an array of integers:\nReturns a new array containing all elements from arr1 and arr2, sorted in ascending order.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MergeSortedLists(arr1: array<int>, arr2: array<int>) returns (result: array<int>)\n    requires \n        forall i, j :: 0 <= i < j < arr1.Length ==> arr1[i] <= arr1[j]\n    requires\n        forall i, j :: 0 <= i < j < arr2.Length ==> arr2[i] <= arr2[j]\n    ensures\n        forall i, j :: 0 <= i < j < result.Length ==> result[i] <= result[j]\n    ensures\n        result.Length == arr1.Length + arr2.Length", "vc-code": "{\n    // impl-start\n    result := new int[arr1.Length + arr2.Length];\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0049", "language": "dafny", "source": "verina", "source_id": "verina_advanced_50_task", "vc-description": "/*\nThis task involves merging two sorted arrays of natural numbers (it is ill defined if inputs aren't sorted.)\nThe input consists of two arrays:\na1: A sorted array of natural numbers\na2: A sorted array of natural numbers\nThe output is an array:\nReturns a new array with all elements from both input arrays (included once and only once)\nThe resulting array is sorted itself\n*/", "vc-preamble": "predicate IsSorted(v: seq<nat>)\n{\n    forall i, j :: 0 <= i < j < |v| ==> v[i] <= v[j]\n}", "vc-helpers": "", "vc-spec": "method MergeSorted(a1: array<nat>, a2: array<nat>) returns (result: array<nat>)\n    requires IsSorted(a1[..])\n    requires IsSorted(a2[..])\n    ensures IsSorted(result[..])\n    ensures multiset(result[..]) == multiset(a1[..]) + multiset(a2[..])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new nat[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0050", "language": "dafny", "source": "verina", "source_id": "verina_advanced_51_task", "vc-description": "/*\nThis task requires writing a Dafny method that takes two sorted (non-decreasing) integer lists and merges them into a single sorted list. The output must preserve order and include all elements from both input lists.\n\nInput:\nThe input consists of:\na: A list of integers sorted in non-decreasing order.\nb: Another list of integers sorted in non-decreasing order.\n\nOutput:\nThe output is a list of integers:\nReturns a merged list that contains all elements from both input lists, sorted in non-decreasing order.\n*/", "vc-preamble": "predicate IsSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\npredicate MultisetEquiv(s1: seq<int>, s2: seq<int>)\n{\n    multiset(s1) == multiset(s2)\n}\nmethod MergeSortedAux(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n{\n    assume {:axiom} false;\n    result := [];\n}", "vc-helpers": "", "vc-spec": "method MergeSorted(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires IsSorted(a)\n    requires IsSorted(b)\n    ensures IsSorted(result)\n    ensures MultisetEquiv(result, a + b)", "vc-code": "{\n    assume {:axiom} false;\n    result := [];\n}", "vc-postamble": ""}
{"id": "DV0052", "language": "dafny", "source": "verina", "source_id": "verina_advanced_53_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates the minimum number of right shifts required to sort a given array of distinct positive integers.\n\nA right shift operation on an array nums of length n moves the element at index i to index (i + 1) % n for all indices i. Effectively, the last element moves to the first position, and all other elements shift one position to the right.\n\nThe method should return the minimum number of right shifts needed to make the array sorted in ascending order. If the array is already sorted, the method should return 0. If it's impossible to sort the array using only right shifts, the method should return -1.\n\nInput:\nThe input consists of a single array of integers:\nnums: An array (array<int>) containing distinct positive integers.\n\nOutput:\nThe output is a single integer (int):\n- If the array can be sorted using right shifts, return the minimum number of shifts required (an integer >= 0).\n- If the array cannot be sorted using right shifts, return -1.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MinimumRightShifts(nums: array<int>) returns (result: int)\n    requires nums.Length <= 2147483647\n    requires forall i, j :: 0 <= i < nums.Length && 0 <= j < nums.Length && i != j ==> nums[i] != nums[j]\n    ensures\n        var n := nums.Length;\n        if n <= 1 then\n            result == 0\n        else\n            (result >= 0 && result < n) || result == -1", "vc-code": "{\n    // TODO: implement\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0054", "language": "dafny", "source": "verina", "source_id": "verina_advanced_55_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the integer that appears most frequently in the input list. If multiple integers have the same maximum frequency, return the one that appears first in the original list. You should implement a frequency counter using a fold over the list, extract the maximum frequency, and return the first element in the list that matches it.\n\nInput: The input consists of xs: A list of integers (possibly with duplicates). The list is guaranteed to be non-empty.\n\nOutput: The output is an integer that appears the most frequently in the list. If there is a tie, the element that occurs first in the original list should be returned.\n*/", "vc-preamble": "/* Helper function to count occurrences of a target value in a sequence */\nfunction CountOccurrences(xs: seq<int>, target: int): nat\n{\n    |set i | 0 <= i < |xs| && xs[i] == target|\n}", "vc-helpers": "", "vc-spec": "method MostFrequent(xs: array<int>) returns (result: int)\n    requires xs.Length > 0\n    ensures result in xs[..]\n    ensures forall x :: x in xs[..] ==> CountOccurrences(xs[..], x) <= CountOccurrences(xs[..], result)\n    ensures exists first_idx :: \n        0 <= first_idx < xs.Length && \n        xs[first_idx] == result && \n        CountOccurrences(xs[..], result) == CountOccurrences(xs[..], xs[first_idx]) &&\n        forall i :: 0 <= i < first_idx ==> CountOccurrences(xs[..], xs[i]) < CountOccurrences(xs[..], result)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0055", "language": "dafny", "source": "verina", "source_id": "verina_advanced_56_task", "vc-description": "/*\nThis task requires writing a Dafny method that moves all zeroes in a given integer array to the end, while preserving the relative order of the non-zero elements.\n\nThe method `MoveZeroes` processes the input array by separating the non-zero and zero elements. It then returns a new array formed by appending all non-zero elements followed by all the zero elements.\n\n-----Input-----\nThe input is a single array of integers:\nxs: An array of integers (type: array<int>), possibly containing zero and non-zero values.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array (type: array<int>) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.\n*/", "vc-preamble": "/* Count how many times a specific value appears in the sequence */\nfunction CountVal(val: int, xs: seq<int>): nat \n    decreases |xs|\n{\n    if |xs| == 0 then\n        0\n    else\n        var rest := CountVal(val, xs[1..]);\n        if xs[0] == val then rest + 1 else rest\n}\n\n/* Check whether one sequence is a subsequence of another (preserving relative order) */\npredicate IsSubsequence(xs: seq<int>, ys: seq<int>) \n    decreases |xs| + |ys|\n{\n    if |xs| == 0 then\n        true\n    else if |ys| == 0 then\n        false\n    else\n        if xs[0] == ys[0] then\n            IsSubsequence(xs[1..], ys[1..])\n        else\n            IsSubsequence(xs, ys[1..])\n}\n\nfunction FilterNonZero(xs: seq<int>): seq<int>\n{\n    if |xs| == 0 then []\n    else if xs[0] != 0 then [xs[0]] + FilterNonZero(xs[1..])\n    else FilterNonZero(xs[1..])\n}", "vc-helpers": "", "vc-spec": "method MoveZeroes(xs: array<int>) returns (result: array<int>)\n    ensures\n        /* All non-zero elements must maintain their relative order */\n        IsSubsequence(FilterNonZero(xs[0..xs.Length]), result[0..result.Length])\n        /* All zeroes must be located at the end of the output array */\n        && (forall i :: 0 <= i < result.Length && result[i] != 0 ==> \n            forall j :: i < j < result.Length ==> result[j] != 0)\n        /* The output must contain the same number of elements */\n        && xs.Length == result.Length\n        /* The number of zeroes must remain unchanged */\n        && CountVal(0, xs[0..xs.Length]) == CountVal(0, result[0..result.Length])", "vc-code": "{\n    assume {:axiom} false;\n    result := new int[xs.Length];\n}", "vc-postamble": ""}
{"id": "DV0056", "language": "dafny", "source": "verina", "source_id": "verina_advanced_57_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the next greater element for a given array of numbers. The next greater element for an element x is defined as the first element greater than x that appears to the right of x in the array.\n\nGiven two distinct 0-indexed integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`, the method should determine the next greater element for each value in `nums1` as it appears in `nums2`.\nAll integers in both arrays are unique, and the length constraints are.\n\nInput:\nThe input consists of two arrays of integers:\nnums1: An array of integers, which is a subset of nums2.\nnums2: An array of integers containing all elements from nums1 and possibly additional elements.\n\nOutput:\nThe output is an array of integers:\n- An array of the same length as nums1.\n- For each element nums1[i], the corresponding output element is:\n  - The next greater element of nums1[i] in nums2 if one exists\n  - -1 if there is no next greater element\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method NextGreaterElement(nums1: array<int>, nums2: array<int>) returns (result: array<int>)\n    requires\n        forall i, j :: 0 <= i < nums1.Length && 0 <= j < nums1.Length && i != j ==> nums1[i] != nums1[j]\n    requires\n        forall i, j :: 0 <= i < nums2.Length && 0 <= j < nums2.Length && i != j ==> nums2[i] != nums2[j]\n    ensures\n        result.Length == nums1.Length", "vc-code": "{\n    // impl-start\n    // TODO: implement\n    result := new int[nums1.Length];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0057", "language": "dafny", "source": "verina", "source_id": "verina_advanced_58_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the nth \"ugly number\". Ugly numbers are positive integers whose only prime factors are 2, 3, or 5.\n\nThe method should generate ugly numbers in ascending order and return the nth one. The first ugly number is 1.\n\nInput:\nThe input is a natural number:\n\nn: The index (1-based) of the ugly number to return.\n\nOutput:\nThe output is a natural number:\nThe nth smallest ugly number.\n*/", "vc-preamble": "predicate NthUglyNumberPrecond(n: nat)\n{\n    n > 0\n}", "vc-helpers": "", "vc-spec": "method NthUglyNumber(n: int) returns (result: int)\n    requires n > 0\n    ensures result > 0", "vc-code": "{\n    // TODO: implement\n    result := 1;\n}", "vc-postamble": ""}
{"id": "DV0058", "language": "dafny", "source": "verina", "source_id": "verina_advanced_59_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines if a given string is a palindrome, ignoring all\nnon-alphanumeric characters and case differences. For example, the string \"A man, a plan, a canal: Panama\" should return\ntrue.\n\n-----Input-----\nA single string:\ns: The string to check for palindrome property.\n\n-----Output-----\nA boolean (Bool):\ntrue if s is a palindrome when ignoring non-alphanumeric characters and case. false otherwise.\n*/", "vc-preamble": "predicate IsAlphanumeric(c: char)\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z') || ('0' <= c <= '9')\n}\n\nfunction ToLowercase(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        ((c as int) + 32) as char\n    else\n        c\n}\n\nfunction FilterAlphanumeric(s: seq<char>): seq<char>\n{\n    if |s| == 0 then []\n    else if IsAlphanumeric(s[0]) then [ToLowercase(s[0])] + FilterAlphanumeric(s[1..])\n    else FilterAlphanumeric(s[1..])\n}", "vc-helpers": "", "vc-spec": "method PalindromeIgnoreNonAlnum(s: string) returns (result: bool)\n    ensures \n        result <==> (\n            var cleaned := FilterAlphanumeric(s[..]);\n            var backward := seq(|cleaned|, i requires 0 <= i < |cleaned| => cleaned[|cleaned| - 1 - i]);\n            cleaned == backward\n        )", "vc-code": "{\n    assume {:axiom} false;\n    return false;\n}", "vc-postamble": ""}
{"id": "DV0059", "language": "dafny", "source": "verina", "source_id": "verina_advanced_60_task", "vc-description": "/*\nThis task requires writing a Dafny method that takes a list of natural numbers and partitions it into two separate lists: one containing all the even numbers and the other containing all the odd numbers. The order of elements in each sublist should match their appearance in the original list. Assume there are no duplicates in the input.\n\nInput:\nThe input consists of a single list with no duplicate natural numbers:\n- nums: A list of natural numbers (nat)\n\nOutput:\nThe output is a tuple of two lists:\n- The first list contains all even numbers from the input list, in order.\n- The second list contains all odd numbers from the input list, in order.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method PartitionEvensOdds(nums: array<nat>) returns (evens: array<nat>, odds: array<nat>)\n    requires true\n    ensures forall i :: 0 <= i < evens.Length ==> evens[i] % 2 == 0\n    ensures forall i :: 0 <= i < odds.Length ==> odds[i] % 2 == 1", "vc-code": "{\n    // TODO: implement\n    evens := new nat[0];\n    odds := new nat[0];\n}", "vc-postamble": ""}
{"id": "DV0060", "language": "dafny", "source": "verina", "source_id": "verina_advanced_61_task", "vc-description": "/*\nThis task requires writing a Dafny method that takes an array of integers and returns a new array. For each index i in the input array, the output at i is equal to the product of all numbers in the array except the number at index i. The solution must run in O(n) time without using the division operation.\n\nThe input is an array of integers. For example, [1,2,3,4].\n\nThe output is an array of integers where each element at index i is the product of every input element except the one at that index. For example, for the input [1,2,3,4], the output should be [24,12,8,6]. Each intermediate product is guaranteed to fit in a 32-bit integer.\n*/", "vc-preamble": "/* Helper: Product of a sequence of integers */\nfunction ListProduct(nums: seq<int>): int\n    decreases |nums|\n{\n    if |nums| == 0 then 1 else nums[0] * ListProduct(nums[1..])\n}", "vc-helpers": "", "vc-spec": "method ProductExceptSelf(nums: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == nums.Length\n    ensures\n        forall i :: 0 <= i < nums.Length ==> \n            result[i] == ListProduct(nums[..i]) * ListProduct(nums[i+1..])", "vc-code": "{\n    result := new int[nums.Length];\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0061", "language": "dafny", "source": "verina", "source_id": "verina_advanced_62_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates how much rainwater would be trapped by a terrain represented as an array of heights. Imagine rainwater falls onto a terrain with varying elevation levels. The water can only be trapped between higher elevation points.\n\nGiven an array of non-negative integers representing the elevation map where the width of each bar is 1 unit, calculate how much water can be trapped after it rains.\n\nInput:\nThe input consists of one array:\nheights: An array of non-negative integers representing elevation levels.\n\nOutput:\nThe output is an integer:\nReturns the total amount of rainwater that can be trapped.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Rain(heights: array<int>) returns (result: int)\n    requires forall i :: 0 <= i < heights.Length ==> heights[i] >= 0\n    ensures result >= 0\n    ensures heights.Length < 3 ==> result == 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0062", "language": "dafny", "source": "verina", "source_id": "verina_advanced_63_task", "vc-description": "/*\nThis task requires writing a Dafny method that counts the unique elements from a sorted array.\n\n-----Input-----\nThe input is a single list of integers:\nnums: An array of integers sorted in non-decreasing order.\n\n-----Output-----\nThe output is a single integer:\nReturns the number of unique elements (k).\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method RemoveDuplicates(nums: seq<int>) returns (result: nat)\n    requires forall i, j :: 0 <= i < j < |nums| ==> nums[i] <= nums[j]\n    ensures result <= |nums|", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}\n\nlemma RemoveDuplicatesSpecSatisfied(nums: seq<int>)\n    requires forall i, j :: 0 <= i < j < |nums| ==> nums[i] <= nums[j]\n{\n    // TODO: Implement proof\n}", "vc-postamble": ""}
{"id": "DV0063", "language": "dafny", "source": "verina", "source_id": "verina_advanced_64_task", "vc-description": "/*\nThis task requires writing a Dafny method that removes all occurrences of a given element from a list of natural numbers. The method should return a new list that contains all the elements of the original list except those equal to the target number. The order of the remaining elements must be preserved.\n\n-----Input-----\nThe input consists of two elements:\nlst: A list of natural numbers (seq<nat>).\ntarget: A natural number to be removed from the list.\n\n-----Output-----\nThe output is a list of natural numbers:\nReturns a new list with all occurrences of the target number removed. The relative order of the remaining elements must be the same as in the input list.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method RemoveElement(lst: seq<nat>, target: nat) returns (result: seq<nat>)\n    ensures\n        forall i :: 0 <= i < |result| ==> result[i] != target\n    ensures\n        forall i :: 0 <= i < |result| ==> \n            exists j :: 0 <= j < |lst| && lst[j] == result[i] && lst[j] != target\n    ensures\n        forall i, j :: 0 <= i < j < |lst| && lst[i] != target && lst[j] != target ==> \n            (exists k1, k2 :: 0 <= k1 < k2 < |result| && \n            result[k1] == lst[i] && result[k2] == lst[j])", "vc-code": "{\n    assume {:axiom} false;\n    result := [];\n}", "vc-postamble": ""}
{"id": "DV0064", "language": "dafny", "source": "verina", "source_id": "verina_advanced_65_task", "vc-description": "/*\nThis task requires writing a Dafny method that reverses a given string. The method should return a new string which consists of the characters of the input string in reverse order.\n\n-----Input-----\nThe input consists of:\ns: A string (which may be empty).\n\n-----Output-----\nThe output is a string:\nReturns a string where the characters are in reverse order from the original input.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ReverseString(s: array<char>) returns (result: array<char>)\n    ensures\n        result.Length == s.Length &&\n        forall i :: 0 <= i < s.Length ==> result[i] == s[s.Length - 1 - i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new char[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0065", "language": "dafny", "source": "verina", "source_id": "verina_advanced_66_task", "vc-description": "/*\nGiven an input string \"words_str\", this task requires writing a Dafny method that reverses the order of its words. A word is defined as a contiguous sequence of non-space characters. The method must remove any extra spaces so that the output string contains words separated by a single space and has no leading or trailing spaces. The characters within each word must stay the same as the original input.\n\n-----Input-----\nwords_str: A string that may contain leading, trailing, or multiple spaces between words.\n\n-----Output-----\nA string with the words from the input reversed, where words are separated by a single space, with no extra spaces at the beginning or end.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ReverseWords(words_str: string) returns (result: string)", "vc-code": "{\n    // impl-start  \n    // TODO: implement\n    result := \"\";\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0066", "language": "dafny", "source": "verina", "source_id": "verina_advanced_67_task", "vc-description": "/*\nThis task requires writing a Dafny method that performs run-length encoding on a given string. The method should scan the string from left to right and group consecutive identical characters into pairs. Each pair consists of the character itself and the number of times it appears consecutively. For example, \"aaabbc\" becomes [('a', 3), ('b', 2), ('c', 1)].\n\nThe resulting encoded list must satisfy the following properties:\n1. No pair has a zero or negative run-length.\n2. Consecutive pairs in the encoding list must not have the same character.\n3. Decoding the output should return the original string.\n\n-----Input-----\nThe input is a single string, `s`.\n\n-----Output-----\nThe output is a list of pairs `(Char, Nat)`, which represents the run-length-encoded form of the input string.\n*/", "vc-preamble": "function DecodeRle(lst: seq<(char, nat)>): seq<char>\n{\n    []\n}", "vc-helpers": "", "vc-spec": "method RunLengthEncode(s: seq<char>) returns (result: seq<(char, nat)>)\n    ensures\n        forall i :: 0 <= i < |result| ==> result[i].1 > 0\n    ensures\n        forall i :: 0 <= i < |result| ==> i + 1 < |result| ==> result[i].0 != result[i + 1].0\n    ensures\n        DecodeRle(result) == s", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0067", "language": "dafny", "source": "verina", "source_id": "verina_advanced_68_task", "vc-description": "/*\nThis task requires implementing a Run-Length Encoding (RLE) algorithm in Dafny. The method should take a string as input and return a compressed string where consecutive duplicate characters are replaced by the character followed by its count. The output must strictly alternate between characters and digits, reconstruct to the original input when decoded, and return a non-empty string if and only if the input is non-empty.\n\nInput: The input is a string consisting of any characters (including special characters and digits).\n\nOutput: The output is a string where each sequence of identical characters is replaced by the character followed by its count. The output must:\n1. Alternate between characters and digits (e.g., \"a3b2\").\n2. Reconstruct to the original input when decoded.\n3. Be non-empty if and only if the input is non-empty.\n*/", "vc-preamble": "predicate IsDigit(c: char)\n{\n    '0' <= c <= '9'\n}", "vc-helpers": "", "vc-spec": "lemma RunLengthEncoderProperty(input: string, result: string)\n    requires\n        // Non-empty check: input is empty iff result is empty\n        (|input| == 0) <==> (|result| == 0)\n    requires\n        // Format validation: result alternates between characters and digits\n        |result| > 0 ==> (\n            forall i :: 0 <= i < |result| ==> \n                (i % 2 == 0 ==> !IsDigit(result[i])) &&\n                (i % 2 == 1 ==> IsDigit(result[i]))\n        )", "vc-code": "{\n    // TODO: Implement proof\n}", "vc-postamble": ""}
{"id": "DV0068", "language": "dafny", "source": "verina", "source_id": "verina_advanced_69_task", "vc-description": "/*\nGiven a sorted list of distinct integers and a target value, return the index if the target is found. If it is not found, return the index where it would be inserted to maintain the sorted order.\n\nThis function must preserve the sorted property of the list. The list is assumed to be strictly increasing and contain no duplicates.\n\n-----Input-----\nxs : List Int — a sorted list of distinct integers in increasing order\ntarget : Int — the integer to search for\n\n-----Output-----\nA natural number (Nat) representing the index at which the target is found, or the index at which it should be inserted to maintain sorted order.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SearchInsert(xs: array<int>, target: int) returns (result: int)\n    requires forall i, j :: 0 <= i < j < xs.Length ==> xs[i] < xs[j]\n    ensures 0 <= result <= xs.Length\n    ensures forall i :: 0 <= i < result ==> xs[i] < target\n    ensures result < xs.Length ==> target <= xs[result]", "vc-code": "{\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0069", "language": "dafny", "source": "verina", "source_id": "verina_advanced_70_task", "vc-description": "/*\nThis task requires writing a Dafny method that's goal is to determine the minimum number of adjacent swaps needed to make the array semi-ordered. You may repeatedly swap 2 adjacent elements in the array. A permutation is called semi-ordered if the first number equals 1 and the last number equals n.\n\nInput:\n\nThe input consists of:\n- nums: An array of integers.\n\nOutput:\n\nThe output is an integer.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SemiOrderedPermutation(nums: array<int>) returns (result: int)\n    ensures \n        result >= 0", "vc-code": "{\n    // impl-start\n    // TODO: implement\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0072", "language": "dafny", "source": "verina", "source_id": "verina_advanced_73_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the first missing natural number in an increasingly sorted list. The method should return the smallest natural number that is not in the list, ensuring that all natural numbers that are smaller is inside the list.\n\n-----Input-----\nThe input consists of a list of natural numbers sorted in increasing order:\nl: The sorted list\n\n-----Output-----\nThe output is a natural number:\nReturns the smallest natural number that is not in the list, which means all natural numbers that are smaller than the returned value should be inside the input list.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "function SmallestMissing(l: seq<nat>): nat\n\nlemma SmallestMissingSpecSatisfied(l: seq<nat>)\n    requires forall i, j :: 0 <= i < j < |l| ==> l[i] < l[j]\n    ensures SmallestMissing(l) !in l\n    ensures forall candidate: nat :: candidate < SmallestMissing(l) ==> candidate in l", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0073", "language": "dafny", "source": "verina", "source_id": "verina_advanced_74_task", "vc-description": "/*\nThis task requires writing a Dafny function called `solution` that takes an array of natural numbers `nums`. The function should calculate and return the sum of values obtained for each subarray, where the value for a subarray is the square of the count of distinct elements within that subarray.\n\nInput:\nThe input is an array of natural numbers:\n`nums`: An array where each element is a natural number.\nConstraints:\n- The length of the array `nums` (n) is between 1 and 100 (inclusive).\n- Each element in `nums` is between 1 and 100 (inclusive).\n\nOutput:\nThe output is a natural number:\nReturns the total sum of squared distinct counts for all subarrays.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method solution(nums: array<int>) returns (result: int)\n    requires\n        1 <= nums.Length <= 100\n    requires\n        forall i :: 0 <= i < nums.Length ==> nums[i] >= 1 && nums[i] <= 100\n    ensures\n        result >= 0", "vc-code": "{\n    // TODO: implement\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0074", "language": "dafny", "source": "verina", "source_id": "verina_advanced_75_task", "vc-description": "/*\nGiven a sequence of n integers, your task is to find the largest sum obtainable by choosing a contiguous subarray of the sequence. At least one number must be selected.\n\nThe algorithm uses dynamic programming (Kadane's Algorithm) to solve the problem:\n1. Initialize the current maximum (cur) and the overall maximum (maxSoFar) with the first element.\n2. For each subsequent element, update:\n     cur = max(element, cur + element)\n     maxSoFar = max(maxSoFar, cur)\n3. Return maxSoFar as the answer.\n\nInput:\nThe input is provided as a list of integers:\n  sequence: A list of n integers.\n\nOutput:\nThe output is a single integer representing the maximum subarray sum.\n*/", "vc-preamble": "function SpecSubarraySum(sequence: seq<int>, start: int, end: int): int\n    decreases end - start\n{\n    if start >= end || start < 0 || end > |sequence| then\n        0\n    else if start + 1 == end then\n        sequence[start]\n    else\n        sequence[start] + SpecSubarraySum(sequence, start + 1, end)\n}", "vc-helpers": "", "vc-spec": "method TaskCode(sequence: array<int>) returns (result: int)\n    requires sequence.Length > 0\n    ensures \n        exists start: int, end: int :: \n            0 <= start < end <= sequence.Length && \n            result == SpecSubarraySum(sequence[..], start, end) &&\n            forall s: int, e: int :: (0 <= s < e <= sequence.Length) ==> \n                SpecSubarraySum(sequence[..], s, e) <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0075", "language": "dafny", "source": "verina", "source_id": "verina_advanced_76_task", "vc-description": "/*\nThis task requires writing a Dafny method that returns the k most frequent elements from a list of integers. The method should count the frequency of each distinct element in the list and return the k elements with the highest frequency.\n\n-----Input-----\nThe input consists of two values:\nnums: A list of integers, possibly with duplicates.\nk: A natural number indicating how many of the most frequent elements to return. Assuming k <= # of distinct elements in nums.\n\n-----Output-----\nThe output is a list of integers:\nReturns exactly k integers representing the elements that appear most frequently in the input list in the order from the higher frequency to lower frequency.\nIf two numbers have the same frequency, use the order of the first occurrence in nums.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TopKFrequent(nums: array<int>, k: nat) returns (result: array<int>)\n    requires k <= |set i | 0 <= i < nums.Length :: nums[i]|\n    ensures result.Length == k\n    ensures forall x :: x in result[..] ==> x in nums[..]\n    ensures forall i, j :: 0 <= i < j < result.Length ==> result[i] != result[j]", "vc-code": "{\n    result := new int[k];\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0076", "language": "dafny", "source": "verina", "source_id": "verina_advanced_77_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates how much water can be trapped between elevations after it rains. The input is an array of non-negative integers representing an elevation map. Each index traps water depending on the min of max heights to its left and right.\n\nInput:\n- height: An array of natural numbers representing elevations.\n\nOutput:\n- A natural number: total units of water that can be trapped.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TrapRainWater(height: array<nat>) returns (result: nat)\n    requires height.Length >= 0\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    // TODO: implement\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0077", "language": "dafny", "source": "verina", "source_id": "verina_advanced_78_task", "vc-description": "/*\nThis task requires writing a Dafny method that solves the Two Sum problem. Given an array of integers and a target integer, the method must return a pair of indices such that the sum of the numbers at those indices equals the target. You may assume that each input has exactly one solution and that you may not use the same element twice. The answer should be returned with first index is smaller than the second.\n\n-----Input-----\nThe input consists of:\n- nums: An array of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\nThe output is a pair (tuple) of integers representing the indices of the two numbers in the input array that add up to the target.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TwoSum(nums: array<int>, target: int) returns (result: (int, int))\n    requires\n        nums.Length > 1 &&\n        exists i: int, j: int :: 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n    ensures\n        0 <= result.0 < result.1 < nums.Length &&\n        nums[result.0] + nums[result.1] == target", "vc-code": "{\n    assume {:axiom} false;\n    result := (0, 1);\n}", "vc-postamble": ""}
{"id": "DV0078", "language": "dafny", "source": "verina", "source_id": "verina_advanced_79_task", "vc-description": "/*\nThis task requires writing a Dafny method that implementing the \"Two Sum\" problem. Given a list of integers\nand a target integer, the function should return the indices of the two numbers that add up to\nthe target. If no valid pair exists, the function should return none. And the indices returned must\nbe within the bounds of the list. If multiple pair exists, return the first pair.\n\n-----Input-----\n- nums: A list of integers.\n- target: An integer representing the target sum.\n\n-----Output-----\n- An option type containing a pair of natural numbers (indices) such that\n  nums[i] + nums[j] = target, if such a pair exists. Otherwise, it returns none.\n*/", "vc-preamble": "datatype Option<T> = None | Some(value: T)", "vc-helpers": "", "vc-spec": "method TwoSum(nums: array<int>, target: int) returns (result: Option<(nat, nat)>)\n    ensures\n        match result {\n            case None => \n                forall i: int, j: int :: 0 <= i < nums.Length && 0 <= j < nums.Length && i != j ==> nums[i] + nums[j] != target\n            case Some((i, j)) => \n                i < j &&\n                j < nums.Length &&\n                nums[i] + nums[j] == target &&\n                forall k1: int, k2: int :: 0 <= k1 < nums.Length && 0 <= k2 < nums.Length && k1 < k2 && (k1 < i || (k1 == i && k2 < j)) ==> nums[k1] + nums[k2] != target\n        }", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := None;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0079", "language": "dafny", "source": "verina", "source_id": "verina_advanced_80_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the indices of two numbers in an array that add up to a target value. Given an array of integers and a target integer, the function should return the indices of the two numbers such that they add up to the target.\n\nYou may assume that each input has exactly one solution, and you may not use the same element twice.\n\n-----Input-----\nThe input consists of:\nnums: An array of integers.\ntarget: An integer representing the target sum.\n\n-----Output-----\nThe output is an array of two integers:\nReturns the indices of the two numbers in the array that add up to the target. The indices should be sorted.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TwoSum(nums: array<int>, target: int) returns (result: array<int>)\n    requires \n        nums.Length >= 2 &&\n        (exists i: int, j: int :: 0 <= j < i < nums.Length && nums[i] + nums[j] == target) &&\n        (forall i1: int, j1: int, i2: int, j2: int :: \n            (0 <= j1 < i1 < nums.Length && nums[i1] + nums[j1] == target &&\n             0 <= j2 < i2 < nums.Length && nums[i2] + nums[j2] == target) ==> \n            (i1 == i2 && j1 == j2))\n    ensures\n        result.Length == 2 &&\n        0 <= result[0] < nums.Length &&\n        0 <= result[1] < nums.Length &&\n        result[0] < result[1] &&\n        nums[result[0]] + nums[result[1]] == target", "vc-code": "{\n    result := new int[2];\n    result[0] := 0;\n    result[1] := 1;\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0080", "language": "dafny", "source": "verina", "source_id": "verina_advanced_81_task", "vc-description": "/*\nImplement a Dafny method that, given an array of integers, removes all duplicates and returns the resulting array in ascending order.\n\nInput:\nThe input consists of a single array of integers:\narr: An array of integers.\n\nOutput:\nThe output is an array of integers:\nReturns an array containing the unique elements of the input, sorted in ascending order. The returned array must not contain any duplicates, and every element in the output must appear in the original input array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method UniqueSorted(arr: array<int>) returns (result: array<int>)\n    ensures result.Length <= arr.Length\n    ensures forall i :: 0 <= i < result.Length - 1 ==> result[i] <= result[i + 1]\n    ensures forall x :: x in arr[..] <==> x in result[..]", "vc-code": "{\n    assume {:axiom} false;\n    result := new int[0];\n}", "vc-postamble": ""}
{"id": "DV0082", "language": "dafny", "source": "verina", "source_id": "verina_basic_2_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the smallest number in an array of integers.\n\n-----Input-----\nThe input consists of:\ns: An array of integers.\n\n-----Output-----\nThe output is an option integer:\nReturns the smallest number found in the input array or none if the array is empty.\n*/", "vc-preamble": "datatype Option<T> = None | Some(value: T)", "vc-helpers": "", "vc-spec": "method FindSmallest(s: array<nat>) returns (result: Option<nat>)\n    ensures\n        match result {\n            case None => s.Length == 0\n            case Some(r) => s.Length > 0 && \n                      (exists i :: 0 <= i < s.Length && s[i] == r) &&\n                      (forall i :: 0 <= i < s.Length ==> r <= s[i])\n        }", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := None;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0083", "language": "dafny", "source": "verina", "source_id": "verina_basic_3_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given integer is divisible by 11. The method should return true if the number is divisible by 11 and false otherwise.\n\n-----Input-----\nThe input consists of:\nn: An integer to check for divisibility by 11.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is divisible by 11.\nReturns false if the input number is not divisible by 11.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsDivisibleBy11(n: int) returns (result: bool)\n    ensures result <==> (exists k: int :: k * 11 == n)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0084", "language": "dafny", "source": "verina", "source_id": "verina_basic_4_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the kth element in a given array using 1-based indexing. The method should return the element at the specified position, where the first element is at position 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\nk: An integer representing the position (1-based index) of the element to find.\n\n-----Output-----\nThe output is an integer:\nReturns the element at the kth position in the array.\n\n-----Note-----\nThe input k is assumed to be valid (between 1 and array length inclusive).\nThe array is assumed to be non-empty.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method KthElementImpl(arr: array<int>, k: int) returns (result: int)\n    requires k >= 1 && k <= arr.Length\n    ensures result == arr[k - 1]", "vc-code": "{\n    // impl-start\n    result := arr[k - 1];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0085", "language": "dafny", "source": "verina", "source_id": "verina_basic_5_task", "vc-description": "/*\nThis task requires writing a Dafny method that multiplies two integers. The method should return the product of the two input numbers.\n\n-----Input-----\nThe input consists of:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the product of the two input integers (a * b).\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method multiply(a: int, b: int) returns (result: int)\n    ensures result == a * b", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0086", "language": "dafny", "source": "verina", "source_id": "verina_basic_6_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the minimum among three given integers. The method should return the smallest value, ensuring that the result is less than or equal to each of the input numbers and that it is one of the provided integers.\n\nInput:\nThe input consists of three integers:\na: The first integer.\nb: The second integer.\nc: The third integer.\n\nOutput:\nThe output is an integer:\nReturns the minimum of the three input numbers, assuring that the returned value is less than or equal to a, b, and c, and that it matches one of these values.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MinOfThree(a: int, b: int, c: int) returns (result: int)\n    ensures result <= a && result <= b && result <= c\n    ensures result == a || result == b || result == c", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0087", "language": "dafny", "source": "verina", "source_id": "verina_basic_7_task", "vc-description": "/*\nThis task requires writing a Dafny method that computes the sum of the squares of the first n odd natural numbers. The result should match the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of odd natural numbers to consider (n should be non-negative).\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the squares of the first n odd natural numbers, as defined by the formula: (n * (2 * n - 1) * (2 * n + 1)) / 3.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SumOfSquaresOfFirstNOddNumbers(n: nat) returns (result: nat)\n    requires n >= 0\n    ensures result as int == (n as int * (2 * n as int - 1) * (2 * n as int + 1)) / 3", "vc-code": "{\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0088", "language": "dafny", "source": "verina", "source_id": "verina_basic_8_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines the minimum of two integers. The method should return the smaller of the two numbers. When both numbers are equal, either one may be returned.\n\n-----Input-----\nThe input consists of two integers:\na: The first integer.\nb: The second integer.\n\n-----Output-----\nThe output is an integer:\nReturns the smaller value between the input integers, ensuring that the result is less than or equal to both inputs.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MyMin(a: int, b: int) returns (result: int)\n    ensures result <= a && result <= b\n    ensures result == a || result == b", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0089", "language": "dafny", "source": "verina", "source_id": "verina_basic_9_task", "vc-description": "/*\nThis task requires writing a Dafny method that checks whether two arrays of integers have any elements in common. In other words, the method should return true if there is at least one element that appears in both arrays, and false if no such element exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one common element between the two arrays.\nReturns false if there are no common elements shared by the arrays.\n\n-----Note-----\nBoth arrays are assumed to be non-null.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method HasCommonElement(a: array<int>, b: array<int>) returns (result: bool)\n    requires \n        a.Length > 0 &&\n        b.Length > 0\n    ensures\n        result == (exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && a[i] == b[j])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0090", "language": "dafny", "source": "verina", "source_id": "verina_basic_10_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines if a given integer is strictly greater than every element in a provided array. The method should return true only if the integer is larger than each element in the array; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\nn: An integer.\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the integer is greater than all elements in the array.\nReturns false if there is at least one element in the array that is greater than or equal to the integer.\n\n-----Note-----\nThe array is assumed to be non-null.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsGreater(n: int, a: array<int>) returns (result: bool)\n    requires a.Length > 0\n    ensures result == (forall i :: 0 <= i < a.Length ==> n > a[i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0091", "language": "dafny", "source": "verina", "source_id": "verina_basic_11_task", "vc-description": "/*\nThis task requires writing a Dafny method that extracts the last digit of a given non-negative integer. The method should return the last digit, which is obtained by computing the remainder when the number is divided by 10. The result must always be between 0 and 9.\n\n-----Input-----\nThe input consists of a single value:\nn: A non-negative integer.\n\n-----Output-----\nThe output is an integer:\nReturns the last digit of the input number, ensuring that the digit lies within the range 0 to 9.\n\n-----Note-----\nIt is assumed that the input number n is non-negative.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "function last_digit(n: nat): nat", "vc-code": "{\n    // impl-start\n    // TODO: implement\n    n % 10\n    // impl-end\n}\n\nlemma last_digit_correct(n: nat)\n    ensures\n        last_digit(n) < 10\n    ensures\n        last_digit(n) == n % 10\n{\n    // impl-start\n    // TODO: Implement proof\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0093", "language": "dafny", "source": "verina", "source_id": "verina_basic_13_task", "vc-description": "/*\nThis task requires writing a Dafny method that transforms an array of integers by replacing every element with its cube. In other words, for each element in the input array, the output array should contain the result of multiplying that element by itself three times.\n\nInput:\nThe input consists of:\na: An array of integers (which may be empty or non-empty).\n\nOutput:\nThe output is an array of integers:\nReturns an array with the same length as the input, where each element is the cube of the corresponding element in the input array.\n\nNote:\nThere are no additional preconditions; the method should work correctly for any array of integers.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method CubeElements(a: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == a[i] * a[i] * a[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[a.Length];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0094", "language": "dafny", "source": "verina", "source_id": "verina_basic_14_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given string contains the character 'z' or 'Z'. The method should return true if the string includes either the lowercase or uppercase letter 'z', and false otherwise.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input string contains the character 'z' or 'Z'.\nReturns false if the input string does not contain the character 'z' or 'Z'.\n\n-----Note-----\nThere are no preconditions; the method will always work as strings and sequences are considered non-null.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ContainsZ(s: string) returns (result: bool)\n    ensures\n        result <==> exists i :: 0 <= i < |s| && (s[i] == 'z' || s[i] == 'Z')", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0095", "language": "dafny", "source": "verina", "source_id": "verina_basic_15_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether an array of integers contains at least one pair of consecutive numbers. The method should return true if there is any index where an element, when increased by one, equals the next element in the array. If no such consecutive pair exists, the method should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers (the array may be empty or non-empty).\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if there is at least one index where an element plus one equals the following element.\nReturns false if the array does not contain any consecutive numbers.\n\n-----Note-----\nThere are no additional preconditions; the method will function correctly regardless of the array's size.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ContainsConsecutiveNumbers(a: seq<int>) returns (result: bool)\n    ensures\n        result <==> exists i :: 0 <= i < |a| - 1 && a[i] + 1 == a[i + 1]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0097", "language": "dafny", "source": "verina", "source_id": "verina_basic_17_task", "vc-description": "/*\nThis task requires writing a Dafny method that converts all uppercase characters in a given string to their lowercase equivalents while keeping the other characters unchanged. The output string must have the same length as the input string.\n\n-----Input-----\nThe input consists of:\ns: A string that may contain both uppercase and lowercase characters.\n\n-----Output-----\nThe output is a string:\nReturns a new string where every uppercase letter has been converted to lowercase, and every non-uppercase character remains exactly as in the input.\n\n-----Note-----\nThere are no preconditions; the method is expected to work for any non-null string.\n*/", "vc-preamble": "/* Helper function to check if a character is uppercase */\npredicate IsUppercase(c: char)\n{\n    'A' <= c <= 'Z'\n}\n\n/* Helper function to shift character by 32 positions */\nfunction Shift32(c: char): char\n    requires 'A' <= c <= 'Z'\n{\n    ((c as int) + 32) as char\n}", "vc-helpers": "", "vc-spec": "method ToLowercase(s: seq<char>) returns (result: seq<char>)\n    ensures\n        |result| == |s| &&\n        forall i :: 0 <= i < |s| ==> \n            if IsUppercase(s[i]) then\n                result[i] == Shift32(s[i])\n            else\n                result[i] == s[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0098", "language": "dafny", "source": "verina", "source_id": "verina_basic_18_task", "vc-description": "/*\nThis task requires writing a Dafny method that computes the sum of the digits of a non-negative integer. The method should process each digit of the input number and return the total sum. The output is guaranteed to be a non-negative natural number.\n\n-----Input-----\nThe input consists of:\nn: A non-negative integer.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the digits of the input integer.\n\n-----Note-----\nThe input is assumed to be a valid non-negative integer.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "function SumOfDigits(n: nat): nat", "vc-code": "lemma SumOfDigitsSpecSatisfied(n: nat)\n    ensures SumOfDigits(n) >= 0\n{\n    // TODO: Implement proof\n}", "vc-postamble": ""}
{"id": "DV0099", "language": "dafny", "source": "verina", "source_id": "verina_basic_19_task", "vc-description": "/*\nThis task requires writing a Dafny method that checks whether an array of integers is sorted in non-decreasing order. The method should return true if every element is less than or equal to the element that follows it, and false otherwise.\n\n-----Input-----\nThe input consists of:\na: An array of integers. The array can be empty or have any length.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is sorted in non-decreasing order.\nReturns false if the array is not sorted in non-decreasing order.\n\n-----Note-----\nA true result guarantees that for every valid pair of indices i and j (with i < j), the element at position i is less than or equal to the element at position j. A false result indicates that there exists at least one adjacent pair of elements where the first element is greater than the second.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsSorted(a: seq<int>) returns (result: bool)\n    ensures\n        result == (forall i :: 0 <= i < |a| - 1 ==> a[i] <= a[i + 1])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0100", "language": "dafny", "source": "verina", "source_id": "verina_basic_20_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates the product of all distinct integers in an array. The method should consider each unique integer only once when computing the product and return the resulting value. If the array is empty, the method should return 1.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the product of all unique integers from the input array.\n\n-----Note-----\nThe order in which the unique integers are multiplied does not affect the final product.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method unique_product(arr: array<int>) returns (result: int)\n    ensures\n        /* Product of all unique integers in the array */\n        true /* Placeholder for actual postcondition */", "vc-code": "{\n    // impl-start\n    // TODO: implement\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0101", "language": "dafny", "source": "verina", "source_id": "verina_basic_21_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether one list is a sublist of another. In other words, the method should check if the first list appears as a contiguous sequence within the second list and return true if it does, and false otherwise.\n\n-----Input-----\nThe input consists of two lists of integers:\nsub: A list of integers representing the potential sublist.\nmain: A list of integers in which to search for the sublist.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the first list appears as a contiguous sequence within the second list.\nReturns false if the first list does not appear as a contiguous sequence in the second list.\n\n-----Note-----\nThere are no preconditions for this method; the sequences are always non-null.\n*/", "vc-preamble": "predicate IsSubseqAt(sub: seq<int>, main: seq<int>, i: int)\n{\n    0 <= i && i + |sub| <= |main| && \n    (forall j :: 0 <= j < |sub| ==> sub[j] == main[i + j])\n}", "vc-helpers": "", "vc-spec": "method IsSublist(sub: seq<int>, main: seq<int>) returns (result: bool)\n    ensures result <==> exists i :: IsSubseqAt(sub, main, i)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0104", "language": "dafny", "source": "verina", "source_id": "verina_basic_24_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the difference between the first even number and the first odd number in an array of integers. The method should process the array sequentially until it identifies the first even number and the first odd number, and then return the difference calculated as (first even number) minus (first odd number).\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the difference computed as the first even number minus the first odd number found in the array.\n\n-----Note-----\nThe input array is assumed to be non-empty and to contain at least one even number and one odd number.\n*/", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}", "vc-helpers": "", "vc-spec": "method FirstEvenOddDifference(a: array<int>) returns (result: int)\n    requires \n        a.Length > 1 &&\n        (exists x :: 0 <= x < a.Length && IsEven(a[x])) &&\n        (exists x :: 0 <= x < a.Length && IsOdd(a[x]))\n    ensures \n        exists i, j :: \n            0 <= i < a.Length && 0 <= j < a.Length &&\n            IsEven(a[i]) && IsOdd(a[j]) &&\n            result == a[i] - a[j] &&\n            (forall k :: 0 <= k < i ==> IsOdd(a[k])) &&\n            (forall k :: 0 <= k < j ==> IsEven(a[k]))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0105", "language": "dafny", "source": "verina", "source_id": "verina_basic_25_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates both the sum and the average of the first n natural numbers. The method should compute the sum of numbers from 0 to n (which equals n * (n + 1) / 2) and then determine the average by dividing this sum by n. The specification assumes that the input n is a positive integer.\n\n-----Input-----\nThe input consists of:\nn: A natural number representing the count of the first natural numbers. The value of n is assumed to be positive.\n\n-----Output-----\nThe output is a pair consisting of:\n- An integer representing the sum of the first n natural numbers.\n- A floating-point number representing the average of the first n natural numbers.\n\n-----Note-----\nThe input n must be a positive integer.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SumAndAverage(n: int) returns (result: (int, real))\n    requires n < 100000  // reasonable bound to prevent overflow\n    ensures\n        n == 0 ==> result.0 == 0\n    ensures\n        n > 0 ==> result.0 == (n * (n + 1)) / 2", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, 0.0);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0106", "language": "dafny", "source": "verina", "source_id": "verina_basic_26_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given integer is even. In other words, the method should return true if the number is even and false if the number is odd.\n\n-----Input-----\nThe input consists of:\nn: An integer.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the input number is even.\nReturns false if the input number is odd.\n\n-----Note-----\nThere are no preconditions; the method will always work for any integer input.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsEven(n: int) returns (result: bool)\n    ensures result <==> (n % 2 == 0)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0107", "language": "dafny", "source": "verina", "source_id": "verina_basic_27_task", "vc-description": "/*\nThis task requires writing a Dafny method that identifies the first repeated character in a given string. The method should return an Option containing a character. The Option value indicates whether any character in the string is repeated. If it is Some(c), the accompanying character is the first character that appears more than once. If it is None, it indicates that there are no repeated characters in the string.\n\nInput:\nThe input consists of:\ns: An array of characters.\n\nOutput:\nThe output is Option<char>:\n- Returns Some(c) with the first repeated character in the string if any repeated character is found.\n- Returns None if no repeated characters are present.\n\nNote:\nThere are no preconditions; the method is expected to work for any array of characters.\n*/", "vc-preamble": "datatype Option<T> = None | Some(value: T)\n\nfunction CountChar(chars: seq<char>, c: char): nat\n    decreases |chars|\n{\n    if |chars| == 0 then\n        0\n    else if chars[0] == c then\n        1 + CountChar(chars[1..], c)\n    else\n        CountChar(chars[1..], c)\n}\n\npredicate HasNoDuplicatesUpTo(chars: seq<char>, endIdx: int)\n    requires 0 <= endIdx <= |chars|\n{\n    forall i, j :: 0 <= i < j < endIdx ==> chars[i] != chars[j]\n}\n\npredicate HasNoDuplicates(chars: seq<char>)\n{\n    forall i, j :: 0 <= i < j < |chars| ==> chars[i] != chars[j]\n}\n\nfunction FirstOccurrenceIndex(chars: seq<char>, c: char): int\n    requires exists i :: 0 <= i < |chars| && chars[i] == c\n    ensures 0 <= FirstOccurrenceIndex(chars, c) < |chars|\n    ensures chars[FirstOccurrenceIndex(chars, c)] == c\n{\n    if chars[0] == c then 0\n    else 1 + FirstOccurrenceIndex(chars[1..], c)\n}\n\npredicate SecondOccurrenceExists(chars: seq<char>, c: char)\n{\n    exists i, j :: 0 <= i < j < |chars| && chars[i] == c && chars[j] == c\n}", "vc-helpers": "", "vc-spec": "method FindFirstRepeatedChar(s: array<char>) returns (result: Option<char>)\n    ensures match result {\n        case Some(c) => \n            var chars := s[..];\n            CountChar(chars, c) >= 2 &&\n            SecondOccurrenceExists(chars, c) &&\n            (exists firstIdx :: 0 <= firstIdx < |chars| && chars[firstIdx] == c &&\n             exists secondIdx :: firstIdx < secondIdx < |chars| && chars[secondIdx] == c &&\n             HasNoDuplicatesUpTo(chars, secondIdx))\n        case None => \n            HasNoDuplicates(s[..])\n    }", "vc-code": "{\n    assume {:axiom} false;\n    result := None;\n}", "vc-postamble": ""}
{"id": "DV0108", "language": "dafny", "source": "verina", "source_id": "verina_basic_28_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given natural number is prime. A number (with n ≥ 2) is considered prime if it is divisible only by 1 and itself. The method should return true when the input number is prime and false otherwise.\n\nInput:\nThe input consists of:\nn: A natural number (nat) such that n ≥ 2.\n\nOutput:\nThe output is a Boolean value:\nReturns true if the input number is prime (i.e., there is no integer k with 1 < k < n that divides n).\nReturns false if the input number is not prime (i.e., there exists an integer k with 1 < k < n that divides n).\n\nNote:\nThe input is expected to satisfy the condition n ≥ 2.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsPrime(n: nat) returns (result: bool)\n    requires n >= 2\n    ensures result ==> forall k: nat :: 2 <= k < n ==> n % k != 0\n    ensures !result ==> exists k: nat :: 2 <= k < n && n % k == 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0110", "language": "dafny", "source": "verina", "source_id": "verina_basic_30_task", "vc-description": "/*\nThis task requires writing a Dafny method that computes the element-wise modulo between two arrays of integers. The method should produce a new array where each element is the remainder after dividing the corresponding element from the first array by the element from the second array.\n\nInput:\nThe input consists of:\na: An array of integers.\nb: An array of integers.\n\nOutput:\nThe output is an array of integers:\nReturns a new array in which each element is the result of taking the modulo of the corresponding elements from the two input arrays.\n\nNote:\nPreconditions:\n- Both arrays must be non-null.\n- Both arrays must have the same length.\n- All elements in the second array should be non-zero.\n\nPostconditions:\n- The length of the resulting array is the same as the length of the input arrays.\n- Each element in the resulting array is the modulo of the corresponding elements in the input arrays.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ElementWiseModulo(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires |a| > 0\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] % b[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0111", "language": "dafny", "source": "verina", "source_id": "verina_basic_31_task", "vc-description": "/*\nThis task requires writing a Dafny method that converts a given string to uppercase. The method should replace every lowercase letter in the input string with its corresponding uppercase character while leaving all other characters unchanged. The output string must have the same length as the input string.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a string:\nReturns a new string in which every lowercase letter from the input string is converted to uppercase, and all other characters are exactly the same as in the input string, ensuring the output string has the same length as the input.\n\nNote:\nThere are no preconditions since the method assumes that the input string is always valid (i.e., non-null).\n*/", "vc-preamble": "predicate IsLowerCase(c: char)\n{\n    'a' <= c && c <= 'z'\n}\n\nfunction ShiftMinus32(c: char): char\n    requires 'a' <= c <= 'z'\n{\n    (c as int - 32) as char\n}", "vc-helpers": "", "vc-spec": "method ToUppercase(s: string) returns (result: string)\n    ensures\n        |result| == |s|\n    ensures\n        forall i :: 0 <= i < |s| ==> \n            var c := s[i];\n            var r := result[i];\n            if IsLowerCase(c) then\n                r == ShiftMinus32(c)\n            else\n                r == c", "vc-code": "{\n    assume {:axiom} false;\n    result := \"\";\n}", "vc-postamble": ""}
{"id": "DV0112", "language": "dafny", "source": "verina", "source_id": "verina_basic_32_task", "vc-description": "/*\nThis task requires writing a Dafny method that swaps the first and last elements of an array of integers. The method should produce a new array where the first element of the output is the last element of the input, the last element of the output is the first element of the input, and all other elements remain in their original positions.\n\nInput:\nThe input consists of:\na: An array of integers (assumed to be non-empty).\n\nOutput:\nThe output is an array of integers:\nReturns a new array where:\n- The former last element becomes the first element.\n- The former first element becomes the last element.\n- All other elements remain unchanged.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SwapFirstAndLast(a: seq<int>) returns (result: seq<int>)\n    requires |a| > 0\n    ensures |result| == |a|\n    ensures result[0] == a[|a| - 1]\n    ensures result[|result| - 1] == a[0]\n    ensures forall i :: 1 <= i < |result| - 1 ==> result[i] == a[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0114", "language": "dafny", "source": "verina", "source_id": "verina_basic_34_task", "vc-description": "/*\nThis task requires writing a Dafny method that extracts even numbers from an array of integers. The method should return a new array containing only the even numbers found in the input array, while preserving the order in which they appear.\n\n-----Input-----\nThe input consists of:\narr: An array of integers.\n\n-----Output-----\nThe output is an array of integers:\nReturns an array containing all the even numbers from the input array. Specifically:\n- Every element in the output array is an even integer.\n- All even integers present in the input array are included in the output array.\n- The relative order of the even integers is preserved as in the input array.\n\n-----Note-----\nThere are no preconditions for this task; the method will work with any array, including empty arrays (which are not null).\n*/", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "", "vc-spec": "method FindEvenNumbers(arr: array<int>) returns (result: array<int>)\n    ensures forall x :: x in result[..] ==> IsEven(x) && x in arr[..]\n    ensures forall x :: x in arr[..] && IsEven(x) ==> x in result[..]\n    ensures forall i, j :: 0 <= i < arr.Length && 0 <= j < arr.Length && i <= j \n        && IsEven(arr[i]) && IsEven(arr[j]) ==> \n        exists ri, rj :: 0 <= ri < result.Length && 0 <= rj < result.Length \n            && ri <= rj && result[ri] == arr[i] && result[rj] == arr[j]", "vc-code": "{\n    assume {:axiom} false;\n    result := new int[0];\n}", "vc-postamble": ""}
{"id": "DV0116", "language": "dafny", "source": "verina", "source_id": "verina_basic_36_task", "vc-description": "/*\nThis task requires writing a Dafny method that takes a given string and returns a new string where every occurrence of a space, comma, or dot is replaced with a colon. The transformation must preserve the original string's length and leave all other characters unmodified.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a string:\n- The returned string must have the same length as the input string.\n- Every space, comma, or dot in the input string is replaced with a colon.\n- All other characters remain unchanged.\n\nNote:\nThere are no preconditions; the input string is assumed to be non-null.\n*/", "vc-preamble": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}", "vc-helpers": "", "vc-spec": "method ReplaceWithColon(s: string) returns (result: string)\n    ensures\n        |result| == |s|\n    ensures\n        forall i :: 0 <= i < |s| ==> \n            result[i] == \n            if IsSpaceCommaDot(s[i]) then ':' else s[i]", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := \"\";\n}", "vc-postamble": ""}
{"id": "DV0117", "language": "dafny", "source": "verina", "source_id": "verina_basic_37_task", "vc-description": "/*\nThis task requires writing a Dafny method that locates the first occurrence of a specified integer within a sorted array of integers. The method returns the index corresponding to the first time the target value appears in the array; if the target is absent, it returns -1. It is also essential that the original array remains unchanged.\n\nInput:\nThe input consists of:\n• arr: An array of integers sorted in non-decreasing order.\n• target: An integer representing the value to search for.\n\nOutput:\nThe output is an integer:\n• If the target is found, the method returns the index of its first occurrence.\n• If the target is not found, the method returns -1.\n\nNote:\n• The input array must be sorted in non-decreasing order.\n• The array is guaranteed to remain unmodified after the method executes.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method FindFirstOccurrence(arr: array<int>, target: int) returns (result: int)\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures (result >= 0 ==> (\n        0 <= result < arr.Length &&\n        arr[result] == target &&\n        forall i :: 0 <= i < result ==> arr[i] != target\n    )) &&\n    (result == -1 ==> (\n        forall i :: 0 <= i < arr.Length ==> arr[i] != target\n    ))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := -1;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0118", "language": "dafny", "source": "verina", "source_id": "verina_basic_38_task", "vc-description": "/*\nThis task requires writing a Lean 4 method that checks whether all characters in an input string are identical. The method should return true if every character in the string is the same, and false if at least one character differs. An empty string or a single-character string is considered to have all characters identical.\n\n-----Input-----\nThe input consists of:\ns: A string.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if every character in the string is identical.\nReturns false if there is at least one differing character.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method AllCharactersSame(s: seq<char>) returns (result: bool)\n    requires true\n    ensures result ==> (forall i: int, j: int :: 0 <= i < |s| && 0 <= j < |s| ==> s[i] == s[j])\n    ensures !result ==> (|s| > 0 && exists i: int :: 0 <= i < |s| && s[i] != s[0])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0119", "language": "dafny", "source": "verina", "source_id": "verina_basic_39_task", "vc-description": "/*\nThis task requires writing a Dafny method that rotates a list of integers to the right by a specified number of positions. The method should produce a new list where each element is shifted to the right while preserving the original list's length.\n\n-----Input-----\nThe input consists of:\n• l: A list of integers.\n• n: A non-negative natural number that indicates the number of positions by which to rotate the list.\n\n-----Output-----\nThe output is a list of integers:\n• Returns a list with the same length as the input list, where the elements have been rotated to the right by n positions.\n\n-----Note-----\n• The precondition requires that n is non-negative.\n• If the input list is empty, it should be returned unchanged.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method RotateRight(l: array<int>, n: nat) returns (result: array<int>)\n    ensures\n        result.Length == l.Length &&\n        (l.Length == 0 || forall i :: 0 <= i < l.Length ==> \n            var len := l.Length;\n            var rotatedIndex := ((i - n + len) % len);\n            result[i] == l[rotatedIndex])", "vc-code": "{\n    assume {:axiom} false;\n    result := new int[l.Length];\n}", "vc-postamble": ""}
{"id": "DV0120", "language": "dafny", "source": "verina", "source_id": "verina_basic_40_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the second-smallest number in an array of integers. The method should determine and return the number that is larger than the smallest element in the array. It is crucial that the input array remains unchanged after the computation.\n\n-----Input-----\nThe input consists of:\ns: An array of integers containing at least two elements.\n\n-----Output-----\nThe output is an integer:\nReturns the second-smallest number in the input array.\n\n-----Note-----\n- The input array is guaranteed to contain at least two elements and is non-null.\n- It is assumed that there exist at least two distinct values in the array to ensure a unique second-smallest element.\n- The original array must remain unmodified.\n*/", "vc-preamble": "predicate SecondSmallestPrecond(s: array<int>)\n    reads s\n{\n    s.Length > 1\n}\n\npredicate SecondSmallestPostcond(s: array<int>, result: int)\n    reads s\n{\n    (exists i :: 0 <= i < s.Length && s[i] == result) &&\n    (exists j :: 0 <= j < s.Length && s[j] < result &&\n        (forall k :: 0 <= k < s.Length && s[k] != s[j] ==> s[k] >= result))\n}", "vc-helpers": "", "vc-spec": "function SecondSmallest(s: array<int>): int\n    requires SecondSmallestPrecond(s)\n    reads s", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    0\n    // impl-end\n}\n\nlemma SecondSmallestSpecSatisfied(s: array<int>)\n    requires SecondSmallestPrecond(s)\n    ensures SecondSmallestPostcond(s, SecondSmallest(s))\n{\n    assume {:axiom} false;\n}", "vc-postamble": ""}
{"id": "DV0121", "language": "dafny", "source": "verina", "source_id": "verina_basic_41_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether an array of integers contains only one distinct element. The method should return true if the array is empty or if every element in the array is the same, and false if there are at least two different elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if the array is empty or if all elements in the array are identical.\nReturns false if the array contains at least two distinct elements.\n\n-----Note-----\nThe input array is assumed to be non-null.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method HasOnlyOneDistinctElement(a: array<int>) returns (result: bool)\n    requires a.Length > 0\n    ensures result ==> (forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] == a[j])\n    ensures !result ==> (exists i :: 0 <= i < a.Length && a[i] != a[0])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0122", "language": "dafny", "source": "verina", "source_id": "verina_basic_42_task", "vc-description": "/*\nThis task requires writing a Dafny method that counts the number of digit characters within a given string. A digit is any character between '0' and '9'. The method should determine how many such digit characters appear in the input.\n\nInput:\nThe input consists of:\ns: A string.\n\nOutput:\nThe output is a natural number (nat):\nReturns a non-negative count representing the number of digit characters found in the input string.\n\nNote:\nThere are no additional preconditions; the method works for any provided string.\n*/", "vc-preamble": "predicate IsDigit(c: char)\n{\n    '0' <= c <= '9'\n}", "vc-helpers": "", "vc-spec": "method CountDigits(s: string) returns (result: nat)\n    ensures result >= 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0123", "language": "dafny", "source": "verina", "source_id": "verina_basic_43_task", "vc-description": "/*\nThis task requires writing a Dafny function that computes the sum of the fourth power of the first n odd natural numbers. In other words, given a non-negative integer n, the function should calculate the sum: 1⁴ + 3⁴ + 5⁴ + ... for the first n odd numbers.\n\n-----Input-----\nThe input consists of:\nn: A non-negative natural number representing the number of odd natural numbers to consider.\n\n-----Output-----\nThe output is a natural number:\nReturns the sum of the fourth power of the first n odd natural numbers.\n\n-----Note-----\nThe input n is assumed to be a non-negative integer.\nThe correctness of the result is established by a theorem that relates the computed sum to a specific formula.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "function SumOfFourthPowerOfOddNumbers(n: nat): nat", "vc-code": "{\n    // impl-start\n    0\n    // impl-end\n}\n\nlemma SumOfFourthPowerOfOddNumbersSpec(n: nat)\n    ensures\n        15 * SumOfFourthPowerOfOddNumbers(n) == n * (2 * n + 1) * (7 + 24 * (n * n * n) - 12 * (n * n) - 14 * n)\n{\n    assume {:axiom} false; // TODO: Remove this line and implement the proof\n}", "vc-postamble": ""}
{"id": "DV0124", "language": "dafny", "source": "verina", "source_id": "verina_basic_44_task", "vc-description": "/*\nThis task requires writing a Verus method that verifies if every odd index in an array of integers holds an odd number. In other words, for each index in the array that is odd, the number located at that index must also be odd. The method should return true if this condition is satisfied for every odd index; otherwise, it should return false.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is a Boolean value:\nReturns true if, for every odd index in the array, the corresponding element is odd.\nReturns false if there is at least one odd index where the corresponding element is not odd.\n\n-----Note-----\nThere are no preconditions; the method will work for any array of integers.\n*/", "vc-preamble": "predicate IsOdd(n: int)\n{\n    n % 2 == 1\n}", "vc-helpers": "", "vc-spec": "method IsOddAtIndexOdd(a: array<int>) returns (result: bool)\n    ensures result <==> (forall i :: 0 <= i < a.Length && i % 2 == 1 ==> IsOdd(a[i]))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0125", "language": "dafny", "source": "verina", "source_id": "verina_basic_45_task", "vc-description": "/*\nThis task requires writing a Dafny method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.\n\nInput:\nThe input consists of:\nlst: A list of integers.\n\nOutput:\nThe output is an integer:\nReturns the product resulting from multiplying the first even number and the first odd number found in the list.\n\nNote:\nThe input list is assumed to contain at least one even number and one odd number.\n*/", "vc-preamble": "predicate FindProductPrecond(lst: seq<int>)\n{\n    |lst| > 1 &&\n    (exists x :: x in lst && IsEven(x)) &&\n    (exists x :: x in lst && IsOdd(x))\n}\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\nfunction {:axiom} FirstEvenIndex(lst: seq<int>): int\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    ensures 0 <= FirstEvenIndex(lst) < |lst|\n    ensures IsEven(lst[FirstEvenIndex(lst)])\n    ensures forall j :: 0 <= j < FirstEvenIndex(lst) ==> !IsEven(lst[j])\n\nfunction {:axiom} FirstOddIndex(lst: seq<int>): int\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= FirstOddIndex(lst) < |lst|\n    ensures IsOdd(lst[FirstOddIndex(lst)])\n    ensures forall j :: 0 <= j < FirstOddIndex(lst) ==> !IsOdd(lst[j])", "vc-helpers": "", "vc-spec": "method FindProduct(lst: array<int>) returns (result: int)\n    requires lst.Length > 1\n    requires exists x :: x in lst[..] && IsEven(x)\n    requires exists x :: x in lst[..] && IsOdd(x)\n    ensures var ei := FirstEvenIndex(lst[..]);\n            var oi := FirstOddIndex(lst[..]);\n            result == lst[ei] * lst[oi]", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0126", "language": "dafny", "source": "verina", "source_id": "verina_basic_46_task", "vc-description": "/*\nThis task requires writing a Dafny method that finds the last occurrence of a specified element in a sorted array of integers. The method should return the index corresponding to the last occurrence of the element if it is present; if the element is absent, it should return -1. Additionally, the array must remain unchanged after the method is executed.\n\nInput:\nThe input consists of:\narr: A sorted array of integers in non-decreasing order.\nelem: An integer whose last occurrence position is to be determined.\n\nOutput:\nThe output is an integer:\nReturns the index of the last occurrence of the specified integer in the array if it exists.\nReturns -1 if the integer is not found in the array.\n\nNote:\nThe input array is assumed to be sorted in non-decreasing order and remains unchanged by the method.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LastPosition(arr: array<int>, elem: int) returns (result: int)\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures\n        (result >= 0 ==> \n            0 <= result < arr.Length &&\n            arr[result] == elem &&\n            forall k :: result < k < arr.Length ==> arr[k] != elem) &&\n        (result == -1 ==> forall k :: 0 <= k < arr.Length ==> arr[k] != elem)", "vc-code": "{\n    assume {:axiom} false;\n    result := -1;\n}", "vc-postamble": ""}
{"id": "DV0127", "language": "dafny", "source": "verina", "source_id": "verina_basic_47_task", "vc-description": "/*\nThis task requires writing a Dafny method that calculates the sum of all the elements in an array of integers. The method should process the entire array and return the total sum of its elements.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an integer:\nReturns the sum of all elements in the input array.\n\n-----Note-----\n- The input array is assumed not to be null.\n*/", "vc-preamble": "function SumTo(a: seq<int>, n: int): int\n    requires 0 <= n <= |a|\n    decreases n\n{\n    if n <= 0 then 0 else SumTo(a, n - 1) + a[n - 1]\n}", "vc-helpers": "", "vc-spec": "method ArraySum(a: seq<int>) returns (result: int)\n    requires |a| > 0\n    ensures result == SumTo(a, |a|)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0128", "language": "dafny", "source": "verina", "source_id": "verina_basic_48_task", "vc-description": "/*\nThis task requires writing a Dafny method that determines whether a given non-negative natural number is a perfect square. In other words, the method should return true if there exists a natural number whose square is equal to the input number, and false if no such number exists.\n\nInput:\nThe input consists of a single natural number:\nn: A non-negative natural number (nat).\n\nOutput:\nThe output is a Boolean value:\nReturns true if there exists an integer such that its square equals the input n.\nReturns false if no integer squared equals the input n.\n*/", "vc-preamble": "ghost predicate IsPerfectSquare(n: nat)\n{\n    exists i: nat :: i * i == n\n}", "vc-helpers": "", "vc-spec": "method IsPerfectSquareFn(n: int) returns (result: bool)\n    requires n >= 0\n    ensures result <==> IsPerfectSquare(n as nat)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0129", "language": "dafny", "source": "verina", "source_id": "verina_basic_49_task", "vc-description": "/*\nThis task requires writing a Dafny method that searches an array of integers to locate the first odd number. The method should return an Option where Some(index) indicates the smallest index of an odd number, and None indicates no odd number exists.\n\n-----Input-----\nThe input consists of:\na: An array of integers.\n\n-----Output-----\nThe output is an Option<nat>:\n- If Some(idx), then idx represents the smallest index of an odd number in the array.\n- If None, then there are no odd numbers in the array.\n\n-----Note-----\n- The input array is assumed to be non-null.\n- If multiple odd numbers are present, the index returned should correspond to the first occurrence.\n*/", "vc-preamble": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\n\ndatatype Option<T> = None | Some(value: T)", "vc-helpers": "", "vc-spec": "method FindFirstOdd(a: array<int>) returns (result: Option<nat>)\n    requires a.Length > 0\n    ensures\n        match result {\n            case Some(idx) => idx < a.Length && IsOdd(a[idx]) &&\n                forall j :: 0 <= j < idx ==> !IsOdd(a[j])\n            case None => forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n        }", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    return None;\n}", "vc-postamble": ""}
{"id": "DV0130", "language": "dafny", "source": "verina", "source_id": "verina_basic_50_task", "vc-description": "/*\nThis task is about calculating the absolute value of an integer. The goal is to determine the non-negative value of a given integer: if the integer is non-negative, it remains unchanged; if it is negative, its positive counterpart is returned.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is an integer that represents the absolute value of the input. Specifically:\n• If x is non-negative, the output is x.\n• If x is negative, the output is the negation of x (that is, a value y such that x + y = 0).\n\n-----Note-----\nThis function should correctly handle zero, positive, and negative integers.\n*/", "vc-preamble": "function abs(x: int): int\n{\n    if x >= 0 then x else -x\n}", "vc-helpers": "", "vc-spec": "method abs_impl(x: int) returns (result: int)\n    ensures (x >= 0 ==> result == x) && (x < 0 ==> x + result == 0)", "vc-code": "{\n    if x >= 0 {\n        result := x;\n    } else {\n        result := -x;\n    }\n}", "vc-postamble": ""}
{"id": "DV0131", "language": "dafny", "source": "verina", "source_id": "verina_basic_51_task", "vc-description": "/*\nThis task requires creating a function that determines the correct insertion index for a given integer in a sorted array. The goal is to identify an index where every number before it is less than the specified value, and every number from that index onward is greater than or equal to the value. If the given integer is larger than all elements in the array, the function should return the array's size.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers that is assumed to be sorted in non-decreasing order.\n• key: An integer to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) representing the index determined by the binary search. The index satisfies the following postconditions:\n• It is between 0 and the size of the array.\n• Every element before the returned index is less than the key.\n• If the returned index equals the size of the array, then all elements are less than the key.\n• Every element from the index onwards is greater than or equal to the key.\n\n-----Note-----\nIt is assumed that the input array is sorted in non-decreasing order. The function returns the first index where the key could be inserted while maintaining the sorted order.\n*/", "vc-preamble": "predicate BinarySearchPrecond(a: array<int>, key: int)\n    reads a\n{\n    forall i, j :: 0 <= i <= j < a.Length ==> a[i] <= a[j]\n}\nmethod BinarySearchLoop(a: array<int>, key: int, lo: nat, hi: nat) returns (result: nat)\n    requires lo <= hi\n    requires hi <= a.Length\n    requires BinarySearchPrecond(a, key)\n    ensures lo <= result <= hi\n    ensures forall i :: lo <= i < result ==> a[i] < key\n    ensures forall i :: result <= i < hi ==> a[i] >= key\n    decreases hi - lo\n{\n    if lo < hi {\n        var mid := lo + (hi - lo) / 2;\n        if a[mid] < key {\n            result := BinarySearchLoop(a, key, mid + 1, hi);\n        } else {\n            result := BinarySearchLoop(a, key, lo, mid);\n        }\n    } else {\n        result := lo;\n    }\n}", "vc-helpers": "", "vc-spec": "method BinarySearch(a: array<int>, key: int) returns (result: nat)\n    requires BinarySearchPrecond(a, key)\n    ensures result <= a.Length\n    ensures forall i :: 0 <= i < result ==> a[i] < key\n    ensures forall i :: result <= i < a.Length ==> a[i] >= key", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0132", "language": "dafny", "source": "verina", "source_id": "verina_basic_52_task", "vc-description": "/*\nThis task requires developing a solution that sorts an array of integers in non-decreasing order. The solution must return an array that is a rearrangement of the input, containing exactly the same elements but ordered from smallest to largest.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. This array can be empty or non-empty.\n\n-----Output-----\nThe output is an array of integers that:\n• Is sorted in non-decreasing order (i.e., for any indices i and j with i < j, a[i]! ≤ a[j]!).\n• Has the same size as the input array.\n• Contains exactly the same elements as the input array, ensuring that the multiset of elements is preserved.\n\n-----Note-----\nThe implementation uses helper functions for swapping elements and performing inner and outer loops of the bubble sort algorithm. No additional preconditions are required as the function should correctly handle empty and non-empty arrays.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method BubbleSort(a: seq<int>) returns (result: seq<int>)\n    ensures |result| == |a|\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]\n    ensures multiset(a) == multiset(result)", "vc-code": "{\n    assume {:axiom} false;\n    result := a;\n}", "vc-postamble": ""}
{"id": "DV0135", "language": "dafny", "source": "verina", "source_id": "verina_basic_55_task", "vc-description": "/*\nThis task involves determining whether two integer values are equal. The goal is simply to compare the two provided numbers and indicate with a Boolean result whether they are the same.\n\n-----Input-----\nThe input consists of two elements:\n• a: An element of type Int.\n• b: An element of type Int.\n\n-----Output-----\nThe output is a Boolean:\n• Returns true if a equals b.\n• Returns false if a does not equal b.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method compare(a: int, b: int) returns (result: bool)\n    ensures\n        (a == b ==> result == true) && (a != b ==> result == false)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0136", "language": "dafny", "source": "verina", "source_id": "verina_basic_56_task", "vc-description": "/*\nThe problem is to update a destination array by replacing a specific segment with values taken from a source array. Given two arrays, starting positions, and a length, the task is to construct a new array where the segment in the destination from the specified starting index for the given length is replaced by the corresponding segment from the source, while all other elements remain unchanged.\n\nInput:\nThe input consists of:\n• src: An array of integers representing the source array.\n• sStart: A natural number indicating the starting index in src from where to begin copying.\n• dest: An array of integers representing the destination array.\n• dStart: A natural number indicating the starting index in dest where the segment will be replaced.\n• len: A natural number specifying the number of elements to copy.\n\nOutput:\nThe output is an array of integers that:\n• Has the same size as the destination array (dest).\n• Preserves the original elements of dest except for the segment starting at index dStart of length len, which is replaced by the corresponding segment from src.\n• Under the preconditions that src.size ≥ sStart + len and dest.size ≥ dStart + len, guarantees that:\n  - All elements with indices less than dStart remain as in dest.\n  - All elements with indices greater than or equal to dStart + len remain as in dest.\n  - For each index i with 0 ≤ i < len, the element at index dStart + i in the output equals the element at index sStart + i in src.\n\nNote:\nIt is assumed that the input arrays satisfy the preconditions: the source array has enough elements starting from sStart and the destination array has enough space starting from dStart to accommodate the copied segment.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Copy(src: seq<int>, s_start: nat, dest: seq<int>, d_start: nat, len: nat) returns (result: seq<int>)\n    requires \n        |src| >= s_start + len\n    requires\n        |dest| >= d_start + len\n    ensures\n        |result| == |dest|\n    ensures\n        forall i :: 0 <= i < d_start ==> result[i] == dest[i]\n    ensures\n        forall i :: d_start + len <= i < |result| ==> result[i] == dest[i]\n    ensures\n        forall i {:trigger result[d_start + i]} :: 0 <= i < len ==> result[d_start + i] == src[s_start + i]", "vc-code": "{\n    assume {:axiom} false;\n    result := [];\n}", "vc-postamble": ""}
{"id": "DV0137", "language": "dafny", "source": "verina", "source_id": "verina_basic_57_task", "vc-description": "/*\nThis task involves determining how many numbers within an array are less than a specified threshold. The problem is focused on identifying and counting such numbers based purely on their value in relation to the threshold.\n\n-----Input-----\nThe input consists of:\n• numbers: An array of integers (which may be empty or non-empty).\n• threshold: An integer that serves as the comparison threshold.\n\n-----Output-----\nThe output is a natural number (Nat) representing the count of elements in the array that are less than the given threshold.\n\n-----Note-----\nThere are no additional preconditions; the function should work correctly for any array of integers and any integer threshold.\n*/", "vc-preamble": "/* Helper function to recursively count elements less than threshold */\nfunction CountLessThanSpec(numbers: seq<int>, threshold: int): nat\n    decreases |numbers|\n{\n    if |numbers| == 0 then\n        0\n    else\n        var first := numbers[0];\n        var rest := numbers[1..];\n        if first < threshold then\n            1 + CountLessThanSpec(rest, threshold)\n        else\n            CountLessThanSpec(rest, threshold)\n}", "vc-helpers": "", "vc-spec": "method CountLessThan(numbers: array<int>, threshold: int) returns (result: nat)\n    ensures result == CountLessThanSpec(numbers[..], threshold)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0138", "language": "dafny", "source": "verina", "source_id": "verina_basic_58_task", "vc-description": "/*\nThis task involves transforming an array of integers by doubling each element.\n\n-----Input-----\nThe input consists of:\n• s: An array of integers.\n\n-----Output-----\nThe output is an array of integers where for each valid index i, the element at position i is equal to twice the corresponding element in the input array.\n\n-----Note-----\nThe implementation makes use of a recursive helper function to update the array in place. It is assumed that the input array is valid and that the doubling operation does not lead to any overflow issues.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method DoubleArrayElements(s: seq<int>) returns (result: seq<int>)\n    ensures |result| == |s|\n    ensures forall i :: 0 <= i < |s| ==> result[i] == 2 * s[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0139", "language": "dafny", "source": "verina", "source_id": "verina_basic_59_task", "vc-description": "/*\nGiven an integer x, determine a pair (a, b) where the first element is twice the value of x and the second element is four times the value of x.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is a tuple (a, b) where:\n• a = 2 * x\n• b = 4 * x\n\n-----Note-----\nThere are no additional preconditions; the method is defined for all integers.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method DoubleQuadruple(x: int) returns (result: (int, int))\n    ensures result.0 == 2 * x\n    ensures result.1 == 2 * result.0", "vc-code": "{\n    // impl-start\n    result := (2 * x, 4 * x);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0140", "language": "dafny", "source": "verina", "source_id": "verina_basic_60_task", "vc-description": "/*\nThis task requires writing a function that processes an array of integers and produces a new array containing only the even numbers from the input. The order of these even numbers should remain the same as in the original array, ensuring that every even number from the input appears in the output and that every element in the output is even.\n\n-----Input-----\nThe input consists of one parameter:\n• arr: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n• Contains exactly all even numbers from the input array, preserving their original order.\n• Meets the specified conditions that ensure no extraneous (odd or non-existing) elements are returned.\n\n-----Note-----\nThere are no additional preconditions. The function must adhere to the provided specification which enforces evenness and order preservation for the elements in the output array.\n*/", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "", "vc-spec": "method FindEvenNumbers(arr: array<int>) returns (result: array<int>)\n    ensures forall i :: 0 <= i < result.Length ==> IsEven(result[i])\n    ensures forall i :: 0 <= i < result.Length ==> exists j :: 0 <= j < arr.Length && result[i] == arr[j]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0142", "language": "dafny", "source": "verina", "source_id": "verina_basic_62_task", "vc-description": "/*\nThe problem involves finding the first occurrence of a specified key in an array of integers. Your task is to identify the index at which the key appears for the first time in the array and return that index. If the key is not found, return -1.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• key: An integer representing the value to search for in the array.\n\n-----Output-----\nThe output is an integer which represents:\n• The index in the array where the key is found, provided that the index is in the range [0, a.size).\n• -1 if the key is not present in the array.\nIn addition, if the output is not -1, then a[(Int.toNat result)]! equals key and every element in the array prior to this index is not equal to key.\n\n-----Note-----\nThe function performs a linear search beginning at index 0 and returns the first occurrence of the key. There are no additional preconditions on the input array; it can be empty or non-empty.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Find(a: array<int>, key: int) returns (result: int)\n    ensures\n        (result == -1 || (result >= 0 && result < a.Length)) &&\n        (result != -1 ==> (a[result] == key && forall i :: 0 <= i < result ==> a[i] != key)) &&\n        (result == -1 ==> forall i :: 0 <= i < a.Length ==> a[i] != key)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0143", "language": "dafny", "source": "verina", "source_id": "verina_basic_63_task", "vc-description": "/*\nThe task is to determine whether there exists at least one pair of different floating-point numbers in a list such that the absolute difference between them is less than a given threshold. The focus is solely on deciding if such a pair is present in the list.\n\nInput:\nThe input consists of:\n• numbers: A list of floating-point numbers.\n• threshold: A floating-point number representing the maximum allowed difference between two numbers for them to be considered \"close.\"\n\nOutput:\nThe output is a boolean value:\n• true – if there exists at least one pair of distinct elements in the list such that the absolute difference between them is less than the threshold.\n• false – if for every possible pair of elements, the absolute difference is greater than or equal to the threshold.\n\nNote:\nIt is assumed that the list of numbers is provided and that the threshold is non-negative.\n*/", "vc-preamble": "function AbsDiff(a: int, b: int): int\n{\n    if a >= b then a - b else b - a\n}", "vc-helpers": "", "vc-spec": "method HasCloseElements(numbers: array<int>, threshold: int) returns (result: bool)\n    requires threshold >= 0\n    ensures\n        !result <==> (forall i: int, j: int :: \n            0 <= i < numbers.Length && 0 <= j < numbers.Length && i != j ==> \n            AbsDiff(numbers[i], numbers[j]) >= threshold)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0144", "language": "dafny", "source": "verina", "source_id": "verina_basic_64_task", "vc-description": "/*\nThis task requires writing a Dafny method that inserts a subarray of characters into another array of characters at a specified index. The method takes the original array (oline) and, given the effective length l to consider, inserts another array of characters (nl) of effective length p starting at the index atPos. The resulting array is of length l + p and is constructed as follows:\n• All characters before the insertion position (atPos) remain unchanged.\n• The new characters from nl are inserted starting at index atPos.\n• The remaining characters from the original array (starting at atPos) are shifted right by p positions.\n\n-----Input-----\nThe input consists of:\n• oline: An array of characters representing the original sequence.\n• l: A natural number indicating how many characters from oline to consider.\n• nl: An array of characters to be inserted into oline.\n• p: A natural number indicating how many characters from nl to consider for insertion.\n• atPos: A natural number indicating the position in oline where the insertion should occur (0-indexed).\n\n-----Output-----\nThe output is an array of characters that is the result of inserting nl into oline at the given atPos. Specifically, the output array should:\n• Contain the original characters from index 0 up to (but not including) atPos.\n• Have the next p characters equal to the characters from nl.\n• Contain the remaining characters from oline (starting from atPos) shifted right by p positions.\n\n-----Note-----\nIt is assumed that:\n• atPos is within the range [0, l].\n• l does not exceed the size of oline.\n• p does not exceed the size of nl.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Insert(oline: seq<char>, l: int, nl: seq<char>, p: int, atPos: int) returns (result: seq<char>)\n    requires l <= |oline|\n    requires p <= |nl|\n    requires atPos <= l\n    requires l >= 0\n    requires p >= 0\n    requires atPos >= 0\n    ensures |result| == l + p\n    ensures forall i :: 0 <= i < p ==> result[atPos + i] == nl[i]\n    ensures forall i :: 0 <= i < atPos ==> result[i] == oline[i]\n    ensures forall i {:trigger result[atPos + p + i]} :: 0 <= i < (l - atPos) ==> result[atPos + p + i] == oline[atPos + i]", "vc-code": "{\n    assume {:axiom} false;\n    result := [];\n}", "vc-postamble": ""}
{"id": "DV0145", "language": "dafny", "source": "verina", "source_id": "verina_basic_65_task", "vc-description": "/*\nThis task involves computing the integer square root of a given natural number. The goal is to determine the largest natural number r that satisfies r * r ≤ N and N < (r + 1) * (r + 1).\n\n-----Input-----\nThe input consists of:\n• N: A natural number.\n\n-----Output-----\nThe output is a natural number r that meets the following conditions:\n• r * r ≤ N\n• N < (r + 1) * (r + 1)\n\n-----Note-----\nThe implementation relies on a recursive strategy to iteratively increment r until (r + 1)*(r + 1) exceeds N. Edge cases, such as N = 0, should be handled correctly.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SquareRoot(n: nat) returns (result: nat)\n    ensures result * result <= n\n    ensures n < (result + 1) * (result + 1)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0146", "language": "dafny", "source": "verina", "source_id": "verina_basic_66_task", "vc-description": "/*\nThis task focuses on determining if a given integer is even. The problem requires checking whether the integer can be represented as twice another integer, meaning it is divisible by 2 without any remainder.\n\n-----Input-----\nThe input consists of a single integer:\n• x: An integer to be evaluated.\n\n-----Output-----\nThe output is a boolean value:\n• true if x is even (x mod 2 equals 0).\n• false if x is odd.\n\n-----Note-----\nNo additional preconditions are required. The method should work correctly for any integer value.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ComputeIsEven(x: int) returns (result: bool)\n    ensures result == true <==> x % 2 == 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0147", "language": "dafny", "source": "verina", "source_id": "verina_basic_67_task", "vc-description": "/*\nThis task requires determining whether a given list of characters is a palindrome; that is, whether the sequence reads the same forward and backward.\n\n-----Input-----\nThe input consists of:\n• x: A list of characters (List Char). The list can be empty or non-empty.\n\n-----Output-----\nThe output is a Boolean value (Bool):\n• Returns true if the input list is a palindrome.\n• Returns false otherwise.\n\n-----Note-----\nAn empty list is considered a palindrome. The function does not impose any additional preconditions.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IsPalindrome(x: seq<char>) returns (result: bool)\n    ensures\n        result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - 1 - i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0148", "language": "dafny", "source": "verina", "source_id": "verina_basic_68_task", "vc-description": "/*\nThe task is to determine the position of a target integer in a given array. The goal is to return the index corresponding to the first occurrence of the target value. If the target is not present in the array, the result should indicate that by returning the size of the array. This description focuses entirely on understanding the problem without specifying any particular implementation method.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• e: An integer representing the target to search for in the array.\n\n-----Output-----\nThe output is a natural number (Nat) which is:\n• The index of the first occurrence of the target integer if found.\n• The size of the array if the target integer is not present.\n\n-----Note-----\nThere are no strict preconditions on the input; the method should work correctly for any array of integers. The specification ensures that the returned index is always valid: it is either within the array bounds with a matching element or equals the array's size if the element is absent.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LinearSearch(a: array<int>, e: int) returns (result: nat)\n    ensures result <= a.Length\n    ensures result == a.Length || a[result] == e\n    ensures forall i :: 0 <= i < result ==> a[i] != e", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0149", "language": "dafny", "source": "verina", "source_id": "verina_basic_69_task", "vc-description": "/*\nThis problem involves determining the index of the first occurrence of a specified element within an array of integers. The objective is to identify the correct position where the target element appears for the first time, ensuring that all elements prior to that index are different from the target.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• e: An integer representing the element to search for.\n\n-----Output-----\nThe output is a natural number (nat) representing the index of the first occurrence of e in the array.\n• If the element e exists in the array, the index n will satisfy the conditions specified above.\n\n-----Note-----\nIt is assumed that the input satisfies the precondition where at least one index i in a exists such that a[i] = e.\nThe implementation uses a helper function to iterate through the array recursively.\n*/", "vc-preamble": "method LinearSearchAux(a: array<int>, e: int, n: nat) returns (result: nat)\n    requires n <= a.Length\n    decreases a.Length - n\n{\n    if n < a.Length {\n        if a[n] == e {\n            result := n;\n        } else {\n            result := LinearSearchAux(a, e, n + 1);\n        }\n    } else {\n        result := 0;\n    }\n}", "vc-helpers": "", "vc-spec": "method LinearSearch(a: array<int>, e: int) returns (result: nat)\n    requires exists i :: 0 <= i < a.Length && a[i] == e\n    ensures result < a.Length\n    ensures a[result] == e\n    ensures forall k :: 0 <= k < result ==> a[k] != e", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0150", "language": "dafny", "source": "verina", "source_id": "verina_basic_70_task", "vc-description": "/*\nThis task involves determining the first index in an array where a given condition holds true. The goal is to identify the position of the first element that meets a specified criterion, ensuring that no preceding element does.\n\n-----Input-----\nThe input consists of:\n• a: An array of elements (for testing purposes, you can assume it is an array of integers).\n• P: A predicate function on the elements (represented as a string for test cases, e.g., \"fun x => x > 5\"). It is assumed that at least one element in the array satisfies P.\n\n-----Output-----\nThe output is a natural number (Nat) which represents the index of the first element in the array that satisfies the predicate P.\n• The index returned is less than the size of the array.\n• The element at the returned index satisfies P.\n• All elements before the returned index do not satisfy P.\n\n-----Note-----\nIt is assumed that the array contains at least one element that satisfies P. In cases where this precondition does not hold, the behavior of the function is not guaranteed by the specification.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LinearSearch3(a: seq<int>, p: int -> bool) returns (result: nat)\n    requires \n        exists i :: 0 <= i < |a| && p(a[i])\n    ensures \n        result < |a| &&\n        p(a[result]) &&\n        forall k :: 0 <= k < result ==> !p(a[k])", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0151", "language": "dafny", "source": "verina", "source_id": "verina_basic_71_task", "vc-description": "/*\nThis problem involves determining the longest common prefix shared by two lists of characters. Given two sequences, the goal is to identify and return the maximal contiguous sequence of characters from the beginning of both lists that are identical.\n\n-----Input-----\nThe input consists of:\n• str1: A list of characters.\n• str2: A list of characters.\n\n-----Output-----\nThe output is a list of characters representing the longest common prefix of the two input lists. The output list satisfies the following conditions:\n• Its length is less than or equal to the length of each input list.\n• It is exactly the prefix of both str1 and str2.\n• It is empty if the first characters of the inputs differ or if one of the lists is empty.\n\n-----Note-----\nIt is assumed that both inputs are provided as valid lists of characters. The function always returns the correct longest common prefix based on the inputs.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LongestCommonPrefix(str1: array<char>, str2: array<char>) returns (result: array<char>)\n    ensures\n        result.Length <= str1.Length &&\n        result.Length <= str2.Length &&\n        (forall i :: 0 <= i < result.Length ==> result[i] == str1[i] && result[i] == str2[i]) &&\n        (result.Length == str1.Length || result.Length == str2.Length || \n            (result.Length < str1.Length && result.Length < str2.Length && str1[result.Length] != str2[result.Length]))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new char[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0152", "language": "dafny", "source": "verina", "source_id": "verina_basic_72_task", "vc-description": "/*\n-----Description-----\nThe problem asks you to construct a new list by adding an extra number to the end of an existing list of numbers. The focus is on understanding what the final list should look like when a given number is included as the last element.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• b: An integer to be appended to the array.\n\n-----Output-----\nThe output is an array of integers which represents the original array with the element b added at the end. That is, the output array's list representation equals a.toList concatenated with [b].\n\n-----Note-----\nThere are no special preconditions; the method is expected to work correctly for any array of integers and any integer b.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Append(a: array<int>, b: int) returns (result: array<int>)\n    ensures result.Length == a.Length + 1\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == a[i]\n    ensures result[a.Length] == b", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0153", "language": "dafny", "source": "verina", "source_id": "verina_basic_73_task", "vc-description": "/*\nDetermine whether two strings match based on a specific pattern: for each position in the strings, either the characters are the same, or the character in p is a wildcard represented by a question mark '?' that may match any character.\n\n-----Input-----\nThe input consists of:\n• s: A string that is to be matched.\n• p: A pattern string of equal length, where each character is either a specific character or the wildcard '?'.\n\n-----Output-----\nThe output is a Boolean value:\n• Returns true if the length of s is equal to the length of p and each corresponding character in s and p are either identical or the character in p is a '?'.\n• Returns false if any character in s does not match the corresponding character in p and the character in p is not a '?'.\n\n-----Note-----\nIt is assumed that both strings provided have the same length.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MatchStrings(s: string, p: string) returns (result: bool)\n    requires |s| == |p|\n    ensures result == (forall n :: 0 <= n < |s| ==> \n        (s[n] == p[n] || p[n] == '?'))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0154", "language": "dafny", "source": "verina", "source_id": "verina_basic_74_task", "vc-description": "/*\nThis task involves identifying the maximum value in a non-empty array of integers. The objective is to determine which element in the array is greater than or equal to every other element, ensuring that the selected value is one of the elements in the array.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. It is assumed that the array is non-empty (i.e., its size is at least 1).\n\n-----Output-----\nThe output is an integer that represents the maximum element in the array. This value is guaranteed to satisfy the following:\n• It is greater than or equal to every element in the array.\n• It is exactly equal to one of the elements in the array.\n\n-----Note-----\nIt is assumed that the provided array is non-empty. In cases where the array is empty, the function's behavior is not defined.\n*/", "vc-preamble": "predicate MaxArrayPrecond(a: array<int>)\n{\n    a.Length > 0\n}\nmethod MaxArrayAux(a: array<int>, index: int, current: int) returns (result: int)\n    requires 0 <= index <= a.Length\n    decreases a.Length - index\n{\n    if index < a.Length {\n        var new_current := if current > a[index] then current else a[index];\n        result := MaxArrayAux(a, index + 1, new_current);\n    } else {\n        result := current;\n    }\n}", "vc-helpers": "", "vc-spec": "method MaxArray(a: array<int>) returns (result: int)\n    requires MaxArrayPrecond(a)\n    ensures forall k :: 0 <= k < a.Length ==> result >= a[k]\n    ensures exists k :: 0 <= k < a.Length && result == a[k]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0155", "language": "dafny", "source": "verina", "source_id": "verina_basic_75_task", "vc-description": "/*\nThis task involves finding the minimum element in a non-empty array of integers. The goal is to identify and return the smallest number present in the array.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (the array is assumed to be non-empty).\n\n-----Output-----\nThe output is an integer that:\n• Is the smallest element from the input array.\n• Satisfies the property that it is less than or equal to every element in the array and is exactly equal to at least one element of the array.\n\n-----Note-----\nIt is assumed that the input array contains at least one element. The implementation uses a helper function (loop) to recursively compare elements and determine the minimum value.\n*/", "vc-preamble": "function LoopSpec(a: array<int>, i: int, currentMin: int): int\n    requires 0 <= i <= a.Length\n    decreases a.Length - i\n    reads a\n{\n    if i < a.Length then\n        var newMin := if currentMin > a[i] then a[i] else currentMin;\n        LoopSpec(a, i + 1, newMin)\n    else\n        currentMin\n}", "vc-helpers": "", "vc-spec": "method MinArray(a: array<int>) returns (result: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> result <= a[i]\n    ensures exists i :: 0 <= i < a.Length && result == a[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0156", "language": "dafny", "source": "verina", "source_id": "verina_basic_76_task", "vc-description": "/*\nThis task requires determining the smaller of two integers. Given two input numbers, the goal is to compare them and return the one that is less than or equal to the other.\n\n-----Input-----\nThe input consists of two integers:\n• x: The first integer.\n• y: The second integer.\n\n-----Output-----\nThe output is an integer representing the minimum of the two input integers:\n• Returns x if x is less than or equal to y.\n• Returns y if x is greater than y.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MyMin(x: int, y: int) returns (result: int)\n    ensures (x <= y ==> result == x) && (x > y ==> result == y)", "vc-code": "{\n    // TODO: implement\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0157", "language": "dafny", "source": "verina", "source_id": "verina_basic_77_task", "vc-description": "/*\nThis task involves updating an element within a 2-dimensional array. The goal is to modify only a specific inner array by changing one of its elements to a new value while keeping every other element and all other inner arrays unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of arrays of natural numbers.\n• index1: A natural number representing the index in the outer array identifying which inner array to modify (0-indexed).\n• index2: A natural number representing the index within the selected inner array that should be updated (0-indexed).\n• val: A natural number which is the new value to set at the specified inner index.\n\n-----Output-----\nThe output is an array of arrays of natural numbers that:\n• Has the same overall structure as the input.\n• Contains all original inner arrays unchanged except for the inner array at position index1.\n• In the modified inner array, only the element at index2 is replaced with val, while all other elements remain the same.\n\n-----Note-----\nIt is assumed that index1 is a valid index for the outer array and that index2 is a valid index within the corresponding inner array.\n*/", "vc-preamble": "method UpdateInner(a: seq<nat>, idx: int, val: nat) returns (result: seq<nat>)\n    requires 0 <= idx < |a|\n    ensures |result| == |a|\n    ensures result[idx] == val\n    ensures forall i :: 0 <= i < |a| && i != idx ==> result[i] == a[i]\n{\n    result := a[idx := val];\n}", "vc-helpers": "", "vc-spec": "method ModifyArrayElement(arr: seq<seq<nat>>, index1: int, index2: int, val: nat) returns (result: seq<seq<nat>>)\n    requires 0 <= index1 < |arr|\n    requires 0 <= index2 < |arr[index1]|\n    ensures |result| == |arr|\n    ensures forall i :: 0 <= i < |arr| && i != index1 ==> result[i] == arr[i]\n    ensures |result[index1]| == |arr[index1]|\n    ensures forall j :: 0 <= j < |arr[index1]| && j != index2 ==> result[index1][j] == arr[index1][j]\n    ensures result[index1][index2] == val", "vc-code": "{\n    // impl-start\n    var updatedInner := UpdateInner(arr[index1], index2, val);\n    result := arr[index1 := updatedInner];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0158", "language": "dafny", "source": "verina", "source_id": "verina_basic_78_task", "vc-description": "/*\nGiven two integers, the task is to compute two output values: one being the sum of the integers and the other being their difference.\n\n-----Input-----\nThe input consists of two integers:\n• x: An integer.\n• y: An integer.\n\n-----Output-----\nThe output is a tuple of two integers:\n• The first element is x + y.\n• The second element is x - y.\n\n-----Note-----\nIt is assumed that x and y are valid integers. There are no additional constraints on the inputs.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method MultipleReturns(x: int, y: int) returns (result: (int, int))\n    ensures result.0 == x + y\n    ensures result.1 + y == x", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, 0);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0159", "language": "dafny", "source": "verina", "source_id": "verina_basic_79_task", "vc-description": "/*\nGiven a nonempty array of integers and a valid index x (with 1 ≤ x < array size), the task is to identify two key pieces of information. First, determine the maximum value among the first x elements of the array. Second, select an index p within the range [x, array size) that satisfies the following conditions: if there exists an element in the segment starting from index x that is strictly greater than the previously determined maximum, then p should be the index of the first such occurrence; otherwise, p should be set to the last index of the array. The focus of the problem is solely on correctly identifying the maximum and choosing the appropriate index based on these order conditions.\n\nInput:\nThe input consists of:\n• a: An array of integers (assumed to be nonempty).\n• x: A natural number (Nat) such that 1 ≤ x < a.size.\n\nOutput:\nThe output is a pair (m, p) where:\n• m is the maximum value among the first x elements of the array.\n• p is an index in the array, with x ≤ p < a.size, determined based on the ordering condition where a[p] is the first element (from index x onward) that is strictly greater than m. If no such element exists, then p is set to a.size − 1.\n\nNote:\nIt is assumed that the array a is nonempty and that the parameter x meets the precondition 1 ≤ x < a.size. The function relies on helper functions to compute the maximum among the first x elements and to select the appropriate index p based on the given conditions.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method OnlineMax(a: array<int>, x: int) returns (result: (int, int))\n    requires\n        a.Length > 0 &&\n        x < a.Length\n    ensures\n        var (m, p) := result;\n        x <= p && p < a.Length &&\n        (forall i :: 0 <= i < x ==> a[i] <= m) &&\n        (exists i :: 0 <= i < x && a[i] == m) &&\n        ((p < a.Length - 1) ==> (exists i :: x <= i <= p && a[i] > m)) &&\n        ((forall i :: x <= i < a.Length ==> a[i] <= m) ==> p == a.Length - 1)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, x);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0160", "language": "dafny", "source": "verina", "source_id": "verina_basic_80_task", "vc-description": "/*\nThis task involves determining whether a specified key appears exactly once in an array. The goal is to verify the uniqueness of the key's occurrence without prescribing any specific approach or implementation method.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• key: An integer representing the element whose occurrence is to be checked.\n\n-----Output-----\nThe output is a Boolean value that:\n• Is true if the key appears exactly once in the array.\n• Is false otherwise.\n\n-----Note-----\nThe function should correctly handle arrays with no occurrences of the key, multiple occurrences, and exactly one occurrence.\n*/", "vc-preamble": "function CountOccurrences(a: seq<int>, key: int): nat\n{\n    |set i | 0 <= i < |a| && a[i] == key|\n}", "vc-helpers": "", "vc-spec": "method OnlyOnce(a: array<int>, key: int) returns (result: bool)\n    ensures result <==> CountOccurrences(a[..], key) == 1", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := false;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0162", "language": "dafny", "source": "verina", "source_id": "verina_basic_82_task", "vc-description": "/*\nThis task is about processing an array of integers by producing a new array that excludes the first element. The objective is to define a clear behavior: if the array contains at least one element, return a modified array starting from the second element.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n\n-----Output-----\nThe output is an array of integers that:\n• Has a length equal to the original array's length minus one.\n• Contains the same elements as the input array except for the first element.\n• Satisfies the condition that for every index i in the output array, the element at position i is equal to the element at position i+1 in the input array.\n\n-----Note-----\nIt is assumed that the input array is non-empty.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method RemoveFront(a: seq<int>) returns (result: seq<int>)\n    requires |a| > 0\n    ensures |a| > 0\n    ensures |result| == |a| - 1\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i + 1]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0163", "language": "dafny", "source": "verina", "source_id": "verina_basic_83_task", "vc-description": "/*\nThis task involves concatenating two arrays of integers by appending the second array to the end of the first array. The goal is to produce a new array that sequentially contains all elements from the first array followed by all elements from the second array.\n\n-----Input-----\nThe input consists of two parameters:\n• a: An Array of integers representing the first part of the concatenated array.\n• b: An Array of integers representing the second part of the concatenated array.\n\n-----Output-----\nThe output is an Array of integers that satisfies the following:\n• The length of the output array is equal to the sum of the lengths of arrays a and b.\n• The first part of the output array (indices 0 to a.size - 1) is identical to array a.\n• The remaining part of the output array (indices a.size to a.size + b.size - 1) is identical to array b.\n\n-----Note-----\nNo additional preconditions are required since the function uses the sizes of the input arrays to build the resulting array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Concat(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    ensures |result| == |a| + |b|\n    ensures forall k :: 0 <= k < |a| ==> result[k] == a[k]\n    ensures forall k :: 0 <= k < |b| ==> result[k + |a|] == b[k]", "vc-code": "{\n    assume {:axiom} false;\n    result := a + b;\n}", "vc-postamble": ""}
{"id": "DV0164", "language": "dafny", "source": "verina", "source_id": "verina_basic_84_task", "vc-description": "/*\nYou are given an array of integers and a threshold value k. The problem is to create a new array where every element greater than k is replaced with -1 while every other element remains unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of integers.\n• k: An integer used as the threshold for replacement.\n\n-----Output-----\nThe output is an array of integers that satisfies the following conditions:\n• For every index i, if arr[i] is greater than k, then the returned array at index i is -1.\n• For every index i, if arr[i] is less than or equal to k, then the returned array at index i remains unchanged.\n\n-----Note-----\nIt is assumed that the input array may be empty or non-empty, and that k can be any integer. There are no additional preconditions.\n*/", "vc-preamble": "/* Helper function to process the replacement loop */\nfunction ReplaceLoopSpec(oldArr: seq<int>, k: int, i: nat, acc: seq<int>): seq<int>", "vc-helpers": "", "vc-spec": "method Replace(arr: seq<int>, k: int) returns (result: seq<int>)\n    ensures\n        |result| == |arr| &&\n        (forall i :: 0 <= i < |arr| ==> (arr[i] > k ==> result[i] == -1)) &&\n        (forall i :: 0 <= i < |arr| ==> (arr[i] <= k ==> result[i] == arr[i]))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0165", "language": "dafny", "source": "verina", "source_id": "verina_basic_85_task", "vc-description": "/*\nThis problem focuses on reversing an array of integers. The goal is to take an input array and produce a new array with the elements arranged in the reverse order.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers, which may be empty, contain one element, or many elements.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input array.\n• Contains the same elements as the input array, but in reverse order.\n• For every valid index i in the input array, the output at index i is equal to the element at index (a.size - 1 - i) from the input array.\n\n-----Note-----\nThere are no specific preconditions; the method should correctly handle any array of integers.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Reverse(a: array<int>) returns (result: array<int>)\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == a[a.Length - 1 - i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0166", "language": "dafny", "source": "verina", "source_id": "verina_basic_86_task", "vc-description": "/*\nThis task requires writing a Dafny method that rotates an array of integers to the left by a specified offset.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers (which may be empty or non-empty).\n• offset: An integer representing the number of positions to rotate the array. The offset is assumed to be non-negative.\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input array.\n• For every valid index i, the output element at index i is equal to the input element at index ((i + offset) mod n), where n is the array size.\n\n-----Note-----\nIf the array is empty, the method should return an empty array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method rotate(a: array<int>, offset: int) returns (result: array<int>)\n    requires offset >= 0\n    ensures result.Length == a.Length\n    ensures a.Length == 0 ==> result.Length == 0\n    ensures a.Length > 0 ==> forall i :: 0 <= i < a.Length ==> \n        result[i] == a[(i + offset) % a.Length]", "vc-code": "{\n    result := new int[a.Length];\n    if a.Length > 0 {\n        var j := 0;\n        while j < a.Length\n            invariant 0 <= j <= a.Length\n            invariant forall k :: 0 <= k < j ==> result[k] == a[(k + offset) % a.Length]\n        {\n            var srcIdx := (j + offset) % a.Length;\n            result[j] := a[srcIdx];\n            j := j + 1;\n        }\n    }\n}", "vc-postamble": ""}
{"id": "DV0167", "language": "dafny", "source": "verina", "source_id": "verina_basic_87_task", "vc-description": "/*\nThis problem requires sorting an array of integers into non-decreasing order, ensuring that the output contains exactly the same elements as the input (i.e., it is a permutation of the original array).\n\nInput: The input consists of an array of integers (array<int>).\n\nOutput: The output is an array of integers that is:\n• Sorted in non-decreasing order.\n• A permutation of the input, meaning it contains exactly the same elements (with the same multiplicities) as the original array.\n\nNote: It is assumed that the input array is valid and that the swap operations, along with the helper functions, correctly implement the selection sort algorithm.\n*/", "vc-preamble": "method FindMinIndexInRange(arr: array<int>, start: int, finish: int) returns (result: int)\n    requires \n        start <= finish &&\n        finish <= arr.Length &&\n        start < arr.Length\n    ensures\n        start <= result < finish\n{\n    // impl-start\n    assume {:axiom} false;\n    result := start;\n    // impl-end\n}\n\nmethod Swap(a: array<int>, i: int, j: int)\n    requires\n        a.Length > 0 &&\n        0 <= i < a.Length &&\n        0 <= j < a.Length\n    modifies a\n    ensures\n        a.Length == old(a.Length) &&\n        (0 <= i < a.Length && 0 <= j < a.Length ==> a[i] == old(a[j])) &&\n        (0 <= i < a.Length && 0 <= j < a.Length ==> a[j] == old(a[i])) &&\n        forall k :: 0 <= k < a.Length && k != i && k != j ==> a[k] == old(a[k])\n{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-helpers": "", "vc-spec": "method SelectionSort(a: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == a.Length &&\n        (forall i, j :: 0 <= i <= j < result.Length ==> result[i] <= result[j]) &&\n        multiset(result[..]) == multiset(a[..])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0168", "language": "dafny", "source": "verina", "source_id": "verina_basic_88_task", "vc-description": "/*\nThis task involves converting a list of integers into an array such that the array contains all the elements of the list in the exact same order. The objective is to ensure that the array has the same number of elements as the list and that each element in the array corresponds exactly to the element at the same position in the list.\n\nInput:\nThe input consists of:\n• xs: A list of integer elements.\n\nOutput:\nThe output is an array of elements of type integer that:\n• Has a size equal to the length of the input list xs.\n• Contains all the elements from xs in the same order, ensuring that for every valid index i, the array element at i is equal to the list element at i.\n\nNote:\nThere are no additional preconditions; the method should work correctly for any list of elements.\nA corresponding specification is provided stating that the array's size equals the list's length and that each element is preserved.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ToArray(xs: seq<int>) returns (result: array<int>)\n    ensures\n        result.Length == |xs| &&\n        forall i :: 0 <= i < |xs| ==> result[i] == xs[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[|xs|];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0169", "language": "dafny", "source": "verina", "source_id": "verina_basic_89_task", "vc-description": "/*\nThis problem asks you to design a solution that transforms a list with possible duplicate entries into a new list where each element appears only once, maintaining the order of its first occurrence.\n\n-----Input-----\nThe input consists of:\n• s: A list of integers (or any type supporting decidable equality) that may contain duplicate elements.\n\n-----Output-----\nThe output is a list of integers (or the original type) in which every duplicate element is removed. The order of elements is preserved based on their first appearance in the input list, ensuring that the set of elements in the output is identical to the set in the input.\n\n-----Note-----\nNo additional preconditions are required. The method should correctly handle any list, including an empty list.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SetToSeq(s: seq<int>) returns (result: seq<int>)\n    ensures\n        // All elements are unique in the result  \n        forall i: int, j: int :: 0 <= i < j < |result| ==> result[i] != result[j]\n    ensures\n        // Every element in result is in s\n        forall i: int :: 0 <= i < |result| ==> \n            exists j: int :: 0 <= j < |s| && s[j] == result[i]\n    ensures\n        // Every element in s is in result\n        forall i: int :: 0 <= i < |s| ==> \n            exists j: int :: 0 <= j < |result| && result[j] == s[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0170", "language": "dafny", "source": "verina", "source_id": "verina_basic_90_task", "vc-description": "/*\nThe task is to search for a specific integer in a 2D array where the rows and columns are sorted in non-decreasing order. The goal is to locate the key and return its position as row and column indices, or return (-1, -1) if the algorithm fails to find the key.\n\n-----Input-----\nThe input consists of:\n• a: A non-empty 2D array of integers (seq<seq<int>>). The array is guaranteed to contain at least one element.\n• key: An integer value (int) to search for in the array.\n\n-----Output-----\nThe output is a pair of integers (int, int):\n• If the key is found, the first element represents the row index and the second element represents the column index such that get2d a row col = key.\n• If the key is not found, the function returns (-1, -1).\n\n-----Note-----\nIt is assumed that the input 2D array is sorted by rows and columns.\n*/", "vc-preamble": "predicate SlopeSearchPrecond(a: seq<seq<int>>, key: int)\n{\n    |a| > 0 &&\n    (forall i :: 0 <= i < |a| ==> |a[i]| == |a[0]|) &&\n    (forall i, j :: 0 <= i < |a| && 0 <= j < |a[i]| - 1 ==> a[i][j] <= a[i][j + 1]) &&\n    (forall j, i {:trigger a[i][j]} :: 0 <= j < |a[0]| && 0 <= i < |a| - 1 ==> a[i][j] <= a[i + 1][j])\n}\nfunction Get2d(a: seq<seq<int>>, i: int, j: int): int\n    requires 0 <= i < |a|\n    requires 0 <= j < |a[i]|\n{\n    a[i][j]\n}", "vc-helpers": "", "vc-spec": "method SlopeSearch(a: seq<seq<int>>, key: int) returns (result: (int, int))\n    requires SlopeSearchPrecond(a, key)\n    ensures\n        var (m, n) := result;\n        ((m >= 0 && m < |a| && n >= 0 && n < |a[0]| && a[m][n] == key) ||\n         (m == -1 && n == -1 && forall i, j :: 0 <= i < |a| && 0 <= j < |a[i]| ==> a[i][j] != key))", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (-1, -1);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0171", "language": "dafny", "source": "verina", "source_id": "verina_basic_91_task", "vc-description": "/*\nThis task involves creating a function that swaps two integer values. Given two integers, the function should return a pair where the first element is the second input value and the second element is the first input value.\n\n-----Input-----\nThe input consists of two integers:\n• X: An integer representing the first value.\n• Y: An integer representing the second value.\n\n-----Output-----\nThe output is a pair (int, int) that:\n• Contains the original Y as the first element.\n• Contains the original X as the second element.\n\n-----Note-----\nThere are no additional preconditions. The function simply swaps the two input values.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Swap(x: int, y: int) returns (result: (int, int))\n    ensures\n        result.0 == y &&\n        result.1 == x &&\n        (x != y ==> result.0 != x && result.1 != y)", "vc-code": "{\n    result := (y, x);\n}", "vc-postamble": ""}
{"id": "DV0172", "language": "dafny", "source": "verina", "source_id": "verina_basic_92_task", "vc-description": "/*\nThis problem involves swapping the values of two integers. Given two integers as inputs, the objective is to return the two numbers in reversed order.\n\n-----Input-----\nThe input consists of two integers:\n• X: The first integer.\n• Y: The second integer.\n\n-----Output-----\nThe output is a tuple of two integers (Int × Int) where:\n• The first element is equal to Y.\n• The second element is equal to X.\n\n-----Note-----\nThere are no restrictions on the input values. The function must correctly swap the inputs regardless of whether they are positive, negative, or zero.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SwapArithmetic(x: int, y: int) returns (result: (int, int))\n    ensures result.0 == y\n    ensures result.1 == x\n    ensures x != y ==> (result.0 != x && result.1 != y)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, 0);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0173", "language": "dafny", "source": "verina", "source_id": "verina_basic_93_task", "vc-description": "/*\nThis task requires swapping two 8-bit unsigned integers. Given two unsigned integer inputs, the goal is to produce an output pair where the first element is the original second input and the second element is the original first input. The problem focuses solely on exchanging the values without specifying any particular method to achieve the swap.\n\nInput:\nThe input consists of:\n• X: A u8 value.\n• Y: A u8 value.\n\nOutput:\nThe output is a pair of u8 values (newX, newY) where:\n• newX is equal to the original Y.\n• newY is equal to the original X.\n\nNote:\nThere are no additional preconditions; the function is meant to work correctly for any pair of u8 values by leveraging bitwise xor operations.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SwapBitvectors(x: int, y: int) returns (result: (int, int))\n    requires 0 <= x < 256 && 0 <= y < 256\n    ensures result.0 == y && result.1 == x\n    ensures x != y ==> (result.0 != x && result.1 != y)", "vc-code": "{\n    assume {:axiom} false;\n    return (0, 0);\n}", "vc-postamble": ""}
{"id": "DV0174", "language": "dafny", "source": "verina", "source_id": "verina_basic_94_task", "vc-description": "/*\nThis task involves taking an array as input and producing a new array that has the same size and identical elements in the same order as the input.\n\n-----Input-----\nThe input consists of:\n• s: An array of elements (for testing purposes, assume an array of integers, i.e., Array Int).\n\n-----Output-----\nThe output is an array of the same type as the input:\n• The output array has the same size as the input array.\n• Each element in the output array is identical to the corresponding element in the input array.\n\n-----Note-----\nThere are no special preconditions for the input array (it can be empty or non-empty); the function simply performs a straightforward copy operation on the array.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method IterCopy(s: array<int>) returns (result: array<int>)\n    ensures\n        s.Length == result.Length &&\n        forall i :: 0 <= i < s.Length ==> s[i] == result[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0175", "language": "dafny", "source": "verina", "source_id": "verina_basic_95_task", "vc-description": "/*\nThis problem involves swapping two elements in an array of integers at specified positions. Given an array and two indices, the task is to exchange these elements so that the element from the first index moves to the second index and vice versa, while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n• arr: An array of integers.\n• i: An integer representing the first index (0-indexed) whose element is to be swapped.\n• j: An integer representing the second index (0-indexed) whose element is to be swapped.\n\n-----Output-----\nThe output is an array of integers which:\n• Has the same size as the input array.\n• Contains the element originally at index i in position j and the element originally at index j in position i.\n• Leaves all other elements unchanged.\n\n-----Note-----\nIt is assumed that both indices i and j are non-negative and within the bounds of the array (i.e., i and j are less than arr.len()).\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method swap(arr: seq<int>, i: int, j: int) returns (result: seq<int>)\n    requires 0 <= i < |arr|\n    requires 0 <= j < |arr|\n    ensures |result| == |arr|\n    ensures result[i] == arr[j]\n    ensures result[j] == arr[i]\n    ensures forall k :: 0 <= k < |arr| && k != i && k != j ==> result[k] == arr[k]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0176", "language": "dafny", "source": "verina", "source_id": "verina_basic_96_task", "vc-description": "/*\nThis task requires swapping two integer values. Given two integers as input, the objective is to produce an output where their order is reversed: the first element of the output corresponds to the second input and the second element corresponds to the first input.\n\nInput:\nThe input consists of two integers:\n• X: An integer value.\n• Y: Another integer value.\n\nOutput:\nThe output is a tuple (int, int) where:\n• The first element is equal to Y.\n• The second element is equal to X.\n\nNote:\nThere are no additional preconditions for this task. The function simply returns a swapped tuple of its two input integers.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SwapSimultaneous(x: int, y: int) returns (result: (int, int))\n    ensures\n        result.0 == y &&\n        result.1 == x &&\n        (x != y ==> result.0 != x && result.1 != y)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, 0);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0177", "language": "dafny", "source": "verina", "source_id": "verina_basic_97_task", "vc-description": "/*\nThis task involves updating an array of integers such that the element at a specified index is set to 60 while all other elements remain unchanged.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers.\n• j: A natural number representing the index (0-indexed) to update. It is assumed that j is a valid index (j < a.size).\n\n-----Output-----\nThe output is an array of integers where:\n• The element at index j is set to 60.\n• All other elements remain the same as in the input array.\n\n-----Note-----\nIt is assumed that j is a valid index (0 ≤ j < a.size).\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TestArrayElements(a: seq<int>, j: nat) returns (result: seq<int>)\n    requires j < |a|\n    ensures |result| == |a|\n    ensures result[j] == 60\n    ensures forall k :: 0 <= k < |a| && k != j ==> result[k] == a[k]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := [];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0178", "language": "dafny", "source": "verina", "source_id": "verina_basic_98_task", "vc-description": "/*\nThis task involves computing three times a given integer. Given an integer, the goal is to produce a value that is exactly three times its value.\n\nInput:\nThe input consists of a single integer:\nx: An integer.\n\nOutput:\nThe output is an integer:\nReturns the product of the input integer and 3.\n\nNote:\nThere are no additional preconditions.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Triple(x: int) returns (result: int)\n    ensures result / 3 == x\n    ensures result / 3 * 3 == result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0179", "language": "dafny", "source": "verina", "source_id": "verina_basic_99_task", "vc-description": "/*\nThis task requires computing three times the given integer. The goal is to determine the product of the input integer and 3.\n\nThe input consists of:\n• x: An integer.\n\nThe output is an integer that represents three times the input value.\n\nThe implementation uses two different branches based on the value of x (i.e., x < 18 or x ≥ 18), but both branches guarantee that the result equals 3*x.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Triple(x: int) returns (result: int)\n    ensures result / 3 == x\n    ensures result / 3 * 3 == result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 0;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0180", "language": "dafny", "source": "verina", "source_id": "verina_basic_100_task", "vc-description": "/*\nThis task involves determining the triple of a given integer. The goal is to create a function that, for any integer provided as input, returns a value equal to three times that integer, including handling the case when the input is zero.\n\n-----Input-----\nThe input consists of:\n• x: An integer.\n\n-----Output-----\nThe output is an integer that represents three times the input integer.\n• If x = 0, the output will be 0.\n• Otherwise, the output will be computed as x + 2 * x, which is equivalent to 3 * x.\n\n-----Note-----\nThere are no additional preconditions. It is assumed that x is a valid integer.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Triple(x: int) returns (result: int)\n    ensures result == 3 * x", "vc-code": "{\n    // impl-start\n    result := 3 * x;\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0181", "language": "dafny", "source": "verina", "source_id": "verina_basic_101_task", "vc-description": "/*\nThis problem involves computing the triple of a given integer. The goal is to produce an output that is exactly three times the input value.\n\n-----Input-----\nThe input consists of:\n• x: An integer representing the value to be tripled.\n\n-----Output-----\nThe output is an integer that is three times the input value (i.e., 3 * x).\n\n-----Note-----\nThe implementation uses a local variable to first compute double the input and then adds the original input to get the final result. The accompanying theorem asserts that the function satisfies the specification of computing 3 * x.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method triple(x: int) returns (result: int)\n    ensures\n        result / 3 == x &&\n        result / 3 * 3 == result", "vc-code": "{\n    assume {:axiom} false;\n    result := 0;\n}", "vc-postamble": ""}
{"id": "DV0182", "language": "dafny", "source": "verina", "source_id": "verina_basic_102_task", "vc-description": "/*\nThis task involves identifying the first occurrence of a pair of indices in an array of integers such that the sum of the corresponding elements equals the given target value. The focus is on determining the earliest valid pair (i, j), with 0 ≤ i < j < nums.size, where the sum of the two numbers equals the target, without considering any language-specific or implementation details.\n\nInput:\nThe input consists of:\n• nums: An array of integers.\n• target: An integer representing the desired sum.\n\nOutput:\nThe output is a pair of natural numbers (i, j) that satisfy:\n• 0 ≤ i < j < nums.size.\n• nums[i] + nums[j] = target.\n• Any valid pair with indices preceding (i, j) does not yield the target sum, and no index between i and j forms a valid sum with nums[i].\n\nNote:\nIt is assumed that the array has at least two elements and that there exists at least one valid pair whose sum is equal to the target.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method TwoSum(nums: array<int>, target: int) returns (result: (int, int))\n    requires \n        nums.Length > 1 &&\n        (exists i: int, j: int :: 0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures\n        0 <= result.0 < result.1 < nums.Length &&\n        nums[result.0] + nums[result.1] == target &&\n        (forall i: int, j: int :: 0 <= i < j < nums.Length && i < result.0 ==> nums[i] + nums[j] != target)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := (0, 1);\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0183", "language": "dafny", "source": "verina", "source_id": "verina_basic_103_task", "vc-description": "/*\nThis problem involves updating an array of integers by modifying two specific positions. Specifically, the element at index 4 should be increased by 3, and the element at index 7 should be changed to 516. The goal is to correctly update these positions while leaving the rest of the array unchanged. The description assumes that the array contains at least 8 elements.\n\n-----Input-----\nThe input consists of:\n• a: An array of integers. The array must contain at least 8 elements.\n\n-----Output-----\nThe output is an array of integers that meets the following criteria:\n• The element at index 4 is updated to its original value plus 3.\n• The element at index 7 is set to 516.\n• All other elements in the array remain the same as in the input array.\n\n-----Note-----\nIt is assumed that the input array has a size of at least 8 elements. Indices are 0-indexed.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method update_elements(a: array<int>) returns (result: array<int>)\n    requires a.Length >= 8\n    ensures result.Length == a.Length\n    ensures result[4] == a[4] + 3\n    ensures result[7] == 516\n    ensures forall i :: 0 <= i < a.Length && i != 4 && i != 7 ==> result[i] == a[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := new int[0];\n    // impl-end\n}", "vc-postamble": ""}
{"id": "DV0185", "language": "dafny", "source": "verina", "source_id": "verina_basic_105_task", "vc-description": "/*\nThis task involves computing the element-wise product of two integer arrays. For each position in the arrays, the corresponding numbers are multiplied together. If an element is missing in one of the arrays at a given index, the missing value is treated as 0. When both arrays provide values for every index, the resulting array will contain the product of the two numbers at each corresponding index.\n\n-----Input-----\nThe input consists of two arrays:\n• a: An array of integers.\n• b: An array of integers (should be of equal length to a for the specification to hold).\n\n-----Output-----\nThe output is an array of integers that:\n• Has the same length as the input arrays.\n• For each index i, the output array contains the product a[i] * b[i].\n• In cases where one of the arrays might be shorter, missing elements default to 0 during multiplication.\n\n-----Note-----\nIt is assumed that the arrays are of equal length for the theorem specification, although the implementation defaults missing indices to 0.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ArrayProduct(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |a| ==> result[i] == a[i] * b[i]", "vc-code": "{\n    assume {:axiom} false;\n    result := a;\n}", "vc-postamble": ""}
{"id": "DV0186", "language": "dafny", "source": "verina", "source_id": "verina_basic_106_task", "vc-description": "/*\nThe task is to compute the element-wise sum of two integer arrays. The result should be a new array where each element is the sum of the corresponding elements from the two input arrays. The problem assumes that both arrays have the same length.\n\nInput:\nThe input consists of two parameters:\n• a: An array of integers.\n• b: An array of integers.\nNote: Both arrays must have the same length.\n\nOutput:\nThe output is an array of integers that:\n• Has the same size as the input arrays.\n• Contains elements where each element at index i is computed as a[i] + b[i] from the input arrays.\n\nNote:\nIt is assumed that the two input arrays have equal lengths.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ArraySum(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |a| ==> result[i] == a[i] + b[i]", "vc-code": "{\n    assume {:axiom} false;\n    result := seq(|a|, i => 0);\n}", "vc-postamble": ""}
{"id": "DV0188", "language": "dafny", "source": "verina", "source_id": "verina_basic_108_task", "vc-description": "/*\nThe problem is about processing a sequence of integer operations to determine cumulative results and identify potential negative outcomes. Given a list of integers, the task is to generate an array where the first element is 0 and each subsequent element is the cumulative sum of the operations performed sequentially. Additionally, the solution should check whether any of these cumulative values (after the initial 0) is negative, and return a corresponding boolean flag.\n\nInput:\nThe input consists of:\n• operations: A list of integers representing sequential operations.\n\nOutput:\nThe output is a tuple consisting of:\n• An array of integers representing the partial sums. The array's size is one more than the number of operations, starting with 0 and where for each index i such that 0 ≤ i < operations.length, the element at index i+1 is equal to the element at index i added to operations[i].\n• A boolean value that is true if there exists an index i (with 1 ≤ i ≤ operations.length) such that the i-th partial sum is negative, and false otherwise.\n\nNote:\nThe function should also correctly handle an empty list of operations.\n*/", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method BelowZero(operations: array<int>) returns (result: (array<int>, bool))\n    ensures\n        result.0.Length == operations.Length + 1\n    ensures\n        result.0[0] == 0\n    ensures\n        forall i :: 0 <= i < operations.Length ==> result.0[i + 1] == result.0[i] + operations[i]\n    ensures\n        result.1 == (exists i :: 1 <= i < result.0.Length && result.0[i] < 0)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    var emptyArray := new int[0];\n    result := (emptyArray, false);\n    // impl-end\n}", "vc-postamble": ""}
