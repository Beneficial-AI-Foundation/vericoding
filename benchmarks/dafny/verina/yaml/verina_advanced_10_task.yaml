vc-description: |-
  /*
  This task requires writing a Dafny method that decomposes a natural number `n` into its prime factorization components based on a user-provided list of primes. Specifically, it calculates the exponents for each prime in the factorization such that:
  \[ n = \prod p^e \]
  In other words, it determines the exponent e for each prime p.
  
  -----Input-----
  The input consists of a natural number n, and a list of prime numbers. The input n is obtained by multiplying together any powers of the prime numbers from the provided list.
  n: The natural number to be factorized.
  primes: A list of primes to decompose n into.
  
  -----Output-----
  The output is `seq<(nat, nat)>`:
  Return a list of pair/Cartesian product of two natural numbers (p, e), where p is the prime and e is the exponent of p in the factorization. Each prime in the output must be from the input list, and every prime in the input list must appear in the output.
  */

vc-preamble: |-
  function pow(base: int, exp: nat): int
  {
      if exp == 0 then 1 else base * pow(base, exp - 1)
  }

  predicate IsPrime(n: nat)
  {
      true // Abstract predicate for prime numbers
  }

  function SpecFold(pairs: seq<(nat, nat)>, acc: int): int
      decreases |pairs|
  {
      if |pairs| == 0 then
          acc
      else
          var p, e := pairs[0].0, pairs[0].1;
          SpecFold(pairs[1..], acc * pow(p as int, e))
  }

vc-helpers: |-

vc-spec: |-
  method FindExponents(n: nat, primes: seq<nat>) returns (result: seq<(nat, nat)>)
      requires forall i :: 0 <= i < |primes| ==> IsPrime(primes[i])
      ensures n as int == SpecFold(result, 1)
      ensures forall i :: 0 <= i < |result| ==> result[i].0 in primes
      ensures forall p :: p in primes ==> 
          exists j :: 0 <= j < |result| && result[j].0 == p

vc-code: |-
  {
      // TODO: implement
      assume {:axiom} false;
      result := [];
  }

vc-postamble: |-
