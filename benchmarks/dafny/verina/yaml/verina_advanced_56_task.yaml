vc-description: |-
  /*
  This task requires writing a Dafny method that moves all zeroes in a given integer array to the end, while preserving the relative order of the non-zero elements.
  
  The method `MoveZeroes` processes the input array by separating the non-zero and zero elements. It then returns a new array formed by appending all non-zero elements followed by all the zero elements.
  
  -----Input-----
  The input is a single array of integers:
  xs: An array of integers (type: array<int>), possibly containing zero and non-zero values.
  
  -----Output-----
  The output is an array of integers:
  Returns an array (type: array<int>) with the same elements as the input, where all zeroes appear at the end, and the non-zero elements maintain their original relative order.
  */

vc-preamble: |-
  /* Count how many times a specific value appears in the sequence */
  function CountVal(val: int, xs: seq<int>): nat 
      decreases |xs|
  {
      if |xs| == 0 then
          0
      else
          var rest := CountVal(val, xs[1..]);
          if xs[0] == val then rest + 1 else rest
  }

  /* Check whether one sequence is a subsequence of another (preserving relative order) */
  predicate IsSubsequence(xs: seq<int>, ys: seq<int>) 
      decreases |xs| + |ys|
  {
      if |xs| == 0 then
          true
      else if |ys| == 0 then
          false
      else
          if xs[0] == ys[0] then
              IsSubsequence(xs[1..], ys[1..])
          else
              IsSubsequence(xs, ys[1..])
  }

  function FilterNonZero(xs: seq<int>): seq<int>
  {
      if |xs| == 0 then []
      else if xs[0] != 0 then [xs[0]] + FilterNonZero(xs[1..])
      else FilterNonZero(xs[1..])
  }

vc-helpers: |-

vc-spec: |-
  method MoveZeroes(xs: array<int>) returns (result: array<int>)
      ensures
          /* All non-zero elements must maintain their relative order */
          IsSubsequence(FilterNonZero(xs[0..xs.Length]), result[0..result.Length])
          /* All zeroes must be located at the end of the output array */
          && (forall i :: 0 <= i < result.Length && result[i] != 0 ==> 
              forall j :: i < j < result.Length ==> result[j] != 0)
          /* The output must contain the same number of elements */
          && xs.Length == result.Length
          /* The number of zeroes must remain unchanged */
          && CountVal(0, xs[0..xs.Length]) == CountVal(0, result[0..result.Length])

vc-code: |-
  {
      assume {:axiom} false;
      result := new int[xs.Length];
  }

vc-postamble: |-