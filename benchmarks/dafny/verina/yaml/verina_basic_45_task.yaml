vc-description: |-
  /*
  This task requires writing a Dafny method that computes the product of the first even and the first odd number encountered in a list of integers. The method should search the list for the earliest even number and the earliest odd number, then return the product of these two numbers.
  
  Input:
  The input consists of:
  lst: A list of integers.
  
  Output:
  The output is an integer:
  Returns the product resulting from multiplying the first even number and the first odd number found in the list.
  
  Note:
  The input list is assumed to contain at least one even number and one odd number.
  */

vc-preamble: |-
  predicate FindProductPrecond(lst: seq<int>)
  {
      |lst| > 1 &&
      (exists x :: x in lst && IsEven(x)) &&
      (exists x :: x in lst && IsOdd(x))
  }

vc-helpers: |-
  predicate IsEven(n: int)
  {
      n % 2 == 0
  }
  
  predicate IsOdd(n: int)
  {
      n % 2 != 0
  }
  
  function {:axiom} FirstEvenIndex(lst: seq<int>): int
      requires exists i :: 0 <= i < |lst| && IsEven(lst[i])
      ensures 0 <= FirstEvenIndex(lst) < |lst|
      ensures IsEven(lst[FirstEvenIndex(lst)])
      ensures forall j :: 0 <= j < FirstEvenIndex(lst) ==> !IsEven(lst[j])
  
  function {:axiom} FirstOddIndex(lst: seq<int>): int
      requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])
      ensures 0 <= FirstOddIndex(lst) < |lst|
      ensures IsOdd(lst[FirstOddIndex(lst)])
      ensures forall j :: 0 <= j < FirstOddIndex(lst) ==> !IsOdd(lst[j])

vc-spec: |-
  method FindProduct(lst: array<int>) returns (result: int)
      requires lst.Length > 1
      requires exists x :: x in lst[..] && IsEven(x)
      requires exists x :: x in lst[..] && IsOdd(x)
      ensures var ei := FirstEvenIndex(lst[..]);
              var oi := FirstOddIndex(lst[..]);
              result == lst[ei] * lst[oi]

vc-code: |-
  {
      // TODO: implement
      assume {:axiom} false;
      result := 0;
  }

vc-postamble: |-