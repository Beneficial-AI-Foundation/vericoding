{"id": "bignum_ModExp[DivMod]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Mul[Add,NormalizeBitString]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Mul[Add,NormalizeBitString].\nImplement the method according to the Dafny specification.", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[Mul]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,ModExpPow2,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Add", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Add.\nImplement the method according to the Dafny specification.", "vc-spec": "method Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[ModExpPow2]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_DivMod", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_DivMod.\nImplement the method according to the Dafny specification.", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[Add,DivMod]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,ModExpPow2,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[Add,Mul]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[Add,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,ModExpPow2]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp_int", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp_int.\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[Add]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[Add].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignums_Zeros", "vc-preamble": "predicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignums_Zeros.\nImplement the method according to the Dafny specification.", "vc-spec": "method Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Mul[NormalizeBitString]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Mul[NormalizeBitString].\nImplement the method according to the Dafny specification.", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,ModExpPow2,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,ModExpPow2,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2.\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_DivMod[Compare]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_DivMod[Compare].\nImplement the method according to the Dafny specification.", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2_int", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2_int.\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Mul", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Mul.\nImplement the method according to the Dafny specification.", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp.\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[DivMod,Mul]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,ModExpPow2,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Compare[CompareUnequal]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Compare[CompareUnequal].\nImplement the method according to the Dafny specification.", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[ModExpPow2,Add,Zeroes,DivMod,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Add,Zeroes,DivMod,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[Add,DivMod,Mul]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[ModExpPow2,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Compare", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Compare.\nImplement the method according to the Dafny specification.", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,ModExpPow2,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Mul[Add]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Mul[Add].\nImplement the method according to the Dafny specification.", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,ModExpPow2]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[ModExpPow2,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Compare[CompareUnequal,NormalizeBitString]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  // Remove leading zeros, except keep at least one digit\n  ensures ValidBitString(t)\n  // I added and proved some extra post-conditions:\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Compare[CompareUnequal,NormalizeBitString].\nImplement the method according to the Dafny specification.", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignums_Sub[NormalizeBitstring]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignums_Sub[NormalizeBitstring].\nImplement the method according to the Dafny specification.", "vc-spec": "method Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_DivMod[Sub]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_DivMod[Sub].\nImplement the method according to the Dafny specification.", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Compare[NormalizeBitString]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  // Remove leading zeros, except keep at least one digit\n  ensures ValidBitString(t)\n  // I added and proved some extra post-conditions:\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Compare[NormalizeBitString].\nImplement the method according to the Dafny specification.", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_CompareUnequal", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_CompareUnequal.\nImplement the method according to the Dafny specification.", "vc-spec": "method CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[ModExpPow2,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_Add[NormalizeBitString]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  // Remove leading zeros, except keep at least one digit\n  ensures ValidBitString(t)\n  // I added and proved some extra post-conditions:\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_Add[NormalizeBitString].\nImplement the method according to the Dafny specification.", "vc-spec": "method Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,DivMod,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_DivMod[Compare,Sub]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_DivMod[Compare,Sub].\nImplement the method according to the Dafny specification.", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,ModExpPow2]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Add,ModExpPow2,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExpPow2[DivMod]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignums_Sub", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignums_Sub.\nImplement the method according to the Dafny specification.", "vc-spec": "method Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp_int[ModExpPow2_int]", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp_int[ModExpPow2_int].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1 //&& n > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,Mul,Zeroes]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul,Zeroes].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_NormalizeBitString", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_NormalizeBitString.\nImplement the method according to the Dafny specification.", "vc-spec": "method NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
{"id": "bignum_ModExp[DivMod,ModExpPow2,Mul]", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n  // All characters must be '0' or '1'.\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  // sy is power of 2 or zero\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  //requires y < Exp_int(2,n+1)\n  requires |sy| > 0 && Str2Int(sz) > 1 //&& n > 0\n  decreases |sy|", "vc-code": "{\n  assume false;\n}", "vc-postamble": ""}
