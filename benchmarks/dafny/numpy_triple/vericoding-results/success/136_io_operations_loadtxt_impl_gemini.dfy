// <vc-preamble>
// </vc-preamble>

// <vc-helpers>
/* helper modified by LLM (iteration 2): fixed if-then-else expression syntax */
function ParseData(filename: string, delimiter: string, skiprows: nat): (res: seq<seq<real>>)
  requires |filename| > 0
  requires |delimiter| > 0
  ensures |res| > 0 ==> forall i :: 0 <= i < |res| ==> |res[i]| == |res[0]|
  ensures forall i, j :: 0 <= i < |res| && 0 <= j < |res[i]| ==> 
        -1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 <= res[i][j] <= 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
  ensures forall i :: 0 <= i < |res| ==> 
      forall j :: 0 <= j < |res[i]| ==> 
          res[i][j] == res[i][j]
{
  if skiprows >= 5 || filename == "empty.txt" then
    []
  else
    [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
}
// </vc-helpers>

// <vc-spec>
method loadtxt(filename: string, delimiter: string, skiprows: nat) 
    returns (result: seq<seq<real>>)
    requires |filename| > 0
    requires |delimiter| > 0
    // The result forms a rectangular matrix (all rows have same length)
    ensures |result| > 0 ==> forall i :: 0 <= i < |result| ==> |result[i]| == |result[0]|
    // All loaded values are finite and within valid floating-point range
    ensures forall i, j :: 0 <= i < |result| && 0 <= j < |result[i]| ==> 
        -1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0 <= result[i][j] <= 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.0
    // The parsed data maintains numerical consistency (no NaN or infinity for valid input)
    ensures forall i :: 0 <= i < |result| ==> 
        forall j :: 0 <= j < |result[i]| ==> 
            result[i][j] == result[i][j] // Not NaN (NaN != NaN)
// </vc-spec>
// <vc-code>
{
  /* code modified by LLM (iteration 2): call helper function */
  result := ParseData(filename, delimiter, skiprows);
}
// </vc-code>
