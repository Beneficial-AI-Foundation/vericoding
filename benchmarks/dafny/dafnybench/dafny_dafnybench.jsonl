{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_FindPivotIndex_FindPivotIndex", "vc-description": "", "vc-preamble": "/*\nhttps://leetcode.com/problems/find-pivot-index/description/\nGiven an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn the leftmost pivot index. If no such index exists, return -1.\n\n\n\nExample 1:\n\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.\nExample 3:\n\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n\n```TypeScript\nfunction pivotIndex(nums: number[]): number {\n    const n = nums.length;\n    let leftsums = [0], rightsums = [0];\n    for(let i=1; i < n+1; i++) {\n        leftsums.push(nums[i-1]+leftsums[i-1]);\n        rightsums.push(nums[n-i]+rightsums[i-1]);\n    }\n    for(let i=0; i <= n; i++) {\n        if(leftsums[i] == rightsums[n-(i+1)]) return i;\n    }\n    return -1;\n};\n```\n*/\n\nfunction sum(nums: seq<int>): int {\n    // if |nums| == 0 then 0 else nums[0]+sum(nums[1..])\n    if |nums| == 0 then 0 else sum(nums[0..(|nums|-1)])+nums[|nums|-1]\n}\n\n\nfunction sumUp(nums: seq<int>): int {\n    if |nums| == 0 then 0 else nums[0]+sumUp(nums[1..])\n}\n\n// By Divyanshu Ranjan\n\n// By Divyanshu Ranjan", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod  FindPivotIndex(nums: seq<int>) returns (index: int)\n    requires |nums| > 0\n    ensures index == -1 ==> forall k: nat :: k < |nums| ==> sum(nums[0..k]) != sum(nums[(k+1)..])\n    ensures 0 <= index < |nums| ==> sum(nums[0..index]) == sum(nums[(index+1)..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_432_MedianLength", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MedianLength(a: int, b: int) returns (median: int)\n    requires a > 0 && b > 0\n    ensures median == (a + b) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_477_ToLowercase", "vc-description": "", "vc-preamble": "predicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ToLowercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_invertarray_InvertArray", "vc-description": "", "vc-preamble": "/**\n  Inverts an array of ints.\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InvertArray(a: array<int>)\n  modifies a\n  ensures forall i | 0 <= i < a.Length :: a[i] == old(a[a.Length-1-i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2_max", "vc-description": "", "vc-preamble": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\n\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\n\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_query", "vc-description": "", "vc-preamble": "//Exercicio 1.a)\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\n//Exercicio 1.b)\n\n//Exercicio 1.c)\n\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\n///Exercicio 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod query (a:array<int>, i:int, j:int) returns (s:int)\nrequires 0 <= i <= j <= a.Length\nensures s == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_ComputeCount", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputeCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_455_MonthHas31Days", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MonthHas31Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month in {1, 3, 5, 7, 8, 10, 12}\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Programs_tmp_tmp99966ew4_binary_search_BinarySearch", "vc-description": "", "vc-preamble": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_557_ToggleCase", "vc-description": "", "vc-preamble": "predicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsUpperCase(c : char)\n{\n    65 <= c as int <= 90\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\npredicate IsUpperLowerPair(C : char, c : char)\n{\n    (C as int) == (c as int) - 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}\n\nfunction Shift32(c : char) :  char\n{\n    ((c as int + 32) % 128) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ToggleCase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else if IsUpperCase(s[i]) then IsUpperLowerPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_554_FindOddNumbers", "vc-description": "", "vc-preamble": "/**\n * Find odd numbers from an array of numbers\n **/\n\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_624_ToUppercase", "vc-description": "", "vc-preamble": "predicate IsLowerCase(c : char)\n{\n    97 <= c as int <= 122\n}\n\npredicate IsLowerUpperPair(c : char, C : char)\n{\n    (c as int) == (C as int) + 32\n}\n\nfunction ShiftMinus32(c : char) :  char\n{\n    ((c as int - 32) % 128) as char\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ToUppercase(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==>  if IsLowerCase(s[i]) then IsLowerUpperPair(s[i], v[i]) else v[i] == s[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_600_IsEven", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsEven(n: int) returns (result: bool)\n    ensures result <==> n % 2 == 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_606_DegreesToRadians", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DegreesToRadians(degrees: real) returns (radians: real)\n    ensures radians == degrees * 3.14159265358979323846 / 180.0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_swap_arith_SwapArithmetic", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Reverse", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Reverse (a : array<int>) returns (aRev : array<int>)\n    ensures aRev.Length == a.Length\n    ensures forall i : int :: 0 <= i < a.Length ==> a[i] == aRev[aRev.Length-i-1]\n    ensures fresh(aRev) // Indicates returned object is newly created in method body\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates."}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod_mod", "vc-description": "", "vc-preamble": "ghost function f(n: nat): nat {\n    if n == 0 then 1 \n    else if n%2 == 0 then 1 + 2*f(n/2)\n    else 2*f(n/2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mod(n:nat) returns (a:nat) \nensures a == f(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mfirstMaximum", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mfirstMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: 0<=l<i ==> v[i]>v[l]\n//Algorithm: from left to right\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Algorithm : from left to right\n//Algorithm : from right to left"}
{"id": "Clover_multi_return_MultipleReturns", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_BinarySearch", "vc-description": "", "vc-preamble": "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n    // comparer is '>' or '>='\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove_Element_remove_element_remove_element", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod remove_element(nums: array<int>, val: int) returns (i: int)\n    modifies nums\n    requires 0 <= nums.Length <= 100\n    requires forall i :: 0 <= i < nums.Length ==> 0 <= nums[i] <= 50\n    requires 0 <= val <= 100\n    ensures forall j :: 0 < j < i < nums.Length ==> nums[j] != val\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_reverse_Reverse", "vc-description": "", "vc-preamble": "// Write an *iterative* Dafny method Reverse with signature:", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "//          method Reverse(a: array<char>) returns (b: array<char>)\n\n// which takes an input array of characters 'a' and outputs array 'b' consisting of\n// the elements of the input array in reverse order. The following conditions apply:\n//  - the input array cannot be empty\n//  - the input array is not modified\n//  - you must use iteration\n//  - not permitted is an *executable* (parallel) forall statement\n//  - not permitted are any other predicates, functions or methods\n\n// For the purposes of this practice exercise, I'll include a test method.\n\n// <vc-spec>\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a.Length == b.Length\nensures forall k :: 0 <= k < a.Length ==> b[k] == a[(a.Length-1) - k];\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Notice it compiles and the executable generates output (just to see the arrays printed in reverse)."}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt_sort", "vc-description": "", "vc-preamble": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n\n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_579_DissimilarElements", "vc-description": "", "vc-preamble": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_tutorial_maximum_Maximum", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This file shows how to specify and implement a function to compute the\n// largest element of a list. The function is fully specified by two\n// preconditions, as proved by the MaximumIsUnique lemma below.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Maximum(values: seq<int>) returns (max: int)\n  requires values != []\n  ensures max in values\n  ensures forall i | 0 <= i < |values| :: values[i] <= max\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segSumaMaxima2", "vc-description": "", "vc-preamble": "function Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\n\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\n//Now do the same but with a loop from right to left\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod segSumaMaxima2(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum2(v,k,i+1) &&  SumMaxToRight2(v,0,i,s)\n//Implement and verify\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSComp2010_Problem1-SumMax_M", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// VSComp 2010, problem 1, compute the sum and max of the elements of an array and prove\n// that 'sum <= N * max'.\n// Rustan Leino, 18 August 2010.\n//\n// The problem statement gave the pseudo-code for the method, but did not ask to prove\n// that 'sum' or 'max' return as the sum and max, respectively, of the array.  The\n// given assumption that the array's elements are non-negative is not needed to establish\n// the requested postcondition.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod M(N: int, a: array<int>) returns (sum: int, max: int)\n  requires 0 <= N && a.Length == N && (forall k :: 0 <= k && k < N ==> 0 <= a[k]);\n  ensures sum <= N * max;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_616_ElementWiseModulo", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ElementWiseModulo(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires forall i :: 0 <= i < b.Length ==> b[i] != 0\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] % b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Grind75_tmp_tmpsxfz3i4r_problems_twoSum_twoSum", "vc-description": "", "vc-preamble": "predicate summingPair(i: nat, j: nat, nums: seq<int>, target: int)\n    requires i < |nums|\n    requires j < |nums|\n{\n    i != j &&  nums[i] + nums[j] == target\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (nat, nat))\n    requires exists i:nat,j:nat :: i < j < |nums| && summingPair(i, j, nums, target) && forall l: nat, m: nat :: l <  m < |nums| && l != i && m != j ==> !summingPair(l, m, nums, target)\n    ensures 0 <= pair.0 < |nums| && 0 <= pair.1 < |nums| && summingPair(pair.0, pair.1, nums, target)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSortAux", "vc-description": "", "vc-preamble": "predicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\n\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures lo <= p < hi\n    ensures forall i :: lo <= i < p ==> a[i] < a[p]\n    ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    ensures SwapFrame(a, lo, hi)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod QuickSortAux(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]\n    ensures SwapFrame(a, lo, hi)\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    decreases hi - lo\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_SelectionSort", "vc-description": "", "vc-preamble": "predicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SelectionSort(a: array<int>)\n    modifies a\n    ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_longestPalindrome", "vc-description": "", "vc-preamble": "/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)  // Among all palindromes\n    && i + j == i0 + j0                                             // sharing the same center,\n    :: j - i <= hi - lo                                             // `s[lo..hi]` is longest.\n{\n  assume{:axiom} false;\n}\n\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod longestPalindrome(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]  // `ans` is indeed a substring in `s`\n  ensures palindromic(s, lo, hi)  // `ans` is palindromic\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo  // `ans` is longest\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_appendArray_appendArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_610_RemoveElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveElement(s: array<int>, k: int) returns (v: array<int>)\n    requires 0 <= k < s.Length\n    ensures v.Length == s.Length - 1\n    ensures forall i :: 0 <= i < k ==> v[i] == s[i]\n    ensures forall i :: k <= i < v.Length ==> v[i] == s[i + 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_BinarySearch", "vc-description": "", "vc-preamble": "/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_625_SwapFirstAndLast", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1])\n    ensures a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_605_IsPrime", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (forall k :: 2 <= k < n ==> n % k != 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_prac3_ex2_GetEven", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod GetEven(s: array<nat>) modifies s\nensures forall i :: 0 <= i < s.Length ==> \n                                if old(s[i]) % 2 == 1 then s[i] == old(s[i]) + 1\n                                else s[i] == old(s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_BST_InsertBST", "vc-description": "", "vc-preamble": "datatype Tree = Empty | Node(int,Tree,Tree)\n\n\n\nfunction NumbersInTree(t: Tree): set<int>\n{\n    NumbersInSequence(Inorder(t))\n}\n\nfunction NumbersInSequence(q: seq<int>): set<int>\n{\n    set x | x in q\n}\n\npredicate BST(t: Tree)\n{\n    Ascending(Inorder(t))\n}\n\nfunction Inorder(t: Tree): seq<int>\n{\n    match t {\n        case Empty => []\n        case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)\n    }\n}\n\npredicate Ascending(q: seq<int>)\n{\n    forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]\n}\n\npredicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }\n\n/*\n    Goal: Implement correctly, clearly. No need to document the proof obligations.\n*/\n\n/*\n    Goal: Implement correctly, efficiently, clearly, documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertBST(t0: Tree, x: int) returns (t: Tree)\n    requires BST(t0) && x !in NumbersInTree(t0)\n    ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_find_Find", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_242_CountCharacters", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountCharacters(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == |s|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_433_IsGreater", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsGreater(n: int, a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> n > a[i]\n    ensures !result ==> exists i :: 0 <= i < a.Length && n <= a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSorta", "vc-description": "", "vc-preamble": "predicate sorted_seg(a:array<int>, i:int, j:int) //j excluded\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod bubbleSorta(a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_809_IsSmaller", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsSmaller(a: seq<int>, b: seq<int>) returns (result: bool)\n    requires |a| == |b|\n    ensures result <==> forall i :: 0 <= i < |a| ==> a[i] > b[i]\n    ensures !result <==> exists i :: 0 <= i < |a| && a[i] <= b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_flip_flip", "vc-description": "", "vc-preamble": "// flips (i.e., reverses) array elements in the range [0..num]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_760_HasOnlyOneDistinctElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod HasOnlyOneDistinctElement(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] == a[j]\n    ensures !result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && a[i] != a[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_732_ReplaceWithColon", "vc-description": "", "vc-preamble": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_776_CountVowelNeighbors", "vc-description": "", "vc-preamble": "predicate IsVowel(c: char)\n{\n    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountVowelNeighbors(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 1 <= i < |s|-1 && IsVowel(s[i-1]) && IsVowel(s[i+1]) |\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_prac4_ex2_GetTriple", "vc-description": "", "vc-preamble": "predicate triple(a: array<int>) \nreads a\n{\n    exists i :: 0 <= i < a.Length - 2 && a[i] == a[i + 1] == a[i + 2]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod GetTriple(a: array<int>) returns (index: int)\nensures 0 <= index < a.Length - 2 || index == a.Length\nensures index == a.Length <==> !triple(a)\nensures 0 <= index < a.Length - 2 <==> triple(a)\nensures 0 <= index < a.Length - 2 ==> a[index] == a[index + 1] == a[index + 2]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_641_NthNonagonalNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod NthNonagonalNumber(n: int) returns (number: int)\n    requires n >= 0\n    ensures number == n * (7 * n - 5) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_618_ElementWiseDivide", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ElementWiseDivide(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercises_tmp_tmp5mvrowrx_leetcode_26-remove-duplicates-from-sorted-array_RemoveDuplicates", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveDuplicates(nums: array<int>) returns (num_length: int)\n  modifies nums\n  requires forall i, j | 0 <= i < j < nums.Length :: nums[i] <= nums[j]\n  ensures nums.Length == old(nums).Length\n  ensures 0 <= num_length <= nums.Length\n  ensures forall i, j | 0 <= i < j < num_length :: nums[i] != nums[j]\n  ensures forall i | 0 <= i < num_length :: nums[i] in old(nums[..])\n  ensures forall i | 0 <= i < nums.Length :: old(nums[i]) in nums[..num_length]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_convert_map_key_convert_map_key", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod convert_map_key(inputs: map<nat, bool>, f: nat->nat) returns(r:map<nat, bool>)\n  requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)\n  ensures forall k :: k in inputs <==> f(k) in r\n  ensures forall k :: k in inputs ==> r[f(k)] == inputs[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_quotient_Quotient", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Quotient(x: nat, y:nat) returns (r:int, q:int)\n  requires y != 0\n  ensures q * y + r == x && 0 <= r < y && 0 <= q\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Remove_Duplicates_from_Sorted_Array_remove_duplicates_from_sorted_array_remove_duplicates_from_sorted_array", "vc-description": "", "vc-preamble": "// Helper predicate\npredicate is_sorted(nums: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] <= nums[j]\n}\n\npredicate is_sorted_and_distinct(nums: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] < nums[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod remove_duplicates_from_sorted_array(nums: seq<int>) returns (result: seq<int>) \n    requires is_sorted(nums)\n    requires 1 <= |nums| <= 30000\n    requires forall i :: 0 <= i < |nums| ==> -100 <= nums[i] <= 100\n    ensures is_sorted_and_distinct(result)\n    ensures forall i :: i in nums <==> i in result\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_401_IndexWiseAddition", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IndexWiseAddition(a: seq<seq<int>>, b: seq<seq<int>>) returns (result: seq<seq<int>>)\n    requires |a| > 0 && |b| > 0\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |a| ==> |a[i]| == |b[i]|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> |result[i]| == |a[i]|\n    ensures forall i :: 0 <= i < |result| ==> forall j :: 0 <= j < |result[i]| ==> result[i][j] == a[i][j] + b[i][j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "se2011_tmp_tmp71eb82zt_ass2_ex2_SecondLargest", "vc-description": "", "vc-preamble": "// ex2\n\n// this was me playing around to try and get an ensures for the method \n/*predicate method check(a: array<int>, seclar:int)\nrequires a.Length > 0\nreads a\n{ ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j]) } */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SecondLargest(a:array<int>) returns (seclar:int)\nrequires a.Length > 0\n//ensures exists i :: 0 <= i < a.Length && forall j :: (0 <= j < a.Length && j != i) ==> (a[i] >= a[j]) && (seclar <= a[i]) && ( if a[j] != a[i] then seclar >= a[j] else seclar <= a[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_linear_search1_LinearSearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_find_min_index", "vc-description": "", "vc-preamble": "predicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\n\n// predicate is_permutation(a:seq<int>, b:seq<int>)\n// decreases |a|\n// decreases |b|\n// {\n//     |a| == |b|  && ((|a| == 0 && |b| == 0) ||  exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))\n// }\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "BinaryAddition_ArrayToSequence", "vc-description": "", "vc-preamble": "/* \nMIPS 0\nWe implement the following with bitvectors in Dafny.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\nfunction ArrayToBv10(arr: array<bool>): bv10 // Converts boolean array to bitvector\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>) // Converts boolean array to boolean sequence\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_PreCompute", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n\n\n\n\nmethod ComputeCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PreCompute(a:array<int>,b:array<int>)returns(p:nat)\n    requires a.Length == b.Length \n    modifies b\n    ensures (b.Length == 0 || (a.Length == b.Length && 1 <= b.Length <= a.Length)) &&\n    forall p::p == Count(b.Length,a[..]) ==> p==Count(b.Length,a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_743_RotateRight", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort_bubbleSort", "vc-description": "", "vc-preamble": "predicate sorted_seg(a:array<int>, i:int, j:int) //j excluded\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod bubbleSort(a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isSubstring", "vc-description": "", "vc-preamble": "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_vector_Sum", "vc-description": "", "vc-preamble": "/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\nfunction sum(v: seq<int>): int \ndecreases v\n{\n    if v==[] then 0\n    else if |v|==1 then v[0]\n    else v[0]+sum(v[1..])\n}\n\n// Structural Induction on Sequences\n\n// MAXIMUM OF A SEQUENCE\n\n// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j\n\n\n// REVERSE OF A SEQUENCE\nfunction reverse<T> (s:seq<T>):seq<T> \n{\n    if s==[] then []\n    else reverse(s[1..])+[s[0]]\n}\n\nfunction seq2set<T> (s:seq<T>): set<T>\n{\n    if s==[] then {}\n    else {s[0]}+seq2set(s[1..])\n}\n\n\n// REVERSE IS ITS OWN INVERSE\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\nfunction scalar_product (v1:seq<int>, v2:seq<int>):int\nrequires |v1| == |v2|\n{\n    if v1 == [] then 0 else v1[0]*v2[0] + scalar_product(v1[1..],v2[1..])\n}\n\n// MULTISETS\n\nmethod multiplicity_examples<T> ()\n{\n  assume{:axiom} false;\n}\n\n// REVERSE HAS THE SAME MULTISET", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod vector_Sum(v:seq<int>) returns (x:int)\nensures x == sum(v)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_573_UniqueProduct", "vc-description": "", "vc-preamble": "ghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_match_Match", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Match(s: string, p: string) returns (b: bool)\n  requires |s| == |p|\n  ensures b <==> forall n :: 0 <= n < |s| ==> s[n] == p[n] || p[n] == '?'\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p1_SumArray", "vc-description": "", "vc-preamble": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\n\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_728_AddLists", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AddLists(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] + b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_598_IsArmstrong", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsArmstrong(n: int) returns (result: bool)\n    requires 100 <= n < 1000\n    ensures result <==> (n == ((n / 100) * (n / 100) * (n / 100) + ((n / 10) % 10) * ((n / 10) % 10) * ((n / 10) % 10) + (n % 10) * (n % 10) * (n % 10)))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_FooCount", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FooCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_Merge", "vc-description": "", "vc-preamble": "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n//This is a method that replace the loop body\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n        //decreases ensures\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n        {\n\n            i,j := i0,j0;\n\n                if(i == c.Length || (j< d.Length && d[j] < c[i])){\n                    // in this case we take the next value from d\n                assert InvSorted(b[..][i+j:=d[j]],c[..],d[..],i,j+1);\n                b[i+j] := d[j];\n\n                assert InvSubSet(b[..],c[..],d[..],i,j+1);\n                assert InvSorted(b[..],c[..],d[..],i,j+1);\n                j := j + 1;\n            }\n            else{\n                assert j == d.Length || (i < c.Length && c[i] <= d[j]);\n                    // in this case we take the next value from c\n                assert InvSorted(b[..][i+j:=c[i]],c[..],d[..],i+1,j);\n\n                b[i+j] := c[i];\n\n                assert InvSubSet(b[..],c[..],d[..],i+1,j);\n                assert InvSorted(b[..],c[..],d[..],i+1,j);\n                i := i + 1;\n            }\n\n\n        }\n\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElemsB", "vc-description": "", "vc-preamble": "function SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {SumR(v[c..f])}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sumElemsB(v:array<int>) returns (sum:int)\n//ensures sum==SumL(v[0..v.Length])\nensures sum==SumR(v[0..v.Length])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_swap", "vc-description": "", "vc-preamble": "\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod swap<T>(a: array<T>, i: int, j: int)\n  // requires a != null\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_807_FindFirstOdd", "vc-description": "", "vc-preamble": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_avg_ComputeAvg", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_588_DifferenceMinMax", "vc-description": "", "vc-preamble": "// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DifferenceMinMax(a: array<int>) returns (diff: int)\n    requires a.Length > 0\n    ensures diff == Max(a[..]) - Min(a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_spmv_SpMV", "vc-description": "", "vc-preamble": "function sum(X_val: array<int>, X_crd: array<nat>, v : array<int>, b : int, k : int) : (s : int)\n  reads X_val, X_crd, v\n  requires X_val.Length >= b >= 0\n  requires k <= X_val.Length\n  requires X_val.Length == X_crd.Length\n  requires forall i :: 0 <= i < X_crd.Length ==> 0 <= X_crd[i] < v.Length\n  decreases k - b\n  {\n    if k <= b then \n      0\n    else  sum(X_val, X_crd, v, b + 1, k) + X_val[b] * v[X_crd[b]]\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SpMV(X_val: array<int>, X_crd: array<nat>, X_pos: array<nat>, v : array<int>) returns (y : array<int>)\n  requires X_crd.Length >= 1 \n  requires X_crd.Length == X_val.Length;\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_crd.Length ==> X_crd[i] < v.Length\n  requires forall i :: 0 <= i < X_pos.Length ==> X_pos[i] <= X_val.Length\n  requires X_pos.Length >= 1\n  ensures y.Length + 1 == X_pos.Length\n  ensures forall i :: 0 <= i < y.Length ==> y[i] == sum(X_val, X_crd, v, X_pos[i], X_pos[i + 1])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// 0 0 0 0 0 0 1 0\n// 0 0 0 0 0 0 0 0\n// 0 0 0 0 1 0 0 0\n// 0 0 0 0 0 0 0 0\n// 0 0 1 0 0 0 0 0\n// 0 0 0 0 0 0 0 0\n// 1 0 0 0 0 0 0 0\n// 0 0 0 0 0 0 0 0"}
{"id": "Dafny_tmp_tmpv_d3qi10_2_min_minArray", "vc-description": "", "vc-preamble": "function min(a: int, b: int): int\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a || min(a, b) == b\n{\n    if a < b then a else b\n}\n\n\nghost function minFunction(a: int, b: int): int\n    ensures minFunction(a, b) <= a && minFunction(a, b) <= b\n    ensures minFunction(a, b) == a || minFunction(a, b) == b\n{\n    if a < b then a else b\n}\n\n\n// Return a minimum of a.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod minArray(a: array<int>) returns (m: int)\n    requires a!= null  && a.Length > 0 \n    ensures forall k | 0 <= k < a.Length :: m <= a[k]\n    ensures exists k | 0 <= k < a.Length :: m == a[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained_mcontained", "vc-description": "", "vc-preamble": "predicate strictSorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_127_Multiply", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Multiply(a: int, b: int) returns (result: int)\n  ensures result == a * b\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseReplace_replace", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod replace(v:array<int>, x:int, y:int)\nmodifies v\nensures forall k::0<=k<old(v.Length) && old(v[k])==x ==> v[k]==y\nensures forall k::0<=k<old(v.Length) && old(v[k])!=x ==> v[k]==old(v[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_ReverseString_yarra", "vc-description": "", "vc-preamble": "// RUN: /compile:0\n\npredicate reversed (arr : array<char>, outarr: array<char>)\nrequires arr != null && outarr != null\n//requires 0<=k<=arr.Length-1\nrequires arr.Length == outarr.Length\nreads arr, outarr\n{\n  forall k :: 0<=k<=arr.Length-1 ==> outarr[k] == arr[(arr.Length-1-k)]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod yarra(arr : array<char>) returns (outarr : array<char>)\nrequires arr != null && arr.Length > 0\nensures outarr != null && arr.Length == outarr.Length && reversed(arr,outarr)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_Find", "vc-description": "", "vc-preamble": "// shenanigans going through the dafny tutorial\n\n\n\n\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_exp_by_sqr", "vc-description": "", "vc-preamble": "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod exp_by_sqr(x0: real, n0: nat) returns (r:real)\nrequires x0 >= 0.0;\nensures r == exp(x0, n0);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Euclid", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Euclid (m : int, n : int) returns (gcd : int)\n    requires m > 1 && n > 1 && m >= n  // TODO\n    ensures gcd > 0 && gcd <= n && gcd <= m && m % gcd == 0 && n % gcd == 0 // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates."}
{"id": "Clover_reverse_reverse", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_804_IsProductEven", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsProductEven(a: array<int>) returns (result: bool)\n    ensures result <==> exists i :: 0 <= i < a.Length && IsEven(a[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Valid_Palindrome_valid_panlindrome_isPalindrome", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod isPalindrome(s: array<char>) returns (result: bool)\n    requires 1<= s.Length <= 200000\n    ensures result <==> (forall i:: 0 <= i < s.Length / 2 ==> s[i] == s[s.Length - 1 - i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex1_PalVerify", "vc-description": "", "vc-preamble": "// ex3errors.dfy in Assignment 1\n// verify that an array of characters is a Palindrome\n/*\nA Palindrome is a word that is the same when written forwards and when written backwards. \nFor example, the word ”refer” is a Palindrome.\nThe method PalVerify is supposed to verify whether a word is a Palindrome, \nwhere the word is represented as an array of characters. \nThe method was written by a novice software engineer, and contains many errors.\n\n   i) Without changing the signature or the code in the while loop, \n      fix the method so that it veriifes the code. Do not add any Dafny predicates or functions: \n      keep the changes to a minimum.\n\n   ii) Write a tester method (you may call it anything you like) that verifies that the \n      testcases refer, z and the empty string are Palindromes, and xy and 123421 are not. \n      The tester should not generate any output.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PalVerify(a: array<char>) returns (yn: bool)\nensures yn == true ==> forall i :: 0 <= i < a.Length/2 ==> a[i] == a[a.Length - i -1]\nensures yn == false ==> exists i :: 0 <= i < a.Length/2 && a[i] != a[a.Length - i -1]\nensures forall j :: 0<=j<a.Length ==> a[j] == old(a[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_803_IsPerfectSquare", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsPerfectSquare(n: int) returns (result: bool)\n    requires n >= 0\n    ensures result == true ==> (exists i: int :: 0 <= i <= n && i * i == n)\n    ensures result == false ==> (forall a: int :: 0 < a*a < n ==> a*a != n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "FlexWeek_tmp_tmpc_tfdj_3_ex4_join", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod join(a:array<int>,b:array<int>) returns (c:array<int>)\nensures a[..] + b[..] == c[..]\nensures multiset(a[..] + b[..]) == multiset(c[..])\nensures multiset(a[..]) + multiset(b[..]) == multiset(c[..])\nensures a.Length+b.Length == c.Length\n\n// Forall\n\nensures forall i :: 0<=i<a.Length ==> c[i] == a[i]\nensures forall i_2,j_2::\n    a.Length <= i_2 < c.Length &&\n    0<=j_2< b.Length && i_2 - j_2 == a.Length  ==> c[i_2] == b[j_2]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_750_AddTupleToList", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AddTupleToList(l: seq<(int, int)>, t: (int, int)) returns (r: seq<(int, int)>)\n    ensures |r| == |l| + 1\n    ensures r[|r| - 1] == t\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_94_MinSecondValueFirst", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Sort", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n\n// Insertion sort með hjálp helmingunarleitar.\n\n\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_sequences_ex3_Delete", "vc-description": "", "vc-preamble": "// line contém uma string de tamanho l\n// remover p caracteres a partir da posição at", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Delete(line:array<char>, l:nat, at:nat, p:nat)\n  requires l <= line.Length\n  requires at+p <= l\n  modifies line\n  ensures line[..at] == old(line[..at])\n  ensures line[at..l-p] == old(line[at+p..l])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_haveCommonKSubstring", "vc-description": "", "vc-preamble": "predicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex1_StringSwap", "vc-description": "", "vc-preamble": "// method verifies", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod StringSwap(s: string, i:nat, j:nat) returns (t: string)\nrequires i >= 0 && j >= 0 && |s| >= 0;\nrequires |s| > 0 ==> i < |s| && j < |s|;\nensures multiset(s[..]) == multiset(t[..]);\nensures |s| == |t|;\nensures |s| > 0 ==> forall k:nat :: k != i && k != j && k < |s| ==> t[k] == s[k]\nensures |s| > 0 ==> t[i] == s[j] && t[j] == s[i];\nensures |s| == 0 ==> t == s;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// string == seq<Char>\n//give se2011 ass2 ex1.dfy"}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual1", "vc-description": "", "vc-preamble": "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\n\n//All equal to first", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mallEqual1(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_430_ParabolaDirectrix", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ParabolaDirectrix(a: real, h: real, k: real) returns (directrix: real)\n    requires a != 0.0\n    ensures directrix == k - 1.0 / (4.0 * a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_q", "vc-description": "", "vc-preamble": "//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n\nmethod strange()\nensures 1==2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_249_Intersection", "vc-description": "", "vc-preamble": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Intersection(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_476_SumMinMax", "vc-description": "", "vc-preamble": "// The order of the recursion in these two functions\n// must match the order of the iteration in the algorithm above\nfunction Min(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var minPrefix := Min(a[..|a|-1]);\n        if a[|a|-1] <= minPrefix then a[|a|-1] else Min(a[..|a|-1])\n}\n\nfunction Max(a: seq<int>) : int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n        var maxPrefix := Max(a[..|a|-1]);\n        if a[|a|-1] >= maxPrefix then a[|a|-1] else Max(a[..|a|-1])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumMinMax(a: array<int>) returns (sum: int)\n    requires a.Length > 0\n    ensures sum == Max(a[..]) + Min(a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort_selSort", "vc-description": "", "vc-preamble": "predicate sorted_seg(a:array<int>, i:int, j:int) //j not included\nrequires 0 <= i <= j <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k < j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod selSort (a:array<int>, c:int, f:int)//f excluded\nmodifies a \nrequires 0 <= c <= f <= a.Length //when c==f empty sequence\nensures sorted_seg(a,c,f) \nensures multiset(a[c..f]) == old(multiset(a[c..f]))\nensures a[..c]==old(a[..c]) && a[f..]==old(a[f..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_array_concat_concat", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_623_PowerOfListElements", "vc-description": "", "vc-preamble": "function Power(base: int, exponent: int): int\n    requires exponent >= 0\n{\n    if exponent == 0 then 1\n    else base * Power(base, exponent-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PowerOfListElements(l: seq<int>, n: int) returns (result: seq<int>)\n    requires n >= 0\n    ensures |result| == |l|\n    ensures forall i :: 0 <= i < |l| ==> result[i] == Power(l[i], n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_bubble_sort", "vc-description": "", "vc-preamble": "// Bubble Sort\n\n// Predicates for Bubble Sort\npredicate sorted(a: array2<int>, l: int, u: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length0 ==> a[i, 1] <= a[j, 1]\n}\n\npredicate partitioned(a: array2<int>, i: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall k, k' :: 0 <= k <= i < k' < a.Length0 ==> a[k, 1] <= a[k', 1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod bubble_sort(a: array2<int>)\n    modifies a\n    requires a.Length1 == 2\n    ensures sorted(a, 0, a.Length0 - 1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search1000", "vc-description": "", "vc-preamble": "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Search1000( a: array<int>, x: int ) returns ( k: int )\n    requires a.Length >= 1000;\n    requires forall p,q | 0 <= p < q < 1000 :: a[p] <= a[q];\n    ensures 0 <= k <= 1000;\n    ensures forall r | 0 <= r < k :: a[r] < x;\n    ensures forall r | k <= r < 1000 :: a[r] >= x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_pancakesort_findmax_findMax", "vc-description": "", "vc-preamble": "// returns an index of the largest element of array 'a' in the range [0..n)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod findMax (a : array<int>, n : int) returns (r:int)\nrequires a.Length > 0\nrequires 0 < n <= a.Length\nensures 0 <= r < n <= a.Length;\nensures forall k :: 0 <= k < n <= a.Length ==> a[r] >= a[k];\nensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_145_MaxDifference", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchLoop", "vc-description": "", "vc-preamble": "// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/0HRr\n\n// Author of solution:    Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/8pxWd\n\n// Use the command\n//   dafny LinearSearch-skeleton.dfy\n// or\n//   compile LinearSearch-skeleton.dfy\n// to compile the file.\n// Or use the web page rise4fun.com/dafny.\n\n// When you have solved the problem put\n// the solution on the Dafny web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SearchLoop( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_741_AllCharactersSame", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AllCharactersSame(s: string) returns (result: bool)\n    ensures result ==> forall i, j :: 0 <= i < |s| && 0 <= j < |s| ==> s[i] == s[j]\n    ensures !result ==> (|s| > 1) && (exists i, j :: 0 <= i < |s| && 0 <= j < |s| && i != j && s[i] != s[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_414_AnyValueExists", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_587_ArrayToSeq", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ArrayToSeq(a: array<int>) returns (s: seq<int>)\n    requires a != null\n    ensures |s| == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> s[i] == a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_cal_sum_Sum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Sum(N:int) returns (s:int)\n  requires N >= 0\n  ensures s == N * (N + 1) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_Power_powerDC", "vc-description": "", "vc-preamble": "/* \n* Formal verification of an O(log n) algorithm to calculate the natural power of a real number (x^n), \n* illustrating the usage of lemmas and automatic induction in Dafny.\n* J.  Pascoal Faria, FEUP, Jan/2022.\n*/\n\n// Recursive definition of x^n in functional style, with time and space complexity O(n).\nfunction power(x: real, n: nat) : real {\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Computation of x^n in time and space O(log n).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod powerDC(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "\n\n\n// A few test cases (checked statically by Dafny)."}
{"id": "MFES_2021_tmp_tmpuljn8zd9_Exams_Special_Exam_03_2020_4_CatalanNumbers_calcC", "vc-description": "", "vc-preamble": "function C(n: nat): nat \n    decreases n\n{\n    if n == 0 then 1 else (4 * n - 2) * C(n-1) / (n + 1) \n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod calcC(n: nat) returns (res: nat)\n    ensures res == C(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_474_ReplaceChars", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_2_SharedElements", "vc-description": "", "vc-preamble": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_460_GetFirstElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod GetFirstElements(lst: seq<seq<int>>) returns (result: seq<int>)\n    requires forall i :: 0 <= i < |lst| ==> |lst[i]| > 0\n    ensures |result| == |lst|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == lst[i][0]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_161_RemoveElements", "vc-description": "", "vc-preamble": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in a and not in b\n    ensures forall x :: x in result ==> InArray(a, x) && !InArray(b, x)\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_sol_bubbleSort", "vc-description": "", "vc-preamble": "predicate sorted_between (a:array<int>, from:nat, to:nat)\n  reads a;\n  requires a != null;\n  requires from <= to;\n  requires to <= a.Length;\n{\n  forall i,j :: from <= i < j < to && 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\npredicate sorted (a:array<int>)\n  reads a;\n  requires a!=null;\n{\n  sorted_between (a, 0, a.Length)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod bubbleSort (a: array<int>)\n  modifies a;\n  requires a != null;\n  requires a.Length > 0;\n  ensures sorted(a);\n  ensures multiset(old(a[..])) == multiset(a[..]);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_modify_2d_array_modify_array_element", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall i: nat :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n  ensures forall i: nat, j: nat :: 0 <= i < arr.Length && 0 <= j < arr[i].Length && (i != index1 || j != index2) ==> arr[i][j] == old(arr[i][j])\n  ensures  arr[index1][index2] == val\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_435_LastDigit", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LastDigit(n: int) returns (d: int)\n    requires n >= 0\n    ensures 0 <= d < 10\n    ensures n % 10 == d\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_775_IsOddAtIndexOdd", "vc-description": "", "vc-preamble": "predicate IsOdd(n: int)\n{\n    n % 2 == 1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsOddAtIndexOdd(a: array<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < a.Length ==> (IsOdd(i) ==> IsOdd(a[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_ex3_BadSort", "vc-description": "", "vc-preamble": "// program verifies\n\npredicate sortedbad(s: string)\n{\n  // no b's after non-b's\n  forall i, j :: 0 <= i <= j < |s| && s[i] == 'b' && s[j] != 'b' ==> i < j &&\n  // only non-d's before d's\n  forall i, j :: 0 <= i <= j < |s| && s[i] != 'd' && s[j] == 'd' ==> i < j\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall i :: 0<=i<|a| ==> a[i] in {'b', 'a', 'd'}\nensures sortedbad(b)\nensures multiset(b[..]) == multiset(a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_swap", "vc-description": "", "vc-preamble": "// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,\n// which actually somehow manages to work perfectly:\n//\n// for i in 0..n\n//   for j in 0..n\n//     if i < j\n//       swap a[i], a[j]\n//\n// It is perhaps the simpliest sorting algorithm to \"memorize\",\n// even \"symmetrically beautiful\" as if `i` and `j` just played highly\n// similar roles. And technically it's still O(n^2) time lol...\n//\n// Proving its correctness is tricky (interesting) though.\n\n// Successfully verified with [Dafny 3.3.0.31104] in about 5 seconds.\n\n\n\n// We define \"valid permutation\" using multiset:\n\npredicate valid_permut(a: seq<int>, b: seq<int>)\n  requires |a| == |b|\n{\n  multiset(a) == multiset(b)\n}\n\n// This is a swap-based sorting algorithm, so permutedness is trivial:\n// note that: if i == j, the spec just says a[..] remains the same.\n\n// We then define \"sorted\" (by increasing order):\npredicate sorted(a: seq<int>)\n{\n  forall i, j | 0 <= i <= j < |a| :: a[i] <= a[j]\n}\n\n\n// Now, the lol sort algorithm:\n// (Some invariants were tricky to find, but Dafny was smart enough otherwise)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[..] == old(a[..]) [i := old(a[j])] [j := old(a[i])]\n  ensures valid_permut(a[..], old(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p6_FilterVowelsArray", "vc-description": "", "vc-preamble": "//Given an array of characters, it filters all the vowels. [‘d’,’e’,’l’,’i’,’g’,’h’,’t’]-> [’e’,’i’]\nconst vowels: set<char> := {'a', 'e', 'i', 'o', 'u'}\n\nfunction FilterVowels(xs: seq<char>): seq<char>\n{\n    if |xs| == 0 then []\n    else if xs[|xs|-1] in vowels then FilterVowels(xs[..|xs|-1]) + [xs[|xs|-1]]\n    else FilterVowels(xs[..|xs|-1])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FilterVowelsArray(xs: array<char>) returns (ys: array<char>)\n    ensures fresh(ys)\n    ensures FilterVowels(xs[..]) == ys[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Selection_Sort_Standard_selectionSorted", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod selectionSorted(Array: array<int>) \n  modifies Array\n  ensures multiset(old(Array[..])) == multiset(Array[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_even_list_FindEvenNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindEvenNumbers (arr: array<int>) returns (evenNumbers: array<int>)\n  ensures forall x {:trigger (x%2) }:: x in arr[..] &&  (x%2==0)==> x in evenNumbers[..]\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n  ensures forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] % 2 == 0\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n                           exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_637_IsBreakEven", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsBreakEven(costPrice: int, sellingPrice: int) returns (result: bool)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures result <==> costPrice == sellingPrice\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_zapNegatives_ZapNegatives", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ZapNegatives(a: array<int>) \nmodifies a\nensures forall i :: 0 <= i < a.Length ==> if old(a[i]) < 0 then a[i] == 0 \n                                            else a[i] == old(a[i])\nensures a.Length == old(a).Length\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_queryFast", "vc-description": "", "vc-preamble": "/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\n\n\n//(b)\n\n\n\n\n//(c)\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n    requires a.Length + 1 == c.Length && c[0] == 0\n    requires 0 <= i <= j <= a.Length\n    requires is_prefix_sum_for(a,c)  \n    ensures r == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_swap_Swap", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Non-overlapping_Intervals_non_overlapping_intervals_non_overlapping_intervals", "vc-description": "", "vc-preamble": "// Bubble Sort\nmethod bubble_sort(a: array2<int>)\n    modifies a\n    requires a.Length1 == 2\n    ensures sorted(a, 0, a.Length0 - 1)\n{\n  assume{:axiom} false;\n}\n\n\n// Predicates for Bubble Sort\npredicate sorted(a: array2<int>, l: int, u: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length0 ==> a[i, 1] <= a[j, 1]\n}\n\npredicate partitioned(a: array2<int>, i: int)\n    reads a\n    requires a.Length1 == 2\n{\n    forall k, k' :: 0 <= k <= i < k' < a.Length0 ==> a[k, 1] <= a[k', 1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod non_overlapping_intervals(intervals: array2<int>) returns (count: int)\n    modifies intervals\n    requires 1 <= intervals.Length0 <= 100000\n    requires intervals.Length1 == 2\n    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 0] <= 50000\n    requires forall i :: 0 <= i < intervals.Length0 ==> -50000 <= intervals[i, 1] <= 50000\n    // TODO: modify the ensures clause so that count is indeed equal to the minimum number of intervals we need to remove to make the rest of the intervals non-overlapping.\n    ensures count >= 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "veri-sparse_tmp_tmp15fywna6_dafny_dspmspv_DSpMSpV", "vc-description": "", "vc-preamble": "function sum(X_val : array<int>, X_crd : array<nat>,\n             v_val : array<int>, v_crd : array<nat>, kX : nat, kV : nat, pX_end : nat, pV_end : nat) : (s : int) \n  reads X_val, X_crd\n  requires X_val.Length == X_crd.Length\n  requires pX_end <= X_crd.Length\n  requires 0 <= kX <= X_crd.Length\n\n  reads v_crd, v_val\n  requires v_val.Length == v_crd.Length\n  requires pV_end <= v_crd.Length\n  requires 0 <= kV <= v_crd.Length\n\n  decreases pX_end + pV_end - (kX + kV)\n  {\n    if pV_end <= kV || pX_end <= kX then \n      0\n    else if X_crd[kX] == v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV + 1, pX_end, pV_end) + v_val[kV] * X_val[kX]\n    else if X_crd[kX] < v_crd[kV] then \n      sum(X_val, X_crd, v_val, v_crd, kX + 1, kV, pX_end, pV_end)\n    else sum(X_val, X_crd, v_val, v_crd, kX, kV + 1, pX_end, pV_end)\n  }\n\nfunction min(x : nat, y : nat) : nat {\n  if x <= y then x else y\n}\n\npredicate notin(y: nat, x : array<nat>) \n  reads x\n{\n  forall i :: 0 <= i < x.Length ==> y != x[i]\n}\n\npredicate notin_seq(y: nat, x : seq<nat>) \n{\n  forall i :: 0 <= i < |x| ==> y != x[i]\n}\n\nfunction index_seq(x : nat, y: seq<nat>) : (i : nat)\n  ensures i >= |y| ==> notin_seq(x, y)\n  ensures i <  |y| ==> y[i] == x\n{\n  if |y| == 0 then 0 \n  else \n    if y[0] == x then 0 \n    else 1 + index_seq(x, y[1..])\n}\n\nfunction index(x : nat, y: array<nat>) : (i : nat)\n  reads y\n  ensures i >= y.Length ==> notin(x, y)\n  ensures i <  y.Length ==> y[i] == x\n{\n  index_seq(x, y[.. ])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DSpMSpV(X_val : array<int>, X_crd : array<nat>, X_pos : array<nat>,\n                                  X_crd1 : array<nat>, X_len: nat,\n              v_val : array<int>, v_crd : array<nat>) returns (y : array<int>)\n  // X requirements \n  requires X_pos.Length >= 1\n  requires X_val.Length == X_crd.Length\n  requires forall i, j :: 0 <= i < j < X_pos.Length ==> X_pos[i] <= X_pos[j];\n  requires forall i :: 0 <= i < X_pos.Length ==> 0 <= X_pos[i] <= X_val.Length\n\n  requires X_len >= X_crd1.Length\n  requires forall i :: 0 <= i < X_crd1.Length ==> X_crd1[i] < X_len\n\n  requires X_crd1.Length < X_pos.Length\n  requires forall i, j :: 0 <= i < j < X_crd1.Length ==> X_crd1[i] < X_crd1[j]\n\n  // v requirements \n  requires v_val.Length == v_crd.Length\n\n  ensures y.Length == X_len\n  ensures forall i :: 0 <= i < y.Length ==> \n    y[i] == \n      if index(i, X_crd1) < X_crd1.Length then \n        sum(X_val, X_crd, v_val, v_crd, X_pos[index(i, X_crd1)], 0, X_pos[index(i, X_crd1)+1], v_val.Length)\n      else 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_CombNK_Comb", "vc-description": "", "vc-preamble": "/* \n* Formal specification and verification of a dynamic programming algorithm for calculating C(n, k).\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial recursive definition of C(n, k), based on the Pascal equality.\nfunction comb(n: nat, k: nat): nat \n  requires 0 <= k <= n\n{\n  if k == 0 || k == n then 1 else comb(n-1, k) + comb(n-1, k-1)  \n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Comb(n: nat, k: nat) returns (res: nat)\n  requires 0 <= k <= n\n  ensures res == comb(n, k)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower_ComputePower", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_tmp_tmp49a6ihvk_m4_DutchFlag", "vc-description": "", "vc-preamble": "datatype Color = Red | White | Blue\n\npredicate Below(c: Color, d: Color)\n{\n    c == Red || c == d || d == Blue\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DutchFlag(a: array<Color>)\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> Below(a[i], a[j])\n    ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_canyon_search_CanyonSearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CanyonSearch(a: array<int>, b: array<int>) returns (d:nat)\n  requires a.Length !=0 && b.Length!=0\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  requires forall i,j :: 0<=i<j<b.Length ==> b[i]<=b[j]\n  ensures exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n  ensures forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_113_IsInteger", "vc-description": "", "vc-preamble": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_230_ReplaceBlanksWithChar", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ReplaceBlanksWithChar(s: string, ch: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == ' ' ==> v[i] == ch) && (s[i] != ' ' ==> v[i] == s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_NoDups", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod NoDups (a : array<int>) returns (noDups : bool)\n    requires forall j : int :: 0 < j < a.Length ==> a[j-1] <= a[j] // a sorted\n    ensures noDups <==> forall j : int :: 1 <= j < a.Length ==> a[j-1] != a[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_max_array_maxArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_69_ContainsSequence", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ContainsSequence(list: seq<seq<int>>, sub: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |list| && sub == list[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_261_ElementWiseDivision", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ElementWiseDivision(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    requires forall i :: 0 <= i < |b| ==> b[i] != 0\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] / b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_170_SumInRange", "vc-description": "", "vc-preamble": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_412_RemoveOddNumbers", "vc-description": "", "vc-preamble": "/**\n * Remove odd numbers from an array of numbers\n **/\n\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0070-climbing-stairs_ClimbStairs", "vc-description": "", "vc-preamble": "function Stairs(n: nat): nat {\n  if n <= 1 then 1 else Stairs(n - 2) + Stairs(n - 1)\n}\n\n// A simple specification", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ClimbStairs(n: nat) returns (r: nat)\n  ensures r == Stairs(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_ProgrammingLanguages_tmp_tmp82_e0kji_ExtraCredit_optimizeCorrect", "vc-description": "", "vc-preamble": "datatype Exp = Const(int) | Var(string) | Plus(Exp, Exp) |  Mult(Exp, Exp)\n\nfunction eval(e:Exp, store:map<string, int>):int\n{\n    match(e)\n        case Const(n) => n\n        case Var(s) => if(s in store) then store[s] else -1\n        case Plus(e1, e2) => eval(e1, store) + eval(e2, store)\n        case Mult(e1, e2) => eval(e1, store) * eval(e2, store)\n}\n\n//fill this function in to make optimizeFeatures work\nfunction optimize(e:Exp):Exp\n{\n    match e\n    case Mult(Const(0), e) => Const(0)\n    case Mult(e, Const(0)) => Const(0)\n    case Mult(Const(1), e) => e\n    case Mult(e, Const(1)) => e\n    case Mult(Const(n1), Const(n2)) => Const(n1*n2)\n    case Plus(Const(0), e) => e\n    case Plus(e, Const(0)) => e\n    case Plus(Const(n1), Const(n2)) => Const(n1+ n2)\n    case e => e\n\n} \n\n//as you write optimize this will become unproved\n//you must write proof code so that Dafny can prove this", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod optimizeCorrect(e:Exp, s:map<string, int>)\nensures eval(e,s) == eval(optimize(e), s)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_QuickSort", "vc-description": "", "vc-preamble": "method Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    modifies a\n    ensures lo <= p < hi\n{\n  assume{:axiom} false;\n}\n\npredicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}\n\nmethod QuickSortAux(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures forall i,j :: lo <= i < j < hi ==> a[i] <= a[j]\n    ensures SwapFrame(a, lo, hi)\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    decreases hi - lo\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod QuickSort(a: array<int>)\n    modifies a\n    ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_Partition", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/GW7a\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://www.rise4fun.com/Dafny/JPGct\n\n// Klárið að forrita föllin tvö.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Partition( m: multiset<int> )\n        returns( pre: multiset<int>, p: int, post: multiset<int> )\n    requires |m| > 0;\n    ensures p in m;\n    ensures m == pre+multiset{p}+post;\n     ensures forall z | z in pre :: z <= p;\n     ensures forall z | z in post :: z >= p;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_reverse_Reverse", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a == old(a)\nensures b.Length == a.Length\nensures forall i :: 0 <= i < a.Length ==> b[i] == a[a.Length - i - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_slope_search_SlopeSearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SlopeSearch(a: array2<int>, key: int) returns (m:int, n:int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures 0<=m<a.Length0 && 0<=n<a.Length1\n  ensures a[m,n]==key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Longest_Increasing_Subsequence_longest_increasing_subsequence_longest_increasing_subsequence", "vc-description": "", "vc-preamble": "// Function\nfunction find_max(x: int, y: int): int\n{\n    if x > y then x\n    else y\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod longest_increasing_subsequence(nums: array<int>) returns (max: int)\n    requires 1 <= nums.Length <= 2500\n    requires forall i :: 0 <= i < nums.Length ==> -10000 <= nums[i] <= 10000\n    // TODO: modify the ensures clause so that max is indeed equal to the longest increasing subsequence\n    ensures max >= 1\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_triple3_Triple", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExercisePeekSum_mPeekSum", "vc-description": "", "vc-preamble": "predicate isPeek(v:array<int>,i:int)\n reads v\n requires 0<=i<v.Length\n {forall k::0<=k<i ==> v[i]>=v[k]}\n\n function peekSum(v:array<int>,i:int):int\n decreases i \n reads v\n requires 0<=i<=v.Length\n {\n  if (i==0) then 0\n  else if isPeek(v,i-1) then v[i-1]+peekSum(v,i-1)\n  else peekSum(v,i-1)\n }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mPeekSum(v:array<int>) returns (sum:int)\n requires  v.Length>0\n ensures sum==peekSum(v,v.Length)\n //Implement and verify an O(v.Length) algorithm to solve this problem\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchRecursive", "vc-description": "", "vc-preamble": "// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/CGB1z\n\n// Authors of solution:   Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/VnB5\n\n// Use the command\n//   dafny H2-skeleton.dfy\n// or\n//   compile H2-skeleton.dfy\n// to compile the file.\n// Or use the web page rise4fun.com/dafny.\n\n// When you have solved the problem put\n// the solution on the Dafny web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SearchRecursive( a: seq<real>, i: int, j: int, x: real ) returns ( k: int )\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    requires forall p, q :: i <= p < q < j ==> a[p] >= a[q];\n    ensures i <= k <= j\n    ensures forall r | i <= r < k :: a[r] >= x;\n    ensures forall r | k <= r < j :: a[r] < x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Ef eftirfarandi fall er ekki samþykkt þá eru\n// föllin ekki að haga sér rétt að mati Dafny."}
{"id": "Clover_has_close_elements_has_close_elements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  requires threshold >= 0.0\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_InsertionSortSeq_InsertionSort", "vc-description": "", "vc-preamble": "// Insertion sort.\n//\n// Author: Snorri Agnarsson, snorri@hi.is\n\n\npredicate IsSorted( s: seq<int> )\n{\n    forall p,q | 0<=p<q<|s| :: s[p]<=s[q]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertionSort( s: seq<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == multiset(s);\n    ensures IsSorted(r);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_two_sum_twoSum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod twoSum(nums: array<int>, target: int) returns (i: int, j: int)\n  requires nums.Length > 1\n  requires exists i,j::0 <= i < j < nums.Length &&  nums[i] + nums[j] == target\n  ensures 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length)  ==> nums[ii] + nums[jj] != target\n  ensures forall jj:: i < jj < j ==> nums[i] + nums[jj] != target\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0027-remove-element_RemoveElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveElement(nums: array<int>, val: int) returns (newLength: int)\n    modifies nums\n    ensures 0 <= newLength <= nums.Length\n    ensures forall x :: x in nums[..newLength] ==> x != val\n    ensures multiset(nums[..newLength]) == multiset(old(nums[..]))[val := 0]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_632_MoveZeroesToEnd", "vc-description": "", "vc-preamble": "method swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n{\n  assume{:axiom} false;\n}\n\nfunction count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MoveZeroesToEnd(arr: array<int>)\n    requires arr.Length >= 2\n    modifies arr\n    // Same size\n    ensures arr.Length == old(arr.Length)\n    // Zeros to the right of the first zero\n    ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] == 0 ==> arr[j] == 0\n    // The final array is a permutation of the original one\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n    // Relative order of non-zero elements is preserved\n    ensures forall n, m /* on old array */:: 0 <= n < m < arr.Length && old(arr[n]) != 0 && old(arr[m]) != 0 ==> \n            exists k, l /* on new array */:: 0 <= k < l < arr.Length && arr[k] == old(arr[n]) && arr[l] == old(arr[m])\n    //ensures IsOrderPreserved(arr[..], old(arr[..]))\n    // Number of zeros is preserved\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_599_SumAndAverage", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumAndAverage(n: int) returns (sum: int, average: real)\n    requires n > 0\n    ensures sum == n * (n + 1) / 2\n    ensures average == sum as real / n as real\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_290_MaxLengthList", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MaxLengthList(lists: seq<seq<int>>) returns (maxList: seq<int>)\n    requires |lists| > 0\n    ensures forall l :: l in lists ==> |l| <= |maxList|\n    ensures maxList in lists\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_233_CylinderLateralSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CylinderLateralSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * (radius * height) * 3.14\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Practice_tmp_tmphnmt4ovh_Pattern_Matching_FindAllOccurrences", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindAllOccurrences(text: string, pattern: string) returns (offsets: set<nat>)\n  ensures forall i:nat :: i in offsets ==> i + |pattern| <= |text|\n  ensures forall i:nat :: 0 <= i <= |text| - |pattern|\n                       ==> (text[i..i+|pattern|] == pattern <==> i in offsets)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_abs_Abs", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_629_FindEvenNumbers", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindEvenNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_gcdI", "vc-description": "", "vc-preamble": "//Problem01\nfunction fib(n: nat):nat\n{\n    if n < 2 then n else fib(n-2)+fib(n-1)\n}\n\n//# 2 pts\n\n//Problem02\nfunction fact(n:nat):nat\n{if n==0 then 1 else n*fact(n-1)}\n\n//# 3 pts\n//Problem03\nfunction gcd(m: nat, n: nat): nat\n    requires m > 0 && n > 0\n{\n    if m == n then m\n    else if m > n then gcd(m - n, n)\n    else gcd(m, n - m)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod gcdI(m: int, n: int) returns (g: int)\n    requires  m > 0 && n > 0 \n    ensures g == gcd(m, n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//# 3 pts\n\n\n// # sum: 9 pts"}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_insertionSort", "vc-description": "", "vc-preamble": "predicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}\n\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod insertionSort (a: array<int>)\n\n    modifies a\n    ensures sorted(a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_relativeOrder_FindEvenNumbers", "vc-description": "", "vc-preamble": "predicate IsEven (n: int)\n{\n  n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindEvenNumbers (arr: array<int>)\n  returns (evenNumbers: array<int>)\n  ensures forall x :: x in arr[..] && IsEven(x) ==> x in evenNumbers[..];\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n    ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n    exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_577_FactorialOfLastDigit", "vc-description": "", "vc-preamble": "function Factorial(n: int): int\n    requires n >= 0\n    ensures 0 <= Factorial(n)\n    {\n        if n == 0 then 1\n        else n * Factorial(n-1)\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FactorialOfLastDigit(n: int) returns (fact: int)\n    requires n >= 0\n    ensures fact == Factorial(n % 10)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_TP3_binary_search_binarySearch", "vc-description": "", "vc-preamble": "// Checks if array 'a' is sorted.\npredicate isSorted(a: array<int>)\n  reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n// Finds a value 'x' in a sorted array 'a', and returns its index,\n// or -1 if not found.\n\n// Simple test cases to check the post-condition.\n\n/*\na) Identify adequate pre and post-conditions for this method, \nand encode them as “requires” and “ensures” clauses in Dafny. \nYou can use the predicate below if needed.\n\nb) Identify an adequate loop variant and loop invariant, and encode them \nas “decreases” and “invariant” clauses in Dafny.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod binarySearch(a: array<int>, x: int) returns (index: int) \n    requires isSorted(a)\n    ensures -1 <= index < a.Length\n    ensures if index != -1 then a[index] == x \n        else x !in a[..] //forall i :: 0 <= i < a.Length ==> a[i] != x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_HoareTripleReqEns", "vc-description": "", "vc-preamble": "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod HoareTripleReqEns(i: int, k: int) returns (k': int)\n    // (| k == i*i |) k := k + 2 * i +1; (| k = (i+1)*(i+1) |)\n    requires  k == i*i\n    ensures  k' == (i+1)*(i+1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_142_CountIdenticalPositions", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountIdenticalPositions(a: seq<int>, b: seq<int>, c: seq<int>) returns (count: int)\n    requires |a| == |b| && |b| == |c|\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |a| && a[i] == b[i] && b[i] == c[i]|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session5Exercises_ExerciseSumElems_sumElems", "vc-description": "", "vc-preamble": "function SumR(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\ndecreases s\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\n\nfunction SumV(v:array<int>,c:int,f:int):int\n  requires 0<=c<=f<=v.Length\n  reads v\n  {\n    SumR(v[c..f])\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sumElems(v:array<int>) returns (sum:int)\n//ensures sum==SumL(v[0..v.Length])\nensures sum==SumR(v[..])\n//ensures sum==SumV(v,0,v.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_FindZero", "vc-description": "", "vc-preamble": "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n  requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n  ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n  ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_selectionsort_SelectionSort", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_238_CountNonEmptySubstrings", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountNonEmptySubstrings(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == (|s| * (|s| + 1)) / 2 // Formula for the number of non-empty substrings of a string\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_MatrixMultiplication_multiply", "vc-description": "", "vc-preamble": "function RowColumnProduct(m1: array2<int>, m2: array2<int>, row: nat, column: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n{\n    RowColumnProductFrom(m1, m2, row, column, 0)\n}\n\nfunction RowColumnProductFrom(m1: array2<int>, m2: array2<int>, row: nat, column: nat, k: nat): int\n    reads m1\n    reads m2\n    requires m1 != null && m2 != null && k <= m1.Length1 == m2.Length0\n    requires row < m1.Length0 && column < m2.Length1\n    decreases m1.Length1 - k\n{\n    if k == m1.Length1 then\n        0\n    else\n        m1[row,k]*m2[k,column] + RowColumnProductFrom(m1, m2, row, column, k+1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod multiply(m1: array2<int>, m2: array2<int>) returns (m3: array2<int>)\n    requires m1 != null && m2 != null\n    requires m1.Length1 == m2.Length0\n    ensures m3 != null && m3.Length0 == m1.Length0 && m3.Length1 == m2.Length1\n    ensures forall i, j | 0 <= i < m3.Length0 && 0 <= j < m3.Length1 ::\n        m3[i, j] == RowColumnProduct(m1, m2, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_801_CountEqualNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountEqualNumbers(a: int, b: int, c: int) returns (count: int)\n    ensures count >= 0 && count <= 3\n    ensures (count == 3) <==> (a == b && b == c)\n    ensures (count == 2) <==> ((a == b && b != c) || (a != b && b == c) || (a == c && b != c))\n    ensures (count == 1) <==> (a != b && b != c && a != c)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insertRecursion", "vc-description": "", "vc-preamble": "datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition_QuicksortPartition", "vc-description": "", "vc-preamble": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\n\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_ProdAndCount_ProdAndCount", "vc-description": "", "vc-preamble": "\nfunction RecursivePositiveProduct(q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 1\n    else if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n    else q[0] * RecursivePositiveProduct(q[1..])\n}\n\nfunction RecursiveCount(key: int, q: seq<int>): int\n    decreases |q|\n{\n    if q == [] then 0\n    else if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])\n    else RecursiveCount(key, q[..|q|-1])\n}\n\nfunction county(elem: int, key: int): int{\n    if elem==key then 1 else 0\n}\n\nfunction prody(elem: int): int{\n    if elem <= 0 then 1 else elem\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ProdAndCount(q: seq<int>, key: int) returns (prod: int, count: nat)\n    ensures prod == RecursivePositiveProduct(q)\n    ensures count == RecursiveCount(key, q)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_FindRange_FindRange", "vc-description": "", "vc-preamble": "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\n// all the values in the range satisfy `comparer` (comparer(q[i], key) == true)\npredicate RangeSatisfiesComparer(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    forall i :: lowerBound <= i < upperBound ==> comparer(q[i], key)\n}\n\n// all the values in the range satisfy `!comparer` (comparer(q[i], key) == false)\npredicate RangeSatisfiesComparerNegation(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool)\n    requires 0 <= lowerBound <= upperBound <= |q|\n{\n    RangeSatisfiesComparer(q, key, lowerBound, upperBound, (n1, n2) => !comparer(n1, n2))\n}\n\nmethod BinarySearch(q: seq<int>, key: int, lowerBound: nat, upperBound: nat, comparer: (int, int) -> bool) returns (index: nat)\n    requires Sorted(q)\n    requires 0 <= lowerBound <= upperBound <= |q|\n    requires RangeSatisfiesComparerNegation(q, key, 0, lowerBound, comparer)\n    requires RangeSatisfiesComparer(q, key, upperBound, |q|, comparer)\n    // comparer is '>' or '>='\n    requires\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >  n2)) ||\n        (forall n1, n2 :: comparer(n1, n2) == (n1 >= n2))\n\n    ensures lowerBound <= index <= upperBound\n    ensures RangeSatisfiesComparerNegation(q, key, 0, index, comparer)\n    ensures RangeSatisfiesComparer(q, key, index, |q|, comparer)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindRange(q: seq<int>, key: int) returns (left: nat, right: nat)\n    requires Sorted(q)\n    ensures left <= right <= |q|\n    ensures forall i :: 0 <= i < left ==> q[i] < key\n    ensures forall i :: left <= i < right ==> q[i] == key\n    ensures forall i :: right <= i < |q| ==> q[i] > key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier_barrier", "vc-description": "", "vc-preamble": "//Method barrier below receives an array and an integer p\n//and returns a boolean b which is true if and only if \n//all the positions to the left of p and including also position p contain elements \n//that are strictly smaller than all the elements contained in the positions to the right of p \n\n//Examples:\n// If v=[7,2,5,8] and p=0 or p=1 then the method must return false, \n// but for p=2 the method should return true\n//1.Specify the method\n//2.Implement an O(v.size()) method\n//3.Verify the method", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod barrier(v:array<int>,p:int) returns (b:bool)\n//Give the precondition\n//Give the postcondition\n//{Implement and verify}\nrequires v.Length > 0\nrequires 0<=p<v.Length\nensures b==forall k,l::0<=k<=p && p<l<v.Length ==> v[k]<v[l]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_784_FirstEvenOddIndices", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n    // This is the postcondition that ensures that it's the first, not just any\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionnSort", "vc-description": "", "vc-preamble": "twostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SelectionnSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_452_CalculateLoss", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CalculateLoss(costPrice: int, sellingPrice: int) returns (loss: int)\n    requires costPrice >= 0 && sellingPrice >= 0\n    ensures (costPrice > sellingPrice ==> loss == costPrice - sellingPrice) && (costPrice <= sellingPrice ==> loss == 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_644_Reverse", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Reverse(a: array<int>)\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length-1) - k]);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_FIND", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\n\n// A version of Turing's additive factorial program [Dr. A. Turing, \"Checking a large routine\",\n// In \"Report of a Conference of High Speed Automatic Calculating Machines\", pp. 67-69, 1949].\n\nghost function Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}\n\n\n// Hoare's FIND program [C.A.R. Hoare, \"Proof of a program: FIND\", CACM 14(1): 39-45, 1971].\n// The proof annotations here are not the same as in Hoare's article.\n\n// In Hoare's words:\n//   This program operates on an array A[1:N], and a value of f (1 <= f <= N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).\n//\n// Here, we use 0-based indices, so we would say:\n//   This method operates on an array A[0..N], and a value of f (0 <= f < N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FIND(A: array<int>, N: int, f: int)\n  requires A.Length == N;\n  requires 0 <= f < N;\n  modifies A;\n  ensures forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[q];\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p5_partition", "vc-description": "", "vc-preamble": "type T = int // example\n\n // Partitions a nonempty array 'a', by reordering the elements in the array,\n// so that elements smaller than a chosen pivot are placed to the left of the\n// pivot, and values greater or equal than the pivot are placed to the right of \n// the pivot. Returns the pivot position.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod partition(a: array<T>) returns(pivotPos: int) \n    requires a.Length > 0\n    ensures 0 <= pivotPos < a.Length\n    ensures forall i :: 0 <= i < pivotPos ==> a[i] < a[pivotPos]\n    ensures forall i :: pivotPos < i < a.Length ==> a[i] >= a[pivotPos]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    modifies a\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_longest_prefix_LongestCommonPrefix", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n  ensures |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  ensures |prefix|==|str1| || |prefix|==|str2| || (str1[|prefix|]!=str2[|prefix|])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_automaton_ExecuteAutomaton", "vc-description": "", "vc-preamble": "/**\nConsider cellular automata: a row of cells is repeatedly updated according to a rule. In this exercise I dabbled with,\neach cell has the value either false or true. Each cell's next state depends only on the immediate neighbours, in the \ncase where the cell is at the edges of the row, the inexistent neighbours are replaced by \"false\". The automaton table \nwill contain the initial row, plus a row for each number of steps.\n */\nclass Automaton {\n\n/**\nThis method computes the automaton.\nProvide the initial row: init, the rule and the desired number of steps\n */\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ExecuteAutomaton(init: seq<bool>, rule: (bool, bool, bool) -> bool, steps: nat)\n  returns (table: seq<seq<bool>>)\n  // we need the initial row to have the length bigger or equal to two\n  requires |init| >= 2\n  // after computation the automaton is made of the initial row plus a row for each of the steps\n  ensures |table| == 1 + steps\n  // the automaton must have the initial row at the top\n  ensures table[0] == init;\n  // all rows in the automaton must be the same length\n  ensures forall i | 0 <= i < |table| :: |table[i]| == |init|\n  // all the middle row elements (with existing neighbours) after a step, will be equal to the rule applied on the element in the previous state\n  // and its neigbours\n  ensures forall i | 0 <= i < |table| - 1 ::\n            forall j | 1 <= j <= |table[i]| - 2 :: table[i + 1][j] == rule(table[i][j - 1], table[i][j], table[i][j + 1])\n  // the corner row elements (with non-existing neighbours) after a step, will be equal to the rule applied on the element in the previous state,\n  // its neighbour and false\n  ensures forall i | 0 <= i < |table| - 1 ::\n            table[i + 1][0] == rule(false, table[i][0], table[i][1]) && table[i + 1][|table[i]| - 1] == rule(table[i][|table[i]| - 2], table[i][|table[i]| - 1], false)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_SumIntsLoop_SumIntsLoop", "vc-description": "", "vc-preamble": "function sumInts( n: int ): int\n    requires n >= 0;\n{\n    if n == 0 then\n        0\n    else\n        sumInts(n-1)+n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumIntsLoop( n: int ) returns ( s: int )\n    requires n >= 0;\n    ensures s == sumInts(n)\n    ensures s == n*(n+1)/2;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_441_CubeSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CubeSurfaceArea(size: int) returns (area: int)\n    requires size > 0\n    ensures area == 6 * size * size\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_min_of_two_Min", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Sorter", "vc-description": "", "vc-preamble": "// see pdf 'ex6 & 7 documentation' for excercise question\n\n\ndatatype Bases = A | C | G | T\n\n//swaps two sequence indexes\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n{\n  assume{:axiom} false;\n}\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\n//checks if a sequence is in base order\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Sorter(bases: seq<Bases>) returns (sobases:seq<Bases>)\nrequires 0 < |bases|\nensures |sobases| == |bases|\nensures bordered(sobases)\nensures multiset(bases) == multiset(sobases);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex2_String3Sort", "vc-description": "", "vc-preamble": "// verifies\n// check that string between indexes low and high-1 are sorted\npredicate Sorted(a: string, low:int, high:int)\nrequires 0 <= low <= high <= |a|\n{ \n    forall j, k :: low <= j < k < high ==> a[j] <= a[k] \n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod String3Sort(a: string) returns (b: string) \nrequires |a| == 3;\nensures Sorted(b, 0, |b|);\nensures |a| == |b|;\nensures multiset{b[0], b[1], b[2]} == multiset{a[0], a[1], a[2]};\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_linear_search2_LinearSearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeSort", "vc-description": "", "vc-preamble": "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\nmethod Merge(b: array<int>, c: array<int>, d: array<int>)\n    requires b != c && b != d && b.Length == c.Length + d.Length\n    requires Sorted(c[..]) && Sorted(d[..])\n    ensures Sorted(b[..]) && multiset(b[..]) == multiset(c[..])+multiset(d[..])\n    modifies b\n{\n  assume{:axiom} false;\n}\n\n\n//This is a method that replace the loop body\n\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MergeSort(a: array<int>) returns (b: array<int>)\n    ensures b.Length == a.Length && Sorted(b[..]) && multiset(a[..]) == multiset(b[..])\n    decreases a.Length\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_Sort", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/dtcnY\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/ybUCz\n\n///////////////////////////////////////////////////////////////\n// Hér byrjar óbreytanlegi hluti skrárinnar.\n// Fyrir aftan þann hluta er sá hluti sem þið eigið að breyta.\n///////////////////////////////////////////////////////////////\n\n// Hjálparfall sem finnur minnsta gildi í poka\n\nmethod MinOfMultiset( m: multiset<int> ) returns( min: int )\n    ensures min in m;\n    ensures forall z | z in m :: min <= z;\n{\n  assume{:axiom} false;\n}\n\n// Ekki má breyta þessu falli.\n\n\n///////////////////////////////////////////////////////////////\n// Hér lýkur óbreytanlega hluta skrárinnar.\n// Hér fyrir aftan er sá hluti sem þið eigið að breyta til að\n// útfæra afbrigði af selection sort.\n///////////////////////////////////////////////////////////////\n\n// Selection sort sem raðar poka í runu.\n// Klárið að forrita þetta fall.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Sort( m: multiset<int> ) returns ( s: seq<int> )\n    // Setjið viðeigandi ensures klausur hér\n    ensures multiset(s) == m;\n    ensures forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex2_Getmini", "vc-description": "", "vc-preamble": "/*\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Getmini(a:array<int>) returns(mini:nat) \nrequires a.Length > 0\nensures 0 <= mini < a.Length // mini is an index of a\nensures forall x :: 0 <= x < a.Length ==> a[mini] <= a[x] // a[mini] is the minimum value\nensures forall x :: 0 <= x < mini ==> a[mini] < a[x] // a[mini] is the first min\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsPrime", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsPrime (m : int) returns (isPrime : bool)\n    requires m > 0 // m must be greater than 0\n    ensures isPrime <==> (m > 1 && forall j : int :: 2 <= j < m ==> m % j != 0) \n    // ensures states that \"isPrime is true iff m > 1 && not divisible by [2, m-1)\"\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates."}
{"id": "BinarySearchTree_tmp_tmp_bn2twp5_bst4copy_insert", "vc-description": "", "vc-preamble": "datatype Tree = Empty | Node(left: Tree, value: int, right: Tree)\n\npredicate BinarySearchTree(tree: Tree)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(_,_,_) =>\n    (tree.left == Empty || tree.left.value < tree.value)\n    && (tree.right == Empty || tree.right.value > tree.value)\n    && BinarySearchTree(tree.left) && BinarySearchTree(tree.right)\n    && minValue(tree.right, tree.value) && maxValue(tree.left, tree.value)\n}\n\npredicate maxValue(tree: Tree, max: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (max > v) && maxValue(left, max) && maxValue(right, max)\n}\n\npredicate minValue(tree: Tree, min: int)\n  decreases tree\n{\n  match tree\n  case Empty => true\n  case Node(left,v,right) => (min < v) && minValue(left, min) && minValue(right, min)\n}\n\nmethod insertRecursion(tree: Tree, value: int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures res != Empty ==> BinarySearchTree(res)\n  ensures forall x :: minValue(tree, x) && x < value ==> minValue(res, x)\n  ensures forall x :: maxValue(tree, x) && x > value ==> maxValue(res, x)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod insert(tree: Tree, value : int) returns (res: Tree)\n  requires BinarySearchTree(tree)\n  decreases tree;\n  ensures BinarySearchTree(res)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\n// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci1", "vc-description": "", "vc-preamble": "function fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod fibonacci1(n:nat) returns (f:nat)\nensures f==fib(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IntDiv", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IntDiv (m : int, n : int) returns (d : int, r : int)\n    requires n > 0\n    ensures m == n * d + r && 0 <= r < n // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates."}
{"id": "Dafny-Projects_tmp_tmph399drhy_p2_arraySplit_ArraySplit", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ArraySplit (a : array<int>) returns (b : array<int>, c : array<int>)\n  ensures fresh(b)\n  ensures fresh(c)\n  ensures a[..] == b[..] + c[..]\n  ensures a.Length == b.Length + c.Length\n  ensures a.Length > 1 ==> a.Length > b.Length\n  ensures a.Length > 1 ==> a.Length > c.Length\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_MergeSort_MergeLoop", "vc-description": "", "vc-preamble": "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n\n\npredicate Sorted(q: seq<int>) {\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j]\n}\n\n/*\nGoal: Implement the well known merge sort algorithm in O(a.Length X log_2(a.Length)) time, recursively.\n\n- Divide the contents of the original array into two local arrays\n- After sorting the local arrays (recursively), merge the contents of the two returned arrays using the Merge method (see below)\n- DO NOT modify the specification or any other part of the method's signature\n- DO NOT introduce any further methods\n*/\n\nghost predicate Inv(a: seq<int>, a1: seq<int>, a2: seq<int>, i: nat, mid: nat){\n    (i <= |a1|) && (i <= |a2|) && (i+mid <= |a|) &&\n    (a1[..i] == a[..i]) && (a2[..i] == a[mid..(i+mid)])\n}\n\n\n/*\nGoal: Implement iteratively, correctly, efficiently, clearly\n\nDO NOT modify the specification or any other part of the method's signature\n*/\n\n\n//This is a method that replace the loop body\n\n//Loop invariant - b is sprted so far and the next two potential values that will go into b are bigger then the biggest value in b.\nghost predicate InvSorted(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    ((i+j > 0 && i < |c|) ==> (b[j + i - 1] <= c[i])) &&\n    ((i+j > 0 && j < |d|) ==> (b[j + i - 1] <= d[j])) &&\n    Sorted(b[..i+j])\n    }\n\n\n//Loop invariant - the multiset of the prefix of b so far is the same multiset as the prefixes of c and d so far.\nghost predicate InvSubSet(b: seq<int>, c: seq<int>, d: seq<int>, i: nat, j: nat){\n    i <= |c| && j <= |d| && i + j <= |b| &&\n    multiset(b[..i+j]) == multiset(c[..i]) + multiset(d[..j])\n}\n\n//This lemma helps dafny see that if the prefixs of arrays are the same multiset until the end of the arrays,\n//all the arrays are the same multiset.\n\n\n//This lemma helps dafny see that after adding the next value from c to b the prefixes are still the same subsets.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MergeLoop(b: array<int>, c: array<int>, d: array<int>,i0: nat , j0: nat)  returns (i: nat, j: nat)\n        requires b != c && b != d && b.Length == c.Length + d.Length\n        requires Sorted(c[..]) && Sorted(d[..])\n        requires i0 <= c.Length && j0 <= d.Length && i0 + j0 <= b.Length\n        requires InvSubSet(b[..],c[..],d[..],i0,j0)\n        requires InvSorted(b[..],c[..],d[..],i0,j0)\n        requires i0 + j0 < b.Length\n\n        modifies b\n\n        ensures i <= c.Length && j <= d.Length && i + j <= b.Length\n        ensures InvSubSet(b[..],c[..],d[..],i,j)\n        ensures InvSorted(b[..],c[..],d[..],i,j)\n        //decreases ensures\n        ensures 0 <= c.Length - i < c.Length - i0 || (c.Length - i == c.Length - i0 && 0 <= d.Length - j < d.Length - j0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_603_LucidNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_470_PairwiseAddition", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PairwiseAddition(a: array<int>) returns (result: array<int>)\n    requires a != null\n    requires a.Length % 2 == 0\n    ensures result != null\n    ensures result.Length == a.Length / 2\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[2*i] + a[2*i + 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_770_SumOfFourthPowerOfOddNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumOfFourthPowerOfOddNumbers(n: int) returns (sum: int)\n    requires n > 0\n    ensures sum == n * (2 * n + 1) * (24 * n * n * n - 12 * n * n  - 14 * n + 7) / 15\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountEven_mcountEven", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{\n  forall u::0<=u<|s| ==> s[u]>=0\n  }\n\npredicate isEven(i:int)\nrequires i>=0\n{\n  i%2==0\n}\n\nfunction CountEven(s:seq<int>):int\ndecreases s\nrequires positive(s)\n{\n  if s==[] then 0\n  else (if (s[|s|-1]%2==0) then 1 else 0)+CountEven(s[..|s|-1])\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mcountEven(v:array<int>) \nreturns (n:int)\nrequires positive(v[..])\nensures  n==CountEven(v[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_threshold", "vc-description": "", "vc-preamble": "predicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_bubblesort_BubbleSort", "vc-description": "", "vc-preamble": "//https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny\nfunction NChoose2(n: int): int\n{\n  n * (n - 1) / 2\n}\n\n// sum of all integers in the range [lo, hi)\n// (inclusive of lo, exclusive of hi)\nfunction SumRange(lo: int, hi: int): int\n  decreases hi - lo\n{\n  if lo >= hi then 0\n  else SumRange(lo, hi - 1) + hi - 1\n}\n\n// dafny proves this automatically by induction", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BubbleSort(a: array<int>) returns (n: nat) \n  modifies a\n  ensures n <= NChoose2(a.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_InsertionSort_InsertionSort", "vc-description": "", "vc-preamble": "predicate sorted (a:array<int>, start:int, end:int) // all \"before\" end are sorted      \n requires a!=null       \n requires 0<=start<=end<=a.Length       \n reads a       \n {           \n   forall j,k:: start<=j<k<end ==> a[j]<=a[k]\n }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertionSort (a:array<int>)\nrequires a!=null && a.Length>1 \nensures sorted(a, 0, a.Length) \nmodifies a\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "BelowZero_BelowZero", "vc-description": "", "vc-preamble": "/* \nHumanEvalX 3\nYou're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. \nYour task is to detect if at any point the balance of account falls below zero, and at that point function \nshould return True. Otherwise it should return False.\n*/\n\nfunction sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BelowZero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven_partitionOddEven", "vc-description": "", "vc-preamble": "// Rearranges the elements in an array 'a' of natural numbers,\n// so that all odd numbers appear before all even numbers.\n\npredicate  odd(n: nat) { n % 2 == 1 }\npredicate  even(n: nat) { n % 2 == 0 }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod partitionOddEven(a: array<nat>) \n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures ! exists i, j :: 0 <= i < j < a.Length && even(a[i]) && odd(a[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_selectionSort", "vc-description": "", "vc-preamble": "//Problem01\n//a)\n\n//b)\n//Problem04\n\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n{\n  assume{:axiom} false;\n}\n\n//Problem02\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod selectionSort(a: array<int>)\n    modifies a\n    //ensures multiset(a[..]) == multiset(old(a[..]))\n    //ensures sorted(a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Problem03"}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_ProgramProofs_ch15_Partition", "vc-description": "", "vc-preamble": "predicate SplitPoint(a: array<int>, n: int)\n    reads a\n    requires 0 <= n <= n\n\n{\n    forall i,j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n}\n\n\n\ntwostate predicate SwapFrame(a: array<int>, lo: int, hi: int)\n    requires 0 <= lo <= hi <= a.Length\n    reads a\n{\n    (forall i :: 0 <= i < lo || hi <= i < a.Length ==> a[i] == old(a[i])) && multiset(a[..]) == old(multiset(a[..]))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Partition(a: array<int>, lo: int, hi: int) returns (p: int)\n    requires 0 <= lo < hi <= a.Length\n    requires SplitPoint(a, lo) && SplitPoint(a, hi)\n    modifies a\n    ensures lo <= p < hi\n    ensures forall i :: lo <= i < p ==> a[i] < a[p]\n    ensures forall i :: p <= i < hi ==> a[p] <= a[i]\n    ensures SplitPoint(a, lo) && SplitPoint(a, hi)\n    ensures SwapFrame(a, lo, hi)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_SelectionSort_SelectionSort", "vc-description": "", "vc-preamble": "twostate predicate Preserved(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    multiset(a[left..right]) == multiset(old(a[left..right]))\n}\n\nghost predicate Ordered(a: array<int>, left: nat, right: nat)\n    reads a\n    requires left <= right <= a.Length\n{\n    forall i: nat :: 0 < left <= i < right ==> a[i-1] <= a[i]\n}\n\ntwostate predicate Sorted(a: array<int>)\n    reads a\n{\n    Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SelectionSort(a: array<int>)\n    modifies a\n    ensures Sorted(a)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_merge", "vc-description": "", "vc-preamble": "predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod merge(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires end - start == |a1| + |a2|\n  requires 0 <= start < end < |a1| && end <= |a2| < b.Length\n  requires end < |a1| && end < |a2|\n  ensures sorted_slice(b, start, end)\n  requires b.Length == |a2| + |a1|\n  ensures merged(a1, a2, b, start, end)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_793_LastPosition", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_max_array_max", "vc-description": "", "vc-preamble": "// http://verifythus.cost-ic0701.org/common-example/arraymax-in-dafny", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod max(a:array<int>) returns(max:int)\n    requires a != null;\n    ensures forall j :: j >= 0 && j < a.Length ==> max >= a[j]; //max is larger then anything in the array\n    ensures a.Length > 0 ==> exists j :: j >= 0 && j < a.Length && max == a[j]; //max is an element in the array\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_return_seven_M", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod M(x: int) returns (seven: int)\n  ensures seven==7\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_max_max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod max(a: array<int>, b: array<int>, i: int, j: int)\n  returns (m: int)\n  requires 0 <= i < a.Length\n  requires 0 <= j < b.Length\n  ensures  a[i] > b[j] ==> m == a[i]\n  ensures  a[i] <= b[j] ==> m == b[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_isAnagram", "vc-description": "", "vc-preamble": "method toMultiset(s: string) returns (mset: multiset<char>)\n    ensures multiset(s) == mset\n{\n  assume{:axiom} false;\n}\n\nmethod msetEqual(s: multiset<char>, t: multiset<char>) returns (equal: bool)\n    ensures s == t <==> equal\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod isAnagram(s: string, t: string) returns (equal: bool)\n    ensures (multiset(s) == multiset(t)) == equal\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_622_FindMedian", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindMedian(a: array<int>, b: array<int>) returns (median: int)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    requires a.Length > 0\n    requires forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n    requires forall i :: 0 <= i < b.Length - 1 ==> b[i] <= b[i + 1]\n    ensures median == if (a.Length % 2 == 0) then (a[a.Length / 2 - 1] + b[0]) / 2 else a[a.Length / 2]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session9Exercises_ExerciseSeqMaxSum_segMaxSum", "vc-description": "", "vc-preamble": "function Sum(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j\n{\n    if (i==j) then 0\n    else Sum(v,i,j-1)+v[j-1]\n}\n\npredicate SumMaxToRight(v:array<int>,i:int,s:int)\nreads v\nrequires 0<=i<v.Length\n{\nforall l,ss {:induction l}::0<=l<=i && ss==i+1==> Sum(v,l,ss)<=s\n}\n\nfunction Sum2(v:array<int>,i:int,j:int):int\nreads v\nrequires 0<=i<=j<=v.Length\ndecreases j-i\n{\n    if (i==j) then 0\n    else v[i]+Sum2(v,i+1,j)\n}\n\n//Now do the same but with a loop from right to left\npredicate SumMaxToRight2(v:array<int>,j:int,i:int,s:int)//maximum sum stuck to the right\nreads v\nrequires 0<=j<=i<v.Length\n{(forall l,ss {:induction l}::j<=l<=i && ss==i+1 ==> Sum2(v,l,ss)<=s)}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod segMaxSum(v:array<int>,i:int) returns (s:int,k:int)\nrequires v.Length>0 && 0<=i<v.Length\nensures 0<=k<=i && s==Sum(v,k,i+1) &&  SumMaxToRight(v,i,s)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_intDiv", "vc-description": "", "vc-preamble": "//Problem 01\n\n//problem02\n//a)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod intDiv(n:int, d:int) returns (q:int, r:int)\nrequires n >= d && n >= 0 && d > 0 ;\nensures (d*q)+r == n && 0 <= q <= n/2 && 0 <= r < d; \n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_mt2_19_p4_calcR", "vc-description": "", "vc-preamble": "function R(n: nat): nat {\n    if n == 0 then 0 else if R(n-1) > n then R(n-1) - n else R(n-1) + n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod calcR(n: nat) returns (r: nat)\n    ensures r == R(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sorted_Standard_sorting", "vc-description": "", "vc-preamble": "predicate InsertionSorted(Array: array<int>, left: int, right: int)  \n  requires 0 <= left <= right <= Array.Length       \n  reads Array       \n{           \n  forall i,j :: left <= i < j < right ==> Array[i] <= Array[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sorting(Array: array<int>)\n  requires Array.Length > 1 \n  ensures InsertionSorted(Array, 0, Array.Length) \n  modifies Array\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_F1a_Mid", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Mid( p: int, q: int) returns ( m: int )\n    // | ... | ??? | ... |\n    //        p m   q\n    requires p <= q;\n    ensures p<= m <= q;\n    ensures m-p <= q-m;\n    ensures 0 <= (q-m)-(m-p) <= 1;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_verified_algorithms_lol_sort_lol_sort", "vc-description": "", "vc-preamble": "// By `lol sort` here, I refer to a seemingly-broken sorting algorithm,\n// which actually somehow manages to work perfectly:\n//\n// for i in 0..n\n//   for j in 0..n\n//     if i < j\n//       swap a[i], a[j]\n//\n// It is perhaps the simpliest sorting algorithm to \"memorize\",\n// even \"symmetrically beautiful\" as if `i` and `j` just played highly\n// similar roles. And technically it's still O(n^2) time lol...\n//\n// Proving its correctness is tricky (interesting) though.\n\n// Successfully verified with [Dafny 3.3.0.31104] in about 5 seconds.\n\n\n\n// We define \"valid permutation\" using multiset:\n\npredicate valid_permut(a: seq<int>, b: seq<int>)\n  requires |a| == |b|\n{\n  multiset(a) == multiset(b)\n}\n\n// This is a swap-based sorting algorithm, so permutedness is trivial:\n// note that: if i == j, the spec just says a[..] remains the same.\nmethod swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[..] == old(a[..]) [i := old(a[j])] [j := old(a[i])]\n  ensures valid_permut(a[..], old(a[..]))\n{\n  assume{:axiom} false;\n}\n\n// We then define \"sorted\" (by increasing order):\npredicate sorted(a: seq<int>)\n{\n  forall i, j | 0 <= i <= j < |a| :: a[i] <= a[j]\n}\n\n\n// Now, the lol sort algorithm:\n// (Some invariants were tricky to find, but Dafny was smart enough otherwise)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod lol_sort(a: array<int>)\n  modifies a\n  ensures valid_permut(a[..], old(a[..]))\n  ensures sorted(a[..])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent_Tangent", "vc-description": "", "vc-preamble": "/**\n  Ather, Mohammad Faiz (s4648481/3)\n  CSSE3100\n  Assignemnt 3\n  The University of Queensland\n */\n\n// Question 1\n\n// Author: Leino, Title: Program Proofs\nmethod BinarySearch(a: array<int>, circle: int)\n  returns (n: int)\n  requires forall i ::\n           1 <= i < a.Length\n           ==> a[i-1] < a[i]\n  requires forall i, j ::\n           0 <= i < j < a.Length ==>\n           a[i] < a[j]\n  ensures 0 <= n <= a.Length\n  ensures forall i ::\n          0 <= i < n ==>\n          a[i] < circle\n  ensures forall i ::\n          n <= i < a.Length ==>\n          circle <= a[i]\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Tangent(r: array<int>, x: array<int>)\n  returns (found: bool)\n  requires forall i:: 1 <= i < x.Length ==> \n           x[i-1] < x[i]\n  requires forall i, j ::\n           0 <= i < j < x.Length ==>\n           x[i] < x[j]\n  ensures !found ==>\n          forall i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length ==>\n          r[i] != x[j]\n  ensures found ==>\n          exists i,j ::\n          0 <= i < r.Length &&\n          0 <= j < x.Length &&\n          r[i] == x[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin_mCountMin", "vc-description": "", "vc-preamble": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\n\n\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Counting_Bits_counting_bits_counting_bits", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod counting_bits(n: int) returns (result: array<int>)\n    requires 0 <= n <= 100000\n    ensures result.Length == n + 1\n    ensures forall i :: 1 <= i < n + 1 ==> result[i] == result[i / 2] + i % 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_555_DifferenceSumCubesAndSumNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DifferenceSumCubesAndSumNumbers(n: int) returns (diff: int)\n    requires n >= 0\n    ensures diff == (n * n * (n + 1) * (n + 1)) / 4 - (n * (n + 1)) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_240_ReplaceLastElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ReplaceLastElement(first: seq<int>, second: seq<int>) returns (result: seq<int>)\n    requires |first| > 0\n    ensures |result| == |first| - 1 + |second|\n    ensures forall i :: 0 <= i < |first| - 1 ==> result[i] == first[i]\n    ensures forall i :: |first| - 1 <= i < |result| ==> result[i] == second[i - |first| + 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex2_Allow42", "vc-description": "", "vc-preamble": "/*\n    i)  Write a verified method with signature", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Allow42(x:int, y:int) returns (z: int, err:bool) \nensures y != 42 ==> z == x/(42-y) && err == false;\nensures y == 42 ==> z == 0 && err == true;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n    // Check that both strings are larger than k \n    if (k > |str1| || k > |str2| ){\n        return false;\n    }\n    // Initialize variables\n    var i := 0;\n    var temp := false;\n\n    // Don't want to exceed the bounds of str1 when checking for the element that is k entries away\n    while i <= |str1|-k\n    // Invariant to stay within bounds\n    invariant 0 <= i <= (|str1|-k) + 1\n    // Invariant to show that when temp is true, it is a substring\n    invariant temp ==> 0 <= i <= (|str1| - k) && isSubstringPred(str1[i..i+k], str2)\n    // Invariant to show that when temp is false, it is not a substring\n    invariant !temp ==> (forall m,n :: (0 <= m < i && n == m+k) ==> isNotSubstringPred(str1[m..n], str2))\n    // Telling dafny that i is that value that is increasing\n    decreases |str1| - k - i\n    {\n        assume false;\n\n        // Get an index from the array position were are at to the array position that is k away and check the substring\n        temp := isSubstring(str1[i..(i + k)], str2);\n        if  temp == true \n        {\n            return true;\n        }\n        i := i + 1;\n    }\n    return false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_567_IsSorted", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsSorted(a: array<int>) returns (sorted: bool)\n    requires a.Length > 0\n    ensures sorted <== forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures !sorted ==> exists i, j :: 0 <= i < j < a.Length && a[i] > a[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_flex_ex1_sum", "vc-description": "", "vc-preamble": "// sums from index 0 -> i - 1\nfunction sumcheck(s: array<int>, i: int): int\nrequires 0 <= i <= s.Length\nreads s\n{\n    if i == 0 then 0\n    else s[i - 1] + sumcheck(s, i - 1)\n}\n\n// returns sum of array", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sum(s: array<int>) returns (a:int)\nrequires s.Length > 0\nensures sumcheck(s, s.Length) == a\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_power_compute_power", "vc-description": "", "vc-preamble": "//power -- Stephanie Renee McIntyre\n//Based on the code used in the course overheads for Fall 2018\n\n//There is no definition for power, so this function will be used for validating that our imperative program is correct.\n\n/* Proof of implied (a): Follows from definition of the power function. */\n\n/* Proof of implied (b): Details left as exercise, but this is relatively simple. */\n\n/* Proof of implied (c): Simple substitution and uses the fact that i=n. */\n\n/* Proof of termination: the loop guard gives us the expression i<n. This is equivalent to n-i>=0.\n   Prior to the loop, n>=0 and i=0.\n   Each iteration of the loop, i increases by 1 and thus n-i decreases by 1. Thus n-i will eventually reach 0.\n   When the n-i=0, n=i and thus the loop guard ends the loop as it is no longer the case that i<n.\n   Thus the program terminates.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nfunction power(a: int, n: int): int //function for a to the power of n\n  requires 0 <= a && 0 <= n;\n  decreases n;{if (n == 0) then 1 else a * power(a, n - 1)}\n\n//Our code from class\nmethod compute_power(a: int, n: int) returns (s: int)\n/*Pre-Condition*/   requires n >= 0 && a >= 0;\n/*Post-Condition*/  ensures s == power(a,n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_Percentile", "vc-description": "", "vc-preamble": "// Sum of elements of A from indices 0 to end.\n// end is inclusive! (not James's normal way of thinking!!)\nfunction SumUpto(A: array<real>, end: int): real\n  requires -1 <= end < A.Length\n  reads A\n{\n  if end == -1 then\n    0.0\n  else\n    A[end] + SumUpto(A, end-1)\n}\n\nfunction Sum(A: array<real>): real\n  reads A\n{\n  SumUpto(A, A.Length-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Percentile(p: real, A: array<real>, total: real) returns (i: int)\n  requires forall i | 0 <= i < A.Length :: A[i] > 0.0\n  requires 0.0 <= p <= 100.0\n  requires total == Sum(A)\n  requires total > 0.0\n  ensures -1 <= i < A.Length\n  ensures SumUpto(A, i) <= (p/100.0) * total\n  ensures i+1 < A.Length ==> SumUpto(A, i+1) > (p/100.0) * total\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// example showing that, with the original postcondition, the answer is non-unique!\n\n\n// proof that, with the corrected postcondition, the answer is unique\n// lemma for previous proof: when an array has strictly positive elements, the\n// sums strictly increase left to right"}
{"id": "dafny-synthesis_task_id_424_ExtractRearChars", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Programs_tmp_tmp99966ew4_lemma_FindZero", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_triple2_Triple", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_tmp_tmp59p638nn_examples_realExponent_pow", "vc-description": "", "vc-preamble": "ghost function power(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures power(n, alpha) > 0.0\n\nghost function log(n: real, alpha: real): real\n    requires n > 0.0 && alpha > 0.0\n    ensures log(n, alpha) > 0.0", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod pow(n: nat, alpha: real) returns (product: real)\n    requires n > 0\n    requires alpha > 0.0\n    ensures product == power(n as real, alpha)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_swap_sim_SwapSimultaneous", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "VerifiedMergeSortDafny_tmp_tmpva7qms1b_MergeSort_mergeSimple", "vc-description": "", "vc-preamble": "predicate merged(a1: seq<int>, a2: seq<int>, b: array<int>, start: int, end: int)\n  reads b\n  requires end - start  == |a2| + |a1|\n  requires 0 <= start <= end <= b.Length\n{\n  multiset(a1) + multiset(a2) == multiset(b[start..end])\n}\n\npredicate sorted_slice(a: array<int>, start: int, end: int)\n  requires 0 <= start <= end <= a.Length\n  reads a\n{\n  forall i, j :: start <= i <= j < end ==> a[i] <= a[j]\n}\n\npredicate sorted_seq(a: seq<int>)\n{\n  forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mergeSimple(a1: seq<int>, a2: seq<int>, start: int, end: int, b: array<int>)\n  modifies b\n  requires sorted_seq(a1)\n  requires sorted_seq(a2)\n  requires 0 <= start <= end <= b.Length\n  requires |a1| +  |a2| == end - start + 1\n  ensures sorted_slice(b, start, end)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_304_ElementAtIndexAfterRotation", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ElementAtIndexAfterRotation(l: seq<int>, n: int, index: int) returns (element: int)\n    requires n >= 0\n    requires 0 <= index < |l|\n    ensures element == l[(index - n + |l|) % |l|]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_572_RemoveDuplicates", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveDuplicates(a: array<int>) returns (result: seq<int>)\n    requires a != null\n    ensures forall x :: x in result <==> exists i :: 0 <= i < a.Length && a[i] == x\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_762_IsMonthWith30Days", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsMonthWith30Days(month: int) returns (result: bool)\n    requires 1 <= month <= 12\n    ensures result <==> month == 4 || month == 6 || month == 9 || month == 11\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_106_AppendArrayToSeq", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort_two_way_sort", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\n\nfunction multisets<T>(s: seq<T>): multiset<T>\n{\n    if |s| == 0 then multiset{} \n    else multiset{s[0]} + multiset(s[1..])\n}\n\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  assume{:axiom} false;\n}\n\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_detailed_examples_SelectionSort_SelectionSort", "vc-description": "", "vc-preamble": "// Works by dividing the input list into two parts: sorted and unsorted. At the beginning, \n// the sorted part is empty and the unsorted part contains all the elements.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SelectionSort(a: array<int>)\n  modifies a\n  // Ensures the final array is sorted in ascending order\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  // Ensures that the final array has the same elements as the initial array\n  ensures multiset(a[..]) == old(multiset(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n    // ensures  !res ==> !isSubstringPred(sub, str)\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Contains_Duplicate_contains_duplicate_contains_duplicate", "vc-description": "", "vc-preamble": "predicate distinct(nums: seq<int>) {\n    forall i, j :: 0 <= i < j < |nums| ==> nums[i] != nums[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod contains_duplicate(nums: seq<int>) returns (result: bool)\n    requires 1 <= |nums| <= 100000\n    requires forall i :: 0 <= i < |nums| ==> -1000000000 <= nums[i] <= 1000000000\n    ensures result <==> distinct(nums)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "software_analysis_tmp_tmpmt6bo9sf_ss_selection_sort", "vc-description": "", "vc-preamble": "method find_min_index(a : array<int>, s: int, e: int) returns (min_i: int)\nrequires a.Length > 0\nrequires 0 <= s < a.Length\nrequires e <= a.Length\nrequires e > s\n\nensures min_i >= s \nensures min_i < e \nensures forall k: int :: s <= k < e ==> a[min_i] <= a[k]\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate is_sorted(ss: seq<int>)\n{\n    forall i, j: int:: 0 <= i <= j < |ss| ==> ss[i] <= ss[j]\n}\n\npredicate is_permutation(a:seq<int>, b:seq<int>)\ndecreases |a|\ndecreases |b|\n{\n    |a| == |b|  && \n    ((|a| == 0 && |b| == 0) ||  \n    exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + if i < |a| then a[i+1..] else [], b[0..j] + if j < |b| then  b[j+1..] else []))\n}\n\n\n// predicate is_permutation(a:seq<int>, b:seq<int>)\n// decreases |a|\n// decreases |b|\n// {\n//     |a| == |b|  && ((|a| == 0 && |b| == 0) ||  exists i,j : int :: 0<=i<|a| &&  0<=j<|b|  && a[i] == b[j] && is_permutation(a[0..i] + a[i+1..], b[0..j] + b[j+1..]))\n// }\n\npredicate is_permutation2(a:seq<int>, b:seq<int>)\n{\n    multiset(a) == multiset(b)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod selection_sort(ns: array<int>) \nrequires ns.Length >= 0\nensures is_sorted(ns[..])\nensures is_permutation2(old(ns[..]), ns[..])\nmodifies ns\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Bug165_Select", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\ntype T\nfunction f(a: T) : bool", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Select(s1: seq<T>) returns (r: seq<T>)\n  ensures (forall e: T  :: f(e) ==> multiset(s1)[e] == multiset(r)[e])\n  ensures (forall e: T  :: (!f(e)) ==> 0 == multiset(r)[e])\n\nmethod Main(s1: seq<T>)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_all_digits_allDigits", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_644_ReverseUptoK", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ReverseUptoK(s: array<int>, k: int)\n    modifies s\n    requires 2 <= k <= s.Length\n    ensures forall i :: 0 <= i < k ==> s[i] == old(s[k - 1 - i])\n    ensures forall i :: k <= i < s.Length ==> s[i] == old(s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate_separate", "vc-description": "", "vc-preamble": "predicate strictNegative(v:array<int>,i:int,j:int)\nreads v\nrequires 0<=i<=j<=v.Length\n{forall u | i<=u<j :: v[u]<0}\n\npredicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\n\npredicate isPermutation(s:seq<int>, t:seq<int>)\n{multiset(s)==multiset(t)}\n\n/**\nreturns an index st new array is a permutation of the old array\npositive first and then strictnegative, i is the firs neg or len if not any */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod separate(v:array<int>) returns (i:int)\nmodifies v\nensures 0<=i<=v.Length\nensures positive(v[0..i]) && strictNegative(v,i,v.Length)\nensures isPermutation(v[0..v.Length], old(v[0..v.Length]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_remove_front_remove_front", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod remove_front(a:array<int>) returns (c:array<int>)\n  requires a.Length>0\n  ensures  a[1..] == c[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_absIt_AbsIt", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AbsIt(s: array<int>) \nmodifies s\nensures forall i :: 0 <= i < s.Length ==> if old(s[i]) < 0 then s[i] == -old(s[i]) else s[i] == old(s[i])\nensures s.Length == old(s).Length\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "bbfny_tmp_tmpw4m0jvl0_enjoying_FindMax", "vc-description": "", "vc-preamble": "// shenanigans going through the dafny tutorial\n\n\n\n\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'()\n{\n  assume{:axiom} false;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n  requires a.Length >= 1 \n  ensures 0 <= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearchRec", "vc-description": "", "vc-preamble": "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\n\n\n\n\n\n\n//Recursive binary search", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod binarySearchRec(v:array<int>, elem:int, c:int, f:int) returns (p:int)\n requires sorted(v[0..v.Length])\n requires 0<=c<=f+1<=v.Length//0<=c<=v.Length && -1<=f<v.Length && c<=f+1\n requires forall k::0<=k<c ==> v[k]<=elem\n requires forall k::f<k<v.Length ==> v[k]>elem\n decreases f-c\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_swap3", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod swap3(a: array<int>, h: int, i: int, j: int)\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n  ensures a[h] == old(a[i]);\n  ensures a[j] == old(a[h]);\n  ensures a[i] == old(a[j]);\n  ensures forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-duck_tmp_tmplawbgxjo_p4_single", "vc-description": "", "vc-preamble": "//Given two arrays of integers, it returns a single array with all integers merged. \n// [1,5,2,3],[4,3,5]->[1,5,2,3,4,3,5]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod single(x:array<int>, y:array<int>) returns (b:array<int>) \nrequires x.Length > 0\nrequires y.Length > 0\n// ensuring that the new array is the two arrays joined\nensures b[..] == x[..] + y[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_triple4_Triple", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-demo_tmp_tmpkgr_dvdi_Dafny_BinarySearch_BinarySearch", "vc-description": "", "vc-preamble": "predicate sorted(a: array?<int>, l: int, u: int)\n    reads a\n    requires a != null\n    {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(a: array?<int>, key: int)\n    returns (index: int)\n    requires a != null && sorted(a,0,a.Length-1);\n    ensures index >= 0 ==> index < a.Length && a[index] == key;\n    ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_399_BitwiseXOR", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BitwiseXOR(a: seq<bv32>, b: seq<bv32>) returns (result: seq<bv32>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] ^ b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_ComputePower", "vc-description": "", "vc-preamble": "function Power(n:nat):nat \n{\n    if n == 0 then 1 else 2 * Power(n-1)\n}\n\nmethod CalcPower(n:nat) returns (p:nat)\n    ensures p == 2*n;\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputePower(n:nat) returns (p:nat)\n    ensures p == Power(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_5_intersperse", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod intersperse(numbers: seq<int>, delimiter: int) returns (interspersed: seq<int>)\n    ensures |interspersed| == if |numbers| > 0 then 2 * |numbers| - 1 else 0\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 0 ==> \n                interspersed[i] == numbers[i / 2]\n    ensures forall i :: 0 <= i < |interspersed| ==> i % 2 == 1 ==>\n                interspersed[i] == delimiter\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_262_SplitArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SplitArray(arr: array<int>, L: int) returns (firstPart: seq<int>, secondPart: seq<int>)\n    requires 0 <= L <= arr.Length\n    ensures |firstPart| == L\n    ensures |secondPart| == arr.Length - L\n    ensures firstPart + secondPart == arr[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0005-longest-palindromic-substring_expand_from_center", "vc-description": "", "vc-preamble": "/* https://leetcode.com/problems/longest-palindromic-substring/\nGiven a string s, return the longest palindromic substring in s.\n\nExample 1:\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n*/\n\n\n// Specifying the problem: whether `s[i..j]` is palindromic\nghost predicate palindromic(s: string, i: int, j: int)\n  requires 0 <= i <= j <= |s|\n  decreases j - i\n{\n  j - i < 2 || (s[i] == s[j-1] && palindromic(s, i+1, j-1))\n}\n\n// A \"common sense\" about palindromes:\n\n// A useful \"helper function\" that returns the longest palindrome at a given center (i0, j0).\n\n// The main algorithm.\n// We traverse all centers from left to right, and \"expand\" each of them, to find the longest palindrome.\n\n\n/* Discussions\n1. Dafny is super bad at slicing (esp. nested slicing).\n  Do circumvent it whenever possible. It can save you a lot of assertions & lemmas!\n\n  For example, instead of `palindromic(s[i..j])`, use the pattern `palindromic(s, i, j)` instead.\n  I didn't realize this (ref: https://github.com/Nangos/dafleet/commit/3302ddd7642240ff2b2f6a8c51e8becd5c9b6437),\n  Resulting in a couple of clumsy lemmas.\n\n2. Bonus -- Manacher's algorithm\n  Our above solution needs `O(|s|^2)` time in the worst case. Can we improve it? Yes.\n\n  Manacher's algorithm guarantees an `O(|s|)` time.\n  To get the intuition, ask yourself: when will it really take `O(|s|^2)` time?\n  When there are a lot of \"nesting and overlapping\" palindromes. like in `abcbcbcba` or even `aaaaaa`.\n\n  Imagine each palindrome as a \"mirror\". \"Large mirrors\" reflect \"small mirrors\".\n  Therefore, when we \"expand\" from some \"center\", we can \"reuse\" some information from its \"mirrored center\".\n  For example, we move the \"center\", from left to right, in the string `aiaOaia...`\n  Here, the char `O` is the \"large mirror\".\n  When the current center is the second `i`, it is \"mirrored\" to the first `i` (which we've calculated for),\n  so we know the palindrome centered at the second `i` must have at least a length of 3 (`aia`).\n  So we can expand directly from `aia`, instead of expanding from scratch.\n\n  Manacher's algorithm is verified below.\n  Also, I will verify that \"every loop is entered for only `O(|s|)` times\",\n  which \"indirectly\" proves that the entire algorithm runs in `O(|s|)` time.\n*/\n\n\n// A reference implementation of Manacher's algorithm:\n// (Ref. https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm) for details...\nmethod longestPalindrome'(s: string) returns (ans: string, lo: int, hi: int)\n  ensures 0 <= lo <= hi <= |s| && ans == s[lo..hi]\n  ensures palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) :: j - i <= hi - lo\n{\n  assume{:axiom} false;\n}\n\n\n// Below are helper functions and lemmas we used:\n\n// Inserts bogus characters to the original string (e.g. from `abc` to `|a|b|c|`).\n// Note that this is neither efficient nor necessary in reality, but just for the ease of understanding.\nfunction insert_bogus_chars(s: string, bogus: char): (s': string)\n  ensures |s'| == 2 * |s| + 1\n  ensures forall i | 0 <= i <= |s| :: s'[i * 2] == bogus\n  ensures forall i | 0 <= i < |s| :: s'[i * 2 + 1] == s[i]\n{\n  if s == \"\" then\n    [bogus]\n  else\n    var s'_old := insert_bogus_chars(s[1..], bogus);\n    var s'_new := [bogus] + [s[0]] + s'_old;\n    assert forall i | 1 <= i <= |s| :: s'_new[i * 2] == s'_old[(i-1) * 2];\n    s'_new\n}\n\n// Returns (max_index, max_value) of array `a` starting from index `start`.\nfunction argmax(a: array<int>, start: int): (res: (int, int))\n  reads a\n  requires 0 <= start < a.Length\n  ensures start <= res.0 < a.Length && a[res.0] == res.1\n  ensures forall i | start <= i < a.Length :: a[i] <= res.1\n  decreases a.Length - start\n{\n  if start == a.Length - 1 then\n    (start, a[start])\n  else\n    var (i, v) := argmax(a, start + 1);\n    if a[start] >= v then (start, a[start]) else (i, v)\n}\n\n// Whether an interval at center `c` with a radius `r` is within the boundary of `s'`.\nghost predicate inbound_radius(s': string, c: int, r: int)\n{\n  r >= 0 && 0 <= c-r && c+r < |s'|\n}\n\n// Whether `r` is a valid palindromic radius at center `c`.\nghost predicate palindromic_radius(s': string, c: int, r: int)\n  requires inbound_radius(s', c, r)\n{\n  palindromic(s', c-r, c+r+1)\n}\n\n// Whether `r` is the maximal palindromic radius at center `c`.\nghost predicate max_radius(s': string, c: int, r: int)\n{\n  && inbound_radius(s', c, r)\n  && palindromic_radius(s', c, r)\n  && (forall r' | r' > r && inbound_radius(s', c, r') :: !palindromic_radius(s', c, r'))\n}\n\n// Basically, just \"rephrasing\" the `lemma_palindromic_contains`,\n// talking about center and radius, instead of interval\n\n// When \"expand from center\" ends, we've find the max radius:\n\n// The critical insight behind Manacher's algorithm.\n//\n// Given the longest palindrome centered at `c` has length `r`, consider the interval from `c-r` to `c+r`.\n// Consider a pair of centers in the interval: `c1` (left half) and `c2` (right half), equally away from `c`.\n// Then, the length of longest palindromes at `c1` and `c2` are related as follows:\n//, where:\nghost function abs(x: int): int {\n  if x >= 0 then x else -x\n}\n\n// Transfering our final result on `s'` to that on `s`:\n\n// The following returns whether `s[lo..hi]` is the longest palindrome s.t. `lo + hi == k`:\nghost predicate max_interval_for_same_center(s: string, k: int, lo: int, hi: int) {\n  && 0 <= lo <= hi <= |s|\n  && lo + hi == k\n  && palindromic(s, lo, hi)\n  && (forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j) && i + j == k :: j - i <= hi - lo)\n}\n\n// Establishes the \"palindromic isomorphism\" between `s` and `s'`.\n\n// Implies that whenever `c + r` is odd, the corresponding palindrome can be \"lengthened for free\"\n// because its both ends are the bogus char.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod expand_from_center(s: string, i0: int, j0: int) returns (lo: int, hi: int)\n  requires 0 <= i0 <= j0 <= |s|\n  requires palindromic(s, i0, j0)\n  ensures 0 <= lo <= hi <= |s| && palindromic(s, lo, hi)\n  ensures forall i, j | 0 <= i <= j <= |s| && palindromic(s, i, j)  // Among all palindromes\n    && i + j == i0 + j0                                             // sharing the same center,\n    :: j - i <= hi - lo                                             // `s[lo..hi]` is longest.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_576_IsSublist", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsSublist(sub: seq<int>, main: seq<int>) returns (result: bool)\n    ensures true <== (exists i :: 0 <= i <= |main| - |sub| && sub == main[i..i + |sub|])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_cal_ans_CalDiv", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_426_FilterOddNumbers", "vc-description": "", "vc-preamble": "/**\n * Filter odd numbers from an array of numbers\n **/\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FilterOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_selectionSort", "vc-description": "", "vc-preamble": "/* \n* Formal verification of the selection sort algorithm with Dafny.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a miminum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod selectionSort(a: array<real>)\n  modifies a\n  ensures isSorted(a, 0, a.Length) \n  ensures multiset(a[..]) == multiset(old(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_update_array_UpdateElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod UpdateElements(a: array<int>)\n  requires a.Length >= 8\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[7]==516\n  ensures forall i::0 <= i<a.Length ==> i != 7 && i != 4 ==> a[i] == old(a[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_test_array_TestArrayElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod TestArrayElements(a:array<int>, j: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n  ensures forall k :: 0 <= k < a.Length && k != j ==> a[k] == old(a[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_3_below_zero", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, n: nat): int\n    requires n <= |s|\n{\n    if |s| == 0 || n == 0 then\n        0\n    else\n        s[0] + sum(s[1..], n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod below_zero(ops: seq<int>) returns (result: bool)\n    ensures result <==> exists n: nat :: n <= |ops| && sum(ops, n) < 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Insertion_Sort_Normal_lookForMin", "vc-description": "", "vc-preamble": "predicate sorted (a: array<int>)\n\n    reads a\n{\n    sortedA(a, a.Length)\n}\n\npredicate sortedA (a: array<int>, i: int)\n\n    requires 0 <= i <= a.Length\n    reads a\n{\n    forall k :: 0 < k < i ==> a[k-1] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod lookForMin (a: array<int>, i: int) returns (m: int)\n\n    requires 0 <= i < a.Length\n    ensures i <= m < a.Length\n    ensures forall k :: i <= k < a.Length ==> a[k] >= a[m]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_798_ArraySum", "vc-description": "", "vc-preamble": "function sumTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else sumTo(a, n-1) + a[n-1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ArraySum(a: array<int>) returns (result: int)\n    ensures result == sumTo(a, a.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_demo_Partition", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Partition(a: array<int>) returns (lo: int, hi: int)\n  modifies a\n  ensures 0 <= lo <= hi <= a.Length\n  ensures forall x | 0 <= x < lo :: a[x] < 0\n  ensures forall x | lo <= x < hi :: a[x] == 0\n  ensures forall x | hi <= x < a.Length :: a[x] > 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isPrefix", "vc-description": "", "vc-preamble": "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_251_InsertBeforeEach", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertBeforeEach(s: seq<string>, x: string) returns (v: seq<string>)\n        ensures |v| == 2 * |s|\n        ensures forall i :: 0 <= i < |s| ==> v[2*i] == x && v[2*i + 1] == s[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_431_HasCommonElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod HasCommonElement(a: array<int>, b: array<int>) returns (result: bool)\n    requires a != null && b != null\n    ensures result ==> exists i, j :: 0 <= i < a.Length && 0 <= j < b.Length && a[i] == b[j]\n    ensures !result ==> forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> a[i] != b[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "feup-mfes_tmp_tmp6_a1y5a5_examples_SelectionSort_findMin", "vc-description": "", "vc-preamble": "/* \n* Formal verification of the selection sort algorithm with Dafny.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Checks if array 'a' is sorted between positions 'from' (inclusive) and 'to' (exclusive).\npredicate isSorted(a: array<real>, from: nat, to: nat)\n  requires 0 <= from <= to <= a.Length\n  reads a\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j] \n}\n\n// Sorts array 'a' using the selection sort algorithm.\n\n// Finds the position of a miminum value in non-empty subarray 'a' between positions \n// 'from' (inclusive) and 'to' (exclusive)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod findMin(a: array<real>, from: nat, to: nat) returns(index: nat)\n  requires 0 <= from < to <= a.Length\n  ensures from <= index < to\n  ensures forall k :: from <= k < to ==> a[k] >= a[index]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_InsertionSortMultiset_Search", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n\n// Insertion sort með hjálp helmingunarleitar.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki má breyta forskilyrðum eða eftirskilyrðum fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_457_MinLengthSublist", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MinLengthSublist(s: seq<seq<int>>) returns (minSublist: seq<int>)\n    requires |s| > 0\n    ensures minSublist in s\n    ensures forall sublist :: sublist in s ==> |minSublist| <= |sublist|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_Product", "vc-description": "", "vc-preamble": "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Product(m: nat, n:nat) returns (res:nat)\nensures res == m*n;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "predicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPredicate(pre,str)\n{\n  assume{:axiom} false;\n}\n\n\n\npredicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n  ensures |str1| < k || |str2| < k ==> !found\n  ensures haveCommonKSubstringPredicate(k,str1,str2) == found\n{\n  assume{:axiom} false;\n}\n\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\nensures len <= |str1| && len <= |str2|\nensures len >= 0\nensures maxCommonSubstringPredicate(str1, str2, len)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod1", "vc-description": "", "vc-preamble": "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DivMod1(a: int, b: int) returns (q: int, r: int)\nrequires b > 0 && a >= 0\nensures a == b*q + r && 0 <= r < b\n//decreases *\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_461_CountUppercase", "vc-description": "", "vc-preamble": "predicate IsUpperCase(c: char)\n{\n    65 <= c as int <= 90\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountUppercase(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |s| && IsUpperCase(s[i])|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "BinaryAddition_BinaryAddition", "vc-description": "", "vc-preamble": "/* \nMIPS 0\nWe implement the following with bitvectors in Dafny.\nhere s' and t' are converted to decimal scalars\ns = [1,1,1], t = [1,0,1], ys = [1, 0, 0], s' = 7, t' = 5, ys' = 4\nys' % 2 ^ (len(s)) = (s' + t') % 2 ^ (len(s))\n4 % 8 = 12 % 8\n\ndef f(s,t):\n    a = 0;b = 0;\n    ys = []\n    for i in range(10):\n        c = s[i]; d = t[i];\n        next_a = b ^ c ^ d\n        next_b = b+c+d>1\n        a = next_a;b = next_b;\n        y = a\n        ys.append(y)\n    return ys\n*/\n\nfunction ArrayToBv10(arr: array<bool>): bv10 // Converts boolean array to bitvector\n    reads arr\n    requires arr.Length == 10\n{\n    ArrayToBv10Helper(arr, arr.Length - 1)\n}\n\nfunction ArrayToBv10Helper(arr: array<bool>, index: nat): bv10\n    reads arr\n    requires arr.Length == 10\n    requires 0 <= index < arr.Length\n    decreases index\n{\n    if index == 0 then\n        (if arr[0] then 1 else 0) as bv10\n    else\n        var bit: bv10 := if arr[index] then 1 as bv10 else 0 as bv10;\n        (bit << index) + ArrayToBv10Helper(arr, index - 1)\n}\n\nmethod ArrayToSequence(arr: array<bool>) returns (res: seq<bool>) // Converts boolean array to boolean sequence\n    ensures |res| == arr.Length\n    ensures forall k :: 0 <= k < arr.Length ==> res[k] == arr[k]\n{\n  assume{:axiom} false;\n}\n\nfunction isBitSet(x: bv10, bitIndex: nat): bool\n    requires bitIndex < 10\n    ensures isBitSet(x, bitIndex) <==> (x & (1 << bitIndex)) != 0\n{\n    (x & (1 << bitIndex)) != 0\n}\n\nfunction Bv10ToSeq(x: bv10): seq<bool> // Converts bitvector to boolean sequence\n    ensures |Bv10ToSeq(x)| == 10\n    ensures forall i: nat :: 0 <= i < 10 ==> Bv10ToSeq(x)[i] == isBitSet(x, i)\n{\n    var result := [isBitSet(x, 0), isBitSet(x, 1), isBitSet(x, 2), isBitSet(x, 3),\n    isBitSet(x, 4), isBitSet(x, 5), isBitSet(x, 6), isBitSet(x, 7),\n    isBitSet(x, 8), isBitSet(x, 9)];\n    assert result[0] == isBitSet(x, 0);\n    assert result[1] == isBitSet(x, 1);\n    assert result[2] == isBitSet(x, 2);\n    assert result[3] == isBitSet(x, 3);\n    assert result[4] == isBitSet(x, 4);\n    assert result[5] == isBitSet(x, 5);\n    assert result[6] == isBitSet(x, 6);\n    assert result[7] == isBitSet(x, 7);\n    assert result[8] == isBitSet(x, 8);\n    assert result[9] == isBitSet(x, 9);\n    assert forall i: nat :: 0 <= i < 10 ==> result[i] == isBitSet(x, i);\n    result\n}\n\nfunction BoolToInt(a: bool): int {\n    if a then 1 else 0\n}\n\nfunction XOR(a: bool, b: bool): bool {\n    (a || b) && !(a && b)\n}\n\nfunction BitAddition(s: array<bool>, t: array<bool>): seq<bool> // Performs traditional bit addition\n    reads s\n    reads t\n    requires s.Length == 10 && t.Length == 10\n{\n    var a: bv10 := ArrayToBv10(s);\n    var b: bv10 := ArrayToBv10(t);\n    var c: bv10 := a + b;\n    Bv10ToSeq(c)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinaryAddition(s: array<bool>, t: array<bool>) returns (sresult: seq<bool>) // Generated program for bit addition\n    requires s.Length == 10 && t.Length == 10\n    ensures |sresult| == 10\n    ensures BitAddition(s, t) == sresult // Verification of correctness\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_105_CountTrue", "vc-description": "", "vc-preamble": "function countTo( a:array<bool>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else countTo(a, n-1) + (if a[n-1] then 1 else 0)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountTrue(a: array<bool>) returns (result: int)\n    requires a != null\n    ensures result == countTo(a, a.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session8Exercises_ExerciseInsertionSort_InsertionSort", "vc-description": "", "vc-preamble": "predicate sorted_seg(a:array<int>, i:int, j:int) //i and j included\nrequires 0 <= i <= j+1 <= a.Length\nreads a\n{\n    forall l, k :: i <= l <= k <= j ==> a[l] <= a[k]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertionSort(a: array<int>)\n  modifies a;\n  ensures sorted_seg(a,0,a.Length-1) \n  ensures multiset(a[..]) == old(multiset(a[..])) //Add and prove this\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_fibonacci_ComputeFib", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/\n\n\n//      n = 0, 1, 2, 3, 4, 5, 6,  7,  8, ...\n// fib(n) = 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\nfunction fib(n: nat): nat\n  decreases n;\n{\n  if n == 0 then 0 \n  else if n == 1 then 1 \n  else fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == fib(n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_search_findPositionOfIndex_FindPositionOfElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindPositionOfElement(a:array<int>,Element:nat,n1:nat,s1:seq<int>) returns (Position:int,Count:nat)\n        requires n1 == |s1| && 0 <= n1 <= a.Length\n        requires forall i:: 0<= i < |s1| ==> a[i] == s1[i]\n        ensures Position == -1 || Position >= 1\n        ensures |s1| != 0 && Position >= 1 ==> exists i:: 0 <= i < |s1| && s1[i] == Element\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_586_SplitAndAppend", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SplitAndAppend(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0 && n < |l|\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i + n) % |l|]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex7_Exchanger", "vc-description": "", "vc-preamble": "// see pdf 'ex6 & 7 documentation' for excercise question\n\n\ndatatype Bases = A | C | G | T\n\n//swaps two sequence indexes\n\n//idea from Rustan Leino video \"Basics of specification and verification: Lecture 3, the Dutch National Flag algorithm\"\n//modified for 4 elements\npredicate below(first: Bases, second: Bases)\n{\n    first == second ||\n    first == A || \n    (first == C && (second ==  G || second == T)) || \n    (first == G && second == T) ||\n    second == T\n}\n\n//checks if a sequence is in base order\npredicate bordered(s:seq<Bases>)\n{\n    forall j, k :: 0 <= j < k < |s| ==> below(s[j], s[k])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Exchanger(s: seq<Bases>, x:nat, y:nat) returns (t: seq<Bases>)\nrequires 0 < |s| && x < |s| && y < |s|\nensures |t| == |s|\nensures forall b:nat :: 0 <= b < |s| && b != x && b != y ==> t[b] == s[b]\nensures t[x] == s[y] && s[x] == t[y]\nensures multiset(s) == multiset(t)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_227_MinOfThree", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MinOfThree(a: int, b: int, c: int) returns (min: int)\n    ensures min <= a && min <= b && min <= c\n    ensures (min == a) || (min == b) || (min == c)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_95_SmallestListLength", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SmallestListLength(s: seq<seq<int>>) returns (v: int)\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> v <= |s[i]|\n    ensures exists i :: 0 <= i < |s| && v == |s[i]|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_472_ContainsConsecutiveNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ContainsConsecutiveNumbers(a: array<int>) returns (result: bool)\n    requires a.Length>0\n    ensures result <==> (exists i :: 0 <= i < a.Length - 1 && a[i] + 1 == a[i + 1])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "CVS-handout1_tmp_tmptm52no3k_1_query", "vc-description": "", "vc-preamble": "/*                                      Cumulative Sums over Arrays                                        */\n\n/*\n    Daniel Cavalheiro   57869\n    Pedro Nunes         57854\n*/\n\n\n\n//(a)\n\nfunction sum(a: array<int>, i: int, j: int): int\n    reads a\n    requires 0 <= i <= j <= a.Length\n    decreases j - i\n{\n    if (i == j) then 0\n    else a[i] + sum(a, i+1, j)\n}\n\n\n\n//(b)\n\n//(c)\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n    requires a.Length + 1 == c.Length\n    requires c[0] == 0\n    reads c, a\n{\n    forall i: int :: 0 <= i < a.Length ==> c[i+1] == c[i] + a[i]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod query(a: array<int>, i: int, j: int) returns (res:int)\n    requires 0 <= i <= j <= a.Length\n    ensures res == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cs245-verification_tmp_tmp0h_nxhqp_A8_Q1_A8Q1", "vc-description": "", "vc-preamble": "// A8Q1 — Steph Renee McIntyre\n// Following the solutions from Carmen Bruni\n\n// There is no definition for power, so this function will be used for validating that our imperative program is correct. This is just for Dafny.\nfunction power(a: int, n: int): int //function for a to the power of n\n  requires 0 <= n;\n  decreases n;\n  {\n    if (n == 0) then 1 else a * power(a, n - 1)\n  }\n\n/* Proof of implieds can be seen on LEARN.\n    Note: If you are unconvinced, putting asserts for each condition will demonstrate the correctness of the statements. \n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod A8Q1(y0: int, x: int) returns (z: int)\nrequires y0 >= 0\nensures z==power(x,y0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_755_SecondSmallest", "vc-description": "", "vc-preamble": "function MinPair(s: seq<int>) : (r: int)\n    requires |s| == 2\n    ensures s[0] <= s[1] <==> r == s[0]\n    ensures s[0] > s[1] ==> r == s[1] \n{\n    if s[0] <= s[1] then s[0] else s[1]\n}\n\n\nfunction min(s: seq<int>) : (r: int)\n    requires |s| >= 2\n    ensures forall i :: 0 <= i < |s| ==> r <= s[i]\n{\n    if |s| == 2 then MinPair(s)\n    else MinPair([s[0], min(s[1..])])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SecondSmallest(s: array<int>) returns (secondSmallest: int)\n    requires s.Length >= 2\n    // There must be at least 2 different values, a minimum and another one\n    requires exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] != s[i]\n    ensures exists i, j :: 0 <= i < s.Length && 0 <= j < s.Length && i != j && s[i] == min(s[..]) && s[j] == secondSmallest \n    ensures forall k ::  0 <= k < s.Length && s[k] != min(s[..])  ==>  s[k] >= secondSmallest\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_haveCommonKSubstring", "vc-description": "", "vc-preamble": "// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    //ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpmvs2dmry_examples2_gcdCalc", "vc-description": "", "vc-preamble": "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod gcdCalc(m: nat, n: nat) returns (res: nat)\nrequires m>0 && n>0;\nensures res == gcd(m,n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex_06_hoangkim_gcdI", "vc-description": "", "vc-preamble": "//Problem01\n//a)\nghost function gcd(x: int, y: int): int\n    requires x > 0 && y > 0\n{\n    if x == y then x\n    else if x > y then gcd(x - y, y)\n    else gcd(x, y - x)\n}\n\n//b)\nghost function gcd'(x: int, y: int): int\n    requires x > 0 && y > 0\n    decreases if x > y then x else y\n{\n    if x == y then x\n    else if x > y then gcd'(x - y, y)\n    else gcd(y, x)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod gcdI(m: int, n: int) returns (d: int)\nrequires  m > 0 && n > 0 \nensures d == gcd(m, n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_lc-remove-element_removeElement", "vc-description": "", "vc-preamble": "//https://leetcode.com/problems/remove-element/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod removeElement(nums: array<int>, val: int) returns (i: int)\n    ensures forall k :: 0 < k < i < nums.Length ==> nums[k] != val\n    modifies nums\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "///compileTarget:js"}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertIntoSorted", "vc-description": "", "vc-preamble": "// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\n\n/*\n*/\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\n\n\n*/\n\n// TODO play with this for keys==Contents\n\n\nghost predicate SortedSeq(a: seq<int>)\n  //sequence is sorted from left to right\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n  // get index so that array stays sorted\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n{\n  assume{:axiom} false;\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\n/*\nmethod InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])\n{\n  assume{:axiom} false;\n}\n*/\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise3_Increment_Array_incrementArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod incrementArray(a:array<int>)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1\n  modifies a\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_733_FindFirstOccurrence", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindFirstOccurrence(arr: array<int>, target: int) returns (index: int)\n    requires arr != null\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures 0 <= index < arr.Length ==> arr[index] == target\n    ensures index == -1 ==> forall i :: 0 <= i < arr.Length ==> arr[i] != target\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_advanced_examples_Percentile_PercentileNonUniqueAnswer", "vc-description": "", "vc-preamble": "// Sum of elements of A from indices 0 to end.\n// end is inclusive! (not James's normal way of thinking!!)\nfunction SumUpto(A: array<real>, end: int): real\n  requires -1 <= end < A.Length\n  reads A\n{\n  if end == -1 then\n    0.0\n  else\n    A[end] + SumUpto(A, end-1)\n}\n\nfunction Sum(A: array<real>): real\n  reads A\n{\n  SumUpto(A, A.Length-1)\n}\n\n\n// example showing that, with the original postcondition, the answer is non-unique!", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PercentileNonUniqueAnswer() returns (p: real, A: array<real>, total: real, i1: int, i2: int)\n  ensures forall i | 0 <= i < A.Length :: A[i] > 0.0\n  ensures 0.0 <= p <= 100.0\n  ensures total == Sum(A)\n  ensures total > 0.0\n\n  ensures -1 <= i1 < A.Length\n  ensures SumUpto(A, i1) <= (p/100.0) * total\n  ensures i1+1 < A.Length ==> SumUpto(A, i1+1) >= (p/100.0) * total\n\n  ensures -1 <= i2 < A.Length\n  ensures SumUpto(A, i2) <= (p/100.0) * total\n  ensures i2+1 < A.Length ==> SumUpto(A, i2+1) >= (p/100.0) * total\n\n  ensures i1 != i2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// proof that, with the corrected postcondition, the answer is unique\n// lemma for previous proof: when an array has strictly positive elements, the\n// sums strictly increase left to right"}
{"id": "CS494-final-project_tmp_tmp7nof55uq_bubblesort_BubbleSort", "vc-description": "", "vc-preamble": "//Bubblesort CS 494 submission\n//References: https://stackoverflow.com/questions/69364687/how-to-prove-time-complexity-of-bubble-sort-using-dafny/69365785#69365785\n\n\n// predicate checks if elements of a are in ascending order, two additional conditions are added to allow us to sort in specific range within array\n\npredicate sorted(a:array<int>, from:int, to:int)\n  requires a != null; // requires array to have n amount of elements\n  reads a; \n  requires 0 <= from <= to <= a.Length; // pre condition checks that from is the start of the range and to is the end of the range, requires values to be within 0 - a.Length\n{\n  forall x, y :: from <= x < y < to ==> a[x] <= a[y]\n}\n\n//helps ensure swapping is valid, it is used inside the nested while loop to make sure linear order is being kept \npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null; // requires array to have n amount of elements\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall x, y :: 0 <= x < pvt < y < to ==> a[x] <= a[y] // all values within the array should be in ascending order\n}\n\n// Here having the algorithm for the bubblesort", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BubbleSort (a: array<int>)\n    requires a != null && a.Length > 0; // makes sure a is not empty and length is greater than 0\n    modifies a; // as method runs, we are changing a\n    ensures sorted(a, 0, a.Length); // makes sure elements of array a are sorted from 0 - a.Length\n    ensures multiset(a[..]) == multiset(old(a[..])); // Since a is being modified, we deference the heap \n                                                      //and compare the previous elements to current elements.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0003-longest-substring-without-repeating-characters_lengthOfLongestSubstring", "vc-description": "", "vc-preamble": "/* https://leetcode.com/problems/longest-substring-without-repeating-characters/\nGiven a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n*/\n\n\n// a left-inclusive right-exclusive interval:\ntype interval = iv: (int, int) | iv.0 <= iv.1 witness (0, 0)\n\nghost function length(iv: interval): int {\n  iv.1 - iv.0\n}\n\nghost predicate valid_interval(s: string, iv: interval) {\n  && (0 <= iv.0 <= iv.1 <= |s|)                             // interval is in valid range\n  && (forall i, j | iv.0 <= i < j < iv.1 :: s[i] != s[j])   // no repeating characters in interval\n}\n\n// Below shows an efficient solution using standard \"sliding window\" technique. \n// For verification simplicity, we pretend as if:\n// - `set` were Python set (or even better, a fixed-size array -- if the \"alphabet\" is small)\n//\n// `best_iv` is for verification purpose, not returned by the real program, thus `ghost`.\n\n/* Discussions\n1. The \"sliding window\" technique is the most \"fancy\" part of the solution,\n  ensuring an O(n) time despite the O(n^2) search space.\n  The reason why it works lies in the last two invariants: (A) and (B).\n\n  Invariant (A) is simply a \"partial\" guarantee for the longest valid substring in `s[..hi]`,\n  so once the loop finishes, as `hi == |s|`, this \"partial\" guarantee becomes \"full\".\n\n  Invariant (B) is crucial: it encodes why we can monotonically increase `lo` as we increase `hi`.\n  What's the \"intuition\" behind that? Let me share an \"informal proof\" below:\n\n    Let `sub(i)` be the longest valid substring whose last character is `s[i]`.\n    Apparently, the final answer will be \"the longest among the longests\", i.e.\n    `max(|sub(0)|, |sub(1)|, ..., |sub(|s|-1)|)`.\n\n    Now, notice that the \"starting position\" of `sub(i)` is monotonically increasing regarding `i`!\n    Otherwise, imagine `sub(i+1)` started at `j` while `sub(i)` started at `j+1` (or even worse),\n    then `sub(i)` could be made longer (by starting at `j` instead).\n    This is an obvious contradiction.\n\n    Therefore, when we search for the starting position of `sub(i)` (the `lo`) for each `i` (the `hi`),\n    there's no need to \"look back\".\n\n2. The solution above can be made more efficient, using \"jumping window\" instead of \"sliding window\".\n  Namely, we use a dict (instead of set) to look up the \"position of repetition\",\n  and move `lo` right after that position at once.\n\n  You can even \"early terminate\" (based on `lo`) when all remaining intervals are doomed \"no longer\",\n  resulting in even fewer number of loop iterations.\n  (Time complexity will still be O(n), though.)\n\n  The corresponding verification code is shown below:\n*/\n\n\n// For verification simplicity, we pretend as if:\n// - `map` were Python dict (or even better, a fixed-size array -- if the \"alphabet\" is small)\n\n// Bonus Question:\n//   \"Why can we safely use (C) instead of (D) as the loop condition? Won't `hi` go out-of-bound?\"\n// Can you figure it out?", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod lengthOfLongestSubstring(s: string) returns (n: int, ghost best_iv: interval)\n  ensures valid_interval(s, best_iv) && length(best_iv) == n    /** `best_iv` is valid */\n  ensures forall iv | valid_interval(s, iv) :: length(iv) <= n  /** `best_iv` is longest */\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_SmallNum_add_small_numbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod add_small_numbers (a: array<int>, n: int, max: int) returns (r: int)\n    requires n > 0;\n    requires n <= a.Length;\n    requires (forall i: int :: 0 <= i && i < n ==> a[i] <= max);\n    ensures r <= max * n;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum_TwoSum", "vc-description": "", "vc-preamble": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_is_palindrome_IsPalindrome", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_566_SumOfDigits", "vc-description": "", "vc-preamble": "//lemma DivIsZero()\n//  ensures forall num, den : nat :: den >= 1 && num < den ==> num/den == 0\n\n// ghost function ValuesOfn(number: nat, ndigits: nat) : (r: seq<nat>)\n// {\n//   seq(ndigits+1, i requires 0 <= i <= ndigits => number / PowersOfTen[i])\n// }\n\nghost function IntValues(n: int) : (r: seq<int>)\n  requires n >= 0\n  ensures 0 in r\n  ensures n in r\n  ensures n/10 in r\n  //    ensures forall p :: p in powersOfTen ==> n/p in r\n{\n  if n == 0 then [0]\n  else [n] + IntValues(n/10)\n}\n\nfunction Power10(n: nat): (r: nat)\n  ensures r >= 1\n  ensures n > 0 ==> r % 10 == 0\n{\n  if (n == 0) then 1 else 10 * Power10(n-1)\n}\n\nfunction NumberToSeq(number: int) : seq<int>\n  requires number >= 0\n{\n  if number == 0 then []\n  else [number % 10] + NumberToSeq(number/10)\n}\n\nfunction Sum(digits: seq<int>) : int\n{\n  if |digits| == 0 then 0 else digits[0] + Sum(digits[1..])\n}\n\nfunction SumDigits(n: nat) : nat\n{\n  var ndigits := NumberOfDigits(n);\n  var p := Power10(ndigits-1);\n  SumDigitsRecursive(n, p)\n}\n\nfunction SumDigitsRecursive(n: nat, p: nat) : (r: nat)\n{\n  if n == 0 || p == 0 then 0\n  else\n    var leftMostDigit := n/p;\n    var rest := n%p;\n    leftMostDigit + SumDigitsRecursive(rest, p/10)\n\n}\n\nfunction NumberOfDigits(n: nat) : (r: nat)\n  ensures r >= 1\n  ensures r == 1 <==> 0 <= n <= 9\n{\n  if 0 <= n <= 9 then 1 else 1+NumberOfDigits(n/10)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumOfDigits(number: nat) returns (sum: nat)\n  requires number >= 0\n  ensures sum >= 0\n  ensures sum == SumDigits(number)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_binarySearch", "vc-description": "", "vc-preamble": "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Recursive binary search"}
{"id": "dafny-synthesis_task_id_565_SplitStringIntoChars", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SplitStringIntoChars(s: string) returns (v: seq<char>)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> v[i] == s[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mlastMaximum", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mlastMaximum(v:array<int>) returns (i:int)\nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\nensures forall l:: i<l<v.Length ==> v[i]>v[l]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Algorithm : from left to right\n//Algorithm : from right to left"}
{"id": "Dafny-programs_tmp_tmpnso9eu7u_Algorithms___sorting_bubble-sort_BubbleSort", "vc-description": "", "vc-preamble": "/*\nBubble Sort is the simplest sorting algorithm that works by \nrepeatedly swapping the adjacent elements if they are in wrong order.\n*/\n\npredicate sorted_between(A:array<int>, from:int, to:int)\n    reads A\n{\n    forall i, j :: 0 <= i <= j < A.Length && from <= i <= j <= to ==> A[i] <= A[j]\n}\n\npredicate sorted(A:array<int>)\n    reads A\n{\n    sorted_between(A, 0, A.Length-1)\n}\n\n/* Explanation:\n\ninvariant forall n, m :: 0 <= n <= i <m <N ==> A [n] <= A [m]\n     // A is ordered for each pair of elements such that\n     // the first element belongs to the left partition of i\n     // and the second element belongs to the right partition of i\n\ninvariant forall n :: 0 <= n <= j ==> A [n] <= A [j]\n     // There is a variable defined by the value that the array takes at position j\n     // Therefore, each value that the array takes for all elements from 0 to j\n     // They are less than or equal to the value of the variable\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BubbleSort(A:array<int>)\n    modifies A\n    ensures sorted(A)\n    ensures multiset(A[..]) == multiset(old(A[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_627_SmallestMissingNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SmallestMissingNumber(s: seq<int>) returns (v: int)\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 0\n    ensures 0 <= v\n    ensures v !in s\n    ensures forall k :: 0 <= k < v ==> k in s\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_below_zero_below_zero", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_triple_Triple", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Triple (x:int) returns (r:int)\n  ensures r==3*x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Quick_Sort_quickSort", "vc-description": "", "vc-preamble": "predicate quickSorted(Seq: seq<int>)\n{\n  forall idx_1, idx_2 :: 0 <= idx_1 < idx_2 < |Seq| ==> Seq[idx_1] <= Seq[idx_2]\n}\n\nmethod threshold(thres:int,Seq:seq<int>) returns (Seq_1:seq<int>,Seq_2:seq<int>)\n  ensures (forall x | x in Seq_1 :: x <= thres) && (forall x | x in Seq_2 :: x >= thres)\n  ensures |Seq_1| + |Seq_2| == |Seq| \n  ensures multiset(Seq_1) + multiset(Seq_2) == multiset(Seq)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod quickSort(Seq: seq<int>) returns (Seq': seq<int>)\n  ensures multiset(Seq) == multiset(Seq')\n  decreases |Seq|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_0_has_close_elements", "vc-description": "", "vc-preamble": "function abs(x: real): real\n{\n  if x < 0.0 then -x else x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod has_close_elements(numbers: seq<real>, threshold: real) returns (result: bool)\n    ensures result <==> exists i, j ::\n      0 <= i < |numbers| &&\n      0 <= j < |numbers| &&\n      i != j &&\n      abs(numbers[i] - numbers[j]) < threshold\n    ensures result ==> |numbers| > 1\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_436_FindNegativeNumbers", "vc-description": "", "vc-preamble": "/**\n * Find negative numbers from an array of numbers\n **/\n\npredicate IsNegative(n: int)\n{\n    n < 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindNegativeNumbers(arr: array<int>) returns (negativeList: seq<int>)\n    // All numbers in the output are negative and exist in the input \n    ensures forall i :: 0 <= i < |negativeList| ==> IsNegative(negativeList[i]) && negativeList[i] in arr[..]\n    // All negative numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsNegative(arr[i]) ==> arr[i] in negativeList\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_integer_square_root_SquareRoot", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_273_SubtractSequences", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SubtractSequences(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] - b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_min_array_minArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_replace_replace", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod replace(arr: array<int>, k: int)\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) > k ==> arr[i] == -1\n  ensures forall i :: 0 <= i < arr.Length ==> old(arr[i]) <= k ==> arr[i] == old(arr[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "CVS-Projto1_tmp_tmpb1o0bu8z_proj1_proj1_queryFast", "vc-description": "", "vc-preamble": "//Exercicio 1.a)\nfunction sum (a:array<int>, i:int, j:int) :int\ndecreases j\nreads a\nrequires 0 <= i <= j <= a.Length\n{\n    if i == j then\n        0\n    else\n        a[j-1] + sum(a, i, j-1)\n}\n\n//Exercicio 1.b)\n\n//Exercicio 1.c)\n\npredicate is_prefix_sum_for (a:array<int>, c:array<int>)\nreads c, a\n{\n    a.Length + 1 == c.Length\n    && c[0] == 0\n    && forall j :: 1 <= j <= a.Length ==> c[j] == sum(a,0,j)\n}\n\n///Exercicio 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\nrequires a.Length > 0\nensures forall j::0 <= j < a.Length ==> mem(a[j],l)\n{\n  assume{:axiom} false;\n}\n\nfunction mem<T(==)> (x: T, l:List<T>) : bool\ndecreases l\n{\n    match l\n    case Nil => false\n    case Cons(y,r)=> if (x==y) then true else mem(x,r)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod queryFast (a:array<int>, c:array<int>, i:int, j:int) returns (r:int)\nrequires is_prefix_sum_for(a,c) && 0 <= i <= j <= a.Length < c.Length\nensures r == sum(a, i,j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_Find", "vc-description": "", "vc-preamble": "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\n\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> (forall k :: 0 <= k < a.Length ==> a[k] != key)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_isSubstring", "vc-description": "", "vc-preamble": "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n  assume{:axiom} false;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    ensures  res ==> isSubstringPred(sub, str)\n    // ensures  !res ==> !isSubstringPred(sub, str)\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures  isSubstringPred(sub, str) ==> res\n    ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_581_SquarePyramidSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SquarePyramidSurfaceArea(baseEdge: int, height: int) returns (area: int)\n    requires baseEdge > 0\n    requires height > 0\n    ensures area == baseEdge * baseEdge + 2 * baseEdge * height\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_array_product_arrayProduct", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod arrayProduct(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] * b[i]==c[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_swap_in_array_swap", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_591_SwapFirstAndLast", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SwapFirstAndLast(a: array<int>)\n    requires a != null && a.Length > 0\n    modifies a\n    ensures a[0] == old(a[a.Length - 1]) && a[a.Length - 1] == old(a[0])\n    ensures forall k :: 1 <= k < a.Length - 1 ==> a[k] == old(a[k])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerIter", "vc-description": "", "vc-preamble": "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, M.EIC, MFS, 2021/22.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod powerIter(b: real, n: nat) returns (p : real)\n    ensures p == power(b, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Recursive version, imperative, with time and space complexity O(log n).\n\n// A simple test case to make sure the specification is adequate."}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_otherbSearch", "vc-description": "", "vc-preamble": "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}\n\n\n\n\n\n\n//Recursive binary search", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod otherbSearch(v:array<int>, elem:int) returns (b:bool,p:int)\n requires sorted(v[0..v.Length])\n ensures 0<=p<=v.Length\n ensures b == (elem in v[0..v.Length])\n ensures b ==> p<v.Length && v[p]==elem\n ensures !b ==> (forall u::0<=u<p ==> v[u]<elem) && \n               (forall w::p<=w<v.Length ==> v[w]>elem)\n //Implement and verify\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArrayReverse", "vc-description": "", "vc-preamble": "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxArrayReverse(arr : array<int>) returns (max: int)\n  requires arr.Length > 0\n  ensures forall i: int :: 0 <= i < arr.Length ==> arr[i] <= max\n  ensures exists x::0 <= x < arr.Length && arr[x] == max\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowRecursive", "vc-description": "", "vc-preamble": "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Search2PowRecursive( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    decreases n;\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_769_Difference", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_firstE_firstE", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod firstE(a: array<char>) returns (x: int)\nensures if 'e' in a[..] then 0 <= x < a.Length && a[x] == 'e' && forall i | 0 <= i < x :: a[i] != 'e' else x == -1\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_SegmentSum_MaxSegSum", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod MaxSegSum(a: seq<int>) returns (k: int, m: int)\n  ensures 0 <= k <= m <= |a|\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) <= Sum(a, k, m)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_751_IsMinHeap", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsMinHeap(a: array<int>) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length / 2 ==> a[i] <= a[2*i + 1] && (2*i + 2 == a.Length || a[i] <= a[2*i + 2])\n    ensures !result ==> exists i :: 0 <= i < a.Length / 2 && (a[i] > a[2*i + 1] || (2*i + 2 != a.Length && a[i] > a[2*i + 2]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_SqrSum1", "vc-description": "", "vc-preamble": "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program\n\n\n\n/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SqrSum1(n: int) returns (s: int)\n    requires n >= 0\n    ensures s == SqrSumRec(n)  // s = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_784_ProductEvenOdd", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\n\npredicate IsFirstEven(evenIndex: int, lst: seq<int>)\n    requires 0 <= evenIndex < |lst|\n    requires IsEven(lst[evenIndex])\n{\n    forall i :: 0 <= i < evenIndex ==> IsOdd(lst[i])\n}\n\npredicate IsFirstOdd(oddIndex: int, lst: seq<int>)\n    requires 0 <= oddIndex < |lst|\n    requires IsOdd(lst[oddIndex])\n{\n    forall i :: 0 <= i < oddIndex ==> IsEven(lst[i])\n}\n\n\nmethod FirstEvenOddIndices(lst : seq<int>) returns (evenIndex: int, oddIndex : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures 0 <= evenIndex < |lst|\n    ensures 0 <= oddIndex < |lst|\n    // This is the postcondition that ensures that it's the first, not just any\n    ensures IsEven(lst[evenIndex]) && IsFirstEven(evenIndex, lst)\n    ensures IsOdd(lst[oddIndex]) && IsFirstOdd(oddIndex, lst)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ProductEvenOdd(lst: seq<int>) returns (product : int)\n    requires |lst| >= 2\n    requires exists i :: 0 <= i < |lst| && IsEven(lst[i])\n    requires exists i :: 0 <= i < |lst| && IsOdd(lst[i])\n    ensures exists i, j :: 0 <= i < |lst| && IsEven(lst[i]) && IsFirstEven(i, lst) && \n                           0 <= j < |lst| && IsOdd(lst[j])  && IsFirstOdd(j, lst) && product == lst[i] * lst[j]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_factorial_factorial", "vc-description": "", "vc-preamble": "function fact(n: nat): nat \n    ensures fact(n) >= 1\n{\n    if n == 0 then 1 else n * fact(n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod factorial(n: nat) returns (res: nat)\n    ensures res == fact(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_171_PentagonPerimeter", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod PentagonPerimeter(side: int) returns (perimeter: int)\n    requires side > 0\n    ensures perimeter == 5 * side\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_is_even_ComputeIsEven", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Count_count", "vc-description": "", "vc-preamble": "function has_count(v: int, a: array<int>, n: int): int\n    reads a  // This allows the function to read from array 'a'\n    requires n >= 0 && n <= a.Length\n{\n    if n == 0 then 0 else\n    (if a[n-1] == v then has_count(v, a, n-1) + 1 else has_count(v, a, n-1))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod count (v: int, a: array<int>, n: int) returns (r: int)\n    requires n >= 0 && n <= a.Length;\n    ensures has_count(v, a, n) == r;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_759_IsDecimalWithTwoPrecision", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_tests_Search1000_Search2PowLoop", "vc-description": "", "vc-preamble": "// Author: Snorri Agnarsson, snorri@hi.is\n\n// Search1000 is a Dafny version of a function shown\n// by Jon Bentley in his old Programming Pearls\n// column in CACM.  Surprisingly Dafny needs no help\n// to verify the function.\n\n// Is2Pow(n) is true iff n==2^k for some k>=0.\npredicate Is2Pow( n: int )\n    decreases n;\n{\n    if n < 1 then\n        false\n    else if n == 1 then\n        true\n    else\n        n%2 == 0 && Is2Pow(n/2)\n}\n\n// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Search2PowLoop( a: array<int>, i: int, n: int, x: int ) returns ( k: int )\n    requires 0 <= i <= i+n <= a.Length;\n    requires forall p,q | i <= p < q < i+n :: a[p] <= a[q];\n    requires Is2Pow(n+1);\n    ensures i <= k <= i+n;\n    ensures forall r | i <= r < k :: a[r] < x;\n    ensures forall r | k <= r < i+n :: a[r] >= x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// This method is a binary search that only works for array\n// segments of size n == 2^k-1 for some k>=0."}
{"id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getRandomDataEntry", "vc-description": "", "vc-preamble": "method random(a: int, b: int) returns (r: int)\n//  requires a <= b\n  ensures a <= b ==> a <= r <= b\n\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod getRandomDataEntry<T(==)>(m_workList: array<T>, avoidSet: seq<T>) returns (e: T)\n  requires m_workList.Length > 0\n  ensures set_of_seq(avoidSet) < set_of_seq(m_workList[..]) ==> e !in avoidSet\n  ensures avoidSet < m_workList[..] ==> e in m_workList[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBinarySearch_search", "vc-description": "", "vc-preamble": "predicate sorted(s : seq<int>) {\n    forall u, w :: 0 <= u < w < |s| ==> s[u] <= s[w]\n}\n\nmethod binarySearch(v:array<int>, elem:int) returns (p:int)\n requires sorted(v[0..v.Length])\n ensures -1<=p<v.Length\n ensures (forall u::0<=u<=p ==> v[u]<=elem) && (forall w::p<w<v.Length ==> v[w]>elem)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod search(v:array<int>,elem:int) returns (b:bool)\n requires sorted(v[0..v.Length])\nensures b==(elem in v[0..v.Length])\n //Implement by calling binary search function\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Recursive binary search"}
{"id": "verified-using-dafny_tmp_tmp7jatpjyn_longestZero_longestZero", "vc-description": "", "vc-preamble": "function getSize(i: int, j:int) : int\n{\n    j - i + 1    \n}\n\n// For a given integer array, let's find the longest subesquence of 0s.\n// sz: size, pos: position.   a[pos..(pos+sz)] will be all zeros", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod longestZero(a: array<int>) returns (sz:int, pos:int)   \n    requires 1 <= a.Length\n    ensures 0 <= sz <= a.Length\n    ensures 0 <= pos < a.Length\n    ensures pos + sz <= a.Length\n    ensures forall i:int  :: pos <= i < pos + sz ==> a[i] == 0\n    ensures forall i,j :: (0 <= i < j < a.Length && getSize(i, j) > sz) ==> exists k :: i <= k <= j && a[k] != 0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExercisefirstZero_mfirstCero", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mfirstCero(v:array<int>) returns (i:int)\nensures 0 <=i<=v.Length\nensures forall j:: 0<=j<i ==> v[j]!=0 \nensures i!=v.Length ==> v[i]==0\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmpv_d3qi10_3_cumsum_cumsum", "vc-description": "", "vc-preamble": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_strange", "vc-description": "", "vc-preamble": "//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\nmethod q(x:nat, y:nat) returns (z:nat)\nrequires y - x > 2\nensures x < z*z < y\n\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b)\n{\n  assume{:axiom} false;\n}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod strange()\nensures 1==2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_799_RotateLeftBits", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RotateLeftBits(n: bv32, d: int) returns (result: bv32)\n    requires 0 <= d < 32\n    ensures result == ((n << d) | (n >> (32 - d)))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_rolling_max", "vc-description": "", "vc-preamble": "function isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod rolling_max(numbers: seq<int>) returns (result: seq<int>)\nrequires numbers != []\nensures |result| == |numbers|\nensures forall i :: 0 < i < |result| ==> isMax(result[i], numbers[0..(i+1)])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-3-TwoDuplicates_Search", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 3: Two equal elements\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: An integer array a of length n+2 with n>=2. It is known that at\nleast two values stored in the array appear twice (i.e., there are at\nleast two duplets).\n\nImplement and verify a program finding such two values.\n\nYou may assume that the array contains values between 0 and n-1.\n*/\n\n// Remarks:\n\n// The implementation of method 'Search' takes one pass through the elements of\n// the given array.  To keep track of what it has seen, it allocates an array as\n// temporary storage--I imagine that this is what the competition designers\n// had in mind, since the problem description says one can assume the values\n// of the given array to lie in the range 0..n.\n\n// To keep track of whether it already has found one duplicate, the method\n// sets the output variables p and q as follows:\n//   p != q   - no duplicates found yet\n//   p == q   - one duplicate found so far, namely the value stored in p and q\n// Note, the loop invariant does not need to say anything about the state\n// of two duplicates having been found, because when the second duplicate is\n// found, the method returns.\n\n// What needs to be human-trusted about this program is the specification of\n// 'Search'.  The specification straightforwardly lists the assumptions stated\n// in the problem description, including the given fact that the array contains\n// (at least) two distinct elements that each occurs (at least) twice.  To\n// trust the specification of 'Search', a human also needs to trust the definition\n// of 'IsDuplicate' and its auxiliary function 'IsPrefixDuplicate'.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 11 seconds)\n// without further human intervention.\n\nghost predicate IsDuplicate(a: array<int>, p: int)\n  reads a\n{\n  IsPrefixDuplicate(a, a.Length, p)\n}\n\nghost predicate IsPrefixDuplicate(a: array<int>, k: int, p: int)\n  requires 0 <= k <= a.Length;\n  reads a;\n{\n  exists i,j :: 0 <= i < j < k && a[i] == a[j] == p\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Search(a: array<int>) returns (p: int, q: int)\n  requires 4 <= a.Length;\n  requires exists p,q :: p != q && IsDuplicate(a, p) && IsDuplicate(a, q);  // two distinct duplicates exist\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] < a.Length - 2;  // the elements of \"a\" in the range [0.. a.Length-2]\n  ensures p != q && IsDuplicate(a, p) && IsDuplicate(a, q);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-Verification_tmp_tmpv4ueky2d_Best_Time_to_Buy_and_Sell_Stock_best_time_to_buy_and_sell_stock_best_time_to_buy_and_sell_stock", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_DivMode_Unary_IterativeDivMod", "vc-description": "", "vc-preamble": "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\n// definitions borrowed from Rustan Leino's Program Proofs Chapter 7\n// (https://program-proofs.com/code.html example code in Dafny; source file 7-Unary.dfy)\ndatatype Unary = Zero | Suc(pred: Unary)\n\nghost function UnaryToNat(x: Unary): nat {\n  match x\n  case Zero => 0\n  case Suc(x') => 1 + UnaryToNat(x')\n}\n\nghost function NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Suc(NatToUnary(n-1))\n}\n\npredicate Less(x: Unary, y: Unary) {\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\npredicate LessAlt(x: Unary, y: Unary) {\n  y != Zero && (x == Zero || Less(x.pred, y.pred))\n}\n\nfunction Add(x: Unary, y: Unary): Unary {\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nfunction Mul(x: Unary, y: Unary): Unary {\n  match x\n  case Zero => Zero\n  case Suc(x') => Add(Mul(x', y), y)\n}\n\n/*\nGoal: implement correcly and clearly, using iterative code (no recursion), documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n\n- DO NOT modify the specification or any of the definitions given in this file\n- Not all definitions above are relevant, some are simply included as examples\n- Feel free to use existing non-ghost functions/predicates in your code, and existing lemmas (for the proof) in your annotations\n- New functions/predicates may be added ONLY as ghost\n- If it helps you in any way, a recursive implementation + proof can be found in the book and the downloadable source file\n  [https://program-proofs.com/code.html example code in Dafny, source file 7-Unary.dfy]\n*/\n\nmethod IterativeDivMod'(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IterativeDivMod(x: Unary, y: Unary) returns (d: Unary, m: Unary)\n  requires y != Zero\n  ensures Add(Mul(d, y), m) == x && Less(m, y)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_126_SumOfCommonDivisors", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumOfCommonDivisors(a: int, b: int) returns (sum: int)\n    requires a > 0 && b > 0\n    ensures sum >= 0\n    ensures forall d :: 1 <= d <= a && 1 <= d <= b && a % d == 0 && b % d == 0 ==> sum >= d\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_online_max_onlineMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_234_CubeVolume", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CubeVolume(size: int) returns (volume: int)\n    requires size > 0\n    ensures volume == size * size * size\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_solve", "vc-description": "", "vc-preamble": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\n\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\n\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\n\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i]\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_countNeg_CountNeg", "vc-description": "", "vc-preamble": "function verifyNeg(a: array<int>, idx: int) : nat\nreads a\nrequires 0 <= idx <= a.Length\n{\n    if idx == 0 then 0 \n    else verifyNeg(a, idx - 1) + (if a[idx - 1] < 0 then 1 else 0)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountNeg(a: array<int>) returns (cnt: nat) \nensures cnt == verifyNeg(a, a.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_examples_tmp_tmp8qotd4ez_leetcode_0069-sqrt_mySqrt", "vc-description": "", "vc-preamble": "// Author: Shaobo He\n\npredicate sqrt(x: int, r: int) {\n    r*r <= x && (r+1)*(r+1) > x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mySqrt(x: int) returns (res: int)\nrequires 0 <= x;\nensures sqrt(x, res);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot1", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mroot1(n:int) returns (r:int) //Cost O(root n)\nrequires n>=0\nensures r>=0 && r*r <= n <(r+1)*(r+1)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_double_array_elements_double_array_elements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod double_array_elements(s: array<int>)\n  modifies s\n  ensures forall i :: 0 <= i < s.Length ==> s[i] == 2 * old(s[i])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_comp_Arrays_LinearSearch", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cs \"%s\" > \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:js \"%s\" >> \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:go \"%s\" >> \"%t\"\n// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:java \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nmethod PrintArray<A>(a: array?<A>)\n{\n  assume{:axiom} false;\n}\n\n\ntype lowercase = ch | 'a' <= ch <= 'z' witness 'd'\n\n\n\nmethod DiagMatrix<A>(rows: int, cols: int, zero: A, one: A)\n    returns (a: array2<A>)\n    requires rows >= 0 && cols >= 0\n{\n  assume{:axiom} false;\n}\n\nmethod PrintMatrix<A>(m: array2<A>)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod LinearSearch(a: array<int>, key: int) returns (n: nat)\n  ensures 0 <= n <= a.Length\n  ensures n == a.Length || a[n] == key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_133_SumOfNegatives", "vc-description": "", "vc-preamble": "function sumNegativesTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  decreases n;\n  reads a;\n{\n  if (n == 0) then 0 else if a[n-1] < 0 then sumNegativesTo(a, n-1) + a[n-1] else sumNegativesTo(a, n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SumOfNegatives(a: array<int>) returns (result: int)\n    ensures result == sumNegativesTo(a, a.Length)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_626_AreaOfLargestTriangleInSemicircle", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AreaOfLargestTriangleInSemicircle(radius: int) returns (area: int)\n    requires radius > 0\n    ensures area == radius * radius\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_BubbleSort_bubbleSort", "vc-description": "", "vc-preamble": "predicate sorted(a:array<int>, from:int, to:int)\n  requires a != null;\n  reads a;\n  requires 0 <= from <= to <= a.Length;\n{\n  forall u, v :: from <= u < v < to ==> a[u] <= a[v]\n}\n\npredicate pivot(a:array<int>, to:int, pvt:int)\n  requires a != null;\n  reads a;\n  requires 0 <= pvt < to <= a.Length;\n{\n  forall u, v :: 0 <= u < pvt < v < to ==> a[u] <= a[v]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod bubbleSort (a: array<int>)\n  requires a != null && a.Length > 0;\n  modifies a;\n  ensures sorted(a, 0, a.Length);\n  ensures multiset(a[..]) == multiset(old(a[..]));\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_swap_bitvector_SwapBitvectors", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_143_CountArrays", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountArrays(arrays: seq<array<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |arrays|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_double_quadruple_DoubleQuadruple", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_array_append_append", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_574_CylinderSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CylinderSurfaceArea(radius: real, height: real) returns (area: real)\n    requires radius > 0.0 && height > 0.0\n    ensures area == 2.0 * 3.14159265358979323846 * radius * (radius + height)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "630-dafny_tmp_tmpz2kokaiq_Solution_BinarySearch", "vc-description": "", "vc-preamble": "function sorted(a: array<int>) : bool\n    reads a\n{\n   forall i,j : int :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(a: array<int>, x: int) returns (index: int)\n    requires sorted(a)\n    ensures 0 <= index < a.Length ==> a[index] == x\n    ensures index == -1 ==> forall i : int :: 0 <= i < a.Length ==> a[i] != x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-programs_tmp_tmpcwodh6qh_src_expt_expt", "vc-description": "", "vc-preamble": "ghost function Expt(b: int, n: nat): int\n  requires n >= 0\n{\n  if n == 0 then 1 else b * Expt(b, n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod expt(b: int, n: nat) returns (res: int) \n  ensures res == Expt(b, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerIter", "vc-description": "", "vc-preamble": "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n  decreases n\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod powerIter(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Recursive version, imperative, with time and space complexity O(log n).\n\n// States the property x^a * x^b = x^(a+b), that powerOpt takes advantage of. \n// The annotation {:induction a} guides Dafny to prove the property\n// by automatic induction on 'a'.\n\n// A simple test case to make sure the specification is adequate."}
{"id": "vfag_tmp_tmpc29dxm1j_Verificacion_torneo_torneo", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod torneo(Valores : array?<real>, i : int, j : int, k : int) returns (pos_padre : int, pos_madre : int)\n    requires Valores != null && Valores.Length >= 20 && Valores.Length < 50 && i >= 0 && j >= 0 && k >= 0 \n    requires i < Valores.Length && j < Valores.Length && k < Valores.Length && i != j && j != k && k != i \n    ensures exists p, q, r | p in {i, j, k} && q in {i, j, k} && r in {i, j, k} && p != q && q != r && p != r :: Valores[p] >= Valores[q] >= Valores[r] && pos_padre == p && pos_madre == q // Q\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_testPrimeness", "vc-description": "", "vc-preamble": "//predicate for primeness\nghost predicate prime(n: nat)\n\n{ n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }\n\ndatatype Answer = Yes | No | Unknown\n\n//the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number\n//is not in the database it returns Unknown\nclass {:autocontracts} PrimeMap{\n\n  var database: map<nat, bool>; \n\n//the valid invariant of the class\n  ghost predicate Valid()\n    reads this\n  {\n    forall i | i in database.Keys :: (database[i] == true <==> prime(i)) \n  }\n\n//the constructor\n  constructor()\n    ensures database == map[]\n  {\n    database := map[];\n  }\n\n\n  // lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,\n  // or with Unknown when it's not in the databse\nmethod IsPrime?(n: nat) returns (answer: Answer) \n      ensures database.Keys == old(database.Keys)\n      ensures (n in database) && prime(n) <==> answer == Yes \n      ensures (n in database) && !prime(n) <==> answer == No \n      ensures !(n in database) <==> answer == Unknown\n{\n  assume{:axiom} false;\n}\n\n  // method to test whether a number is prime, returns bool\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod testPrimeness(n: nat) returns (result: bool) \n      requires n >= 0\n      ensures result <==> prime(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_792_CountLists", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountLists(lists: seq<seq<int>>) returns (count: int)\n    ensures count >= 0\n    ensures count == |lists|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_binary_search_BinarySearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  ensures 0<= n <=a.Length\n  ensures forall i :: 0<= i < n ==> a[i] < key\n  ensures n == a.Length ==> forall i :: 0 <= i < a.Length ==> a[i] < key\n  ensures forall i :: n<= i < a.Length ==> a[i]>=key\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_insert_insert", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_bubble_sort_BubbleSort", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BubbleSort(a: array<int>)\n  modifies a\n  ensures forall i,j::0<= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..])==multiset(old(a[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_find_Find", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2017\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from Dafny tutorial\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Find(a: array<int>, key: int) returns (i: int)\n   requires a != null;\n   // if i is non-negative then \n   ensures 0 <= i ==> (// (1) i is smaller than the length of a\n                       i < a.Length && \n                       // (2) key is at position i in a\n                       a[i] == key && \n                       // (3) i is the smallest position where key appears\n                       forall k :: 0 <= k < i ==> a[k] != key\n                      );\n   // if index is negative then\n   ensures i < 0 ==> \n           // a does not contain key\n           forall k :: 0 <= k < a.Length ==> a[k] != key;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_count_lessthan_CountLessThan", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "vfag_tmp_tmpc29dxm1j_sumar_componentes_suma_componentes", "vc-description": "", "vc-preamble": "function suma_aux(V : array?<int>, n : int) : int\n\n  // suma_aux(V, n) = V[n] + V[n + 1] + ... + V[N - 1]\n\n  requires V != null            // P_0\n  requires 0 <= n <= V.Length       // Q_0\n\n  decreases V.Length - n        // C_0\n\n  reads V\n\n{\n\n  if (n == V.Length) then 0                     // Caso base:      n = N\n                     else V[n] + suma_aux(V, n + 1)     // Caso recursivo: n < N\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod suma_componentes(V : array?<int>) returns (suma : int)\n\n  requires V != null\n  ensures  suma == suma_aux(V, 0)   // x = V[0] + V[1] + ... + V[N - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Simulink-To_dafny_tmp_tmpbcuesj2t_Tank_checkRegulation", "vc-description": "", "vc-preamble": "datatype Valve = ON | OFF\n\nclass Pipe{\n   var v1: Valve; //outlet valve \n   var v2: Valve; //inlet Valve\n   var v3: Valve; //outlet valve\n   var in_flowv1: int; //flow in valve v1\n   var in_flowv2: int; //flow in vave v2\n   var in_flowv3: int; //flow in valve v3\n\n   constructor()\n   {\n       this.v1:= OFF;\n       this.v2:= ON;\n   }\n\n}\nclass Tank\n{\n   var pipe: Pipe;\n   var height: int;\n    constructor()\n    {\n        pipe := new Pipe();\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod checkRegulation(tank: Tank)\n //requires tank.pipe.v1==OFF && tank.pipe.v2==ON && (tank.pipe.v3==OFF || tank.pipe.v2==ON) \nensures (tank.height>10 && tank.pipe.v1==OFF && tank.pipe.v3==ON && tank.pipe.v2==old(tank.pipe.v2)) \n|| (tank.height <8 && tank.pipe.v1== OFF && tank.pipe.v2== ON && tank.pipe.v3==old(tank.pipe.v3))\n|| ((tank.pipe.in_flowv3 >5 || tank.pipe.in_flowv1 >5 ) && tank.pipe.v2==OFF && tank.pipe.v3==old(tank.pipe.v3) && tank.pipe.v1==old(tank.pipe.v1))\nmodifies tank.pipe;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafleet_tmp_tmpa2e4kb9v_0001-0050_0001-two-sum_twoSum", "vc-description": "", "vc-preamble": "/* https://leetcode.com/problems/two-sum/\nGiven an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n*/\n\n\nghost predicate correct_pair(pair: (int, int), nums: seq<int>, target: int) {\n  var (i, j) := pair;\n  && 0 <= i < |nums|\n  && 0 <= j < |nums|\n  && i != j  // \"you may not use the same element twice\"\n  && nums[i] + nums[j] == target\n}\n\n// We actually make a weaker pre-condition: there exists at least one solution.\n// For verification simplicity, we pretend as if:\n// - `seq` were Python list\n// - `map` were Python dict\n\n/* Discussions\n1. It may be tempting to append `&& e_to_i[nums[i']] == i'` to the invariant (formula A),\n  but this is wrong, because `nums` may contain redundant elements.\n  Redundant elements will share the same key in `e_to_i`, the newer overwriting the older.\n\n2. Tip: Generally, we often need invariants when copying data from a container to another.\n  To specify a set/map, we often need \"back and forth\" assertions, namely:\n  (a) What elements are in the map/set (like in formula A)\n  (b) What do elements in the set/map satisfy (like in formula B)\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod twoSum(nums: seq<int>, target: int) returns (pair: (int, int))\n  requires exists i, j :: correct_pair((i, j), nums, target)\n  ensures correct_pair(pair, nums, target)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "assertive-programming-assignment-1_tmp_tmp3h_cj44u_SearchAddends_FindAddends", "vc-description": "", "vc-preamble": "predicate Sorted(q: seq<int>)\n{\n    forall i,j :: 0 <= i <= j < |q| ==> q[i] <= q[j] \n}\n\npredicate HasAddends(q: seq<int>, x: int)\n{\n    exists i,j :: 0 <= i < j < |q| && q[i] + q[j] == x\n}\n\npredicate IsValidIndex<T>(q: seq<T>, i: nat)\n{\n    0 <= i < |q|\n}\n\npredicate AreOreredIndices<T>(q: seq<T>, i: nat, j: nat)\n{\n    0 <= i < j < |q|\n}\n\npredicate AreAddendsIndices(q: seq<int>, x: int, i: nat, j: nat)\n    requires IsValidIndex(q, i) && IsValidIndex(q, j)\n{\n    q[i] + q[j] == x\n}\n\npredicate HasAddendsInIndicesRange(q: seq<int>, x: int, i: nat, j: nat)\n    requires AreOreredIndices(q, i, j)\n{\n    HasAddends(q[i..(j + 1)], x)\n}\n\npredicate LoopInv(q: seq<int>, x: int, i: nat, j: nat, sum: int)\n{\n    AreOreredIndices(q, i, j) &&\n    HasAddendsInIndicesRange(q, x, i, j) &&\n    AreAddendsIndices(q, sum, i, j)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindAddends(q: seq<int>, x: int) returns (i: nat, j: nat)\n    requires Sorted(q) && HasAddends(q, x)\n    ensures i < j < |q| && q[i]+q[j] == x\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_FindMin", "vc-description": "", "vc-preamble": "//Problem01\n//a)\n\n//b)\n//Problem04\n\n//Problem02\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n\n\n\n//Problem03", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindMin(a: array<int>, lo: nat) returns (minIdx: nat)\n    requires a != null && a.Length > 0 && lo < a.Length\n    ensures lo <= minIdx < a.Length\n    ensures forall x :: lo <= x < a.Length ==> a[minIdx] <= a[x]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal-verification_tmp_tmpoepcssay_strings3_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "predicate isSubstring(sub: string, str: string)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nmethod haveCommonKSubstring(k: nat, str1: string, str2: string) returns (found: bool)\n    ensures found  <==>  haveCommonKSubstringPred(k,str1,str2)\n    ensures !found <==> haveNotCommonKSubstringPred(k,str1,str2) // This postcondition follows from the above lemma.\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod maxCommonSubstringLength(str1: string, str2: string) returns (len:nat)\n    requires (|str1| <= |str2|)\n    ensures (forall k :: len < k <= |str1| ==> !haveCommonKSubstringPred(k,str1,str2))\n    ensures haveCommonKSubstringPred(len,str1,str2)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_602_FindFirstRepeatedChar", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindFirstRepeatedChar(s: string) returns (found: bool, c: char)\n    ensures found ==> exists i, j :: 0 <= i < j < |s| && s[i] == s[j] && s[i] == c && (forall k, l :: 0 <= k < l < j && s[k] == s[l] ==> k >= i)\n    ensures !found ==> (forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j])\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "DafnyProjects_tmp_tmp2acw_s4s_longestPrefix_longestPrefix", "vc-description": "", "vc-preamble": "// MFES, Exam 8/Sept/20201, Exercise 5 \n\n// Computes the length (i) of the longest common prefix (initial subarray) \n// of two arrays a and b.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod longestPrefix(a: array<int>, b: array <int>) returns (i: nat) \n ensures i <= a.Length && i <= b.Length\n ensures a[..i] == b[..i]\n ensures i < a.Length && i < b.Length ==> a[i] != b[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Test method with an example."}
{"id": "Clover_array_sum_arraySum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_fibonacci_sequence_FibonacciIterative", "vc-description": "", "vc-preamble": "// definition of Fibonacci numbers\nfunction Fibonacci(n: nat): nat {\n  match n {\n    case 0 => 0\n    case 1 => 1\n    case _ => Fibonacci(n - 1) + Fibonacci(n - 2)\n  }\n}\n\n// iterative calculation of Fibonacci numbers", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FibonacciIterative(n: nat) returns (f: nat)\n  ensures f == Fibonacci(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_578_Interleave", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Interleave(s1: seq<int>, s2: seq<int>, s3: seq<int>) returns (r: seq<int>)\n    requires |s1| == |s2| && |s2| == |s3|\n    ensures |r| == 3 * |s1|\n    ensures forall i :: 0 <= i < |s1| ==> r[3*i] == s1[i] && r[3*i + 1] == s2[i] && r[3*i + 2] == s3[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_mod2_mod2", "vc-description": "", "vc-preamble": "ghost function f2(n: nat): nat {\n    if n == 0 then 0\n    else 5*f2(n/3) + n%4\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mod2(n:nat) returns (a:nat) \nensures a == f2(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "formal_verication_dafny_tmp_tmpwgl2qz28_Challenges_ex6_BullsCows", "vc-description": "", "vc-preamble": "// see pdf 'ex6 & 7 documentation' for excercise question\n\nfunction bullspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{reccbull(s, u, 0)}\n\nfunction cowspec(s:seq<nat>, u:seq<nat>): nat\nrequires 0 <= |u| == |s| && nomultiples(u)\n{recccow(s, u, 0)}\n\nfunction reccbull(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i ==|s| then 0\n    else if s[i] == u[i] then reccbull(s, u, i + 1) + 1\n    else reccbull(s, u, i + 1)\n}\n\nfunction recccow(s: seq<nat>, u:seq<nat>, i:int): nat\nrequires 0 <= i <= |s| == |u|\ndecreases |s| - i\n{\n    if i == |s| then 0\n    else if s[i] != u[i] && u[i] in s then recccow(s, u, i + 1) + 1\n    else recccow(s, u, i + 1)\n}\n\npredicate nomultiples(u:seq<nat>) \n{forall j, k :: 0<=j<k<|u| ==> u[j] != u[k]}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BullsCows (s:seq<nat>, u:seq<nat>) returns (b:nat, c:nat) \nrequires 0 < |u| == |s| <= 10\nrequires nomultiples(u) && nomultiples(s);\nensures b >= 0 && c >= 0\nensures b == bullspec(s, u)\nensures c == cowspec(s, u)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "AssertivePrograming_tmp_tmpwf43uz0e_Find_Substring_FindFirstOccurrence", "vc-description": "", "vc-preamble": "// Noa Leron 207131871\n// Tsuri Farhana 315016907\n\n\nghost predicate ExistsSubstring(str1: string, str2: string) {\n    // string in Dafny is a sequence of characters (seq<char>) and <= on sequences is the prefix relation\n    exists offset :: 0 <= offset <= |str1| && str2 <= str1[offset..]\n}\n\nghost predicate Post(str1: string, str2: string, found: bool, i: nat) {\n    (found <==> ExistsSubstring(str1, str2)) &&\n    (found ==> i + |str2| <= |str1| && str2 <= str1[i..])\n}\n\n/*\nGoal: Verify correctness of the following code. Once done, remove the {:verify false} (or turn it into {:verify true}).\n\nFeel free to add GHOST code, including calls to lemmas. But DO NOT modify the specification or the original (executable) code.\n*/\n\n//this is our lemmas, invatiants and presicats\n\n\nghost predicate Outter_Inv_correctness(str1: string, str2: string, found: bool, i : nat)\n{\n    (found ==> (i + |str2| <= |str1| && str2 <= str1[i..])) // Second part of post condition\n    &&\n    (!found &&  0 < i <= |str1| && i != |str2|-1 ==> !(ExistsSubstring(str1[..i], str2))) // First part of post condition\n    &&\n    (!found ==> i <= |str1|)\n}\n\nghost predicate Inner_Inv_correctness(str1: string, str2: string, i : nat, j: int, found: bool){\n    0 <= j <= i && // index in range\n    j < |str2| && // index in range\n    i < |str1| &&// index in range\n    (str1[i] == str2[j] ==> str2[j..] <= str1[i..]) &&\n    (found ==> j==0 && str1[i] == str2[j])\n}\n\nghost predicate Inner_Inv_Termination(str1: string, str2: string, i : nat, j: int, old_i: nat, old_j: nat){\n    old_j - j == old_i - i\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindFirstOccurrence(str1: string, str2: string) returns (found: bool, i: nat)\n    ensures Post(str1, str2, found, i)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TuringFactorial_ComputeFactorial", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ComputeFactorial(n: int) returns (u: int)\n  requires 1 <= n;\n  ensures u == Factorial(n);\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_rotate_rotate", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod rotate(a: array<int>, offset:int) returns (b: array<int> )\n  requires 0<=offset\n  ensures b.Length==a.Length\n  ensures forall  i::0<=i<a.Length ==>  b[i]==a[(i+offset)%a.Length]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_594_FirstEvenOddDifference", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_790_IsEvenAtIndexEven", "vc-description": "", "vc-preamble": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsEvenAtIndexEven(lst: seq<int>) returns (result: bool)\n    ensures result <==> forall i :: 0 <= i < |lst| ==> (IsEven(i) ==> IsEven(lst[i]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_ArraySum", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod ArraySum (a : array<int>, b : array<int>) returns (c : array<int>)\n    requires a.Length == b.Length\n    ensures c.Length == a.Length && \n        forall i : int :: 0 <= i < c.Length ==> c[i] == a[i] + b[i] // TODO\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates."}
{"id": "SENG2011_tmp_tmpgk5jq85q_ass2_ex3_BadSort", "vc-description": "", "vc-preamble": "// verifies\n// all bs are before all as which are before all ds\n\npredicate sortedbad(s:string) \n{\n    // all b's are before all a's and d's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'b' && (s[j] == 'a' || s[j] == 'd') ==> i < j &&\n    // all a's are after all b's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'b' ==> i > j &&\n    // all a's are before all d's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'a' && s[j] == 'd' ==> i < j &&\n    // all d's are after a;; b's and a's\n    forall i,j :: 0 <= i < |s| && 0 <= j < |s| && s[i] == 'd' && (s[j] == 'a' || s[j] == 'b') ==> i > j\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod BadSort(a: string) returns (b: string)\nrequires forall k :: 0 <= k < |a| ==> a[k] == 'b' || a[k] == 'a' || a[k] == 'd';\nensures sortedbad(b);\nensures multiset(a[..]) == multiset(b[..]);\nensures |a| == |b|;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_1_LinearSearch_SearchRecursive", "vc-description": "", "vc-preamble": "// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/0HRr\n\n// Author of solution:    Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/8pxWd\n\n// Use the command\n//   dafny LinearSearch-skeleton.dfy\n// or\n//   compile LinearSearch-skeleton.dfy\n// to compile the file.\n// Or use the web page rise4fun.com/dafny.\n\n// When you have solved the problem put\n// the solution on the Dafny web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod SearchRecursive( a: seq<int>, i: int, j: int, x: int ) returns (k: int)\n    decreases j-i;\n    requires 0 <= i <= j <= |a|;\n    ensures i <= k < j || k == -1;\n    ensures k != -1 ==> a[k] == x;\n    ensures k != -1 ==> forall r | k < r < j :: a[r] != x;\n    ensures k == -1 ==> forall r | i <= r < j :: a[r] != x;\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_3_IsNonPrime", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_14_TriangularPrismVolume", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod TriangularPrismVolume(base: int, height: int, length: int) returns (volume: int)\n    requires base > 0\n    requires height > 0\n    requires length > 0\n    ensures volume == (base * height * length) / 2\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array_FindMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_284_AllElementsEqual", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AllElementsEqual(a: array<int>, n: int) returns (result: bool)\n    requires a != null\n    ensures result ==> forall i :: 0 <= i < a.Length ==> a[i] == n\n    ensures !result ==> exists i :: 0 <= i < a.Length && a[i] != n\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Clover_copy_part_copy", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod copy( src: array<int>, sStart: nat, dest: array<int>, dStart: nat, len: nat) returns (r: array<int>)\n  requires src.Length >= sStart + len\n  requires dest.Length >= dStart + len\n  ensures r.Length == dest.Length\n  ensures r[..dStart] == dest[..dStart]\n  ensures r[dStart + len..] == dest[dStart + len..]\n  ensures r[dStart..len+dStart] == src[sStart..len+sStart]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_632_swap", "vc-description": "", "vc-preamble": "function count(arr: seq<int>, value: int) : (c: nat)\n    ensures c <= |arr|\n{\n    if |arr| == 0 then 0 else (if arr[0] == value then 1 else 0) + count(arr[1..], value)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod swap(arr: array<int>, i: int, j: int)\n    requires arr.Length > 0\n    requires 0 <= i < arr.Length && 0 <= j < arr.Length\n    modifies arr\n    ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n    ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n    ensures multiset(arr[..]) == multiset(old(arr[..]))\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-synthesis_task_id_70_AllSequencesEqualLength", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod AllSequencesEqualLength(sequences: seq<seq<int>>) returns (result: bool)\n    ensures result <==> forall i, j :: 0 <= i < |sequences| && 0 <= j < |sequences| ==> |sequences[i]| == |sequences[j]|\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_sumBackwards", "vc-description": "", "vc-preamble": "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod sumBackwards(n: nat) returns (r: nat)\n  ensures r == sum(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_binary-search_binSearch", "vc-description": "", "vc-preamble": "///////////////////\n// Binary search\n///////////////////\n\n\npredicate isSorted(a:array<int>)\n  reads a\n{\n  forall i:nat, j:nat :: i <= j < a.Length ==> a[i] <= a[j]\n}\n\n\n// a[lo] <= a[lo+1] <= ... <= a[hi-2] <= a[hi-1]\n\n/* Note: the following definition of isSorted:\n\n\nalthough equivalent to the one above is not enough for Dafny to be able \nto prove the invariants for the loop in binSearch.\n\nThe given one works because it *explicitly* states that every element \nof the input array is smaller than or equal to all later elements. \nThis fact is implied by the alternative definition of isSorted given \nhere (which only talks about array elements and their successors). \nHowever, it needs to be derived as an auxiliary lemma first, something \nthat Dafny is not currently able to do automatically. \n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod binSearch(a:array<int>, K:int) returns (b:bool)\n  requires isSorted(a)\n  ensures b == exists i:nat :: i < a.Length && a[i] == K\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_mathematical_objects_verification_examples_fast_exp_FastExp", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nfunction exp(b: nat, n: nat): nat {\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nfunction bits(n: nat): seq<bool>\n  decreases n\n{\n  if n == 0 then []\n  else [if (n % 2 == 0) then false else true] + bits(n/2)\n}\n\nfunction from_bits(s: seq<bool>): nat {\n  if s == [] then 0\n  else (if s[0] then 1 else 0) + 2 * from_bits(s[1..])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod FastExp(b: nat, n: nat) returns (r: nat)\n  ensures r == exp(b, n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum1", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod mmaximum1(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": "//Algorithm 2: From right to left return the last\n\n\n\n\n//Algorithm : from left to right\n//Algorithm : from right to left"}
{"id": "dafny-synthesis_task_id_18_RemoveChars", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "SENG2011_tmp_tmpgk5jq85q_exam_ex3_Symmetric", "vc-description": "", "vc-preamble": "/*\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Symmetric(a: array<int>) returns (flag: bool)\nensures flag == true ==> forall x :: 0 <= x < a.Length ==> a[x] == a[a.Length - x - 1]\nensures flag == false ==> exists x :: 0 <= x < a.Length && a[x] != a[a.Length - x - 1]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_queryFast", "vc-description": "", "vc-preamble": "// 1 a)\n\n// [ai, aj[\nfunction sum(a: array<int>, i: int, j: int) : int\n  requires 0 <= i <= j <= a.Length\n  reads a\n  decreases j\n{\n  if i == j then 0\n  else a[j-1] + sum(a, i, j-1)\n}\n\n// 1 b)\n\n// 1 c)\n// a -> [1, 10, 3, −4, 5]\n// c -> [0, 1, 11, 14, 10, 15]\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n  reads c, a\n{\n  a.Length + 1 == c.Length && forall i: int :: 0 <= i <= a.Length ==> c[i] == sum(a, 0, i)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod queryFast(a: array<int>, c: array<int>, i: int, j: int) returns (r: int)\n  requires 0 <= i <= j <= a.Length\n  requires is_prefix_sum_for(a,c)\n  ensures r == sum(a, i, j)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_GetInsertIndex", "vc-description": "", "vc-preamble": "// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\n\n/*\n*/\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\n\n\n*/\n\n// TODO play with this for keys==Contents\n\n\nghost predicate SortedSeq(a: seq<int>)\n  //sequence is sorted from left to right\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\n/*\nmethod InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])\n{\n  assume{:axiom} false;\n}\n*/\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n{\n  assume{:axiom} false;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n  // get index so that array stays sorted\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny-exercise_tmp_tmpouftptir_filter_Filter", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod Filter(a:seq<char>, b:set<char>) returns(c:set<char>) \nensures forall x :: x in a && x in b <==> x in c\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
{"id": "dafny_misc_tmp_tmpg4vzlnm1_rosetta_code_factorial_IterativeFactorial", "vc-description": "", "vc-preamble": "// recursive definition of factorial\nfunction Factorial(n: nat): nat {\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\n// iterative implementation of factorial", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// <vc-spec>\nmethod IterativeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n// </vc-spec>", "vc-code": "// <vc-code>\n{\n  assume false;\n}\n// </vc-code>", "vc-postamble": ""}
