{"id": "DD0001", "language": "dafny", "source": "dafnybench", "source_id": "703FinalProject_tmp_tmpr_10rn4z_DP-GD_DPGD_GradientPerturbation", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DPGD_GradientPerturbation (size:int, learning_rate:real, noise_scale:real, gradient_norm_bound:real, iterations:int) returns (Para:real, PrivacyLost:real)\n  requires iterations>=0\n  requires size>=0\n  requires noise_scale >= 1.0\n  requires -1.0 <= gradient_norm_bound <= 1.0", "vc-code": "{\n  var thetha:array<real> := new real[iterations+1];\n  thetha[0] := *;\n  var alpha:real := 0.0;\n  var tau:real := *;\n  assume(tau>=0.0);\n  var t :int := 0;\n  var constant:real := (size as real) * tau;\n  while (t < iterations)\n    invariant t <= iterations\n    invariant alpha == t as real * constant\n  {\n    var i :int := 0;\n    var beta:real := 0.0;\n    var summation_gradient:real := 0.0;\n    while (i< size)\n      invariant i <= size\n      invariant beta == i as real * tau\n    {\n      var gradient:real := *;\n      // Note: We do not need to clip the value of the gradient.\n      // Instead, we clip the sensitivity of the gradient by the gradient_norm_bound provided by the user\n      var eta:real := *;\n      beta := beta + tau;\n      var eta_hat:real := - gradient_norm_bound;\n      assert (gradient_norm_bound + eta_hat == 0.0);\n      summation_gradient := summation_gradient + gradient + eta;\n      i := i + 1;\n    }\n    alpha := alpha + beta;\n    thetha[t+1] := thetha[t] - learning_rate*summation_gradient;\n    t := t+1;\n  }\n  assert(t==iterations);\n  assert(alpha == iterations as real * constant);\n  Para := thetha[iterations];\n  PrivacyLost := alpha;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0002", "language": "dafny", "source": "dafnybench", "source_id": "703FinalProject_tmp_tmpr_10rn4z_gaussian_gaussian", "vc-description": "", "vc-preamble": "// VERIFY USING DAFNY:\n// /Applications/dafny/dafny /Users/apple/GaussianDP/Dafny/gaussian.dfy", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method gaussian (size:int, q: array<real>, q_hat: array<real>) returns (out: array<real>)\nrequires q_hat.Length==size\nrequires q.Length==size\nrequires size > 0\nrequires arraySquaredSum(q_hat[..]) <= 1.0", "vc-code": "{\n var i : int := 0;\n  var alpha : real := arraySquaredSum(q_hat[..1]);\n var eta: real := 0.0;\n var eta_hat: real := 0.0;\n out := new real[size];\n while (i <size)\n invariant 0 < i <= size ==> alpha <= arraySquaredSum(q_hat[..i])\n invariant i<=size\n {\n  eta := *;\n  eta_hat := - q_hat[i];\n  alpha := arraySquaredSum(q_hat[..i+1]);\n  assert (q_hat[i] + eta_hat ==0.0);\n  out[i] := q[i] + eta;\n  i := i+1;\n }\n assert i==size;\n assert alpha <= arraySquaredSum(q_hat[..size]);\n assert q_hat[..size] == q_hat[..];\n assert alpha <= arraySquaredSum(q_hat[..]);\n assert alpha <= 1.0;\n}", "vc-postamble": "function arraySquaredSum(a: seq<real>): real\nrequires |a| > 0\n{\n  if |a| == 1 then \n    a[0]*a[0]\n  else \n    (a[0]*a[0]) + arraySquaredSum(a[1..])\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0010", "language": "dafny", "source": "dafnybench", "source_id": "BPTree-verif_tmp_tmpq1z6xm1d_Utils_InsertSorted", "vc-description": "", "vc-preamble": "// method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n// //   ensures count == |set i | i in numbers && i < threshold|\n//     ensures count == |SetLessThan(numbers, threshold)|\n// {\n//   count := 0;\n//   var ss := numbers;\n//   while ss != {}\n//     decreases |ss|\n//   {\n//     var i: int :| i in ss;\n//     ss := ss - {i};\n//     if i < threshold {\n//       count := count + 1;\n//     }\n\n//   }\n//   assert count == |SetLessThan(numbers, threshold)|;\n// //   assert count == |set i | i in numbers && i < threshold|;\n// }\n\nfunction SetLessThan(numbers: set<int>, threshold: int): set<int>\n{\n  set i | i in numbers && i < threshold\n}\n\n\nlemma set_memebrship_implies_cardinality_helper<A>(s: set<A>, t: set<A>, s_size: int)\n  requires s_size >= 0 && s_size == |s|\n  requires forall x :: x in s <==> x in t\n  ensures |s| == |t|\n  decreases s_size {\n  if s_size == 0 {\n  } else {\n    var s_hd;\n    // assign s_hd to a value *such that* s_hd is in s (see such_that expressions)\n    s_hd :| s_hd in s;\n    set_memebrship_implies_cardinality_helper(s - {s_hd}, t - {s_hd}, s_size - 1);\n  }\n}\n\n\nlemma set_memebrship_implies_cardinality<A>(s: set<A>, t: set<A>)\n  requires forall x :: x in s <==> x in t\n  ensures |s| == |t| {\n  set_memebrship_implies_cardinality_helper(s, t, |s|);\n}\n\n\n/*\nlemma Bijection(arr: seq<int>, s: set<int>) // returns (bool)\n  requires sorted(arr)\n  // requires forall x, y :: x in s && y in s && x != y ==> x < y\n  ensures  |s| == |arr|\n{\n    var mapping: map<int, int> := map[];\n\n    // Establish the bijection\n    for i := 0 to |arr| {\n        mapping := mapping[arr[i]:= arr[i]];\n    }\n\n    // Prove injectiveness\n    assert forall i, j :: (0 <= i < |arr|-1 && 0 <= j < |arr|-1 && i != j )==> mapping[arr[i]] != mapping[arr[j]];\n\n    // Prove surjectiveness\n    // assert forall x :: x in s ==> exists i :: 0 <= i < |arr|-1 && arr[i] == x;\n\n    // Conclude equinumerosity\n    // assert |s| == |arr|;\n    // return true;\n}\n*/\n\nfunction seqSet(nums: seq<int>, index: nat): set<int> {\n    set x | 0 <= x < index < |nums| :: nums[x]\n}\n\nlemma containsDuplicateI(nums: seq<int>) returns (containsDuplicate: bool)\n    ensures containsDuplicate ==>  exists i,j :: 0 <= i < j < |nums| && nums[i] == nums[j]\n{\n    var windowGhost: set<int> := {};\n    var windowSet: set<int> := {};\n    for i:= 0 to |nums| \n        invariant 0 <= i <= |nums|\n        invariant forall j :: 0 <= j < i < |nums|  ==> nums[j] in windowSet\n        // invariant forall x :: x in windowSet ==> x in nums\n        invariant forall x :: x in windowSet ==> x in nums[0..i]\n        invariant seqSet(nums, i) <= windowSet\n    {\n        windowGhost := windowSet;\n        if nums[i] in windowSet { // does not verify\n        // if nums[i] in seqSet(nums, i) { //verifies\n            return true;\n        }\n        windowSet := windowSet + {nums[i]};\n    }\n    return false;\n}\n\n// lemma numElemsOfSet(a: seq<int>)\n//   requires sorted(a)\n// {\n//   assert distinct(a);\n//   var s := set x | x in a;\n//   assert forall x :: x in s ==> x in a[..];\n//   assert forall x :: x in a ==> x in s;\n//   assert |s| == |a|;\n// }\n\n// lemma CardinalitySetEqualsArray(a: seq<int>, s: set<int>)\n//   requires s == set x | x in a\n//   requires distinct(a)\n//   ensures |s| == |a|\n// {\n//     assert forall x :: x in s ==> exists i :: 0 <= i < |a| && a[i] == x;\n//     assert forall i, j :: 0 <= i < |a| && 0 <= j < |a| && i != j ==> a[i] != a[j];\n//     // Assert that each element in the array is in the set\n//     assert forall i :: 0 <= i < |a| ==> a[i] in s;\n//     // Assert that the set contains exactly the elements in the array\n//     assert s == set x | x in a;\n//     // Assert that the set is a subset of the array\n//     assert forall x :: x in s <==> x in a;\n\n//     // Conclude the equivalence\n//     assert |s| == |a|;\n// }\n\n\n/*\nlemma memebrship_implies_cardinality_helper<A>(s: set<A>, t: seq<A>, s_size: int)\n  requires s_size >= 0 && s_size == |s|\n  requires forall x :: x in s <==> x in t\n  requires forall i, j :: (0 <= i < |t| && 0 <= j < |t| && i != j ) ==> t[i] != t[j]\n  requires |set x | x in t| == |t| \n  ensures |s| == |t|\n  decreases s_size {\n    if s_size == 0 {\n    } else {\n      var t_hd;\n      t_hd := t[0];\n      assert t_hd in s;\n      ghost var t_h := set x | x in t[1..];\n      assert |t_h| == |t[1..]|; \n      memebrship_implies_cardinality_helper(s - {t_hd}, t[1..], s_size - 1);\n    }\n}\n\n\nlemma memebrship_implies_cardinality<A>(s: set<A>, t: seq<A>)\n  requires forall x :: x in s <==> x in t\n  ensures |s| == |t| {\n    memebrship_implies_cardinality_helper(s, t, |s|);\n}\n*/\n\nlemma set_memebrship_implies_equality_helper<A>(s: set<A>, t: set<A>, s_size: int)\n  requires s_size >= 0 && s_size == |s|\n  requires forall x :: x in s <==> x in t\n  ensures s == t\n  decreases s_size {\n  if s_size == 0 {\n  } else {\n    var s_hd;\n    // assign s_hd to a value *such that* s_hd is in s (see such_that expressions)\n    s_hd :| s_hd in s;\n    set_memebrship_implies_equality_helper(s - {s_hd}, t - {s_hd}, s_size - 1);\n  }\n}\n\n\nlemma set_memebrship_implies_equality<A>(s: set<A>, t: set<A>)\n  requires forall x :: x in s <==> x in t\n  ensures s == t {\n  set_memebrship_implies_equality_helper(s, t, |s|);\n}\n\n// TODO play with this for keys==Contents\nlemma set_seq_equality(s: set<int>, t: seq<int>)\n  requires distinct(t)\n  requires forall x :: x in t <==> x in s\n{\n  var s2 : set<int> := set x | x in t;\n  set_memebrship_implies_equality_helper(s, s2, |s|);\n  assert |s2| == |s|;\n  // assert |s2| == |t|;\n  // assert |s| == |t|;\n}\n\n\nghost predicate SortedSeq(a: seq<int>)\n  //sequence is sorted from left to right\n{\n  (forall i,j :: 0<= i< j < |a| ==> ( a[i] < a[j] ))\n}\n\nmethod GetInsertIndex(a: array<int>, limit: int, x:int) returns (idx:int)\n  // get index so that array stays sorted\n  requires x !in a[..]\n  requires 0 <= limit <= a.Length\n  requires SortedSeq(a[..limit])\n  ensures 0<= idx <= limit\n  ensures SortedSeq(a[..limit])\n  ensures idx > 0 ==> a[idx-1]< x\n  ensures idx < limit ==> x < a[idx]\n{\n  idx := limit;\n  for i := 0 to limit\n    invariant i>0 ==> x > a[i-1]\n  {\n    if x < a[i] {\n      idx := i;\n      break;\n    }\n  }\n}\n\npredicate sorted(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] < a[j]\n}\n\npredicate distinct(a: seq<int>)\n{\n  forall i,j :: (0 <= i < |a| && 0 <= j < |a| && i != j) ==> a[i] != a[j]\n}\n\npredicate sorted_eq(a: seq<int>)\n{\n  forall i,j :: 0 <= i < j < |a| ==> a[i] <= a[j]\n}\n\npredicate lessThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] < key\n}\n\npredicate greaterThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] > key\n}\n\npredicate greaterEqualThan(a:seq<int>, key:int) {\n  forall i :: 0 <= i < |a| ==> a[i] >= key\n}\n/*", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method InsertSorted(a: array<int>, key: int ) returns (b: array<int>)\n  requires sorted_eq(a[..])\n  ensures sorted_eq(b[..])", "vc-code": "{\n  b:= new int[a.Length + 1];\n\n  ghost var k := 0;\n  b[0] := key;\n\n  ghost var a' := a[..];\n\n  var i:= 0;\n  while (i < a.Length)\n    modifies b\n    invariant 0 <= k <= i <= a.Length\n    invariant b.Length == a.Length + 1\n    invariant a[..] == a'\n    invariant lessThan(a[..i], key) ==> i == k\n    invariant lessThan(a[..k], key)\n    invariant b[..k] == a[..k]\n    invariant b[k] == key\n    invariant k < i ==> b[k+1..i+1] == a[k..i]\n    invariant k < i ==> greaterEqualThan(b[k+1..i+1], key)\n    invariant 0 <= k < b.Length && b[k] == key\n  {\n    if(a[i]<key)\n    {\n      b[i]:= a[i];\n      b[i+1] := key;\n      k := i+1;\n    }\n    else if (a[i] >= key)\n    {\n      b[i+1] := a[i];\n    }\n    i := i+1;\n  }\n  assert b[..] == a[..k] + [key] + a[k..];\n}", "vc-postamble": "*/\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures count(a + b) == count(a) + count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    DistributiveLemma(a[1..], b);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\n\nlemma DistributiveIn(a: seq<int>, b:seq<int>, k:int, key:int)\n    requires |a| + 1 == |b| \n    requires 0 <= k <= |a|\n    requires b == a[..k] + [key] + a[k..]\n    ensures forall i :: 0 <= i < |a| ==> a[i] in b\n{\n    assert forall j :: 0 <= j < k ==> a[j] in b;\n    assert forall j :: k <= j < |a| ==> a[j] in b;\n    assert ((forall j :: 0 <= j < k ==> a[j] in b) && (forall j :: k <= j < |a| ==> a[j] in b)) ==> (forall j :: 0 <= j < |a| ==> a[j] in b);\n    assert forall j :: 0 <= j < |a| ==> a[j] in b;\n}\n\nlemma DistributiveGreater(a: seq<int>, b:seq<int>, k:int, key:int)\n    requires |a| + 1 == |b| \n    requires 0 <= k <= |a|\n    requires b == a[..k] + [key] + a[k..]\n    requires forall j :: 0 <= j < |a| ==> a[j] > 0\n    requires key > 0\n    ensures forall i :: 0 <= i < |b| ==> b[i] > 0\n{\n    // assert ((forall j :: 0 <= j < k ==> b[j] > 0) && (forall j :: k <= j < |a| ==> b[j] > 0)) ==> (forall j :: 0 <= j < |b| ==> b[j] > 0);\n    assert forall j :: 0 <= j < |b| ==> b[j] > 0;\n}\n\n// verifies in more than 45 seconds, but less than 100 seconds\nmethod InsertIntoSorted(a: array<int>, limit:int, key:int) returns (b: array<int>)\n    requires key > 0\n    requires key !in a[..]\n    requires 0 <= limit < a.Length\n    requires forall i :: 0 <= i < limit ==> a[i] > 0\n    requires forall i :: limit <= i < a.Length ==> a[i] == 0\n    requires sorted(a[..limit]) \n    ensures b.Length == a.Length\n    ensures sorted(b[..(limit+ 1)])\n    ensures forall i :: limit + 1 <= i < b.Length ==> b[i] == 0  \n    ensures forall i :: 0 <= i < limit ==> a[i] in b[..]\n    ensures forall i :: 0 <= i < limit + 1 ==> b[i] > 0\n{\n    b:= new int[a.Length];\n\n    ghost var k := 0;\n    b[0] := key;\n\n    ghost var a' := a[..];\n\n    var i:= 0;\n    while (i < limit)\n        modifies b\n        invariant 0 <= k <= i <= limit\n        invariant b.Length == a.Length\n        invariant a[..] == a'\n        invariant lessThan(a[..i], key) ==> i == k\n        invariant lessThan(a[..k], key)\n        invariant b[..k] == a[..k]\n        invariant b[k] == key\n        invariant k < i ==> b[k+1..i+1] == a[k..i]\n        invariant k < i ==> greaterThan(b[k+1..i+1], key)\n        invariant 0 <= k < b.Length && b[k] == key\n    {\n        if(a[i]<key)\n        {\n            b[i]:= a[i];\n            b[i+1] := key;\n            k := i+1;\n        }\n        else if (a[i] >= key)\n        {\n            b[i+1] := a[i];\n        } \n        i := i+1;\n    }\n    assert b[..limit+1] == a[..k] + [key] + a[k..limit];\n    assert sorted(b[..limit+1]);\n\n    // assert b[..limit+1] == a[..k] + [key] + a[k..limit];\n    DistributiveIn(a[..limit], b[..limit+1], k, key);\n    assert forall i :: 0 <= i < limit ==> a[i] in b[..limit+1];\n\n    DistributiveGreater(a[..limit], b[..limit+1], k, key);\n    // assert forall i :: 0 <= i < limit + 1 ==> b[i] > 0;\n\n    ghost var b' := b[..];\n    i := limit + 1;\n    while i < b.Length \n        invariant limit + 1 <= i <= b.Length \n        invariant forall j :: limit + 1 <= j < i ==> b[j] == 0\n        invariant b[..limit+1] == b'[..limit+1]\n        invariant sorted(b[..limit+1])\n    {\n        b[i] := 0;\n        i := i + 1;\n    }\n    assert forall i :: limit + 1 <= i < b.Length ==> b[i] == 0;\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0016", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_checkAvailability", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n\n\n  // The method maintains the invariant that the number of available spaces availableSpaces is updated correctly\n  // based on the current state of the car park and whether it is a weekend or not", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method checkAvailability() returns (availableSpaces: int) \n    requires true\n    modifies this\n    ensures weekend ==> availableSpaces == (normalSpaces - old(|carPark|)) + (reservedSpaces - old(|reservedCarPark|)) - badParkingBuffer;\n    ensures !weekend ==> availableSpaces == (normalSpaces - old(|carPark|)) - badParkingBuffer;\n    ensures carPark == old(carPark) && reservedCarPark == old(reservedCarPark) && weekend == old(weekend) && subscriptions == old(subscriptions);", "vc-code": "{\n    if (weekend){\n      availableSpaces := (normalSpaces - |carPark|) + (reservedSpaces - |reservedCarPark|) - badParkingBuffer;\n    } else{\n      availableSpaces := (normalSpaces - |carPark|) - badParkingBuffer;\n    }\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0017", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_closeCarPark", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n\n\n\n\n\n\n\n  // The method maintains the invariant that the weekend variable is set to true\n\n  // The method maintains the invariant that the carPark, reservedCarPark, and subscriptions sets are all cleared", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method closeCarPark()\n    requires true\n    modifies this\n    ensures carPark == {} && reservedCarPark == {} && subscriptions == {}\n    ensures weekend == old(weekend);", "vc-code": "{\n    carPark := {};\n    reservedCarPark := {};\n    subscriptions := {};\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0018", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_enterCarPark", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method enterCarPark(car: string) returns (success: bool) \n    requires true\n    modifies this;\n\n    ensures success ==> (car !in old(carPark)) && (car !in old(reservedCarPark)) && (old(|carPark|) < normalSpaces - badParkingBuffer);\n    ensures success ==> carPark == old(carPark) + {car};\n    ensures !success ==> carPark == old(carPark) && reservedCarPark == old(reservedCarPark);\n    ensures !success ==> (car in old(carPark)) || (car in old(reservedCarPark) || (old(|carPark|) >= normalSpaces - badParkingBuffer));\n    ensures subscriptions == old(subscriptions) && reservedCarPark == old(reservedCarPark) && weekend == old(weekend);", "vc-code": "{\n    if (|carPark| >= normalSpaces - badParkingBuffer || car in carPark || car in reservedCarPark) {\n      return false;\n    }\n    else\n    {\n      carPark := carPark + {car};\n      return true;\n    }\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0019", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_enterReservedCarPark", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n\n\n  // The method maintains the invariant that if success is true, then the car parameter is added to the\n  // reservedCarPark set and the number of cars in the reservedCarPark set is less than the number of\n  // reserved spaces and either the weekend variable is true or the car parameter is in the subscriptions set.\n  // Otherwise, the carPark and reservedCarPark sets are not modified", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method enterReservedCarPark(car: string) returns (success: bool) \n    requires true\n    modifies this;\n\n    ensures success ==> (car !in old(carPark)) && (car !in old(reservedCarPark)) && (old(|reservedCarPark|) < reservedSpaces) && (car in subscriptions || weekend == true);\n    ensures success ==> reservedCarPark == old(reservedCarPark) + {car};\n    ensures !success ==> carPark == old(carPark) && reservedCarPark == old(reservedCarPark);\n    ensures !success ==> (car in old(carPark)) || (car in old(reservedCarPark) || (old(|reservedCarPark|) >= reservedSpaces) || (car !in subscriptions && weekend == false));\n    ensures subscriptions == old(subscriptions) && carPark == old(carPark) && weekend == old(weekend);\n    ensures weekend == old(weekend) && subscriptions == old(subscriptions);", "vc-code": "{\n    if (|reservedCarPark| >= reservedSpaces || car in carPark || car in reservedCarPark || (car !in subscriptions && weekend == false)) {\n      return false;\n    }\n    else\n    {\n      reservedCarPark := reservedCarPark + {car};\n      return true;\n    }\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0020", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_leaveCarPark", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n  // The method maintains the invariant that if success is true, then the car parameter is removed from either\n  // the carPark or the reservedCarPark set. Otherwise, neither set is modified", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method leaveCarPark(car: string) returns (success: bool)\n    requires true\n    modifies this\n    ensures success ==> (((car in old(carPark)) && carPark == old(carPark) - {car} && reservedCarPark == old(reservedCarPark)) || ((car in old(reservedCarPark)) && reservedCarPark == old(reservedCarPark) - {car} && carPark == old(carPark)));\n    ensures success ==> (car !in carPark) && (car !in reservedCarPark);\n    ensures !success ==> carPark == old(carPark) && reservedCarPark == old(reservedCarPark) && (car !in old(carPark)) && (car !in old(reservedCarPark));\n    ensures subscriptions == old(subscriptions) && weekend == old(weekend);", "vc-code": "{\n    success := false;\n\n    if car in carPark {\n      carPark := carPark - {car};\n      success := true;\n    } else if car in reservedCarPark {\n      reservedCarPark := reservedCarPark - {car};\n      success := true;\n    }\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0021", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_makeSubscription", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n  // The method maintains the invariant that if success is true, then the car parameter is added to the\n  // subscriptions set. Otherwise, the subscriptions set is not modified", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method makeSubscription(car: string) returns (success: bool)\n    requires true\n    modifies this\n    ensures success ==> old(|subscriptions|) < reservedSpaces && car !in old(subscriptions) && subscriptions == old(subscriptions) + {car};\n    ensures !success ==> subscriptions == old(subscriptions) && (car in old(subscriptions) || old(|subscriptions|) >= reservedSpaces);\n    ensures carPark == old(carPark) && reservedCarPark == old(reservedCarPark) && weekend == old(weekend);", "vc-code": "{\n    if |subscriptions| >= reservedSpaces || car in subscriptions {\n      success := false;\n    } else {\n      subscriptions := subscriptions + {car};\n      success := true;\n    }\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0022", "language": "dafny", "source": "dafnybench", "source_id": "CO3408-Advanced-Software-Modelling-Assignment-2022-23-Part-2-A-Specification-Spectacular_tmp_tmp4pj4p2zx_car_park_openReservedArea", "vc-description": "", "vc-preamble": "class {:autocontracts} CarPark {\n    const totalSpaces: nat := 10;\n    const normalSpaces: nat:= 7;\n    const reservedSpaces: nat := 3;\n    const badParkingBuffer: int := 5;\n\n    var weekend: bool;\n    var subscriptions: set<string>;\n    var carPark: set<string>;\n    var reservedCarPark: set<string>;\n\n    constructor()\n    requires true\n    ensures this.subscriptions == {} && this.carPark == {} && this.reservedCarPark == {} && this.weekend == false;\n    {\n\n    this.subscriptions := {};\n    this.carPark := {};\n    this.reservedCarPark := {};\n    this.weekend := false;\n    }\n\n    // This predicate checks if the car park is in a valid state at all times.\n    // It checks if the sets of cars in the car park and the reserved car park are disjoint and share no values,\n    // the total number of cars in the car park is less than or equal to the total number of spaces in\n    // the car park plus the bad parking buffer, the number of normal spaces plus reserved spaces is\n    // equal to the total number of spaces, and the number of cars in the reserved car park is less than or equal\n    // to the number of reserved spaces\n    ghost predicate Valid()\n    reads this\n    {\n                          carPark * reservedCarPark == {} && |carPark| <= totalSpaces + badParkingBuffer && (normalSpaces + reservedSpaces) == totalSpaces && |reservedCarPark| <= reservedSpaces\n    }\n\n\n\n  // The method maintains the invariant that the weekend variable is set to true", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method openReservedArea()\n    requires true\n    modifies this\n    ensures carPark == old(carPark) && reservedCarPark == old(reservedCarPark) && weekend == true && subscriptions == old(subscriptions);", "vc-code": "{\n    weekend := true;\n}", "vc-postamble": "}\n\n\n\n// Added due to timeout in Main", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0024", "language": "dafny", "source": "dafnybench", "source_id": "CS5232_Project_tmp_tmpai_cfrng_LFUSimple_get", "vc-description": "", "vc-preamble": "class LFUCache {\n\n    var capacity : int;\n    var cacheMap : map<int, (int, int)>; //key -> {value, freq}\n\n    constructor(capacity: int)\n      requires capacity > 0;\n      ensures Valid();\n    {\n      this.capacity := capacity;\n      this.cacheMap := map[];\n    }\n\n    predicate Valid()\n      reads this;\n      // reads this.freqMap.Values;\n    {\n      // general value check\n      this.capacity > 0 &&\n      0 <= |cacheMap| <= capacity &&\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].1 >= 1)) && // frequency should always larger than 0\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].0 >= 0)) // only allow positive values\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method get(key: int) returns (value: int)\n      requires Valid();\n      modifies this;\n      ensures Valid();\n      ensures key !in cacheMap ==> value == -1;\n      ensures forall e :: e in old(cacheMap) <==> e in cacheMap;\n      ensures forall e :: e in old(cacheMap) ==> (old(cacheMap[e].0) == cacheMap[e].0);\n      ensures key in cacheMap ==> value == cacheMap[key].0 && old(cacheMap[key].1) == cacheMap[key].1-1;", "vc-code": "{\n      assert key in cacheMap ==> cacheMap[key].0 >= 0;\n      if(key !in cacheMap) {\n        value := -1;\n      }\n      else{\n        assert key in cacheMap;\n        assert cacheMap[key].0 >= 0;\n        value := cacheMap[key].0;\n        var oldFreq := cacheMap[key].1;\n        var newV := (value, oldFreq + 1);\n        cacheMap := cacheMap[key := newV];\n      }\n      print \"after get: \";\n      print cacheMap;\n      print \"\\n\";\n      return value;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0025", "language": "dafny", "source": "dafnybench", "source_id": "CS5232_Project_tmp_tmpai_cfrng_LFUSimple_getLFUKey", "vc-description": "", "vc-preamble": "class LFUCache {\n\n    var capacity : int;\n    var cacheMap : map<int, (int, int)>; //key -> {value, freq}\n\n    constructor(capacity: int)\n      requires capacity > 0;\n      ensures Valid();\n    {\n      this.capacity := capacity;\n      this.cacheMap := map[];\n    }\n\n    predicate Valid()\n      reads this;\n      // reads this.freqMap.Values;\n    {\n      // general value check\n      this.capacity > 0 &&\n      0 <= |cacheMap| <= capacity &&\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].1 >= 1)) && // frequency should always larger than 0\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].0 >= 0)) // only allow positive values\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method getLFUKey() returns (lfuKey : int) \n      requires Valid();\n      requires |cacheMap| > 0;\n      ensures Valid();\n      ensures lfuKey in cacheMap;\n      ensures forall k :: k in cacheMap.Items ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;", "vc-code": "{\n      var items := cacheMap.Items;\n      var seenItems := {};\n\n      var anyItem :| anyItem in items;\n      var minFreq := anyItem.1.1;\n      lfuKey := anyItem.0;\n\n      while items != {}\n        decreases |items|;\n        invariant cacheMap.Items >= items;\n        invariant cacheMap.Items >= seenItems;\n        invariant cacheMap.Items == seenItems + items;\n        invariant lfuKey in cacheMap;\n        invariant cacheMap[lfuKey].1 == minFreq;\n        invariant forall e :: e in seenItems ==> minFreq <= e.1.1;\n        invariant forall e :: e in seenItems ==> minFreq <= cacheMap[e.0].1;\n        invariant forall e :: e in seenItems ==> cacheMap[lfuKey].1 <= cacheMap[e.0].1;\n        invariant exists e :: e in seenItems + items ==> minFreq == e.1.1;\n      {\n        var item :| item in items;\n\n        if (item.1.1 < minFreq) {\n          lfuKey := item.0;\n          minFreq := item.1.1;\n        }\n        items := items - { item };\n        seenItems := seenItems + { item };\n      }\n      assert seenItems == cacheMap.Items;\n      assert cacheMap[lfuKey].1 == minFreq;\n      assert forall e :: e in seenItems ==> minFreq <= e.1.1;\n      assert forall e :: e in cacheMap.Items ==> minFreq <= e.1.1;\n      assert forall k :: k in seenItems ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;\n      assert forall k :: k in cacheMap.Items ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;\n      // assert forall k :: k in cacheMap ==> cacheMap[lfuKey].1 <= cacheMap[k].1; // ????\n      return lfuKey;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0026", "language": "dafny", "source": "dafnybench", "source_id": "CS5232_Project_tmp_tmpai_cfrng_LFUSimple_put", "vc-description": "", "vc-preamble": "class LFUCache {\n\n    var capacity : int;\n    var cacheMap : map<int, (int, int)>; //key -> {value, freq}\n\n    constructor(capacity: int)\n      requires capacity > 0;\n      ensures Valid();\n    {\n      this.capacity := capacity;\n      this.cacheMap := map[];\n    }\n\n    predicate Valid()\n      reads this;\n      // reads this.freqMap.Values;\n    {\n      // general value check\n      this.capacity > 0 &&\n      0 <= |cacheMap| <= capacity &&\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].1 >= 1)) && // frequency should always larger than 0\n      (|cacheMap| > 0 ==> (forall e :: e in cacheMap ==> cacheMap[e].0 >= 0)) // only allow positive values\n    } \n\n    method getLFUKey() returns (lfuKey : int) \n      requires Valid();\n      requires |cacheMap| > 0;\n      ensures Valid();\n      ensures lfuKey in cacheMap;\n      ensures forall k :: k in cacheMap.Items ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;\n    {\n\n\n      var items := cacheMap.Items;\n      var seenItems := {};\n\n      var anyItem :| anyItem in items;\n      var minFreq := anyItem.1.1;\n      lfuKey := anyItem.0;\n\n      while items != {}\n        decreases |items|;\n        invariant cacheMap.Items >= items;\n        invariant cacheMap.Items >= seenItems;\n        invariant cacheMap.Items == seenItems + items;\n        invariant lfuKey in cacheMap;\n        invariant cacheMap[lfuKey].1 == minFreq;\n        invariant forall e :: e in seenItems ==> minFreq <= e.1.1;\n        invariant forall e :: e in seenItems ==> minFreq <= cacheMap[e.0].1;\n        invariant forall e :: e in seenItems ==> cacheMap[lfuKey].1 <= cacheMap[e.0].1;\n        invariant exists e :: e in seenItems + items ==> minFreq == e.1.1;\n      {\n        var item :| item in items;\n\n        if (item.1.1 < minFreq) {\n          lfuKey := item.0;\n          minFreq := item.1.1;\n        }\n        items := items - { item };\n        seenItems := seenItems + { item };\n      }\n      assert seenItems == cacheMap.Items;\n      assert cacheMap[lfuKey].1 == minFreq;\n      assert forall e :: e in seenItems ==> minFreq <= e.1.1;\n      assert forall e :: e in cacheMap.Items ==> minFreq <= e.1.1;\n      assert forall k :: k in seenItems ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;\n      assert forall k :: k in cacheMap.Items ==> cacheMap[lfuKey].1 <= cacheMap[k.0].1;\n      // assert forall k :: k in cacheMap ==> cacheMap[lfuKey].1 <= cacheMap[k].1; // ????\n      return lfuKey;\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method put(key: int, value: int)\n        requires Valid();\n        requires value > 0;\n        modifies this\n        ensures Valid();", "vc-code": "{\n        if (key in cacheMap) {\n          var currFreq := cacheMap[key].1;\n          cacheMap := cacheMap[key := (value, currFreq)];\n        } else {\n          if (|cacheMap| < capacity) {\n            cacheMap := cacheMap[key := (value, 1)];\n          } else {\n            var LFUKey := getLFUKey();\n            assert LFUKey in cacheMap;\n            assert |cacheMap| == capacity;\n            ghost var oldMap := cacheMap;\n            var newMap := cacheMap - {LFUKey};\n            cacheMap := newMap;\n            assert newMap == cacheMap - {LFUKey};\n            assert LFUKey !in cacheMap;\n            assert LFUKey in oldMap;\n            ghost var oldCard := |oldMap|;\n            ghost var newCard := |newMap|;\n            assert |cacheMap.Keys| < |oldMap|; // ????\n            cacheMap := cacheMap[key := (value, 1)];\n          }\n        }\n        print \"after put: \";\n        print cacheMap;\n        print \"\\n\";\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0027", "language": "dafny", "source": "dafnybench", "source_id": "CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_haveCommonKSubstring", "vc-description": "", "vc-preamble": "//This method should return true iff pre is a prefix of str. That is, str starts with pre\nmethod isPrefix(pre:string, str:string) returns(res:bool)\n    requires 0 < |pre| <= |str| //This line states that this method requires that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: \"str[i] != pre[i]\"\n{\n    //Initialising the index variable\n    var i := 0;\n\n    //Iterating through the first |pre| elements in str\n    while (i < |pre|)\n        invariant 0 <= i <= |pre|                               //Specifying the range of the while loop\n        decreases |pre| - i                                     //Specifying that the while loop will terminate\n    {\n        //If an element does not match, return false\n        if (str[i] != pre[i]) {\n            //Debug print\n            print str[i], \" != \", pre[i], \"\\n\";\n\n            //Return once mismatch detected, no point in iterating any further\n            return false;\n        }\n        //Else loop until mismatch found or we have reached the end of pre\n        else{\n            //Debug pront\n            print str[i], \" == \", pre[i], \"\\n\";\n\n            i := i + 1;\n        }\n    }\n    return true;\n}\n\n//This method should return true iff sub is a substring of str. That is, str contains sub\nmethod isSubstring(sub:string, str:string) returns(res:bool)\n    requires 0 < |sub| <= |str| //This method requires that sub is less than or equal in length to str\n{\n    //Initialising the index variable\n    var i := 0;\n\n    //This variable stores the difference in length between the two strings\n    var n := (|str| - |sub|);\n\n    //Here, we want to re-use the \"isPrefix\" method above, so with each iteration of the search, we are passing an offset of str - effectively trimming a character off the front of str and passing it to isPrefix\n        //example 1 (sub found in str): \n        //str = door & sub = or\n        //iteration 1: isPrefix(or, door), returns false, trim & iterate again\n        //iteration 2: isprefix(or, oor), returns false, trim & iterate again\n        //iteration 3: isPrefix(or, or), returns true, stop iterating\n\n        //example 2 (sub not found in str):\n        //str = doom & sub = or\n        //iteration 1: isPrefix(or, doom), returns false, trim & iterate again\n        //iteration 2: isprefix(or, oom), returns false, trim & iterate again\n        //iteration 3: isPrefix(or, om), returns false, str is has not been \"trimmed\" to the same length as sub, so we stop iterating\n\n    while(i < n+1)\n        invariant 0 <= i <= n+1     //Specifying the range of the while loop\n        decreases n - i             //Specifying that the while loop will terminate\n    {\n        //Debug print to show what is being passed to isPrefix with each iteration\n        print \"\\n\", sub, \", \", str[i..|str|], \"\\n\";\n\n        var result:= isPrefix(sub, str[i..|str|]);\n\n        //Return once the substring is found, no point in iterating any further\n        if(result == true){\n            return true;\n        }\n        //Else loop until sub is found, or we have reached the end of str\n        else{\n            i := i+1;\n        }\n    }\n    return false;\n}\n\n//This method should return true iff str1 and str1 have a common substring of length k", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method haveCommonKSubstring(k:nat, str1:string, str2:string) returns(found:bool)\n    requires 0 < k <= |str1| &&  0 < k <= |str2| //This method requires that k > 0 and k is less than or equal to in length to str1 and str2", "vc-code": "{\n    //Initialising the index variable\n    var i := 0;\n\n    //This variable is used to define the end condition of the while loop\n    var n := |str1|-k;\n\n    //Here, we want to re-use the \"isSubstring\" method above, so with each iteration of the search, we are passing a substring of str1 with length k and searching for this substring in str2. If the k-length substring is not found, we \"slide\" the length-k substring \"window\" along and search again\n        //example:\n        //str1 = operation, str2 = rational, k = 5\n        //Iteration 1: isSubstring(opera, rational), returns false, slide the substring & iterate again\n        //Iteration 2: isSubstring(perat, rational), returns false, slide the substring & iterate again\n        //Iteration 3: isSubstring(erati, rational), returns false, slide the substring & iterate again\n        //Iteration 4: isSubstring(ratio, rational), returns true, stop iterating\n\n    while(i < n)\n        decreases n - i //Specifying that the loop will terminate\n    {\n        //Debug print to show what is being passed to isSubstring with each iteration\n        print \"\\n\", str1[i..i+k], \", \", str2, \"\\n\";\n\n        var result := isSubstring(str1[i..i+k], str2);\n\n        //Return once the length-k substring is found, no point in iterating any further\n        if(result == true){\n            return true;\n        }\n        //Else loop until the length-k substring is found, or we have reached the end condition\n        else{\n            i:=i+1;\n        }\n    }\n    return false;\n}", "vc-postamble": "//This method should return the natural number len which is equal to the length of the longest common substring of str1 and str2. Note that every two strings have a common substring of length zero.\n\n//Main to test each method", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0028", "language": "dafny", "source": "dafnybench", "source_id": "CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_isPrefix", "vc-description": "", "vc-preamble": "//This method should return true iff pre is a prefix of str. That is, str starts with pre", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isPrefix(pre:string, str:string) returns(res:bool)\n    requires 0 < |pre| <= |str| //This line states that this method requires that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: \"str[i] != pre[i]\"", "vc-code": "{\n    //Initialising the index variable\n    var i := 0;\n\n    //Iterating through the first |pre| elements in str\n    while (i < |pre|)\n        invariant 0 <= i <= |pre|                               //Specifying the range of the while loop\n        decreases |pre| - i                                     //Specifying that the while loop will terminate\n    {\n        //If an element does not match, return false\n        if (str[i] != pre[i]) {\n            //Debug print\n            print str[i], \" != \", pre[i], \"\\n\";\n\n            //Return once mismatch detected, no point in iterating any further\n            return false;\n        }\n        //Else loop until mismatch found or we have reached the end of pre\n        else{\n            //Debug pront\n            print str[i], \" == \", pre[i], \"\\n\";\n\n            i := i + 1;\n        }\n    }\n    return true;\n}", "vc-postamble": "//This method should return true iff sub is a substring of str. That is, str contains sub\n\n//This method should return true iff str1 and str1 have a common substring of length k\n\n//This method should return the natural number len which is equal to the length of the longest common substring of str1 and str2. Note that every two strings have a common substring of length zero.\n\n//Main to test each method", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0029", "language": "dafny", "source": "dafnybench", "source_id": "CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_isSubstring", "vc-description": "", "vc-preamble": "//This method should return true iff pre is a prefix of str. That is, str starts with pre\nmethod isPrefix(pre:string, str:string) returns(res:bool)\n    requires 0 < |pre| <= |str| //This line states that this method requires that pre is less than or equal in length to str. Without this line, an out of bounds error is shown on line 14: \"str[i] != pre[i]\"\n{\n    //Initialising the index variable\n    var i := 0;\n\n    //Iterating through the first |pre| elements in str\n    while (i < |pre|)\n        invariant 0 <= i <= |pre|                               //Specifying the range of the while loop\n        decreases |pre| - i                                     //Specifying that the while loop will terminate\n    {\n        //If an element does not match, return false\n        if (str[i] != pre[i]) {\n            //Debug print\n            print str[i], \" != \", pre[i], \"\\n\";\n\n            //Return once mismatch detected, no point in iterating any further\n            return false;\n        }\n        //Else loop until mismatch found or we have reached the end of pre\n        else{\n            //Debug pront\n            print str[i], \" == \", pre[i], \"\\n\";\n\n            i := i + 1;\n        }\n    }\n    return true;\n}\n\n//This method should return true iff sub is a substring of str. That is, str contains sub", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isSubstring(sub:string, str:string) returns(res:bool)\n    requires 0 < |sub| <= |str| //This method requires that sub is less than or equal in length to str", "vc-code": "{\n    //Initialising the index variable\n    var i := 0;\n\n    //This variable stores the difference in length between the two strings\n    var n := (|str| - |sub|);\n\n    //Here, we want to re-use the \"isPrefix\" method above, so with each iteration of the search, we are passing an offset of str - effectively trimming a character off the front of str and passing it to isPrefix\n        //example 1 (sub found in str): \n        //str = door & sub = or\n        //iteration 1: isPrefix(or, door), returns false, trim & iterate again\n        //iteration 2: isprefix(or, oor), returns false, trim & iterate again\n        //iteration 3: isPrefix(or, or), returns true, stop iterating\n\n        //example 2 (sub not found in str):\n        //str = doom & sub = or\n        //iteration 1: isPrefix(or, doom), returns false, trim & iterate again\n        //iteration 2: isprefix(or, oom), returns false, trim & iterate again\n        //iteration 3: isPrefix(or, om), returns false, str is has not been \"trimmed\" to the same length as sub, so we stop iterating\n\n    while(i < n+1)\n        invariant 0 <= i <= n+1     //Specifying the range of the while loop\n        decreases n - i             //Specifying that the while loop will terminate\n    {\n        //Debug print to show what is being passed to isPrefix with each iteration\n        print \"\\n\", sub, \", \", str[i..|str|], \"\\n\";\n\n        var result:= isPrefix(sub, str[i..|str|]);\n\n        //Return once the substring is found, no point in iterating any further\n        if(result == true){\n            return true;\n        }\n        //Else loop until sub is found, or we have reached the end of str\n        else{\n            i := i+1;\n        }\n    }\n    return false;\n}", "vc-postamble": "//This method should return true iff str1 and str1 have a common substring of length k\n\n//This method should return the natural number len which is equal to the length of the longest common substring of str1 and str2. Note that every two strings have a common substring of length zero.\n\n//Main to test each method", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0030", "language": "dafny", "source": "dafnybench", "source_id": "CSU55004---Formal-Verification_tmp_tmp4ki9iaqy_Project_Project_Part_1_project_pt_1_maxCommonSubstringLength", "vc-description": "", "vc-preamble": "predicate isSubstring(sub: seq<char>, str: seq<char>)\n{\n    exists i :: 0 <= i <= |str| - |sub| && str[i..i+|sub|] == sub\n}\n\n//This method should return true iff pre is a prefix of str. That is, str starts with pre\n\n//This method should return true iff sub is a substring of str. That is, str contains sub\n\n//This method should return true iff str1 and str1 have a common substring of length k\nmethod haveCommonKSubstring(k:nat, str1:string, str2:string) returns(found:bool)\n    requires 0 < k <= |str1| &&  0 < k <= |str2| //This method requires that k > 0 and k is less than or equal to in length to str1 and str2\n{\n    //Initialising the index variable\n    var i := 0;\n\n    //This variable is used to define the end condition of the while loop\n    var n := |str1|-k;\n\n    //Here, we want to re-use the \"isSubstring\" method above, so with each iteration of the search, we are passing a substring of str1 with length k and searching for this substring in str2. If the k-length substring is not found, we \"slide\" the length-k substring \"window\" along and search again\n        //example:\n        //str1 = operation, str2 = rational, k = 5\n        //Iteration 1: isSubstring(opera, rational), returns false, slide the substring & iterate again\n        //Iteration 2: isSubstring(perat, rational), returns false, slide the substring & iterate again\n        //Iteration 3: isSubstring(erati, rational), returns false, slide the substring & iterate again\n        //Iteration 4: isSubstring(ratio, rational), returns true, stop iterating\n\n    while(i < n)\n        decreases n - i //Specifying that the loop will terminate\n    {\n        //Debug print to show what is being passed to isSubstring with each iteration\n        print \"\\n\", str1[i..i+k], \", \", str2, \"\\n\";\n\n        var result := isSubstring(str1[i..i+k], str2);\n\n        //Return once the length-k substring is found, no point in iterating any further\n        if(result == true){\n            return true;\n        }\n        //Else loop until the length-k substring is found, or we have reached the end condition\n        else{\n            i:=i+1;\n        }\n    }\n    return false;\n}\n\n//This method should return the natural number len which is equal to the length of the longest common substring of str1 and str2. Note that every two strings have a common substring of length zero.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method maxCommonSubstringLength(str1:string, str2:string) returns(len:nat)\n    requires 0 < |str1| && 0 < |str1|", "vc-code": "{\n    //This variable is used to store the result of calling haveCommonKSubstring\n    var result:bool;\n\n    //We want the longest common substring between str1 and str2, so the starting point is going to be the shorter of the two strings.\n    var i:= |str1|;\n    if(|str2| < |str1|){\n        i := |str2|;\n    }\n\n    //Here, we want to re-use the \"haveKCommonSubstring\" method above, so with each iteration of the search, we pass a decreasing value of k until a common substring of this length is found. If no common substring is found, we return 0.\n    while (i > 0)\n        decreases i - 0\n    {\n        print str1, \", \", str2, \" k = \", i, \"\\n\";\n\n        result := haveCommonKSubstring(i, str1, str2);\n\n        if(result == true){\n            return i;\n        }\n        else{\n            i := i - 1;\n        }\n    }\n    return 0;\n}", "vc-postamble": "//Main to test each method", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0031", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_Fib", "vc-description": "", "vc-preamble": "function fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)", "vc-code": "{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}", "vc-postamble": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0032", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)", "vc-code": "{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}", "vc-postamble": "function fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\n\n\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0033", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_MaxA", "vc-description": "", "vc-preamble": "function fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\n\n\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m", "vc-code": "{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\n        invariant 1 <= i <= a.Length\n        invariant forall j :: 0 <= j < i ==> a[j] <=m\n        invariant exists j :: 0 <= j < i && a[j] ==m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0034", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_addImp", "vc-description": "", "vc-preamble": "function fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\n\n\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)", "vc-code": "{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0035", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare_m1", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x", "vc-code": "{\n    //assume 0 < x < y\n    z := 0;\n}", "vc-postamble": "function fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\n\n\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0038", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_containsSubString", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method containsSubString(a: array<char>, b: array<char>) returns (pos: int)\n    requires 0 <= b.Length <= a.Length", "vc-code": "{\n    pos := -1;\n\n    if b.Length == 0 {\n        return pos;\n    }\n\n    var p := 0;\n\n    while p < a.Length\n    invariant 0 <= p <= a.Length\n    {\n        if a.Length - p < b.Length\n        {\n            return pos;\n        }\n\n        if a[p] == b[0] {\n\n                var i := 0;\n                    while i < b.Length\n                    {\n                        if a[i + p] != b[i] {\n                            return -1;\n                        }\n                    i:= i + 1;\n                    }\n                    pos := p;\n                return pos;\n        }\n\n        p:= p +1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0039", "language": "dafny", "source": "dafnybench", "source_id": "CVS-Projto1_tmp_tmpb1o0bu8z_searchSort_fillK", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method fillK(a: array<int>, n: int, k: int, c: int) returns (b: bool)\n    requires 0 <= c <= n\n    requires n == a.Length", "vc-code": "{\n    if c == 0 {\n        return true;\n    }\n\n    var p := 0;\n    while p < c\n        invariant 0 <= p <= c\n\n        {\n            if a[p] != k\n            {\n                return false;\n            }\n\n            p := p + 1;\n        }\n    return true;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0097", "language": "dafny", "source": "dafnybench", "source_id": "Correctness_tmp_tmpwqvg5q_4_HoareLogic_exam_GCD1", "vc-description": "", "vc-preamble": "// Redo for exam\n\nfunction gcd(a: nat, b: nat): nat\n\nlemma r1(a: nat)\n    ensures gcd(a, 0) == a\n\nlemma r2(a:nat)\n    ensures gcd(a, a) == a\n\nlemma r3(a: nat, b: nat)\n    ensures gcd(a, b) == gcd(b, a)\n\nlemma r4 (a: nat, b: nat)\n    ensures b > 0 ==> gcd(a, b) == gcd(b, a % b)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method GCD1(a: int, b: int) returns (r: int)\n    requires a > 0 && b > 0\n    ensures gcd(a,b) == r\n    decreases b", "vc-code": "{\n    if a < b {\n        r3(a,b);\n        r := GCD1(b, a);\n    } else if (a % b == 0) {\n        r4(a,b);\n        assert b > 0;\n        assert gcd(a, b) == gcd(b, a % b);\n        assert a % b == 0;\n        assert gcd(a, b) == gcd(b, 0);\n        r1(b);\n        assert gcd(a, b) == b;\n        r := b;\n        assert gcd(a,b) == r;\n    } else {\n        r4(a,b);\n        r := GCD1(b, a % b);\n        assert gcd(a,b) == r;\n    }\n    assert gcd(a,b) == r;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0098", "language": "dafny", "source": "dafnybench", "source_id": "Correctness_tmp_tmpwqvg5q_4_HoareLogic_exam_GCD2", "vc-description": "", "vc-preamble": "// Redo for exam\n\nfunction gcd(a: nat, b: nat): nat\n\nlemma r1(a: nat)\n    ensures gcd(a, 0) == a\n\nlemma r2(a:nat)\n    ensures gcd(a, a) == a\n\nlemma r3(a: nat, b: nat)\n    ensures gcd(a, b) == gcd(b, a)\n\nlemma r4 (a: nat, b: nat)\n    ensures b > 0 ==> gcd(a, b) == gcd(b, a % b)\n\nmethod GCD1(a: int, b: int) returns (r: int)\n    requires a > 0 && b > 0\n    ensures gcd(a,b) == r\n    decreases b\n{\n    if a < b {\n        r3(a,b);\n        r := GCD1(b, a);\n    } else if (a % b == 0) {\n        r4(a,b);\n        assert b > 0;\n        assert gcd(a, b) == gcd(b, a % b);\n        assert a % b == 0;\n        assert gcd(a, b) == gcd(b, 0);\n        r1(b);\n        assert gcd(a, b) == b;\n        r := b;\n        assert gcd(a,b) == r;\n    } else {\n        r4(a,b);\n        r := GCD1(b, a % b);\n        assert gcd(a,b) == r;\n    }\n    assert gcd(a,b) == r;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method GCD2(a: int, b: int) returns (r: int)\n    requires a > 0 && b >= 0\n    decreases b\n    ensures gcd(a,b) == r", "vc-code": "{\n    r1(a);\n    r4(a,b);\n    assert\n        ( b != 0 || (a > 0 && b >= 0 && gcd(a,b) == a) )\n        &&\n        ( (b < 0 || b == 0) || (b > 0 && (a % b) >= 0 ==> gcd(a,b) == gcd(b,(a % b))) );\n    assert\n        b != 0 || (a > 0 && b >= 0 && gcd(a,b) == a);\n    assert\n        b == 0 ==> a > 0 && b >= 0 && gcd(a,b) == a;\n    assert\n        (b < 0 || b == 0) || (b > 0 && (a % b) >= 0 ==> gcd(a,b) == gcd(b,(a % b)));\n    assert\n        b >= 0 && b != 0 ==> b > 0 && (a % b) >= 0 ==> gcd(a,b) == gcd(b,(a % b));\n    if b == 0 {\n        r1(a);\n        assert\n            gcd(a,b) == a;\n        r := a;\n        assert\n            gcd(a,b) == r;\n    } else {\n        r4(a,b);\n        // Method call rule\n        assert\n            b > 0 && (a % b) >= 0 ==> gcd(a,b) == gcd(b,(a % b));\n        // assert\n        //    gcd(a,b) == GCD2(b, a % b);\n        r := GCD2(b, a % b);\n        assert\n            gcd(a,b) == r;\n    }\n    assert\n        gcd(a,b) == r;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0099", "language": "dafny", "source": "dafnybench", "source_id": "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1_ComputeFusc", "vc-description": "", "vc-preamble": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\n\nfunction fusc(n: int): nat\n\nlemma rule1()\n  ensures fusc(0) == 0\n\nlemma rule2()\n  ensures fusc(1) == 1\n\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\n\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)", "vc-code": "{\n  b := 0;\n  var n, a := N, 1;\n  assert 0 <= n <= N;\n  assert fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n  while (n != 0)\n    invariant 0 <= n <= N // J\n    invariant fusc(N) == a * fusc(n) + b * fusc(n + 1) // J\n    decreases n // D\n  {\n    ghost var d := n; // termination metric\n\n    assert fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n    assert n != 0;\n\n    assert (n % 2 != 0 && n % 2 == 0) || fusc(N) == a * fusc(n) + b * fusc(n + 1);\n    assert (n % 2 != 0 || n % 2 == 0) ==> fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n    assert n % 2 != 0 || fusc(N) == a * fusc(n) + b * fusc(n + 1);\n    assert n % 2 == 0 || fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n    assert n % 2 == 0 ==> fusc(N) == a * fusc(n) + b * fusc(n + 1);\n    assert n % 2 != 0 ==> fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      assert fusc((n/2) + 1) == fusc(n + 1) - fusc(n/2);\n\n      rule3(n/2);\n      assert fusc(n/2) == fusc(n);\n\n      assert fusc(N) == (a + b) * fusc(n/2) + b * fusc((n/2) + 1);\n\n      a := a + b;\n\n      assert fusc(N) == a * fusc(n/2) + b * fusc((n/2) + 1);\n\n      n := n / 2;\n\n      assert fusc(N) == a * fusc(n) + b * fusc(n + 1);\n    } else {\n      rule4((n-1)/2);\n      assert fusc(n) - fusc((n-1)/2) == fusc(((n-1)/2)+1);\n\n      rule3((n-1)/2);\n      assert fusc((n-1)/2) == fusc(n-1);\n\n      assert fusc(((n-1)/2)+1) == fusc((n+1)/2);\n\n      rule3((n+1)/2);\n      assert fusc((n+1)/2) == fusc(n+1);\n\n      assert fusc(N) == a * fusc(n) + b * fusc(n + 1);\n\n      assert fusc(N) == b * fusc(((n-1)/2)+1) + a * fusc(n);\n\n      assert fusc(N) ==\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n\n      assert fusc(N) ==\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n\n      assert fusc(N) == b * fusc(n) - b  * fusc((n-1)/2) + a * fusc(n);\n\n      assert fusc(N) == b * fusc(n) - b  * fusc(n-1) + a * fusc(n);\n\n      assert fusc(N) == b * fusc(n) - b  * fusc(n-1) + a * fusc(n);\n\n      assert fusc(N) ==\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      assert fusc(N) == a * fusc(n - 1) + (b + a) * (fusc(n) - fusc(n-1));\n\n      assert fusc(N) == a * fusc((n - 1)) + (b + a) * (fusc(n) - fusc((n-1)/2));\n\n      assert fusc(N) == a * fusc((n - 1) / 2) + (b + a) * fusc(((n - 1) / 2) + 1);\n\n      b := b + a;\n\n      assert fusc(N) == a * fusc((n - 1) / 2) + b * fusc(((n - 1) / 2) + 1);\n\n      n := (n - 1) / 2;\n\n      assert fusc(N) == a * fusc(n) + b * fusc(n + 1);\n    }\n    assert n < d; // termination metric\n    assert fusc(N) == a * fusc(n) + b * fusc(n + 1);  // J\n  }\n  assert n == 0; // !B\n\n  rule1();\n  assert fusc(0) == 0;\n\n  rule2();\n  assert fusc(1) == 1;\n\n  assert fusc(N) == a * fusc(0) + b * fusc(0 + 1);  // J\n\n  assert fusc(N) == a * 0 + b * 1; // J\n  assert b == fusc(N);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0103", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci2", "vc-description": "", "vc-preamble": "function fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method fibonacci2(n:nat) returns (f:nat)\nensures f==fib(n)", "vc-code": "{\nif (n==0) {f:=0;}\nelse{\n   var i := 1;\n   var fant := 0;\n   f := 1;\n   while i < n\n      decreases n-i//write the bound\n      invariant fant==fib(i-1) && f==fib(i)//write the invariant\n      invariant i<=n\n   {\n      fant, f := f, fant + f;\n      i := i + 1;\n   }\n}\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0104", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseFibonacci_fibonacci3", "vc-description": "", "vc-preamble": "function fib(n: nat): nat\ndecreases n\n{\n   if n == 0 then 0 else\n   if n == 1 then 1 else\n                  fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method fibonacci3(n:nat) returns (f:nat)\nensures f==fib(n)", "vc-code": "{\n{\n   var i: int := 0;\n   var a := 1;\n       f := 0; \n   while i < n\n    decreases n-i//write the bound\n    invariant 0<=i<=n\n    invariant if i ==0 then a==fib(i+1) && f==fib(i)//write the invariant \n               else a==fib(i-1) && f==fib(i)\n   {\n      a, f := f, a + f; \n      i := i + 1;\n   }\n}\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0106", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive3", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])", "vc-code": "{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0107", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositive4", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])", "vc-code": "{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0108", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive_mpositivertl", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])", "vc-code": "{\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\n        decreases i\n        invariant -1 <= i < v.Length\n        invariant positive(v[i+1..])\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0110", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot2", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mroot2(n:int) returns (r:int) //Cost O(n)\nrequires n>=0\nensures r>=0 && r*r <= n <(r+1)*(r+1)", "vc-code": "{\n    r:=n;\n    while n<r*r\n    invariant 0<=r<=n && n<(r+1)*(r+1)//write the invariant\n    invariant r*r<=n ==> n<(r+1)*(r+1)\n    decreases r//write the bound\n    {\n        r:=r-1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0111", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExerciseSquare_root_mroot3", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mroot3(n:int) returns (r:int) \nrequires n>=0\nensures r>=0 && r*r <= n <(r+1)*(r+1)", "vc-code": "{\n  var y:int;\n  var h:int;\n  r:=0;\n  y:=n+1;\n  while (y!=r+1) \n    invariant r>=0 && r*r<=n<y*y && y>=r+1\n    decreases y-r\n  {\n    h:=(r+y)/2;\n    if (h*h<=n)\n      {r:=h;}\n    else\n      {y:=h;} \n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0115", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaximum2", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mmaximum2(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]", "vc-code": "{\n    var j:=v.Length-2; i:=v.Length - 1;\n    while(j>=0)\n        decreases j\n        invariant 0<=i<v.Length\n        invariant -1<=j<v.Length-1\n        invariant forall k :: v.Length>k>j ==> v[k]<=v[i]\n    {\n        if(v[j] > v[i]){i:=j;}\n        j:=j-1;\n    }\n}", "vc-postamble": "//Algorithm : from left to right\n//Algorithm : from right to left", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0116", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaxvalue1", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first\nmethod mmaximum1(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\n{\n    var j:=1; i:=0;\n    while(j<v.Length)\n        decreases v.Length - j\n        invariant 0<=j<=v.Length\n        invariant 0<=i<j\n        invariant forall k:: 0<=k<j ==> v[i] >= v[k]\n    {\n        if(v[j] > v[i]){i:=j;}\n        j:=j+1;\n    }\n}\n\n//Algorithm 2: From right to left return the last\n\n\n\n\n//Algorithm : from left to right\n//Algorithm : from right to left", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mmaxvalue1(v:array<int>) returns (m:int)\nrequires v.Length>0\nensures m in v[..]\nensures forall k::0<=k<v.Length ==> m>=v[k]", "vc-code": "{\n    var i:=mmaximum1(v);\n    m:=v[i];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0117", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session3Exercises_ExerciseMaximum_mmaxvalue2", "vc-description": "", "vc-preamble": "//Algorithm 1: From left to right return the first\n\n//Algorithm 2: From right to left return the last\nmethod mmaximum2(v:array<int>) returns (i:int) \nrequires v.Length>0\nensures 0<=i<v.Length \nensures forall k:: 0<=k<v.Length ==> v[i]>=v[k]\n{\n    var j:=v.Length-2; i:=v.Length - 1;\n    while(j>=0)\n        decreases j\n        invariant 0<=i<v.Length\n        invariant -1<=j<v.Length-1\n        invariant forall k :: v.Length>k>j ==> v[k]<=v[i]\n    {\n        if(v[j] > v[i]){i:=j;}\n        j:=j-1;\n    }\n}\n\n\n\n\n//Algorithm : from left to right\n//Algorithm : from right to left", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mmaxvalue2(v:array<int>) returns (m:int)\nrequires v.Length>0\nensures m in v[..]\nensures forall k::0<=k<v.Length ==> m>=v[k]", "vc-code": "{\n    var i:=mmaximum2(v);\n    m:=v[i];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0119", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual2", "vc-description": "", "vc-preamble": "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\nlemma equivalenceNoOrder(s:seq<int>)\nensures allEqual(s) <==> forall i,j::0<=i<=j<|s| ==> s[i]==s[j]\n{}\n\n//All equal to first\nlemma equivalenceEqualtoFirst(s:seq<int>)\nrequires s!=[]\nensures allEqual(s) <==> (forall i::0<=i<|s| ==> s[0]==s[i])\n{}\n\n\n\nlemma equivalenceContiguous(s:seq<int>)\nensures (allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\nensures (allEqual(s) <== forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\n{\n  assert allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n\n  if(|s|==0 || |s|==1){\n\n  }\n  else{\n    calc {\n      forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n      ==>\n      {\n        equivalenceContiguous(s[..|s|-1]);\n        assert s[|s|-2] == s[|s|-1];\n      }\n      allEqual(s);\n    }\n  }\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mallEqual2(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])", "vc-code": "{\n  var i:int; \n  b:=true;\n\n  i:=0;\n  while (i < v.Length && v[i] == v[0])\n     invariant 0 <= i <= v.Length\n   invariant forall k:: 0 <= k < i ==> v[k] == v[0]\n     decreases v.Length - i\n     {\n     i:=i+1;\n     }\n     b:=(i==v.Length);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0120", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual3", "vc-description": "", "vc-preamble": "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\nlemma equivalenceNoOrder(s:seq<int>)\nensures allEqual(s) <==> forall i,j::0<=i<=j<|s| ==> s[i]==s[j]\n{}\n\n//All equal to first\nlemma equivalenceEqualtoFirst(s:seq<int>)\nrequires s!=[]\nensures allEqual(s) <==> (forall i::0<=i<|s| ==> s[0]==s[i])\n{}\n\n\n\nlemma equivalenceContiguous(s:seq<int>)\nensures (allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\nensures (allEqual(s) <== forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\n{\n  assert allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n\n  if(|s|==0 || |s|==1){\n\n  }\n  else{\n    calc {\n      forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n      ==>\n      {\n        equivalenceContiguous(s[..|s|-1]);\n        assert s[|s|-2] == s[|s|-1];\n      }\n      allEqual(s);\n    }\n  }\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mallEqual3(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])", "vc-code": "{\nequivalenceContiguous(v[..]);\n var i:int;\n b:=true;\n if (v.Length >0){\n    i:=0;\n    while (i<v.Length-1 && v[i]==v[i+1])\n    invariant 0<=i<=v.Length -1\n    invariant b==allEqual(v[..i+1])\n      decreases v.Length - i\n    {\n     i:=i+1;\n    }\n\n    b:=(i==v.Length-1);\n }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0121", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual4", "vc-description": "", "vc-preamble": "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\nlemma equivalenceNoOrder(s:seq<int>)\nensures allEqual(s) <==> forall i,j::0<=i<=j<|s| ==> s[i]==s[j]\n{}\n\n//All equal to first\nlemma equivalenceEqualtoFirst(s:seq<int>)\nrequires s!=[]\nensures allEqual(s) <==> (forall i::0<=i<|s| ==> s[0]==s[i])\n{}\n\n\n\nlemma equivalenceContiguous(s:seq<int>)\nensures (allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\nensures (allEqual(s) <== forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\n{\n  assert allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n\n  if(|s|==0 || |s|==1){\n\n  }\n  else{\n    calc {\n      forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n      ==>\n      {\n        equivalenceContiguous(s[..|s|-1]);\n        assert s[|s|-2] == s[|s|-1];\n      }\n      allEqual(s);\n    }\n  }\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mallEqual4(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])", "vc-code": "{\n var i:int;\n b:=true;\n if (v.Length>0){\n    i:=0;\n    while (i < v.Length-1 && b)\n    invariant 0 <= i < v.Length\n    invariant b==allEqual(v[..i+1])\n      decreases v.Length - i \n    {\n        b:=(v[i]==v[i+1]);\n        i:=i+1;\n    }\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0122", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseAllEqual_mallEqual5", "vc-description": "", "vc-preamble": "predicate allEqual(s:seq<int>)\n{forall i,j::0<=i<|s| && 0<=j<|s| ==> s[i]==s[j] }\n//{forall i,j::0<=i<=j<|s| ==> s[i]==s[j] }\n//{forall i::0<i<|s| ==> s[i-1]==s[i]} \n//{forall i::0<=i<|s|-1 ==> s[i]==s[i+1]}\n\n\n//Ordered indexes\nlemma equivalenceNoOrder(s:seq<int>)\nensures allEqual(s) <==> forall i,j::0<=i<=j<|s| ==> s[i]==s[j]\n{}\n\n//All equal to first\nlemma equivalenceEqualtoFirst(s:seq<int>)\nrequires s!=[]\nensures allEqual(s) <==> (forall i::0<=i<|s| ==> s[0]==s[i])\n{}\n\n\n\nlemma equivalenceContiguous(s:seq<int>)\nensures (allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\nensures (allEqual(s) <== forall i::0<=i<|s|-1 ==> s[i]==s[i+1])\n{\n  assert allEqual(s) ==> forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n\n  if(|s|==0 || |s|==1){\n\n  }\n  else{\n    calc {\n      forall i::0<=i<|s|-1 ==> s[i]==s[i+1];\n      ==>\n      {\n        equivalenceContiguous(s[..|s|-1]);\n        assert s[|s|-2] == s[|s|-1];\n      }\n      allEqual(s);\n    }\n  }\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mallEqual5(v:array<int>) returns (b:bool)\nensures b==allEqual(v[0..v.Length])", "vc-code": "{\n    var i := 0;\n    b := true;\n    while (i < v.Length && b) \n        invariant 0<=i<=v.Length//\n      invariant b ==> forall k::0<=k<i ==> v[k] == v[0]\n      invariant !b ==> exists k:: 0<=k<v.Length && v[k]!=v[0]\n        decreases v.Length - i - (if b then 0 else 1)//\n      { \n       if (v[i] != v[0]) { b := false; }\n       else { i := i+1;}\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0125", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative_mfirstNegative2", "vc-description": "", "vc-preamble": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])", "vc-code": "{\n i:=0;b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b ==> i<v.Length && v[i]<0 && !(exists k::0<=k<i && v[k]<0)\n    invariant b <== exists k::0<=k<i && v[k]<0\n    decreases v.Length - i - (if b then 1 else 0)\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0146", "language": "dafny", "source": "dafnybench", "source_id": "Dafny-Practice_tmp_tmphnmt4ovh_BST_BuildBST", "vc-description": "", "vc-preamble": "datatype Tree = Empty | Node(int,Tree,Tree)\n\n\n\nfunction NumbersInTree(t: Tree): set<int>\n{\n    NumbersInSequence(Inorder(t))\n}\n\nfunction NumbersInSequence(q: seq<int>): set<int>\n{\n    set x | x in q\n}\n\npredicate BST(t: Tree)\n{\n    Ascending(Inorder(t))\n}\n\nfunction Inorder(t: Tree): seq<int>\n{\n    match t {\n        case Empty => []\n        case Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)\n    }\n}\n\npredicate Ascending(q: seq<int>)\n{\n    forall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]\n}\n\npredicate NoDuplicates(q: seq<int>) { forall i,j :: 0 <= i < j < |q| ==> q[i] != q[j] }\n\n/*\n    Goal: Implement correctly, clearly. No need to document the proof obligations.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BuildBST(q: seq<int>) returns (t: Tree)\n    requires NoDuplicates(q)\n    ensures BST(t) && NumbersInTree(t) == NumbersInSequence(q)", "vc-code": "{\n    t := Empty;\n    for i:=0 to |q|\n        invariant BST(t);\n        invariant NumbersInTree(t) == NumbersInSequence(q[..i])\n    {\n        t := InsertBST(t,q[i]);\n    }\n}", "vc-postamble": "/*\n    Goal: Implement correctly, efficiently, clearly, documenting the proof obligations\n    as we've learned, with assertions and a lemma for each proof goal\n*/\nmethod InsertBST(t0: Tree, x: int) returns (t: Tree)\n    requires BST(t0) && x !in NumbersInTree(t0)\n    ensures BST(t) && NumbersInTree(t) == NumbersInTree(t0)+{x}\n{\n    match t0 \n    {\n        case Empty => t := Node(x, Empty, Empty);\n\n        case Node(i, left, right) => \n        {\n            var tmp:Tree:= Empty;\n            if x < i\n            {\n                LemmaBinarySearchSubtree(i,left,right);\n                tmp :=  InsertBST(left, x);\n                t := Node(i, tmp, right);\n                ghost var right_nums := Inorder(right);\n                ghost var left_nums := Inorder(left);\n                ghost var all_nums := Inorder(t0);\n                assert all_nums == left_nums + [i] + right_nums;\n                assert all_nums[|left_nums|] == i;\n                assert all_nums[|left_nums|+1..] == right_nums;\n                // assert all_nums[..|left_nums|] == left_nums;\n                assert Ascending(right_nums);\n                assert Ascending(left_nums);\n                assert Ascending(left_nums + [i] + right_nums);\n                assert forall j,k :: |left_nums| < j < k < |all_nums| ==> x < i < all_nums[j] < all_nums[k];\n                ghost var new_all_nums := Inorder(t);\n                ghost var new_left_nums := Inorder(tmp);\n                assert new_all_nums == (new_left_nums + [i] + right_nums);\n                assert Ascending([i]+right_nums);\n                assert Ascending(new_left_nums);\n                assert NumbersInSequence(new_left_nums) == NumbersInSequence(left_nums) + {x};\n                // assert Ascending(new_left_nums+ [i] + right_nums);\n\n\n                assert forall j,k::0<= j < k <|all_nums| ==> all_nums[j]<all_nums[k];\n                assert forall j,k::0<= j < k <|left_nums| ==> all_nums[j]<all_nums[k]<all_nums[|left_nums|];\n                assert all_nums[|left_nums|] == i;\n                assert left_nums == all_nums[..|left_nums|];\n                assert NumbersInSequence(new_left_nums) == NumbersInSequence(all_nums[..|left_nums|])+{x};\n                assert forall j,k::0<=j < k < |left_nums| ==> left_nums[j] < left_nums[k] < i;\n                assert x < i;\n\n                assert forall j :: j in NumbersInSequence(all_nums[..|left_nums|]) ==> j < i;\n                assert forall j :: j in NumbersInSequence(all_nums[..|left_nums|])+{x} ==> j < i;\n\n                assert forall j :: j in NumbersInSequence(new_left_nums) ==> j < i;\n                assert forall j :: j in NumbersInSequence(new_left_nums) <==> j in new_left_nums;\n\n                assert forall j,k::0<=j < k < |new_left_nums| ==> new_left_nums[j] < new_left_nums[k];\n                assert x < i;\n                lemma_all_small(new_left_nums,i);\n                assert forall j::0<=j < |new_left_nums| ==> new_left_nums[j] < i;\n\n                assert Ascending(new_left_nums+[i]);\n                assert Ascending(Inorder(t));\n\n                assert BST(t);\n            }\n            else\n            {\n                LemmaBinarySearchSubtree(i,left,right);\n                tmp := InsertBST(right, x);\n                t := Node(i, left, tmp);\n\n                ghost var right_nums := Inorder(right);\n                ghost var left_nums := Inorder(left);\n                ghost var all_nums := Inorder(t0);\n                assert all_nums == left_nums + [i] + right_nums;\n                assert all_nums[|left_nums|] == i;\n                assert all_nums[|left_nums|+1..] == right_nums;\n                // assert all_nums[..|left_nums|] == left_nums;\n                assert Ascending(right_nums);\n                assert Ascending(left_nums);\n                assert Ascending(left_nums + [i] + right_nums);\n                assert forall j,k :: 0 <= j < k < |left_nums| ==> all_nums[j] < all_nums[k] < i < x;\n                ghost var new_all_nums := Inorder(t);\n                ghost var new_right_nums := Inorder(tmp);\n                assert new_all_nums == (left_nums + [i] + new_right_nums);\n                assert Ascending(left_nums + [i]);\n                assert Ascending(new_right_nums);\n                assert NumbersInSequence(new_right_nums) == NumbersInSequence(right_nums) + {x};\n                // assert Ascending(left_nums+ [i] + right_nums);\n\n                assert forall j,k::0<= j < k <|all_nums| ==> all_nums[j]<all_nums[k];\n                assert forall j,k::|left_nums| < j < k < |all_nums|==> all_nums[|left_nums|]<all_nums[j]<all_nums[k];\n                assert all_nums[|left_nums|] == i;\n                assert left_nums == all_nums[..|left_nums|];\n                assert NumbersInSequence(new_right_nums) == NumbersInSequence(all_nums[|left_nums|+1..])+{x};\n                assert forall j,k::0<=j < k < |right_nums| ==> i < right_nums[j] < right_nums[k] ;\n                assert x > i;\n\n                // assert forall j :: j in NumbersInSequence(all_nums[|left_nums|+1..]) ==> j > i;\n                // assert forall j :: j in NumbersInSequence(all_nums[|left_nums|+1..])+{x} ==> j > i;\n\n                assert forall j :: j in NumbersInSequence(new_right_nums) ==> j > i;\n                assert forall j :: j in NumbersInSequence(new_right_nums) <==> j in new_right_nums;\n\n                assert forall j,k::0<=j < k < |new_right_nums| ==> new_right_nums[j] < new_right_nums[k];\n                assert x > i;\n                lemma_all_big(new_right_nums,i);\n                assert forall j::0<=j < |new_right_nums| ==> new_right_nums[j] > i;\n\n                // assert Ascending(new_right_nums+[i]);\n                assert Ascending(Inorder(t));\n\n                assert BST(t);\n            }\n        }\n    }\n}\n\nlemma   LemmaBinarySearchSubtree(n: int, left: Tree, right: Tree)\n    requires BST(Node(n, left, right))\n    ensures BST(left) && BST(right)\n{\n    assert Ascending(Inorder(Node(n, left, right)));\n    var qleft, qright := Inorder(left), Inorder(right);\n    var q := qleft+[n]+qright;\n    assert q == Inorder(Node(n, left, right));\n    assert Ascending(qleft+[n]+qright);\n    assert Ascending(qleft) by { LemmaAscendingSubsequence(q, qleft, 0); }\n    assert Ascending(qright) by { LemmaAscendingSubsequence(q, qright, |qleft|+1); }\n}\n\nlemma LemmaAscendingSubsequence(q1: seq<int>, q2: seq<int>, i: nat)\n    requires i <= |q1|-|q2| && q2 == q1[i..i+|q2|]\n    requires Ascending(q1)\n    ensures Ascending(q2)\n{}\n\nlemma lemma_all_small(q:seq<int>,i:int)\n    requires forall k:: k in NumbersInSequence(q) ==> k < i\n    requires forall k:: 0 <= k < |q| ==> q[k] in NumbersInSequence(q)\n    ensures forall j::0<=j < |q| ==> q[j] < i\n{}\n\nlemma lemma_all_big(q:seq<int>,i:int)\n    requires forall k:: k in NumbersInSequence(q) ==> k > i\n    requires forall k:: 0 <= k < |q| ==> q[k] in NumbersInSequence(q)\n    ensures forall j::0<=j < |q| ==> q[j] > i\n{}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0153", "language": "dafny", "source": "dafnybench", "source_id": "DafnyExercises_tmp_tmpd6qyevja_Part1_Q1_addArrays", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addArrays(a : array<int>, b : array<int>) returns (c : array<int>) \nrequires a.Length == b.Length\nensures b.Length == c.Length\nensures forall i:int :: 0 <= i <c.Length ==> c[i] == a[i] + b[i]", "vc-code": "{\n     c := new int[a.Length];\n     var j := 0;\n     while (j < a.Length) \n       invariant 0 <= j <= c.Length\n       invariant forall i :: (0 <= i < j) ==> c[i] == a[i] + b[i];\n     {    \n          c[j] := a[j] + b[j];\n          j := j + 1;      \n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0156", "language": "dafny", "source": "dafnybench", "source_id": "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_InsertNumber", "vc-description": "", "vc-preamble": "//predicate for primeness\n\nmethod testPrimeness(n: nat) returns (result: bool)\n{\n    if n <= 1 {\n        result := false;\n    } else if n == 2 {\n        result := true;\n    } else if n % 2 == 0 {\n        result := false;\n    } else {\n        result := true; // Simplified implementation\n    }\n}\n\nghost predicate prime(n: nat)\n\n{ n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }\n\ndatatype Answer = Yes | No | Unknown\n\n//the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number\n//is not in the database it returns Unknown\nclass {:autocontracts} PrimeMap{\n\n  var database: map<nat, bool>; \n\n//the valid invariant of the class\n  ghost predicate Valid()\n    reads this\n  {\n    forall i | i in database.Keys :: (database[i] == true <==> prime(i)) \n  }\n\n//the constructor\n  constructor()\n    ensures database == map[]\n  {\n    database := map[];\n  }\n\n\n  // check the primeness of n and insert it accordingly into the database", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method InsertNumber(n: nat) \n    modifies this\n    ensures database.Keys == old(database.Keys) + {n}\n    ensures prime(n) <==> database == database[n := true] \n    ensures !prime(n) <==> database == database[n := false]", "vc-code": "{\n    assume false;\n    var prime : bool;\n    prime := testPrimeness(n);\n    database := database[n := prime];\n}", "vc-postamble": "// lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,\n  // or with Unknown when it's not in the databse\n  method IsPrime?(n: nat) returns (answer: Answer) \n      ensures database.Keys == old(database.Keys)\n      ensures (n in database) && prime(n) <==> answer == Yes \n      ensures (n in database) && !prime(n) <==> answer == No \n      ensures !(n in database) <==> answer == Unknown\n  {\n    if !(n in database){\n      return Unknown;\n    } else if database[n] == true {\n      return Yes;\n    } else if database[n] == false {\n      return No;\n    }\n  }\n\n  // method to test whether a number is prime, returns bool\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0157", "language": "dafny", "source": "dafnybench", "source_id": "DafnyPrograms_tmp_tmp74_f9k_c_prime-database_InsertPrime", "vc-description": "", "vc-preamble": "//predicate for primeness\n\nmethod testPrimeness(n: nat) returns (result: bool)\n{\n    if n <= 1 {\n        result := false;\n    } else if n == 2 {\n        result := true;\n    } else if n % 2 == 0 {\n        result := false;\n    } else {\n        result := true; // Simplified implementation\n    }\n}\n\nghost predicate prime(n: nat)\n\n{ n > 1 && (forall nr | 1 < nr < n :: n % nr != 0) }\n\ndatatype Answer = Yes | No | Unknown\n\n//the class containing a prime database, if a number is prime it returns Yes, if it is not No and if the number\n//is not in the database it returns Unknown\nclass {:autocontracts} PrimeMap{\n\n  var database: map<nat, bool>; \n\n//the valid invariant of the class\n  ghost predicate Valid()\n    reads this\n  {\n    forall i | i in database.Keys :: (database[i] == true <==> prime(i)) \n  }\n\n//the constructor\n  constructor()\n    ensures database == map[]\n  {\n    database := map[];\n  }\n\n  // insert an already known prime number into the database", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method InsertPrime(n: nat)\n    modifies this;\n    ensures database.Keys == old(database.Keys) + {n}\n    requires prime(n)\n    ensures database == database[n := true]", "vc-code": "{\n    database := database[n := true];\n}", "vc-postamble": "// lookup n in the database and reply with Yes or No if it's in the database and it is or it is not prime,\n  // or with Unknown when it's not in the databse\n  method IsPrime?(n: nat) returns (answer: Answer) \n      ensures database.Keys == old(database.Keys)\n      ensures (n in database) && prime(n) <==> answer == Yes \n      ensures (n in database) && !prime(n) <==> answer == No \n      ensures !(n in database) <==> answer == Unknown\n  {\n    if !(n in database){\n      return Unknown;\n    } else if database[n] == true {\n      return Yes;\n    } else if database[n] == false {\n      return No;\n    }\n  }\n\n  // method to test whether a number is prime, returns bool\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0160", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_Graph_addEdge", "vc-description": "", "vc-preamble": "// Simple directed graph with vertices of any type T.\nclass {:autocontracts} Graph<T(==)> {\n   var V: set<T>; // vertex-set\n   var E: set<(T, T)>; // edge-set\n\n   // Class invariant.\n   ghost predicate Valid() {\n       // edges must refer to vertices that belong to the vertex-set \n       // and self-loops (edges connecting a vertex to itself) are not allowed \n       forall e :: e in E ==> e.0 in V && e.1 in V && e.0 != e.1\n   } \n\n   // Creates an empty graph.\n   constructor ()\n     ensures V == {} && E == {}\n     {\n       V:= {};\n       E := {};\n     }\n\n\n   // Adds a new edge (u, v) to this graph.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addEdge(u: T, v: T)\n     requires u in V && v in V && (u, v) !in E && u != v\n     ensures V == old(V) && E == old(E) + {(u, v)}", "vc-code": "{\n        E := E + {(u, v)};\n}", "vc-postamble": "// Obtains the set of vertices adjacent to a given vertex v. \n   function getAdj(v: T): set<T>\n     requires v in V\n     {\n        set e | e in E && e.0 == v :: e.1\n     } \n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0161", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_Graph_addVertex", "vc-description": "", "vc-preamble": "// Simple directed graph with vertices of any type T.\nclass {:autocontracts} Graph<T(==)> {\n   var V: set<T>; // vertex-set\n   var E: set<(T, T)>; // edge-set\n\n   // Class invariant.\n   ghost predicate Valid() {\n       // edges must refer to vertices that belong to the vertex-set \n       // and self-loops (edges connecting a vertex to itself) are not allowed \n       forall e :: e in E ==> e.0 in V && e.1 in V && e.0 != e.1\n   } \n\n   // Creates an empty graph.\n   constructor ()\n     ensures V == {} && E == {}\n     {\n       V:= {};\n       E := {};\n     }\n\n   // Adds a new vertex v to this graph.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addVertex(v: T)\n     requires v !in V\n     ensures E == old(E) && V == old(V) + {v}", "vc-code": "{\n        V := V + {v};\n}", "vc-postamble": "// Obtains the set of vertices adjacent to a given vertex v. \n   function getAdj(v: T): set<T>\n     requires v in V\n     {\n        set e | e in E && e.0 == v :: e.1\n     } \n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0162", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_Graph_collapseVertices", "vc-description": "", "vc-preamble": "// Simple directed graph with vertices of any type T.\nclass {:autocontracts} Graph<T(==)> {\n   var V: set<T>; // vertex-set\n   var E: set<(T, T)>; // edge-set\n\n   // Class invariant.\n   ghost predicate Valid() {\n       // edges must refer to vertices that belong to the vertex-set \n       // and self-loops (edges connecting a vertex to itself) are not allowed \n       forall e :: e in E ==> e.0 in V && e.1 in V && e.0 != e.1\n   } \n\n   // Creates an empty graph.\n   constructor ()\n     ensures V == {} && E == {}\n     {\n       V:= {};\n       E := {};\n     }\n\n\n   // Obtains the set of vertices adjacent to a given vertex v. \n   function getAdj(v: T): set<T>\n     requires v in V\n     {\n        set e | e in E && e.0 == v :: e.1\n     } \n\n\n    // Collapses a subset C of vertices to a single vertex v (belonging to C).\n    // All vertices in C are removed from the graph, except v.  \n    // Edges that connect vertices in C are removed from the graph.  \n    // In all other edges, vertices belonging to C are replaced by v.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method collapseVertices(C: set<T>, v: T)\n      requires v in C && C <= V \n      ensures V == old(V) - C + {v}\n      ensures E == set e | e in old(E) && (e.0 !in C || e.1 !in C) ::\n                          (if e.0 in C then v else e.0, if e.1 in C then v else e.1)", "vc-code": "{\n        V := V - C + {v};\n        E := set e | e in E && (e.0 !in C || e.1 !in C) ::\n                          (if e.0 in C then v else e.0, if e.1 in C then v else e.1);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0163", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_Graph_removeVertex", "vc-description": "", "vc-preamble": "// Simple directed graph with vertices of any type T.\nclass {:autocontracts} Graph<T(==)> {\n   var V: set<T>; // vertex-set\n   var E: set<(T, T)>; // edge-set\n\n   // Class invariant.\n   ghost predicate Valid() {\n       // edges must refer to vertices that belong to the vertex-set \n       // and self-loops (edges connecting a vertex to itself) are not allowed \n       forall e :: e in E ==> e.0 in V && e.1 in V && e.0 != e.1\n   } \n\n   // Creates an empty graph.\n   constructor ()\n     ensures V == {} && E == {}\n     {\n       V:= {};\n       E := {};\n     }\n\n\n   // Obtains the set of vertices adjacent to a given vertex v. \n   function getAdj(v: T): set<T>\n     requires v in V\n     {\n        set e | e in E && e.0 == v :: e.1\n     } \n\n   // Removes a vertex v and all the edges incident on v from the graph.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method removeVertex(v: T)\n     requires v in V\n     ensures V == old(V) - {v}\n     ensures E == set e | e in old(E) && e.0 != v && e.1 != v", "vc-code": "{\n        V := V - {v};\n        E := set e | e in E && e.0 != v && e.1 != v;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0165", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_RawSort_rawsort", "vc-description": "", "vc-preamble": "function multisets<T>(s: seq<T>): multiset<T>\n{\n    if |s| == 0 then multiset{} \n    else multiset{s[0]} + multiset(s[1..])\n}\n\n/**\n * Proves the correctness of a \"raw\" array sorting algorithm that swaps elements out of order, chosen randomly.\n * FEUP, MFES, 2020/21.\n */\n\n// Type of each array element; can be any type supporting comparision operators.\ntype T = int \n\n// Checks if array 'a' is sorted by non-descending order.\nghost predicate sorted(a: array<T>)\n  reads a\n{ forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j] }\n\n// Obtains the set of all inversions in an array 'a', i.e., \n// the pairs of indices i, j such that i < j and a[i] > a[j]. \nghost function inversions(a: array<T>): set<(nat, nat)>\n  reads a\n{ set i, j | 0 <= i < j < a.Length && a[i] > a[j] :: (i, j) }\n\n// Sorts an array by simply swapping elements out of order, chosen randomly.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method rawsort(a: array<T>)\n   modifies a\n   ensures sorted(a) && multiset(a[..]) == multiset(old(a[..]))\n   decreases |inversions(a)|", "vc-code": "{\n   if i, j :| 0 <= i < j < a.Length && a[i] > a[j]  {\n      ghost var bef := inversions(a); // inversions before swapping\n      a[i], a[j] := a[j], a[i]; // swap\n      ghost var aft := inversions(a); // inversions after swapping  \n      ghost var aft2bef := map p | p in aft :: // maps inversions in 'aft' to 'bef'\n                  (if p.0 == i && p.1 > j then j else if p.0 == j then i else p.0,\n                   if p.1 == i then j else if p.1 == j && p.0 < i then i else p.1);    \n      mappingProp(aft, bef, (i, j), aft2bef); // recall property implying |aft| < |bef|\n      rawsort(a); // proceed recursivelly\n   }\n}", "vc-postamble": "// States and proves (by induction) the following property: given sets 'a' and 'b' and an injective\n// and non-surjective mapping 'm' from elements in 'a' to elements in 'b', then |a| < |b|.\n// To facilitate the proof, it is given an element 'k' in 'b' that is not an image of elements in 'a'.   \nlemma mappingProp<T1, T2>(a: set<T1>, b: set<T2>, k: T2, m: map<T1, T2>)\n  requires k in b\n  requires forall x :: x in a ==> x in m && m[x] in b - {k} \n  requires forall x, y :: x in a && y in a && x != y ==> m[x] != m[y] \n  ensures |a| < |b|\n{\n   if x :| x in a {\n      mappingProp(a - {x}, b - {m[x]}, k, m);\n   }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0166", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_findMax_findMax", "vc-description": "", "vc-preamble": "/* \n* Formal verification of a simple algorithm to find the maximum value in an array.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Finds the maximum value in a non-empty array.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method findMax(a: array<real>) returns (max: real)\n  requires a.Length > 0\n  ensures exists k :: 0 <= k < a.Length && max == a[k]\n  ensures forall k :: 0 <= k < a.Length ==> max >= a[k]", "vc-code": "{\n    max := a[0];\n    for i := 1 to a.Length\n      invariant exists k :: 0 <= k < i && max == a[k]\n      invariant forall k :: 0 <= k < i ==> max >= a[k]\n    {\n        if (a[i] > max) {\n            max := a[i];\n        }\n    } \n}", "vc-postamble": "// Test cases checked statically.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0169", "language": "dafny", "source": "dafnybench", "source_id": "DafnyProjects_tmp_tmp2acw_s4s_sqrt_sqrt", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sqrt(x: real) \nreturns (r: real)\n  requires x >= 0.0\n  ensures r * r == x && r >= 0.0", "vc-code": "{\n  assume false;\n}", "vc-postamble": "method testSqrt() {\n  var r := sqrt(4.0);\n  //if (2.0 < r) { monotonicSquare(2.0, r); }\n  if (r < 2.0) { monotonicSquare(r, 2.0); }\n  assert r == 2.0;\n}\n\nlemma monotonicMult(c: real, x: real, y: real)\n  requires x < y && c > 0.0\n  ensures c * x < c * y\n{}\n\n\nlemma monotonicSquare(x: real, y: real)\n  requires 0.0 < x < y\n  ensures 0.0 < x * x < y * y\n{\n    monotonicMult(x, x, y);\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0171", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_Evens", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n\n\n\n\nmethod ComputeCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n{\n    if CountIndex == 0{\n        p :=0;\n    } else{\n        if a[CountIndex-1]%2==0{\n            var d := ComputeCount(CountIndex -1,a,b);\n            p:= d+1;\n        }else{\n            var d:= ComputeCount(CountIndex -1,a,b);\n            p:= d;\n        }\n        b[CountIndex-1] := p;  \n    }\n}\n\nmethod PreCompute(a:array<int>,b:array<int>)returns(p:nat)\n    requires a.Length == b.Length \n    modifies b\n    ensures (b.Length == 0 || (a.Length == b.Length && 1 <= b.Length <= a.Length)) &&\n    forall p::p == Count(b.Length,a[..]) ==> p==Count(b.Length,a[..])\n\n{\n\n    assert  (b.Length == 0 || (a.Length == b.Length && 1 <= b.Length <= a.Length)) \n    && (forall p::p == Count(b.Length,a[..]) ==> p==Count(b.Length,a[..]) );\n    p := ComputeCount(b.Length,a[..],b);\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Evens(a:array<int>) returns (c:array2<int>)\n\n    // modifies c\n    // ensures  invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j<i ==> c[i,j] == 0", "vc-code": "{\n     c := new int[a.Length,a.Length];\n     var b := new int[a.Length];\n     var foo := PreCompute(a,b); \n     var m := 0;\n     while m != a.Length\n        decreases a.Length - m\n        modifies c\n        invariant 0 <= m <= a.Length\n        invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j<i ==> c[i,j] == 0\n        invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j>=i ==> i>0 ==> c[i,j] == b[j] - b[i-1]\n        invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j>=i ==> i == 0 ==> c[i,j] == b[j]\n     {  \n        var n := 0;\n        while n != a.Length\n            decreases a.Length - n\n            modifies c\n            invariant 0 <= n <= a.Length\n            invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j<i ==> c[i,j] == 0\n            invariant forall j:: 0 <= j <n ==> j < m ==> c[m,j] == 0\n            invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j>=i ==> i>0 ==> c[i,j] == b[j] - b[i-1]\n            invariant forall j:: 0 <= j <n ==> j>=m ==> m>0 ==> c[m,j] == b[j] - b[m-1]\n            invariant forall i,j:: 0 <=i <m && 0 <= j < a.Length ==> j>=i ==> i == 0 ==> c[i,j] == b[j]\n            invariant forall j:: 0 <= j <n ==> j>=m ==> m==0 ==> c[m,j] == b[j]\n        {   \n            if (n < m) {\n                c[m,n] := 0;\n            }else { \n                if m > 0 {\n                    c[m,n] := b[n] - b[m-1];\n                }else{\n                    c[m,n] := b[n];\n                }\n            }\n            n := n + 1;\n        }\n        m := m + 1;\n     }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0173", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_FooPreCompute", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}\n\nmethod FooCount(CountIndex:nat, a:seq<int>,b:array<int>) returns (p:nat)\n    requires  CountIndex == 0 || (|a| == b.Length && 1 <= CountIndex <= |a|)\n    decreases CountIndex\n    modifies b\n    ensures p == Count(CountIndex,a)\n{\n    assert CountIndex == 0 || (|a| == b.Length && 1<=CountIndex  <= |a|);\n    assert CountIndex == 0 || (|a| == b.Length && 0<=CountIndex -1 <= |a|);\n    assert CountIndex!=0 ==> |a| == b.Length && 0<=CountIndex -1 <= |a|;\n    assert CountIndex == 0 ==> true && CountIndex != 0 ==> |a| == b.Length && 0<=CountIndex -1 <= |a|;\n    if CountIndex == 0{\n        assert true;\n        assert 0 == 0;\n        assert 0 == Count(0,a);\n        p :=0;\n        assert p == Count(CountIndex,a);\n    } else{\n        assert |a| == b.Length && 0<=CountIndex-1 <=|a|;\n        assert (a[CountIndex-1]%2 ==0 ==>|a| == b.Length && 0<= CountIndex -1 <|a| && 1+ Count(CountIndex-1,a) == Count(CountIndex,a)) && \n        (a[CountIndex-1]%2 !=0 ==>  |a| == b.Length && 0<= CountIndex -1 <|a| && Count(CountIndex-1,a) == Count(CountIndex,a));\n        if a[CountIndex-1]%2==0{\n            assert |a| == b.Length && 0<= CountIndex -1 <|a| && 1+ Count(CountIndex-1,a) == Count(CountIndex,a);\n            var d := FooCount(CountIndex -1,a,b);\n            assert d+1 == Count(CountIndex,a);\n            p:= d+1;\n             assert p == Count(CountIndex,a);\n        }else{\n            assert |a| == b.Length && 0<= CountIndex -1 <|a| && Count(CountIndex-1,a) == Count(CountIndex,a);\n            assert  |a| == b.Length && 0<= CountIndex -1 <|a| && forall p'::p' ==Count(CountIndex-1,a) ==> p'==Count(CountIndex,a);\n            var d:= FooCount(CountIndex -1,a,b);\n            assert d == Count(CountIndex,a);\n            p:= d;\n            assert p == Count(CountIndex,a);\n        }\n        b[CountIndex-1] := p;\n        assert p == Count(CountIndex,a);\n\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FooPreCompute(a:array<int>,b:array<int>)\n    requires a.Length == b.Length\n    modifies b", "vc-code": "{\n    var CountIndex := 1;\n    while CountIndex != a.Length + 1\n        decreases a.Length + 1  - CountIndex\n        invariant 1 <= CountIndex <= a.Length +1;\n\n    {   \n        assert (CountIndex == 0 || (a.Length == b.Length && 1 <= CountIndex <= a.Length)) && forall a'::a' ==Count(CountIndex,a[..]) ==> a' ==Count(CountIndex,a[..]);\n        var p := FooCount(CountIndex,a[..],b);\n        assert 1<= CountIndex <= a.Length;\n        assert 1 <= CountIndex  + 1<= a.Length +1;\n        CountIndex := CountIndex +1;\n        assert 1 <= CountIndex <= a.Length +1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0174", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_A2_Q1_trimmed_copy_-_副本_Mult", "vc-description": "", "vc-preamble": "ghost function Count(hi: nat, s:seq<int>): int\n    requires 0 <= hi <= |s|\n    decreases hi\n{\n    if hi == 0 then 0\n    else if s[hi-1]%2 == 0 then 1 + Count(hi-1, s) else Count(hi-1, s)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mult(x:int, y:int) returns (r:int)\n    requires x>= 0 && y>=0\n    decreases x\n    ensures r == x*y", "vc-code": "{\n    if x==0 {\n        r:=0;\n    }else{\n        assert x-1>= 0 && y>= 0&& (x-1)*y + y== x*y;\n        var z:= Mult(x-1,y);\n        assert z+y == x*y;\n        r:=z+y;\n        assert r == x*y;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0176", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_MaxSum_MaxSum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MaxSum(x:int, y:int) returns (s:int, m:int)\n    ensures s == x+y\n    ensures (m == x || m == y) && x <= m && y <= m", "vc-code": "{\n    s := x+y;\n    if x > y{\n      m := x;\n    } else if y > x{\n      m := y;\n    } else {\n      m := x;\n    }\n    assert  m >= y;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0177", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week1_7_week5_ComputePower_CalcPower", "vc-description": "", "vc-preamble": "function Power(n:nat):nat \n{\n    if n == 0 then 1 else 2 * Power(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CalcPower(n:nat) returns (p:nat)\n    ensures p == 2*n;", "vc-code": "{\n    p := 2*n;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0179", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_peek1", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method peek1() returns (EmptyStatus:bool, TopItem:T)\n        requires Valid()\n        ensures Empty1() ==> EmptyStatus == false\n        ensures !Empty1() ==> EmptyStatus == true && TopItem == s1[|s1|-1] \n        ensures Valid()", "vc-code": "{\n        if n1 == 0 {\n            EmptyStatus := false;\n            TopItem := *;\n        } else {\n            TopItem := data[n1-1];\n            EmptyStatus := true;\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0180", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_peek2", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method peek2() returns (EmptyStatus:bool, TopItem:T)\n        requires Valid()\n        ensures Empty2() ==> EmptyStatus == false\n        ensures !Empty2() ==> EmptyStatus == true && TopItem == s2[|s2|-1] \n        ensures Valid()", "vc-code": "{\n        if n2 == 0 {\n            EmptyStatus := false;\n            TopItem := *;\n        } else {\n            TopItem := data[data.Length-n2];\n            EmptyStatus := true;\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0181", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_pop1", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method pop1() returns (EmptyStatus:bool, PopedItem:T)\n        requires Valid()\n        modifies Repr\n        ensures old(|s1|) != 0 ==> s1 == old(s1[0..|s1|-1]) && EmptyStatus == true && PopedItem == old(s1[|s1|-1]) \n        ensures old(|s1|) == 0 ==> EmptyStatus == false \n        ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n        if n1 == 0 { \n            EmptyStatus := false;\n            PopedItem := *;\n        } else{\n            s1 := old(s1[0..|s1|-1]);\n            PopedItem := data[n1-1];\n            n1 := n1 -1;\n            EmptyStatus := true;\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0182", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_pop2", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method pop2() returns (EmptyStatus:bool, PopedItem:T)\n        requires Valid()\n        modifies Repr\n        ensures old(|s2|) != 0 ==> s2 == old(s2[0..|s2|-1]) && EmptyStatus == true && PopedItem == old(s2[|s2|-1]) \n        ensures old(|s2|) == 0 ==> EmptyStatus == false \n        ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n        if n2 == 0 { \n            EmptyStatus := false;\n            PopedItem := *;\n        } else{\n            s2 := old(s2[0..|s2|-1]);\n            PopedItem := data[data.Length-n2];\n            n2 := n2 -1;\n            EmptyStatus := true;\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0183", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_push1", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method push1(element:T) returns (FullStatus:bool)\n        requires Valid()\n        modifies Repr\n        ensures old(|s1|) != N && old(|s1|) + old(|s2|) != N ==> s1 ==  old(s1) + [element];\n        ensures old(|s1|) == N ==> FullStatus == false\n        ensures old(|s1|) != N && old(|s1|) + old(|s2|) == N ==> FullStatus == false\n        ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n        if n1  == data.Length\n        {   \n            FullStatus := false;\n        }else {\n            if n1 != data.Length && n1 + n2 != data.Length{\n                s1 := old(s1) + [element] ;\n                data[n1] := element;\n                n1 := n1 +1;\n                FullStatus := true;\n            }else{\n                FullStatus := false;\n            }\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0184", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_push2", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method push2(element:T) returns (FullStatus:bool)\n        requires Valid()\n        modifies Repr\n        ensures old(|s2|) != N && old(|s1|) + old(|s2|) != N ==> s2 ==  old(s2) + [element];\n        ensures old(|s2|) == N ==> FullStatus == false\n        ensures old(|s2|) != N && old(|s1|) + old(|s2|) == N ==> FullStatus == false\n        ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n        if n2  == data.Length\n        {   \n            FullStatus := false;\n        }else {\n            if n2 != data.Length && n1 + n2 != data.Length{\n                s2 := old(s2) + [element] ;\n                data[data.Length-1-n2] := element;\n                n2 := n2 +1;\n                FullStatus := true;\n            }else{\n                FullStatus := false;\n            }\n        }\n}", "vc-postamble": "ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0185", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_search1", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }\n\n\n\n\n\n\n\n    ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method search1(Element:T) returns (position:int)\n        requires Valid()\n        ensures position == -1 || position >= 1\n        ensures position >= 1 ==> exists i::0 <=i < |s1| && s1[i] == Element && !Empty1()\n        ensures position == -1 ==> forall i :: 0 <= i < |s1| ==> s1[i] != Element || Empty1()\n        ensures Valid()", "vc-code": "{\n        var n := 0;\n        position := 0;\n\n        while n != n1\n            decreases |s1| - n\n            invariant Valid()\n            invariant 0 <= n <= |s1|\n            invariant position >= 1 ==> exists i::0 <= i < |s1| && s1[i] == Element\n            invariant forall i :: |s1|-1-n < i < |s1|==> s1[i] != Element\n        {\n            if data[n1-1-n] == Element \n            {\n                position := n + 1;\n                return position; \n            }\n            n := n + 1;\n        }\n        position := -1;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0186", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_a3_copy_2_search3", "vc-description": "", "vc-preamble": "class TwoStacks<T(0)(==)> \n{\n    //abstract state\n    ghost var s1 :seq<T>\n    ghost var s2 :seq<T>\n    ghost const N :nat // maximum size of the stacks\n    ghost var Repr : set<object>\n    //concrete state\n    var data: array<T>\n    var n1: nat // number of elements in the stack 1\n    var n2: nat // number of elements in the stack 2\n\n    ghost predicate Valid()\n        reads this,Repr\n        ensures Valid() ==> this in Repr &&  |s1| + |s2| <= N && 0 <= |s1| <= N && 0 <=|s2| <= N\n    {\n        this in Repr && data in Repr && data.Length == N  \n         && 0 <= |s1| + |s2| <= N && 0 <=|s1| <= N && 0 <=|s2| <= N\n        &&  (|s1| != 0 ==> forall i:: 0<= i < |s1| ==> s1[i] == data[i]) \n        && (|s2| != 0 ==> forall i:: 0<= i < |s2| ==> s2[i] == data[data.Length-1-i])\n       && n1 == |s1| && n2 == |s2|\n    }\n\n    constructor (N: nat)\n        ensures Valid() && fresh(Repr)\n        ensures s1 == s2 == [] && this.N == N\n    {\n        s1,s2,this.N := [],[],N;\n        data := new T[N];\n        n1, n2 := 0, 0;\n        Repr := {this, data};\n    }\n\n\n\n\n\n\n\n    ghost predicate Empty1() \n        requires Valid()\n        reads this,Repr\n        ensures Empty1() ==> |s1| == 0\n        ensures Valid()\n    {\n        |s1| == 0 && n1 == 0\n    }\n\n    ghost predicate Empty2() \n        reads this\n        ensures Empty2() ==> |s2| == 0\n    {\n        |s2| == 0 && n2 == 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method search3(Element:T) returns (position:int)\n        requires Valid()\n        ensures position == -1 || position >= 1\n        ensures position >= 1 ==> exists i::0 <=i < |s2| && s2[i] == Element && !Empty2()\n      //  ensures position == -1 ==> forall i :: 0 <= i < |s2| ==> s2[i] != Element || Empty2()\n        ensures Valid()", "vc-code": "{\n        position := 0;\n        var n := 0;\n\n        while n != n2\n            decreases |s2| - n\n            invariant 0 <= n <= |s2|\n            invariant Valid()\n            invariant position >= 1 ==> exists i::0 <= i < |s2| && s2[i] == Element\n            invariant forall i :: |s2| - 1- n < i < |s2| -1  ==> s2[i] != Element\n            invariant forall i :: data.Length-n2 < i < data.Length-n2+n ==> data[i] != Element\n        {\n            if data[data.Length - n2 + n] == Element \n            {\n                position :=  n + 1;\n\n                assert data[data.Length -n2 +n] == s2[n2-1-n];\n                assert position >= 1 ==> exists i::0 <= i < |s2| && s2[i] == Element;\n                assert forall i:: data.Length - |s2| < i< data.Length-1 ==> data[i] == s2[data.Length-i-1];\n                assert forall i:: 0 <= i < |s2| ==> s2[i] == data[data.Length-i-1];\n                assert  forall i :: |s2| - 1- n < i < |s2| -1  ==> s2[i] != Element;\n                assert  forall i :: data.Length-n2 < i < data.Length-n2+n ==> data[i] != Element;\n                return position; \n            }\n            n := n + 1;\n        }\n\n        position := -1;\n        assert position >= 1 ==> exists i::0 <= i < |s2| && s2[i] == Element;\n        assert forall i:: data.Length - |s2| < i< data.Length-1 ==> data[i] == s2[data.Length-i-1];\n        assert forall i:: 0 <= i < |s2| ==> s2[i] == data[data.Length-i-1];\n        assert  forall i :: |s2| - 1- n < i < |s2| -1  ==> s2[i] != Element;\n        assert  forall i :: data.Length-n2 < i < data.Length-n2+n ==> data[i] != Element;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0188", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week8_CheckSumCalculator_Append", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nghost function Hash(s:string):int {\n    SumChars(s) % 137\n}\n\nghost function SumChars(s: string):int {\n    if |s| == 0 then 0 else \n        s[|s| - 1] as int + SumChars(s[..|s| -1])\n}\nclass CheckSumCalculator{\n    var data: string\n    var cs:int\n\n    ghost predicate Valid()\n        reads this\n    {\n        cs == Hash(data)\n    }\n\n    constructor ()\n        ensures Valid() && data == \"\"\n    {\n        data, cs := \"\", 0;\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Append(d:string)\n        requires Valid()\n        modifies this\n        ensures Valid() && data == old(data) + d", "vc-code": "{\n        var i := 0;\n        while i != |d| \n            invariant 0<= i <= |d|\n            invariant Valid()\n            invariant data == old(data) + d[..i]\n        {\n            cs := (cs + d[i] as int) % 137;\n            data := data + [d[i]];\n            i := i +1;\n        }\n}", "vc-postamble": "function GetData(): string\n        requires Valid()\n        reads this\n        ensures Hash(GetData()) == Checksum()\n    {\n        data\n    }\n\n    function Checksum(): int \n        requires Valid()\n        reads this \n        ensures Checksum() == Hash(data)\n    {\n        cs\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0189", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week8_CoffeeMaker2_Dispense", "vc-description": "", "vc-preamble": "class Grinder { \n    ghost var hasBeans: bool \n    ghost var Repr: set<object>\n\n    ghost predicate Valid() \n        reads this, Repr\n        ensures Valid() ==> this in Repr\n\n    constructor() \n        ensures Valid() && fresh(Repr) && !hasBeans\n\n    function Ready(): bool \n        requires Valid() \n        reads Repr\n        ensures Ready() == hasBeans \n\n    method AddBeans() \n        requires Valid() \n        modifies Repr \n        ensures Valid() && hasBeans && fresh(Repr-old(Repr))\n\n    method Grind() \n        requires Valid() && hasBeans \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr))\n}\n\nclass WaterTank { \n    ghost var waterLevel: nat\n    ghost var Repr: set<object>\n\n    ghost predicate Valid()              \n        reads this, Repr        \n        ensures Valid() ==> this in Repr\n\n    constructor()                \n        ensures Valid() && fresh(Repr) && waterLevel == 0\n\n    function Level(): nat \n        requires Valid()\n        reads Repr\n        ensures Level() == waterLevel\n\n    method Fill() \n        requires Valid() \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr)) && waterLevel == 10 \n\n    method Use() \n        requires Valid() && waterLevel != 0 \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr)) && waterLevel == old(Level()) - 1  \n}\n\nclass CoffeeMaker {     \n    var g: Grinder  \n    var w: WaterTank\n    ghost var ready: bool\n    ghost var Repr: set<object>\n\n    ghost predicate Valid() \n        reads this, Repr \n        ensures Valid() ==> this in Repr\n    { \n        this in Repr && g in Repr && w in Repr &&\n        g.Repr <= Repr && w.Repr <= Repr &&\n        g.Valid() && w.Valid() &&\n        this !in g.Repr && this !in w.Repr && w.Repr !! g.Repr &&\n        ready == (g.hasBeans && w.waterLevel != 0) \n    }\n\n    constructor() \n        ensures Valid() && fresh(Repr)\n    { \n\n        g := new Grinder(); \n        w := new WaterTank(); \n        ready := false;\n        new;\n        Repr := {this, g, w} + g.Repr + w.Repr;\n\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Dispense()\n        requires Valid() && ready \n        modifies Repr \n        ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n        g.Grind(); \n        w.Use(); \n        ready := g.hasBeans && w.waterLevel != 0;\n        Repr := Repr + g.Repr + w.Repr;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0190", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week8_CoffeeMaker2_Restock", "vc-description": "", "vc-preamble": "class Grinder { \n    ghost var hasBeans: bool \n    ghost var Repr: set<object>\n\n    ghost predicate Valid() \n        reads this, Repr\n        ensures Valid() ==> this in Repr\n\n    constructor() \n        ensures Valid() && fresh(Repr) && !hasBeans\n\n    function Ready(): bool \n        requires Valid() \n        reads Repr\n        ensures Ready() == hasBeans \n\n    method AddBeans() \n        requires Valid() \n        modifies Repr \n        ensures Valid() && hasBeans && fresh(Repr-old(Repr))\n\n    method Grind() \n        requires Valid() && hasBeans \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr))\n}\n\nclass WaterTank { \n    ghost var waterLevel: nat\n    ghost var Repr: set<object>\n\n    ghost predicate Valid()              \n        reads this, Repr        \n        ensures Valid() ==> this in Repr\n\n    constructor()                \n        ensures Valid() && fresh(Repr) && waterLevel == 0\n\n    function Level(): nat \n        requires Valid()\n        reads Repr\n        ensures Level() == waterLevel\n\n    method Fill() \n        requires Valid() \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr)) && waterLevel == 10 \n\n    method Use() \n        requires Valid() && waterLevel != 0 \n        modifies Repr \n        ensures Valid() && fresh(Repr-old(Repr)) && waterLevel == old(Level()) - 1  \n}\n\nclass CoffeeMaker {     \n    var g: Grinder  \n    var w: WaterTank\n    ghost var ready: bool\n    ghost var Repr: set<object>\n\n    ghost predicate Valid() \n        reads this, Repr \n        ensures Valid() ==> this in Repr\n    { \n        this in Repr && g in Repr && w in Repr &&\n        g.Repr <= Repr && w.Repr <= Repr &&\n        g.Valid() && w.Valid() &&\n        this !in g.Repr && this !in w.Repr && w.Repr !! g.Repr &&\n        ready == (g.hasBeans && w.waterLevel != 0) \n    }\n\n    constructor() \n        ensures Valid() && fresh(Repr)\n    { \n\n        g := new Grinder(); \n        w := new WaterTank(); \n        ready := false;\n        new;\n        Repr := {this, g, w} + g.Repr + w.Repr;\n\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Restock() \n        requires Valid() \n        modifies Repr \n        ensures Valid() && ready == true && fresh(Repr - old(Repr))", "vc-code": "{\n        assert w.Valid();\n        g.AddBeans(); \n        assert w.Valid();\n        w.Fill();  \n        ready := true;\n        Repr := Repr + g.Repr + w.Repr;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0191", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_AssignmentsToMark", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AssignmentsToMark(students:int, tutors: int) returns (r:int)\n    requires students > 0 && tutors > 1\n    ensures r < students", "vc-code": "{\n    assert students > 0 && tutors > 1;\n    assert students > 0 && tutors > 1 && true;\n    assert students > 0 && tutors > 1 && students/tutors < students ==> students/tutors < students;\n    DivisionLemma(students,tutors);\n    assert students/tutors < students;\n    r:= students/tutors;\n    assert r< students;\n    calc  {\n        //true;\n        1/tutors < 1;\n        students/tutors < students;\n    }\n}", "vc-postamble": "lemma DivisionLemma(n:int,d:int) \n    requires n > 0 && d>1\n    ensures n/d < n\n\n\nmethod AssignmentsToMarkOne(students:int, tutors: int) returns (r:int)\n    requires students > 0 && tutors > 1\n    ensures r < students\n{\n\n    r:= students/tutors;\n\n    calc == {\n        true;\n        1/tutors < 1;\n        students/tutors < students;\n    }\n}\n\nlemma CommonElement(a:array<nat>, b:array<nat>)\n    requires a.Length> 0 && b.Length > 0 && a[0] == b[0]\n    ensures multiset(a[..])  * multiset(b[..]) == multiset([a[0]]) + multiset(a[1..]) * multiset(b[1..])\n    //ensures multiset{a[..]}  * multiset{b[..]} == multiset([a[0]]) + multiset{a[1..]} * multiset{b[1..]}\n/*\n{\n    var E := multiset{a[0]};\n    calc =={\n        multiset(a[..]) * multiset(b[..]);\n        assert (a[..] == [a[0]] + a[1..]) && (b[..] == [b[0]] + b[1..]); \n        (E+ multiset(a[1..])) * (E + multiset(a[1..]));\n        E + multiset(a[1..]) * multiset(b[1..]);\n    }\n}*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0192", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week9_lemma_AssignmentsToMarkOne", "vc-description": "", "vc-preamble": "lemma DivisionLemma(n:int,d:int) \n    requires n > 0 && d>1\n    ensures n/d < n", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AssignmentsToMarkOne(students:int, tutors: int) returns (r:int)\n    requires students > 0 && tutors > 1\n    ensures r < students", "vc-code": "{\n    r:= students/tutors;\n\n    calc == {\n        true;\n        1/tutors < 1;\n        students/tutors < students;\n    }\n}", "vc-postamble": "lemma CommonElement(a:array<nat>, b:array<nat>)\n    requires a.Length> 0 && b.Length > 0 && a[0] == b[0]\n    ensures multiset(a[..])  * multiset(b[..]) == multiset([a[0]]) + multiset(a[1..]) * multiset(b[1..])\n    //ensures multiset{a[..]}  * multiset{b[..]} == multiset([a[0]]) + multiset{a[1..]} * multiset{b[1..]}\n/*\n{\n    var E := multiset{a[0]};\n    calc =={\n        multiset(a[..]) * multiset(b[..]);\n        assert (a[..] == [a[0]] + a[1..]) && (b[..] == [b[0]] + b[1..]); \n        (E+ multiset(a[1..])) * (E + multiset(a[1..]));\n        E + multiset(a[1..]) * multiset(b[1..]);\n    }\n}*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0193", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week10_BoundedQueue_01_Insert", "vc-description": "", "vc-preamble": "class BoundedQueue<T(0)>\n{\n // abstract state\n ghost var contents: seq<T> // the contents of the bounded queue\n ghost var N: nat // the (maximum) size of the bounded queue\n ghost var Repr: set<object>\n // concrete state\nvar data: array<T>\n var wr: nat\n var rd: nat\n\n  ghost predicate Valid()\n reads this, Repr\nensures Valid() ==> this in Repr && |contents| <= N \n {\n this in Repr && data in Repr &&\ndata.Length == N + 1 &&\nwr <= N && rd <= N &&\n contents == if rd <= wr then data[rd..wr] else data[rd..] + data[..wr]\n }\n\n constructor (N: nat)\nensures Valid() && fresh(Repr)\nensures contents == [] && this.N == N\n{\n contents := [];\n this.N := N;\n data := new T[N+1]; // requires T to have default initial value\n rd, wr := 0, 0;\n Repr := {this, data};\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Insert(x:T)\nrequires Valid()\nrequires |contents| != N\nmodifies Repr\nensures contents == old(contents) + [x]\nensures N == old(N)\nensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n contents := old(contents) + [x];\n\n data[wr] := x;\n assert (wr == data.Length -1 ==> contents == if rd <= 0 then data[rd..0] else data[rd..] + data[..0])\n && (wr!= data.Length -1 ==> contents == if rd <= wr+1 then data[rd..wr+1] else data[rd..] + data[..wr+1]);\n if wr == data.Length -1 {\n    assert contents == if rd <= 0 then data[rd..0] else data[rd..] + data[..0];\n wr := 0;\n assert contents == if rd <= wr then data[rd..wr] else data[rd..] + data[..wr];\n } else {\n    assert contents == if rd <= wr+1 then data[rd..wr+1] else data[rd..] + data[..wr+1];\n wr := wr + 1;\n assert contents == if rd <= wr then data[rd..wr] else data[rd..] + data[..wr];\n }\n assert contents == if rd <= wr then data[rd..wr] else data[rd..] + data[..wr];\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0194", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week10_BoundedQueue_01_Remove", "vc-description": "", "vc-preamble": "class BoundedQueue<T(0)>\n{\n // abstract state\n ghost var contents: seq<T> // the contents of the bounded queue\n ghost var N: nat // the (maximum) size of the bounded queue\n ghost var Repr: set<object>\n // concrete state\nvar data: array<T>\n var wr: nat\n var rd: nat\n\n  ghost predicate Valid()\n reads this, Repr\nensures Valid() ==> this in Repr && |contents| <= N \n {\n this in Repr && data in Repr &&\ndata.Length == N + 1 &&\nwr <= N && rd <= N &&\n contents == if rd <= wr then data[rd..wr] else data[rd..] + data[..wr]\n }\n\n constructor (N: nat)\nensures Valid() && fresh(Repr)\nensures contents == [] && this.N == N\n{\n contents := [];\n this.N := N;\n data := new T[N+1]; // requires T to have default initial value\n rd, wr := 0, 0;\n Repr := {this, data};\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Remove() returns (x:T)\nrequires Valid()\nrequires |contents| != 0\nmodifies Repr\nensures contents == old(contents[1..]) && old(contents[0]) == x\nensures N == old(N)\nensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n contents := contents[1..];\n x := data[rd];\n if rd == data.Length - 1 {\n rd := 0;\n } else {\n rd := rd + 1;\n }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0195", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week10_ExtensibleArray_Add", "vc-description": "", "vc-preamble": "class ExtensibleArray<T(0)> {\n  // abstract state\n  ghost var Elements: seq<T>\n  ghost var Repr: set<object>\n  //concrete state\n  var front: array?<T>\n  var depot: ExtensibleArray?<array<T>>\n  var length: int   // number of elements\n  var M: int   // number of elements in depot\n\n  ghost predicate Valid()\n    decreases Repr +{this}\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    // Abstraction relation: Repr\n    this in Repr &&\n    (front != null ==> front in Repr) &&\n    (depot != null ==>\n      depot in Repr && depot.Repr <= Repr &&\n      forall j :: 0 <= j < |depot.Elements| ==>\n          depot.Elements[j] in Repr) &&\n    // Standard concrete invariants: Aliasing\n    (depot != null ==>\n        this !in depot.Repr && \n        front !in depot.Repr &&\n        forall j :: 0 <= j < |depot.Elements| ==>\n        depot.Elements[j] !in depot.Repr &&\n        depot.Elements[j] != front &&\n        forall k :: 0 <= k < |depot.Elements| && k != j ==>\n            depot.Elements[j] != depot.Elements[k]) &&\n    // Concrete state invariants\n    (front != null ==> front.Length == 256) &&\n    (depot != null ==>\n        depot.Valid() &&\n        forall j :: 0 <= j < |depot.Elements| ==>\n            depot.Elements[j].Length == 256) &&\n    (length == M <==> front == null) &&\n    M == (if depot == null then 0 else 256 * |depot.Elements|) &&\n    // Abstraction relation: Elements\n    length == |Elements| &&\n    M <= |Elements| < M + 256 &&\n    (forall i :: 0 <= i < M ==>\n      Elements[i] == depot.Elements[i / 256][i % 256]) &&\n      (forall i :: M <= i < length ==>\n          Elements[i] == front[i - M])\n  }\n\n  constructor ()\n    ensures Valid() && fresh(Repr) && Elements == []\n  {\n    front, depot := null, null;\n    length, M := 0, 0;\n    Elements, Repr := [], {this};\n  }\n\n  function Get(i: int): T\n    requires Valid() && 0 <= i < |Elements|\n    ensures Get(i) == Elements[i]\n    reads Repr\n  {\n    if M <= i then front[i - M]\n    else depot.Get(i/256)[i%256]\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Add(t: T)\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Elements == old(Elements) + [t]\n    decreases |Elements|", "vc-code": "{\n    if front == null {\n      front := new T[256];\n      Repr := Repr + {front};\n    }\n    front[length-M] := t;\n    length := length + 1;\n    Elements := Elements + [t];\n    if length == M + 256 {\n      if depot == null {\n        depot := new ExtensibleArray();\n      }\n      depot.Add(front);\n      Repr := Repr + depot.Repr;\n      M := M + 256;\n      front := null;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0196", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Learning_Experience_tmp_tmpuxvcet_u_week8_12_week10_ExtensibleArray_Set", "vc-description": "", "vc-preamble": "class ExtensibleArray<T(0)> {\n  // abstract state\n  ghost var Elements: seq<T>\n  ghost var Repr: set<object>\n  //concrete state\n  var front: array?<T>\n  var depot: ExtensibleArray?<array<T>>\n  var length: int   // number of elements\n  var M: int   // number of elements in depot\n\n  ghost predicate Valid()\n    decreases Repr +{this}\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    // Abstraction relation: Repr\n    this in Repr &&\n    (front != null ==> front in Repr) &&\n    (depot != null ==>\n      depot in Repr && depot.Repr <= Repr &&\n      forall j :: 0 <= j < |depot.Elements| ==>\n          depot.Elements[j] in Repr) &&\n    // Standard concrete invariants: Aliasing\n    (depot != null ==>\n        this !in depot.Repr && \n        front !in depot.Repr &&\n        forall j :: 0 <= j < |depot.Elements| ==>\n        depot.Elements[j] !in depot.Repr &&\n        depot.Elements[j] != front &&\n        forall k :: 0 <= k < |depot.Elements| && k != j ==>\n            depot.Elements[j] != depot.Elements[k]) &&\n    // Concrete state invariants\n    (front != null ==> front.Length == 256) &&\n    (depot != null ==>\n        depot.Valid() &&\n        forall j :: 0 <= j < |depot.Elements| ==>\n            depot.Elements[j].Length == 256) &&\n    (length == M <==> front == null) &&\n    M == (if depot == null then 0 else 256 * |depot.Elements|) &&\n    // Abstraction relation: Elements\n    length == |Elements| &&\n    M <= |Elements| < M + 256 &&\n    (forall i :: 0 <= i < M ==>\n      Elements[i] == depot.Elements[i / 256][i % 256]) &&\n      (forall i :: M <= i < length ==>\n          Elements[i] == front[i - M])\n  }\n\n  constructor ()\n    ensures Valid() && fresh(Repr) && Elements == []\n  {\n    front, depot := null, null;\n    length, M := 0, 0;\n    Elements, Repr := [], {this};\n  }\n\n  function Get(i: int): T\n    requires Valid() && 0 <= i < |Elements|\n    ensures Get(i) == Elements[i]\n    reads Repr\n  {\n    if M <= i then front[i - M]\n    else depot.Get(i/256)[i%256]\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Set(i: int, t: T)\n    requires Valid() && 0 <= i < |Elements|\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Elements == old(Elements)[i := t]", "vc-code": "{\n  if M <= i {\n    front[i - M] := t;\n  } else {\n    depot.Get(i/256)[i%256] := t;\n  }\n  Elements := Elements[i := t];\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0200", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Programs_tmp_tmp99966ew4_mymax_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b:int) returns (c: int)\n    ensures c >= a && c>= b", "vc-code": "{\n    if (a < b)\n        { c := b; }\n    else\n        { c := a; }\n    assert a <= c && b <= c;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0201", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_ComputePower", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)", "vc-code": "{\n    y := 1;\n    var x := 0; \n    while x != N\n        invariant 0 <= x <= N \n        invariant y == Power(x) \n        decreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}", "vc-postamble": "// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0202", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_CopyMatrix", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CopyMatrix(src: array2, dst: array2)\n    requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n    modifies dst\n    ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])", "vc-code": "{\n    var m := 0;\n    while m != src.Length0\n        invariant 0 <= m <= src.Length0\n        invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n        invariant forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> src[i,j] == old(src[i,j])\n    {\n        var n := 0;\n        while n != src.Length1\n            invariant 0 <= n <= src.Length1 \n            invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n            invariant forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> src[i,j] == old(src[i,j])\n            invariant forall j :: 0 <= j < n ==> dst[m,j] == old(src[m,j])\n        {\n            dst[m,n] := src[m,n]; n := n + 1;\n        }\n        m := m + 1; \n    }\n}", "vc-postamble": "// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0203", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_Cube", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Cube(n: nat) returns (c: nat) \n    ensures c == n * n * n", "vc-code": "{\n    c := 0;\n    var i := 0;\n    var k := 1;\n    var m := 6;\n    while i != n\n        invariant 0 <= i <= n \n        invariant c == i * i * i \n        invariant k == 3*i*i + 3*i + 1\n        invariant m == 6 * i + 6\n    {\n        c, k, m := c + k, k + m, m + 6; \n        i := i + 1;\n    }\n}", "vc-postamble": "// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0204", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_DoubleArray", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DoubleArray(src: array<int>, dst: array<int>)\n    requires src.Length == dst.Length\n    modifies dst\n    ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])", "vc-code": "{\n    var n := 0;\n    while n != src.Length\n    invariant 0 <= n <= src.Length\n    invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i]) \n    invariant forall i :: n <= i < src.Length ==> src[i] == old(src[i])\n    {\n        dst[n] := 2 * src[n]; n := n + 1;\n    } \n}", "vc-postamble": "// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0205", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_IncrementMatrix", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IncrementMatrix(a: array2<int>)\n    modifies a\n    ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1", "vc-code": "{\n    var m := 0;\n    while m != a.Length0\n        invariant 0 <= m <= a.Length0\n        invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1 \n        invariant forall i, j :: m <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j])\n    {\n        var n := 0;\n        while n != a.Length1\n            invariant 0 <= n <= a.Length1\n            invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1 \n            invariant forall i, j :: m < i < a.Length0 && 0 <= j < a.Length1==> a[i,j] == old(a[i,j]) \n            invariant forall j :: 0 <= j < n ==> a[m,j] == old(a[m,j])+1\n            invariant forall j :: n <= j < a.Length1 ==> a[m,j] == old(a[m,j])\n        {\n            a[m,n] := a[m,n] + 1;\n            n := n + 1; \n        }\n        m := m + 1; \n    }\n}", "vc-postamble": "// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0206", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_Max", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: array<nat>) returns (m: int)\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]", "vc-code": "{\n    m := 0;\n    var n := 0;\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        invariant forall i :: 0 <= i < n ==> a[i] <= m\n        invariant (m == 0 && n == 0) || exists i :: 0 <= i < n && m == a[i]\n    {\n        if m < a[n] {\n            m := a[n]; \n        }\n        n := n + 1; \n    }\n}", "vc-postamble": "// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0207", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_RotateLeft", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RotateLeft(a: array)\n    requires a.Length > 0\n    modifies a\n    ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n    ensures a[a.Length -1] == old(a[0])", "vc-code": "{\n    var n := 0;\n    while n != a.Length - 1\n        invariant 0 <= n <= a.Length - 1\n        invariant forall i :: 0 <= i < n ==> a[i] == old(a[i+1]) \n        invariant a[n] == old(a[0])\n        invariant forall i :: n < i <= a.Length-1 ==> a[i] == old(a[i])\n    {\n        a[n], a[n+1] := a[n+1], a[n];\n        n := n + 1; \n    }\n}", "vc-postamble": "// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0208", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_validation_examples_RotateRight", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\n\n\n\n// Original davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n\n// Fine_tuned davinci-003 completion:\n// method ComputePower1(N: int) returns (y: nat) requires N >= 0\n//     ensures y == Power(N)\n// {\n//     y := 1;\n//     var x := 0; \n//     while x != N\n//         decreases N - x\n//         invariant 0 <= x <= N\n//         invariant y == Power(x)\n//     {\n//         x, y := x + 1, y + y;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Max(a: array<nat>) returns (m: int)\n//     requires a.Length > 0\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures exists i :: 0 <= i < a.Length && m == a[i] \n// {\n//     m := a[0];\n//     var n := 1;\n//     while n != a.Length\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//         // Loop invariant: 0 <= n <= a.Length && forall i :: 0 <= i < n ==> a[i] <= m\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Max1(a: array<nat>) returns (m: int)\n//     ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n//     ensures (m == 0 && a.Length == 0) || exists i :: 0 <= i < a.Length && m == a[i]\n// {\n//     m := 0;\n//     var n := 0;\n//     while n != a.Length\n//         invariant 0 <= n <= a.Length\n//         invariant forall i :: 0 <= i < n ==> a[i] <= m\n//     {\n//         if m < a[n] {\n//             m := a[n]; \n//         }\n//         n := n + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method Cube(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     // Loop invariant: c = i^3\n//     while i != n\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method Cube1(n: nat) returns (c: nat) \n//     ensures c == n * n * n\n// {\n//     c := 0;\n//     var i := 0;\n//     var k := 1;\n//     var m := 6;\n//     while i != n\n//         invariant 0 <= i <= n\n//         invariant c == i * k * m\n//     {\n//         c, k, m := c + k, k + m, m + 6; \n//         i := i + 1;\n//     }\n// }\n\n\n\n\n// Original davinci-003 completion:\n// method IncrementMatrix(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         {\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> a[i,j] == old(a[i,j]) + 1\n//             a[m,n] := a[m,n] + 1;\n//             n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method IncrementMatrix1(a: array2<int>)\n//     modifies a\n//     ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n// {\n//     var m := 0;\n//     while m != a.Length0\n//         invariant 0 <= m <= a.Length0 && 0 <= j < a.Length1 <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//     {\n//         var n := 0;\n//         while n != a.Length1\n//         invariant 0 <= n <= a.Length2\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1\n//         {\n//             a[m,n] := a[m,n] + 1;\n//         n := n + 1; \n//         }\n//         m := m + 1; \n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method CopyMatrix(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n// {\n//     var m := 0;\n//     while m != src.Length0\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//         {\n//             dst[m,n] := src[m,n]; \n//             n := n + 1;\n//             // Loop invariant: forall i, j :: 0 <= i < m && 0 <= j < n ==> dst[i,j] == old(src[i,j])\n//         }\n//         m := m + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method CopyMatrix1(src: array2, dst: array2)\n//     requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n//     modifies dst\n//     ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     var m := 0;\n//     while m != src.Length0\n//         invariant 0 <= m <= src.Length0\n//         invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])\n//     {\n//         var n := 0;\n//         while n != src.Length1\n//            invariant 0 <= n <= src.Length1\n//         {\n//            dst[m,n] := src[m,n]; n := n + 1;\n//         }\n//         m := m + 1; \n//     }\n\n\n\n\n\n// Original davinci-003 completion:\n// method DoubleArray(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     var i : int := 0;\n//     while n != src.Length\n//     {\n//         dst[n] := 2 * src[n];\n//         n := n + 1;\n//         i := i + 1;\n//     } \n//     assert i == src.Length;\n// }\n\n// Fine_tuned davinci-003 completion:\n// method DoubleArray1(src: array<int>, dst: array<int>)\n//     requires src.Length == dst.Length\n//     modifies dst\n//     ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])\n// {\n//     var n := 0;\n//     while n != src.Length\n//         invariant 0 <= n <= src.Length\n//         invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i])\n//     {\n//         dst[n] := 2 * src[n]; n := n + 1;\n//     }\n// }\n\n\n// Original davinci-003 completion:\n// method RotateLeft(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)]) \n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     // loop invariant: forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//     while n != a.Length - 1\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1; \n//     }\n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateLeft1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     ensures a[a.Length -1] == old(a[0])\n// {\n//     var n := 0;\n//     while n != a.Length - 1\n//         invariant 0 <= n <= a.Length - 1\n//         invariant forall i :: 0 <= i < n ==> a[i] == old(a[(i+1)])\n//         invariant forall i :: 0 <= i < a.Length - 1 ==> a[i] == old(a[(i+1)])\n//     {\n//         a[n], a[n+1] := a[n+1], a[n];\n//         n := n + 1;\n//     }\n// }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RotateRight(a: array)\n    requires a.Length > 0\n    modifies a\n    ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n    ensures a[0] == old(a[a.Length-1])", "vc-code": "{\n    var n := 1;\n    while n != a.Length\n        invariant 1 <= n <= a.Length\n        invariant forall i :: 1 <= i < n ==> a[i] == old(a[i-1]) \n        invariant a[0] == old(a[n-1])\n        invariant forall i :: n <= i <= a.Length-1 ==> a[i] == old(a[i])\n    {\n        a[0], a[n] := a[n], a[0]; n := n + 1;\n    } \n}", "vc-postamble": "// Original davinci-003 completion:\n// method RotateRight(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     var temp := a[0];\n//     while n != a.Length\n//     {\n//         a[0] := a[n];\n//         a[n] := temp;\n//         temp := a[0];\n//         n := n + 1;\n//         // loop invariant:\n//         // forall k :: 0 <= k < n ==> a[k] == old(a[k+1])\n//     } \n// }\n\n// Fine_tuned davinci-003 completion:\n// method RotateRight1(a: array)\n//     requires a.Length > 0\n//     modifies a\n//     ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)])\n//     ensures a[0] == old(a[a.Length-1])\n// {\n//     var n := 1;\n//     while n != a.Length\n//         invariant 1 <= n <= a.Length\n//         invariant forall i :: 1<= i < n ==> a[i] == old(a[(i-1)])\n//         invariant forall i :: 1<= i < a.Length ==> a[i] == old(a[i])\n//     {\n//         a[0], a[n] := a[n], a[0]; n := n + 1;\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0209", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower_ComputePower", "vc-description": "", "vc-preamble": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)", "vc-code": "{\n    y := 1;\n    var x := 0; \n    while x != N\n        invariant 0 <= x <= N \n        invariant y == Power(x) \n        decreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0210", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_CopyMatrix_CopyMatrix", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CopyMatrix(src: array2, dst: array2)\n    requires src.Length0 == dst.Length0 && src.Length1 == dst.Length1\n    modifies dst\n    ensures forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j])", "vc-code": "{\n    var m := 0;\n    while m != src.Length0\n        invariant 0 <= m <= src.Length0\n        invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n        invariant forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> src[i,j] == old(src[i,j])\n    {\n        var n := 0;\n        while n != src.Length1\n            invariant 0 <= n <= src.Length1 \n            invariant forall i, j :: 0 <= i < m && 0 <= j < src.Length1 ==> dst[i,j] == old(src[i,j]) \n            invariant forall i, j :: 0 <= i < src.Length0 && 0 <= j < src.Length1 ==> src[i,j] == old(src[i,j])\n            invariant forall j :: 0 <= j < n ==> dst[m,j] == old(src[m,j])\n        {\n            dst[m,n] := src[m,n]; n := n + 1;\n        }\n        m := m + 1; \n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0211", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_Cube_Cube", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Cube(n: nat) returns (c: nat) \n    ensures c == n * n * n", "vc-code": "{\n    c := 0;\n    var i := 0;\n    var k := 1;\n    var m := 6;\n    while i != n\n        invariant 0 <= i <= n \n        invariant c == i * i * i \n        invariant k == 3*i*i + 3*i + 1\n        invariant m == 6 * i + 6\n    {\n        c, k, m := c + k, k + m, m + 6; \n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0212", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_DoubleArray_DoubleArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DoubleArray(src: array<int>, dst: array<int>)\n    requires src.Length == dst.Length\n    modifies dst\n    ensures forall i :: 0 <= i < src.Length ==> dst[i] == 2 * old(src[i])", "vc-code": "{\n    var n := 0;\n    while n != src.Length\n    invariant 0 <= n <= src.Length\n    invariant forall i :: 0 <= i < n ==> dst[i] == 2 * old(src[i]) \n    invariant forall i :: n <= i < src.Length ==> src[i] == old(src[i])\n    {\n        dst[n] := 2 * src[n]; n := n + 1;\n    } \n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0213", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_IncrementMatrix_IncrementMatrix", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IncrementMatrix(a: array2<int>)\n    modifies a\n    ensures forall i, j :: 0 <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1", "vc-code": "{\n    var m := 0;\n    while m != a.Length0\n        invariant 0 <= m <= a.Length0\n        invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1 \n        invariant forall i, j :: m <= i < a.Length0 && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j])\n    {\n        var n := 0;\n        while n != a.Length1\n            invariant 0 <= n <= a.Length1\n            invariant forall i, j :: 0 <= i < m && 0 <= j < a.Length1 ==> a[i,j] == old(a[i,j]) + 1 \n            invariant forall i, j :: m < i < a.Length0 && 0 <= j < a.Length1==> a[i,j] == old(a[i,j]) \n            invariant forall j :: 0 <= j < n ==> a[m,j] == old(a[m,j])+1\n            invariant forall j :: n <= j < a.Length1 ==> a[m,j] == old(a[m,j])\n        {\n            a[m,n] := a[m,n] + 1;\n            n := n + 1; \n        }\n        m := m + 1; \n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0214", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_RotateRight_RotateRight", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RotateRight(a: array)\n    requires a.Length > 0\n    modifies a\n    ensures forall i :: 1<= i < a.Length ==> a[i] == old(a[(i-1)]) \n    ensures a[0] == old(a[a.Length-1])", "vc-code": "{\n    var n := 1;\n    while n != a.Length\n        invariant 1 <= n <= a.Length\n        invariant forall i :: 1 <= i < n ==> a[i] == old(a[i-1]) \n        invariant a[0] == old(a[n-1])\n        invariant forall i :: n <= i <= a.Length-1 ==> a[i] == old(a[i])\n    {\n        a[0], a[n] := a[n], a[0]; n := n + 1;\n    } \n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0215", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n", "vc-code": "{\n    x_out := x;\n    y_out := y;\n    n := 0;\n\n    while (x_out != n)\n        invariant x_out >= 0\n        invariant x_out == y_out\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0216", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_37_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int) returns(x: int, m: int)\nrequires n > 0\nensures (n <= 0) || (0 <= m && m < n)", "vc-code": "{\n    x := 0;\n    m := 0;\n\n    while(x < n)\n        invariant 0 <= x <= n\n        invariant 0 <= m < n\n    {\n        if(*)\n        {\n            m := x;\n        }\n        else{}\n        x := x + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0217", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_38_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n : int) returns (i: int, x: int, y:int)\nrequires n >= 0\nensures (i % 2 != 0) || (x == 2 * y)", "vc-code": "{\n    i := 0;\n    x := 0;\n    y := 0;\n\n    while (i < n)\n        invariant 0 <= i <= n\n        invariant x == i\n        invariant y == i / 2\n    {\n        i := i + 1;\n        x := x + 1;\n        if (i % 2 == 0)\n        {\n            y := y + 1;\n        }\n        else\n        {}\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0218", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_41_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int, k: int) returns (i :int, j: int)\n    requires n >= 0\n    requires k == 1 || k >= 0\n    ensures k + i + j >= 2 * n", "vc-code": "{\n    i := 0;\n    j := 0;\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant j == i * (i + 1) / 2\n    {\n        i := i + 1;\n        j := j + i;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0219", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_BinarySearch_BinarySearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BinarySearch(a: array<int>, key: int) returns (n: int)\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures 0 <= n <= a.Length\n    ensures forall i :: 0 <= i < n ==> a[i] < key\n    ensures forall i :: n <= i < a.Length ==> key <= a[i]", "vc-code": "{\n    var lo, hi := 0, a.Length;\n\n    while lo < hi\n        invariant 0 <= lo <= hi <= a.Length\n        invariant forall i :: 0 <= i < lo ==> a[i] < key\n        invariant forall i :: hi <= i < a.Length ==> key <= a[i]\n    {\n        var mid := (lo + hi) / 2;\n\n        if a[mid] < key {\n            lo := mid + 1;\n        } else {\n            hi := mid;\n        }\n    }\n\n    n := lo;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0220", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray_SumArray", "vc-description": "", "vc-preamble": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)", "vc-code": "{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0221", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_07_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int) returns (a: int, b: int)\n    requires n >= 0\n    ensures a + b == 3 * n", "vc-code": "{\n    var i: int := 0;\n    a := 0;\n    b := 0;\n\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant a + b == 3 * i\n    {\n        if(*)\n        {\n            a := a + 1;\n            b := b + 2;\n        }\n        else\n        {\n            a := a + 2;\n            b := b + 1;\n        }\n\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0222", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_error_data_completion_11_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(x :int) returns (j :int, i :int)\nrequires x > 0\nensures j == 2 * x", "vc-code": "{\n    i := 0;\n    j := 0;\n\n    while i < x\n        invariant 0 <= i <= x\n        invariant j == 2 * i\n    {\n        j := j + 2;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0224", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n    requires k > n;\n    ensures k_out >= 0;", "vc-code": "{\n    k_out := k;\n    var j: int := 0;\n    while(j < n)\n        invariant 0 <= j <= n;\n        invariant k_out == k - j;\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0227", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Minimum_Minimum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Minimum(a: array<int>) returns (m: int) \n    requires a.Length > 0\n    ensures exists i :: 0 <= i < a.Length && m == a[i]\n    ensures forall i :: 0 <= i < a.Length ==> m <= a[i]", "vc-code": "{\n    var n := 0;\n    m := a[0];\n    while n != a.Length\n        invariant 0 <= n <= a.Length\n        invariant exists i :: 0 <= i < a.Length && m == a[i]\n        invariant forall i :: 0 <= i < n ==> m <= a[i]\n    {\n        if a[n] < m {\n            m := a[n];\n        }\n        n := n + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0228", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult_mult", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mult(a:int, b:int) returns (x:int)\n    requires a >= 0 && b >= 0\n    ensures x == a * b", "vc-code": "{\n    x := 0;\n    var y := a;\n    while y > 0\n        invariant x == (a - y) * b\n    {\n        x := x + b;\n        y := y - 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0229", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_01_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main() returns (t1: int, t2: int, x: int, y: int)\nensures y >= 1", "vc-code": "{\n    x := 1;\n    y := 1;\n    t1 := 0;\n    t2 := 0;\n\n    while(x <= 100000) \n        invariant x == y;\n    {\n        t1 := x;\n        t2 := y;\n        x := t1 + t2;\n        y := t1 + t2;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0230", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_07_main", "vc-description": "", "vc-preamble": "// MODULE main\n//  int i;\n//  int n;\n//  int a;\n//  int b;\n\n//  assume(i == 0);\n//  assume(a == 0);\n//  assume(b == 0);\n//  assume(n >= 0);\n\n//  while(i < n){\n//      if(*) {\n//          a = a+1;\n//          b = b+2;\n//      } \n//      else {\n//                  a = a+2;\n//                  b = b+1;\n//          }\n\n//      i = i+1;\n//  }\n\n//  assert(a + b == 3 * n); \n\n// END MODULE\n\n// (let ((.def_201 (<= (+ (* 3 n) (+ (* (- 1) a) (* (- 1) b))) (- 1)))) (let ((.def_392 (<= (+ (* 3 i) (+ (* (- 1) a) (* (- 1) b))) (- 1)))) (not (or (<= 1 (+ (* 3 i) (+ (* (- 1) a) (* (- 1) b)))) (and (or .def_201 .def_392) (or .def_392 (and .def_201 (<= (+ (* 3 i) (+ (* (- 1) a) (* (- 1) b))) 0))))))))", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int) returns (a: int, b: int)\n    requires n >= 0\n    ensures a + b == 3 * n", "vc-code": "{\n    var i: int := 0;\n    a := 0;\n    b := 0;\n\n    while(i < n)\n        invariant 0 <= i <= n\n        invariant a + b == 3 * i\n    {\n        if(*)\n        {\n            a := a + 1;\n            b := b + 2;\n        }\n        else\n        {\n            a := a + 2;\n            b := b + 1;\n        }\n\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0231", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_11_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(x :int) returns (j :int, i :int)\nrequires x > 0\nensures j == 2 * x", "vc-code": "{\n    i := 0;\n    j := 0;\n\n    while i < x\n        invariant 0 <= i <= x\n        invariant j == 2 * i\n    {\n        j := j + 2;\n        i := i + 1;\n    }\n}", "vc-postamble": "// MODULE main\n//  int i;\n//  int j;\n//  int x;\n\n//  assume(j == 0);\n//  assume(x > 0);\n//  assume(i == 0);\n\n//  while(i < x){\n//      j = j + 2;\n\n//      i = i + 1;\n//  }\n\n//  assert(j == 2*x);   \n\n// END MODULE\n\n\n// (and (not (<= (+ (* 2 i) (* (- 1) j)) (- 1))) (and (not (<= 1 (+ j (* (- 2) x)))) (not (<= 1 (+ (* 2 i) (* (- 1) j))))))\n\n\n// (and \n// (not (<= (+ (* 2 i) (* (- 1) j)) (- 1)))\n// (not (<= 1 (+ j (* (- 2) x)))) \n// (not (<= 1 (+ (* 2 i) (* (- 1) j))))\n\n// (\n    // and (not (<= (+ (* 2 i) (* (- 1) j)) (- 1))) (\n    //     and (not (<= 1 (+ j (* (- 2) x)))) (not (<= 1 (+ (* 2 i) (* (- 1) j))))))", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0232", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n    requires k > n;\n    ensures k_out >= 0;", "vc-code": "{\n    k_out := k;\n    var j: int := 0;\n    while(j < n)\n        invariant 0 <= j <= n;\n        invariant j + k_out == k;\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}", "vc-postamble": "// C code:\n// MODULE main\n//  int i;\n//  int n;\n//  int j;\n//  int k;\n\n//  assume(n > 0);\n//  assume(k > n);\n//  assume(j == 0);\n\n//  while(j < n){\n//      j = j + 1;\n//      k = k - 1;\n//  }\n\n//  assert(k >= 0); \n\n// END MODULE\n\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0233", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_23_x_main", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method main(n: int) returns (sum: int, i: int)\nrequires n >= 0", "vc-code": "{\n    sum := 0;\n    i := 0;\n    while(i < n)\n        invariant sum >= 0\n        invariant 0 <= i <= n\n    {\n        sum := sum + i;\n        i := i + 1;\n    }\n}", "vc-postamble": "// MODULE main\n//  int i;\n//  int sum;\n//  int n;\n\n//  assume(sum == 0);\n//  assume(n >= 0);\n//  assume(i == 0);\n\n//  while(i < n){\n//      sum = sum + i;\n//      i = i + 1;\n//  }\n\n//  assert(sum >= 0);   \n\n// END MODULE", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0234", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Min_min", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method min(a: array<int>, n : int) returns (min : int)\n    requires 0 < n <= a.Length;\n    ensures (exists i : int :: 0 <= i && i < n && a[i] == min);\n    ensures (forall i : int :: 0 <= i && i < n ==> a[i] >= min);", "vc-code": "{\n    var i : int;\n\n    min := a[0];\n    i := 1;\n\n    while (i < n)\n        invariant i <= n;\n        invariant (exists j : int :: 0 <= j && j < i && a[j] == min);\n        invariant (forall j : int :: 0 <= j && j < i ==> a[j] >= min);\n    {\n        if (a[i] < min) {\n            min := a[i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0236", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_bql_exampls_Square_square", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method square (n: int) returns (r: int)\n    requires 0 <= n;\n    ensures r == n*n;", "vc-code": "{\n    var x: int;\n    var i: int;\n\n    r := 0;\n    i := 0;\n    x := 1;\n\n    while (i < n)\n        invariant i <= n;\n        invariant r == i*i;\n        invariant x == 2*i + 1;\n    {\n        r := r + x;\n        x := x + 2;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0238", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_Verify_tmp_tmphq7j0row_dataset_error_data_real_error_IsEven_success_1_is_even", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "function even(n: int): bool\n  requires n >= 0", "vc-code": "{\n  if n == 0 then true else !even(n-1)\n}", "vc-postamble": "method is_even(n: int) returns (r: bool)\n  requires n >= 0;\n  ensures r <==> even(n);\n{\n  var i: int := 0;\n  r := true;\n\n  while i < n\n    invariant 0 <= i <= n;\n    invariant r <==> even(i);\n  {\n    r := !r;\n    i := i + 1;\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0241", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_2_BinarySearchDec_SearchLoop", "vc-description": "", "vc-preamble": "// Author of question: Snorri Agnarsson\n// Permalink of question: https://rise4fun.com/Dafny/CGB1z\n\n// Authors of solution:   Alexander Guðmundsson\n// Permalink of solution: https://rise4fun.com/Dafny/VnB5\n\n// Use the command\n//   dafny H2-skeleton.dfy\n// or\n//   compile H2-skeleton.dfy\n// to compile the file.\n// Or use the web page rise4fun.com/dafny.\n\n// When you have solved the problem put\n// the solution on the Dafny web page,\n// generate a permalink and put it in\n// this file.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SearchLoop( a: seq<real>, i: int, j: int, x: real ) returns ( k: int )\n    requires 0 <= i <= j <= |a|;\n    requires forall p, q :: i <= p < q < j ==> a[p] >= a[q];\n    ensures i <= k <= j;\n    ensures forall r | i <= r < k :: a[r] >= x;\n    ensures forall r | k <= r < j :: a[r] < x;", "vc-code": "{\n    if i == j\n    {\n        return i;\n    }\n    var p := i;\n    var q := j;\n    while p != q\n        decreases q-p;\n        invariant i <= p <= q <= j;\n        invariant forall r | i <= r < p :: a[r] >= x;\n        invariant forall r | q <= r < j :: a[r] < x;\n    {\n        var m := p + (q-p)/2;\n        if a[m] < x\n        {\n            q := m;\n        }\n        else\n        {\n            p := m+1;\n        }\n    }\n    return p;\n}", "vc-postamble": "// Ef eftirfarandi fall er ekki samþykkt þá eru\n// föllin ekki að haga sér rétt að mati Dafny.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0245", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_3_SelectionSortMultiset_MinOfMultiset", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/dtcnY\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/ybUCz\n\n///////////////////////////////////////////////////////////////\n// Hér byrjar óbreytanlegi hluti skrárinnar.\n// Fyrir aftan þann hluta er sá hluti sem þið eigið að breyta.\n///////////////////////////////////////////////////////////////\n\n// Hjálparfall sem finnur minnsta gildi í poka", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MinOfMultiset( m: multiset<int> ) returns( min: int )\n    requires m != multiset{};\n    ensures min in m;\n    ensures forall z | z in m :: min <= z;", "vc-code": "{\n    min :| min in m;\n    var done := multiset{min};\n    var m' := m-done;\n    while m' != multiset{}\n        decreases m';\n        invariant m == done+m';\n        invariant min in done;\n        invariant forall z | z in done :: min <= z;\n    {\n        var z :| z in m';\n        done := done+multiset{z};\n        m' := m'-multiset{z};\n        if z < min { min := z; }\n    }\n}", "vc-postamble": "// Ekki má breyta þessu falli.\n\n\n///////////////////////////////////////////////////////////////\n// Hér lýkur óbreytanlega hluta skrárinnar.\n// Hér fyrir aftan er sá hluti sem þið eigið að breyta til að\n// útfæra afbrigði af selection sort.\n///////////////////////////////////////////////////////////////\n\n// Selection sort sem raðar poka í runu.\n// Klárið að forrita þetta fall.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0248", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni_8_H8_QuickSelect", "vc-description": "", "vc-preamble": "// Höfundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/GW7a\n\n// Höfundur lausnar:     Alexander Guðmundsson\n// Permalink lausnar:    https://www.rise4fun.com/Dafny/JPGct\n\n// Klárið að forrita föllin tvö.\n\n\nmethod Partition(m: multiset<int>) returns( pre: multiset<int>, p: int, post: multiset<int> )\n    requires |m| > 0;\n    ensures p in m;\n    ensures m == pre+multiset{p}+post;\n     ensures forall z | z in pre :: z <= p;\n     ensures forall z | z in post :: z >= p;\n{\n    p :| p in m;\n    var m' := m;\n    m' := m' - multiset{p};\n    pre := multiset{};\n    post := multiset{};\n    while m' != multiset{}\n        decreases m';\n        invariant m == m' + pre + multiset{p} + post;\n        invariant forall k | k in pre :: k <= p;\n        invariant forall k | k in post :: k >= p;\n\n    {\n        var temp :| temp in m';\n        m' := m' - multiset{temp};\n        if temp <= p\n        {\n            pre := pre + multiset{temp};\n        }\n        else\n        {\n            post := post + multiset{temp};\n        }\n    }\n    return pre,p,post;\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method QuickSelect( m: multiset<int>, k: int )\n        returns( pre: multiset<int>, kth: int, post: multiset<int> )\n    decreases m;\n    requires 0 <= k < |m|;\n    // ensures kth in m;\n    ensures m == pre+multiset{kth}+post;\n    // ensures |pre| == k;\n    // ensures forall z | z in pre :: z <= kth;\n    // ensures forall z | z in post :: z >= kth;", "vc-code": "{\n    pre,kth,post := Partition(m);\n    assert m == pre + multiset{kth} + post;\n    if |pre| != k\n    {\n        if k > |pre|\n        {\n\n            var pre',p,post' := QuickSelect(post,k-|pre| - 1);\n            assert pre' + multiset{p} + post' == post;\n            pre := pre + multiset{kth} + pre';\n            post := post - pre' - multiset{p};\n            kth := p;\n\n        }\n        else if k < |pre|\n        {\n            var pre',p,post' := QuickSelect(pre,k);\n            pre := pre - multiset{p} - post';\n            post := post + multiset{kth} + post';\n            kth := p;\n\n        }\n    }\n    else{\n        return pre,kth,post;\n    } \n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0249", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmp0wu8wmfr_tests_F1a_F", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method F() returns ( r: int)\n    ensures r <= 0", "vc-code": "{\n    r := 0;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0258", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpj88zq5zt_2-Kontrakte_reverse3_testSwap3", "vc-description": "", "vc-preamble": "method swap3(a: array<int>, h: int, i: int, j: int)\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;\n  ensures a[h] == old(a[i]);\n  ensures a[j] == old(a[h]);\n  ensures a[i] == old(a[j]);\n  ensures forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]); \n{\n    var tmp := a[h];\n    a[h] := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method testSwap3(a: array<int>, h: int, i: int, j:int )\n  modifies a\n  requires 0 <= h < a.Length\n  requires 0 <= i < a.Length\n  requires 0 <= j < a.Length\n  requires i != j && j != h && h != i;", "vc-code": "{\n  swap3(a, h, i, j);\n  assert a[h] == old(a[i]);\n  assert a[j] == old(a[h]);\n  assert a[i] == old(a[j]);\n  assert forall k: int :: 0 <= k < a.Length && k != h && k != i && k != j ==> a[k] == old(a[k]); \n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0259", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpmvs2dmry_examples1_Abs", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x:int) returns (y:int)\nensures y>=0;\nensures x>=0 ==> x == y;\nensures x<0 ==> -x == y;\nensures y == abs(x); // use this instead of line 3,4", "vc-code": "{\n    if(x<0)\n    {\n        return -x;\n    }\n    else{\n    return x;\n    }\n}", "vc-postamble": "function abs(x: int): int{\n    if x>0 then x else -x\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0260", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpmvs2dmry_examples1_Max", "vc-description": "", "vc-preamble": "function abs(x: int): int{\n    if x>0 then x else -x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(x:int, y:int) returns (a:int)\nensures a == x || a == y;\nensures x > y ==> a == x;\nensures x <= y ==> a == y;", "vc-code": "{\n    if ( x > y ) \n    { \n        a := x;\n    } else \n    { \n        a := y; \n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0261", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpmvs2dmry_examples1_MultiReturn", "vc-description": "", "vc-preamble": "function abs(x: int): int{\n    if x>0 then x else -x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MultiReturn(x:int, y:int) returns (more:int, less:int)\nrequires y>=0;\nensures less <= x <= more;", "vc-code": "{\n    more := x + y;\n    less := x - y;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0263", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpmvs2dmry_examples2_add_by_inc", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method add_by_inc(x: nat, y:nat) returns (z:nat)\nensures z == x+y;", "vc-code": "{\n    z := x;\n    var i := 0;\n    while (i < y) \n    decreases y-i;\n    invariant 0 <= i <= y;\n    invariant z == x + i;\n    {\n        z := z+1;\n        i := i+1; \n    }\n    assert (z == x+y);\n    assert (i == y);\n}", "vc-postamble": "function gcd(m: nat, n: nat) : nat\nrequires m>0 && n>0;\ndecreases m+n\n{\n    if(m==n) then n \n    else if( m > n) then gcd(m-n,n)\n    else gcd(m, n-m)\n}\n\n\nfunction exp(x: real, n: nat) :real\ndecreases n;\n{\n    if(n == 0) then 1.0\n    else if (x==0.0) then 0.0\n    else if (n  ==0 && x == 0.0) then 1.0\n    else x*exp(x, n-1)\n}\n\n// method add_by_inc_vc(x: int, y:int) returns (z:int)\n// {\n//     assume x>=0 && y>=0;\n//     z := x;\n//     var i := 0;\n//     assert 0 <= i <= y && z == x + i;\n//     z,i = *,*;\n//     assume 0 <= i <= y && z == x + i;\n//     if (i < y) \n//     {\n//         ghost var rank0 := y-i\n//         z := z+1;\n//         i := i+1; \n//         assert(y-i < rank0)\n//         ghost var rank1 := y-i\n//         assert(rank1 < rank0)\n//         assert(rank1 >=0)\n//         assert 0 <= i <= y && z == x + i;\n//         assume(false);\n//     }\n//     assert (z == x+y);\n//     assert (i == y);\n//     return z;\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0269", "language": "dafny", "source": "dafnybench", "source_id": "Dafny_tmp_tmpv_d3qi10_2_min_minMethod", "vc-description": "", "vc-preamble": "function min(a: int, b: int): int\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a || min(a, b) == b\n{\n    if a < b then a else b\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method minMethod(a: int, b: int) returns (c: int)\n    ensures c <= a && c <= b\n    ensures c == a || c == b\n    // Ou encore:\n    ensures c == min(a, b)", "vc-code": "{\n    if a < b {\n        c := a;\n    } else {\n        c := b;\n    }\n}", "vc-postamble": "ghost function minFunction(a: int, b: int): int\n    ensures minFunction(a, b) <= a && minFunction(a, b) <= b\n    ensures minFunction(a, b) == a || minFunction(a, b) == b\n{\n    if a < b then a else b\n}\n\n\n// Return a minimum of a.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0272", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max_findMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;", "vc-code": "{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\n    invariant 1 <= j <= a.Length;\n    invariant forall i :: 0 <= i < j ==> a[i] <= maxVal;\n    invariant exists i :: 0 <= i < j && a[i] == maxVal;\n    invariant 0 <= pos < a.Length;\n    invariant a[pos] == maxVal;\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0273", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise6_Binary_Search_binarySearch", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method binarySearch(a:array<int>, val:int) returns (pos:int)\n  requires a.Length > 0\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n\n  ensures 0 <= pos < a.Length ==> a[pos] == val\n  ensures pos < 0 || pos >= a.Length  ==> forall i :: 0 <= i < a.Length ==> a[i] != val", "vc-code": "{\n  var left := 0;\n  var right := a.Length;\n  if a[left] > val || a[right-1] < val \n  {\n    return -1;\n  }\n  while left < right\n\n    invariant 0 <= left <= right <= a.Length\n    invariant forall i :: 0 <= i < a.Length && !(left <= i < right) ==> a[i] != val\n\n    decreases right - left\n  {\n    var med := (left + right) / 2;\n    assert left <= med <= right;\n    if a[med] < val\n    {\n      left := med + 1;\n    }\n    else if a[med] > val\n    {\n      right := med;\n    }\n    else\n    {\n      assert a[med] == val;\n      pos := med;\n      return;\n    }\n\n  }\n  return -1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0277", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Merge_Sort_mergeSort", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mergeSort(a: array<int>)\nmodifies a", "vc-code": "{\n  sorting(a, 0, a.Length-1);\n}", "vc-postamble": "method merging(a: array<int>, low: int, medium: int, high: int)\nrequires 0 <= low <= medium <= high < a.Length\nmodifies a\n{\n  var x := 0;\n  var y := 0;\n  var z := 0;\n  var a1: array<int> := new [medium - low + 1];\n  var a2: array<int> := new [high - medium];\n  // The first case\n  while(y < a1.Length && low+y < a.Length)\n  invariant 0 <= y <= a1.Length\n  invariant 0 <= low+y <= a.Length\n  decreases a1.Length-y\n  {\n    a1[y] := a[low+y];\n    y := y +1;\n  }\n  // The second case\n  while(z < a2.Length && medium+z+1 < a.Length)\n  invariant 0 <= z <= a2.Length\n  invariant 0 <= medium+z <= a.Length\n  decreases a2.Length-z\n  {\n    a2[z] := a[medium+z+1];\n    z := z +1;\n  }\n  y, z := 0, 0;\n  // The third case\n  while (x < high - low + 1 && y <= a1.Length && z <= a2.Length && low+x < a.Length)\n  invariant 0 <= x <= high - low + 1\n  decreases high-low-x\n  {\n    if(y >= a1.Length && z >= a2.Length) {\n      break;\n    } else if(y >= a1.Length) {\n      a[low+x] := a2[z];\n      z := z+1;\n    } else if(z >= a2.Length) {\n      a[low+x] := a1[y];\n      y := y+1;\n    } else {\n      if(a1[y] <= a2[z]) {\n        a[low+x] := a1[y];\n        y := y +1;\n      } else {\n        a[low+x] := a2[z];\n        z := z +1;\n      }\n    }\n    x := x+1;\n  }\n}\n\nmethod sorting(a: array<int>, low: int, high: int)\nrequires 0 <= low && high < a.Length\ndecreases high-low\nmodifies a\n{\n    if (low < high) {\n        var medium: int := low + (high - low)/2;\n        sorting(a, low, medium);\n        sorting(a, medium+1, high);\n        merging(a, low, medium, high);\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0278", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Merge_Sort_merging", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method merging(a: array<int>, low: int, medium: int, high: int)\nrequires 0 <= low <= medium <= high < a.Length\nmodifies a", "vc-code": "{\n  var x := 0;\n  var y := 0;\n  var z := 0;\n  var a1: array<int> := new [medium - low + 1];\n  var a2: array<int> := new [high - medium];\n  // The first case\n  while(y < a1.Length && low+y < a.Length)\n  invariant 0 <= y <= a1.Length\n  invariant 0 <= low+y <= a.Length\n  decreases a1.Length-y\n  {\n    a1[y] := a[low+y];\n    y := y +1;\n  }\n  // The second case\n  while(z < a2.Length && medium+z+1 < a.Length)\n  invariant 0 <= z <= a2.Length\n  invariant 0 <= medium+z <= a.Length\n  decreases a2.Length-z\n  {\n    a2[z] := a[medium+z+1];\n    z := z +1;\n  }\n  y, z := 0, 0;\n  // The third case\n  while (x < high - low + 1 && y <= a1.Length && z <= a2.Length && low+x < a.Length)\n  invariant 0 <= x <= high - low + 1\n  decreases high-low-x\n  {\n    if(y >= a1.Length && z >= a2.Length) {\n      break;\n    } else if(y >= a1.Length) {\n      a[low+x] := a2[z];\n      z := z+1;\n    } else if(z >= a2.Length) {\n      a[low+x] := a1[y];\n      y := y+1;\n    } else {\n      if(a1[y] <= a2[z]) {\n        a[low+x] := a1[y];\n        y := y +1;\n      } else {\n        a[low+x] := a2[z];\n        z := z +1;\n      }\n    }\n    x := x+1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0279", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Merge_Sort_sorting", "vc-description": "", "vc-preamble": "method merging(a: array<int>, low: int, medium: int, high: int)\nrequires 0 <= low <= medium <= high < a.Length\nmodifies a\n{\n  var x := 0;\n  var y := 0;\n  var z := 0;\n  var a1: array<int> := new [medium - low + 1];\n  var a2: array<int> := new [high - medium];\n  // The first case\n  while(y < a1.Length && low+y < a.Length)\n  invariant 0 <= y <= a1.Length\n  invariant 0 <= low+y <= a.Length\n  decreases a1.Length-y\n  {\n    a1[y] := a[low+y];\n    y := y +1;\n  }\n  // The second case\n  while(z < a2.Length && medium+z+1 < a.Length)\n  invariant 0 <= z <= a2.Length\n  invariant 0 <= medium+z <= a.Length\n  decreases a2.Length-z\n  {\n    a2[z] := a[medium+z+1];\n    z := z +1;\n  }\n  y, z := 0, 0;\n  // The third case\n  while (x < high - low + 1 && y <= a1.Length && z <= a2.Length && low+x < a.Length)\n  invariant 0 <= x <= high - low + 1\n  decreases high-low-x\n  {\n    if(y >= a1.Length && z >= a2.Length) {\n      break;\n    } else if(y >= a1.Length) {\n      a[low+x] := a2[z];\n      z := z+1;\n    } else if(z >= a2.Length) {\n      a[low+x] := a1[y];\n      y := y+1;\n    } else {\n      if(a1[y] <= a2[z]) {\n        a[low+x] := a1[y];\n        y := y +1;\n      } else {\n        a[low+x] := a2[z];\n        z := z +1;\n      }\n    }\n    x := x+1;\n  }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sorting(a: array<int>, low: int, high: int)\nrequires 0 <= low && high < a.Length\ndecreases high-low\nmodifies a", "vc-code": "{\n    if (low < high) {\n        var medium: int := low + (high - low)/2;\n        sorting(a, low, medium);\n        sorting(a, medium+1, high);\n        merging(a, low, medium, high);\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0283", "language": "dafny", "source": "dafnybench", "source_id": "Final-Project-Dafny_tmp_tmpmcywuqox_Final_Project_3_nonZeroReturn", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method nonZeroReturn(x: int) returns (y: int)\n  ensures y != 0", "vc-code": "{\n  if x == 0 {\n    return x + 1;\n  } else {\n    return -x;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0284", "language": "dafny", "source": "dafnybench", "source_id": "FlexWeek_tmp_tmpc_tfdj_3_ex2_aba", "vc-description": "", "vc-preamble": "// 2. Given an array of positive and negative integers, it returns an array of the absolute value of all the integers. [-4,1,5,-2,-5]->[4,1,5,2,5]\n\nfunction abs(a:int):nat\n{\n    if a < 0 then -a else a\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method aba(a:array<int>)returns (b:array<int>)\nensures a.Length == b.Length // needed for next line\nensures forall x :: 0<=x<b.Length ==> b[x] == abs(a[x])", "vc-code": "{\n    b := new int[a.Length];\n    var i:=0;\n\n    while(i < a.Length)\n    invariant 0<= i <= a.Length\n    invariant forall x :: 0<=x<i ==> b[x] == abs(a[x])\n    {\n\n        if(a[i] < 0){\n            b[i] := -a[i];\n        } else{\n            b[i] := a[i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0285", "language": "dafny", "source": "dafnybench", "source_id": "FlexWeek_tmp_tmpc_tfdj_3_ex3_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a:array<nat>)returns(m:int)\nensures a.Length > 0 ==> forall k :: 0<=k<a.Length ==> m >= a[k]// not strong enough\nensures a.Length == 0 ==> m == -1\nensures a.Length > 0 ==> m in a[..] // finally at the top // approach did not work for recusrive function", "vc-code": "{\n    if(a.Length == 0){\n        return -1;\n    }\n    assert a.Length > 0;\n    var i := 0;\n    m := a[0];\n    assert m in a[..]; // had to show that m is in a[..], otherwise how could i assert for it\n\n    while(i < a.Length)\n    invariant 0<=i<=a.Length\n    invariant forall k :: 0<=k<i ==> m >= a[k]// Not strong enough\n    invariant m in a[..] // again i  the array\n    // invariant 0 < i <= a.Length ==> (ret_max(a,i-1) == m)\n    {\n        if(a[i] >= m){\n            m:= a[i];\n        }\n        i := i+1;\n    }\n\n    assert m in a[..]; //\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0288", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Methods-Project_tmp_tmphh2ar2xv_BubbleSort_BubbleSort", "vc-description": "", "vc-preamble": "predicate sorted(a: array?<int>, l: int, u: int)\n  reads a;\n  requires a != null;\n  {\n    forall i, j :: 0 <= l <= i <= j <= u < a.Length ==> a[i] <= a[j]\n  }\npredicate partitioned(a: array?<int>, i: int)\n  reads a\n  requires a != null\n  {\n    forall k, k' :: 0 <= k <= i < k' < a.Length ==> a[k] <= a[k']\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BubbleSort(a: array?<int>)\n  modifies a\n  requires a != null", "vc-code": "{\n    var i := a.Length - 1;\n    while(i > 0)\n   invariant sorted(a, i, a.Length-1)\n   invariant partitioned(a, i)\n   {\n        var j := 0;\n        while (j < i)\n        invariant 0 < i < a.Length && 0 <= j <= i\n        invariant sorted(a, i, a.Length-1)\n        invariant partitioned(a, i)\n        invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n          {\n            if(a[j] > a[j+1])\n              {\n                a[j], a[j+1] := a[j+1], a[j];\n              }\n              j := j + 1;\n          }\n          i := i -1;\n      }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0289", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Methods-Project_tmp_tmphh2ar2xv_Factorial_Fact", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Fact(x: int) returns (y: int)\n  requires x >= 0;", "vc-code": "{\n    y := 1;\n    var z := 0;\n    while(z != x)\n     decreases x - z;\n     invariant 0 <= x-z;\n    {\n        z := z + 1;\n        y := y * z;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0291", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Verification-Project_tmp_tmp9gmwsmyp_strings3_isPrefix", "vc-description": "", "vc-preamble": "predicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nlemma PrefixNegationLemma(pre:string, str:string)\n    ensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n    ensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)", "vc-code": "{\n    if |str| < |pre| \n    {\n        return false;\n    }\n    else if pre[..] == str[..|pre|]\n    {\n        return true;\n    }\n    else{\n        return false;\n    }\n}", "vc-postamble": "predicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nlemma SubstringNegationLemma(sub:string, str:string)\n    ensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n    ensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\n\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n    ensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n    ensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}\n\n\nlemma haveCommon0SubstringLemma(str1:string, str2:string)\n    ensures  haveCommonKSubstringPred(0,str1,str2)\n{\n    assert isPrefixPred(str1[0..0], str2[0..]);\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0295", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_isPrefix", "vc-description": "", "vc-preamble": "predicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isPrefix(pre: string, str: string) returns (res: bool)\n  ensures |pre| > |str| ==> !res\n  ensures res == isPrefixPredicate(pre, str)", "vc-code": "{\n  if |pre| > |str|\n    {return false;}\n\n  var i := 0;\n  while i < |pre|\n    decreases |pre| - i\n    invariant 0 <= i <= |pre|\n    invariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n  {\n    if pre[i] != str[i]\n    {\n        return false;\n    } \n    i := i + 1;\n  }\n return true;\n}", "vc-postamble": "predicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}\n\n\npredicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\n\n\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0296", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings1_isSubstring", "vc-description": "", "vc-preamble": "predicate isPrefixPredicate(pre: string, str:string)\n{\n  |str| >= |pre| && pre <= str\n}\n\nmethod isPrefix(pre: string, str: string) returns (res: bool)\n  ensures |pre| > |str| ==> !res\n  ensures res == isPrefixPredicate(pre, str)\n{\n  if |pre| > |str|\n    {return false;}\n\n  var i := 0;\n  while i < |pre|\n    decreases |pre| - i\n    invariant 0 <= i <= |pre|\n    invariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n  {\n    if pre[i] != str[i]\n    {\n        return false;\n    } \n    i := i + 1;\n  }\n return true;\n}\n\npredicate isSubstringPredicate (sub: string, str:string)\n{\n  |str| >= |sub| && (exists i :: 0 <= i <= |str| && isPrefixPredicate(sub, str[i..]))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isSubstring(sub: string, str: string) returns (res:bool)\nensures res == isSubstringPredicate(sub, str)", "vc-code": "{\n    if |sub| > |str| {\n        return false;\n    }\n\n    var i := |str| - |sub|;\n    while i >= 0 \n    decreases i\n    invariant i >= -1\n    invariant forall j :: i <  j <= |str|-|sub| ==> !(isPrefixPredicate(sub, str[j..]))\n    {\n        var isPref := isPrefix(sub, str[i..]);\n        if isPref\n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}", "vc-postamble": "predicate haveCommonKSubstringPredicate(k: nat, str1: string, str2: string)\n{\n  |str1| >= k && |str2| >= k && (exists i :: 0 <= i <= |str1| - k && isSubstringPredicate((str1[i..])[..k], str2))\n}\n\n\n\n\npredicate maxCommonSubstringPredicate(str1: string, str2: string, len:nat)\n{\n   forall k :: len < k <= |str1| ==> !haveCommonKSubstringPredicate(k, str1, str2)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0299", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_isPrefix", "vc-description": "", "vc-preamble": "// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nlemma PrefixNegationLemma(pre:string, str:string)\n    ensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n    ensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)", "vc-code": "{\n    if |pre| > |str|\n        {return false;}\n\n    var i := 0;\n    while i < |pre|\n        decreases |pre| - i\n        invariant 0 <= i <= |pre|\n        invariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n    {\n        if pre[i] != str[i]\n        {\n            return false;\n        } \n        i := i + 1;\n    }\n    return true;\n}", "vc-postamble": "predicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nlemma SubstringNegationLemma(sub:string, str:string)\n    ensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n    ensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}\n\n\npredicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n    ensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n    ensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0300", "language": "dafny", "source": "dafnybench", "source_id": "Formal-Verification_tmp_tmpuyt21wjt_Dafny_strings3_isSubstring", "vc-description": "", "vc-preamble": "// We spent 2h each on this assignment\n\npredicate isPrefixPred(pre:string, str:string)\n{\n    (|pre| <= |str|) && \n    pre == str[..|pre|]\n}\n\npredicate isNotPrefixPred(pre:string, str:string)\n{\n    (|pre| > |str|) || \n    pre != str[..|pre|]\n}\n\nlemma PrefixNegationLemma(pre:string, str:string)\n    ensures  isPrefixPred(pre,str) <==> !isNotPrefixPred(pre,str)\n    ensures !isPrefixPred(pre,str) <==>  isNotPrefixPred(pre,str)\n{}\n\nmethod isPrefix(pre: string, str: string) returns (res:bool)\n    ensures !res <==> isNotPrefixPred(pre,str)\n    ensures  res <==> isPrefixPred(pre,str)\n{\n    if |pre| > |str|\n        {return false;}\n\n    var i := 0;\n    while i < |pre|\n        decreases |pre| - i\n        invariant 0 <= i <= |pre|\n        invariant forall j :: 0 <= j < i ==> pre[j] == str[j]\n    {\n        if pre[i] != str[i]\n        {\n            return false;\n        } \n        i := i + 1;\n    }\n    return true;\n}\npredicate isSubstringPred(sub:string, str:string)\n{\n    (exists i :: 0 <= i <= |str| &&  isPrefixPred(sub, str[i..]))\n}\n\npredicate isNotSubstringPred(sub:string, str:string)\n{\n    (forall i :: 0 <= i <= |str| ==> isNotPrefixPred(sub,str[i..]))\n}\n\nlemma SubstringNegationLemma(sub:string, str:string)\n    ensures  isSubstringPred(sub,str) <==> !isNotSubstringPred(sub,str)\n    ensures !isSubstringPred(sub,str) <==>  isNotSubstringPred(sub,str)\n{}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isSubstring(sub: string, str: string) returns (res:bool)\n    ensures  res <==> isSubstringPred(sub, str)\n    //ensures !res <==> isNotSubstringPred(sub, str) // This postcondition follows from the above lemma.", "vc-code": "{\n    if |sub| > |str| {\n        return false;\n    }\n\n    var i := |str| - |sub|;\n    while i >= 0 \n    decreases i\n    invariant i >= -1\n    invariant forall j :: i <  j <= |str|-|sub| ==> !(isPrefixPred(sub, str[j..]))\n    {\n        var isPref := isPrefix(sub, str[i..]);\n        if isPref\n        {\n            return true;\n        }\n        i := i-1;\n    }\n    return false;\n}", "vc-postamble": "predicate haveCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    exists i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k && isSubstringPred(str1[i1..j1],str2)\n}\n\npredicate haveNotCommonKSubstringPred(k:nat, str1:string, str2:string)\n{\n    forall i1, j1 :: 0 <= i1 <= |str1|- k && j1 == i1 + k ==>  isNotSubstringPred(str1[i1..j1],str2)\n}\n\nlemma commonKSubstringLemma(k:nat, str1:string, str2:string)\n    ensures  haveCommonKSubstringPred(k,str1,str2) <==> !haveNotCommonKSubstringPred(k,str1,str2)\n    ensures !haveCommonKSubstringPred(k,str1,str2) <==>  haveNotCommonKSubstringPred(k,str1,str2)\n{}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0302", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_ComputeFact", "vc-description": "", "vc-preamble": "function factorial(n: nat): nat\n{\n    if n == 0 then 1 else n * factorial(n-1)\n}\n\n\n\n// PROGRAMA VERIFICADOR DE WHILE", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFact (n:int) returns (f:int)\nrequires n >=0\nensures f== factorial(n)", "vc-code": "{\n    assert 0 <= n <= n && 1*factorial(n) == factorial(n);\n    f:=1;\n    assert 0 <= n <= n && f*factorial(n) == factorial(n);\n    var x:=n;\n    assert 0 <= x <= n && f*factorial(x) == factorial(n);\n    while x > 0 \n        invariant 0 <= x <= n;\n        invariant f*factorial(x)== factorial(n);\n        decreases x-0;\n    {\n        assert 0 <= x-1 <= n && (f*x)*factorial(x-1) == factorial(n);\n        f:= f*x;\n        assert 0 <= x-1 <= n && f*factorial(x-1) == factorial(n);\n        x:=x-1;\n        assert 0 <= x <= n && f*factorial(x) == factorial(n);\n    }\n    assert 0 <= x <= n && f*factorial(x) == factorial(n);\n}", "vc-postamble": "// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\nlemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0303", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_ComputeFact2", "vc-description": "", "vc-preamble": "function factorial(n: nat): nat\n{\n    if n == 0 then 1 else n * factorial(n-1)\n}\n\n\n\n// PROGRAMA VERIFICADOR DE WHILE", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFact2 (n:int) returns (f:int)\nrequires n >=0\nensures f== factorial(n)", "vc-code": "{\n    var x:= 0;\n    f:= 1;\n    while x<n\n        invariant 0<=x<=n;\n        invariant f==factorial(x);\n        decreases n - x;\n    {\n        x:=x+1;\n        f:= f*x;\n        assert 0<=x<=n && f==factorial(x);  \n    }\n}", "vc-postamble": "// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\nlemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0304", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_Sqare", "vc-description": "", "vc-preamble": "// PROGRAMA VERIFICADOR DE WHILE\n\n\n\n// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Sqare(a:int) returns (x:int)\nrequires a>=1\nensures x == a*a", "vc-code": "{\n    assert 1==1 && 1 <= 1 <= a;\n    var y:=1;\n    assert y*y==1 && 1 <= y <= a;\n    x:=1;\n    while y < a \n        invariant 1 <= y <= a;\n        invariant y*y==x;\n    {\n        assert (y+1)*(y+1)==x+ (2*(y+1)-1) && 1 <= (y+1) <= a;\n        y:= y+1;\n        assert y*y==x+ (2*y-1) && 1 <= y <= a;\n        x:= x+ (2*y-1);\n        assert y*y==x && 1 <= y <= a;\n    }\n    assert y*y==x && 1 <= y <= a;\n}", "vc-postamble": "function sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\nlemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0305", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_Sqare2", "vc-description": "", "vc-preamble": "// PROGRAMA VERIFICADOR DE WHILE\n\n\n\n// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\nlemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Sqare2(a:int) returns (x:int)\nrequires a>=1\nensures x == a*a", "vc-code": "{\n    assert 1 <= 1 <= a && 1==1*1;\n    var y:=1;\n    assert 1 <= y <= a && 1==y*y;\n    x:=1;\n    assert 1 <= y <= a && x==y*y;\n    while y < a \n        invariant 1 <= y <= a\n        invariant x==y*y\n        decreases a - y\n    {\n        assert 1 <= (y+1) <= a && (x+2*(y+1)-1)==(y+1)*(y+1);\n        y:= y+1;\n        assert 1 <= y <= a && (x+2*y-1)==y*y;\n        x:= x +2*y -1;\n        assert 1 <= y <= a && x==y*y;\n    }\n    assert 1 <= y <= a && x==y*y;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0306", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_multipleReturns", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method multipleReturns (x:int, y:int) returns (more:int, less:int)\nrequires y > 0\nensures less < x < more", "vc-code": "{\n    assume false;\n}", "vc-postamble": "function factorial(n:int):int\nrequires n>=0\n{\n    if n==0 || n==1 then 1 else n*factorial(n-1)\n}\n\n// PROGRAMA VERIFICADOR DE WHILE\n\n\n\n// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\nlemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0307", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_multipleReturns2", "vc-description": "", "vc-preamble": "// PROGRAMA VERIFICADOR DE WHILE\n\n\n\n// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method multipleReturns2 (x:int, y:int) returns (more:int, less:int)\nrequires y > 0\nensures more + less == 2*x", "vc-code": "{\n    assume false;\n}", "vc-postamble": "lemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0308", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_1_Lab3_multipleReturns3", "vc-description": "", "vc-preamble": "// PROGRAMA VERIFICADOR DE WHILE\n\n\n\n// n>=1 ==> 1 + 3 + 5 + ... + (2*n-1) = n*n\n\n\n\nfunction sumSerie(n:int):int\nrequires n >=1 \n{\n    if n==1 then 1 else sumSerie(n-1) + 2*n -1\n}\n\n// TODO: Hacer en casa", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method multipleReturns3 (x:int, y:int) returns (more:int, less:int)\nrequires y > 0\nensures more - less == 2*y", "vc-code": "{\n    assume false;\n}", "vc-postamble": "lemma Sqare_Lemma (n:int)\nrequires n>=1\nensures sumSerie(n) == n*n\n{\n    if n==1 {}\n    else{\n        Sqare_Lemma(n-1);\n        assert sumSerie(n-1) ==(n-1)*(n-1);\n\n        calc == {\n            sumSerie(n);\n            sumSerie(n-1) + 2*n -1;\n            {\n                Sqare_Lemma(n-1);\n                assert sumSerie(n-1) ==(n-1)*(n-1);\n            }\n            (n-1)*(n-1) + 2*n -1;\n            n*n-2*n+1 +2*n -1;\n            n*n;\n        }\n    assert sumSerie(n) == n*n;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0309", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_Cubes", "vc-description": "", "vc-preamble": "/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\nfunction sum(v: seq<int>): int \ndecreases v\n{\n    if v==[] then 0\n    else if |v|==1 then v[0]\n    else v[0]+sum(v[1..])\n}\n\n/*\n\n// Structural Induction on Sequences\nlemma left_sum_Lemma(r:seq<int>, k:int)\nrequires 0 <= k < |r|\nensures sum(r[..k]) + r[k] == sum(r[..k+1]);\n{\n    if |r|==1 || k==0{\n        assert sum(r[..0])+r[0]== sum(r[..1]);\n    }\n    else {\n        left_sum_Lemma(r[1..], k);\n        assert sum(r[1..][..k]) + r[k] == sum(r[1..][..k+1]);\n\n        calc {\n            sum(r[..k+1]);\n            sum(r[..k]) + [r[k]];\n        }\n    }\n}\n\n// MAXIMUM OF A SEQUENCE\n\n// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Cubes (n:int) returns (s:seq<int>)\nrequires n >= 0\nensures |s| == n\nensures forall i:int :: 0 <= i < n ==> s[i] == i*i*i", "vc-code": "{\ns := [];\nvar c, j, k, m := 0,0,1,6;\nwhile j < n\n    invariant  0 <= j ==|s| <= n\n    invariant forall i:int :: 0 <= i < j ==> s[i] == i*i*i\n    invariant c == j*j*j\n    invariant k == 3*j*j + 3*j + 1\n    invariant m == 6*j + 6\n    {\n    s := s+[c]; \n    //c := (j+1)*(j+1)*(j+1);\n    c := c + k;\n    k := k + 6*j + 6;\n    m := m + 6;\n    //assert m == 6*(j+1) + 6 == 6*j + 6 + 6;\n    assert k  == 3*(j+1)*(j+1) + 3*(j+1) + 1 \n                == 3*j*j + 9*j + 7\n                == 3*j*j + 3*j + 1 + (6*j + 6);\n    //assert c == (j+1)*(j+1)*(j+1) == j*j*j + 3*j*j + 3*j + 1;\n    j := j+1;\n    //assert m == 6*j + 6;\n    //assert k == 3*j*j + 3*j + 1;\n    //assert c == j*j*j;\n    }\n}", "vc-postamble": "// REVERSE OF A SEQUENCE\nfunction reverse<T> (s:seq<T>):seq<T> \n{\n    if s==[] then []\n    else reverse(s[1..])+[s[0]]\n}\n\nfunction seq2set<T> (s:seq<T>): set<T>\n{\n    if s==[] then {}\n    else {s[0]}+seq2set(s[1..])\n}\n\n\nlemma seq2setRev_Lemma<T> (s:seq<T>)\nensures seq2set(reverse(s)) == seq2set(s)\n{\n    if s==[]{}\n    else {\n        seq2setRev_Lemma(s[1..]);\n        assert seq2set(reverse(s[1..])) == seq2set(s[1..]);\n\n        calc {\n            seq2set(s);\n            seq2set([s[0]]+s[1..]);\n            {\n                concat_seq2set_Lemma([s[0]], s[1..]);\n                assert seq2set([s[0]]+s[1..]) == seq2set([s[0]]) + seq2set(s[1..]);\n            }\n            seq2set([s[0]]) + seq2set(s[1..]);\n            {\n                seq2setRev_Lemma(s[1..]);\n                assert seq2set(reverse(s[1..])) == seq2set(s[1..]);\n            }\n            seq2set([s[0]]) + seq2set(reverse(s[1..]));\n            seq2set(reverse(s[1..])) + seq2set([s[0]]); \n            {\n                concat_seq2set_Lemma(reverse(s[1..]), [s[0]]);\n            }\n            seq2set(reverse(s[1..]) + [s[0]]);\n            {\n                assert reverse([s[0]]+s[1..]) == reverse(s);\n                assert [s[0]]+s[1..] == s;\n                assert reverse(s[1..])+[s[0]] == reverse(s);\n            }\n            seq2set(reverse(s));\n        }\n    }\n}\n\n\nlemma concat_seq2set_Lemma<T>(s1:seq<T>,s2:seq<T>)\nensures seq2set(s1+s2) == seq2set(s1) + seq2set(s2)\n{\n    if s1==[]{\n        assert seq2set(s2) == seq2set([]) + seq2set(s2);\n        assert []==s1;\n        assert []+s2==s2;\n        assert s1+s2==s2;\n        assert seq2set(s1+s2)==seq2set(s2);\n    }\n    else {\n        concat_seq2set_Lemma(s1[1..], s2);\n        assert seq2set(s1[1..]+s2) == seq2set(s1[1..]) + seq2set(s2);\n\n        calc{\n            seq2set(s1) + seq2set(s2);\n            seq2set([s1[0]]+s1[1..]) + seq2set(s2);\n            seq2set([s1[0]]) + seq2set(s1[1..]) + seq2set(s2);\n            {\n                concat_seq2set_Lemma(s1[1..], s2);\n                assert seq2set(s1[1..]+s2) == seq2set(s1[1..]) + seq2set(s2);\n            }\n            seq2set([s1[0]]) + seq2set(s1[1..]+s2);\n            {\n                assert s1[1..]+s2 == (s1+s2)[1..];\n            }\n            seq2set([s1[0]]) + seq2set((s1+s2)[1..]);\n            {\n                // assert seq2set([s1[0]]) + seq2set((s1+s2)[1..]) == seq2set(s1+s2);\n                var ls:= s1+s2;\n                calc {\n                    seq2set([s1[0]]) + seq2set((s1+s2)[1..]);\n                    seq2set([ls[0]])+ seq2set(ls[1..]);\n                    seq2set([ls[0]]+ ls[1..]);\n                    seq2set(ls);\n                    seq2set(s1+s2);\n                }\n            }\n            seq2set(s1+s2);\n        }\n    }\n}\n\n\n// REVERSE IS ITS OWN INVERSE\n\nlemma Rev_Lemma<T(==)>(s:seq<T>)\n//ensures forall i :: 0 <= i < |s| ==> s[i] == reverse(s)[|s|-1-i]\n\nlemma ItsOwnInverse_Lemma<T> (s:seq<T>)\nensures s == reverse(reverse(s))\n{\n    if s==[]{}\n    else{\n        ItsOwnInverse_Lemma(s[1..]);\n        assert s[1..] == reverse(reverse(s[1..]));\n\n        calc {\n            reverse(reverse(s));\n            reverse(reverse(s[1..])+[s[0]]);\n            reverse(reverse([s[0]]+s[1..]));\n            {\n                assert reverse([s[0]]+ s[1..]) ==  reverse(s[1..]) + [s[0]];\n                assert reverse(reverse([s[0]]+ s[1..])) ==  reverse(reverse(s[1..]) + [s[0]]);\n            }\n            reverse(reverse(s[1..]) + [s[0]]);\n            {\n                // TODO: Demostrar este assume\n                assume reverse(reverse(s[1..]) + [s[0]]) == [s[0]] + reverse(reverse(s[1..]));\n            }\n            [s[0]] + reverse(reverse(s[1..]));\n            {\n                ItsOwnInverse_Lemma(s[1..]);\n                assert s[1..] == reverse(reverse(s[1..]));\n            }\n            [s[0]]+s[1..];\n            s;\n        }\n    }\n}\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\nfunction scalar_product (v1:seq<int>, v2:seq<int>):int\nrequires |v1| == |v2|\n{\n    if v1 == [] then 0 else v1[0]*v2[0] + scalar_product(v1[1..],v2[1..])\n}\n\n\nlemma scalar_product_Lemma (v1:seq<int>, v2:seq<int>)\nrequires |v1| == |v2| > 0\nensures scalar_product(v1,v2) == scalar_product(v1[..|v1|-1],v2[..|v2|-1]) + v1[|v1|-1] * v2[|v2|-1]\n{\n    // INDUCCION EN LA LONGITUD DE V1\n    if |v1| == 0 && |v2| == 0 {}\n    else if |v1| == 1 {}\n    else {\n        // Se crean estas variables para simplificar las operaciones\n        var v1r:= v1[1..];\n        var v2r:= v2[1..];\n        var t1:= |v1[1..]|-1;\n        var t2:= |v2[1..]|-1;\n\n        // Se realiza la induccion utilizando las variables\n        scalar_product_Lemma(v1r, v2r);\n        assert  scalar_product(v1r,v2r) == \n                scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2]; //HI\n\n        // Se demuestra que la propiedad se mantiene\n        calc{\n            scalar_product(v1,v2);\n            v1[0]*v2[0] + scalar_product(v1r, v2r);\n            v1[0]*v2[0] + scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2];\n            {\n                scalar_product_Lemma(v1r, v2r);\n                assert  scalar_product(v1r,v2r) == \n                        scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2]; //HI\n            }\n            v1[0]*v2[0] + scalar_product(v1r,v2r);\n            v1[0]*v2[0] + scalar_product(v1[1..],v2[1..]);\n            scalar_product(v1,v2);\n        }\n    }\n}\n\n// MULTISETS\n\nmethod multiplicity_examples<T> ()\n{\nvar m := multiset{2,4,6,2,1,3,1,7,1,5,4,7,8,1,6};\nassert m[7] == 2;\nassert m[1] == 4;\n\nassert forall m1: multiset<T>, m2 :: m1 == m2 <==> forall z:T :: m1[z] == m2[z];\n}\n\n// REVERSE HAS THE SAME MULTISET \n\nlemma seqMultiset_Lemma<T> (s:seq<T>)\nensures multiset(reverse(s)) == multiset(s)\n{\n    if s==[]{}\n    else {\n        seqMultiset_Lemma(s[1..]);\n        assert multiset(reverse(s[1..])) == multiset(s[1..]);\n\n        calc {\n            multiset(reverse(s));\n            multiset(reverse(s[1..]) + [s[0]]);\n            multiset(reverse(s[1..])) + multiset{[s[0]]};\n            multiset(s[1..]) + multiset{[s[0]]};\n            multiset(s);\n        }\n        assert multiset(reverse(s)) == multiset(s);\n    }\n}\n*/\nlemma empty_Lemma<T> (r:seq<T>)\nrequires  multiset(r) == multiset{} \nensures r == []\n{\n    if r != []  {\n        assert r[0] in multiset(r);\n    }\n}\n\nlemma elem_Lemma<T> (s:seq<T>,r:seq<T>)\nrequires s != [] && multiset(s) == multiset(r)\nensures exists i :: 0 <= i < |r| && r[i] == s[0] && multiset(s[1..]) == multiset(r[..i]+r[i+1..]);\n\n// SEQUENCES WITH EQUAL MULTISETS HAVE EQUAL SUMS\n\nlemma sumElems_Lemma(s:seq<int>, r:seq<int>)   \nrequires multiset(s) == multiset(r)\nensures sum(s) == sum(r)\n{\n    if s==[]{\n        empty_Lemma(r);\n    }\n    else {\n        // Con este lema demuestro que el elemento que le quito a s tambien se lo quito a r y de esta manera\n        // poder hacer la induccion\n        elem_Lemma(s,r);\n        var i :| 0 <= i < |r| && r[i] == s[0] && multiset(s[1..]) == multiset(r[..i]+r[i+1..]);\n        sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n        assert sum(s[1..]) == sum(r[..i]+r[i+1..]); //HI\n\n        // Hago la llamada recursiva\n        sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n        assert sum(s[1..]) == sum(r[..i]+r[i+1..]);\n\n        calc {\n            sum(s);\n            s[0]+sum(s[1..]);\n            {\n                sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n                assert sum(s[1..]) == sum(r[..i]+r[i+1..]);\n            }\n            s[0]+sum(r[..i]+r[i+1..]);\n            {\n                assert s[0] == r[i];\n            }\n            r[i]+sum(r[..i]+r[i+1..]);\n            {\n                // TODO: No consigo acertarlo\n                assume r[i]+sum(r[..i]+r[i+1..]) == sum([r[i]]+r[..i] + r[i+1..]) == sum(r);\n            }\n            sum(r);\n        }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0310", "language": "dafny", "source": "dafnybench", "source_id": "Formal-methods-of-software-development_tmp_tmppryvbyty_Bloque_2_Lab6_maxSeq", "vc-description": "", "vc-preamble": "/*predicate palindrome<T(==)> (s:seq<T>)\n{\n    forall i:: 0<=i<|s| ==> s[i] == s[|s|-i-1]\n}\n*/\n// SUM OF A SEQUENCE OF INTEGERS\nfunction sum(v: seq<int>): int \ndecreases v\n{\n    if v==[] then 0\n    else if |v|==1 then v[0]\n    else v[0]+sum(v[1..])\n}\n\n/*\n\n// Structural Induction on Sequences\nlemma left_sum_Lemma(r:seq<int>, k:int)\nrequires 0 <= k < |r|\nensures sum(r[..k]) + r[k] == sum(r[..k+1]);\n{\n    if |r|==1 || k==0{\n        assert sum(r[..0])+r[0]== sum(r[..1]);\n    }\n    else {\n        left_sum_Lemma(r[1..], k);\n        assert sum(r[1..][..k]) + r[k] == sum(r[1..][..k+1]);\n\n        calc {\n            sum(r[..k+1]);\n            sum(r[..k]) + [r[k]];\n        }\n    }\n}\n\n// MAXIMUM OF A SEQUENCE", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method maxSeq(v: seq<int>) returns (max:int)\nrequires |v| >= 1\nensures forall i :: 0 <= i < |v| ==> max >= v[i]\nensures max in v", "vc-code": "{\n    max := v[0];\n    var v' := v[1..];\n    ghost var t := [v[0]];\n    while |v'| >= 1\n        invariant forall i :: 0 <= i < |t| ==> max >= t[i]\n        invariant v == t + v'\n        invariant max in t\n        decreases |v'| - 1\n    {\n        if v'[0] > max { max := v'[0]; }\n        v', t := v'[1..], t + [v'[0]];\n    }\n}", "vc-postamble": "// TODO: Hacer\n// Derivar formalmente un calculo incremental de j*j*j\n\n\n// REVERSE OF A SEQUENCE\nfunction reverse<T> (s:seq<T>):seq<T> \n{\n    if s==[] then []\n    else reverse(s[1..])+[s[0]]\n}\n\nfunction seq2set<T> (s:seq<T>): set<T>\n{\n    if s==[] then {}\n    else {s[0]}+seq2set(s[1..])\n}\n\n\nlemma seq2setRev_Lemma<T> (s:seq<T>)\nensures seq2set(reverse(s)) == seq2set(s)\n{\n    if s==[]{}\n    else {\n        seq2setRev_Lemma(s[1..]);\n        assert seq2set(reverse(s[1..])) == seq2set(s[1..]);\n\n        calc {\n            seq2set(s);\n            seq2set([s[0]]+s[1..]);\n            {\n                concat_seq2set_Lemma([s[0]], s[1..]);\n                assert seq2set([s[0]]+s[1..]) == seq2set([s[0]]) + seq2set(s[1..]);\n            }\n            seq2set([s[0]]) + seq2set(s[1..]);\n            {\n                seq2setRev_Lemma(s[1..]);\n                assert seq2set(reverse(s[1..])) == seq2set(s[1..]);\n            }\n            seq2set([s[0]]) + seq2set(reverse(s[1..]));\n            seq2set(reverse(s[1..])) + seq2set([s[0]]); \n            {\n                concat_seq2set_Lemma(reverse(s[1..]), [s[0]]);\n            }\n            seq2set(reverse(s[1..]) + [s[0]]);\n            {\n                assert reverse([s[0]]+s[1..]) == reverse(s);\n                assert [s[0]]+s[1..] == s;\n                assert reverse(s[1..])+[s[0]] == reverse(s);\n            }\n            seq2set(reverse(s));\n        }\n    }\n}\n\n\nlemma concat_seq2set_Lemma<T>(s1:seq<T>,s2:seq<T>)\nensures seq2set(s1+s2) == seq2set(s1) + seq2set(s2)\n{\n    if s1==[]{\n        assert seq2set(s2) == seq2set([]) + seq2set(s2);\n        assert []==s1;\n        assert []+s2==s2;\n        assert s1+s2==s2;\n        assert seq2set(s1+s2)==seq2set(s2);\n    }\n    else {\n        concat_seq2set_Lemma(s1[1..], s2);\n        assert seq2set(s1[1..]+s2) == seq2set(s1[1..]) + seq2set(s2);\n\n        calc{\n            seq2set(s1) + seq2set(s2);\n            seq2set([s1[0]]+s1[1..]) + seq2set(s2);\n            seq2set([s1[0]]) + seq2set(s1[1..]) + seq2set(s2);\n            {\n                concat_seq2set_Lemma(s1[1..], s2);\n                assert seq2set(s1[1..]+s2) == seq2set(s1[1..]) + seq2set(s2);\n            }\n            seq2set([s1[0]]) + seq2set(s1[1..]+s2);\n            {\n                assert s1[1..]+s2 == (s1+s2)[1..];\n            }\n            seq2set([s1[0]]) + seq2set((s1+s2)[1..]);\n            {\n                // assert seq2set([s1[0]]) + seq2set((s1+s2)[1..]) == seq2set(s1+s2);\n                var ls:= s1+s2;\n                calc {\n                    seq2set([s1[0]]) + seq2set((s1+s2)[1..]);\n                    seq2set([ls[0]])+ seq2set(ls[1..]);\n                    seq2set([ls[0]]+ ls[1..]);\n                    seq2set(ls);\n                    seq2set(s1+s2);\n                }\n            }\n            seq2set(s1+s2);\n        }\n    }\n}\n\n\n// REVERSE IS ITS OWN INVERSE\n\nlemma Rev_Lemma<T(==)>(s:seq<T>)\n//ensures forall i :: 0 <= i < |s| ==> s[i] == reverse(s)[|s|-1-i]\n\nlemma ItsOwnInverse_Lemma<T> (s:seq<T>)\nensures s == reverse(reverse(s))\n{\n    if s==[]{}\n    else{\n        ItsOwnInverse_Lemma(s[1..]);\n        assert s[1..] == reverse(reverse(s[1..]));\n\n        calc {\n            reverse(reverse(s));\n            reverse(reverse(s[1..])+[s[0]]);\n            reverse(reverse([s[0]]+s[1..]));\n            {\n                assert reverse([s[0]]+ s[1..]) ==  reverse(s[1..]) + [s[0]];\n                assert reverse(reverse([s[0]]+ s[1..])) ==  reverse(reverse(s[1..]) + [s[0]]);\n            }\n            reverse(reverse(s[1..]) + [s[0]]);\n            {\n                // TODO: Demostrar este assume\n                assume reverse(reverse(s[1..]) + [s[0]]) == [s[0]] + reverse(reverse(s[1..]));\n            }\n            [s[0]] + reverse(reverse(s[1..]));\n            {\n                ItsOwnInverse_Lemma(s[1..]);\n                assert s[1..] == reverse(reverse(s[1..]));\n            }\n            [s[0]]+s[1..];\n            s;\n        }\n    }\n}\n\n// SCALAR PRODUCT OF TWO VECTORS OF INTEGER\nfunction scalar_product (v1:seq<int>, v2:seq<int>):int\nrequires |v1| == |v2|\n{\n    if v1 == [] then 0 else v1[0]*v2[0] + scalar_product(v1[1..],v2[1..])\n}\n\n\nlemma scalar_product_Lemma (v1:seq<int>, v2:seq<int>)\nrequires |v1| == |v2| > 0\nensures scalar_product(v1,v2) == scalar_product(v1[..|v1|-1],v2[..|v2|-1]) + v1[|v1|-1] * v2[|v2|-1]\n{\n    // INDUCCION EN LA LONGITUD DE V1\n    if |v1| == 0 && |v2| == 0 {}\n    else if |v1| == 1 {}\n    else {\n        // Se crean estas variables para simplificar las operaciones\n        var v1r:= v1[1..];\n        var v2r:= v2[1..];\n        var t1:= |v1[1..]|-1;\n        var t2:= |v2[1..]|-1;\n\n        // Se realiza la induccion utilizando las variables\n        scalar_product_Lemma(v1r, v2r);\n        assert  scalar_product(v1r,v2r) == \n                scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2]; //HI\n\n        // Se demuestra que la propiedad se mantiene\n        calc{\n            scalar_product(v1,v2);\n            v1[0]*v2[0] + scalar_product(v1r, v2r);\n            v1[0]*v2[0] + scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2];\n            {\n                scalar_product_Lemma(v1r, v2r);\n                assert  scalar_product(v1r,v2r) == \n                        scalar_product(v1r[..t1],v2r[..t2]) + v1r[t1] * v2r[t2]; //HI\n            }\n            v1[0]*v2[0] + scalar_product(v1r,v2r);\n            v1[0]*v2[0] + scalar_product(v1[1..],v2[1..]);\n            scalar_product(v1,v2);\n        }\n    }\n}\n\n// MULTISETS\n\nmethod multiplicity_examples<T> ()\n{\nvar m := multiset{2,4,6,2,1,3,1,7,1,5,4,7,8,1,6};\nassert m[7] == 2;\nassert m[1] == 4;\n\nassert forall m1: multiset<T>, m2 :: m1 == m2 <==> forall z:T :: m1[z] == m2[z];\n}\n\n// REVERSE HAS THE SAME MULTISET \n\nlemma seqMultiset_Lemma<T> (s:seq<T>)\nensures multiset(reverse(s)) == multiset(s)\n{\n    if s==[]{}\n    else {\n        seqMultiset_Lemma(s[1..]);\n        assert multiset(reverse(s[1..])) == multiset(s[1..]);\n\n        calc {\n            multiset(reverse(s));\n            multiset(reverse(s[1..]) + [s[0]]);\n            multiset(reverse(s[1..])) + multiset{[s[0]]};\n            multiset(s[1..]) + multiset{[s[0]]};\n            multiset(s);\n        }\n        assert multiset(reverse(s)) == multiset(s);\n    }\n}\n*/\nlemma empty_Lemma<T> (r:seq<T>)\nrequires  multiset(r) == multiset{} \nensures r == []\n{\n    if r != []  {\n        assert r[0] in multiset(r);\n    }\n}\n\nlemma elem_Lemma<T> (s:seq<T>,r:seq<T>)\nrequires s != [] && multiset(s) == multiset(r)\nensures exists i :: 0 <= i < |r| && r[i] == s[0] && multiset(s[1..]) == multiset(r[..i]+r[i+1..]);\n\n// SEQUENCES WITH EQUAL MULTISETS HAVE EQUAL SUMS\n\nlemma sumElems_Lemma(s:seq<int>, r:seq<int>)   \nrequires multiset(s) == multiset(r)\nensures sum(s) == sum(r)\n{\n    if s==[]{\n        empty_Lemma(r);\n    }\n    else {\n        // Con este lema demuestro que el elemento que le quito a s tambien se lo quito a r y de esta manera\n        // poder hacer la induccion\n        elem_Lemma(s,r);\n        var i :| 0 <= i < |r| && r[i] == s[0] && multiset(s[1..]) == multiset(r[..i]+r[i+1..]);\n        sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n        assert sum(s[1..]) == sum(r[..i]+r[i+1..]); //HI\n\n        // Hago la llamada recursiva\n        sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n        assert sum(s[1..]) == sum(r[..i]+r[i+1..]);\n\n        calc {\n            sum(s);\n            s[0]+sum(s[1..]);\n            {\n                sumElems_Lemma(s[1..], r[..i]+r[i+1..]);\n                assert sum(s[1..]) == sum(r[..i]+r[i+1..]);\n            }\n            s[0]+sum(r[..i]+r[i+1..]);\n            {\n                assert s[0] == r[i];\n            }\n            r[i]+sum(r[..i]+r[i+1..]);\n            {\n                // TODO: No consigo acertarlo\n                assume r[i]+sum(r[..i]+r[i+1..]) == sum([r[i]]+r[..i] + r[i+1..]) == sum(r);\n            }\n            sum(r);\n        }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0312", "language": "dafny", "source": "dafnybench", "source_id": "FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex1_Mult", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y", "vc-code": "{\n    // Valores passados por parâmetros são imutáveis\n    var m := x;\n    var n := y;\n    r := 0;\n    // Soma sucessiva para multiplicar dois números.\n    while m > 0\n    invariant m*n+r == x*y\n    invariant m>=0\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r; // NOT(m>0) ^ Inv ==> r = x*y\n}", "vc-postamble": "/*\nInv = m*n + r = x*y\nMult(5,3)\nTeste de mesa\nx   y   m   n   r       Inv --> m*n + r = x*y\n5   3   5   3   0       5x3+0 = 5*3\n5   3   4   3   3       4x3+3 = 5*3\n5   3   3   3   6       3x3+6 = 5*3\n5   3   2   3   9       2x3+9 = 5*3\n5   3   1   3   12      1x3+12 = 5*3\n5   3   0   3   15      0x3+15 = 5*3\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0313", "language": "dafny", "source": "dafnybench", "source_id": "FormalMethods_tmp_tmpvda2r3_o_dafny_Invariants_ex2_Pot", "vc-description": "", "vc-preamble": "function Potencia(x:nat, y:nat):nat\n{\n    if y == 0\n    then 1\n    else x * Potencia(x, y-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Pot(x:nat, y:nat) returns (r:nat)\nensures r == Potencia(x,y)", "vc-code": "{\n    r := 1;\n    var b := x;\n    var e := y;\n    while e > 0\n    invariant Potencia(b,e) * r == Potencia(x,y)\n    {\n        r := r * b;\n        e := e - 1;\n    }\n\n    return r;\n}", "vc-postamble": "/*\nInv = \nPot(2,3)\nTeste de mesa\nx   y   b   e   r           Inv --> b^e * r = x^y\n2   3   2   3   1           2^3 * 2^0 = 2^3\n2   3   2   2   1*2         2^2 * 2^1 = 2^3\n2   3   2   1   1*2*2       2^1 * 2^2 = 2^3\n2   3   2   0   1*2*2*2     2^0 * 2^3 = 2^3\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0314", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_Counter_dec", "vc-description": "", "vc-preamble": "class Counter {\n\n  var value : int ;\n\n  constructor init() \n  ensures value == 0;\n  {\n    value := 0 ;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method dec()\n  modifies this`value\n  requires value > 0;\n  ensures value == old(value) - 1;", "vc-code": "{\n    value := value - 1 ;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0315", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_Counter_getValue", "vc-description": "", "vc-preamble": "class Counter {\n\n  var value : int ;\n\n  constructor init() \n  ensures value == 0;\n  {\n    value := 0 ;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method getValue() returns (x:int)\n  ensures x == value;", "vc-code": "{\n    x := value ;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0316", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_Counter_inc", "vc-description": "", "vc-preamble": "class Counter {\n\n  var value : int ;\n\n  constructor init() \n  ensures value == 0;\n  {\n    value := 0 ;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method inc()\n  modifies this`value\n  requires value >= 0;\n  ensures value == old(value) + 1;", "vc-code": "{\n    value := value + 1;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0317", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Init", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Init(c : int)\n      modifies this;\n      requires c > 0\n      ensures Valid() && Empty() && c == capacity\n      ensures fresh(arr); // ensures arr is a newly created object.\n      // Additional post-condition to be given here!", "vc-code": "{\n        capacity := c;\n        arr := new int[c];\n        top := -1;\n}", "vc-postamble": "// Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.\n\n\n\n\n\n      //Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0318", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Peek", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }\n\n\n\n\n\n\n\n      // Returns the top element of the stack, without removing it.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Peek() returns (elem : int) \n      requires Valid() && !Empty()\n      ensures elem == arr[top]", "vc-code": "{\n            return arr[top]; \n}", "vc-postamble": "// Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.\n\n\n\n\n\n      //Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0319", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Pop", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }\n\n\n\n\n\n\n\n      // Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Pop() returns (elem : int)\n      modifies   this`top\n      requires Valid() && !Empty()  \n      ensures Valid()  && top == old(top) - 1 \n      ensures elem == arr[old(top)]", "vc-code": "{\n            elem := arr[top];\n            top := top - 1;\n            return elem;\n}", "vc-postamble": "//Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0320", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Push", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }\n\n\n\n\n\n\n\n      // Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Push(elem : int)\n      modifies this`top, this.arr \n      requires Valid()\n      requires !Full() \n      ensures Valid() && top == old(top) + 1 && arr[top] == elem\n      ensures !old(Empty()) ==> forall i : int :: 0 <= i <= old(top)  ==> arr[i] == old(arr[i]);", "vc-code": "{\n            top := top + 1;\n            arr[top] := elem;\n}", "vc-postamble": "// Pops the top element off the stack.\n\n\n\n\n\n      //Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0321", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Push2", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }\n\n\n\n\n\n\n\n      // Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.\n\n\n\n      method Shift()\n      requires Valid() && !Empty();\n      ensures Valid();\n      ensures forall i : int :: 0 <= i < capacity - 1 ==> arr[i] == old(arr[i + 1]);\n      ensures top == old(top) - 1;\n      modifies this.arr, this`top;\n      {\n        var i : int := 0;\n        while (i < capacity - 1 )\n        invariant 0 <= i < capacity;\n        invariant top == old(top);\n        invariant forall j : int :: 0 <= j < i ==> arr[j] == old(arr[j + 1]);\n        invariant forall j : int :: i <= j < capacity ==> arr[j] == old(arr[j]);\n        {\n          arr[i] := arr[i + 1];\n          i := i + 1;\n        }\n        top := top - 1;\n      }\n\n\n      //Push onto full stack, oldest element is discarded.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Push2(elem : int)\n      modifies this.arr, this`top\n      requires Valid()\n      ensures Valid() && !Empty() \n      ensures arr[top] == elem\n      ensures old(!Full()) ==> top == old(top) + 1 && old(Full()) ==> top == old(top)\n      ensures ((old(Full()) ==> arr[capacity - 1] == elem)  && (old(!Full()) ==> (top == old(top) + 1 && arr[top] == elem) ))\n      ensures old(Full()) ==> forall i : int :: 0 <= i < capacity - 1 ==> arr[i] == old(arr[i + 1]);", "vc-code": "{\n            if(top == capacity - 1){\n                  Shift();\n                  top := top + 1;\n                  arr[top] := elem;\n            }\n            else{\n                  top := top + 1;\n                  arr[top] := elem;\n            }\n}", "vc-postamble": "// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0322", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_Shift", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }\n\n\n\n\n\n\n\n      // Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Shift()\n      requires Valid() && !Empty();\n      ensures Valid();\n      ensures forall i : int :: 0 <= i < capacity - 1 ==> arr[i] == old(arr[i + 1]);\n      ensures top == old(top) - 1;\n      modifies this.arr, this`top;", "vc-code": "{\n        var i : int := 0;\n        while (i < capacity - 1 )\n        invariant 0 <= i < capacity;\n        invariant top == old(top);\n        invariant forall j : int :: 0 <= j < i ==> arr[j] == old(arr[j + 1]);\n        invariant forall j : int :: i <= j < capacity ==> arr[j] == old(arr[j]);\n        {\n          arr[i] := arr[i + 1];\n          i := i + 1;\n        }\n        top := top - 1;\n}", "vc-postamble": "//Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0323", "language": "dafny", "source": "dafnybench", "source_id": "Formal_Verification_With_Dafny_tmp_tmp5j79rq48_LimitedStack_isEmpty", "vc-description": "", "vc-preamble": "// A LIFO queue (aka a stack) with limited capacity.\nclass LimitedStack{\n\n      var capacity : int; // capacity, max number of elements allowed on the stack.\n      var arr : array<int>; // contents of stack.\n      var top : int; // The index of the top of the stack, or -1 if the stack is empty\n\n      // This predicate express a class invariant: All objects of this calls should satisfy this.\n      predicate Valid()\n      reads this;\n      {\n        arr != null && capacity > 0 && capacity == arr.Length &&  top >= -1 && top < capacity \n      }\n\n      predicate Empty()\n      reads this`top;\n      {\n            top == -1\n      }\n\n      predicate Full()\n      reads this`top, this`capacity;\n      {\n        top == (capacity - 1)\n      }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isEmpty() returns (res : bool)\n      ensures res == Empty()", "vc-code": "{\n        if(top == -1)\n        { return true; }\n        else {\n              return false;\n        }\n}", "vc-postamble": "// Returns the top element of the stack, without removing it.\n\n\n\n      // Pushed an element to the top of a (non full) stack. \n\n      // Pops the top element off the stack.\n\n\n\n\n\n      //Push onto full stack, oldest element is discarded.\n\n\n\n\n// When you are finished,  all the below assertions should be provable. \n// Feel free to add extra ones as well.\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0324", "language": "dafny", "source": "dafnybench", "source_id": "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Binary_Search_binary_search_BinarySearch", "vc-description": "", "vc-preamble": "// Dafny verification of binary search alogirthm from binary_search.py\n// Inspired by: https://ece.uwaterloo.ca/~agurfink/stqam/rise4fun-Dafny/#h211", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BinarySearch(arr: array<int>, target: int) returns (index: int)\n    requires distinct(arr)\n    requires sorted(arr)\n    ensures -1 <= index < arr.Length\n    ensures index == -1 ==> not_found(arr, target)\n    ensures index != -1 ==> found(arr, target, index)", "vc-code": "{\n    var low, high := 0 , arr.Length-1;\n    while low <= high\n        invariant 0 <= low <= high + 1\n        invariant low-1 <= high < arr.Length\n        invariant forall i :: 0 <= i <= low && high <= i < arr.Length ==> arr[i] != target\n    { \n        var mid := (low + high) / 2;\n        if arr[mid] == target\n        {\n           return mid;\n        }\n        else if arr[mid] < target\n        {\n           low := mid + 1;\n        }\n        else\n        {\n           high := mid - 1;\n        }\n    }\n\n    return -1;\n}", "vc-postamble": "// Predicate to check that the array is sorted\npredicate sorted(a: array<int>)\nreads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k] \n}\n\n// Predicate to that each element is unique\npredicate distinct(arr: array<int>)\n    reads arr\n{\n    forall i, j :: 0 <= i < arr.Length && 0 <= j < arr.Length ==> arr[i] != arr[j]\n}\n\n// Predicate to that the target is not in the array\npredicate not_found(arr: array<int>, target: int)\nreads arr\n{\n    (forall j :: 0 <= j < arr.Length ==> arr[j] != target)\n}\n\n// Predicate to that the target is in the array\npredicate found(arr: array<int>, target: int, index: int)\nrequires -1 <= index < arr.Length;\nreads arr\n{\n    if index == -1 then false\n    else if arr[index] == target then true\n    else false\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0325", "language": "dafny", "source": "dafnybench", "source_id": "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Largest_Sum_largest_sum_largest_sum", "vc-description": "", "vc-preamble": "// CoPilot function converted to dafny", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|", "vc-code": "{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}", "vc-postamble": "method largest_sum(nums: array<int>, k: int) returns (sum: int)\n    requires nums.Length > 0 \n    ensures max_sum_subarray(nums, sum, 0, nums.Length)\n{\n    var max_sum := 0;\n    var current_sum := 0;\n\n    var i := 0;\n    while (i < nums.Length)\n        invariant 0 <= i <= nums.Length\n        invariant max_sum_subarray(nums, max_sum, 0, i) // Invariant for the max_sum \n        invariant forall j :: 0 <= j < i ==> Sum_Array(nums, j, i) <= current_sum // Invariant for the current_sum\n    {\n        current_sum := current_sum + nums[i];\n        if (current_sum > max_sum)\n        {\n            max_sum := current_sum;\n        }\n        if (current_sum < 0)\n        {\n            current_sum := 0;\n        }\n        i := i + 1;\n    }\n    return max_sum;\n}\n\n// Predicate to confirm that sum is the maximum summation of element [start, stop) \npredicate max_sum_subarray(arr: array<int>, sum: int, start: int, stop: int)\n    requires arr.Length > 0\n    requires 0 <= start <= stop <= arr.Length\n    reads arr\n{\n    forall u, v :: start <= u < v <= stop ==> Sum_Array(arr, u, v) <= sum\n}\n\n\n//Sums array elements between [start, stop)\nfunction Sum_Array(arr: array<int>, start: int, stop: int): int\n    requires 0 <= start <= stop <= arr.Length\n    decreases stop - start\n    reads arr\n{\n    if start >= stop then 0\n    else arr[stop-1] + Sum_Array(arr, start, stop-1)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0326", "language": "dafny", "source": "dafnybench", "source_id": "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Sort_Array_sort_array_sortArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sortArray(arr: array<int>) returns (arr_sorted: array<int>)\n    // Requires array length to be between 0 and 10000\n    requires 0 <= arr.Length < 10000\n    // Ensuring the arry has been sorted\n    ensures sorted(arr_sorted, 0, arr_sorted.Length)\n    // Ensuring that we have not modified elements but have only changed their indices\n    ensures multiset(arr[..]) == multiset(arr_sorted[..])\n\n    // Modifies arr\n    modifies arr", "vc-code": "{\n    var i := 0;\n    while i < arr.Length\n        invariant i <= arr.Length\n        invariant sorted(arr, 0, i)\n        invariant multiset(old(arr[..])) == multiset(arr[..])\n        invariant forall u, v :: 0 <= u < i && i <= v < arr.Length ==> arr[u] <= arr[v]\n        invariant pivot(arr, i)\n    {\n        var j := i;\n        while j < arr.Length\n            invariant j <= arr.Length\n            invariant multiset(old(arr[..])) == multiset(arr[..])\n            invariant pivot(arr, i)\n            invariant forall u :: i < u < j ==> arr[i] <= arr[u]\n            invariant forall u :: 0 <= u < i ==> arr[u] <= arr[i]\n            invariant sorted(arr, 0, i+1)\n        {\n            if arr[i] > arr[j]\n            {\n                var temp := arr[i];\n                arr[i] := arr[j];\n                arr[j] := temp;\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n    return arr;\n}", "vc-postamble": "// Predicate to determine whether the list is sorted between [start, stop)\npredicate sorted(arr: array<int>, start: int, end: int)\nrequires 0 <= start <= end <= arr.Length\nreads arr\n{\n    forall i, j :: start <= i <= j < end ==> arr[i] <= arr[j]\n}\n\n// Predicate to determine whether element arr[pivot] is a pivot point\n// Based on: https://github.com/stqam/dafny/blob/master/BubbleSort.dfy\npredicate pivot(arr: array<int>, pivot: int)\nrequires 0 <= pivot <= arr.Length\nreads arr\n{\n    forall u, v :: 0 <= u < pivot < v < arr.Length ==> arr[u] <= arr[v]\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0327", "language": "dafny", "source": "dafnybench", "source_id": "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two_Sum_two_sum_twoSum", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target", "vc-code": "{\n    var i := 0;\n    while i < nums.Length\n        invariant 0 <= i < nums.Length\n        invariant forall u, v :: 0 <= u < v < nums.Length && u < i ==> nums[u] + nums[v] != target\n        invariant exists u, v :: i <= u < v < nums.Length && nums[u] + nums[v] == target\n    {\n        var j := i + 1;\n        while j < nums.Length\n            invariant 0 <= i < j <= nums.Length\n            invariant forall u, v :: 0 <= u < v < nums.Length && u < i ==> nums[u] + nums[v] != target\n            invariant exists u, v :: i <= u < v < nums.Length && nums[u] + nums[v] == target\n            invariant forall u :: i < u < j ==> nums[i] + nums[u] != target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0328", "language": "dafny", "source": "dafnybench", "source_id": "M2_tmp_tmp2laaavvl_Software_Verification_Exercices_Exo4-CountAndReturn_CountToAndReturnN", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CountToAndReturnN(n: int) returns (r: int)\n    requires n >= 0\n    ensures r == n", "vc-code": "{\n    var i := 0;\n    while i < n\n    invariant 0 <= i <= n\n    {\n        i := i + 1;\n    }\n    r := i;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0329", "language": "dafny", "source": "dafnybench", "source_id": "M2_tmp_tmp2laaavvl_Software_Verification_Exercices_Exo7-ComputeSum_ComputeSum", "vc-description": "", "vc-preamble": "function Sum(n:nat):nat\n\n{\n  if n==0 then  0 else n + Sum(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeSum(n:nat) returns (s:nat)\n    ensures s ==Sum(n)", "vc-code": "{\n    s := 0;\n    var i := 0;\n    while i< n\n      invariant 0 <= i <= n\n      invariant s == Sum(i)\n      {\n        s := s + i + 1;\n        i := i+1;\n      }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0330", "language": "dafny", "source": "dafnybench", "source_id": "M2_tmp_tmp2laaavvl_Software_Verification_Exercices_Exo9-Carre_Carre", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Carre(a: nat) returns (c: nat)\nensures c == a*a", "vc-code": "{\n    var i := 0;\n    c := 0;\n    while i != a\n    invariant 0 <= i <= a\n    invariant c == i*i\n    decreases a - i\n  {\n    c := c + 2*i +1;\n    i := i + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0332", "language": "dafny", "source": "dafnybench", "source_id": "MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_8_sum_sum", "vc-description": "", "vc-preamble": "function calcSum(n: nat) : nat \n{   \n    n * (n - 1) / 2\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sum(n: nat) returns(s: nat)\n    ensures s == calcSum(n + 1)", "vc-code": "{\n    s := 0;\n    var i := 0;\n    while i < n \n        decreases n - i\n        invariant 0 <= i <= n\n        invariant s == calcSum(i + 1)\n    {\n        i := i + 1;\n        s := s + i;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0333", "language": "dafny", "source": "dafnybench", "source_id": "MFES_2021_tmp_tmpuljn8zd9_FCUL_Exercises_10_find_find", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method find(a: array<int>, key: int) returns(index: int)\n    requires a.Length > 0;\n    ensures 0 <= index <= a.Length;\n    ensures index < a.Length ==> a[index] == key;", "vc-code": "{\n    index := 0;\n    while index < a.Length && a[index] != key \n        decreases a.Length - index \n        invariant 0 <= index <= a.Length\n        invariant forall x :: 0 <= x < index ==> a[x] != key\n    {\n        index := index + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0334", "language": "dafny", "source": "dafnybench", "source_id": "MFES_2021_tmp_tmpuljn8zd9_PracticalClasses_TP3_2_Insertion_Sort_insertionSort", "vc-description": "", "vc-preamble": "// Sorts array 'a' using the insertion sort algorithm.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method insertionSort(a: array<int>) \n    modifies a\n    ensures isSorted(a, 0, a.Length)\n    ensures multiset(a[..]) == multiset(old(a[..]))", "vc-code": "{\n    var i := 0;\n    while i < a.Length \n        decreases a.Length - i \n        invariant 0 <= i <= a.Length\n        invariant isSorted(a, 0, i)\n        invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n        var j := i;\n        while j > 0 && a[j-1] > a[j] \n            decreases j\n            invariant 0 <= j <= i \n            invariant multiset(a[..]) == multiset(old(a[..]))\n            invariant forall l, r :: 0 <= l < r <= i && r != j ==> a[l] <= a[r]\n        {\n            a[j-1], a[j] := a[j], a[j-1];\n            j := j - 1;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "// Checks if array 'a' is sorted.\npredicate isSorted(a: array<int>, from: nat, to: nat)\n  reads a\n  requires 0 <= from <= to <= a.Length\n{\n    forall i, j :: from <= i < j < to ==> a[i] <= a[j]\n}\n\n// Simple test case to check the postcondition", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0336", "language": "dafny", "source": "dafnybench", "source_id": "MFES_2021_tmp_tmpuljn8zd9_TheoreticalClasses_Power_powerOpt", "vc-description": "", "vc-preamble": "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, MIEIC, MFES, 2020/21.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n  decreases n\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).\n\n// Recursive version, imperative, with time and space complexity O(log n).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method powerOpt(x: real, n: nat) returns (p : real)\n  ensures p == power(x, n);\n  decreases n;", "vc-code": "{\n    if n == 0 {\n        return 1.0;\n    }\n    else if n == 1 {\n        return x;\n    }\n    else if n % 2 == 0 {\n       distributiveProperty(x,  n/2, n/2); // recall lemma here\n        var temp := powerOpt(x, n/2);\n        return temp * temp;\n    }\n    else {\n        distributiveProperty(x, (n-1)/2, (n-1)/2); // recall lemma here  \n        var temp := powerOpt(x, (n-1)/2);\n        return temp * temp * x;\n    } \n}", "vc-postamble": "// States the property x^a * x^b = x^(a+b), that powerOpt takes advantage of. \n// The annotation {:induction a} guides Dafny to prove the property\n// by automatic induction on 'a'.\nlemma distributiveProperty(x: real, a: nat, b: nat) \n  ensures power(x, a) * power(x, b)  == power(x, a + b) \n{\n  //    \n  // To use the proof below, deactivate automatic induction, with {:induction false}.\n if a == 0 {\n        // base case\n        calc == {\n            power(x, a) * power(x, b);\n            power(x, 0) * power(x, b); // substitution\n            1.0 * power(x, b); // by the definition of power\n            power(x, b); // neutral element of \"*\"\n            power(x, a + b); // neutral element of \"+\"\n        }\n    }\n    else {\n        // recursive case, assuming property holds for a-1 (proof by induction)\n        distributiveProperty(x, a-1, b); \n        // now do the proof\n        calc == {\n            power(x, a) * power(x, b);\n            (x * power(x, a-1)) * power(x, b); // by the definition of power\n            x * (power(x, a-1) * power(x, b)); // associative property\n            x * power(x, a + b - 1); // this same property for a-1\n            power(x, a + b); // definition of power\n        }\n    }\n}\n\n// A simple test case to make sure the specification is adequate.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0338", "language": "dafny", "source": "dafnybench", "source_id": "MFS_tmp_tmpmmnu354t_Praticas_TP9_Power_powerOpt", "vc-description": "", "vc-preamble": "/* \n* Formal verification of O(n) and O(log n) algorithms to calculate the natural\n* power of a real number (x^n), illustrating the usage of lemmas.\n* FEUP, M.EIC, MFS, 2021/22.\n*/\n\n// Initial specification/definition of x^n, recursive, functional style, \n// with time and space complexity O(n).\nfunction power(x: real, n: nat) : real\n{\n    if n == 0 then 1.0 else x * power(x, n-1)\n}\n\n// Iterative version, imperative, with time complexity O(n) and space complexity O(1).\n\n\nlemma distributiveProperty(x: real, a: nat, b: nat)\n    ensures power(x, a) * power(x, b) == power(x, a+b)\n{\n    if a == 0 {\n        assert\n            power(x, a) * power(x, b) ==\n            1.0 * power(x, b) ==\n            power(x, b) ==\n            power(x, a + b);\n    }\n    else {\n        distributiveProperty(x, a-1, b);\n        assert\n            power(x, a) * power(x, b) ==\n            (x * power(x, a-1)) * power(x, b) ==\n            x * (power(x, a-1) * power(x, b)) ==\n            x * power(x, a - 1 + b) ==\n            power(x, a + b);\n    }\n}\n// Recursive version, imperative, with time and space complexity O(log n).", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method powerOpt(b: real, n: nat) returns (p : real)\n    ensures p == power(b, n)", "vc-code": "{\n    if n == 0 {\n        return 1.0;\n    }\n    else if n % 2 == 0 {\n        distributiveProperty(b, n/2, n/2);\n        var r := powerOpt(b, n/2);\n        return r * r;\n    }\n    else {\n        distributiveProperty(b, (n-1)/2, (n-1)/2);\n        var r := powerOpt(b, (n-1)/2);\n        return r * r * b;\n    } \n}", "vc-postamble": "// A simple test case to make sure the specification is adequate.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0339", "language": "dafny", "source": "dafnybench", "source_id": "MFS_tmp_tmpmmnu354t_Testes_anteriores_T2_ex5_2020_2_leq", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method leq(a: array<int>, b: array<int>) returns (result: bool) \n    ensures result <==> (a.Length <= b.Length && a[..] == b[..a.Length]) || (exists k :: 0 <= k < a.Length && k < b.Length && a[..k] == b[..k] && a[k] < b[k])", "vc-code": "{\n    var i := 0;\n    while i < a.Length && i < b.Length \n        decreases a.Length - i\n        invariant 0 <= i <= a.Length && 0 <= i <= b.Length\n        invariant a[..i] == b[..i]\n    {\n        if a[i] < b[i] { return true; }\n        else if a[i] > b[i] { return false; }\n        else {i := i + 1; }\n    }\n    return a.Length <= b.Length;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0341", "language": "dafny", "source": "dafnybench", "source_id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_appeal_20_p4_calcF", "vc-description": "", "vc-preamble": "function F(n: nat): nat { if n <= 2 then n else F(n-1) + F(n-3)}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method calcF(n: nat) returns (res: nat)  \n ensures res == F(n)", "vc-code": "{\n  var a, b, c := 0, 1, 2;\n  var i := 0;\n  while i < n\n    decreases n-i\n    invariant 0 <= i <= n\n    invariant a == F(i) && b == F(i+1) && c == F(i+2)\n   {\n    a, b, c := b, c, a + c;        \n    i := i + 1;\n  }\n  res := a;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0344", "language": "dafny", "source": "dafnybench", "source_id": "MIEIC_mfes_tmp_tmpq3ho7nve_exams_special_20_p5_binarySearch", "vc-description": "", "vc-preamble": "type T = int // for demo purposes, but could be another type\npredicate sorted(a: array<T>, n: nat) \n    requires n <= a.Length\n    reads a\n{\n    forall i,j :: 0 <= i < j < n ==> a[i] <= a[j]\n}\n\n// Use binary search to find an appropriate position to insert a value 'x'\n// in a sorted array 'a', so that it remains sorted.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method binarySearch(a: array<T>, x: T) returns (index: int) \n    requires sorted(a, a.Length)\n    ensures sorted(a, a.Length)\n    //ensures a[..] == old(a)[..]\n    ensures 0 <= index <= a.Length\n    //ensures forall i :: 0 <= i < index ==> a[i] <= x\n    //ensures forall i :: index <= i < a.Length ==> a[i] >= x\n\n    ensures index > 0 ==> a[index-1] <= x\n    ensures index < a.Length ==> a[index] >= x", "vc-code": "{\n    var low, high := 0, a.Length;\n    while low < high \n        decreases high-low\n        invariant 0 <= low <= high <= a.Length\n        invariant low > 0 ==> a[low-1] <= x\n        invariant high < a.Length ==> a[high] >= x\n\n    {\n        var mid := low + (high - low) / 2;\n        if {\n            case a[mid] < x => low := mid + 1;\n            case a[mid] > x => high := mid;\n            case a[mid] == x => return mid;\n        }\n    }\n    return low;\n}", "vc-postamble": "// Simple test cases to check the post-condition", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0345", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1_Mult", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y", "vc-code": "{\n    var m := x;\n    var n := y;\n    r:=0;\n\n    while m > 0\n    invariant m >= 0\n    invariant m*n+r == x*y\n    {\n        r := r + n;\n        m := m - 1;\n    }\n\n    return r;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0346", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex2_Pot", "vc-description": "", "vc-preamble": "function Potencia(x: nat, y: nat): nat\n{\n    if y == 0\n    then 1\n    else x * Potencia(x, y-1) \n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Pot(x: nat, y: nat) returns (r: nat)\nensures r == Potencia(x,y)", "vc-code": "{\n    var b := x;\n    var e := y;\n    r := 1;\n\n    while e > 0\n    invariant Potencia(b, e) * r == Potencia(x,y)\n    {\n        r := b * r;\n        e := e - 1;\n    }\n\n    return r;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0347", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex1_FazAlgo", "vc-description": "", "vc-preamble": "predicate Par(n:int)\n{\n    n % 2 == 0\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FazAlgo (a:int, b:int) returns (x:int, y:int)\nrequires a >= b && Par (a-b)", "vc-code": "{\n    x := a;\n    y := b;\n    while x != y\n    invariant x >= y\n    invariant Par(x-y)\n    decreases x-y\n    {\n        x := x - 1;\n        y := y + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0348", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpbez22nnn_Aula_4_ex3_ComputeFib", "vc-description": "", "vc-preamble": "function Fib(n:nat):nat\n{\n    if n < 2\n    then n\n    else Fib(n-2) + Fib(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFib(n:nat) returns (x:nat)\nensures x == Fib(n)", "vc-code": "{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    while i < n\n    decreases n - i\n    invariant 0 <= i <= n\n    invariant x == Fib(i)\n    invariant y == Fib(i+1)\n    {\n        x, y := y, x + y;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0349", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Arrays_explicacao_buscar", "vc-description": "", "vc-preamble": "// Array<T> = visualização de um array\n// Uma busca ordenada em um array\n// Buscar: Array<Z>xZ -> Z (Z é inteiro)\n// Pré: True (pré-condição é sempre verdadeira)\n// Pos: R < 0 => Para todo i pertencente aos naturais(0 <= i < A.length => A[i] != X) e\n// 0 <= R < A.length => A[R] = x \n//\n// método em qualquer linguagem:\n// R = 0\n// Enquanto(R < |A|) {\n//  Se (A[R] == X) retorne E\n//  R = R + 1\n// }\n// retorne -1 \n// \n// X  | R | |A|\n// 10 | 0 |  5\n// 10 | 1 |  5\n// 10 | 2 |  \n// invariante detectada: 0 <= R <= |A| e Para todo i pertencente aos naturais(0 <= i < R => A[i] != X)\n\n// no dafy\n// forall = é o para todo logico\n// :: é igual ao tal que lógico\n// ==> é o então lógico\n// forall i :: 0 <= i < a.Length ==> a[i] != x (para todo i tal que i e maior ou igual a zero e menor que o tamanho do array, então a posição i do array a é diferente de x)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method buscar(a:array<int>, x:int) returns (r:int)\n    ensures r < 0 ==> forall i :: 0 <= i < a.Length ==> a[i] != x\n    ensures 0 <= r < a.Length ==> a[r] == x", "vc-code": "{\n    r := 0;\n    while r < a.Length\n    decreases a.Length - r //variante, decrescendo a cada passo com o r\n    invariant 0 <= r <= a.Length //a invariante é quando nao é encontado o x depois de rodado todo o projeto\n    invariant forall i :: 0 <= i < r ==> a[i] != x\n    {\n        if a[r] == x\n        {\n            return r;\n        }\n        r := r + 1;\n    }\n    return -1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0350", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Arrays_somatorioArray_somatorio", "vc-description": "", "vc-preamble": "// Deve ser criado uma função explicando o que é um somatório\n// Somatorio: Array<N> -> N\n// Pre: True\n// Pos: Somatorio(A) = somatório de i = 0 até |A|-1 os valores das posições do array pelo i\n//\n\n// function é uma fórmula matemática, ele não possui variaveis globais\n// Soma: Array<N>xN -> N\n// { Soma(A,0) = A[0]\n// { Soma(A,i) = A[i] + soma(A, i-1) , se i > 0\n// Teste\n// |A| = 4\n// Soma(A, |A|-1) = Soma(A,3)\n// A[3] + Soma(A,2)\n// A[3] + A[2] + Soma(A,1)\n// A[3] + A[2] + A[1] + Soma(A,0)\n// A[3] + A[2] + A[1] + A[0]\nfunction soma(a:array<nat>, i:nat):nat\n    requires i <= a.Length //Tem que dizer que o i só vai até um valor antes do tamanho do array\n    reads a //serve para dizer que está sendo lido da memoria o array a (áreas de memória)\n{\n    if i == 0\n    then 0\n    else a[i-1] + soma(a,i-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method somatorio(a:array<nat>) returns (s:nat)\n    ensures s == soma(a, a.Length)", "vc-code": "{\n        s := 0;\n        for i := 0 to a.Length\n            invariant s == soma(a,i)\n        {\n            s := s + a[i];\n        }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0351", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fatorial2_Fatorial", "vc-description": "", "vc-preamble": "function Fat(n:nat):nat\n{\n    if n == 0 then 1 else n*Fat(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Fatorial(n:nat) returns (f:nat)\nensures f == Fat(n)", "vc-code": "{\n    f := 1;\n    var i := 1;\n    while i <= n\n        decreases n-i //variante\n        invariant 1 <= i <= n+1 //invariante\n        invariant f == Fat(i-1) //invariante\n    {\n        f := f * i;\n        i := i + 1;\n    }\n    return f;\n}", "vc-postamble": "// i | n | variante\n// 1 | 3 | 2\n// 2 | 3 | 1\n// 3 | 3 | 0\n// 4 | 3 | -1\n// variante = n - i\n// então é usado o decreases n-1", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0352", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_fibonacci_ComputeFib", "vc-description": "", "vc-preamble": "// Provando fibonacci\nfunction Fib(n:nat):nat\n{\n    if n < 2\n    then n\n    else Fib(n-2) + Fib(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFib(n:nat) returns (x:nat)\nensures x == Fib(n)", "vc-code": "{\n    var i := 0;\n    x := 0;\n    var y := 1;\n    while i < n\n    decreases n-i\n    invariant 0 <= i <= n\n    invariant x == Fib(i)\n    invariant y == Fib(i+1)\n    {\n        x, y := y, x + y; //multiplas atribuições\n        i := i + 1;\n    }\n}", "vc-postamble": "// Fibonnaci\n// n | Fib\n// 0 | 0\n// 1 | 1\n// 2 | 1\n// 3 | 2\n// 4 | 3\n// 5 | 5\n// Teste da computação do Fibonnaci\n// i | n | x | y | n-1\n// 0 | 3 | 0 | 1 | 3\n// 1 | 3 | 1 | 1 | 2\n// 2 | 3 | 1 | 2 | 1\n// 3 | 3 | 2 | 3 | 0\n// Variante: n - 1\n// Invariante: x = Fib(i)  = x sempre é o resultado do fibonnaci do valor de i\n// Invariante: 0 <= i <= n = i deve ter um valor entre 0 e o valor de n\n// Invariante: y = Fib(i+1) = o valor de y sempre vai ser o valor de fibonnaci mais um", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0353", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador_Mult", "vc-description": "", "vc-preamble": "// Exemplo de invariantes\n// Invariante significa que o valor não muda desde a pré-condição até a pós-condição", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y", "vc-code": "{\n    // parâmetros de entrada são imutáveis, por isso\n    // é preciso a atribuir a variáveis locais para usar em blocos de códigos para mudar\n\n    var m := x;\n    var n := y;\n\n    r := 0;\n    while m > 0 \n    invariant m >= 0\n    invariant m*n+r == x*y\n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}", "vc-postamble": "// Teste do método para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a fórmula m*n+r == x*y é uma invariante\n// mas só isso não serve, o m ele é maior ou igual a zero quando acaba o while\n// por isso, também é a invariante que necessita\n// com isso dizemos para o programa as alterações do m de maior ou igual a zero\n// e mostramos a função encontrada que alterava o valor de m e n das variaveis criadas\n\n// SE OS ALGORITMOS TIVEREM REPETIÇÃO OU RECURSÃO, DEVEM SER MOSTRADOS QUAIS SÃO AS INVARIANTES\n// OU SEJA, OS VALORES QUE NÃO ESTÃO SENDO MUDADOS E COLOCAR A FÓRMULA DELE COMO ACIMA", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0354", "language": "dafny", "source": "dafnybench", "source_id": "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_potencia_Pot", "vc-description": "", "vc-preamble": "// Potência\n\n// deve ser especificado a potência, porque ele não existe n dafny\n\n// Função recursiva da potência\nfunction Potencia(x:nat, y:nat):nat\n{\n    if y == 0\n    then 1\n    else x * Potencia(x,y-1)\n}\n\n// Quero agora implementar como uma função não recursiva", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Pot(x:nat, y:nat) returns (r:nat)\nensures r == Potencia(x,y)", "vc-code": "{\n    r := 1; //sempre r começa com 1\n    var b := x; //base\n    var e := y; //expoente\n\n    while e > 0 \n    invariant  Potencia(b,e)*r == Potencia(x,y) \n    {\n        r := r * b;\n        e := e - 1;\n    }\n    return r;\n}", "vc-postamble": "// Devemos sempre construir uma tabela para vermos passo a passo o processo\n// POT(2,3)\n// x | y | b | e | r | \n// 2 | 3 | 2 | 3 | 1 |\n// 2 | 3 | 2 | 2 | 1x2     |\n// 2 | 3 | 2 | 1 | 1x2x2   |\n// 2 | 3 | 2 | 0 | 1x2x2x2 |\n// temos que na invariante queremos a fórmula x^y\n// INV ... = x^y\n// vendo pelo que foi processado fica dando o seguinte\n// x | y | b | e | r |  \n// 2 | 3 | 2 | 3 | 1 (2^0)      | 2^3 x 2^0 = 2^3\n// 2 | 3 | 2 | 2 | 1x2  (2^1)   | 2^2 x 2^1 = 2^3\n// 2 | 3 | 2 | 1 | 1x2x2 (2^2)  | 2^1 x 2^2 = 2^3\n// 2 | 3 | 2 | 0 | 1x2x2x2 (2^3)| 2^0 x 2^3 = 2^3\n// portanto a base está sendo feito a potencia de e (usando o potencia) e multiplicado pelo valor de r\n// b^e * r\n// assim temos a fórmula: b^e * r = x^y\n// dai utilizamos a function potencia para construir a fórmula\n// Potencia(b,e)*r == Potencia(x,y)", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0357", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_pow_Pow", "vc-description": "", "vc-preamble": "ghost function pow(a: int, e: nat): int {\n    if e == 0 then 1 else a*pow(a, e-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Pow(a: nat, n: nat) returns (y: nat)\nensures y == pow(a, n)", "vc-code": "{\n    var x:nat := 1;\n    var k:nat := 0;\n    while k < n\n    invariant x == pow(a, k)\n    invariant 0 <= k <= n\n    decreases n-k\n    {\n        assert x == pow(a, k);\n        x := a*x;\n        assert x == a*pow(a, k);\n        assert x == pow(a, k+1);\n\n        k := k + 1;\n        assert x == pow(a, k);\n\n    }\n    assert k == n;\n    y := x;\n    assert y == pow(a, n);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0358", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_extra_sum_Sum", "vc-description": "", "vc-preamble": "ghost function sum(n: nat): int\n{\n    if n == 0 then 0 else n + sum(n - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Sum(n: nat) returns (s: int)\nensures s == sum(n)", "vc-code": "{\n    var x:nat := 0;\n    var y:nat := 1;\n    var k:nat := n;\n    while k > 0\n    invariant sum(n) == x + y*sum(k)\n    invariant 0 <= k <= n\n    decreases k\n    {\n        assert sum(n) == x + y*sum(k);\n        assert sum(n) == x + y*(k+sum(k-1));\n        assert sum(n) == x + y*k + y*sum(k-1);\n        x := x + y*k;\n        assert sum(n) == x + y*sum(k-1);\n\n        assert sum(n) == x + y*sum(k-1);\n        k := k-1;\n        assert sum(n) == x + y*sum(k);\n    }\n    assert k == 0;\n    assert sum(n) == x + y*sum(0);\n    assert sum(n) == x + y*0;\n    s := x;\n    assert sum(n) == s;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0359", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p2_problem2", "vc-description": "", "vc-preamble": "// problem 2:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXX", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method problem2(p:int, q:int, X:int, Y:int) returns (r:int, s:int)\nrequires p == 2*X + Y && q == X + 3\nensures r == X && s == Y", "vc-code": "{\n    assert p == 2*X + Y && q == X + 3;\n    r, s := p, q;\n    assert r == 2*X + Y && s == X + 3;\n    r := r - 2*s + 6;\n    assert r == 2*X + Y-2*X-6 + 6 && s == X + 3;\n    assert r == Y && s == X + 3;\n    s := s - 3;\n    assert r == Y && s == X;\n    r,s := s, r;\n    assert s == Y && r == X;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0360", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p3_problem3", "vc-description": "", "vc-preamble": "// problem 3:\n// name:      ....... (fill in your name)\n// s-number: s....... (fill in your student number)\n// table:     ....... (fill in your table number)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method problem3(m:int, X:int) returns (r:int)\nrequires X >= 0 && (2*m == 1 - X || m == X + 3)\nensures r == X", "vc-code": "{\n    assert X >= 0 && (X == 1 - 2*m || m-3 == X);\n    r := m;\n    assert X >= 0 && (1 - 2*r >= 0 || r-3 >= 0);\n\n    if (1-2*r >= 0) {\n        assert X >= 0 && 2*r == 1-X;\n        r := 2*r;\n        assert X >= 0 && r == 1-X;\n        r := -r+1;\n    } else {\n        assert r == X + 3;\n        r := r -3;\n    }\n    assert r == X;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0361", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5_problem5", "vc-description": "", "vc-preamble": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\n\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method problem5(n:nat) returns (x: int)\nensures x == f(n)", "vc-code": "{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    invariant f(n) == a*f(k) + b\n    invariant -5 <= k <= n\n    decreases k\n    {\n        assert f(n) == a*f(k) + b;\n        assert f(n) == a*(3*f(k-5)+k) + b;\n\n        assert f(n) == 3*a*f(k-5) + a*k + b;\n        b := a*k + b;\n        assert f(n) == 3*a*f(k-5) + b;\n        a := 3*a;\n        assert f(n) == a*f(k-5) + b;\n        k := k - 5;\n        assert f(n) == a*f(k) + b;\n    }\n\n    assert k < 0;\n    assert f(n) == a*f(k) + b;\n    assert f(n) == a*0 + b;\n    x := b;\n    assert x== f(n);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0362", "language": "dafny", "source": "dafnybench", "source_id": "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6_problem6", "vc-description": "", "vc-preamble": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\n\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\n\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method problem6(n:nat) returns (a: int)\nensures a == fSum(n)", "vc-code": "{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\n  invariant 0 <= k <= n && x == f(k) && y == f(k+1) && a == fSum(k)\n  decreases n-k\n  {\n    assert x == f(k) && y == f(k+1) && a == fSum(k);\n    k := k + 1;\n    assert x == f(k-1) && y == f(k) && a == fSum(k-1);\n    assert x == f(k-1) && y == f(k) && a == fSum(k) - f(k-1);\n    a := a + x;\n    assert x == f(k-1) && y == f(k) && a == fSum(k) - f(k-1) + f(k-1);\n    assert x == f(k-1) && y == f(k) && a == fSum(k);\n\n    x, y := y, k+1 + x*y;    \n    assert x == f(k) && y == k+1+f(k-1)*f(k) && a == fSum(k);\n    assert x == f(k) && y == k+1+f(k+1-2)*f(k+1-1) && a == fSum(k);\n    assert x == f(k) && y == f(k+1) && a == fSum(k);\n  }\n  assert a == fSum(k);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0375", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_examples_simpleMultiplication_Foo", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Foo(y: int, x: int) returns (z: int) \n  requires 0 <= y\n  ensures z == x*y", "vc-code": "{\n  var a: int := 0;\n  z := 0;\n  while a != y \n   invariant 0 <= a <= y\n   invariant z == a*x\n   decreases y-a\n  {\n    z := z + x;\n    a := a + 1;\n  }\n  return z;\n}", "vc-postamble": "function stringToSet(s: string): (r: set<char>)\nensures forall x :: 0 <= x < |s| ==> s[x] in r\n{\n set x | 0 <= x < |s| :: s[x]\n}\n//ensures forall a, b :: 0 <= a < b < |s|  ==> forall k, j :: a <=k < j <=b ==> k !=j ==> s[k] != s[j] ==> b-a <= longest\n// lemma stringSet(s: string)\n//    \n//   {\n//     if |s| != 0 {\n\n\n//     }\n//   }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0376", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_heap2_heapify", "vc-description": "", "vc-preamble": "class Heap {\n  var arr: array<int>\n\n  constructor Heap (input: array<int>)\n   ensures this.arr == input {\n     this.arr := input;\n  }\n\n  function parent(idx: int): int\n  {\n    if idx == 0 then -1\n    else if idx % 2 == 0 then (idx-2)/2\n    else (idx-1)/2\n  }\n\n  predicate IsMaxHeap(input: seq<int>)\n  {\n    forall i :: 0 <= i < |input| ==>\n      && (2*i+1 < |input| ==> input[i] >= input[2*i+1])\n      && (2*i+2 < |input| ==> input[i] >= input[2*i+2])\n  }\n\n  predicate IsAlmostMaxHeap(input: seq<int>, idx: int)\n    requires 0 <= idx\n  {\n    && (forall i :: 0 <= i < |input| ==>\n        && (2*i+1 < |input| && i != idx ==> input[i] >= input[2*i+1])\n        && (2*i+2 < |input| && i != idx ==> input[i] >= input[2*i+2]))\n    && (0 <= parent(idx) < |input| && 2*idx+1 < |input| ==> input[parent(idx)] >= input[2*idx+1])\n    && (0 <= parent(idx) < |input| && 2*idx+2 < |input| ==> input[parent(idx)] >= input[2*idx+2])\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method heapify(idx: int)\n    returns (nidx: int)\n    modifies this, this.arr\n    requires 0 <= idx < this.arr.Length\n    requires IsAlmostMaxHeap(this.arr[..], idx)\n    ensures nidx == -1 || idx < nidx < this.arr.Length\n    ensures nidx == -1 ==> IsMaxHeap(this.arr[..])\n    ensures idx < nidx < this.arr.Length ==> IsAlmostMaxHeap(this.arr[..], nidx)", "vc-code": "{\n    if (2*idx+1 >= this.arr.Length) && (2*idx+2 >= this.arr.Length) {\n      nidx := -1;\n      assert IsMaxHeap(this.arr[..]);\n      return;\n    }\n    else {\n      assert 2*idx+1 < this.arr.Length || 2*idx+2 < this.arr.Length;\n      nidx := idx;\n      if 2*idx+1 < this.arr.Length && this.arr[nidx] < this.arr[2*idx+1] {\n        nidx := 2*idx+1;\n      }\n      if 2*idx+2 < this.arr.Length && this.arr[nidx] < this.arr[2*idx+2] {\n        nidx := 2*idx+2;\n      }\n      if nidx == idx {\n        nidx := -1;\n        return;\n      }\n      else {\n        assert nidx == 2*idx+1 || nidx == 2*idx+2;\n        this.arr[idx], this.arr[nidx] := this.arr[nidx], this.arr[idx];\n        forall i | 0 <= i < this.arr.Length\n          ensures (i != nidx) && (2*i+1 < this.arr.Length) ==> (this.arr[i] >= this.arr[2*i+1]) {\n            if (i != nidx) && (2*i+1 < this.arr.Length) {\n              if 2*i+1 == idx {\n                assert this.arr[i] >= this.arr[2*i+1];\n              }\n            }\n          }\n        forall i | 0 <= i < this.arr.Length\n           ensures (i != nidx) && (2*i+2 < this.arr.Length) ==> (this.arr[i] >= this.arr[2*i+2]) {\n            if (i != nidx) && (2*i+2 < this.arr.Length) {\n              if 2*i+2 == idx {\n                assert this.arr[i]  >= this.arr[2*i+2];\n              }\n            }\n        }\n      }\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0380", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_msetEqual", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method msetEqual(s: multiset<char>, t: multiset<char>) returns (equal: bool)\n    ensures s == t <==> equal", "vc-code": "{\n    ghost var sremoved: multiset<char> := multiset{};\n    var scopy := s;\n    while scopy != multiset{} \n        invariant s - sremoved == scopy\n        invariant sremoved !! scopy\n        invariant sremoved <= s\n        invariant forall x :: x in sremoved ==> x in s && x in t && t[x] == s[x]\n    {\n        var x :| x in scopy;\n        if !(x in t && s[x] == t[x]) {\n           return false; \n        }\n        var removed := multiset{};\n        // assert removed[x := s[x]] <= s;\n        sremoved := sremoved + removed[x := s[x]];\n        scopy := scopy - removed[x := s[x]];\n    }\n    // assert scopy == multiset{};\n    // assert s - sremoved == scopy;\n    // assert sremoved == s;\n    // assert forall x :: x in sremoved ==> x in s && x in t && t[x] == s[x];\n\n    ghost var tremoved: multiset<char> := multiset{};\n    var tcopy := t;\n    while tcopy != multiset{} \n        invariant t - tremoved == tcopy\n        invariant tremoved !! tcopy\n        invariant tremoved <= t\n        invariant forall x :: x in tremoved ==> x in s && x in t && t[x] == s[x]\n    {\n        var x :| x in tcopy;\n        if !(x in t && s[x] == t[x]) {\n           return false; \n        }\n        var removed := multiset{};\n        tremoved := tremoved + removed[x := s[x]];\n        tcopy := tcopy - removed[x := s[x]];\n    }\n    // assert forall x :: x in tremoved ==> x in s && x in t && t[x] == s[x];\n\n    return true;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0381", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_algorithms_and_leetcode_leetcode_validAnagram_toMultiset", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method toMultiset(s: string) returns (mset: multiset<char>)\n    ensures multiset(s) == mset", "vc-code": "{\n    mset := multiset{};\n    for i := 0 to |s| \n        invariant mset == multiset(s[0..i])\n    {\n        assert s == s[0..i] + [s[i]] + s[(i+1)..];\n        // assert multiset(s) == multiset(s[0..i])+multiset{s[i]}+multiset(s[(i+1)..]);\n        mset := mset + multiset{s[i]};\n    }\n    assert s == s[0..|s|];\n    // assert mset == multiset(s[0..|s|]);\n    return mset;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0384", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_add_by_one_add_by_one", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method add_by_one (x:int, y:int) returns (r:int)\n  requires y >= 0;\n  ensures r == x + y;", "vc-code": "{\n  var i:int := 0;\n  r := x;\n  while (i < y)\n    invariant i <= y;\n    invariant r == x + i;\n    decreases y-i;\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n  return r;\n}", "vc-postamble": "/*\n * Illustrates de-sugaring of the while loop.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0385", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_add_by_one_bar", "vc-description": "", "vc-preamble": "/*\n * Illustrates de-sugaring of the while loop.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method bar (x:int, y:int) returns (r:int)\n  requires y >= 0;\n  ensures r == x + y;", "vc-code": "{\n  var i := 0;\n  r := x;\n  // the invariant is true before the loop\n  assert (i <= y && r == x + i);\n  // the ranking function is positive before the loop\n  assert (y-i >= 0);\n\n  // havoc variables assigned by the loop\n  i, r := *, *;\n  // assume the invariant holds\n  assume (i <= y && r == x + i);\n  // assume the ranking function is positive\n  assume (y-i >= 0);\n  // store the value of ranking function to compare against later\n  ghost var rank_before := y-i;\n\n  // one body of the loop\n  if (i < y)\n  {\n    r := r + 1;\n    i := i + 1;\n    // invariant is true at the end of the loop\n    assert (i <= y && r == x + i);\n    // ranking function is positive at the end of the loop\n    assert (y-i >= 0);\n    // ranking function has decreased\n    assert (rank_before - (y-i) > 0);\n    // if got to here, stop verification of this branch\n    assume (false);\n  }\n  // at this point only know the invariant of the loop + negation of\n  // the loop condition\n  return r;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0386", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_find_max_FindMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FindMax(a: array<int>) returns (max: int)\n   requires a != null && a.Length > 0;\n   ensures 0 <= max < a.Length;\n   ensures forall x :: 0 <= x < a.Length ==> a[max] >= a[x];", "vc-code": "{\n  var i := 0;\n  max := 0;\n\n  while (i < a.Length)\n    invariant i <= a.Length;\n    invariant 0 <= max;\n    invariant max == 0 || 0 < max < i;\n    invariant forall k :: 0 <= k < i ==> a[max] >= a[k]\n  {\n    if (a[i] > a[max]) { max := i; }\n    i := i + 1;\n  }\n  return max;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0387", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_product_details_CalcProduct", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CalcProduct(m: nat, n: nat) returns (res: nat)\n  ensures res == m*n;", "vc-code": "{\n  var m1: nat := m;\n  res := 0;\n\n  assert res == (m-m1)*n;\n  m1, res := *, *;\n  assume res == (m-m1)*n;\n  if (m1!=0) \n  {   \n    var n1: nat := n;\n    assert (res == (m-m1)*n + (n-n1));\n    // havoc res, n1;\n    res, n1 := *, *;\n    assume res == (m-m1)*n + (n-n1);\n    if (n1 != 0)\n    {\n      ghost var old_n1 := n1;\n      res := res+1;\n      n1 := n1-1; \n      assert (res == (m-m1)*n + (n-n1));\n      assert n1 < old_n1;\n      assert n1 >= 0;\n      assume (false);\n    }  \n    m1 := m1-1;\n    assert res == (m-m1)*n;\n    assume false;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0388", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_sumto_sol_SumUpTo", "vc-description": "", "vc-preamble": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);", "vc-code": "{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}", "vc-postamble": "function total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\n\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0389", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic_examples_sumto_sol_Total", "vc-description": "", "vc-preamble": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\n\n\n\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\n\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]);", "vc-code": "{\n  var i := 0;\n  r := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|;\n    invariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0390", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny0_snapshots_Inputs_Snapshots1_N", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method N()\n  ensures P();\n\npredicate P()", "vc-code": "{\n  false\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0391", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_BDD_Eval", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\nmodule SimpleBDD\n{\n  class BDDNode\n  {\n    static ghost predicate bitfunc(f: map<seq<bool>, bool>, n: nat)\n    {\n       forall i:seq<bool> :: i in f <==> |i| == n\n    }\n    ghost var Contents: map<seq<bool>, bool>\n    ghost var Repr: set<object>\n    ghost var n: nat\n    var f: BDDNode?, t: BDDNode?\n    var b: bool\n    ghost predicate valid()\n      reads this, Repr\n    {\n      bitfunc(Contents,n) &&\n      (0 == n ==> (b <==> Contents[[]])) &&\n      (0 < n ==>\n        this in Repr &&\n        f != null && t != null && t in Repr && f in Repr &&\n        t.Repr <= Repr && f.Repr <= Repr &&\n        this !in f.Repr && this !in t.Repr &&\n        t.valid() && f.valid() &&\n        t.n == f.n == n-1 &&\n        (forall s | s in t.Contents :: Contents[[true]  + s] <==> t.Contents[s]) &&\n        (forall s | s in f.Contents :: Contents[[false] + s] <==> f.Contents[s]))\n    }\n  }\n  class BDD\n  {\n    var root: BDDNode\n    ghost predicate valid()\n      reads this, Repr\n    {\n      root in Repr && root.Repr <= Repr && root.valid() &&\n      n == root.n && Contents == root.Contents\n    }\n    constructor () {\n      root := new BDDNode;\n    }\n\n    ghost var Contents: map<seq<bool>, bool>\n    var n: nat\n    ghost var Repr: set<object>", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Eval(s: seq<bool>) returns(b: bool)\n      requires valid() && |s| == n\n      ensures b == Contents[s]", "vc-code": "{\n      var node: BDDNode := root;\n      var i := n;\n      assert s[n-i..] == s;\n      while i > 0\n        invariant node.valid()\n        invariant 0 <= i == node.n <= n\n        invariant Contents[s] == node.Contents[s[n-i..]]\n      {\n        assert s[n-i..] == [s[n-i]] + s[n-i+1..];\n        node := if s[n-i] then node.t else node.f;\n        i := i - 1;\n      }\n      assert s[n-i..] == [];\n      b := node.b;\n}", "vc-postamble": "}\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0392", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_ListContents_Prepend", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\nclass Node<T> {\n  ghost var List: seq<T>\n  ghost var Repr: set<Node<T>>\n\n  var data: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next == null ==> List == [data]) &&\n    (next != null ==>\n        next in Repr && next.Repr <= Repr &&\n        this !in next.Repr &&\n        List == [data] + next.List &&\n        next.Valid())\n  }\n\n  constructor (d: T)\n    ensures Valid() && fresh(Repr)\n    ensures List == [d]\n  {\n    data, next := d, null;\n    List, Repr := [d], {this};\n  }\n\n  constructor InitAsPredecessor(d: T, succ: Node<T>)\n    requires succ.Valid()\n    ensures Valid() && fresh(Repr - succ.Repr)\n    ensures List == [d] + succ.List\n  {\n    data, next := d, succ;\n    List := [d] + succ.List;\n    Repr := {this} + succ.Repr;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Prepend(d: T) returns (r: Node<T>)\n    requires Valid()\n    ensures r.Valid() && fresh(r.Repr - old(Repr))\n    ensures r.List == [d] + List", "vc-code": "{\n    r := new Node.InitAsPredecessor(d, this);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0393", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_ListContents_ReverseInPlace", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\nclass Node<T> {\n  ghost var List: seq<T>\n  ghost var Repr: set<Node<T>>\n\n  var data: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next == null ==> List == [data]) &&\n    (next != null ==>\n        next in Repr && next.Repr <= Repr &&\n        this !in next.Repr &&\n        List == [data] + next.List &&\n        next.Valid())\n  }\n\n  constructor (d: T)\n    ensures Valid() && fresh(Repr)\n    ensures List == [d]\n  {\n    data, next := d, null;\n    List, Repr := [d], {this};\n  }\n\n  constructor InitAsPredecessor(d: T, succ: Node<T>)\n    requires succ.Valid()\n    ensures Valid() && fresh(Repr - succ.Repr)\n    ensures List == [d] + succ.List\n  {\n    data, next := d, succ;\n    List := [d] + succ.List;\n    Repr := {this} + succ.Repr;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ReverseInPlace() returns (reverse: Node<T>)\n    requires Valid()\n    modifies Repr\n    ensures reverse.Valid() && reverse.Repr <= old(Repr)\n    ensures |reverse.List| == |old(List)|\n    ensures forall i :: 0 <= i < |reverse.List| ==> reverse.List[i] == old(List)[|old(List)|-1-i]", "vc-code": "{\n    var current := next;\n    reverse := this;\n    reverse.next := null;\n    reverse.Repr := {reverse};\n    reverse.List := [data];\n\n    while current != null\n      invariant reverse.Valid() && reverse.Repr <= old(Repr)\n      invariant current == null ==> |old(List)| == |reverse.List|\n      invariant current != null ==>\n        current.Valid() &&\n        current in old(Repr) && current.Repr <= old(Repr) &&\n        current.Repr !! reverse.Repr\n      invariant current != null ==>\n        |old(List)| == |reverse.List| + |current.List| &&\n        current.List == old(List)[|reverse.List|..]\n      invariant forall i :: 0 <= i < |reverse.List| ==> reverse.List[i] == old(List)[|reverse.List|-1-i]\n      decreases if current != null then |current.List| else -1\n    {\n      var nx := current.next;\n\n      // ..., reverse, current, nx, ...\n      current.next := reverse;\n      current.Repr := {current} + reverse.Repr;\n      current.List := [current.data] + reverse.List;\n\n      reverse := current;\n      current := nx;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0394", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_ListContents_SkipHead", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\nclass Node<T> {\n  ghost var List: seq<T>\n  ghost var Repr: set<Node<T>>\n\n  var data: T\n  var next: Node?<T>\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    (next == null ==> List == [data]) &&\n    (next != null ==>\n        next in Repr && next.Repr <= Repr &&\n        this !in next.Repr &&\n        List == [data] + next.List &&\n        next.Valid())\n  }\n\n  constructor (d: T)\n    ensures Valid() && fresh(Repr)\n    ensures List == [d]\n  {\n    data, next := d, null;\n    List, Repr := [d], {this};\n  }\n\n  constructor InitAsPredecessor(d: T, succ: Node<T>)\n    requires succ.Valid()\n    ensures Valid() && fresh(Repr - succ.Repr)\n    ensures List == [d] + succ.List\n  {\n    data, next := d, succ;\n    List := [d] + succ.List;\n    Repr := {this} + succ.Repr;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SkipHead() returns (r: Node?<T>)\n    requires Valid()\n    ensures r == null ==> |List| == 1\n    ensures r != null ==> r.Valid() && r.List == List[1..] && r.Repr <= Repr", "vc-code": "{\n    r := next;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0395", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_Queue_Enqueue", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Queue.dfy\n// Dafny version of Queue.bpl\n// Rustan Leino, 2008\n\nclass Queue<T(0)> {\n\nmethod Front() returns (x: int)\n{\n    x := 0; // Placeholder\n}\n\n\n\n  var head: Node<T>\n  var tail: Node<T>\n\n  ghost var contents: seq<T>\n  ghost var footprint: set<object>\n  ghost var spine: set<Node<T>>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint && spine <= footprint &&\n    head in spine &&\n    tail in spine &&\n    tail.next == null &&\n    (forall n ::\n      n in spine ==>\n        n.footprint <= footprint && this !in n.footprint &&\n        n.Valid() &&\n        (n.next == null ==> n == tail)) &&\n    (forall n ::\n      n in spine ==>\n        n.next != null ==> n.next in spine) &&\n    contents == head.tailContents\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures |contents| == 0\n  {\n    var n: Node<T> := new Node<T>.Init();\n    head := n;\n    tail := n;\n    contents := n.tailContents;\n    footprint := {this} + n.footprint;\n    spine := {n};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Enqueue(t: T)\n    requires Valid()\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents) + [t]", "vc-code": "{\n    var n := new Node<T>.Init();\n    n.data := t;\n    tail.next := n;\n    tail := n;\n\n    forall m | m in spine {\n      m.tailContents := m.tailContents + [t];\n    }\n    contents := head.tailContents;\n\n    forall m | m in spine {\n      m.footprint := m.footprint + n.footprint;\n    }\n    footprint := footprint + n.footprint;\n\n    spine := spine + {n};\n}", "vc-postamble": "}\n\nclass Node<T(0)> {\n  var data: T\n  var next: Node?<T>\n\n  ghost var tailContents: seq<T>\n  ghost var footprint: set<object>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint &&\n    (next != null ==> next in footprint && next.footprint <= footprint) &&\n    (next == null ==> tailContents == []) &&\n    (next != null ==> tailContents == [next.data] + next.tailContents)\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures next == null\n  {\n    next := null;\n    tailContents := [];\n    footprint := {this};\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0396", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_Queue_Main2", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Queue.dfy\n// Dafny version of Queue.bpl\n// Rustan Leino, 2008\n\nclass Queue<T(0)> {\n  var head: Node<T>\n  var tail: Node<T>\n\n  ghost var contents: seq<T>\n  ghost var footprint: set<object>\n  ghost var spine: set<Node<T>>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint && spine <= footprint &&\n    head in spine &&\n    tail in spine &&\n    tail.next == null &&\n    (forall n ::\n      n in spine ==>\n        n.footprint <= footprint && this !in n.footprint &&\n        n.Valid() &&\n        (n.next == null ==> n == tail)) &&\n    (forall n ::\n      n in spine ==>\n        n.next != null ==> n.next in spine) &&\n    contents == head.tailContents\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures |contents| == 0\n  {\n    var n: Node<T> := new Node<T>.Init();\n    head := n;\n    tail := n;\n    contents := n.tailContents;\n    footprint := {this} + n.footprint;\n    spine := {n};\n  }\n\n\n\n\n  method Enqueue(t: T)\n    requires Valid()\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents) + [t]\n  {\n    var n := new Node<T>.Init();\n    n.data := t;\n    tail.next := n;\n    tail := n;\n\n    forall m | m in spine {\n      m.tailContents := m.tailContents + [t];\n    }\n    contents := head.tailContents;\n\n    forall m | m in spine {\n      m.footprint := m.footprint + n.footprint;\n    }\n    footprint := footprint + n.footprint;\n\n    spine := spine + {n};\n  }\n\n  method Front() returns (t: T)\n    requires Valid()\n    requires 0 < |contents|\n    ensures t == contents[0]\n  {\n    t := head.next.data;\n  }\n\n  method Dequeue()\n    requires Valid()\n    requires 0 < |contents|\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents)[1..]\n  {\n    var n := head.next;\n    head := n;\n    contents := n.tailContents;\n  }\n}\n\nclass Node<T(0)> {\n  var data: T\n  var next: Node?<T>\n\n  ghost var tailContents: seq<T>\n  ghost var footprint: set<object>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint &&\n    (next != null ==> next in footprint && next.footprint <= footprint) &&\n    (next == null ==> tailContents == []) &&\n    (next != null ==> tailContents == [next.data] + next.tailContents)\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures next == null\n  {\n    next := null;\n    tailContents := [];\n    footprint := {this};\n  }\n}\n\nclass Main<U(0)> {\n  method A<T(0)>(t: T, u: T, v: T)\n  {\n    var q0 := new Queue<T>.Init();\n    var q1 := new Queue<T>.Init();\n\n    q0.Enqueue(t);\n    q0.Enqueue(u);\n\n    q1.Enqueue(v);\n\n    assert |q0.contents| == 2;\n\n    var w := q0.Front();\n    assert w == t;\n    q0.Dequeue();\n\n    w := q0.Front();\n    assert w == u;\n\n    assert |q0.contents| == 1;\n    assert |q1.contents| == 1;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Main2(t: U, u: U, v: U, q0: Queue<U>, q1: Queue<U>)\n    requires q0.Valid()\n    requires q1.Valid()\n    requires q0.footprint !! q1.footprint\n    requires |q0.contents| == 0\n    modifies q0.footprint, q1.footprint\n    ensures fresh(q0.footprint - old(q0.footprint))\n    ensures fresh(q1.footprint - old(q1.footprint))", "vc-code": "{\n    q0.Enqueue(t);\n    q0.Enqueue(u);\n\n    q1.Enqueue(v);\n\n    assert |q0.contents| == 2;\n\n    var w := q0.Front();\n    assert w == t;\n    q0.Dequeue();\n\n    w := q0.Front();\n    assert w == u;\n\n    assert |q0.contents| == 1;\n    assert |q1.contents| == old(|q1.contents|) + 1;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0397", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_Queue_Rotate", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Queue.dfy\n// Dafny version of Queue.bpl\n// Rustan Leino, 2008\n\nclass Queue<T(0)> {\n  var head: Node<T>\n  var tail: Node<T>\n\n  ghost var contents: seq<T>\n  ghost var footprint: set<object>\n  ghost var spine: set<Node<T>>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint && spine <= footprint &&\n    head in spine &&\n    tail in spine &&\n    tail.next == null &&\n    (forall n ::\n      n in spine ==>\n        n.footprint <= footprint && this !in n.footprint &&\n        n.Valid() &&\n        (n.next == null ==> n == tail)) &&\n    (forall n ::\n      n in spine ==>\n        n.next != null ==> n.next in spine) &&\n    contents == head.tailContents\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures |contents| == 0\n  {\n    var n: Node<T> := new Node<T>.Init();\n    head := n;\n    tail := n;\n    contents := n.tailContents;\n    footprint := {this} + n.footprint;\n    spine := {n};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Rotate()\n    requires Valid()\n    requires 0 < |contents|\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents)[1..] + old(contents)[..1]", "vc-code": "{\n    var t := Front();\n    Dequeue();\n    Enqueue(t);\n}", "vc-postamble": "method Enqueue(t: T)\n    requires Valid()\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents) + [t]\n  {\n    var n := new Node<T>.Init();\n    n.data := t;\n    tail.next := n;\n    tail := n;\n\n    forall m | m in spine {\n      m.tailContents := m.tailContents + [t];\n    }\n    contents := head.tailContents;\n\n    forall m | m in spine {\n      m.footprint := m.footprint + n.footprint;\n    }\n    footprint := footprint + n.footprint;\n\n    spine := spine + {n};\n  }\n\n  method Front() returns (t: T)\n    requires Valid()\n    requires 0 < |contents|\n    ensures t == contents[0]\n  {\n    t := head.next.data;\n  }\n\n  method Dequeue()\n    requires Valid()\n    requires 0 < |contents|\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents)[1..]\n  {\n    var n := head.next;\n    head := n;\n    contents := n.tailContents;\n  }\n}\n\nclass Node<T(0)> {\n  var data: T\n  var next: Node?<T>\n\n  ghost var tailContents: seq<T>\n  ghost var footprint: set<object>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint &&\n    (next != null ==> next in footprint && next.footprint <= footprint) &&\n    (next == null ==> tailContents == []) &&\n    (next != null ==> tailContents == [next.data] + next.tailContents)\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures next == null\n  {\n    next := null;\n    tailContents := [];\n    footprint := {this};\n  }\n}\n\nclass Main<U(0)> {\n  method A<T(0)>(t: T, u: T, v: T)\n  {\n    var q0 := new Queue<T>.Init();\n    var q1 := new Queue<T>.Init();\n\n    q0.Enqueue(t);\n    q0.Enqueue(u);\n\n    q1.Enqueue(v);\n\n    assert |q0.contents| == 2;\n\n    var w := q0.Front();\n    assert w == t;\n    q0.Dequeue();\n\n    w := q0.Front();\n    assert w == u;\n\n    assert |q0.contents| == 1;\n    assert |q1.contents| == 1;\n  }\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0398", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny1_Queue_RotateAny", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Queue.dfy\n// Dafny version of Queue.bpl\n// Rustan Leino, 2008\n\nclass Queue<T(0)> {\n  var head: Node<T>\n  var tail: Node<T>\n\n  ghost var contents: seq<T>\n  ghost var footprint: set<object>\n  ghost var spine: set<Node<T>>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint && spine <= footprint &&\n    head in spine &&\n    tail in spine &&\n    tail.next == null &&\n    (forall n ::\n      n in spine ==>\n        n.footprint <= footprint && this !in n.footprint &&\n        n.Valid() &&\n        (n.next == null ==> n == tail)) &&\n    (forall n ::\n      n in spine ==>\n        n.next != null ==> n.next in spine) &&\n    contents == head.tailContents\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures |contents| == 0\n  {\n    var n: Node<T> := new Node<T>.Init();\n    head := n;\n    tail := n;\n    contents := n.tailContents;\n    footprint := {this} + n.footprint;\n    spine := {n};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RotateAny()\n    requires Valid()\n    requires 0 < |contents|\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures |contents| == |old(contents)|\n    ensures exists i :: 0 <= i && i <= |contents| &&\n              contents == old(contents)[i..] + old(contents)[..i]", "vc-code": "{\n    var t := Front();\n    Dequeue();\n    Enqueue(t);\n}", "vc-postamble": "method Enqueue(t: T)\n    requires Valid()\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents) + [t]\n  {\n    var n := new Node<T>.Init();\n    n.data := t;\n    tail.next := n;\n    tail := n;\n\n    forall m | m in spine {\n      m.tailContents := m.tailContents + [t];\n    }\n    contents := head.tailContents;\n\n    forall m | m in spine {\n      m.footprint := m.footprint + n.footprint;\n    }\n    footprint := footprint + n.footprint;\n\n    spine := spine + {n};\n  }\n\n  method Front() returns (t: T)\n    requires Valid()\n    requires 0 < |contents|\n    ensures t == contents[0]\n  {\n    t := head.next.data;\n  }\n\n  method Dequeue()\n    requires Valid()\n    requires 0 < |contents|\n    modifies footprint\n    ensures Valid() && fresh(footprint - old(footprint))\n    ensures contents == old(contents)[1..]\n  {\n    var n := head.next;\n    head := n;\n    contents := n.tailContents;\n  }\n}\n\nclass Node<T(0)> {\n  var data: T\n  var next: Node?<T>\n\n  ghost var tailContents: seq<T>\n  ghost var footprint: set<object>\n\n  ghost predicate Valid()\n    reads this, footprint\n  {\n    this in footprint &&\n    (next != null ==> next in footprint && next.footprint <= footprint) &&\n    (next == null ==> tailContents == []) &&\n    (next != null ==> tailContents == [next.data] + next.tailContents)\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(footprint - {this})\n    ensures next == null\n  {\n    next := null;\n    tailContents := [];\n    footprint := {this};\n  }\n}\n\nclass Main<U(0)> {\n  method A<T(0)>(t: T, u: T, v: T)\n  {\n    var q0 := new Queue<T>.Init();\n    var q1 := new Queue<T>.Init();\n\n    q0.Enqueue(t);\n    q0.Enqueue(u);\n\n    q1.Enqueue(v);\n\n    assert |q0.contents| == 2;\n\n    var w := q0.Front();\n    assert w == t;\n    q0.Dequeue();\n\n    w := q0.Front();\n    assert w == u;\n\n    assert |q0.contents| == 1;\n    assert |q1.contents| == 1;\n  }\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0399", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_COST-verif-comp-2011-2-MaxTree-class_ComputeMax", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\n\n/*\nRustan Leino, 5 Oct 2011\n\nCOST Verification Competition, Challenge 2: Maximum in a tree\nhttp://foveoos2011.cost-ic0701.org/verification-competition\n\nGiven: A non-empty binary tree, where every node carries an integer.\n\nImplement and verify a program that computes the maximum of the values\nin the tree.\n\nPlease base your program on the following data structure signature:\n\npublic class Tree {\n    int value;\n    Tree left;\n    Tree right;\n}\n\nYou may represent empty trees as null references or as you consider\nappropriate.\n*/\n\n// Remarks:\n\n// The specification of this program uses the common dynamic-frames idiom in Dafny:  the\n// ghost field 'Contents' stores the abstract value of an object, the ghost field 'Repr'\n// stores the set of (references to) objects that make up the representation of the object\n// (which in this case is the Tree itself plus the 'Repr' sets of the left and right\n// subtrees), and a function 'Valid()' that returns 'true' when an object is in a\n// consistent state (that is, when an object satisfies the \"class invariant\").\n\n// The design I used was to represent an empty tree as a Tree object whose left and\n// right pointers point to the object iself.  This is convenient, because it lets\n// clients of Tree and the implementation of Tree always use non-null pointers to\n// Tree objects.\n\n// What needs to be human-trusted about this program is that the 'requires' and\n// 'ensures' clauses (that is, the pre- and postconditions, respectively) of\n// 'ComputeMax' are correct.  And, since the specification talks about the ghost\n// variable 'Contents', one also needs to trust that the 'Valid()' function\n// constrains 'Contents' in a way that a human thinks matches the intuitive\n// definition of what the contents of a tree is.\n\n// To give a taste of that the 'Valid()' function does not over-constrain the\n// object, I have included two instance constructors, 'Empty()' and 'Node(...)'.\n// To take this a step further, one could also write a 'Main' method that\n// builds somme tree and then calls 'ComputeMax', but I didn't do that here.\n\n// About Dafny:\n// As always (when it is successful), Dafny verifies that the program does not\n// cause any run-time errors (like array index bounds errors), that the program\n// terminates, that expressions and functions are well defined, and that all\n// specifications are satisfied.  The language prevents type errors by being type\n// safe, prevents dangling pointers by not having an \"address-of\" or \"deallocate\"\n// operation (which is accommodated at run time by a garbage collector), and\n// prevents arithmetic overflow errors by using mathematical integers (which\n// is accommodated at run time by using BigNum's).  By proving that programs\n// terminate, Dafny proves that a program's time usage is finite, which implies\n// that the program's space usage is finite too.  However, executing the\n// program may fall short of your hopes if you don't have enough time or\n// space; that is, the program may run out of space or may fail to terminate in\n// your lifetime, because Dafny does not prove that the time or space needed by\n// the program matches your execution environment.  The only input fed to\n// the Dafny verifier/compiler is the program text below; Dafny then automatically\n// verifies and compiles the program (for this program in less than 2.5 seconds)\n// without further human intervention.\n\nclass Tree {\n  // an empty tree is represented by a Tree object with left==this==right\n  var value: int\n  var left: Tree?\n  var right: Tree?\n\n  ghost var Contents: seq<int>\n  ghost var Repr: set<object>\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    left != null && right != null &&\n    ((left == this == right && Contents == []) ||\n     (left in Repr && left.Repr <= Repr && this !in left.Repr &&\n      right in Repr && right.Repr <= Repr && this !in right.Repr &&\n      left.Valid() && right.Valid() &&\n      Contents == left.Contents + [value] + right.Contents))\n  }\n\n  function IsEmpty(): bool\n    requires Valid();\n    reads this, Repr;\n    ensures IsEmpty() <==> Contents == [];\n  {\n    left == this\n  }\n\n  constructor Empty()\n    ensures Valid() && Contents == [];\n  {\n    left, right := this, this;\n    Contents := [];\n    Repr := {this};\n  }\n\n  constructor Node(lft: Tree, val: int, rgt: Tree)\n    requires lft.Valid() && rgt.Valid();\n    ensures Valid() && Contents == lft.Contents + [val] + rgt.Contents;\n  {\n    left, value, right := lft, val, rgt;\n    Contents := lft.Contents + [val] + rgt.Contents;\n    Repr := lft.Repr + {this} + rgt.Repr;\n  }\n\n  lemma exists_intro<T>(P: T ~> bool, x: T)\n    requires P.requires(x)\n    requires P(x)\n    ensures exists y :: P.requires(y) && P(y)\n  {\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeMax() returns (mx: int)\n    requires Valid() && !IsEmpty();\n    ensures forall x :: x in Contents ==> x <= mx;\n    ensures exists x :: x in Contents && x == mx;\n    decreases Repr;", "vc-code": "{\n    mx := value;\n\n    if (!left.IsEmpty()) {\n      var m := left.ComputeMax();\n      mx := if mx < m  then m else mx;\n    }\n\n    if (!right.IsEmpty()) {\n      var m := right.ComputeMax();\n      mx := if mx < m then m else mx;\n    }\n\n    exists_intro(x reads this => x in Contents && x == mx, mx);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0401", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny2_Classics_AdditiveFactorial", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\" -- --warn-deprecation:false\n\n\n// A version of Turing's additive factorial program [Dr. A. Turing, \"Checking a large routine\",\n// In \"Report of a Conference of High Speed Automatic Calculating Machines\", pp. 67-69, 1949].\n\nghost function Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AdditiveFactorial(n: nat) returns (u: nat)\n  ensures u == Factorial(n);", "vc-code": "{\n  u := 1;\n  var r := 0;\n  while (r < n)\n    invariant 0 <= r <= n;\n    invariant u == Factorial(r);\n  {\n    var v := u;\n    var s := 1;\n    while (s <= r)\n      invariant 1 <= s <= r+1;\n      invariant u == s * Factorial(r);\n    {\n      u := u + v;\n      s := s + 1;\n    }\n    r := r + 1;\n  }\n}", "vc-postamble": "// Hoare's FIND program [C.A.R. Hoare, \"Proof of a program: FIND\", CACM 14(1): 39-45, 1971].\n// The proof annotations here are not the same as in Hoare's article.\n\n// In Hoare's words:\n//   This program operates on an array A[1:N], and a value of f (1 <= f <= N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q (1 <= p <= f <= q <= N ==> A[p] <= A[f] <= A[q]).\n//\n// Here, we use 0-based indices, so we would say:\n//   This method operates on an array A[0..N], and a value of f (0 <= f < N).\n//   Its effect is to rearrange the elements of A in such a way that:\n//     forall p,q :: 0 <= p <= f <= q < N ==> A[p] <= A[f] <= A[q]).", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0403", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny3_CalcExample_CalculationalStyleProof", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Here is a function \"f\" and three axioms (that is, unproved lemmas) about \"f\":\n\nghost function f(x: int, y: int): int\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall x :: f(x, y) <= f(x, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n// From these axioms, we can prove a lemma about \"f\":", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x", "vc-code": "{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}", "vc-postamble": "// Here's the same lemma, but with a proof written in a different style.\n// (An explanation of the constructs in this lemma is found below.)\n\n\n// To understand the lemma above, here's what you need to know (and then some):\n//\n// * An ordinary \"assert P;\" statement instructs the verifier to verify\n//   the boolean condition \"P\" and then to assume \"P\" from here on (that\n//   is, in the control flow that continues from here).\n//\n// * An assert with a proof is written \"assert P by { S }\" where \"S\" is\n//   a list of statements (typically other assertions and lemma calls).\n//   This statement instructs the verifier to do \"S\" and then prove \"P\".\n//   Once this is done, the verifier assumes \"P\" from here on, but it\n//   \"forgets\" anything it learnt or was able to assume on account of\n//   doing \"S\". In other words, an assertion like this is like a local\n//   lemma--the proof \"S\" is used only to establish \"P\" and is then\n//   forgotten, and after the statement, only \"P\" remains. Note, the\n//   body of the \"by\" clause does \"S\" and then stops; that is, there are\n//   no control paths out of the body of the \"by\" clause.\n//\n// * An assertion (either an ordinary assertion or an assertion with a\n//   proof) can start with a label, as in:\n//\n//     assert L: P;\n//\n//   or:\n//\n//     assert L: P by { S }\n//\n//   This instructs the verifier to prove the assertion as described in the\n//   previous two bullets, but then to forget about \"P\". In other words, the\n//   difference between a labeled assertion and and an unlabeled assertion\n//   is that an unlabeled assertion ends by assuming \"P\" whereas the labeled\n//   assertion does not assume anything.\n//\n// * Syntactically, the label \"L\" in a labeled assertion is the same as in\n//   a statement prefix \"label L:\", namely, \"L\" is either an identifier or\n//   a (decimal) numeric literal.\n//\n// * The condition \"P\" proved by a labeled assertion can later be recalled\n//   using a \"reveal\" statement. The \"reveal\" statement takes a list of\n//   arguments, each of which can be a label occurring in a previous\n//   assertion.\n//\n// * A precondition (or think of it as an antecedent of a lemma) is given by\n//   a \"requires\" clause. Ordinarily, the precondition is assumed on entry\n//   to the body of a method or lemma. Like an assert statement, a precondition\n//   can also be labeled. Such a precondition is not automatically assumed on\n//   entry to the body, but can be recalled by a \"reveal\" statement.\n//\n// * Fine points: Some exclusions apply. For example, labeled preconditions are\n//   not supported for functions and cannot be used to hide/reveal conditions\n//   while checking the well-formedness of a specification. Labeled assertions are\n//   not supported in expression contexts. The \"reveal\" described is the \"reveal\"\n//   statement. A labeled assertion can be revealed only at those program points\n//   that are dominated by the assertion, that is, in places that are reached\n//   only after definitely first having reached the assertion.\n//\n// * Fine point: The label \"L\" introduced by an assertion can also be used in\n//   \"old@L(E)\" expressions, where \"E\" is an expression. However, note that\n//   \"old@L(E)\" differs from \"E\" only in how the heap is dereferenced. That is,\n//   \"old@L\" has no effect on local variables. In contrast, a labeled assertion\n//   speaks about the values of the heap and locals at the time the assertion is\n//   mentioned. So, even if the heap or locals mentioned in a labeled assertion\n//   change after the assertion is mentioned, recalling the assertion condition\n//   with a \"reveal\" statement always recall the condition with the heap and locals\n//   as they were when the assert was stated. For example, suppose \"P\" is an\n//   expression that mentions a local variable \"x\". Then, the second assertion in\n//\n//     assert L: P by { ... }\n//     x := x + 1;\n//     ...make changes to the heap...\n//     reveal L;\n//     assert old@L(P);\n//\n//   does not necessarily hold. The first assertion uses the initial value of the\n//   heap and the initial value of \"x\". Consequently, \"reveal L;\" recalls the\n//   asserted condition, with that initial heap and that initial value of \"x\",\n//   despite the fact that the code changes both \"x\" and the heap between the\n//   assert and the reveal. The expression \"old@L(P)\" essentially rolls\n//   back to the initial heap, but it uses the current value of \"x\".", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0404", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny3_CalcExample_DifferentStyleProof", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachResolver \"%s\"\n\n\n// Here is a function \"f\" and three axioms (that is, unproved lemmas) about \"f\":\n\nghost function f(x: int, y: int): int\n\nlemma Associativity(x: int, y: int, z: int)\n  ensures f(x, f(y, z)) == f(f(x, y), z)\n\nlemma Monotonicity(y: int, z: int)\n  requires y <= z\n  ensures forall x :: f(x, y) <= f(x, z)\n\nlemma DiagonalIdentity(x: int)\n  ensures f(x, x) == x\n\n// From these axioms, we can prove a lemma about \"f\":\n\nmethod CalculationalStyleProof(a: int, b: int, c: int, x: int)\n  requires c <= x == f(a, b)\n  ensures f(a, f(b, c)) <= x\n{\n  calc {\n    f(a, f(b, c));\n  ==  { Associativity(a, b, c); }\n    f(f(a, b), c);\n  ==  { assert f(a, b) == x; }\n    f(x, c);\n  <=  { assert c <= x; Monotonicity(c, x); }\n    f(x, x);\n  ==  { DiagonalIdentity(x); }\n    x;\n  }\n}\n\n// Here's the same lemma, but with a proof written in a different style.\n// (An explanation of the constructs in this lemma is found below.)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DifferentStyleProof(a: int, b: int, c: int, x: int)\n  requires A: c <= x\n  requires B: x == f(a, b)\n  ensures f(a, f(b, c)) <= x", "vc-code": "{\n  assert 0: f(a, f(b, c)) == f(f(a, b), c) by {\n    Associativity(a, b, c);\n  }\n\n  assert 1: f(f(a, b), c) == f(x, c) by {\n    reveal B;\n  }\n\n  assert 2: f(x, c) <= f(x, x) by {\n    assert c <= x by { reveal A; }\n    Monotonicity(c, x);\n  }\n\n  assert 3: f(x, x) == x by {\n    DiagonalIdentity(x);\n  }\n\n  assert 4: f(a, f(b, c)) == f(x, c) by {\n    reveal 0, 1;\n  }\n\n  assert 5: f(x, c) <= x by {\n    reveal 2, 3;\n  }\n\n  assert f(a, f(b, c)) <= x by {\n    reveal 4, 5;\n  }\n}", "vc-postamble": "// To understand the lemma above, here's what you need to know (and then some):\n//\n// * An ordinary \"assert P;\" statement instructs the verifier to verify\n//   the boolean condition \"P\" and then to assume \"P\" from here on (that\n//   is, in the control flow that continues from here).\n//\n// * An assert with a proof is written \"assert P by { S }\" where \"S\" is\n//   a list of statements (typically other assertions and lemma calls).\n//   This statement instructs the verifier to do \"S\" and then prove \"P\".\n//   Once this is done, the verifier assumes \"P\" from here on, but it\n//   \"forgets\" anything it learnt or was able to assume on account of\n//   doing \"S\". In other words, an assertion like this is like a local\n//   lemma--the proof \"S\" is used only to establish \"P\" and is then\n//   forgotten, and after the statement, only \"P\" remains. Note, the\n//   body of the \"by\" clause does \"S\" and then stops; that is, there are\n//   no control paths out of the body of the \"by\" clause.\n//\n// * An assertion (either an ordinary assertion or an assertion with a\n//   proof) can start with a label, as in:\n//\n//     assert L: P;\n//\n//   or:\n//\n//     assert L: P by { S }\n//\n//   This instructs the verifier to prove the assertion as described in the\n//   previous two bullets, but then to forget about \"P\". In other words, the\n//   difference between a labeled assertion and and an unlabeled assertion\n//   is that an unlabeled assertion ends by assuming \"P\" whereas the labeled\n//   assertion does not assume anything.\n//\n// * Syntactically, the label \"L\" in a labeled assertion is the same as in\n//   a statement prefix \"label L:\", namely, \"L\" is either an identifier or\n//   a (decimal) numeric literal.\n//\n// * The condition \"P\" proved by a labeled assertion can later be recalled\n//   using a \"reveal\" statement. The \"reveal\" statement takes a list of\n//   arguments, each of which can be a label occurring in a previous\n//   assertion.\n//\n// * A precondition (or think of it as an antecedent of a lemma) is given by\n//   a \"requires\" clause. Ordinarily, the precondition is assumed on entry\n//   to the body of a method or lemma. Like an assert statement, a precondition\n//   can also be labeled. Such a precondition is not automatically assumed on\n//   entry to the body, but can be recalled by a \"reveal\" statement.\n//\n// * Fine points: Some exclusions apply. For example, labeled preconditions are\n//   not supported for functions and cannot be used to hide/reveal conditions\n//   while checking the well-formedness of a specification. Labeled assertions are\n//   not supported in expression contexts. The \"reveal\" described is the \"reveal\"\n//   statement. A labeled assertion can be revealed only at those program points\n//   that are dominated by the assertion, that is, in places that are reached\n//   only after definitely first having reached the assertion.\n//\n// * Fine point: The label \"L\" introduced by an assertion can also be used in\n//   \"old@L(E)\" expressions, where \"E\" is an expression. However, note that\n//   \"old@L(E)\" differs from \"E\" only in how the heap is dereferenced. That is,\n//   \"old@L\" has no effect on local variables. In contrast, a labeled assertion\n//   speaks about the values of the heap and locals at the time the assertion is\n//   mentioned. So, even if the heap or locals mentioned in a labeled assertion\n//   change after the assertion is mentioned, recalling the assertion condition\n//   with a \"reveal\" statement always recall the condition with the heap and locals\n//   as they were when the assert was stated. For example, suppose \"P\" is an\n//   expression that mentions a local variable \"x\". Then, the second assertion in\n//\n//     assert L: P by { ... }\n//     x := x + 1;\n//     ...make changes to the heap...\n//     reveal L;\n//     assert old@L(P);\n//\n//   does not necessarily hold. The first assertion uses the initial value of the\n//   heap and the initial value of \"x\". Consequently, \"reveal L;\" recalls the\n//   asserted condition, with that initial heap and that initial value of \"x\",\n//   despite the fact that the code changes both \"x\" and the heap between the\n//   assert and the reveal. The expression \"old@L(P)\" essentially rolls\n//   back to the initial heap, but it uses the current value of \"x\".", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0405", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny3_Iter_Add", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachCompiler --refresh-exit-code=0 \"%s\" -- --relax-definite-assignment\n\nclass List<T> {\n  ghost var Contents: seq<T>\n  ghost var Repr: set<object>\n\n  var a: array<T>\n  var n: nat\n\n  ghost predicate Valid()\n    reads this, Repr\n    ensures Valid() ==> this in Repr\n  {\n    this in Repr &&\n    a in Repr &&\n    n <= a.Length &&\n    Contents == a[..n]\n  }\n\n  constructor Init()\n    ensures Valid() && fresh(Repr)\n    ensures Contents == []\n  {\n    Contents, n := [], 0;\n    a := new T[0];\n    Repr := {this, a};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Add(t: T)\n    requires Valid()\n    modifies Repr\n    ensures Valid() && fresh(Repr - old(Repr))\n    ensures Contents == old(Contents) + [t]", "vc-code": "{\n    if (n == a.Length) {\n      var b := new T[2 * a.Length + 1](i requires 0 <= i reads this, a =>\n                                       if i < a.Length then a[i] else t);\n      assert b[..n] == a[..n] == Contents;\n      a, Repr := b, Repr + {b};\n      assert b[..n] == Contents;\n    }\n    a[n], n, Contents := t, n + 1, Contents + [t];\n}", "vc-postamble": "}\n\nclass Cell { var data: int }\n\niterator M<T(0)>(l: List<T>, c: Cell) yields (x: T)\n  requires l.Valid()\n  reads l.Repr\n  modifies c\n  yield requires true\n  yield ensures xs <= l.Contents  // this is needed in order for the next line to be well-formed\n  yield ensures x == l.Contents[|xs|-1]\n  ensures xs == l.Contents\n{\n  var i := 0;\n  while i < l.n\n    invariant i <= l.n && i == |xs| && xs <= l.Contents\n  {\n    if (*) { assert l.Valid(); }  // this property is maintained, due to the reads clause\n    if (*) {\n      x := l.a[i]; yield;  // or, equivalently, 'yield l.a[i]'\n      i := i + 1;\n    } else {\n      x, i := l.a[i], i + 1;\n      yield;\n    }\n  }\n}\n\nmethod Client<T(==,0)>(l: List, stop: T) returns (s: seq<T>)\n  requires l.Valid()\n{\n  var c := new Cell;\n  var iter := new M(l, c);\n  s := [];\n  while true\n    invariant iter.Valid() && fresh(iter._new)\n    invariant iter.xs <= l.Contents\n    decreases |l.Contents| - |iter.xs|\n  {\n    var more := iter.MoveNext();\n    if (!more) { break; }\n    s := s + [iter.x];\n    if (iter.x == stop) { return; }  // if we ever see 'stop', then just end\n  }\n}\n\nmethod PrintSequence<T>(s: seq<T>)\n{\n  var i := 0;\n  while i < |s|\n  {\n    print s[i], \" \";\n    i := i + 1;\n  }\n  print \"\\n\";\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0406", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_from_dafny_main_repo_dafny4_ClassRefinement_Inc", "vc-description": "", "vc-preamble": "// RUN: %testDafnyForEachCompiler \"%s\" -- --relax-definite-assignment\n\nabstract module M0 {\n  class Counter {\n    ghost var N: int\n    ghost var Repr: set<object>\n    ghost predicate Valid()\n      reads this, Repr\n      ensures Valid() ==> this in Repr\n\n    constructor Init()\n      ensures N == 0\n      ensures Valid() && fresh(Repr)\n    {\n      Repr := {};\n      new;\n      ghost var repr :| {this} <= repr && fresh(repr - {this});\n      N, Repr := 0, repr;\n      assume Valid();  // to be verified in refinement module\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Inc()\n      requires Valid()\n      modifies Repr\n      ensures N == old(N) + 1\n      ensures Valid() && fresh(Repr - old(Repr))", "vc-code": "{\n      N := N + 1;\n      modify Repr - {this};\n      assume Valid();  // to be verified in refinement module\n}", "vc-postamble": "}\n}\n\nmodule M1 refines M0 {\n  class Cell {\n    var data: int\n    constructor (d: int)\n      ensures data == d\n    { data := d; }\n  }\n\n  class Counter ... {\n    var c: Cell\n    var d: Cell\n    ghost predicate Valid...\n    {\n      this in Repr &&\n      c in Repr &&\n      d in Repr &&\n      c != d &&\n      N == c.data - d.data\n    }\n\n    constructor Init...\n    {\n      c := new Cell(0);\n      d := new Cell(0);\n      new;\n      ghost var repr := Repr + {this} + {c,d};\n      ...;\n      assert ...;\n    }\n\n\n    method Get() returns (n: int)\n      requires Valid()\n      ensures n == N\n    {\n      n := c.data - d.data;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0407", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_begin_tx", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n\n    method write_log(off : int, val : int)\n        modifies this;\n        modifies log_;\n        requires 0 <= off <= |gs.log|;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires off == 0 ==> 0 <= val * 2 < |gs.log|;\n        ensures mem_ != log_;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures log_.Length == old(log_).Length;\n        ensures mem_[..] == old(mem_)[..];\n        ensures log_[off] == val || log_[off] == old(log_)[off];\n        ensures forall i :: 0 <= i < log_.Length && i != off ==> log_[i] == old(log_)[i];\n        ensures gs == old(gs);\n        ensures off > 0 ==> ghost_state_equiv(log_write_step(gs, off - 1, val).0);\n        ensures off == 0 ==> ghost_state_equiv(set_num_entry(gs, val).0);\n    {\n        if (impl_countdown > 0) {\n            log_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method begin_tx()\n        modifies log_;\n        modifies this;\n        requires state_inv();\n        requires ghost_state_equiv(gs);\n        requires ghost_state_inv(gs);\n        requires log_[0] == 0;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures state_inv();\n        ensures ghost_state_equiv(gs);\n        ensures ghost_tx_inv(gs);", "vc-code": "{\n        write_log(0, 0);\n\n        gs := ghost_begin_tx(gs);\n        assert state_inv();\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0408", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_commit_tx", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n\n    method write_log(off : int, val : int)\n        modifies this;\n        modifies log_;\n        requires 0 <= off <= |gs.log|;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires off == 0 ==> 0 <= val * 2 < |gs.log|;\n        ensures mem_ != log_;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures log_.Length == old(log_).Length;\n        ensures mem_[..] == old(mem_)[..];\n        ensures log_[off] == val || log_[off] == old(log_)[off];\n        ensures forall i :: 0 <= i < log_.Length && i != off ==> log_[i] == old(log_)[i];\n        ensures gs == old(gs);\n        ensures off > 0 ==> ghost_state_equiv(log_write_step(gs, off - 1, val).0);\n        ensures off == 0 ==> ghost_state_equiv(set_num_entry(gs, val).0);\n    {\n        if (impl_countdown > 0) {\n            log_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method commit_tx()\n        modifies log_;\n        modifies this;\n        requires state_inv();\n        requires ghost_state_equiv(gs);\n        requires ghost_state_inv(gs);\n        requires ghost_tx_inv(gs);\n        requires old_mem_equiv(gs);\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures ghost_state_equiv(gs);\n        ensures state_inv();", "vc-code": "{\n        write_log(0, 0);\n\n        gs := ghost_commit_tx(gs).0;\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0409", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_impl_countdown_dec", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method impl_countdown_dec()\n        modifies this;\n        requires impl_countdown > 0;\n        requires mem_ != log_;\n        ensures mem_ != log_;\n        ensures impl_countdown == old(impl_countdown) - 1;\n        ensures impl_countdown >= 0;\n        ensures gs == old(gs);\n        ensures log_[..] == old(log_)[..];\n        ensures mem_[..] == old(mem_)[..];", "vc-code": "{\n        impl_countdown := impl_countdown - 1;\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0410", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_init", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method init(log_size : int, mem_size : int, countdown : int)\n        requires log_size > 1;\n        requires mem_size > 0;\n        requires log_size < 0xffffffff;\n        modifies this;\n        ensures fresh(log_);\n        ensures fresh(mem_);\n        ensures state_inv();\n        ensures ghost_state_equiv(gs);", "vc-code": "{\n        log_ := new int[log_size];\n        mem_ := new int[mem_size];\n        log_[0] := 0;\n\n        impl_countdown := countdown;\n        gs := GS(0, log_[1..], mem_size, mem_[..], mem_[..], mem_[..], countdown, map[]);\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0411", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_read", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method read(off : int) returns (r : T)\n        requires 0 <= off < mem_.Length;", "vc-code": "{\n        return mem_[off];\n}", "vc-postamble": "}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n\n\n\n\n\n    // we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0412", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_recover", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n\n\n\n\n\n    // we assume that recover won't crash (though this code works when recover can fail)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method recover()\n        modifies log_;\n        modifies mem_;\n        modifies this;\n        requires state_inv();\n        requires ghost_tx_inv(gs);\n        requires old_mem_equiv(gs);\n        requires ghost_state_equiv(gs);\n        ensures gs == ghost_recover(old(gs));\n        ensures ghost_state_equiv(gs);", "vc-code": "{\n        var log_len := log_[0];\n        assert log_len == gs.num_entry;\n        if (log_len > 0) {\n            var i := log_len - 1;\n\n            ghost var gs0 := gs;\n            while i >= 0\n                modifies mem_;\n                modifies this;\n                invariant log_ == old(log_);\n                invariant mem_ == old(mem_);\n                invariant unchanged(log_);\n                invariant -1 <= i < log_len;\n                invariant |gs.log| == |gs0.log|;\n                invariant ghost_state_equiv(gs);\n                invariant ghost_tx_inv(gs);\n                invariant old_mem_equiv(gs);\n                invariant reverse_recovery(gs0, log_len) == reverse_recovery(gs, i + 1);\n                decreases i;\n            {\n                assert ghost_state_equiv(gs);\n                assert 0 <= i < log_[0];\n                var o := i * 2 + 1;\n                var off := log_[o];\n                var val := log_[o + 1];\n                mem_[off] := val;\n                assert 0 <= off < mem_.Length;\n\n                assert gs.log[i * 2] == off;\n                assert gs.log[i * 2 + 1] == val;\n                gs := gs.(mem := gs.mem[off := val]);\n                i := i - 1;\n            }\n            assert ghost_state_equiv(gs);\n        } else {\n            assert ghost_state_equiv(gs);\n        }\n        log_[0] := 0;\n        gs := ghost_recover(old(gs));\n        assert ghost_state_equiv(gs);\n}", "vc-postamble": "}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0413", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_tx_write", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n    method write_mem(off : int, val : int)\n        modifies this;\n        modifies mem_;\n        requires 0 <= off < mem_.Length;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires 0 <= off < gs.mem_len;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures gs == old(gs);\n        ensures ghost_state_equiv(mem_write_step(gs, off, val).0);\n    {\n        if (impl_countdown > 0) {\n            mem_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n    }\n\n    method write_log(off : int, val : int)\n        modifies this;\n        modifies log_;\n        requires 0 <= off <= |gs.log|;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires off == 0 ==> 0 <= val * 2 < |gs.log|;\n        ensures mem_ != log_;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures log_.Length == old(log_).Length;\n        ensures mem_[..] == old(mem_)[..];\n        ensures log_[off] == val || log_[off] == old(log_)[off];\n        ensures forall i :: 0 <= i < log_.Length && i != off ==> log_[i] == old(log_)[i];\n        ensures gs == old(gs);\n        ensures off > 0 ==> ghost_state_equiv(log_write_step(gs, off - 1, val).0);\n        ensures off == 0 ==> ghost_state_equiv(set_num_entry(gs, val).0);\n    {\n        if (impl_countdown > 0) {\n            log_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method tx_write(offset: int, val : int)\n        modifies this;\n        modifies log_;\n        modifies mem_;\n        requires state_inv();\n        requires mem_ != log_;\n        requires 0 <= offset < mem_.Length;\n        requires ghost_state_equiv(gs);\n        requires ghost_tx_inv(gs);\n        requires old_mem_equiv(gs);\n        requires 0 <= log_[0] * 2 + 3 < log_.Length;\n        ensures ghost_state_equiv(gs);\n        ensures ghost_tx_inv(gs);\n        ensures old_mem_equiv(gs);", "vc-code": "{\n        var log_idx := log_[0];\n        var log_off := log_idx * 2;\n        ghost var old_gs := gs;\n        write_log(log_off + 1, offset);\n        gs := log_write_step(gs, log_off, offset).0;\n        assert log_off + 1 > 0;\n        assert ghost_state_equiv(gs);\n        assert mem_ != log_;\n        var old_val := mem_[offset];\n        assert old_val == gs.mem[offset];\n        write_log(log_off + 2, old_val);\n\n        gs := log_write_step(gs, log_off + 1, old_val).0;\n\n        assert ghost_tx_inv(gs);\n        assert log_[0] == gs.num_entry;\n        assert log_.Length == |gs.log| + 1;\n        assert 0 <= gs.num_entry * 2 < |gs.log|;\n\n        write_log(0, log_idx + 1);\n\n        ghost var (s, f) := set_num_entry(gs, log_idx + 1);\n        s := if f && !(offset in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[offset := log_idx])\n             else s;\n        gs := s;\n        write_mem(offset, val);\n        gs := mem_write_step(gs, offset, val).0;\n\n        assert gs == ghost_tx_write(old_gs, offset, val);\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0414", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_write", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method write(off : int, val : T)\n        requires 0 <= off < mem_.Length;\n        modifies mem_;", "vc-code": "{\n        mem_[off] := val;\n}", "vc-postamble": "}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }\n\n\n\n\n\n\n\n\n    // we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0415", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_write_log", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method write_log(off : int, val : int)\n        modifies this;\n        modifies log_;\n        requires 0 <= off <= |gs.log|;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires off == 0 ==> 0 <= val * 2 < |gs.log|;\n        ensures mem_ != log_;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures log_.Length == old(log_).Length;\n        ensures mem_[..] == old(mem_)[..];\n        ensures log_[off] == val || log_[off] == old(log_)[off];\n        ensures forall i :: 0 <= i < log_.Length && i != off ==> log_[i] == old(log_)[i];\n        ensures gs == old(gs);\n        ensures off > 0 ==> ghost_state_equiv(log_write_step(gs, off - 1, val).0);\n        ensures off == 0 ==> ghost_state_equiv(set_num_entry(gs, val).0);", "vc-code": "{\n        if (impl_countdown > 0) {\n            log_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0416", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_lightening_verifier_write_mem", "vc-description": "", "vc-preamble": "class CrashableMem<T> {\n    var mem_ : array<T>;\n\n}\n\ndatatype GhostState = GS(\n    num_entry : int,\n    log : seq<int>,\n\n    mem_len : int,\n    mem : seq<int>,\n    old_mem : seq<int>,\n    ideal_mem : seq<int>,\n    countdown : int,\n    first_log_pos : map<int, int>\n)\n\ndatatype GhostOp = WriteMem(off : int, val : int)\n                 | WriteLog(off : int, val : int)\npredicate ghost_state_inv(s : GhostState) {\n    0 <= s.num_entry * 2 < |s.log|\n    && |s.log| > 0\n    && |s.mem| == s.mem_len && |s.ideal_mem| == s.mem_len && |s.old_mem| == s.mem_len\n    && s.countdown >= 0\n}\n\nfunction init_ghost_state(log : seq<int>, mem : seq<int>, countdown : int) : GhostState\n    requires |log| > 0;\n    requires countdown >= 0;\n    ensures ghost_state_inv(init_ghost_state(log, mem, countdown));\n{\n    GS(0, log[..], |mem|, mem[..], mem[..], mem[..], countdown, map[])\n}\n\nfunction mem_write(s : GhostState, off: int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < s.mem_len;\n    ensures ghost_state_inv(mem_write(s, off, val));\n{\n    var new_mem := s.mem[off := val];\n    var new_ideal_mem := s.ideal_mem[off := val];\n    s.(mem := new_mem,\n       ideal_mem := new_ideal_mem)\n}\n\nfunction log_write(s : GhostState, off : int, val: int) : GhostState\n    requires ghost_state_inv(s);\n    requires 0 <= off < |s.log|;\n    ensures ghost_state_inv(log_write(s, off, val));\n{\n     s.(log := s.log[off := val])\n}\n\npredicate valid_op(s : GhostState, op : GhostOp)\n{\n    match op\n    case WriteMem(off, val) => 0 <= off < |s.mem|\n    case WriteLog(off, val) => 0 <= off < |s.log|\n}\n\nfunction countdown (s : GhostState) : GhostState\n{\n    if s.countdown > 0 then\n        s.(countdown := s.countdown - 1)\n    else\n        s\n}\n\nfunction normal_step (s : GhostState, op : GhostOp) : GhostState\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    match op\n    case WriteMem(off, val) => mem_write(s, off, val)\n    case WriteLog(off, val) => log_write(s, off, val)\n}\n\nfunction ghost_step (s : GhostState, op : GhostOp) : (GhostState, bool)\n    requires valid_op(s, op);\n    requires ghost_state_inv(s);\n    ensures ghost_state_inv(normal_step(s, op));\n{\n    if s.countdown > 0 then\n        var s' := normal_step(s, op);\n        (s'.(countdown := s.countdown - 1), true)\n    else\n        (s, false)\n}\n\nfunction mem_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < s.mem_len;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteMem(off, val))\n}\n\nfunction log_write_step (s : GhostState, off : int, val : int) : (GhostState, bool)\n    requires 0 <= off < |s.log|;\n    requires ghost_state_inv(s);\n{\n    ghost_step(s, WriteLog(off, val))\n}\n\nfunction set_num_entry (s : GhostState, n : int) : (GhostState, bool)\n    requires 0 <= n * 2 < |s.log|;\n{\n    if s.countdown > 0 then\n        (s.(num_entry := n,\n            countdown := s.countdown - 1),\n        true)\n    else\n        (s, false)\n}\n\npredicate crashed (s : GhostState)\n{\n    s.countdown <= 0\n}\n\npredicate old_mem_equiv (s : GhostState)\n    requires ghost_state_inv(s);\n{\n    (forall o :: !(o in s.first_log_pos) && 0 <= o < |s.mem| ==> s.mem[o] == s.old_mem[o])\n}\n\npredicate ghost_tx_inv (s : GhostState)\n{\n    ghost_state_inv(s) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= o < s.mem_len) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] < s.num_entry) &&\n    (forall o :: o in s.first_log_pos ==> 0 <= s.first_log_pos[o] * 2 + 1 < |s.log|) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2] == o) &&\n    (forall o :: o in s.first_log_pos ==> s.log[s.first_log_pos[o] * 2 + 1] == s.old_mem[o]) &&\n    (forall o :: o in s.first_log_pos ==> forall i :: 0 <= i < s.first_log_pos[o] ==> s.log[i * 2] != o) &&\n    (forall i :: 0 <= i < s.num_entry ==> s.log[i * 2] in s.first_log_pos)\n}\n\nfunction ghost_begin_tx (s : GhostState) : GhostState\n    requires ghost_state_inv(s);\n    requires s.num_entry == 0;\n    ensures ghost_state_inv(ghost_begin_tx(s));\n    ensures ghost_tx_inv(ghost_begin_tx(s));\n    ensures old_mem_equiv(ghost_begin_tx(s));\n{\n    var (s', f) := set_num_entry(s, 0);\n    var s' := s'.(first_log_pos := map[], old_mem := s.mem[..]);\n    s'\n}\n\nfunction ghost_commit_tx (s : GhostState) : (GhostState, bool)\n    requires ghost_tx_inv(s);\n    requires old_mem_equiv(s);\n    ensures ghost_state_inv(ghost_commit_tx(s).0);\n    ensures ghost_tx_inv(ghost_commit_tx(s).0);\n    ensures !ghost_commit_tx(s).1 ==> old_mem_equiv(ghost_commit_tx(s).0);\n    ensures ghost_commit_tx(s).1 ==> ghost_commit_tx(s).0.num_entry == 0;\n{\n    var s' := s;\n    var (s', f) := set_num_entry(s', 0);\n    var s' := if f then s'.(first_log_pos := map[]) else s';\n    (s', f)\n}\n\nfunction ghost_tx_write (s0 : GhostState, off : int, val : int) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= off < s0.mem_len;\n    requires 0 <= s0.num_entry * 2 + 2 < |s0.log|;\n    ensures ghost_tx_inv(ghost_tx_write(s0, off, val));\n    ensures old_mem_equiv(ghost_tx_write(s0, off, val));\n    ensures |ghost_tx_write(s0, off, val).mem| == s0.mem_len;\n    ensures !crashed(ghost_tx_write(s0, off, val)) ==> ghost_tx_write(s0, off, val).mem[off] == val;\n{\n    var s := s0;\n    var log_idx := s.num_entry;\n    var log_off := log_idx * 2;\n    var old_val := s.mem[off];\n    var (s, f) := log_write_step(s, log_off, off);\n    var (s, f) := log_write_step(s, log_off + 1, old_val);\n    var (s, f) := set_num_entry(s, log_idx + 1);\n    var s := if f && !(off in s.first_log_pos)\n             then s.(first_log_pos := s.first_log_pos[off := log_idx])\n             else s;\n    var (s, f) := mem_write_step(s, off, val);\n    s\n}\n\nfunction reverse_recovery (s0 : GhostState, idx : int) : GhostState\n    decreases idx;\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    requires 0 <= idx <= s0.num_entry;\n    ensures ghost_tx_inv(reverse_recovery(s0, idx));\n    ensures old_mem_equiv(reverse_recovery(s0, idx));\n    ensures s0.old_mem == reverse_recovery(s0, idx).old_mem;\n    ensures s0.first_log_pos == reverse_recovery(s0, idx).first_log_pos;\n    ensures forall o :: o in s0.first_log_pos && s0.first_log_pos[o] >= idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.mem[o];\n    ensures forall o :: o in s0.first_log_pos && 0 <= s0.first_log_pos[o] < idx ==>\n                reverse_recovery(s0, idx).mem[o] == s0.old_mem[o];\n{\n    if idx == 0 then\n        assert old_mem_equiv(s0);\n        s0\n    else\n        var s := s0;\n        var i := idx - 1;\n        var off := s.log[i * 2];\n        var val := s.log[i * 2 + 1];\n        var s := s.(mem := s.mem[off := val]);\n        assert off in s.first_log_pos;\n        var s := reverse_recovery(s, idx - 1);\n        assert i == idx - 1;\n        assert forall o :: o in s.first_log_pos && 0 <= s.first_log_pos[o] < i ==>\n                   s.mem[o] == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   o == off && val == s.old_mem[o];\n        assert forall o :: o in s.first_log_pos && s.first_log_pos[o] == i ==>\n                   s.mem[o] == val;\n        assert old_mem_equiv(s);\n        s\n}\n\nfunction ghost_recover (s0 : GhostState) : GhostState\n    requires ghost_tx_inv(s0);\n    requires old_mem_equiv(s0);\n    ensures ghost_recover(s0).mem == s0.old_mem;\n    ensures ghost_recover(s0).num_entry == 0;\n{\n    var s := reverse_recovery(s0, s0.num_entry);\n    assert (old_mem_equiv(s));\n    assert (forall o :: o in s.first_log_pos ==> s.mem[o] == s0.old_mem[o]);\n    assert forall i :: 0 <= i < |s.mem| ==> s.mem[i] == s0.old_mem[i];\n    s.(num_entry := 0)\n}\n\n\nclass UndoLog {\n    var log_ : array<int>;\n    var mem_ : array<int>;\n\n    var impl_countdown : int;\n    ghost var gs : GhostState;\n\n    constructor () {}\n\n    predicate ghost_state_equiv(gs : GhostState)\n        reads this;\n        reads mem_;\n        reads log_;\n    {\n        log_.Length > 0 &&\n        mem_[..] == gs.mem &&\n        log_[1..] == gs.log &&\n        log_[0] == gs.num_entry &&\n        impl_countdown == gs.countdown\n    }\n    predicate state_inv()\n        reads this;\n        reads log_;\n    {\n        log_.Length > 1 && 0 <= log_[0] && (log_[0] * 2) < log_.Length\n        && log_.Length < 0xffffffff && mem_ != log_\n        && forall i : int :: 0 <= i < log_[0] ==> 0 <= log_[i * 2 + 1] < mem_.Length\n        && impl_countdown >= 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method write_mem(off : int, val : int)\n        modifies this;\n        modifies mem_;\n        requires 0 <= off < mem_.Length;\n        requires mem_ != log_;\n        requires ghost_state_inv(gs);\n        requires ghost_state_equiv(gs);\n        requires 0 <= off < gs.mem_len;\n        ensures mem_ == old(mem_);\n        ensures log_ == old(log_);\n        ensures gs == old(gs);\n        ensures ghost_state_equiv(mem_write_step(gs, off, val).0);", "vc-code": "{\n        if (impl_countdown > 0) {\n            mem_[off] := val;\n            impl_countdown := impl_countdown - 1;\n        }\n}", "vc-postamble": "// we assume that recover won't crash (though this code works when recover can fail)\n}\n\nlemma crash_safe_single_tx(init_log : seq<int>, init_mem : seq<int>,\n                           countdown : int,\n                           writes : seq<(int, int)>)\n    requires |init_log| > 0;\n    requires countdown >= 0;\n    requires forall i :: 0 <= i < |writes| ==>\n                0 <= writes[i].0 < |init_mem|;\n    requires 0 < |writes| * 2 < |init_log|;\n{\n    var s := init_ghost_state(init_log, init_mem, countdown);\n\n    var end_mem := init_mem;\n\n    s := ghost_begin_tx(s);\n    assert s.num_entry == 0;\n    assert init_mem == s.old_mem;\n\n    var i := 0;\n    while i < |writes|\n        decreases |writes| - i;\n        invariant 0 <= i <= |writes|;\n        invariant s.mem_len == |init_mem|;\n        invariant s.mem_len == |end_mem|;\n        invariant 0 <= s.num_entry <= i;\n        invariant |init_log| == |s.log|;\n        invariant i * 2 < |s.log|;\n        invariant 0 <= s.num_entry * 2 < |s.log|;\n        invariant ghost_tx_inv(s);\n        invariant old_mem_equiv(s);\n        invariant init_mem == s.old_mem;\n        invariant !crashed(s) ==> forall i :: 0 <= i < |s.mem| ==> s.mem[i] == end_mem[i];\n    {\n        assert 0 <= i < |writes|;\n        assert 0 <= writes[i].0 < s.mem_len;\n        assert 0 <= s.num_entry * 2 + 2 < |s.log|;\n        s := ghost_tx_write(s, writes[i].0, writes[i].1);\n\n        end_mem := end_mem[writes[i].0 := writes[i].1];\n\n        assert !crashed(s) ==> s.mem[writes[i].0] == writes[i].1;\n        i := i + 1;\n    }\n\n    assert ghost_tx_inv(s);\n    assert old_mem_equiv(s);\n\n    var (s', c) := ghost_commit_tx(s);\n    assert c ==> !crashed(s);\n\n    if (c) {\n        assert !crashed(s);\n        assert s.mem == end_mem;\n    } else {\n        var recovered := ghost_recover(s');\n        assert recovered.mem == init_mem;\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0418", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel_algorithms_skeleton_nondet-permutation_Generate", "vc-description": "", "vc-preamble": "﻿module Permutation\n{\n    predicate distinct'(a: array<int>, n: nat)\n        requires a.Length == n\n        reads a\n    {\n        forall i, j :: 0 <= i < j < n ==> a[i] != a[j]\n    }\n\n    predicate distinct_prefix(a: array<int>, k: nat)\n        requires a != null && k <= a.Length\n        reads a\n    {\n        forall i, j :: 0 <= i < j < k ==> a[i] != a[j]\n    }\n\n    predicate distinct(a: array<int>)\n        requires a != null\n        reads a\n    {\n        distinct'(a, a.Length)\n    }\n\n   predicate isValid(a: array<int>, n: nat)\n    requires a != null && a.Length == n\n    reads a\n    {\n        distinct(a)\n        && (forall i :: 0 <= i < a.Length ==> 0 <= a[i] < n)\n        && (forall i :: 0 <= i < n ==> i in a[..])\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Generate(n: int) returns (perm: array<int>)\n        requires n >= 0\n        ensures perm != null\n        ensures perm.Length == n\n        ensures fresh(perm)\n        ensures isValid(perm, n)", "vc-code": "{\n        var all := set x | 0 <= x < n;\n        var used := {};\n        perm := new int[n];\n\n        CardinalityLemma(n, all);\n\n        while used < all\n            invariant used <= all\n            invariant |used| <= |all|\n            invariant forall i | 0 <= i < |used| :: perm[i] in used\n            invariant distinct_prefix(perm, |used|)\n            decreases |all| - |used|\n        {\n            CardinalityOrderingLemma(used, all);\n\n            var dst :| dst in all && dst !in used;\n            perm[|used|] := dst;\n            used := used + {dst};\n        }\n        assert used == all;\n        print perm[..];\n        assume false;\n}", "vc-postamble": "lemma CardinalityLemma (size: int, s: set<int>)\n        requires size >= 0\n        requires s == set x | 0 <= x < size\n        ensures size == |s|\n    {\n        if size == 0 {\n            assert size == |(set x | 0 <= x < size)|;\n        } else {\n            CardinalityLemma(size - 1, s - {size - 1});\n        }\n    }\n\n    lemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n        requires s1 < s2\n        ensures |s1| < |s2|\n    {\n        var e :| e in s2 - s1;\n        if s1 != s2 - {e} {\n            CardinalityOrderingLemma(s1, s2 - {e});\n        }\n    }\n\n    lemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n        requires s1 < s2\n        ensures s2 - s1 != {}\n    {\n        var e :| e in s2 - s1;\n        if s2 - s1 != {e} { }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0419", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire_project_original_Searching_Find", "vc-description": "", "vc-preamble": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key", "vc-code": "{\n   index := 0;\n   while index < blood.Length\n      invariant 0 <= index <= blood.Length\n      invariant forall k :: 0 <= k < index ==> blood[k] != key\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0420", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant_examples_KatzManna_Determinant", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Determinant(X: array2<int>, M: int) returns (z: int)\n  requires 1 <= M;\n  requires X != null && M == X.Length0 && M == X.Length1;\n  modifies X;", "vc-code": "{\n  var y := X[1-1,1-1];\n  var a := 1;\n  while (a != M)\n    invariant 1 <= a <= M;\n  {\n    var b := a + 1;\n    while (b != M+1)\n      invariant a+1 <= b <= M+1;\n    {\n      var c := M;\n      while (c != a)\n        invariant a <= c <= M;\n      {\n        assume X[a-1,a-1] != 0;\n        X[b-1, c-1] := X[b-1,c-1] - X[b-1,a-1] / X[a-1,a-1] * X[a-1,c-1];\n        c := c - 1;\n      }\n      b := b + 1;\n    }\n    a := a + 1;\n    y := y * X[a-1,a-1];\n  }\n  z := y;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0421", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant_examples_KatzManna_Gcd", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Gcd(x1: int, x2: int)\n  requires 1 <= x1 && 1 <= x2;", "vc-code": "{\n  var y1 := x1;\n  var y2 := x2;\n  while (y1 != y2)\n    invariant 1 <= y1 && 1 <= y2;\n    decreases y1 + y2;\n  {\n    while (y1 > y2)\n      invariant 1 <= y1 && 1 <= y2;\n    {\n      y1 := y1 - y2;\n    }\n    while (y2 > y1)\n      invariant 1 <= y1 && 1 <= y2;\n    {\n      y2 := y2 - y1;\n    }\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0422", "language": "dafny", "source": "dafnybench", "source_id": "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_variant_examples_KatzManna_NinetyOne", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method NinetyOne(x: int, ghost proveFunctionalPostcondition: bool) returns (z: int)\n  ensures proveFunctionalPostcondition ==> z == if x > 101 then x-10 else 91;", "vc-code": "{\n  var y1 := x;\n  var y2 := 1;\n  while (true)\n    // the following two invariants are needed only to prove the postcondition\n    invariant proveFunctionalPostcondition ==> 100 < x ==> y1 == x;\n    invariant proveFunctionalPostcondition ==> x <= 100 < y1 && y2 == 1 ==> y1 == 101;\n    // the following two lines justify termination, as in the paper by Katz and Manna\n    invariant (y1 <= 111 && y2 >= 1) || (y1 == x && y2 == 1);\n    decreases -2*y1 + 21*y2 + 2*(if x < 111 then 111 else x);\n  {\n    if (y1 > 100) {\n      if (y2 == 1) {\n        break;\n      } else {\n        y1 := y1 - 10;\n        y2 := y2 - 1;\n      }\n    } else {\n      y1 := y1 + 11;\n      y2 := y2 + 1;\n    }\n  }\n  z := y1 - 10;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0426", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_04_Hoangkim_ex_04_Hoangkim_sumOdds", "vc-description": "", "vc-preamble": "//Problem 01", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sumOdds(n: nat) returns (sum: nat)\n    requires n > 0;\n    ensures sum == n * n;", "vc-code": "{\n    sum := 1;\n    var i := 0;\n\n    while i < n-1\n        invariant 0 <= i < n;\n        invariant sum == (i + 1) * (i + 1);\n    {\n        i := i + 1;\n        sum := sum + 2 * i + 1;\n    }\n\n    assert sum == n * n;\n}", "vc-postamble": "//problem02\n//a)", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0427", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_factIter", "vc-description": "", "vc-preamble": "//Problem01\nfunction fib(n: nat):nat\n{\n    if n < 2 then n else fib(n-2)+fib(n-1)\n}\n\n//# 2 pts\n\n//Problem02\nfunction fact(n:nat):nat\n{if n==0 then 1 else n*fact(n-1)}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method factIter(n:nat) returns (a:nat)\nrequires n >= 0;\nensures a == fact(n)", "vc-code": "{\n    a := 1;\n    var i := 1;\n    while i <= n\n        invariant 1 <= i <= n+1\n        invariant a == fact(i-1)\n    {\n        a := a * i;\n        i := i + 1;\n    }\n    assert a == fact(n);\n}", "vc-postamble": "//# 3 pts\n//Problem03\nfunction gcd(m: nat, n: nat): nat\n    requires m > 0 && n > 0\n{\n    if m == n then m\n    else if m > n then gcd(m - n, n)\n    else gcd(m, n - m)\n}\n\n//# 3 pts\n\n\n// # sum: 9 pts", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0428", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_05_Hoangkim_ex_05_Hoangkim_fibIter", "vc-description": "", "vc-preamble": "//Problem01\nfunction fib(n: nat):nat\n{\n    if n < 2 then n else fib(n-2)+fib(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method fibIter(n:nat) returns (a:nat)\nrequires n > 0\nensures a == fib(n)", "vc-code": "{\n    a := 0;\n    var b,x := 1,0;\n    while x < n \n        invariant 0 <= x <= n\n        invariant a == fib(x)\n        invariant b == fib(x+1)\n        {\n            a,b := b,a+b;\n            //why a,b := b,a+b is okay\n            //but when I write  a := b;      //# Because this  \n            //                  b := a+b;    //# is not the same  !! \n            //is error?                      //# {a = 1 , b = 2 } a := b ; b := a+b { b = 4 }, but \n            x := x+1;                        //# {a = 1 , b = 2 }   a, b := b,a+b  { b = 3 }\n        }\n    assert a == fib(n);     \n}", "vc-postamble": "//# 2 pts\n\n//Problem02\nfunction fact(n:nat):nat\n{if n==0 then 1 else n*fact(n-1)}\n\n//# 3 pts\n//Problem03\nfunction gcd(m: nat, n: nat): nat\n    requires m > 0 && n > 0\n{\n    if m == n then m\n    else if m > n then gcd(m - n, n)\n    else gcd(m, n - m)\n}\n\n//# 3 pts\n\n\n// # sum: 9 pts", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0430", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_06_Hoangkim_ex06-solution_gcdI", "vc-description": "", "vc-preamble": "ghost function gcd(x:int,y:int):int\n  requires x > 0 && y > 0 \n{\n  if x==y then x\n  else if x > y then gcd(x-y,y)\n  else gcd(x,y-x)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method gcdI(m:int, n:int) returns (d:int)\n  requires  m > 0 && n > 0\n  ensures   d == gcd(m,n)", "vc-code": "{\n  var x,y := m,n;\n        d := 1;\n  while x != y\n    decreases             x+y\n    invariant             x > 0 && y > 0\n    invariant             gcd(x,y) == gcd(m,n)   \n   { if x > y { x := x-y; } else { y := y-x; }\n   }\n  d := x;\n}", "vc-postamble": "ghost function gcd'(x:int,y:int):int\n  requires x > 0 && y > 0\n  decreases x+y,y        // x+y decreases or x+y remains unchanged while y decreases\n{\n  if x==y then x\n  else if x > y then gcd'(x-y,y)\n  else gcd'(y,x)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0434", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_07_Hoangkim_ex07_Hoangkim_swap", "vc-description": "", "vc-preamble": "//Problem01\n//a)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method swap(a: array<int>, i: nat, j: nat)\n    modifies a\n    requires a != null && a.Length > 0 && i < a.Length && j < a.Length\n    ensures a[i] == old(a[j])\n    ensures a[j] == old(a[i])", "vc-code": "{\n    a[i], a[j] := a[j], a[i];\n}", "vc-postamble": "//b)\n//Problem04\n\n//Problem02\nghost predicate sorted(a:seq<int>)\n{\n    forall i | 0 < i < |a| :: a[i-1] <= a[i]     \n}\n\n\n\n//Problem03", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0436", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_square0", "vc-description": "", "vc-preamble": "//Problem01", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method square0(n:nat) returns (sqn : nat)\nensures sqn == n*n", "vc-code": "{\n    sqn := 0;\n    var i:= 0;\n    var x;\n    while i < n\n    invariant i <= n && sqn == i*i \n    {\n        x := 2*i+1;\n        sqn := sqn+x;\n        i := i+1;\n    }\n}", "vc-postamble": "/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/\n\n\n//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b) {true}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0437", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_PVS_Assignment_ex_10_Hoangkim_ex10_hoangkim_square1", "vc-description": "", "vc-preamble": "//Problem01\n\n/*\n3 Verification conditions\n\n1. VC1: Precondiotion implies the loop variant\nn ∈ ℕ => sqn = 0*0 ∧ i = 0 ∧ x=? ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ i = 0 ∧ i≤n \nn >= 0 => 0 = 0*0 ∧ 0 ≤ n \n2. VC2: Loop invariant and loop guard preserve the loop invariant.\nVC2: i < n ∧ i+1 ≤ n ∧ sqn = i * i ⇒ sqn = sqn + x ∧ i = i + 1 ∧ x = 2 * i + 1\n3.VC3: Loop terminates, and the loop invariant implies the postcondition.\nVC3: ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n\n\nSimplified VC for square0\n1. true, since 0 = 0 and n >= 0 => 0 ≤ n\n2. true, i < n => i + 1 <= n\n3. true, ¬(i < n) ∧ i ≤ n ∧ sqn = i * i ⇒ sqn = n * n since ¬(i < n) ∧ i ≤ n imply i = n\n\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method square1(n:nat) returns (sqn : nat)\nensures sqn == n*n", "vc-code": "{\n    sqn := 0;\n    var i:= 0;\n\n    while i < n\n    invariant i <= n && sqn == i*i \n    {\n        var x := 2*i+1;\n        sqn := sqn+x;\n        i := i+1;\n    }\n}", "vc-postamble": "//Problem02\n//As you can see below, Dafny claims that after executing the following method\n//strange() we will have that 1=2;\n/*(a). Do you have an explanation for this behaviour?\n    Answer: \n    the method strange() doesn't have any input or output. This method initializes\n    variable x with value 4. Then it calculates variable c as a result of calling\n    method 'q' with x as first var and 2*x as second var.the strange method does not \n    specify any postcondition. Therefore, we cannot make any assumptions about the \n    behavior or the value of c after calling q.\n    We can change ensures in strange() to false and it's still verified\n*/\n\n/*(b) {true}var x:nat := 4; var c := q(x,2*x); {1 = 2 }\n    precond in strange(): difference between 'y' and 'x' muss be greater than 2,\n    square from 'z' will be a value  between 'x' and 'y'\n\n    apply the Hoare rules step by step:\n    1. {true} as a precondition\n    2. we assign 4 to 'x' and having {4=4}\n    3. assign value q(x, 2 * x) to c, substitute the postcondition of 'q' in place of 'c'\n        post cond of q will be x < z*z < 2*x. Replacing c we having {x < z * z < 2 * x}\n    4. we having the statement {x < z*z < 2*x} => {1 = 2} as postcondtion\n\n    as we know the statment {1 = 2} is always false. true => false is always false     \n\n\n\n*/\n\n//Problem 3\n//Use what you know about the weakest preconditions/strongest postconditions to ex-\n//plain why the following code verifies:\n\n/*\nWP: is a condition that, if satisfied before the execution of a program, guarantees the \nsatisfaction of a specified postcondition\nSP: is a condition that must hold after the execution of a program, assuming a specified \nprecondition\n\nThe strongest postcondition for assert is x<=9\nAnalyze the code: \nThe strongest postcondition for the assert statement assert x <= 9; is x <= 9. This \npostcondition asserts that the value of x should be less than or equal to 9 after the \nexecution of the program. To ensure this postcondition, we need to find a weakest precondition \n(WP) that guarantees x <= 9 after executing the code.\n\nThe \"assume\" statement introduces a precondition.\nIt assumes that the square of x is less than 100. In other words, it assumes that x is \nwithin the range (0, 10) since the largest possible square less than 100 is 9 * 9 = 81.\n\n\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0439", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_Gauss", "vc-description": "", "vc-preamble": "// ****************************************************************************************\n//                              DafnyIntro.dfy\n// ****************************************************************************************\n// We write a program to sum all numbers from 1 to n\n// \n//  Gauss' formula states that 1 + 2 + 3 + ... + (n-1) + n == n*(n+1)/2 \n//\n// We take this a specification, thus in effect we use Dafny to prove Gauss' formula: \n\n// In essence Dafny does an inductive proof. It needs help with a loop \"invariant\".\n// This is a condition which is \n\n// - true at the beginning of the loop\n// - maintained with each passage through the loop body.\n\n// These requirements correspond to an inductive proof\n\n// - the invariant is the inductive hypothesis H(i)\n// - it must be true for i=0\n// - it must remain true when stepping from i to i+1,    \n\n// Here we use two invariants I1 and I2, which amounts to the same as using I1 && I2:", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Gauss(n:int) returns (sum:int)\nrequires n >= 0\nensures sum == n*(n+1)/2     //", "vc-code": "{\n  sum := 0; \n  var i := 0;\n  while i < n\n    invariant sum == i*(i+1)/2  \n    invariant i <= n\n  {\n      i := i+1;\n    sum := sum + i;\n  }\n}", "vc-postamble": "// As a second example, we add the first n odd numbers \n// This yields n*n, i.e.\n//\n//      1 + 3 + 5 + 7 + 9 + 11 + ... 2n+1 == n*n\n//\n// Here is the proof using Dafny:\n\n\n// This verifies, so the proof is complete !!", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0440", "language": "dafny", "source": "dafnybench", "source_id": "Programmverifikation-und-synthese_tmp_tmppurk6ime_example_DafnyIntro_01_Simple_Loops_sumOdds", "vc-description": "", "vc-preamble": "// ****************************************************************************************\n//                              DafnyIntro.dfy\n// ****************************************************************************************\n// We write a program to sum all numbers from 1 to n\n// \n//  Gauss' formula states that 1 + 2 + 3 + ... + (n-1) + n == n*(n+1)/2 \n//\n// We take this a specification, thus in effect we use Dafny to prove Gauss' formula: \n\n// In essence Dafny does an inductive proof. It needs help with a loop \"invariant\".\n// This is a condition which is \n\n// - true at the beginning of the loop\n// - maintained with each passage through the loop body.\n\n// These requirements correspond to an inductive proof\n\n// - the invariant is the inductive hypothesis H(i)\n// - it must be true for i=0\n// - it must remain true when stepping from i to i+1,    \n\n// Here we use two invariants I1 and I2, which amounts to the same as using I1 && I2:   \n\n\n// As a second example, we add the first n odd numbers \n// This yields n*n, i.e.\n//\n//      1 + 3 + 5 + 7 + 9 + 11 + ... 2n+1 == n*n\n//\n// Here is the proof using Dafny:", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sumOdds(n:nat) returns (sum:nat)\nensures sum == n*n;", "vc-code": "{\n     sum := 0; \n  var  i := 0;\n  while i < n\n    invariant sum == i*i   // the inductive hypothesis\n    invariant i <= n\n  {\n    sum := sum + 2*i+1;\n      i := i+1;            // the step from i to i+1\n  }\n}", "vc-postamble": "// This verifies, so the proof is complete !!", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0441", "language": "dafny", "source": "dafnybench", "source_id": "ProjectosCVS_tmp_tmp_02_gmcw_Handout_1_CVS_handout1_55754_55780_euclidianDiv", "vc-description": "", "vc-preamble": "/**\nCVS 2021-22 Handout 1\nAuthors\nGonçalo Martins Lourenço nº55780\nJoana Soares Faria  nº55754\n */\n\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n\n    }\n\n\n\n//Second Exercise", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r", "vc-code": "{\n        r := a;\n        q := 0;\n        while(r - b >= 0)\n            decreases r - b\n            invariant 0 <= r <= a\n            // invariant a == b * q + r\n            invariant r == a - b * q\n        {\n            r := r - b;\n            q := q + 1;\n        }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0442", "language": "dafny", "source": "dafnybench", "source_id": "ProjectosCVS_tmp_tmp_02_gmcw_Handout_1_CVS_handout1_55754_55780_peasantMult", "vc-description": "", "vc-preamble": "/**\nCVS 2021-22 Handout 1\nAuthors\nGonçalo Martins Lourenço nº55780\nJoana Soares Faria  nº55754\n */\n\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b", "vc-code": "{\n        r := 0;\n        var aa := a;\n        var bb := b;\n\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n}", "vc-postamble": "//Second Exercise", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0443", "language": "dafny", "source": "dafnybench", "source_id": "QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_copyArr", "vc-description": "", "vc-preamble": "function sorted(s : seq<int>) : bool {\n  forall k1, k2 :: 0 <= k1 <= k2 < |s| ==> s[k1] <= s[k2]\n}\n\n\n// Ex1", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method copyArr(a : array<int>, l : int, r : int) returns (ret : array<int>)\n  requires 0 <= l < r <= a.Length \n  ensures ret[..] == a[l..r]", "vc-code": "{\n  var size := r - l;\n  ret := new int[size];\n  var i := 0;\n\n  while(i < size)\n    invariant a[..] == old(a[..])\n    invariant 0 <= i <= size\n    invariant ret[..i] == a[l..(l + i)]\n    decreases size - i\n  {\n    ret[i] := a[i + l];\n    i := i + 1;\n  }\n  return;\n}", "vc-postamble": "// Ex2\n\n\n// Ex3", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0444", "language": "dafny", "source": "dafnybench", "source_id": "QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_mergeArr", "vc-description": "", "vc-preamble": "function sorted(s : seq<int>) : bool {\n  forall k1, k2 :: 0 <= k1 <= k2 < |s| ==> s[k1] <= s[k2]\n}\n\n\n// Ex1\n\nmethod copyArr(a : array<int>, l : int, r : int) returns (ret : array<int>)\n  requires 0 <= l < r <= a.Length \n  ensures ret[..] == a[l..r]\n{\n  var size := r - l;\n  ret := new int[size];\n  var i := 0;\n\n  while(i < size)\n    invariant a[..] == old(a[..])\n    invariant 0 <= i <= size\n    invariant ret[..i] == a[l..(l + i)]\n    decreases size - i\n  {\n    ret[i] := a[i + l];\n    i := i + 1;\n  }\n  return;\n}\n\n\n// Ex2", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mergeArr(a : array<int>, l : int, m : int, r : int)\n  requires 0 <= l < m < r <= a.Length  \n  requires sorted(a[l..m]) && sorted(a[m..r])\n  ensures sorted(a[l..r]) \n  ensures a[..l] == old(a[..l])\n  ensures a[r..] == old(a[r..])\n  modifies a", "vc-code": "{\n  var left := copyArr(a, l, m);\n  var right := copyArr(a, m, r);\n  var i := 0;\n  var j := 0;\n  var cur := l;\n  ghost var old_arr := a[..];\n  while(cur < r) \n    decreases a.Length - cur\n    invariant 0 <= i <= left.Length\n    invariant 0 <= j <= right.Length\n    invariant l <= cur <= r\n    invariant cur == i + j + l\n    invariant a[..l] == old_arr[..l]\n    invariant a[r..] == old_arr[r..]\n    invariant sorted(a[l..cur])\n    invariant sorted(left[..])\n    invariant sorted(right[..])\n    invariant i < left.Length && cur > l ==> a[cur - 1] <= left[i] \n    invariant j < right.Length && cur > l ==> a[cur - 1] <= right[j]\n  {\n    if((i == left.Length && j < right.Length) || (j != right.Length && left[i] > right[j])) {\n      a[cur] := right[j];\n      j := j + 1;\n    }\n    else if((j == right.Length && i < left.Length) || (i != left.Length && left[i] <= right[j])) {\n      a[cur] := left[i];\n      i := i + 1;\n    }\n    cur := cur + 1;\n  }\n  return;\n}", "vc-postamble": "// Ex3", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0445", "language": "dafny", "source": "dafnybench", "source_id": "QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_sort", "vc-description": "", "vc-preamble": "method mergeArr(a: array<int>, l: int, m: int, r: int)\n    requires 0 <= l <= m < r <= a.Length\n    modifies a\n{\n    // Placeholder merge implementation\n}\n\nfunction sorted(s : seq<int>) : bool {\n  forall k1, k2 :: 0 <= k1 <= k2 < |s| ==> s[k1] <= s[k2]\n}\n\n\n// Ex1\n\n\n\n// Ex2\n\n\n// Ex3", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sort(a : array<int>) \n  ensures sorted(a[..])\n  modifies a", "vc-code": "{\n  if(a.Length == 0) { return; }\n  else { sortAux(a, 0, a.Length); }\n}", "vc-postamble": "method sortAux(a : array<int>, l : int, r : int)\n  ensures sorted(a[l..r])\n  ensures a[..l] == old(a[..l])\n  ensures a[r..] == old(a[r..])\n  requires 0 <= l < r <= a.Length\n  modifies a\n  decreases r - l\n{\n  if(l >= (r - 1)) {return;}\n  else {\n    var m := l + (r - l) / 2;\n    sortAux(a, l, m);\n    sortAux(a, m, r);\n    mergeArr(a, l, m, r);\n    assume false;\n    return;\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0446", "language": "dafny", "source": "dafnybench", "source_id": "QS_BoilerPlate1_tmp_tmpa29vtz9__Ex2_sortAux", "vc-description": "", "vc-preamble": "function sorted(s : seq<int>) : bool {\n  forall k1, k2 :: 0 <= k1 <= k2 < |s| ==> s[k1] <= s[k2]\n}\n\n\n\n\n\n// Ex1\n\nmethod copyArr(a : array<int>, l : int, r : int) returns (ret : array<int>)\n  requires 0 <= l < r <= a.Length \n  ensures ret[..] == a[l..r]\n{\n  var size := r - l;\n  ret := new int[size];\n  var i := 0;\n\n  while(i < size)\n    invariant a[..] == old(a[..])\n    invariant 0 <= i <= size\n    invariant ret[..i] == a[l..(l + i)]\n    decreases size - i\n  {\n    ret[i] := a[i + l];\n    i := i + 1;\n  }\n  return;\n}\n\n\n// Ex2\n\nmethod mergeArr(a : array<int>, l : int, m : int, r : int)\n  requires 0 <= l < m < r <= a.Length  \n  requires sorted(a[l..m]) && sorted(a[m..r])\n  ensures sorted(a[l..r]) \n  ensures a[..l] == old(a[..l])\n  ensures a[r..] == old(a[r..])\n  modifies a \n{\n  var left := copyArr(a, l, m);\n  var right := copyArr(a, m, r);\n  var i := 0;\n  var j := 0;\n  var cur := l;\n  ghost var old_arr := a[..];\n  while(cur < r) \n    decreases a.Length - cur\n    invariant 0 <= i <= left.Length\n    invariant 0 <= j <= right.Length\n    invariant l <= cur <= r\n    invariant cur == i + j + l\n    invariant a[..l] == old_arr[..l]\n    invariant a[r..] == old_arr[r..]\n    invariant sorted(a[l..cur])\n    invariant sorted(left[..])\n    invariant sorted(right[..])\n    invariant i < left.Length && cur > l ==> a[cur - 1] <= left[i] \n    invariant j < right.Length && cur > l ==> a[cur - 1] <= right[j]\n  {\n    if((i == left.Length && j < right.Length) || (j != right.Length && left[i] > right[j])) {\n      a[cur] := right[j];\n      j := j + 1;\n    }\n    else if((j == right.Length && i < left.Length) || (i != left.Length && left[i] <= right[j])) {\n      a[cur] := left[i];\n      i := i + 1;\n    }\n    cur := cur + 1;\n  }\n  return;\n}\n\n// Ex3", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sortAux(a : array<int>, l : int, r : int)\n  ensures sorted(a[l..r])\n  ensures a[..l] == old(a[..l])\n  ensures a[r..] == old(a[r..])\n  requires 0 <= l < r <= a.Length\n  modifies a\n  decreases r - l", "vc-code": "{\n  if(l >= (r - 1)) {return;}\n  else {\n    var m := l + (r - l) / 2;\n    sortAux(a, l, m);\n    sortAux(a, m, r);\n    mergeArr(a, l, m, r);\n    return;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0447", "language": "dafny", "source": "dafnybench", "source_id": "RollingMax_RollingMax", "vc-description": "", "vc-preamble": "/*\nHumanEvalX 9\nFrom a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n*/\n\nfunction isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RollingMax(numbers: seq<int>) returns (result: seq<int>)\nrequires numbers != []\nensures |result| == |numbers|\nensures forall i :: 0 < i < |result| ==> isMax(result[i], numbers[0..(i+1)])", "vc-code": "{\n    var m := numbers[0];\n    result := [m];\n    for i := 1 to |numbers|\n    invariant |result| == i\n    invariant m == result[i-1]\n    invariant forall j :: 0 <= j < i ==> isMax(result[j], numbers[0..(j+1)])\n    {\n        if numbers[i] > m {\n            m := numbers[i];\n        }\n        result := result + [m];\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0448", "language": "dafny", "source": "dafnybench", "source_id": "RollingMax_max", "vc-description": "", "vc-preamble": "/*\nHumanEvalX 9\nFrom a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.\n*/\n\nfunction isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(numbers: seq<int>) returns (result: int)\nrequires numbers != []\nensures isMax(result, numbers)", "vc-code": "{\n    result := numbers[0];\n    for i := 1 to |numbers|\n    invariant isMax(result, numbers[0..i])\n    {\n        if numbers[i] > result {\n            result := numbers[i];\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0449", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_ass1_ex7_BigFoot", "vc-description": "", "vc-preamble": "// successfully verifies", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BigFoot(step: nat) // DO NOT CHANGE\nrequires 0 < step <= 42;", "vc-code": "{\n    var indx := 0; // DO NOT CHANGE\n    while indx<=42 // DO NOT CHANGE\n    invariant 0 <= indx <= step + 42 && indx % step == 0\n    decreases 42 - indx\n    { indx := indx+step; } // DO NOT CHANGE\n    assert 0 <= indx <= step + 42 && indx % step == 0 && indx > 42;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0450", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_ass1_ex8_GetEven", "vc-description": "", "vc-preamble": "// successfully verifies", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method GetEven(a: array<nat>)\nrequires true;\nensures forall i:int :: 0<=i<a.Length ==> a[i] % 2 == 0\nmodifies a", "vc-code": "{\n    var i := 0;\n    while i < a.Length\n    invariant 0 <= i <= a.Length && forall j:int :: 0<=j<i ==> a[j] % 2 == 0\n    decreases a.Length - i\n    {\n        if a[i] % 2 != 0\n        {\n            a[i] := a[i] + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0457", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_flex_ex2_max", "vc-description": "", "vc-preamble": "function maxcheck(s: array<nat>, i: int, max: int): int\nrequires 0 <= i <= s.Length\nreads s\n{\n    if i == 0 then max\n    else if s[i - 1] > max then maxcheck(s, i - 1, s[i - 1])\n    else maxcheck(s, i - 1, max)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(s: array<nat>) returns (a:int)\nrequires s.Length > 0\nensures forall x :: 0 <= x < s.Length ==> a >= s[x]\nensures a in s[..]", "vc-code": "{\n    a := s[0];\n    var i:int := 0;\n    while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> a >= s[x]\n    invariant a in s[..]\n    {\n        if (s[i] > a) {\n            a := s[i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0458", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_flex_ex5_firste", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method firste(a: array<char>) returns (c:int)\nensures -1 <= c < a.Length\nensures 0 <= c < a.Length ==> a[c] == 'e' && forall x :: 0 <= x < c ==> a[x] != 'e'\nensures c == -1 ==> forall x :: 0 <= x < a.Length ==> a[x] != 'e'", "vc-code": "{\n    var i:int := 0;\n    while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> a[x] != 'e'\n    {\n        if a[i] == 'e' {\n            return i;\n        }\n        i := i + 1;\n    }\n    return -1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0459", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_p1_Reverse", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Reverse(a: array<char>) returns (b: array<char>)\nrequires a.Length > 0\nensures a.Length == b.Length\nensures forall x :: 0 <= x < a.Length ==> b[x] == a[a.Length - x - 1]", "vc-code": "{\n    // copy array a to new array b\n    b := new char[a.Length];\n    var k := 0;\n    while (k < a.Length) \n    invariant 0 <= k <= a.Length;\n    invariant forall x :: 0 <= x < k ==> b[x] == a[a.Length - x - 1]\n    decreases a.Length - k\n    {\n        b[k] := a[a.Length - 1 - k];\n        k := k + 1;\n    }\n    /*\n    var i:int := 0;\n    while i < a.Length\n    invariant a.Length == b.Length\n    invariant 0 <= i <= a.Length\n    invariant 0 <= i <= b.Length\n    //invariant multiset(a[..]) == multiset(b[..])\n    invariant forall x :: 0 <= x < i ==> b[x] == a[a.Length - x - 1]\n    decreases a.Length - i\n    {\n        b[i] := a[a.Length - 1 - i];\n        i := i + 1;\n    }\n    */\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0460", "language": "dafny", "source": "dafnybench", "source_id": "SENG2011_tmp_tmpgk5jq85q_p2_AbsIt", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AbsIt(s: array<int>) modifies s;\n//requires \nensures forall x :: 0 <= x < s.Length ==> old(s[x]) < 0 ==> s[x] == -old(s[x])\nensures forall x :: 0 <= x < s.Length ==> old(s[x]) >= 0 ==> s[x] == old(s[x])", "vc-code": "{\n    var i:int := 0;\n    while i < s.Length\n    invariant 0 <= i <= s.Length\n    //invariant forall x :: 0 <= x < i ==> s[x] >= 0\n    //invariant forall x :: 0 <= x < i ==> old(s[x]) < 0 ==> s[x] == -old(s[x])\n    //invariant forall x :: 0 <= x < i ==> old(s[x]) >= 0 ==> s[x] == old(s[x])\n\n    invariant forall k :: 0 <= k < i ==> old(s[k]) < 0  ==> s[k] == -old(s[k])// negatives are abs'ed \n    invariant forall k :: 0 <= k < i ==> old(s[k]) >= 0 ==> s[k] == old(s[k])  // positives left alone \n    invariant forall k:: i <= k < s.Length ==> old(s[k]) == s[k]              // not yet touched \n    {\n        if (s[i] < 0) {\n            s[i] := -s[i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0470", "language": "dafny", "source": "dafnybench", "source_id": "Software-Verification_tmp_tmpv4ueky2d_Valid_Anagram_valid_anagram_is_anagram", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method is_anagram(s: string, t: string) returns (result: bool)\n    requires |s| == |t|\n    ensures (multiset(s) == multiset(t)) == result", "vc-code": "{\n    result := is_equal(multiset(s), multiset(t));\n}", "vc-postamble": "method is_equal(s: multiset<char>, t: multiset<char>) returns (result: bool)\n    ensures (s == t) <==> result\n{\n    var s_removed := multiset{};\n    var s_remaining := s;\n    while (|s_remaining| > 0)\n        invariant s_remaining == s - s_removed\n        invariant forall removed :: removed in s_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in s_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n\n        var temp := multiset{};\n        s_removed := s_removed + temp[remaining := s[remaining]];\n        s_remaining := s_remaining - temp[remaining := s[remaining]];\n    }\n\n\n    var t_removed := multiset{};\n    var t_remaining := t;\n    while (|t_remaining| > 0)\n        invariant t_remaining == t - t_removed\n        invariant forall removed :: removed in t_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in t_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n\n        var temp := multiset{};\n        t_removed := t_removed + temp[remaining := t[remaining]];\n        t_remaining := t_remaining - temp[remaining := t[remaining]];\n    }\n\n    return true;\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0471", "language": "dafny", "source": "dafnybench", "source_id": "Software-Verification_tmp_tmpv4ueky2d_Valid_Anagram_valid_anagram_is_equal", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method is_equal(s: multiset<char>, t: multiset<char>) returns (result: bool)\n    ensures (s == t) <==> result", "vc-code": "{\n    var s_removed := multiset{};\n    var s_remaining := s;\n    while (|s_remaining| > 0)\n        invariant s_remaining == s - s_removed\n        invariant forall removed :: removed in s_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in s_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n\n        var temp := multiset{};\n        s_removed := s_removed + temp[remaining := s[remaining]];\n        s_remaining := s_remaining - temp[remaining := s[remaining]];\n    }\n\n\n    var t_removed := multiset{};\n    var t_remaining := t;\n    while (|t_remaining| > 0)\n        invariant t_remaining == t - t_removed\n        invariant forall removed :: removed in t_removed ==> (removed in s &&\n                                                              removed in t &&\n                                                              s[removed] == t[removed])\n    {\n        var remaining :| remaining in t_remaining;\n        if !(remaining in s &&\n             remaining in t &&\n             s[remaining] == t[remaining]) {\n           return false; \n        }\n\n        var temp := multiset{};\n        t_removed := t_removed + temp[remaining := t[remaining]];\n        t_remaining := t_remaining - temp[remaining := t[remaining]];\n    }\n\n    return true;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0473", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_m1", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3\n\n\n// 5a", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m1(x: int,y: int) returns (z: int)\n  requires 0 < x < y\n  ensures z >= 0 && z < y && z != x", "vc-code": "{\n  if (x > 0 && y > 0 && y > x) {\n    z := x-1;\n  }\n}", "vc-postamble": "// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0474", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_m2", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3\n\n\n// 5a\n\n// 5b", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m2(x: nat) returns (y: int)\n  requires x <= -1\n  ensures y > x && y < x", "vc-code": "{\n  if (x <= -1) {\n    y := x+1;\n  }\n}", "vc-postamble": "// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0475", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_m3", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3\n\n\n// 5a\n\n// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n//", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m3(x: int,y: int) returns (z: bool)\n  ensures z ==> x==y", "vc-code": "{\n  if (x == y) {\n    z := true;\n  }\n  else {\n    z := false;\n  }\n}", "vc-postamble": "// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0476", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_m4", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3\n\n\n// 5a\n\n// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m4(x: int,y: int) returns (z: bool)\n  ensures z ==> x==y && x==y ==> z", "vc-code": "{\n  if (x == y) {\n    z := true;\n  }\n  else {\n    z := false;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0477", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_max", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(a: int, b: int) returns (z: int)\n  requires true\n  ensures z >= a || z >= b", "vc-code": "{\n  if a > b {\n    z :=a;\n  }\n  else {\n    z := b;\n  }\n}", "vc-postamble": "// 3\n\n\n// 5a\n\n// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0478", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_mystery1", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mystery1(n: nat,m: nat) returns (res: nat)\n  ensures n+m == res", "vc-code": "{\n  if (n==0) {\n    return m;\n  }\n  else {\n    var aux := mystery1 (n-1,m);\n    return 1+aux;\n  }\n}", "vc-postamble": "// 5a\n\n// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0479", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula2_mystery2", "vc-description": "", "vc-preamble": "//PRE-CONDITIONS -> REQUIRES\n//POST-CONDITIONS -> ENSURES\n\n\n\n// 3\nmethod mystery1(n: nat,m: nat) returns (res: nat)\n  ensures n+m == res\n{\n  if (n==0) {\n    return m;\n  }\n  else {\n    var aux := mystery1 (n-1,m);\n    return 1+aux;\n  }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mystery2(n: nat,m: nat) returns (res: nat)\n  ensures n*m == res", "vc-code": "{\n  if (n==0) {\n    return 0;\n  }\n  else {\n    var aux := mystery2(n-1,m);\n    var aux2 := mystery1(m,aux);\n    return aux2;\n  }\n}", "vc-postamble": "// 5a\n\n// 5b\n\n// 5c\n// pode dar false e eles nao serem iguais\n// \n\n// 5d", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0480", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_Fib", "vc-description": "", "vc-preamble": "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Fib(n : nat) returns (r:nat)\n  ensures r == fib(n)", "vc-code": "{\n  if (n == 0) {\n    return 1;\n  }\n\n  var next:= 2;\n  r:=1;\n  var i := 1;\n\n  while (i < n)\n    invariant next == fib(i+1)\n    invariant r == fib(i)\n    invariant 1 <= i <= n\n  {\n    var tmp := next;\n    next := next + r;\n    r := tmp;\n    i := i + 1;\n  }\n  assert r == fib(n);\n  return r;\n}", "vc-postamble": "// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0481", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_addImp", "vc-description": "", "vc-preamble": "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addImp(l : List<int>) returns (r: int)\n  ensures r == add(l)", "vc-code": "{\n  r := 0;\n  var ll := l;\n  while (ll != Nil)\n    decreases ll\n    invariant r==add(l) - add(ll)\n  {\n    r := r + ll.head;\n    ll := ll.tail;\n\n  }\n\n  assert r == add(l);\n}", "vc-postamble": "// 3.\n\n// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0482", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula3_maxArray", "vc-description": "", "vc-preamble": "function fib(n : nat) : nat\n{\n  if (n==0) then 1 else\n  if (n==1) then 1 else fib(n-1)+fib(n-2)\n}\n\n\n// 2.\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction add(l : List<int>) : int {\n  match l\n  case Nil => 0\n  case Cons(x,xs) => x + add(xs)\n}\n\n\n// 3.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method maxArray(arr : array<int>) returns (max: int)\n  requires arr.Length > 0\n  ensures forall i: int :: 0 <= i < arr.Length ==> arr[i] <= max\n  ensures exists x::0 <= x < arr.Length && arr[x] == max", "vc-code": "{\n  max := arr[0];\n  var index := 1;\n  while(index < arr.Length)\n    invariant 0 <= index <= arr.Length\n    invariant forall i: int :: 0 <= i < index ==> arr[i] <= max\n    invariant exists x::0 <= x < arr.Length && arr[x] == max\n\n  {\n    if (arr[index] > max) {\n      max := arr[index];\n    }\n    index := index + 1;\n  }\n}", "vc-postamble": "// 5.\n\n// 6\nfunction sum(n: nat) : nat\n{\n  if (n == 0) then 0 else n + sum(n-1)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0485", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_add", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method add(v:int)\n    requires RepInv()\n    requires size() < maxSize()\n    ensures RepInv()\n    modifies this,Repr\n    ensures fresh(Repr - old(Repr))", "vc-code": "{\n    var f:int := find(v);\n    if (f < 0) {\n      store[nelems] := v;\n      elems := elems + {v};\n      assert forall i:: 0 <= i < nelems ==> old(store[i]) == store[i];\n      nelems := nelems + 1;\n    }\n}", "vc-postamble": "// private method that should not be in the\n  method find(x:int) returns (r:int)\n    requires RepInv()\n    ensures RepInv()\n    ensures r < 0 ==> x !in elems\n    ensures r >=0 ==> x in elems;\n  {\n    var i:int := 0;\n    while (i<nelems)\n      decreases nelems-i\n      invariant 0 <= i <= nelems;\n      invariant forall j::(0<=j< i) ==> x != store[j];\n    {\n      if (store[i]==x) { return i; }\n      i := i + 1;\n    }\n    return -1;\n  }\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }\n\n\n\n\n}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0486", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_contains", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method contains(v:int) returns (b:bool)\n    requires RepInv()\n    ensures RepInv()\n    ensures b <==> v in elems", "vc-code": "{\n    var i := find(v);\n    return i >= 0;\n}", "vc-postamble": "// adds a new element to the set if space available\n\n  // private method that should not be in the\n  method find(x:int) returns (r:int)\n    requires RepInv()\n    ensures RepInv()\n    ensures r < 0 ==> x !in elems\n    ensures r >=0 ==> x in elems;\n  {\n    var i:int := 0;\n    while (i<nelems)\n      decreases nelems-i\n      invariant 0 <= i <= nelems;\n      invariant forall j::(0<=j< i) ==> x != store[j];\n    {\n      if (store[i]==x) { return i; }\n      i := i + 1;\n    }\n    return -1;\n  }\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }\n\n\n\n\n}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0487", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_deposit", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method deposit(amount:int)\n    requires amount > 0\n    requires RepInv()\n    ensures RepInv()\n    modifies Repr", "vc-code": "{\n    cbalance := cbalance + amount;\n}", "vc-postamble": "}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0488", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_find", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method find(x:int) returns (r:int)\n    requires RepInv()\n    ensures RepInv()\n    ensures r < 0 ==> x !in elems\n    ensures r >=0 ==> x in elems;", "vc-code": "{\n    var i:int := 0;\n    while (i<nelems)\n      decreases nelems-i\n      invariant 0 <= i <= nelems;\n      invariant forall j::(0<=j< i) ==> x != store[j];\n    {\n      if (store[i]==x) { return i; }\n      i := i + 1;\n    }\n    return -1;\n}", "vc-postamble": "}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }\n\n\n\n\n}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0489", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_rescue", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method rescue(amount: int)\n    requires amount > 0\n    requires RepInv()\n    ensures RepInv()\n    modifies Repr", "vc-code": "{\n    if(cbalance >= -(sbalance-amount)/2)\n    {\n      sbalance := sbalance - amount;\n    }\n}", "vc-postamble": "}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0490", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_save", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method save(amount: int)\n    requires amount > 0\n    requires PositiveChecking()\n    requires RepInv()\n    ensures RepInv()\n    modifies Repr", "vc-code": "{\n    if(cbalance >= 0)\n    {\n      sbalance := sbalance + amount;\n    }\n}", "vc-postamble": "}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0491", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_aula5_withdraw", "vc-description": "", "vc-preamble": "/*Ex1 Given the leaky specification of class Set found in Appendix ??, use the techniques from\nclass (the use of ghost state and dynamic frames) so that the specification no longer leaks\nthe internal representation. Produce client code that correctly connects to your revised\nSet class. */\n\nclass Set {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  function size():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { nelems }\n  // returns the maximum number of elements in the set\n  function maxSize():int\n    requires RepInv()\n    ensures RepInv()\n    reads Repr\n  { store.Length }\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*2. Using the corrected version of Set as a baseline, implement a PositiveSet class that\nenforces the invariant that all numbers in the set are strictly positive. */\n\nclass PositiveSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n    && (forall x :: x in elems ==> x > 0)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n  // private method that should not be in the\n}\n\n/*\n * Implement a savings account.\n * A savings account is actually made up of two balances.\n *\n * One is the checking balance, here account owner can deposit and withdraw\n * money at will. There is only one restriction on withdrawing. In a regular\n * bank account, the account owner can make withdrawals as long as he has the\n * balance for it, i.e., the user cannot withdraw more money than the user has.\n * In a savings account, the checking balance can go negative as long as it does\n * not surpass half of what is saved in the savings balance. Consider the\n * following example:\n *\n * Savings = 10\n * Checking = 0\n * Operation 1: withdraw 10 This operation is not valid. Given that the\n * the user only has $$10, his checking account\n * can only decrease down to $$-5 (10/2).\n *\n * Operation 2: withdraw 2 Despite the fact that the checking balance of\n * the user is zero,\n * money in his savings account, therefore, this\n * operation is valid, and the result would be\n * something like:\n * Savings = 10;\n * Checking = -2\n *\n * Regarding depositing money in the savings balance (save), this operation has\n * one small restrictions. It is only possible to save money to the savings\n * balance when the user is not in debt; i.e. to save money into savings, the\n * checking must be non-negative.\n *\n * Given the states:\n * STATE 1 STATE 2\n * Savings = 10 Savings = 10\n * Checking = -5 Checking = 0\n *\n * and the operation save($$60000000000), the operation is valid when executed\n * in STATE 2 but not in STATE 1.\n *\n * Finally, when withdrawing from the savings balance, an operation we will\n * call rescue, the amount the user can withdraw depends on the negativity of\n * the user’s checking account. For instance:\n *\n * Savings: 12\n * Checking: -5\n *\n * In the case, the user could withdraw at most two double dollars ($$). If the\n * user withdrew more than that, the balance of the checking account would\n * go beyond the -50% of the savings account; big no no.\n *\n */\n\nclass SavingsAccount {\n\n  var cbalance: int;\n  var sbalance: int;\n\n  ghost var Repr:set<object>;\n\n  ghost predicate RepInv()\n    reads this,Repr\n  {\n    this in Repr\n    && cbalance >= -sbalance/2\n  }\n\n  ghost predicate PositiveChecking()\n    reads this,Repr\n  {\n    cbalance >= 0\n  }\n\n  constructor()\n    ensures fresh(Repr-{this})\n    ensures RepInv()\n  {\n    Repr := {this};\n    cbalance := 0;\n    sbalance := 0;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method withdraw(amount:int)\n    requires amount > 0\n    requires RepInv()\n    ensures RepInv()\n    modifies Repr", "vc-code": "{\n    if(cbalance-amount >= -sbalance/2)\n    {\n      cbalance := cbalance - amount;\n    }\n}", "vc-postamble": "}\n\n\n\n/*Ex 4 Change your specification and implementation of the ASet ADT to include a growing\narray of integer values. */\nclass GrowingSet {\n  var store:array<int>;\n  var nelems: int;\n\n  ghost var Repr : set<object>\n  ghost var elems : set<int>\n\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && store in Repr &&\n    0 < store.Length\n    && 0 <= nelems <= store.Length\n    && (forall i :: 0 <= i < nelems ==> store[i] in elems)\n    && (forall x :: x in elems ==> exists i :: 0 <= i < nelems && store[i] == x)\n  }\n  // the construction operation\n  constructor(n: int)\n    requires 0 < n\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n  {\n    store := new int[n];\n    Repr := {this,store};\n    elems := {};\n    nelems := 0;\n  }\n  // returns the number of elements in the set\n  // returns the maximum number of elements in the set\n  // checks if the element given is in the set\n  // adds a new element to the set if space available\n\n\n  // private method that should not be in the\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0492", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout1_query", "vc-description": "", "vc-preamble": "// 1 a)\n\n// [ai, aj[\nfunction sum(a: array<int>, i: int, j: int) : int\n  requires 0 <= i <= j <= a.Length\n  reads a\n  decreases j\n{\n  if i == j then 0\n  else a[j-1] + sum(a, i, j-1)\n}\n\n// 1 b)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method query(a: array<int>, i: int, j: int) returns (res : int)\n  requires 0 <= i <= j <= a.Length\n  ensures res == sum(a, i, j)", "vc-code": "{\n  res := 0;\n  var ind := j-1;\n\n  while ind >= i\n    invariant i-1 <= ind < j\n    invariant res == sum(a, i, j) - sum(a, i, ind+1)\n    decreases ind\n  {\n    res := res + a[ind];\n    ind := ind - 1;\n  }\n}", "vc-postamble": "// 1 c)\n// a -> [1, 10, 3, −4, 5]\n// c -> [0, 1, 11, 14, 10, 15]\n\npredicate is_prefix_sum_for (a: array<int>, c: array<int>)\n  reads c, a\n{\n  a.Length + 1 == c.Length && forall i: int :: 0 <= i <= a.Length ==> c[i] == sum(a, 0, i)\n}\n\nlemma proof(a: array<int>, i: int, j: int, k:int)\n  requires 0 <= i <= k <= j <= a.Length\n  ensures sum(a, i, k) + sum(a, k, j) == sum(a, i, j)\n\n\n// 2\n\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nmethod from_array<T>(a: array<T>) returns (l: List<T>)\n  ensures forall i: int :: 0 <= i < a.Length ==> mem(a[i], l)\n  ensures forall x: T :: mem(x, l) ==> exists y: int :: 0 <= y < a.Length && a[y] == x\n{\n  l := Nil;\n  var i := a.Length - 1;\n  while i >= 0\n    invariant 0 <= i+1 <= a.Length\n    invariant forall j: int :: i < j < a.Length ==> mem(a[j], l)\n    invariant forall x: T :: mem(x, l) ==> exists y: int :: i+1 <= y < a.Length && a[y] == x\n    decreases i\n  {\n    l := Cons(a[i], l);\n    i := i - 1;\n  }\n}\n\nfunction mem<T(==)> (x: T, l: List<T>) : bool\n{\n  match l\n  case Nil => false\n  case Cons(h, t) => h == x || mem(x, t)\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0494", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_add", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\n\n\n\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }\n\n  method rehash(l: List<(K,V)>, newData: array<List<(K,V)>>,i: int, oldSize: int, newSize: int)\n    requires newData != data\n    requires 0 < oldSize == data.Length\n    requires newData.Length == 2 * oldSize == newSize\n    requires forall k,v :: mem((k,v), l) ==> bucket(k, oldSize) == i\n    requires forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    requires forall k,v :: (\n                           if 0 <= bucket(k, oldSize) < i then\n                             valid_data(k,v,elems,newData)\n                           else if bucket(k, oldSize) == i then\n                             ((k in elems && elems[k] == Some(v))\n                              <==> mem((k,v), l) || mem((k,v),newData[bucket(k, newSize)]))\n                           else\n                             !mem((k,v),newData[bucket(k, newSize)]))\n    ensures forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    ensures forall k,v ::\n              (if 0 <= bucket(k, oldSize) <= i then\n                valid_data(k,v,elems,newData)\n              else\n                !mem((k,v),newData[bucket(k, newSize)]))\n    modifies newData\n    decreases l\n  {\n    match l {\n      case Nil => return;\n      case Cons((k,v), r) => {\n        var b := bucket(k, newSize);\n        newData[b] := Cons((k,v), newData[b]);\n        assume false;\n        rehash(r, newData, i, oldSize, newSize);\n      }\n    }\n  }\n\n\n  method resize()\n    requires RepInv()\n    ensures RepInv()\n    ensures fresh(Repr - old(Repr))\n    ensures forall key :: key in old(elems) ==> key in elems\n    ensures forall k,v :: k in old(elems) && old(elems)[k] == Some(v) ==> k in elems && elems[k] == Some(v)\n    modifies Repr\n  {\n    var newData := new List<(K,V)>[data.Length * 2](i => Nil);\n    var i := 0;\n    var oldSize := data.Length;\n    var newSize := newData.Length;\n\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i);\n\n    while i < data.Length\n      modifies newData\n      invariant RepInv()\n      invariant 0 <= i <= data.Length\n      invariant newData != data\n      invariant old(data) == data\n      invariant old(size) == size\n      invariant Repr == old(Repr)\n      invariant 0 < oldSize == data.Length\n      invariant data.Length*2 == newData.Length == newSize\n      invariant forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n      invariant forall k,v :: (\n                              if 0<= bucket(k, oldSize) < i then\n                                valid_data(k,v,elems,newData)\n                              else\n                                !mem((k,v), newData[bucket(k, newSize)]))\n    {\n      assert valid_hash(data,i);\n      assert forall k,v :: (\n                           if 0 <= bucket(k, oldSize) < i then\n                             valid_data(k,v,elems,data)\n                           else if bucket(k, oldSize) == i then\n                             ((k in elems && elems[k] == Some(v))\n                              <==> mem((k,v), data[bucket(k,data.Length)]) || mem((k,v), newData[bucket(k, newSize)]))\n                           else\n                             !mem((k,v), newData[bucket(k, newSize)]));\n      rehash(data[i],newData,i,oldSize,newSize);\n      i := i + 1;\n    }\n    Repr := Repr - {data} + {newData};\n    data := newData;\n  }\n\n\n\n\n\n  method remove(k: K)\n    requires RepInv()\n    ensures RepInv()\n    ensures fresh(Repr - old(Repr))\n    ensures k !in elems || elems[k] == None\n    ensures forall key :: key != k && key in old(elems) ==> key in elems && elems[key] == old(elems[key])\n    modifies Repr\n  {\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data, i);\n    assert forall k,v :: valid_data(k,v,elems,data);\n\n    var idx := bucket(k, data.Length);\n    var opt := list_find(k, data[idx]);\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i) && (forall k,v:: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i));\n\n    match opt\n    case None =>\n      assert forall k,v :: valid_data(k,v,elems, data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v), data[bucket(k, data.Length)])));\n      assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i);\n      assert forall v :: !mem((k,v),data[bucket(k,data.Length)]);\n    case Some(v) =>\n      assert forall k,v :: valid_data(k,v,elems,data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v),data[bucket(k,data.Length)])));\n      var idx := bucket(k, data.Length);\n      data[idx] := list_remove(k, data[idx]);\n      elems := elems[k := None];\n      size := size - 1;\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method add(k:K,v:V)\n    requires RepInv()\n    ensures RepInv()\n    ensures fresh(Repr - old(Repr))\n    ensures k in elems && elems[k] == Some(v)\n    ensures forall key :: key != k && key in old(elems) ==> key in elems\n    modifies Repr", "vc-code": "{\n    if(size >= data.Length * 3/4) {\n      resize();\n    }\n\n    remove(k);\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data, i);\n\n    var ind := bucket(k,data.Length);\n\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data, i) && (forall k,v:: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i));\n    assert forall k,v :: valid_data(k,v,elems, data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v), data[bucket(k, data.Length)])));\n    assert forall k,v :: mem((k,v), data[ind]) ==> (bucket(k,data.Length) == ind);\n\n    data[ind] := Cons((k,v), data[ind]);\n    elems := elems[k := Some(v)];\n\n    assert bucket(k,data.Length) == ind;\n    assert mem((k,v), data[bucket(k,data.Length)]);\n\n    size := size + 1;\n\n    assert k in elems && elems[k] == Some(v);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0495", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_clear", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method clear()\n    requires RepInv()\n    ensures RepInv()\n    ensures elems == map[]\n    ensures fresh(Repr - old(Repr))\n    modifies Repr", "vc-code": "{\n    var i := 0;\n    while i < data.Length\n      invariant 0 <= i <= data.Length\n      invariant forall j :: 0 <= j < i ==> data[j] == Nil\n      modifies data\n    {\n      data[i] := Nil;\n      i := i + 1;\n    }\n    size := 0;\n    elems := map[];\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0496", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_find", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method find(k: K) returns (r: Option<V>)\n    requires RepInv()\n    ensures RepInv()\n    ensures match r\n            case None => (k !in elems || (k in elems && elems[k] == None))\n            case Some(v) => (k in elems && elems[k] == Some(v))", "vc-code": "{\n    assert forall k, v :: valid_data(k,v,elems,data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v),data[bucket(k,data.Length)])));\n    var idx := bucket(k, data.Length);\n    r := list_find(k, data[idx]);\n    assert match list_find(k,data[bucket(k, data.Length)])\n           case None => forall v :: idx == bucket(k,data.Length) && !mem((k,v),data[idx])\n           case Some(v) => mem((k,v),data[bucket(k,data.Length)]);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0497", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_rehash", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method rehash(l: List<(K,V)>, newData: array<List<(K,V)>>,i: int, oldSize: int, newSize: int)\n    requires newData != data\n    requires 0 < oldSize == data.Length\n    requires newData.Length == 2 * oldSize == newSize\n    requires forall k,v :: mem((k,v), l) ==> bucket(k, oldSize) == i\n    requires forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    requires forall k,v :: (\n                           if 0 <= bucket(k, oldSize) < i then\n                             valid_data(k,v,elems,newData)\n                           else if bucket(k, oldSize) == i then\n                             ((k in elems && elems[k] == Some(v))\n                              <==> mem((k,v), l) || mem((k,v),newData[bucket(k, newSize)]))\n                           else\n                             !mem((k,v),newData[bucket(k, newSize)]))\n    ensures forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    ensures forall k,v ::\n              (if 0 <= bucket(k, oldSize) <= i then\n                valid_data(k,v,elems,newData)\n              else\n                !mem((k,v),newData[bucket(k, newSize)]))\n    modifies newData\n    decreases l", "vc-code": "{\n    match l {\n      case Nil => return;\n      case Cons((k,v), r) => {\n        var b := bucket(k, newSize);\n        newData[b] := Cons((k,v), newData[b]);\n        assume false;\n        rehash(r, newData, i, oldSize, newSize);\n      }\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0498", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_remove", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method remove(k: K)\n    requires RepInv()\n    ensures RepInv()\n    ensures fresh(Repr - old(Repr))\n    ensures k !in elems || elems[k] == None\n    ensures forall key :: key != k && key in old(elems) ==> key in elems && elems[key] == old(elems[key])\n    modifies Repr", "vc-code": "{\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data, i);\n    assert forall k,v :: valid_data(k,v,elems,data);\n\n    var idx := bucket(k, data.Length);\n    var opt := list_find(k, data[idx]);\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i) && (forall k,v:: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i));\n\n    match opt\n    case None =>\n      assert forall k,v :: valid_data(k,v,elems, data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v), data[bucket(k, data.Length)])));\n      assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i);\n      assert forall v :: !mem((k,v),data[bucket(k,data.Length)]);\n    case Some(v) =>\n      assert forall k,v :: valid_data(k,v,elems,data) && ((k in elems && elems[k] == Some(v)) <==> (mem((k,v),data[bucket(k,data.Length)])));\n      var idx := bucket(k, data.Length);\n      data[idx] := list_remove(k, data[idx]);\n      elems := elems[k := None];\n      size := size - 1;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0499", "language": "dafny", "source": "dafnybench", "source_id": "Software-building-and-verification-Projects_tmp_tmp5tm1srrn_CVS-projeto_handout2_resize", "vc-description": "", "vc-preamble": "datatype List<T> = Nil | Cons(head:T,tail:List<T>)\ndatatype Option<T> = None | Some(elem:T)\n\nghost function mem<T>(x:T,l:List<T>) : bool {\n  match l {\n    case Nil => false\n    case Cons(y,xs) => x==y || mem(x,xs)\n  }\n}\n\nghost function length<T>(l:List<T>) : int {\n  match l {\n    case Nil => 0\n    case Cons(_,xs) => 1 + length(xs)\n  }\n}\n\nfunction list_find<K(==),V(!new)>(k:K,l:List<(K,V)>) : Option<V>\n  ensures match list_find(k,l) {\n            case None => forall v :: !mem((k,v),l)\n            case Some(v) => mem((k,v),l)\n          }\n  decreases l\n{\n  match l {\n    case Nil => None\n    case Cons((k',v),xs) => if k==k' then Some(v) else list_find(k,xs)\n  }\n}\n\nfunction list_remove<K(==,!new),V(!new)>(k:K, l:List<(K,V)>) : List<(K,V)>\n  decreases l\n  ensures forall k',v :: mem((k',v),list_remove(k,l)) <==> (mem((k',v),l) && k != k')\n{\n  match l {\n    case Nil => Nil\n    case Cons((k',v),xs) => if k==k' then list_remove(k,xs) else\n    Cons((k',v),list_remove(k,xs))\n  }\n}\n\n\nclass Hashtable<K(==,!new),V(!new)> {\n  var size : int\n  var data : array<List<(K,V)>>\n\n  ghost var Repr : set<object>\n  ghost var elems : map<K,Option<V>>\n\n  ghost predicate RepInv()\n    reads this, Repr\n  {\n    this in Repr && data in Repr && data.Length > 0 &&\n    (forall i :: 0 <= i < data.Length ==> valid_hash(data, i)) &&\n    (forall k,v :: valid_data(k,v,elems,data))\n  }\n\n  ghost predicate valid_hash(data: array<List<(K,V)>>, i: int)\n    requires 0 <= i < data.Length\n    reads data\n  {\n    forall k,v :: mem((k,v), data[i]) ==> (bucket(k,data.Length) == i)\n  }\n\n\n  ghost predicate valid_data(k: K,v: V,elems: map<K, Option<V>>, data: array<List<(K,V)>>)\n    reads this, Repr, data\n    requires data.Length > 0\n  {\n    (k in elems && elems[k] == Some(v)) <==> mem((k,v), data[bucket(k, data.Length)])\n  }\n\n\n  function hash(key:K) : int\n    ensures hash(key) >= 0\n\n  function bucket(k: K, n: int) : int\n    requires n > 0\n    ensures 0 <= bucket(k, n) < n\n  {\n    hash(k) % n\n  }\n\n  constructor(n:int)\n    requires n > 0\n    ensures RepInv()\n    ensures fresh(Repr-{this})\n    ensures elems == map[]\n    ensures size == 0\n  {\n    size := 0;\n    data := new List<(K,V)>[n](i => Nil);\n    Repr := {this, data};\n    elems := map[];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method resize()\n    requires RepInv()\n    ensures RepInv()\n    ensures fresh(Repr - old(Repr))\n    ensures forall key :: key in old(elems) ==> key in elems\n    ensures forall k,v :: k in old(elems) && old(elems)[k] == Some(v) ==> k in elems && elems[k] == Some(v)\n    modifies Repr", "vc-code": "{\n    assume(false);\n    var newData := new List<(K,V)>[data.Length * 2](i => Nil);\n    var i := 0;\n    var oldSize := data.Length;\n    var newSize := newData.Length;\n\n    assert forall i :: 0 <= i < data.Length ==> valid_hash(data,i);\n\n    while i < data.Length\n      modifies newData\n      invariant RepInv()\n      invariant 0 <= i <= data.Length\n      invariant newData != data\n      invariant old(data) == data\n      invariant old(size) == size\n      invariant Repr == old(Repr)\n      invariant 0 < oldSize == data.Length\n      invariant data.Length*2 == newData.Length == newSize\n      invariant forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n      invariant forall k,v :: (\n                              if 0<= bucket(k, oldSize) < i then\n                                valid_data(k,v,elems,newData)\n                              else\n                                !mem((k,v), newData[bucket(k, newSize)]))\n    {\n      assert valid_hash(data,i);\n      assert forall k,v :: (\n                           if 0 <= bucket(k, oldSize) < i then\n                             valid_data(k,v,elems,data)\n                           else if bucket(k, oldSize) == i then\n                             ((k in elems && elems[k] == Some(v))\n                              <==> mem((k,v), data[bucket(k,data.Length)]) || mem((k,v), newData[bucket(k, newSize)]))\n                           else\n                             !mem((k,v), newData[bucket(k, newSize)]));\n      rehash(data[i],newData,i,oldSize,newSize);\n      i := i + 1;\n    }\n    Repr := Repr - {data} + {newData};\n    data := newData;\n}\n\nmethod rehash(l: List<(K,V)>, newData: array<List<(K,V)>>,i: int, oldSize: int, newSize: int)\n    requires newData != data\n    requires 0 < oldSize == data.Length\n    requires newData.Length == 2 * oldSize == newSize\n    requires forall k,v :: mem((k,v), l) ==> bucket(k, oldSize) == i\n    requires forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    requires forall k,v :: (\n                           if 0 <= bucket(k, oldSize) < i then\n                             valid_data(k,v,elems,newData)\n                           else if bucket(k, oldSize) == i then\n                             ((k in elems && elems[k] == Some(v))\n                              <==> mem((k,v), l) || mem((k,v),newData[bucket(k, newSize)]))\n                           else\n                             !mem((k,v),newData[bucket(k, newSize)]))\n    ensures forall j :: 0 <= j < newSize ==> valid_hash(newData, j)\n    ensures forall k,v ::\n              (if 0 <= bucket(k, oldSize) <= i then\n                valid_data(k,v,elems,newData)\n              else\n                !mem((k,v),newData[bucket(k, newSize)]))\n    modifies newData\n    decreases l\n  {\n    assume(false);\n    match l {\n      case Nil => return;\n      case Cons((k,v), r) => {\n        var b := bucket(k, newSize);\n        newData[b] := Cons((k,v), newData[b]);\n        rehash(r, newData, i, oldSize, newSize);\n      }\n    }\n  }\n\n\n\n\n\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0500", "language": "dafny", "source": "dafnybench", "source_id": "TFG_tmp_tmpbvsao41w_Algoritmos_Dafny_div_ent_it_div_ent_it", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method div_ent_it(a: int, b: int) returns (c: int, r: int)\n\n// Algoritmo iterativo de la división de enteros\n// que calcula su cociente y resto\n\n    requires a >= 0 && b > 0\n    ensures  a == b*c + r && 0 <= r < b", "vc-code": "{\n    c := 0; r := a ;\n    while (r >= b)\n    invariant a == b * c + r && r >= 0 && b > 0\n    decreases r   \n    {\n        c := c + 1 ;\n        r := r - b ;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0501", "language": "dafny", "source": "dafnybench", "source_id": "TFG_tmp_tmpbvsao41w_Algoritmos_Dafny_suma_it_suma_it", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method suma_it(V: array<int>) returns (x: int)\n\n// Algoritmo iterativo que calcula la\n// suma de las componentes de un vector\n\n    ensures  x == suma_vector(V, 0)", "vc-code": "{\n    var n := V.Length ;\n        x := 0 ;\n    while (n != 0)\n        invariant 0 <= n <= V.Length && x == suma_vector(V, n)\n        decreases n\n    {\n        x := x + V[n - 1] ;\n        n := n - 1 ;\n    }\n}", "vc-postamble": "function suma_vector(V: array<int>, n: nat): int\n\n// x = V[n] + V[n + 1] + ... + V[N - 1]\n// Funcion auxiliar para la suma de\n// las componentes de un vector\n\n    requires 0 <= n <= V.Length  \n    decreases V.Length - n  \n    reads V  \n{    \n    if (n == V.Length) then 0 \n    else V[n] + suma_vector(V, n + 1)  \n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0502", "language": "dafny", "source": "dafnybench", "source_id": "Trab1-Metodos-Formais_tmp_tmp_8fa4trr_circular-array_AsSequence", "vc-description": "", "vc-preamble": "/*\n  Class CircularArray.\n\n  Names:\n  Arthur Sudbrack Ibarra,\n  Miguel Torres de Castro,\n  Felipe Grosze Nipper,\n  Willian Magnum Albeche,\n  Luiz Eduardo Mello dos Reis.\n*/\nclass {:autocontracts} CircularArray {\n  /*\n    Implementation\n  */\n  var arr: array<int>; // The array.\n  var start: nat; // The index of the first element.\n  var size: nat; // The number of elements in the queue.\n\n  /*\n    Abstraction.\n  */\n  ghost const Capacity: nat; // The capacity of the queue. (WE WERE UNABLE TO MAKE THE SIZE OF THE ARRAY DYNAMIC).\n  ghost var Elements: seq<int>; // The elements in the array represented as a sequence.\n\n  /*\n    Class invariant.\n  */\n  ghost predicate Valid()\n  {\n    0 <= start < arr.Length &&\n    0 <= size <= arr.Length &&\n    Capacity == arr.Length &&\n    Elements == if start + size <= arr.Length\n                then arr[start..start + size]\n                else arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Constructor.\n  */\n  constructor EmptyQueue(capacity: nat)\n    requires capacity > 0\n    ensures Elements == []\n    ensures Capacity == capacity\n  {\n    arr := new int[capacity];\n    start := 0;\n    size := 0;\n    Capacity := capacity;\n    Elements := [];\n  }\n\n  /*\n    Enqueue Method\n  */\n\n  /*\n    Dequeue method.\n  */\n\n  /*\n    Contains predicate.\n  */\n  predicate Contains(e: int)\n    ensures Contains(e) == (e in Elements)\n  {\n    if start + size < arr.Length then\n      e in arr[start..start + size]\n    else\n      e in arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Size function.\n  */\n  function Size(): nat\n    ensures Size() == |Elements|\n  {\n    size\n  }\n\n  /*\n    IsEmpty predicate.\n  */\n  predicate IsEmpty()\n    ensures IsEmpty() <==> (|Elements| == 0)\n  {\n    size == 0\n  }\n\n  /*\n    IsFull predicate.\n  */\n  predicate IsFull()\n    ensures IsFull() <==> |Elements| == Capacity\n  {\n    size == arr.Length\n  }\n\n  /*\n    GetAt method.\n    (Not requested in the assignment, but useful).\n  */\n\n  /*\n    AsSequence method.\n    (Auxiliary method for the Concatenate method)\n  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AsSequence() returns (s: seq<int>)\n    ensures s == Elements", "vc-code": "{\n      s := if start + size <= arr.Length\n           then arr[start..start + size]\n           else arr[start..] + arr[..size - (arr.Length - start)];\n}", "vc-postamble": "/*\n    Concatenate method.\n  */\n}\n\n/*\n  Main method.\n  Here the the CircularArray class is demonstrated.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0503", "language": "dafny", "source": "dafnybench", "source_id": "Trab1-Metodos-Formais_tmp_tmp_8fa4trr_circular-array_Concatenate", "vc-description": "", "vc-preamble": "/*\n  Class CircularArray.\n\n  Names:\n  Arthur Sudbrack Ibarra,\n  Miguel Torres de Castro,\n  Felipe Grosze Nipper,\n  Willian Magnum Albeche,\n  Luiz Eduardo Mello dos Reis.\n*/\nclass {:autocontracts} CircularArray {\n  /*\n    Implementation\n  */\n  var arr: array<int>; // The array.\n  var start: nat; // The index of the first element.\n  var size: nat; // The number of elements in the queue.\n\n  /*\n    Abstraction.\n  */\n  ghost const Capacity: nat; // The capacity of the queue. (WE WERE UNABLE TO MAKE THE SIZE OF THE ARRAY DYNAMIC).\n  ghost var Elements: seq<int>; // The elements in the array represented as a sequence.\n\n  /*\n    Class invariant.\n  */\n  ghost predicate Valid()\n  {\n    0 <= start < arr.Length &&\n    0 <= size <= arr.Length &&\n    Capacity == arr.Length &&\n    Elements == if start + size <= arr.Length\n                then arr[start..start + size]\n                else arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Constructor.\n  */\n  constructor EmptyQueue(capacity: nat)\n    requires capacity > 0\n    ensures Elements == []\n    ensures Capacity == capacity\n  {\n    arr := new int[capacity];\n    start := 0;\n    size := 0;\n    Capacity := capacity;\n    Elements := [];\n  }\n\n  /*\n    Enqueue Method\n  */\n\n  /*\n    Dequeue method.\n  */\n\n  /*\n    Contains predicate.\n  */\n  predicate Contains(e: int)\n    ensures Contains(e) == (e in Elements)\n  {\n    if start + size < arr.Length then\n      e in arr[start..start + size]\n    else\n      e in arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Size function.\n  */\n  function Size(): nat\n    ensures Size() == |Elements|\n  {\n    size\n  }\n\n  /*\n    IsEmpty predicate.\n  */\n  predicate IsEmpty()\n    ensures IsEmpty() <==> (|Elements| == 0)\n  {\n    size == 0\n  }\n\n  /*\n    IsFull predicate.\n  */\n  predicate IsFull()\n    ensures IsFull() <==> |Elements| == Capacity\n  {\n    size == arr.Length\n  }\n\n  /*\n    GetAt method.\n    (Not requested in the assignment, but useful).\n  */\n\n  /*\n    AsSequence method.\n    (Auxiliary method for the Concatenate method)\n  */\n  method AsSequence() returns (s: seq<int>)\n    ensures s == Elements\n    {\n      s := if start + size <= arr.Length\n           then arr[start..start + size]\n           else arr[start..] + arr[..size - (arr.Length - start)];\n    }\n\n  /*\n    Concatenate method.\n  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Concatenate(q1: CircularArray) returns(q2: CircularArray)\n    requires q1.Valid()\n    requires q1 != this\n    ensures fresh(q2)\n    ensures q2.Capacity == Capacity + q1.Capacity\n    ensures q2.Elements == Elements + q1.Elements", "vc-code": "{\n    q2 := new CircularArray.EmptyQueue(arr.Length + q1.arr.Length);\n    var s1 := AsSequence();\n    var s2 := q1.AsSequence();\n    var both := s1 + s2;\n    forall i | 0 <= i < size\n    {\n      q2.arr[i] := both[i];\n    }\n    q2.size := size + q1.size;\n    q2.start := 0;\n    q2.Elements := Elements + q1.Elements;\n\n    print q2.arr.Length;\n    print q2.size;\n}", "vc-postamble": "}\n\n/*\n  Main method.\n  Here the the CircularArray class is demonstrated.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0504", "language": "dafny", "source": "dafnybench", "source_id": "Trab1-Metodos-Formais_tmp_tmp_8fa4trr_circular-array_Dequeue", "vc-description": "", "vc-preamble": "/*\n  Class CircularArray.\n\n  Names:\n  Arthur Sudbrack Ibarra,\n  Miguel Torres de Castro,\n  Felipe Grosze Nipper,\n  Willian Magnum Albeche,\n  Luiz Eduardo Mello dos Reis.\n*/\nclass {:autocontracts} CircularArray {\n  /*\n    Implementation\n  */\n  var arr: array<int>; // The array.\n  var start: nat; // The index of the first element.\n  var size: nat; // The number of elements in the queue.\n\n  /*\n    Abstraction.\n  */\n  ghost const Capacity: nat; // The capacity of the queue. (WE WERE UNABLE TO MAKE THE SIZE OF THE ARRAY DYNAMIC).\n  ghost var Elements: seq<int>; // The elements in the array represented as a sequence.\n\n  /*\n    Class invariant.\n  */\n  ghost predicate Valid()\n  {\n    0 <= start < arr.Length &&\n    0 <= size <= arr.Length &&\n    Capacity == arr.Length &&\n    Elements == if start + size <= arr.Length\n                then arr[start..start + size]\n                else arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Constructor.\n  */\n  constructor EmptyQueue(capacity: nat)\n    requires capacity > 0\n    ensures Elements == []\n    ensures Capacity == capacity\n  {\n    arr := new int[capacity];\n    start := 0;\n    size := 0;\n    Capacity := capacity;\n    Elements := [];\n  }\n\n  /*\n    Enqueue Method\n  */\n\n  /*\n    Dequeue method.\n  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Dequeue() returns (e: int)\n    requires !IsEmpty()\n    ensures Elements == old(Elements)[1..]\n    ensures e == old(Elements)[0]", "vc-code": "{\n    e := arr[start];\n    if start + 1 < arr.Length {\n      start := start + 1;\n    }\n    else {\n      start := 0;\n    }\n    size := size - 1;\n    Elements := Elements[1..];\n}", "vc-postamble": "/*\n    Contains predicate.\n  */\n  predicate Contains(e: int)\n    ensures Contains(e) == (e in Elements)\n  {\n    if start + size < arr.Length then\n      e in arr[start..start + size]\n    else\n      e in arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Size function.\n  */\n  function Size(): nat\n    ensures Size() == |Elements|\n  {\n    size\n  }\n\n  /*\n    IsEmpty predicate.\n  */\n  predicate IsEmpty()\n    ensures IsEmpty() <==> (|Elements| == 0)\n  {\n    size == 0\n  }\n\n  /*\n    IsFull predicate.\n  */\n  predicate IsFull()\n    ensures IsFull() <==> |Elements| == Capacity\n  {\n    size == arr.Length\n  }\n\n  /*\n    GetAt method.\n    (Not requested in the assignment, but useful).\n  */\n\n  /*\n    AsSequence method.\n    (Auxiliary method for the Concatenate method)\n  */\n\n  /*\n    Concatenate method.\n  */\n}\n\n/*\n  Main method.\n  Here the the CircularArray class is demonstrated.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0505", "language": "dafny", "source": "dafnybench", "source_id": "Trab1-Metodos-Formais_tmp_tmp_8fa4trr_circular-array_Enqueue", "vc-description": "", "vc-preamble": "/*\n  Class CircularArray.\n\n  Names:\n  Arthur Sudbrack Ibarra,\n  Miguel Torres de Castro,\n  Felipe Grosze Nipper,\n  Willian Magnum Albeche,\n  Luiz Eduardo Mello dos Reis.\n*/\nclass {:autocontracts} CircularArray {\n  /*\n    Implementation\n  */\n  var arr: array<int>; // The array.\n  var start: nat; // The index of the first element.\n  var size: nat; // The number of elements in the queue.\n\n  /*\n    Abstraction.\n  */\n  ghost const Capacity: nat; // The capacity of the queue. (WE WERE UNABLE TO MAKE THE SIZE OF THE ARRAY DYNAMIC).\n  ghost var Elements: seq<int>; // The elements in the array represented as a sequence.\n\n  /*\n    Class invariant.\n  */\n  ghost predicate Valid()\n  {\n    0 <= start < arr.Length &&\n    0 <= size <= arr.Length &&\n    Capacity == arr.Length &&\n    Elements == if start + size <= arr.Length\n                then arr[start..start + size]\n                else arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Constructor.\n  */\n  constructor EmptyQueue(capacity: nat)\n    requires capacity > 0\n    ensures Elements == []\n    ensures Capacity == capacity\n  {\n    arr := new int[capacity];\n    start := 0;\n    size := 0;\n    Capacity := capacity;\n    Elements := [];\n  }\n\n  /*\n    Enqueue Method\n  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Enqueue(e: int)\n    requires !IsFull()\n    ensures Elements == old(Elements) + [e]", "vc-code": "{\n    arr[(start + size) % arr.Length] := e;\n    size := size + 1;\n    Elements := Elements + [e];\n}", "vc-postamble": "/*\n    Dequeue method.\n  */\n\n  /*\n    Contains predicate.\n  */\n  predicate Contains(e: int)\n    ensures Contains(e) == (e in Elements)\n  {\n    if start + size < arr.Length then\n      e in arr[start..start + size]\n    else\n      e in arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Size function.\n  */\n  function Size(): nat\n    ensures Size() == |Elements|\n  {\n    size\n  }\n\n  /*\n    IsEmpty predicate.\n  */\n  predicate IsEmpty()\n    ensures IsEmpty() <==> (|Elements| == 0)\n  {\n    size == 0\n  }\n\n  /*\n    IsFull predicate.\n  */\n  predicate IsFull()\n    ensures IsFull() <==> |Elements| == Capacity\n  {\n    size == arr.Length\n  }\n\n  /*\n    GetAt method.\n    (Not requested in the assignment, but useful).\n  */\n\n  /*\n    AsSequence method.\n    (Auxiliary method for the Concatenate method)\n  */\n\n  /*\n    Concatenate method.\n  */\n}\n\n/*\n  Main method.\n  Here the the CircularArray class is demonstrated.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0506", "language": "dafny", "source": "dafnybench", "source_id": "Trab1-Metodos-Formais_tmp_tmp_8fa4trr_circular-array_GetAt", "vc-description": "", "vc-preamble": "/*\n  Class CircularArray.\n\n  Names:\n  Arthur Sudbrack Ibarra,\n  Miguel Torres de Castro,\n  Felipe Grosze Nipper,\n  Willian Magnum Albeche,\n  Luiz Eduardo Mello dos Reis.\n*/\nclass {:autocontracts} CircularArray {\n  /*\n    Implementation\n  */\n  var arr: array<int>; // The array.\n  var start: nat; // The index of the first element.\n  var size: nat; // The number of elements in the queue.\n\n  /*\n    Abstraction.\n  */\n  ghost const Capacity: nat; // The capacity of the queue. (WE WERE UNABLE TO MAKE THE SIZE OF THE ARRAY DYNAMIC).\n  ghost var Elements: seq<int>; // The elements in the array represented as a sequence.\n\n  /*\n    Class invariant.\n  */\n  ghost predicate Valid()\n  {\n    0 <= start < arr.Length &&\n    0 <= size <= arr.Length &&\n    Capacity == arr.Length &&\n    Elements == if start + size <= arr.Length\n                then arr[start..start + size]\n                else arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Constructor.\n  */\n  constructor EmptyQueue(capacity: nat)\n    requires capacity > 0\n    ensures Elements == []\n    ensures Capacity == capacity\n  {\n    arr := new int[capacity];\n    start := 0;\n    size := 0;\n    Capacity := capacity;\n    Elements := [];\n  }\n\n  /*\n    Enqueue Method\n  */\n\n  /*\n    Dequeue method.\n  */\n\n  /*\n    Contains predicate.\n  */\n  predicate Contains(e: int)\n    ensures Contains(e) == (e in Elements)\n  {\n    if start + size < arr.Length then\n      e in arr[start..start + size]\n    else\n      e in arr[start..] + arr[..size - (arr.Length - start)]\n  }\n\n  /*\n    Size function.\n  */\n  function Size(): nat\n    ensures Size() == |Elements|\n  {\n    size\n  }\n\n  /*\n    IsEmpty predicate.\n  */\n  predicate IsEmpty()\n    ensures IsEmpty() <==> (|Elements| == 0)\n  {\n    size == 0\n  }\n\n  /*\n    IsFull predicate.\n  */\n  predicate IsFull()\n    ensures IsFull() <==> |Elements| == Capacity\n  {\n    size == arr.Length\n  }\n\n  /*\n    GetAt method.\n    (Not requested in the assignment, but useful).\n  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method GetAt(i: nat) returns (e: int)\n    requires i < size\n    ensures e == Elements[i]", "vc-code": "{\n    e := arr[(start + i) % arr.Length];\n}", "vc-postamble": "/*\n    AsSequence method.\n    (Auxiliary method for the Concatenate method)\n  */\n\n  /*\n    Concatenate method.\n  */\n}\n\n/*\n  Main method.\n  Here the the CircularArray class is demonstrated.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0510", "language": "dafny", "source": "dafnybench", "source_id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_selection_sort_SelectionSort", "vc-description": "", "vc-preamble": "//https://homepage.cs.uiowa.edu/~tinelli/classes/181/Fall21/Tools/Dafny/Examples/selection-sort.shtml\n\n\n\npredicate sorted (a: array<int>)\n    requires a != null\n    reads a\n{\n    forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\n\n// Selection sort on arrays", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SelectionSort(a: array<int>) \n  modifies a\n  ensures sorted(a)\n  //ensures multiset(old(a[..])) == multiset(a[..])", "vc-code": "{\n  var n := 0;\n  while (n != a.Length)\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j] //all the values in the sorted section will be lower then any value in the non sorted section \n    invariant forall k1, k2 :: 0 <= k1 < k2 < n ==> a[k1] <= a[k2] //all values in the sorted section are sorted with respect to one another\n  {\n    var mindex := n;\n    var m := n + 1;\n    while (m != a.Length)\n      invariant n <= m <= a.Length //m (search idx) between valid range\n      invariant n <= mindex < m <= a.Length // minIndex between valid range\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]  //mindex is current smallest in range n < m\n    {\n      if (a[m] < a[mindex]) {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0511", "language": "dafny", "source": "dafnybench", "source_id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_sum_array_sum_array", "vc-description": "", "vc-preamble": "function sumTo( a:array<int>, n:int ) : int\n  requires a != null;\n  requires 0 <= n && n <= a.Length;\n  reads a;\n{\n  if (n == 0) then 0 else sumTo(a, n-1) + a[n-1]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sum_array( a: array<int>) returns (sum: int)\n  requires a != null;\n  ensures sum == sumTo(a, a.Length);", "vc-code": "{\n  var i := 0;\n  sum := 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length;\n    invariant sum == sumTo(a, i);\n  {\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0512", "language": "dafny", "source": "dafnybench", "source_id": "Workshop_tmp_tmp0cu11bdq_Lecture_Answers_triangle_number_TriangleNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method TriangleNumber(N: int) returns (t: int)\n    requires N >= 0\n    ensures t == N * (N + 1) / 2", "vc-code": "{\n    t := 0;\n    var n := 0;\n    while n < N\n        invariant 0 <= n <= N\n        invariant t == n * (n + 1) / 2\n        decreases N - n;// can be left out because it is guessed correctly by Dafny\n    {\n        n:= n + 1;\n        t := t + n;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0513", "language": "dafny", "source": "dafnybench", "source_id": "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5_rev", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);", "vc-code": "{\n    var i := 0;\n    while (i < a.Length - 1 - i)\n        invariant 0 <= i <= a.Length/2;\n        invariant forall k :: 0 <= k < i || a.Length - 1 - i < k <= a.Length - 1 ==> a[k] == old(a[a.Length - 1 - k]); //The reversed region contains the opposing values\n        invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k]); // The non reversed region contains the original values\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0514", "language": "dafny", "source": "dafnybench", "source_id": "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6_arrayUpToN", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]", "vc-code": "{\n    var i := 0;\n    a := new int[n];\n    while i < n\n        invariant 0 <= i <= n\n        invariant forall k :: 0 <= k < i ==> a[k] >= 0\n        invariant forall k :: 0 <= k < i ==> a[k] == k\n        invariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0519", "language": "dafny", "source": "dafnybench", "source_id": "bbfny_tmp_tmpw4m0jvl0_enjoying_Abs", "vc-description": "", "vc-preamble": "// shenanigans going through the dafny tutorial\n\n\n\n\nfunction max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'() {\n  assert max(1,2) == 2;\n  assert forall a,b : int :: max (a,b) == a || max (a,b) == b;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x: int) returns (y: int)\n  ensures y == abs(x)", "vc-code": "{\n  return abs(x);\n}", "vc-postamble": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0522", "language": "dafny", "source": "dafnybench", "source_id": "bbfny_tmp_tmpw4m0jvl0_enjoying_Max", "vc-description": "", "vc-preamble": "// shenanigans going through the dafny tutorial", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b: int) returns (c: int)\n  ensures a <= c && b <= c\n  ensures a == c || b == c", "vc-code": "{\n  if a > b {\n    c := a;\n  } else { c := b; }\n}", "vc-postamble": "function max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'() {\n  assert max(1,2) == 2;\n  assert forall a,b : int :: max (a,b) == a || max (a,b) == b;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0523", "language": "dafny", "source": "dafnybench", "source_id": "bbfny_tmp_tmpw4m0jvl0_enjoying_MultipleReturns", "vc-description": "", "vc-preamble": "// shenanigans going through the dafny tutorial", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  requires 0 < y\n  ensures less < x < more", "vc-code": "{\n  more := x + y;\n  less := x - y;\n}", "vc-postamble": "function max(a: int, b: int): int\n{\n  if a > b then a else b\n}\nmethod Testing'() {\n  assert max(1,2) == 2;\n  assert forall a,b : int :: max (a,b) == a || max (a,b) == b;\n}\n\nfunction abs(x: int): int\n{\n  if x < 0 then -x else x\n}\n\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall j, k :: 0 <= j < k < a.Length ==> a[j] < a[k]\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0524", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_auxInsertEmptyQueue", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method auxInsertEmptyQueue(item:int)\n    requires front == 0 && rear == 0 && circularQueue.Length == 0\n    ensures circularQueue.Length == 1\n    ensures Content == [item]\n    ensures |Content| == 1\n    ensures rear == 1\n    ensures counter == old(counter) + 1\n    ensures front == 0", "vc-code": "{\n    counter := counter + 1;\n    var queueInsert: array<int>;\n    queueInsert := new int [circularQueue.Length + 1];\n    queueInsert[0] := item;\n    circularQueue := queueInsert;\n    Content := [item];\n    rear := rear + 1;\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0525", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_auxInsertEndQueue", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method auxInsertEndQueue(item:int)\n    requires front == 0 && rear == circularQueue.Length && circularQueue.Length >= 1\n    ensures Content == old(Content) + [item]\n    ensures |Content| == old(|Content|) + 1\n    ensures front == 0\n    ensures rear == old(rear) + 1\n    ensures counter == old(counter) + 1", "vc-code": "{\n      assume false;\n}", "vc-postamble": "// {\n  //   counter := counter + 1;\n  //   var queueInsert: array<int>;\n  //   queueInsert := new int [circularQueue.Length + 1];\n  //   var i: nat := 0;\n  //   while i < circularQueue.Length\n  //   invariant circularQueue.Length + 1 == queueInsert.Length\n  //   invariant 0 <= i <= circularQueue.Length\n  //   invariant forall j :: 0 <= j < i ==> queueInsert[j] == circularQueue[j]\n  //   {\n  //     queueInsert[i] := circularQueue[i];\n  //     i := i + 1;\n  //   }\n  //   queueInsert[queueInsert.Length - 1] := item;\n  //   Content := Content + [item];\n  //   rear := rear + 1;\n  //   circularQueue := queueInsert;\n  // }\n\n  method auxInsertSpaceQueue(item:int)\n    requires rear < front && front < circularQueue.Length\n    ensures rear == old(rear) + 1\n    ensures counter == old(counter) + 1\n    ensures Content == old(Content[0..rear]) + [item] + old(Content[rear+1..circularQueue.Length])\n    ensures |Content| == old(|Content|) + 1\n\n  method auxInsertInitQueue(item:int)\n\n  method auxInsertBetweenQueue(item:int)\n\n  // remove apenas mudando o ponteiro\n  // sem resetar o valor na posição, pois, provavelmente,\n  // vai ser sobrescrito pela inserção\n  method remove() returns (item: int)\n    requires front < circularQueue.Length\n    requires circularQueue.Length > 0\n    ensures rear <= |old(Content)|\n    ensures circularQueue.Length > 0\n    ensures item == old(Content)[old(front)]\n    ensures front == (old(front) + 1) % circularQueue.Length\n    ensures old(front) < rear ==> Content == old(Content)[old(front)..rear]\n    ensures old(front) > rear ==> Content == old(Content)[0 .. rear] + old(Content)[old(front)..|old(Content)|]\n  /*{\n    if counter == 0 {\n      item := -1;\n\n    } else {\n      item := circularQueue[front];\n      front := (front + 1) % circularQueue.Length;\n      counter := counter - 1;\n    }\n  }*/\n\n\n\n\n  // TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0526", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_auxInsertSpaceQueue", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method auxInsertSpaceQueue(item:int)\n    requires rear < front && front < circularQueue.Length\n    ensures rear == old(rear) + 1\n    ensures counter == old(counter) + 1\n    ensures Content == old(Content[0..rear]) + [item] + old(Content[rear+1..circularQueue.Length])\n    ensures |Content| == old(|Content|) + 1", "vc-code": "{\n  assume(false);\n}", "vc-postamble": "method auxInsertInitQueue(item:int)\n\n  method auxInsertBetweenQueue(item:int)\n\n  // remove apenas mudando o ponteiro\n  // sem resetar o valor na posição, pois, provavelmente,\n  // vai ser sobrescrito pela inserção\n  method remove() returns (item: int)\n    requires front < circularQueue.Length\n    requires circularQueue.Length > 0\n    ensures rear <= |old(Content)|\n    ensures circularQueue.Length > 0\n    ensures item == old(Content)[old(front)]\n    ensures front == (old(front) + 1) % circularQueue.Length\n    ensures old(front) < rear ==> Content == old(Content)[old(front)..rear]\n    ensures old(front) > rear ==> Content == old(Content)[0 .. rear] + old(Content)[old(front)..|old(Content)|]\n  /*{\n    if counter == 0 {\n      item := -1;\n\n    } else {\n      item := circularQueue[front];\n      front := (front + 1) % circularQueue.Length;\n      counter := counter - 1;\n    }\n  }*/\n\n\n\n\n  // TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0527", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_contains", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method contains(item: int) returns (contains: bool)\n    ensures contains == true ==> item in circularQueue[..]\n    ensures contains == false ==> item !in circularQueue[..]", "vc-code": "{\n    var i: nat := 0;\n    contains := false;\n\n    while (i < circularQueue.Length)\n      decreases circularQueue.Length - i\n      invariant 0 <= i <= circularQueue.Length\n      invariant !contains ==> forall j :: 0 <= j < i ==> circularQueue[j] != item\n    {\n      if (circularQueue[i] == item) {\n        contains := true;\n        break;\n      }\n      i := i + 1;\n    }\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0528", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_insert", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method insert(item: int)\n    // requires rear <= circularQueue.Length\n    // ensures (front == 0 && rear == 0 && circularQueue.Length == 1) ==>\n    //     (\n    //       Content == [item] &&\n    //       |Content| == 1\n    //     )\n    // ensures circularQueue.Length != 0 ==>\n    // (\n    //   (front == 0 && rear == 0 && circularQueue.Length == 1) ==>\n    //     (\n    //       Content == old(Content)  &&\n    //       |Content| == old(|Content|)\n\n    //     )\n    // ||\n    //   (front == 0 && rear == circularQueue.Length-1 ) ==> \n    //     (\n    //       Content == old(Content) + [item] &&\n    //       |Content| == old(|Content|) + 1\n    //     )\n    // ||\n    //   (rear + 1 != front && rear != circularQueue.Length-1 && rear + 1 < circularQueue.Length - 1) ==> \n    //     (\n    //       Content == old(Content[0..rear]) + [item] + old(Content[rear..circularQueue.Length])\n    //     )\n    // ||\n    //   (rear + 1 == front) ==> \n    //   (\n    //     Content[0..rear + 1] == old(Content[0..rear]) + [item] &&\n    //     forall i :: rear + 2 <= i <= circularQueue.Length ==> Content[i] == old(Content[i-1])\n    //   )\n    // )", "vc-code": "{\n      //counter := counter + 1;\n      // if front == 0 && rear == 0 && circularQueue.Length == 0\n      // {\n      //   var queueInsert: array<int>;\n      //   queueInsert := new int [circularQueue.Length + 1];\n      //   queueInsert[0] := item;\n      //   circularQueue := queueInsert;\n      //   Content := [item];\n      //   rear := rear + 1;\n      // }   \n      // else if front == 0 && rear == circularQueue.Length-1 && circularQueue.Length > 0\n      // {\n      //   var queueInsert: array<int>;\n      //   queueInsert := new int [circularQueue.Length + 1];\n      //   var i: nat := 0;\n      //   while i < circularQueue.Length\n      //   invariant circularQueue.Length + 1 == queueInsert.Length\n      //   {\n      //     queueInsert[i] := circularQueue[i];\n      //     i := i + 1;\n      //   }\n      //   queueInsert[queueInsert.Length - 1] := item;\n      //   Content := Content + [item];\n      //   rear := rear + 1;\n      //   circularQueue := queueInsert;\n      // }\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0529", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_isEmpty", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method isEmpty() returns (isEmpty: bool)\n    ensures isEmpty == true ==> counter == 0;\n    ensures isEmpty == false ==> counter != 0;", "vc-code": "{\n    isEmpty := if counter == 0 then true else false;\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0530", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_remove", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]\n\n\n\n// remove apenas mudando o ponteiro\n  // sem resetar o valor na posição, pois, provavelmente,\n  // vai ser sobrescrito pela inserção", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method remove() returns (item: int)\n    requires front < circularQueue.Length\n    requires circularQueue.Length > 0\n    ensures rear <= |old(Content)|\n    ensures circularQueue.Length > 0\n    ensures item == old(Content)[old(front)]\n    ensures front == (old(front) + 1) % circularQueue.Length\n    ensures old(front) < rear ==> Content == old(Content)[old(front)..rear]\n    ensures old(front) > rear ==> Content == old(Content)[0 .. rear] + old(Content)[old(front)..|old(Content)|]", "vc-code": "{\n    if counter == 0 {\n      item := -1;\n\n    } else {\n      item := circularQueue[front];\n      front := (front + 1) % circularQueue.Length;\n      counter := counter - 1;\n    }\n    assume false;\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0531", "language": "dafny", "source": "dafnybench", "source_id": "circular-queue-implemetation_tmp_tmpnulfdc9l_Queue_size", "vc-description": "", "vc-preamble": "class {:autocontracts} Queue {\n\n  // Atributos\n  var circularQueue: array<int>;\n  var rear: nat;  // cauda\n  var front: nat; // head\n  var counter: nat;\n\n  // Abstração\n  ghost var Content: seq<int>;\n\n  // Predicado\n  ghost predicate Valid()\n  {\n    0 <= counter <= circularQueue.Length &&\n    0 <= front &&\n    0 <= rear &&\n    Content == circularQueue[..]\n  }\n\n  // Construtor\n  constructor()\n    ensures circularQueue.Length == 0\n    ensures front == 0 && rear == 0\n    ensures Content == [] // REVISAR\n    ensures counter == 0\n  {\n    circularQueue := new int[0];\n    rear := 0;\n    front := 0;\n    Content := [];\n    counter := 0;\n  } //[tam] ; [1, 2, 3, 4]", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method size() returns (size:nat)\n    ensures size == counter", "vc-code": "{\n    size := counter;\n}", "vc-postamble": "// TODO\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0536", "language": "dafny", "source": "dafnybench", "source_id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_IsSorted", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IsSorted (a : array<int>) returns (isSorted : bool)\n    ensures isSorted <==> forall j : int :: 1 <= j < a.Length ==> a[j-1] <= a[j]", "vc-code": "{\n    isSorted := true;\n    var i : int := 1;\n    if (a.Length < 2)\n    {\n        return;\n    }\n    else\n    {\n        while (i < a.Length)\n            invariant  1 <= i <= a.Length\n            invariant isSorted <==> forall j: int :: 1 <= j < i ==> a[j-1] <= a[j] // TODO\n        {\n            if a[i-1] > a[i]\n            {\n                return false;\n            }\n            i := i+1;\n        }\n    }\n}", "vc-postamble": "// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0538", "language": "dafny", "source": "dafnybench", "source_id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_PlusOne", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method PlusOne (x : int) returns (y : int)\n    requires x >= 0\n    ensures y > 0", "vc-code": "{\n    y := x+1;\n}", "vc-postamble": "// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds\n// in method Swap (which swaps elements i and j in array a).\n\n\n// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0540", "language": "dafny", "source": "dafnybench", "source_id": "cmsc433_tmp_tmpe3ob3a0o_dafny_project1_p1-assignment-2_Swap", "vc-description": "", "vc-preamble": "// ASSIGNMENT P1\n// CMSC 433 FALL 2023\n// PERFECT SCORE:  100 POINTS\n//\n// This assignment contains nine questions, each of which involves writing Dafny\n// code. You should include your solutions in a single Dafny file and submit it using\n// Gradescope.\n//\n// Revision history\n//\n// 2023-09-22 2:50 pm   Fixed typo in Problem 3.\n\n\n// Question 1 (5 points)\n//\n// Fill in a requires clause that enables Dafny to verify\n// method PlusOne\n\n\n\n// Question 2 (5 points)\n//\n// Fill in requires clause(s) that enable(s) Dafny to verify the array bounds", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// in method Swap (which swaps elements i and j in array a).\n\nmethod Swap (a : array?<int>, i : int, j : int)\n    requires a != null && 0 <= i < a.Length && 0 <= j < a.Length// TODO\n    modifies a  // Dafny requires listing of objects modified in a method", "vc-code": "{\n    var tmp : int := a[i];\n    a[i] := a[j];\n    a[j] := a[i];\n}", "vc-postamble": "// Question 3 (5 points)\n//\n// Give ensures clause(s) asserting that d is the result, and r the\n// remainder, of dividing m by n.  Your clauses cannot use \"/\" or \"%\" (which are\n// the Dafny division and mod operators, respectively). By definition, the\n// remainder must be non-negative.\n\n\n// Question 4 (5 points)\n//\n// Give ensures clause(s) asserting that the return value has the same\n// length as array a and contains as its elements the sum of the\n// corresponding elements in arrays a and b.\n\n\n// Question 5 (10 points)\n\n// Euclid's algorithm is used to compute the greatest common divisor of two\n// positive integers.  If m and n are two such integers, then gcd(m,n) is the\n// largest positve integer that evenly divides both m and n, where j evenly divides i\n// if and only if i % j == 0 (% is the Dafny mod operator).  Write requires and\n// ensures clauses for the method header Euclid below.  Your requires clauses\n// should also specify that the first argument is at least as large as the second.\n// You do *not* need to implement the method!\n\n\n// Question 7 (20 points)\n//\n// Implement, and have Dafny verify, the method IsPrime below, which returns true\n// if and only if the given positive integer is prime.\n\n\n// Question 8 (20 points)\n//\n// Implement, and have Dafny verify, the method Reverse below, which returns a new array\n// aRev consisting of the elements of a, but in reverse order.  To create a new \n// array of ints use the Dafny command \"new int[...]\", where \"...\" is the number\n// of elements in the array.\n\n\n// Question 9 (20 points)\n//\n// Implement and verify method NoDups, which returns true if and only if there\n// are no duplicate elements in array a.  Note that the requires clause allows\n// you to assume that a is sorted, and that this precondition is necessary for\n// the ensures clause to imply a lack of duplicates.", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0542", "language": "dafny", "source": "dafnybench", "source_id": "cs245-verification_tmp_tmp0h_nxhqp_A8_Q2_A8Q1", "vc-description": "", "vc-preamble": "// A8Q2 — Steph Renee McIntyre\n// Following the solutions from Carmen Bruni", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method A8Q1(x: int, y: int, z: int) returns (m: int)\n/*Pre-Condition*/   requires true;\n/*Post-Condition*/  ensures m<=x && m<=y && m<=z;", "vc-code": "{\n  /* (| true |)                               - Pre-Condition */\n      if(z<y){\n      /* (| z<y |)                            - if-then-else  */   \n          if(z<x){\n            /* (| z<y ^ z<=x |)               - if-then-else  */  \n            /* (| z<=x ^ z<=y ^ z<=z |)       - implied (a)   */  \n                m := z;\n            /* (| m<=x ^ m<=y ^ m<=z |)       - assignment    */  \n          }else{\n            /* (| z<y ^ -(z<=x) |)            - if-then-else  */  \n            /* (| x<=x ^ x<=y ^ x<=z |)       - implied (b)   */  \n                m := x;\n            /* (| m<=x ^ m<=y ^ m<=z |)       - assignment    */  \n          }\n      }else{\n      /* (| -(z<y) |)                         - if-then-else  */  \n      /* (| y<=y ^ y<=z |)                    - implied (c)   */  \n          m := y;\n      /* (| m<=y ^ y<=z |)                    - assignment    */  \n          if (x<y){\n            /* (| m<=y ^ y<=z ^ x<y |)        - if-then       */  \n            /* (| x<=x ^ x<=y ^ x<=z |)       - implied (d)   */  \n                m := x;\n            /* (| m<=x ^ m<=y ^ m<=z |)       - assignment    */  \n          }\n      /* (| m<=x ^ m<=y ^ m<=z |)             - if-then: implied (e) */  \n      }\n  /* (| m<=x ^ m<=y ^ m<=z |)                 - if-then-else  */  \n}", "vc-postamble": "/* Proof of implieds can be seen on LEARN.\n    Note: If you are unconvinced, putting asserts for each condition will demonstrate the correctness of the statements. \n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0543", "language": "dafny", "source": "dafnybench", "source_id": "cs245-verification_tmp_tmp0h_nxhqp_Assignments_simple_simple", "vc-description": "", "vc-preamble": "//Simple Assignment Example -- Steph Renee McIntyre\n//Based on the code used in the course overheads for Fall 2018", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method simple(y: int) returns (x: int) \n  requires y==6;\n  ensures x==7;", "vc-code": "{\n    /* (| y = 6 |)  //This is from the requires statement.*/\n\n    /* (| y + 1 = 7 |) - implied (a) */ assert y+1 == 7;\n\n    x := y + 1;\n\n    /* (| x = 7 |) - assignment //This is from the ensures statement. */\n}", "vc-postamble": "/* Proof of implied (a): \n    Let y = 6.\n    Then add 1 to both sides of the equality: y + 1 = 6 + 1\n    Then y + 1 = 7.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0544", "language": "dafny", "source": "dafnybench", "source_id": "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_BubbleSortCode_BubbleSort", "vc-description": "", "vc-preamble": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// The following is just plain old bubble sort.\n//\n// Can you find the invariants for the while loops?\n// Can you annotate this?\n// What about the pre/post-conditions?", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BubbleSort(A: array<int>, n: int)\nmodifies A;\nrequires A.Length>=0 && n==A.Length;", "vc-code": "{\n  var i := 0;\n  var j := 0;\n\n  while(i < n-1){\n    while(j < n-i-1){\n     if(A[j]<A[i]){\n       var t := A[j];\n       A[j] := A[i];\n       A[i] := t;\n     } \n     j := j+1;\n    }\n    i := i+1;\n  }\n}", "vc-postamble": "/*Doesn't my title look all bubbly and cute? I'm trying... */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0548", "language": "dafny", "source": "dafnybench", "source_id": "cs357_tmp_tmpn4fsvwzs_lab7_question2_Two", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Two(x: int) returns (y: int)\nensures y == x + 1", "vc-code": "{\n    assert true;\n    var a:= x+1;\n    assert (a - 1 == 0 ==> x == 0) && (x - 1!= 0 ==> a == x +1);\n    if(a - 1 == 0){\n        y:= 1;\n    } else {\n        y:= a;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0549", "language": "dafny", "source": "dafnybench", "source_id": "cs357_tmp_tmpn4fsvwzs_lab7_question5_A1", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method A1(x: int, y: int) returns (r: int)\nensures r == x + y", "vc-code": "{\n    r:= x;\n    if( y < 0){\n        var n:= y;\n        while(n != 0)\n        invariant r == x + y - n\n        invariant -n >= 0\n        {\n            r:= r-1;\n            n:= n + 1;\n        }\n    } else {\n        var n := y;\n        while(n!= 0)\n        invariant r == x+ y - n\n        invariant n >= 0\n        {\n            r:= r + 1;\n            n:= n - 1;\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0550", "language": "dafny", "source": "dafnybench", "source_id": "cs357_tmp_tmpn4fsvwzs_lab7_question5_M1", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method M1(x: int, y: int) returns (r: int)\nensures r == x*y\ndecreases x < 0, x", "vc-code": "{\n    if (x == 0){\n        r:= 0;\n    } else if( x < 0){\n        r:= M1(-x, y);\n        r:= -r;\n    } else {\n        r:= M1(x-1, y);\n        r:= A1(r, y); \n    }\n}", "vc-postamble": "method A1(x: int, y: int) returns (r: int)\nensures r == x + y\n{\n    r:= x;\n    if( y < 0){\n        var n:= y;\n        while(n != 0)\n        invariant r == x + y - n\n        invariant -n >= 0\n        {\n            r:= r-1;\n            n:= n + 1;\n        }\n    } else {\n        var n := y;\n        while(n!= 0)\n        invariant r == x+ y - n\n        invariant n >= 0\n        {\n            r:= r + 1;\n            n:= n - 1;\n        }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0551", "language": "dafny", "source": "dafnybench", "source_id": "cs686_tmp_tmpdhuh5dza_classNotes_notes-9-8-21_Guess", "vc-description": "", "vc-preamble": "// Forall\n\n// Quantifiers\nclass Secret{\n    var secret : int;\n    var known : bool;\n    var count : int;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Guess(g : int) returns (result : bool, guesses : int)\n    modifies `known, `count\n    requires known == false\n    ensures if g == secret then \n                result == true && known == true \n            else \n                result == false && known == false\n    ensures count == old(count) + 1 && guesses == count", "vc-code": "{\n        if (g == secret)\n        {\n            known := true;\n            result := true;\n        }\n        else\n        {\n            result := false;\n        }\n        count := count + 1;\n        guesses := count;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0552", "language": "dafny", "source": "dafnybench", "source_id": "cs686_tmp_tmpdhuh5dza_classNotes_notes-9-8-21_Init", "vc-description": "", "vc-preamble": "// Forall\n\n// Quantifiers\nclass Secret{\n    var secret : int;\n    var known : bool;\n    var count : int;", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Init(x : int)\n    modifies `secret, `known, `count\n    requires 1 <= x <= 10\n    ensures secret == x\n    ensures known == false\n    ensures count == 0", "vc-code": "{\n        known := false;\n        count := 0;\n        secret := x;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0553", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_DividedConstructors_Mutate", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /env:0 /dprint:- \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n\nmodule M0 {\n  class MyClass {\n    var a: nat\n    const b := 17\n    var c: real\n\n    constructor Init(x: nat)\n    {\n      this.a := x;\n      c := 3.14;\n      new;\n      a := a + b;\n      assert c == 3.14;\n      assert this.a == 17 + x;\n    }\n\n    constructor (z: real)\n      ensures c <= 2.0 * z\n    {\n      a, c := 50, 2.0 * z;\n      new;\n    }\n\n    constructor Make()\n      ensures 10 <= a\n    {\n      new;\n      a := a + b;\n    }\n\n    constructor Create()\n      ensures 30 <= a\n    {\n      new;\n      a := a + 2*b;\n    }\n  }\n}\n\nmodule M1 refines M0 {\n  class MyClass ... {\n    const d := 'D';\n    var e: char;\n\n    constructor Init...\n    {\n      e := 'e';\n      new;\n      e := 'x';\n      ...;\n      assert e == 'x';\n    }\n\n    constructor ...\n    {\n      e := 'y';\n      new;\n    }\n\n    constructor Make...\n    {\n      new;\n      e := 'z';\n    }\n\n    constructor Create...\n    {\n      e := 'w';\n    }\n  }\n}\n\nmodule TypeOfThis {\n  class LinkedList<T(0)> {\n    ghost var Repr: set<LinkedList<T>>\n    ghost var Rapr: set<LinkedList?<T>>\n    ghost var S: set<object>\n    ghost var T: set<object?>\n\n    constructor Init()\n    {\n      Repr := {this};  // regression test: this should pass, but once upon a time didn't\n    }\n\n    constructor Init'()\n    {\n      Rapr := {this};\n    }\n\n    constructor Create()\n    {\n      S := {this};  // regression test: this should pass, but once upon a time didn't\n    }\n\n    constructor Create'()\n    {\n      T := {this};\n    }\n\n    constructor Two()\n    {\n      new;\n      var ll: LinkedList? := this;\n      var o: object? := this;\n      if\n      case true =>  T := {o};\n      case true =>  S := {o};\n      case true =>  Repr := {ll};\n      case true =>  Rapr := {ll};\n      case true =>  S := {ll};\n      case true =>  T := {ll};\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mutate()\n      modifies this", "vc-code": "{\n      Repr := {this};\n      Rapr := {this};\n      S := {this};\n      T := {this};\n}", "vc-postamble": "}\n}\n\nmodule Regression {\n  class A {\n    var b: bool\n    var y: int\n\n    constructor Make0()\n      ensures b == false  // regression test: this didn't used to be provable :O\n    {\n      b := false;\n    }\n    constructor Make1()\n      ensures b == true\n    {\n      b := true;\n    }\n    constructor Make2()\n    {\n      b := false;\n      new;  // this sets \"alloc\" to \"true\", and the verifier previously was not\n            // able to distinguish the internal field \"alloc\" from other boolean\n            // fields\n      assert !b;  // regression test: this didn't used to be provable :O\n    }\n    constructor Make3()\n      ensures b == false && y == 65\n    {\n      b := false;\n      y := 65;\n      new;\n      assert !b;  // regression test: this didn't used to be provable :O\n      assert y == 65;\n    }\n    constructor Make4(bb: bool, yy: int)\n      ensures b == bb && y == yy\n    {\n      b, y := bb, yy;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0554", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_InSetComprehension_Add", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /print:\"%t.print\" /dprint:\"%t.dprint\" /printTooltips \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nlemma Tests<T>(t: T, uu: seq<T>) returns (z: bool)\n  requires 10 <= |uu| && uu[4] == t\n  ensures !z\n{\n  if {\n    case true =>\n      z := 72 in set i | 0 <= i < 10;\n    case true =>\n      z := -8 in set k: nat | k < 10;\n    case true =>\n      z := 6 in set m | 0 <= m < 10 && Even(m) :: m + 1;\n    case true =>\n      z := t !in set u | u in uu;\n    case true =>\n      z := t !in set u {:autotriggers false} | u in uu :: Id(u);\n  }\n}\n\nlemma TestsWhereTriggersMatter<T>(t: T, uu: seq<T>) returns (z: bool)\n  requires 10 <= |uu| && uu[4] == t\n  ensures z\n{\n  if {\n    case true =>\n      z := 7 in set i | 0 <= i < 10;\n    case true =>\n      z := 8 in set k: nat | k < 10;\n    case true =>\n      // In the line below, auto-triggers should pick Even(m)\n      z := 5 in set m | 0 <= m < 10 && Even(m) :: m + 1;\n      // a necessary lemma:\n      assert Even(4);\n    case true =>\n      z := t in set u | u in uu;\n    case true =>\n      z := t in set u {:autotriggers false} | u in uu :: Id(u);\n  }\n}\n\nfunction Id<T>(t: T): T { t }\npredicate Even(x: int) { x % 2 == 0 }\n\nclass Container<T> {\n  ghost var Contents: set<T>\n  var elems: seq<T>", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Add(t: T)\n    requires Contents == set x | x in elems\n    modifies this\n    ensures Contents == set x | x in elems", "vc-code": "{\n    elems := elems + [t];\n    Contents := Contents + {t};\n}", "vc-postamble": "}\n\nclass IntContainer {\n  ghost var Contents: set<int>\n  var elems: seq<int>\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0555", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SeqFromArray_H", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// /autoTriggers:1 added to suppress instabilities", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method H(a: array<int>, c: array<int>, n: nat, j: nat)\n  requires j < n == a.Length == c.Length", "vc-code": "{\n  var A := a[..];\n  var C := c[..];\n\n  if {\n    case A[j] == C[j] =>\n      assert a[j] == c[j];\n    case forall i :: 0 <= i < n ==> A[i] == C[i] =>\n      assert a[j] == c[j];\n    case forall i :: 0 <= i < n ==> A[i] == C[i] =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case true =>\n  }\n}", "vc-postamble": "method M'(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length\n{\n  if {\n    case l+m <= c.Length && forall i :: 0 <= i < m ==> a[i] == c[l+i] =>\n      assert a[..m] == c[l..l+m];\n    case l+a.Length <= c.Length && forall i :: k <= i < a.Length ==> a[i] == c[l+i] =>\n      assert a[k..] == c[l+k..l+a.Length];\n    case l+k+m <= c.Length && forall i :: k <= i < k+m ==> a[i] == c[l+i] =>\n      assert a[k..k+m] == c[l+k..l+k+m];\n    case true =>\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0556", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SeqFromArray_K", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// /autoTriggers:1 added to suppress instabilities", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method K(a: array<int>, c: array<int>, n: nat)\n  requires n <= a.Length && n <= c.Length", "vc-code": "{\n  var A := a[..n];\n  var C := c[..n];\n  if {\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: 0 <= i < n ==> a[i] == c[i];\n    case true =>\n  }\n}", "vc-postamble": "method M'(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length\n{\n  if {\n    case l+m <= c.Length && forall i :: 0 <= i < m ==> a[i] == c[l+i] =>\n      assert a[..m] == c[l..l+m];\n    case l+a.Length <= c.Length && forall i :: k <= i < a.Length ==> a[i] == c[l+i] =>\n      assert a[k..] == c[l+k..l+a.Length];\n    case l+k+m <= c.Length && forall i :: k <= i < k+m ==> a[i] == c[l+i] =>\n      assert a[k..k+m] == c[l+k..l+k+m];\n    case true =>\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0557", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SeqFromArray_L", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// /autoTriggers:1 added to suppress instabilities", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method L(a: array<int>, c: array<int>, n: nat)\n  requires n <= a.Length == c.Length", "vc-code": "{\n  var A := a[n..];\n  var C := c[n..];\n  var h := a.Length - n;\n  if {\n    case A == C =>\n      assert forall i :: 0 <= i < h ==> A[i] == C[i];\n    case A == C =>\n      assert forall i :: n <= i < n + h ==> a[i] == c[i];\n    case true =>\n  }\n}", "vc-postamble": "method M'(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length\n{\n  if {\n    case l+m <= c.Length && forall i :: 0 <= i < m ==> a[i] == c[l+i] =>\n      assert a[..m] == c[l..l+m];\n    case l+a.Length <= c.Length && forall i :: k <= i < a.Length ==> a[i] == c[l+i] =>\n      assert a[k..] == c[l+k..l+a.Length];\n    case l+k+m <= c.Length && forall i :: k <= i < k+m ==> a[i] == c[l+i] =>\n      assert a[k..k+m] == c[l+k..l+k+m];\n    case true =>\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0558", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SeqFromArray_M", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// /autoTriggers:1 added to suppress instabilities", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method M(a: array<int>, c: array<int>, m: nat, n: nat, k: nat, l: nat)\n  requires k + m <= a.Length\n  requires l + n <= c.Length", "vc-code": "{\n  var A := a[k..k+m];\n  var C := c[l..l+n];\n  if A == C {\n    if * {\n      assert m == n;\n    } else if * {\n      assert forall i :: 0 <= i < n ==> A[i] == C[i];\n    } else if * {\n      assert forall i {:nowarn} :: k <= i < k+n ==> A[i-k] == C[i-k];\n    } else if * {\n      assert forall i :: 0 <= i < n ==> A[i] == a[k+i];\n    } else if * {\n      assert forall i :: 0 <= i < n ==> C[i] == c[l+i];\n    } else if * {\n      assert forall i {:nowarn} :: 0 <= i < n ==> a[k+i] == c[l+i];\n    }\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0559", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SharedDestructorsCompile_BaseKlef", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Dt =\n  | A(x: int, y: real)\n  | B(h: MyClass, x: int)\n  | C(y: real)\n\nclass MyClass { }\n\n\ndatatype Klef =\n  | C0(0: int, 1: int, 2: int, c0: int)\n  | C1(1: int, 2: int, 3: int, c1: int)\n  | C2(2: int, 3: int, 0: int, c2: int)\n  | C3(3: int, 0: int, 1: int, c3: int)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BaseKlef(k: Klef)\n  requires !k.C0? && !k.C2? && !k.C1?", "vc-code": "{\n  var k' := k.(0 := 100, c3 := 200);  // makes a C3\n  assert k' == C3(k.3, 100, k.1, 200);\n  print k', \"\\n\";\n}", "vc-postamble": "datatype Datte<T> = AA(a: int, x: int) | BB(b: bool, x: int) | CC(c: real) | DD(x: int, o: set<int>, p: bv27, q: T)", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0560", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_dafny0_SharedDestructorsCompile_Matte", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:cs \"%s\" >> \"%t\"\n// RUN: %dafny /noVerify /compile:4 /compileTarget:py \"%s\" >> \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\ndatatype Dt =\n  | A(x: int, y: real)\n  | B(h: MyClass, x: int)\n  | C(y: real)\n\nclass MyClass { }\n\n\ndatatype Klef =\n  | C0(0: int, 1: int, 2: int, c0: int)\n  | C1(1: int, 2: int, 3: int, c1: int)\n  | C2(2: int, 3: int, 0: int, c2: int)\n  | C3(3: int, 0: int, 1: int, c3: int)\n\n\ndatatype Datte<T> = AA(a: int, x: int) | BB(b: bool, x: int) | CC(c: real) | DD(x: int, o: set<int>, p: bv27, q: T)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Matte(d: Datte<real>)\n  requires !d.CC?", "vc-code": "{\n  var d := d;\n\n  var s := d.(x := 5);\n  print d, \" \", s, \"\\n\";  // AA(10, 2) AA(10, 5)\n\n  d := BB(false, 12);\n  s := d.(x := 6);\n  print d, \" \", s, \"\\n\";  // BB(false, 12) BB(false, 6)\n\n  d := CC(3.2);\n  s := d.(c := 3.4);\n  print d, \" \", s, \"\\n\";  // CC(3.2) CC(3.4)\n\n  d := DD(100, {7}, 5, 9.0);\n  s := d.(x := 30);\n  print d, \" \", s, \"\\n\";  // DD(100, {7}, 5, 9.0) DD(30, {7}, 5, 9.0)\n  s := s.(q := 2.0, p := d.p);\n  print d, \" \", s, \"\\n\";  // DD(100, {7}, 5, 9.0) DD(30, {7}, 5, 2.0)\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0564", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_modifying-arrays_Aliases", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2021\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from material by Graeme Smith\n*/\n\n/////////////////////\n// Modifying arrays \n/////////////////////", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Aliases(a: array<int>, b: array<int>) \n    requires a.Length >= b.Length > 100  \n    modifies a", "vc-code": "{\n  a[0] := 10; \n  var c := a; \n  if b == a { \n    b[10] := b[0] + 1;   // ok since b == a\n  } \n  c[20] := a[14] + 2;    // ok since c == a\n  // b[0] := 4;\n}", "vc-postamble": "// Creating new arrays  \n\n\n\n\n// Initializing arrays \n\nmethod InitArray<T>(a: array<T>, d: T) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{ \n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d; \n    n := n + 1; \n    }\n}\n\n\n// Referring to prestate values of variables\n\n\n\n// Incrementing arrays \n\n\n\n// Copying arrays \n\nmethod CopyArray<T>(a: array<T>, b: array<T>) \n      requires a.Length == b.Length \n      modifies b \n      ensures forall i :: 0 <= i < a.Length ==> b[i] == old(a[i])\n    { \n      var n := 0; \n      while n != a.Length \n        invariant 0 <= n <= a.Length \n        invariant forall i :: 0 <= i < n ==> b[i] == old(a[i]) \n        invariant forall i :: \n                    0 <= i < a.Length ==> a[i] == old(a[i]) \n      { \n      b[n] := a[n];\n        n := n + 1;\n      }\n    }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0565", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_modifying-arrays_IncrementArray", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2021\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from material by Graeme Smith\n*/\n\n/////////////////////\n// Modifying arrays \n/////////////////////\n\n\n\n\n\n\n// Creating new arrays  \n\n\n\n\n// Initializing arrays \n\nmethod InitArray<T>(a: array<T>, d: T) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{ \n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d; \n    n := n + 1; \n    }\n}\n\n\n// Referring to prestate values of variables\n\n\n\n// Incrementing arrays", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IncrementArray(a: array<int>) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[i]) + 1", "vc-code": "{\n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == old(a[i]) + 1\n    invariant forall i :: n <= i < a.Length ==> a[i] == old(a[i])\n  { \n    a[n] := a[n] + 1; \n    n := n + 1; \n  }\n}", "vc-postamble": "// Copying arrays \n\nmethod CopyArray<T>(a: array<T>, b: array<T>) \n      requires a.Length == b.Length \n      modifies b \n      ensures forall i :: 0 <= i < a.Length ==> b[i] == old(a[i])\n    { \n      var n := 0; \n      while n != a.Length \n        invariant 0 <= n <= a.Length \n        invariant forall i :: 0 <= i < n ==> b[i] == old(a[i]) \n        invariant forall i :: \n                    0 <= i < a.Length ==> a[i] == old(a[i]) \n      { \n      b[n] := a[n];\n        n := n + 1;\n      }\n    }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0566", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_modifying-arrays_NewArray", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2021\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from material by Graeme Smith\n*/\n\n/////////////////////\n// Modifying arrays \n/////////////////////\n\n\n\n\n\n\n// Creating new arrays", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method NewArray() returns (a: array<int>) \n  ensures a.Length == 20 \n  ensures fresh(a)", "vc-code": "{\n  a := new int[20]; \n  var b := new int[30]; \n  a[6] := 216; \n  b[7] := 343; \n}", "vc-postamble": "// Initializing arrays \n\nmethod InitArray<T>(a: array<T>, d: T) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{ \n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d; \n    n := n + 1; \n    }\n}\n\n\n// Referring to prestate values of variables\n\n\n\n// Incrementing arrays \n\n\n\n// Copying arrays \n\nmethod CopyArray<T>(a: array<T>, b: array<T>) \n      requires a.Length == b.Length \n      modifies b \n      ensures forall i :: 0 <= i < a.Length ==> b[i] == old(a[i])\n    { \n      var n := 0; \n      while n != a.Length \n        invariant 0 <= n <= a.Length \n        invariant forall i :: 0 <= i < n ==> b[i] == old(a[i]) \n        invariant forall i :: \n                    0 <= i < a.Length ==> a[i] == old(a[i]) \n      { \n      b[n] := a[n];\n        n := n + 1;\n      }\n    }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0567", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_modifying-arrays_SetEndPoints", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2021\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from material by Graeme Smith\n*/\n\n/////////////////////\n// Modifying arrays \n/////////////////////", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SetEndPoints(a: array<int>, left: int, right: int)\n  requires a.Length != 0 \n  modifies a", "vc-code": "{\n  a[0] := left; \n  a[a.Length - 1] := right;  \n}", "vc-postamble": "// Creating new arrays  \n\n\n\n\n// Initializing arrays \n\nmethod InitArray<T>(a: array<T>, d: T) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{ \n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d; \n    n := n + 1; \n    }\n}\n\n\n// Referring to prestate values of variables\n\n\n\n// Incrementing arrays \n\n\n\n// Copying arrays \n\nmethod CopyArray<T>(a: array<T>, b: array<T>) \n      requires a.Length == b.Length \n      modifies b \n      ensures forall i :: 0 <= i < a.Length ==> b[i] == old(a[i])\n    { \n      var n := 0; \n      while n != a.Length \n        invariant 0 <= n <= a.Length \n        invariant forall i :: 0 <= i < n ==> b[i] == old(a[i]) \n        invariant forall i :: \n                    0 <= i < a.Length ==> a[i] == old(a[i]) \n      { \n      b[n] := a[n];\n        n := n + 1;\n      }\n    }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0568", "language": "dafny", "source": "dafnybench", "source_id": "dafl_tmp_tmp_r3_8w3y_dafny_examples_uiowa_modifying-arrays_UpdateElements", "vc-description": "", "vc-preamble": "/*\n   CS:5810 Formal Methods in Software Engineering\n   Fall 2021\n   The University of Iowa\n\n   Instructor: Cesare Tinelli\n\n   Credits: Example adapted from material by Graeme Smith\n*/\n\n/////////////////////\n// Modifying arrays \n/////////////////////\n\n\n\n\n\n\n// Creating new arrays  \n\n\n\n\n// Initializing arrays \n\nmethod InitArray<T>(a: array<T>, d: T) \n  modifies a \n  ensures forall i :: 0 <= i < a.Length ==> a[i] == d\n{ \n  var n := 0; \n  while n != a.Length \n    invariant 0 <= n <= a.Length \n    invariant forall i :: 0 <= i < n ==> a[i] == d\n  {\n    a[n] := d; \n    n := n + 1; \n    }\n}\n\n\n// Referring to prestate values of variables", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method UpdateElements(a: array<int>) \n  requires a.Length == 10 \n  modifies a \n  ensures old(a[4]) < a[4] \n  ensures a[6] <= old(a[6]) \n  ensures a[8] == old(a[8])", "vc-code": "{\n  a[4] := a[4] + 3; \n  a[8] := a[8] + 1; \n  a[7] := 516; \n  a[8] := a[8] - 1; \n}", "vc-postamble": "// Incrementing arrays \n\n\n\n// Copying arrays \n\nmethod CopyArray<T>(a: array<T>, b: array<T>) \n      requires a.Length == b.Length \n      modifies b \n      ensures forall i :: 0 <= i < a.Length ==> b[i] == old(a[i])\n    { \n      var n := 0; \n      while n != a.Length \n        invariant 0 <= n <= a.Length \n        invariant forall i :: 0 <= i < n ==> b[i] == old(a[i]) \n        invariant forall i :: \n                    0 <= i < a.Length ==> a[i] == old(a[i]) \n      { \n      b[n] := a[n];\n        n := n + 1;\n      }\n    }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0575", "language": "dafny", "source": "dafnybench", "source_id": "dafny-duck_tmp_tmplawbgxjo_p2_absx", "vc-description": "", "vc-preamble": "// Given an array of positive and negative integers,\n//  it returns an array of the absolute value of all the integers. [-4,1,5,-2,-5]->[4,1,5,2,5]\n\nfunction abs(x:int):nat {\n\n    if x < 0 then -x else x\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method absx(x:array<int>) returns (y:array<int>) \nensures y.Length == x.Length\nensures forall i :: 0 <= i < y.Length ==>  y[i] == abs(x[i])", "vc-code": "{\n  // put the old array in to new array (declare a new array)\n  // loop through the new array\n  // convert negative to positive by assigning new to be old\n  // increment \n  y:= new int [x.Length];\n  var j:= 0;\n  assert y.Length == x.Length;\n  while (j < y.Length)\n  invariant 0<=j<=y.Length\n  // need to have here equals to make sure we cover the last element  \n  invariant forall i :: 0 <= i < j <= y.Length ==> y[i] == abs(x[i])\n  {\n      if(x[j] < 0) {\n          y[j] := -x[j];\n      } else {\n          y[j] := x[j];\n      }\n      j:= j + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0576", "language": "dafny", "source": "dafnybench", "source_id": "dafny-duck_tmp_tmplawbgxjo_p3_max", "vc-description": "", "vc-preamble": "//Given an array of natural numbers, it returns the maximum value. [5,1,3,6,12,3]->12", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(x:array<nat>) returns (y:nat) \n// for index loop problems\nrequires x.Length > 0\n// ensuring that we maintain y as greater than the elements in the array \nensures forall j :: 0 <= j < x.Length ==> y >= x[j]\n// ensuring that the return value is in the array\nensures y in x[..]", "vc-code": "{\n    y:= x[0];\n    var i := 0;\n    while(i < x.Length)\n    invariant 0 <=i <=x.Length\n    // create new index\n    invariant forall j :: 0 <= j < i ==> y >= x[j]\n    invariant y in x[..]\n    {\n        if(y <= x[i]){\n            y := x[i];\n        }\n\n        i := i + 1;\n    }\n    assert y in x[..];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0584", "language": "dafny", "source": "dafnybench", "source_id": "dafny-exercise_tmp_tmpouftptir_maxArray_MaxArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MaxArray(a: array<int>) returns (max:int)\nrequires a.Length > 0\nensures forall i :: 0 <= i < a.Length ==> a[i] <= max\nensures exists i :: 0 <= i < a.Length && a[i] == max", "vc-code": "{\n    var i: nat := 1;\n    max := a[0];\n    while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> a[j] <= max\n    invariant exists j :: 0 <= j < i && a[j] == max\n    {\n        if (a[i] > max) {\n            max := a[i];\n        }\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0585", "language": "dafny", "source": "dafnybench", "source_id": "dafny-exercise_tmp_tmpouftptir_prac1_ex2_Deli", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Deli(a: array<char>, i: nat)\nmodifies a\nrequires a.Length > 0\nrequires 0 <= i < a.Length\nensures forall j :: 0 <= j < i ==> a[j] == old(a[j])\nensures forall j :: i <= j < a.Length - 1 ==> a[j] == old(a[j + 1])\nensures a[a.Length - 1] == '.'", "vc-code": "{\n    var c := i;\n    while c < a.Length - 1\n    invariant i <= c <= a.Length - 1\n    invariant forall j :: i <= j < c ==> a[j] == old(a[j + 1])\n    // unchanged first half\n    invariant forall j :: 0 <= j < i ==> a[j] == old(a[j])\n    invariant forall j :: c <= j < a.Length ==> a[j] == old(a[j])\n    {\n        a[c] := a[c + 1];\n        c := c + 1;\n    }\n    a[c] := '.';\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0591", "language": "dafny", "source": "dafnybench", "source_id": "dafny-exercises_tmp_tmp5mvrowrx_paper_krml190_Prepend", "vc-description": "", "vc-preamble": "// Examples used in paper:\n//   Specification and Verification of Object-Oriented Software\n// by K. Rustan M. Leino\n// link of the paper:\n//   http://leino.science/papers/krml190.pdf\n\n// Figure 0. An example linked-list program written in Dafny.\nclass Data { }\n\nclass Node {\n  var list: seq<Data>;\n  var footprint: set<Node>;\n\n  var data: Data;\n  var next: Node?;\n\n  function Valid(): bool\n    reads this, footprint\n  {\n    this in footprint &&\n    (next == null ==> list  == [data]) &&\n    (next != null ==> next in footprint &&\n                      next.footprint <= footprint &&\n                      !(this in next.footprint) &&\n                      list == [data] + next.list &&\n                      next.Valid())\n  }\n\n  constructor(d: Data)\n    ensures Valid() && fresh(footprint - {this})\n    ensures list == [d]\n  {\n    data := d;\n    next := null;\n    list := [d];\n    footprint := {this};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Prepend(d: Data) returns (r: Node)\n    requires Valid()\n    ensures r.Valid() && fresh(r.footprint - old(footprint))\n    ensures r.list == [d] + list", "vc-code": "{\n    r := new Node(d);\n    r.data := d;\n    r.next := this;\n    r.footprint := {r} + footprint;\n    r.list := [r.data] + list;\n}", "vc-postamble": "// Figure 1: The Node.ReverseInPlace method,\n  //     which performs an in situ list reversal.\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0592", "language": "dafny", "source": "dafnybench", "source_id": "dafny-exercises_tmp_tmp5mvrowrx_paper_krml190_ReverseInPlace", "vc-description": "", "vc-preamble": "// Examples used in paper:\n//   Specification and Verification of Object-Oriented Software\n// by K. Rustan M. Leino\n// link of the paper:\n//   http://leino.science/papers/krml190.pdf\n\n// Figure 0. An example linked-list program written in Dafny.\nclass Data { }\n\nclass Node {\n  var list: seq<Data>;\n  var footprint: set<Node>;\n\n  var data: Data;\n  var next: Node?;\n\n  function Valid(): bool\n    reads this, footprint\n  {\n    this in footprint &&\n    (next == null ==> list  == [data]) &&\n    (next != null ==> next in footprint &&\n                      next.footprint <= footprint &&\n                      !(this in next.footprint) &&\n                      list == [data] + next.list &&\n                      next.Valid())\n  }\n\n  constructor(d: Data)\n    ensures Valid() && fresh(footprint - {this})\n    ensures list == [d]\n  {\n    data := d;\n    next := null;\n    list := [d];\n    footprint := {this};\n  }\n\n\n\n  // Figure 1: The Node.ReverseInPlace method,\n  //     which performs an in situ list reversal.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ReverseInPlace() returns (reverse: Node)\n    requires Valid()\n    modifies footprint\n    ensures reverse.Valid()\n    // isn't here a typo?\n    ensures fresh(reverse.footprint - old(footprint))\n    ensures |reverse.list| == |old(list)|\n    ensures forall i | 0 <= i < |old(list)| :: old(list)[i] == reverse.list[|old(list)| - 1 - i]", "vc-code": "{\n    var current: Node?;\n    current := next;\n    reverse := this;\n    reverse.next := null;\n    reverse.footprint := {reverse};\n    reverse.list := [data];\n\n    while current != null\n      invariant reverse.Valid()\n      invariant reverse.footprint <= old(footprint)\n      invariant current == null ==> |old(list)| == |reverse.list|\n      invariant current != null ==>\n          current.Valid()\n      invariant current != null ==>\n          current in old(footprint) && current.footprint <= old(footprint)\n      invariant current != null ==>\n          current.footprint !! reverse.footprint\n      invariant current != null ==>\n          |old(list)| == |reverse.list| + |current.list|\n      invariant current != null ==>\n          forall i | 0 <= i < |current.list| ::\n              current.list[i] == old(list)[|reverse.list| + i]\n      invariant forall i | 0 <= i < |reverse.list| ::\n          old(list)[i] == reverse.list[|reverse.list| - 1 - i]\n      decreases |old(list)| - |reverse.list|\n    {\n      var nx: Node?;\n      nx := current.next;\n      assert nx != null ==>\n          forall i | 0 <= i < |nx.list| ::\n              current.list[i + 1] == nx.list[i];\n      // The state looks like: ..., reverse, current, nx, ...\n      assert current.data == current.list[0];\n      current.next := reverse;\n      current.footprint := {current} + reverse.footprint;\n      current.list := [current.data] + reverse.list;\n\n      reverse := current;\n      current := nx;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0593", "language": "dafny", "source": "dafnybench", "source_id": "dafny-exercises_tmp_tmp5mvrowrx_paper_krml190_SkipHead", "vc-description": "", "vc-preamble": "// Examples used in paper:\n//   Specification and Verification of Object-Oriented Software\n// by K. Rustan M. Leino\n// link of the paper:\n//   http://leino.science/papers/krml190.pdf\n\n// Figure 0. An example linked-list program written in Dafny.\nclass Data { }\n\nclass Node {\n  var list: seq<Data>;\n  var footprint: set<Node>;\n\n  var data: Data;\n  var next: Node?;\n\n  function Valid(): bool\n    reads this, footprint\n  {\n    this in footprint &&\n    (next == null ==> list  == [data]) &&\n    (next != null ==> next in footprint &&\n                      next.footprint <= footprint &&\n                      !(this in next.footprint) &&\n                      list == [data] + next.list &&\n                      next.Valid())\n  }\n\n  constructor(d: Data)\n    ensures Valid() && fresh(footprint - {this})\n    ensures list == [d]\n  {\n    data := d;\n    next := null;\n    list := [d];\n    footprint := {this};\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SkipHead() returns (r: Node?)\n    requires Valid()\n    ensures r == null ==> |list| == 1\n    ensures r != null ==> r.Valid() && r.footprint <= footprint", "vc-code": "{\n    return next;\n}", "vc-postamble": "// Figure 1: The Node.ReverseInPlace method,\n  //     which performs an in situ list reversal.\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0595", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_Add", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Spec# and Boogie and Chalice:  The program will be\n// the same, except that these languages do not check\n// for any kind of termination.  Also, in Spec#, there\n// is an issue of potential overflows.\n\n// Benchmark1", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Add(x: int, y: int) returns (r: int)\n  ensures r == x+y;", "vc-code": "{\n  r := x;\n  if (y < 0) {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= -n;\n    {\n      r := r - 1;\n      n := n + 1;\n    }\n  } else {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= n;\n    {\n      r := r + 1;\n      n := n - 1;\n    }\n  }\n}", "vc-postamble": "// ---------------------------", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0596", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b1_Mul", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// Spec# and Boogie and Chalice:  The program will be\n// the same, except that these languages do not check\n// for any kind of termination.  Also, in Spec#, there\n// is an issue of potential overflows.\n\n// Benchmark1\n\nmethod Add(x: int, y: int) returns (r: int)\n  ensures r == x+y;\n{\n  r := x;\n  if (y < 0) {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= -n;\n    {\n      r := r - 1;\n      n := n + 1;\n    }\n  } else {\n    var n := y;\n    while (n != 0)\n      invariant r == x+y-n && 0 <= n;\n    {\n      r := r + 1;\n      n := n - 1;\n    }\n  }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Mul(x: int, y: int) returns (r: int)\n  ensures r == x*y;\n  decreases x < 0, x;", "vc-code": "{\n  if (x == 0) {\n    r := 0;\n  } else if (x < 0) {\n    r := Mul(-x, y);\n    r := -r;\n  } else {\n    r := Mul(x-1, y);\n    r := Add(r, y);\n  }\n}", "vc-postamble": "// ---------------------------", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0597", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_VSI-Benchmarks_b2_BinarySearch", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Benchmark2 {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BinarySearch(a: array<int>, key: int) returns (result: int)\n    requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j];\n    ensures -1 <= result < a.Length;\n    ensures 0 <= result ==> a[result] == key;\n    ensures result == -1 ==> forall i :: 0 <= i < a.Length ==> a[i] != key;", "vc-code": "{\n    var low := 0;\n    var high := a.Length;\n\n    while (low < high)\n      invariant 0 <= low <= high <= a.Length;\n      invariant forall i :: 0 <= i < low ==> a[i] < key;\n      invariant forall i :: high <= i < a.Length ==> key < a[i];\n    {\n      var mid := low + (high - low) / 2;\n      var midVal := a[mid];\n\n      if (midVal < key) {\n        low := mid + 1;\n      } else if (key < midVal) {\n        high := mid;\n      } else {\n        result := mid; // key found\n        return;\n      }\n    }\n    result := -1;  // key not present\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0599", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny1_Cubes_Cubes", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Cubes(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == i*i*i", "vc-code": "{\n  var n := 0;\n  var c := 0;\n  var k := 1;\n  var m := 6;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i :: 0 <= i < n ==> a[i] == i*i*i\n    invariant c == n*n*n\n    invariant k == 3*n*n + 3*n + 1\n    invariant m == 6*n + 6\n  {\n    a[n] := c;\n    c := c + k;\n    k := k + m;\n    m := m + 6;\n    n := n + 1;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0600", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny1_ListReverse_ReverseInPlace", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node {\n  var nxt: Node?", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ReverseInPlace(x: Node?, r: set<Node>) returns (reverse: Node?)\n    requires x == null || x in r;\n    requires (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n    modifies r;\n    ensures reverse == null || reverse in r;\n    ensures (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n    decreases *;", "vc-code": "{\n    var current: Node? := x;\n    reverse := null;\n    while (current != null)\n      invariant current == null || current in r;\n      invariant reverse == null || reverse in r;\n      invariant (forall y :: y in r ==> y.nxt == null || y.nxt in r);  // region closure\n      decreases *;  // omit loop termination check\n    {\n      var tmp := current.nxt;\n      current.nxt := reverse;\n      reverse := current;\n      current := tmp;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0601", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_COST-verif-comp-2011-1-MaxArray_max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(a: array<int>) returns (x: int)\n  requires a.Length != 0\n  ensures 0 <= x < a.Length\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= a[x]", "vc-code": "{\n  x := 0;\n  var y := a.Length - 1;\n  ghost var m := y;\n  while x != y\n    invariant 0 <= x <= y < a.Length\n    invariant m == x || m == y\n    invariant forall i :: 0 <= i < x ==> a[i] <= a[m]\n    invariant forall i :: y < i < a.Length ==> a[i] <= a[m]\n  {\n    if a[x] <= a[y] {\n      x := x + 1;  m := y;\n    } else {\n      y := y - 1;  m := x;\n    }\n  }\n  return x;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0602", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_Intervals_RoundDown", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The RoundDown and RoundUp methods in this file are the ones in the Boogie\n// implementation Source/AbsInt/IntervalDomain.cs.\n\nclass Rounding {\n  var thresholds: array<int>\n\n  function Valid(): bool\n    reads this, thresholds\n  {\n    forall m,n :: 0 <= m < n < thresholds.Length ==> thresholds[m] <= thresholds[n]\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RoundDown(k: int) returns (r: int)\n    requires Valid()\n    ensures -1 <= r < thresholds.Length\n    ensures forall m :: r < m < thresholds.Length ==> k < thresholds[m]\n    ensures 0 <= r ==> thresholds[r] <= k", "vc-code": "{\n    if (thresholds.Length == 0 || k < thresholds[0]) {\n      return -1;\n    }\n    var i, j := 0, thresholds.Length - 1;\n    while (i < j)\n      invariant 0 <= i <= j < thresholds.Length\n      invariant thresholds[i] <= k\n      invariant forall m :: j < m < thresholds.Length ==> k < thresholds[m]\n    {\n      var mid := i + (j - i + 1) / 2;\n      assert i < mid <= j;\n      if (thresholds[mid] <= k) {\n        i := mid;\n      } else {\n        j := mid - 1;\n      }\n    }\n    return i;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0603", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_Intervals_RoundUp", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\n// The RoundDown and RoundUp methods in this file are the ones in the Boogie\n// implementation Source/AbsInt/IntervalDomain.cs.\n\nclass Rounding {\n  var thresholds: array<int>\n\n  function Valid(): bool\n    reads this, thresholds\n  {\n    forall m,n :: 0 <= m < n < thresholds.Length ==> thresholds[m] <= thresholds[n]\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RoundUp(k: int) returns (r: int)\n    requires Valid()\n    ensures 0 <= r <= thresholds.Length\n    ensures forall m :: 0 <= m < r ==> thresholds[m] < k\n    ensures r < thresholds.Length ==> k <= thresholds[r]", "vc-code": "{\n    if (thresholds.Length == 0 || thresholds[thresholds.Length-1] < k) {\n      return thresholds.Length;\n    }\n    var i, j := 0, thresholds.Length - 1;\n    while (i < j)\n      invariant 0 <= i <= j < thresholds.Length\n      invariant k <= thresholds[j]\n      invariant forall m :: 0 <= m < i ==> thresholds[m] < k\n    {\n      var mid := i + (j - i) / 2;\n      assert i <= mid < j;\n      if (thresholds[mid] < k) {\n        i := mid + 1;\n      } else {\n        j := mid;\n      }\n    }\n    return i;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0605", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny2_TreeBarrier_barrier", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node {\n  var left: Node?\n  var right: Node?\n  var parent: Node?\n  var anc: set<Node>\n  var desc: set<Node>\n  var sense: bool\n  var pc: int\n\n\n  predicate validDown()\n    reads this, desc\n  {\n    this !in desc &&\n    left != right &&  // not needed, but speeds up verification\n\n    (right != null ==> right in desc && left !in right.desc) &&\n\n    (left != null ==>\n      left in desc &&\n      (right != null ==> desc == {left,right} + left.desc + right.desc)  &&\n      (right == null ==> desc == {left} + left.desc)  &&\n      left.validDown()) &&\n    (left == null ==>\n      (right != null ==> desc == {right} + right.desc)  &&\n      (right == null ==> desc == {})) &&\n\n    (right != null ==> right.validDown()) &&\n\n    (blocked() ==> forall m :: m in desc ==> m.blocked()) &&\n    (after() ==> forall m :: m in desc ==> m.blocked() || m.after())\n//    (left != null && right != null ==> left.desc !! right.desc)  // not needed\n  }\n\n\n\n\n  predicate validUp()\n    reads this, anc\n  {\n    this !in anc &&\n    (parent != null ==> parent in anc && anc == { parent } + parent.anc && parent.validUp()) &&\n    (parent == null ==> anc == {}) &&\n    (after() ==> forall m :: m in anc ==> m.after())\n  }\n\n  predicate valid()\n    reads this, desc, anc\n  { validUp() && validDown() && desc !! anc }\n\n  predicate before()\n    reads this\n  { !sense && pc <= 2 }\n\n  predicate blocked()\n    reads this\n  { sense }\n\n  predicate after()\n    reads this\n  { !sense && 3 <= pc }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method barrier()\n    requires valid()\n    requires before()\n    modifies this, left, right\n    decreases *  // allow the method to not terminate", "vc-code": "{\n//A\n    pc := 1;\n    if(left != null) {\n      while(!left.sense)\n        modifies left\n        invariant validDown() // this seems necessary to get the necessary unfolding of functions\n        invariant valid()\n        decreases *  // to by-pass termination checking for this loop\n      {\n        // this loop body is supposed to model what the \"left\" thread\n        // might do to its node. This body models a transition from\n        // \"before\" to \"blocked\" by setting sense to true. A transition\n        // all the way to \"after\" is not permitted; this would require\n        // a change of pc.\n        // We assume that \"left\" preserves the validity of its subtree,\n        // which means in particular that it goes to \"blocked\" only if\n        // all its descendants are already blocked.\n        left.sense := *;\n        assume left.blocked() ==> forall m :: m in left.desc ==> m.blocked();\n      }\n    }\n    if(right != null) {\n      while(!right.sense)\n        modifies right\n        invariant validDown() // this seems necessary to get the necessary unfolding of functions\n        invariant valid()\n        decreases *  // to by-pass termination checking for this loop\n      {\n        // analogous to the previous loop\n        right.sense := *;\n        assume right.blocked() ==> forall m :: m in right.desc ==> m.blocked();\n      }\n    }\n\n//B\n    pc := 2;\n    if(parent != null) {\n      sense := true;\n    }\n//C\n    pc := 3;\n    while(sense)\n        modifies this\n        invariant validUp() // this seems necessary to get the necessary unfolding of functions\n        invariant valid()\n        invariant left == old(left)\n        invariant right == old(right)\n        invariant sense ==> parent != null\n        decreases *  // to by-pass termination checking for this loop\n    {\n      // this loop body is supposed to model what the \"parent\" thread\n      // might do to its node. The body models a transition from\n      // \"blocked\" to \"after\" by setting sense to false.\n      // We assume that \"parent\" initiates this transition only\n      // after it went to state \"after\" itself.\n      sense := *;\n      assume !sense ==> parent.after();\n    }\n//D\n    pc := 4;\n    if(left != null) {\n      left.sense := false;\n    }\n//E\n    pc := 5;\n    if(right != null) {\n      right.sense := false;\n    }\n//F\n    pc := 6;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0608", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_Regression19_M", "vc-description": "", "vc-preamble": "// RUN: %dafny \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\npredicate ContainsNothingBut5(s: set<int>)\n{\n  forall q :: q in s ==> q == 5\n}\n\npredicate YeahContains5(s: set<int>)\n{\n  exists q :: q in s && q == 5\n}\n\npredicate ViaSetComprehension(s: set<int>) {\n  |set q | q in s && q == 5| != 0\n}\n\npredicate LambdaTest(s: set<int>) {\n  (q => q in s)(5)\n}\n\npredicate ViaMapComprehension(s: set<int>) {\n  |(map q | q in s && q == 5 :: true).Keys| != 0\n}\n\npredicate Contains5(s: set<int>)\n{\n  var q := 5; q in s\n}\n\ndatatype R = MakeR(int) | Other\n\npredicate RIs5(r: R) {\n  match r case MakeR(q) => q == 5 case Other => false\n}\n\nlemma NonemptySet(x: int, s: set<int>)\n  requires x in s\n  ensures |s| != 0\n{\n}\nlemma NonemptyMap(x: int, s: map<int,bool>)\n  requires x in s.Keys\n  ensures |s| != 0\n{\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method M(s: set<int>, r: R, q: int)\n  requires s == {5} && r == MakeR(5)", "vc-code": "{\n  assert ContainsNothingBut5(s);  // forall\n  assert YeahContains5(s);  // exists\n\n  NonemptySet(5, set q | q in s && q == 5);\n  assert ViaSetComprehension(s);  // set comprehension\n\n  NonemptyMap(5, map q | q in s && q == 5 :: true);\n  assert ViaMapComprehension(s);  // map comprehension\n\n  assert LambdaTest(s);  // lambda expression\n  assert Contains5(s);  // let expression (once had generated malformed Boogie)\n\n  assert RIs5(r);  // match expression\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0609", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_git-issue67_AuxMethod", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node { }\n\npredicate Q(x: Node)\npredicate P(x: Node)", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AuxMethod(y: Node)\n  modifies y\n\nmethod MainMethod(y: Node)\n  modifies y", "vc-code": "{\n  AuxMethod(y);  // remove this call and the assertion below goes through (as it should)\n\n  forall x | Q(x)\n    ensures P(x)\n  {\n    assume false;\n  }\n  // The following assertion should be a direct consequence of the forall statement above\n  assert forall x :: Q(x) ==> P(x);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0610", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_dafny4_git-issue67_MainMethod", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Node { }\n\npredicate Q(x: Node)\npredicate P(x: Node)\n\nmethod AuxMethod(y: Node)\n  modifies y", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MainMethod(y: Node)\n  modifies y", "vc-code": "{\n  AuxMethod(y);  // remove this call and the assertion below goes through (as it should)\n\n  forall x | Q(x)\n    ensures P(x)\n  {\n    assume false;\n  }\n  // The following assertion should be a direct consequence of the forall statement above\n  assert forall x :: Q(x) ==> P(x);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0612", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_vacid0_Composite_Add", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Composite {\n  var left: Composite?\n  var right: Composite?\n  var parent: Composite?\n  var val: int\n  var sum: int\n\n  function Valid(S: set<Composite>): bool\n    reads this, parent, left, right\n  {\n    this in S &&\n    (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&\n    (left != null ==> left in S && left.parent == this && left != right) &&\n    (right != null ==> right in S && right.parent == this && left != right) &&\n    sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n  }\n\n  function Acyclic(S: set<Composite>): bool\n    reads S\n  {\n    this in S &&\n    (parent != null ==> parent.Acyclic(S - {this}))\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Add(ghost S: set<Composite>, child: Composite, ghost U: set<Composite>) \n    requires this in S && Acyclic(S)\n    requires forall c :: c in S ==> c.Valid(S)\n    requires child in U\n    requires forall c :: c in U ==> c.Valid(U)\n    requires S !! U\n    requires left == null || right == null\n    requires child.parent == null\n    // modifies only one of this.left and this.right, and child.parent, and various sum fields:\n    modifies S, child\n    ensures child.left == old(child.left) && child.right == old(child.right) && child.val == old(child.val)\n    ensures forall c :: c in S && c != this ==> c.left == old(c.left) && c.right == old(c.right)\n    ensures old(left) != null ==> left == old(left)\n    ensures old(right) != null ==> right == old(right)\n    ensures forall c :: c in S ==> c.parent == old(c.parent) && c.val == old(c.val)\n    // sets child.parent to this:\n    ensures child.parent == this\n    // leaves everything in S+U valid\n    ensures forall c: Composite {:autotriggers false} :: c in S+U ==> c.Valid(S+U) // We can't generate a trigger for this at the moment; if we did, we would still need to prevent TrSplitExpr from translating c in S+U to S[c] || U[c].", "vc-code": "{\n    if (left == null) {\n      left := child;\n    } else {\n      right := child;\n    }\n    child.parent := this;\n    Adjust(child.sum, S, S+U);\n}", "vc-postamble": "/*private*/ method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)\n    requires U <= S && Acyclic(U)\n    // everything else is valid:\n    requires forall c :: c in S && c != this ==> c.Valid(S)\n    // this is almost valid:\n    requires parent != null ==> parent in S && (parent.left == this || parent.right == this)\n    requires left != null ==> left in S && left.parent == this && left != right\n    requires right != null ==> right in S && right.parent == this && left != right\n    // ... except that sum needs to be adjusted by delta:\n    requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n    // modifies sum fields in U:\n    modifies U`sum\n    // everything is valid, including this:\n    ensures forall c :: c in S ==> c.Valid(S)\n  {\n    var p: Composite? := this;\n    ghost var T := U;\n    while (p != null)\n      invariant T <= U\n      invariant p == null || p.Acyclic(T)\n      invariant forall c :: c in S && c != p ==> c.Valid(S)\n      invariant p != null ==> p.sum + delta == p.val + (if p.left == null then 0 else p.left.sum) + (if p.right == null then 0 else p.right.sum)\n      invariant forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent) && c.val == old(c.val)\n      decreases T\n    {\n      p.sum := p.sum + delta;\n      T := T - {p};\n      p := p.parent;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0613", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_vacid0_Composite_Adjust", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Composite {\n  var left: Composite?\n  var right: Composite?\n  var parent: Composite?\n  var val: int\n  var sum: int\n\n  function Valid(S: set<Composite>): bool\n    reads this, parent, left, right\n  {\n    this in S &&\n    (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&\n    (left != null ==> left in S && left.parent == this && left != right) &&\n    (right != null ==> right in S && right.parent == this && left != right) &&\n    sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n  }\n\n  function Acyclic(S: set<Composite>): bool\n    reads S\n  {\n    this in S &&\n    (parent != null ==> parent.Acyclic(S - {this}))\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)\n    requires U <= S && Acyclic(U)\n    // everything else is valid:\n    requires forall c :: c in S && c != this ==> c.Valid(S)\n    // this is almost valid:\n    requires parent != null ==> parent in S && (parent.left == this || parent.right == this)\n    requires left != null ==> left in S && left.parent == this && left != right\n    requires right != null ==> right in S && right.parent == this && left != right\n    // ... except that sum needs to be adjusted by delta:\n    requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n    // modifies sum fields in U:\n    modifies U`sum\n    // everything is valid, including this:\n    ensures forall c :: c in S ==> c.Valid(S)", "vc-code": "{\n    var p: Composite? := this;\n    ghost var T := U;\n    while (p != null)\n      invariant T <= U\n      invariant p == null || p.Acyclic(T)\n      invariant forall c :: c in S && c != p ==> c.Valid(S)\n      invariant p != null ==> p.sum + delta == p.val + (if p.left == null then 0 else p.left.sum) + (if p.right == null then 0 else p.right.sum)\n      invariant forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent) && c.val == old(c.val)\n      decreases T\n    {\n      p.sum := p.sum + delta;\n      T := T - {p};\n      p := p.parent;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0614", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_vacid0_Composite_Dislodge", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Composite {\n  var left: Composite?\n  var right: Composite?\n  var parent: Composite?\n  var val: int\n  var sum: int\n\n  function Valid(S: set<Composite>): bool\n    reads this, parent, left, right\n  {\n    this in S &&\n    (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&\n    (left != null ==> left in S && left.parent == this && left != right) &&\n    (right != null ==> right in S && right.parent == this && left != right) &&\n    sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n  }\n\n  function Acyclic(S: set<Composite>): bool\n    reads S\n  {\n    this in S &&\n    (parent != null ==> parent.Acyclic(S - {this}))\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Dislodge(ghost S: set<Composite>) \n    requires this in S && Acyclic(S)\n    requires forall c :: c in S ==> c.Valid(S)\n    modifies S\n    ensures forall c :: c in S ==> c.Valid(S)\n    ensures forall c :: c in S ==> c.val == old(c.val)\n    ensures forall c :: c in S && c != this ==> c.parent == old(c.parent)\n    ensures parent == null\n    ensures forall c :: c in S ==> c.left == old(c.left) || (old(c.left) == this && c.left == null)\n    ensures forall c :: c in S ==> c.right == old(c.right) || (old(c.right) == this && c.right == null)\n    ensures Acyclic({this})", "vc-code": "{\n    var p := parent;\n    parent := null;\n    if (p != null) {\n      if (p.left == this) {\n        p.left := null;\n      } else {\n        p.right := null;\n      }\n      var delta := -sum;\n      p.Adjust(delta, S - {this}, S);\n    }\n}", "vc-postamble": "/*private*/ method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)\n    requires U <= S && Acyclic(U)\n    // everything else is valid:\n    requires forall c :: c in S && c != this ==> c.Valid(S)\n    // this is almost valid:\n    requires parent != null ==> parent in S && (parent.left == this || parent.right == this)\n    requires left != null ==> left in S && left.parent == this && left != right\n    requires right != null ==> right in S && right.parent == this && left != right\n    // ... except that sum needs to be adjusted by delta:\n    requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n    // modifies sum fields in U:\n    modifies U`sum\n    // everything is valid, including this:\n    ensures forall c :: c in S ==> c.Valid(S)\n  {\n    var p: Composite? := this;\n    ghost var T := U;\n    while (p != null)\n      invariant T <= U\n      invariant p == null || p.Acyclic(T)\n      invariant forall c :: c in S && c != p ==> c.Valid(S)\n      invariant p != null ==> p.sum + delta == p.val + (if p.left == null then 0 else p.left.sum) + (if p.right == null then 0 else p.right.sum)\n      invariant forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent) && c.val == old(c.val)\n      decreases T\n    {\n      p.sum := p.sum + delta;\n      T := T - {p};\n      p := p.parent;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0615", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_vacid0_Composite_Init", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Composite {\n  var left: Composite?\n  var right: Composite?\n  var parent: Composite?\n  var val: int\n  var sum: int\n\n  function Valid(S: set<Composite>): bool\n    reads this, parent, left, right\n  {\n    this in S &&\n    (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&\n    (left != null ==> left in S && left.parent == this && left != right) &&\n    (right != null ==> right in S && right.parent == this && left != right) &&\n    sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n  }\n\n  function Acyclic(S: set<Composite>): bool\n    reads S\n  {\n    this in S &&\n    (parent != null ==> parent.Acyclic(S - {this}))\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Init(x: int)\n    modifies this\n    ensures Valid({this}) && Acyclic({this}) && val == x && parent == null", "vc-code": "{\n    parent := null;\n    left := null;\n    right := null;\n    val := x;\n    sum := val;\n}", "vc-postamble": "/*private*/ method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)\n    requires U <= S && Acyclic(U)\n    // everything else is valid:\n    requires forall c :: c in S && c != this ==> c.Valid(S)\n    // this is almost valid:\n    requires parent != null ==> parent in S && (parent.left == this || parent.right == this)\n    requires left != null ==> left in S && left.parent == this && left != right\n    requires right != null ==> right in S && right.parent == this && left != right\n    // ... except that sum needs to be adjusted by delta:\n    requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n    // modifies sum fields in U:\n    modifies U`sum\n    // everything is valid, including this:\n    ensures forall c :: c in S ==> c.Valid(S)\n  {\n    var p: Composite? := this;\n    ghost var T := U;\n    while (p != null)\n      invariant T <= U\n      invariant p == null || p.Acyclic(T)\n      invariant forall c :: c in S && c != p ==> c.Valid(S)\n      invariant p != null ==> p.sum + delta == p.val + (if p.left == null then 0 else p.left.sum) + (if p.right == null then 0 else p.right.sum)\n      invariant forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent) && c.val == old(c.val)\n      decreases T\n    {\n      p.sum := p.sum + delta;\n      T := T - {p};\n      p := p.parent;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0616", "language": "dafny", "source": "dafnybench", "source_id": "dafny-language-server_tmp_tmpkir0kenl_Test_vacid0_Composite_Update", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:0 \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nclass Composite {\n  var left: Composite?\n  var right: Composite?\n  var parent: Composite?\n  var val: int\n  var sum: int\n\n  function Valid(S: set<Composite>): bool\n    reads this, parent, left, right\n  {\n    this in S &&\n    (parent != null ==> parent in S && (parent.left == this || parent.right == this)) &&\n    (left != null ==> left in S && left.parent == this && left != right) &&\n    (right != null ==> right in S && right.parent == this && left != right) &&\n    sum == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n  }\n\n  function Acyclic(S: set<Composite>): bool\n    reads S\n  {\n    this in S &&\n    (parent != null ==> parent.Acyclic(S - {this}))\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Update(x: int, ghost S: set<Composite>) \n    requires this in S && Acyclic(S)\n    requires forall c :: c in S ==> c.Valid(S)\n    modifies S\n    ensures forall c :: c in S ==> c.Valid(S)\n    ensures forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent)\n    ensures forall c :: c in S && c != this ==> c.val == old(c.val)\n    ensures val == x", "vc-code": "{\n    var delta := x - val;\n    val := x;\n    Adjust(delta, S, S);\n}", "vc-postamble": "/*private*/ method Adjust(delta: int, ghost U: set<Composite>, ghost S: set<Composite>)\n    requires U <= S && Acyclic(U)\n    // everything else is valid:\n    requires forall c :: c in S && c != this ==> c.Valid(S)\n    // this is almost valid:\n    requires parent != null ==> parent in S && (parent.left == this || parent.right == this)\n    requires left != null ==> left in S && left.parent == this && left != right\n    requires right != null ==> right in S && right.parent == this && left != right\n    // ... except that sum needs to be adjusted by delta:\n    requires sum + delta == val + (if left == null then 0 else left.sum) + (if right == null then 0 else right.sum)\n    // modifies sum fields in U:\n    modifies U`sum\n    // everything is valid, including this:\n    ensures forall c :: c in S ==> c.Valid(S)\n  {\n    var p: Composite? := this;\n    ghost var T := U;\n    while (p != null)\n      invariant T <= U\n      invariant p == null || p.Acyclic(T)\n      invariant forall c :: c in S && c != p ==> c.Valid(S)\n      invariant p != null ==> p.sum + delta == p.val + (if p.left == null then 0 else p.left.sum) + (if p.right == null then 0 else p.right.sum)\n      invariant forall c :: c in S ==> c.left == old(c.left) && c.right == old(c.right) && c.parent == old(c.parent) && c.val == old(c.val)\n      decreases T\n    {\n      p.sum := p.sum + delta;\n      T := T - {p};\n      p := p.parent;\n    }\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0618", "language": "dafny", "source": "dafnybench", "source_id": "dafny-learn_tmp_tmpn94ir40q_R01_assertions_Abs", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x: int) returns (y: int)\n  ensures 0 <= y\n  ensures x < 0 ==> y == -x\n  ensures x >= 0 ==> y == x", "vc-code": "{\n  if x < 0 {\n    return -x;\n  } else {\n    return x;\n  }\n}", "vc-postamble": "// Exercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n// Use your code from Exercise 0", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0619", "language": "dafny", "source": "dafnybench", "source_id": "dafny-learn_tmp_tmpn94ir40q_R01_assertions_Max", "vc-description": "", "vc-preamble": "// Exercise 1. Write a test method that calls your Max method from Exercise 0 and then asserts something about the result.\n// Use your code from Exercise 0", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b: int) returns (c: int)\n  ensures c >= a\n  ensures c >= b", "vc-code": "{\n  c := a;\n  if b > c {\n    c := b;\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0620", "language": "dafny", "source": "dafnybench", "source_id": "dafny-learn_tmp_tmpn94ir40q_R01_functions_Abs", "vc-description": "", "vc-preamble": "function abs(x: int): int\n{\n    if x < 0 then -x else x\n}\n\n\n\n// Exercise 4. Write a function max that returns the larger of two given integer parameters. Write a test method using an assert that checks that your function is correct.\n\nfunction max(a: int, b: int): int\n{\n    // Fill in an expression here.\n    if a > b then a else b\n}\n\n\n// Exercise 6:", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x: int) returns (y: int)\n    ensures abs(x) == y", "vc-code": "{\n    // Then change this body to also use abs.\n    if x < 0 {\n        return -x;\n    } else {\n        return x;\n    }\n}", "vc-postamble": "// Ghost\nghost function Double(val:int) : int\n{\n    2 * val\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0621", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_add", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n  // Adds message m to the mailbox", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method add(m: Message)\n    modifies this\n    ensures m in messages\n    ensures messages == old(messages) + {m}", "vc-code": "{\n    messages := { m } + messages;\n}", "vc-postamble": "}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0622", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_addRecipient", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addRecipient(p: nat, r: Address)\n    modifies this\n    requires p < |recipients|\n    ensures |recipients| == |old(recipients)| + 1\n    ensures recipients[p] == r\n    ensures forall i :: 0 <= i < p ==> recipients[i] == old(recipients[i])\n    ensures forall i :: p < i < |recipients| ==> recipients[i] == old(recipients[i-1])", "vc-code": "{\n    this.recipients := this.recipients[..p] + [r] + this.recipients[p..];\n}", "vc-postamble": "}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n  // Empties the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0623", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_deleteMailbox", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method deleteMailbox(mb: Mailbox)\n    requires Valid()\n    requires mb in userboxList\n    // ensures mb !in userboxList", "vc-code": "{\n    // userboxList := rem(mb, userboxList);\n}", "vc-postamble": "// Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0624", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_deleteMessage", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n  method moveMessage (m: Message, mb1: Mailbox, mb2: Mailbox)\n    modifies mb1, mb2\n    requires Valid()\n    requires m in mb1.messages\n    requires m !in mb2.messages\n    ensures m !in mb1.messages\n    ensures m in mb2.messages\n  {\n    assume false;\n   // mb1.remove(m);\n   // mb2.add(m);\n  }\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method deleteMessage (m: Message, mb: Mailbox)\n    modifies m, mb, this.trash\n    requires Valid()\n    requires m in mb.messages\n    requires m !in trash.messages", "vc-code": "{\n    moveMessage(m, mb, trash);\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0625", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_empty", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n\n  // Empties the mailbox messages", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method empty()\n    modifies this\n    ensures messages == {}", "vc-code": "{\n    messages := {};\n}", "vc-postamble": "}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0626", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_emptyTrash", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n  // Empties the mailbox messages\n  method empty()\n    modifies this\n    ensures messages == {}\n  {\n    messages := {};\n  }\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n  // Empties the trash mailbox", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method emptyTrash()\n    modifies this.trash\n    requires Valid()\n    ensures trash.messages == {}", "vc-code": "{\n    trash.empty();\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0627", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_moveMessage", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n  // Adds message m to the mailbox\n  method add(m: Message)\n    modifies this\n    ensures m in messages\n    ensures messages == old(messages) + {m}\n  {\n    messages := { m } + messages;\n  }\n\n  // Removes message m from mailbox. m must not be in the mailbox.\n  method remove(m: Message)\n    modifies this\n    requires m in messages\n    ensures m !in messages\n    ensures messages == old(messages) - {m}\n  {\n    messages := messages - { m };\n  }\n\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method moveMessage (m: Message, mb1: Mailbox, mb2: Mailbox)\n    modifies mb1, mb2\n    requires Valid()\n    requires m in mb1.messages\n    requires m !in mb2.messages\n    ensures m !in mb1.messages\n    ensures m in mb2.messages", "vc-code": "{\n    mb1.remove(m);\n    mb2.add(m);\n}", "vc-postamble": "// Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0628", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_newMailbox", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method newMailbox(n: string)\n    modifies this\n    requires Valid()\n    requires !exists mb | mb in userboxList :: mb.name == n\n    ensures exists mb | mb in userboxList :: mb.name == n", "vc-code": "{\n    var mb := new Mailbox(n);\n    userboxList := [mb] + userboxList;\n}", "vc-postamble": "// Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0629", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_newMessage", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n  // Adds message m to the mailbox\n  method add(m: Message)\n    modifies this\n    ensures m in messages\n    ensures messages == old(messages) + {m}\n  {\n    messages := { m } + messages;\n  }\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method newMessage(s: Address)\n    modifies this.drafts\n    requires Valid()\n    ensures exists m | m in drafts.messages :: m.sender == s", "vc-code": "{\n    var m := new Message(s);\n    drafts.add(m);\n}", "vc-postamble": "// Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0630", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_remove", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n  // Removes message m from mailbox. m must not be in the mailbox.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method remove(m: Message)\n    modifies this\n    requires m in messages\n    ensures m !in messages\n    ensures messages == old(messages) - {m}", "vc-code": "{\n    messages := messages - { m };\n}", "vc-postamble": "}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n  // Empties the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0631", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_sendMessage", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }\n\n\n\n}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n  method remove(m: Message)\n    modifies this\n    requires m in messages\n    ensures m !in messages\n  {\n    messages := messages - {m};\n  } \n\n  method add(m: Message)\n    modifies this\n    requires m !in messages\n    ensures m in messages\n  {\n    messages := messages + {m};\n  }\n\n  // Removes message m from mailbox. m must not be in the mailbox.\n\n\n  // Empties the mailbox messages\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n  method moveMessage (m: Message, mb1: Mailbox, mb2: Mailbox)\n    modifies mb1, mb2\n    requires Valid()\n    requires m in mb1.messages\n    requires m !in mb2.messages\n    ensures m !in mb1.messages\n    ensures m in mb2.messages\n  {\n    mb1.remove(m);\n    mb2.add(m);\n  }\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method sendMessage(m: Message)\n    modifies this.drafts, this.sent\n    requires Valid()\n    requires m in drafts.messages\n    requires m !in sent.messages", "vc-code": "{\n    moveMessage(m, drafts, sent);\n}", "vc-postamble": "// Empties the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0632", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_setContent", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method setContent(c: string)\n    modifies this\n    ensures content == c", "vc-code": "{\n    this.content := c;\n}", "vc-postamble": "}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n  // Empties the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0633", "language": "dafny", "source": "dafnybench", "source_id": "dafny-mini-project_tmp_tmpjxr3wzqh_src_project2a_setDate", "vc-description": "", "vc-preamble": "/*\n  ===============================================\n  DCC831 Formal Methods\n  2023.2\n\n  Mini Project 2 - Part A\n\n  Your name: Guilherme de Oliveira Silva\n  ===============================================\n*/\n\n\nfunction rem<T(==)>(x: T, s: seq<T>): seq<T> \n  // decreases s\n  ensures x !in rem(x, s)\n  ensures forall i :: 0 <= i < |rem(x, s)| ==> rem(x, s)[i] in s\n  ensures forall i :: 0 <= i < |s| && s[i] != x ==> s[i] in rem(x, s)\n{\n  if |s| == 0 then []\n  else if s[0] == x then rem(x, s[1..])\n  else [s[0]] + rem(x, s[1..])\n}\n\n\n// The next three classes have a minimal class definition,\n// for simplicity\nclass Address\n{\n  constructor () {}\n}\n\nclass Date\n{\n  constructor () {}\n}\n\nclass MessageId\n{\n  constructor () {}\n}\n\n//==========================================================\n//  Message\n//==========================================================\nclass Message\n{\n  var id: MessageId\n  var content: string\n  var date: Date\n  var sender: Address\n  var recipients: seq<Address>\n\n  constructor (s: Address)\n    ensures fresh(id)\n    ensures fresh(date)\n    ensures content == \"\"\n    ensures sender == s\n    ensures recipients == []\n  {\n    id := new MessageId();\n    date := new Date();\n    this.content := \"\";\n    this.sender := s;\n    this.recipients := [];\n  }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method setDate(d: Date)\n    modifies this\n    ensures date == d", "vc-code": "{\n    this.date := d;\n}", "vc-postamble": "}\n\n//==========================================================\n//  Mailbox\n//==========================================================\n// Each Mailbox has a name, which is a string. Its main content is a set of messages.\nclass Mailbox {\n  var messages: set<Message>\n  var name: string\n\n  // Creates an empty mailbox with name n\n  constructor (n: string)\n    ensures name == n\n    ensures messages == {}\n  {\n    name := n;\n    messages := {};\n  }\n\n\n\n  // Empties the mailbox messages\n\n}\n\n//==========================================================\n//  MailApp\n//==========================================================\nclass MailApp {\n  // abstract field for user defined boxes\n  ghost var userboxes: set<Mailbox>\n\n  // the inbox, drafts, trash and sent are both abstract and concrete\n  var inbox: Mailbox\n  var drafts: Mailbox\n  var trash: Mailbox\n  var sent: Mailbox\n\n  // userboxList implements userboxes\n  var userboxList: seq<Mailbox>\n\n  // Class invariant\n  ghost predicate Valid()\n    reads this\n  {\n    //----------------------------------------------------------\n    // Abstract state invariants\n    //----------------------------------------------------------\n    // all predefined mailboxes (inbox, ..., sent) are distinct\n    inbox != drafts &&\n    inbox != trash &&\n    inbox != sent &&\n    drafts != trash &&\n    drafts != sent &&\n\n    // none of the predefined mailboxes are in the set of user-defined mailboxes\n    inbox !in userboxList &&\n    drafts !in userboxList &&\n    trash !in userboxList &&\n    sent !in userboxList &&\n\n    //----------------------------------------------------------\n    // Abstract-to-concrete state invariants\n    //----------------------------------------------------------\n    // userboxes is the set of mailboxes in userboxList\n    forall i :: 0 <= i < |userboxList| ==> userboxList[i] in userboxes\n  }\n\n  constructor ()\n  {\n    inbox := new Mailbox(\"Inbox\");\n    drafts := new Mailbox(\"Drafts\");\n    trash := new Mailbox(\"Trash\");\n    sent := new Mailbox(\"Sent\");\n    userboxList := [];\n  }\n\n  // Deletes user-defined mailbox mb\n\n  // Adds a new mailbox with name n to set of user-defined mailboxes\n  // provided that no user-defined mailbox has name n already\n\n  // Adds a new message with sender s to the drafts mailbox\n\n  // Moves message m from mailbox mb1 to a different mailbox mb2\n\n  // Moves message m from mailbox mb to the trash mailbox provided\n  // that mb is not the trash mailbox\n\n  // Moves message m from the drafts mailbox to the sent mailbox\n\n  // Empties the trash mailbox\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0636", "language": "dafny", "source": "dafnybench", "source_id": "dafny-programs_tmp_tmpcwodh6qh_src_max_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b: int) returns (c: int)\n  ensures a >= b ==> c == a\n  ensures b >= a ==> c == b", "vc-code": "{\n if a > b {\n   return a;\n } else {\n   return b;\n }\n}", "vc-postamble": "function max(a: int, b: int): int\n{\n  if a > b then a else b\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0637", "language": "dafny", "source": "dafnybench", "source_id": "dafny-programs_tmp_tmpcwodh6qh_src_ticketsystem_Enter", "vc-description": "", "vc-preamble": "// Code taken from the following paper: http://leino.science/papers/krml260.pdf\n\n// Each philosopher's pseudocode:\n\n// repeat forever {\n//     Thinking:\n\n//     t: Ticket = ticket, ticket + 1 // request ticket to enter hungry state\n//     Hungry:\n//     //...\n\n//     wait until serving = t; // Enter\n//     Eating:\n//     //...\n\n//     serving := serving + 1; // Leaving\n// }\n\n// control state values; thinking, hungry, eating\n// introduce state for each process: use map from processes to values\n\ntype Process(==) // {type comes equipped with ability to compare its values with equality}\ndatatype CState = Thinking | Hungry | Eating\n\n// provides mutual exclusion\nclass TicketSystem {\n    var ticket: int\n    var serving: int\n    const P: set<Process>\n\n    var cs: map<Process, CState> // cannot use state variable P as domain for maps => use Process => every conceivable process\n    var t: map<Process, int> // ticket number for each philosopher\n\n    // how to know some process p is in domain of map: introduce function which tells whether condition holds or not\n    predicate Valid() // function which describes system invariant\n        reads this // may depend on values in the class\n    {\n        P <= cs.Keys && P <= t.Keys && serving <= ticket && // ticket may be greater than serving but not the other way around\n        (forall p :: p in P && cs[p] != Thinking ==> serving <= t[p] < ticket) && // any current ticket number is in the range of serving to ticket\n        (forall p,q :: \n            p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking ==> t[p] != t[q] // some other process may have a value equal to 'serving'\n        ) && \n        (forall p :: p in P && cs[p] == Eating ==> t[p] == serving) // if eating, the current ticket number must be the one being served\n    }\n\n    constructor (processes: set<Process>)\n        ensures Valid() // postcondition\n    {\n        P := processes;\n        ticket, serving := 0,  0;\n        cs := map p | p in processes :: Thinking; // set initial state of every process to Thinking\n        t := map p | p in processes :: 0;\n\n    }\n\n    // atomic events to formalize for each process: request, enter, leave\n    // model each atomic event by a method\n\n    // atomicity: read or write just once in body\n    // method AtomicStep(p: Process)\n    //     requires Valid() && p in P && cs[p] == Thinking // Request(p) is only enabled when p is thinking\n    //     modifies this\n    //     ensures Valid()", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Enter(p: Process)\n        requires Valid() && p in P && cs[p] == Hungry\n        modifies this\n        ensures Valid()", "vc-code": "{\n        if t[p] == serving {\n            cs := cs[p := Eating]; // map update p to eating state\n        }\n}", "vc-postamble": "// correctness: no two process are in eating state at same time\n    // prove that invariant implies condition\n    lemma MutualExclusion(p: Process, q: Process)\n        requires Valid() && p in P && q in P // if system is in valid state and both p, q are processes\n        requires cs[p] == Eating && cs[q] == Eating // both p, q are in Eating state\n        ensures p == q // p and q are the same process       \n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0638", "language": "dafny", "source": "dafnybench", "source_id": "dafny-programs_tmp_tmpcwodh6qh_src_ticketsystem_Leave", "vc-description": "", "vc-preamble": "// Code taken from the following paper: http://leino.science/papers/krml260.pdf\n\n// Each philosopher's pseudocode:\n\n// repeat forever {\n//     Thinking:\n\n//     t: Ticket = ticket, ticket + 1 // request ticket to enter hungry state\n//     Hungry:\n//     //...\n\n//     wait until serving = t; // Enter\n//     Eating:\n//     //...\n\n//     serving := serving + 1; // Leaving\n// }\n\n// control state values; thinking, hungry, eating\n// introduce state for each process: use map from processes to values\n\ntype Process(==) // {type comes equipped with ability to compare its values with equality}\ndatatype CState = Thinking | Hungry | Eating\n\n// provides mutual exclusion\nclass TicketSystem {\n    var ticket: int\n    var serving: int\n    const P: set<Process>\n\n    var cs: map<Process, CState> // cannot use state variable P as domain for maps => use Process => every conceivable process\n    var t: map<Process, int> // ticket number for each philosopher\n\n    // how to know some process p is in domain of map: introduce function which tells whether condition holds or not\n    predicate Valid() // function which describes system invariant\n        reads this // may depend on values in the class\n    {\n        P <= cs.Keys && P <= t.Keys && serving <= ticket && // ticket may be greater than serving but not the other way around\n        (forall p :: p in P && cs[p] != Thinking ==> serving <= t[p] < ticket) && // any current ticket number is in the range of serving to ticket\n        (forall p,q :: \n            p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking ==> t[p] != t[q] // some other process may have a value equal to 'serving'\n        ) && \n        (forall p :: p in P && cs[p] == Eating ==> t[p] == serving) // if eating, the current ticket number must be the one being served\n    }\n\n    constructor (processes: set<Process>)\n        ensures Valid() // postcondition\n    {\n        P := processes;\n        ticket, serving := 0,  0;\n        cs := map p | p in processes :: Thinking; // set initial state of every process to Thinking\n        t := map p | p in processes :: 0;\n\n    }\n\n    // atomic events to formalize for each process: request, enter, leave\n    // model each atomic event by a method\n\n    // atomicity: read or write just once in body\n    // method AtomicStep(p: Process)\n    //     requires Valid() && p in P && cs[p] == Thinking // Request(p) is only enabled when p is thinking\n    //     modifies this\n    //     ensures Valid()", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Leave(p: Process)\n        requires Valid() && p in P && cs[p] == Eating\n        modifies this\n        ensures Valid()", "vc-code": "{\n        assert t[p] == serving;\n        serving := serving + 1;\n        cs := cs[p := Thinking];\n}", "vc-postamble": "// correctness: no two process are in eating state at same time\n    // prove that invariant implies condition\n    lemma MutualExclusion(p: Process, q: Process)\n        requires Valid() && p in P && q in P // if system is in valid state and both p, q are processes\n        requires cs[p] == Eating && cs[q] == Eating // both p, q are in Eating state\n        ensures p == q // p and q are the same process       \n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0639", "language": "dafny", "source": "dafnybench", "source_id": "dafny-programs_tmp_tmpcwodh6qh_src_ticketsystem_Request", "vc-description": "", "vc-preamble": "// Code taken from the following paper: http://leino.science/papers/krml260.pdf\n\n// Each philosopher's pseudocode:\n\n// repeat forever {\n//     Thinking:\n\n//     t: Ticket = ticket, ticket + 1 // request ticket to enter hungry state\n//     Hungry:\n//     //...\n\n//     wait until serving = t; // Enter\n//     Eating:\n//     //...\n\n//     serving := serving + 1; // Leaving\n// }\n\n// control state values; thinking, hungry, eating\n// introduce state for each process: use map from processes to values\n\ntype Process(==) // {type comes equipped with ability to compare its values with equality}\ndatatype CState = Thinking | Hungry | Eating\n\n// provides mutual exclusion\nclass TicketSystem {\n    var ticket: int\n    var serving: int\n    const P: set<Process>\n\n    var cs: map<Process, CState> // cannot use state variable P as domain for maps => use Process => every conceivable process\n    var t: map<Process, int> // ticket number for each philosopher\n\n    // how to know some process p is in domain of map: introduce function which tells whether condition holds or not\n    predicate Valid() // function which describes system invariant\n        reads this // may depend on values in the class\n    {\n        P <= cs.Keys && P <= t.Keys && serving <= ticket && // ticket may be greater than serving but not the other way around\n        (forall p :: p in P && cs[p] != Thinking ==> serving <= t[p] < ticket) && // any current ticket number is in the range of serving to ticket\n        (forall p,q :: \n            p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking ==> t[p] != t[q] // some other process may have a value equal to 'serving'\n        ) && \n        (forall p :: p in P && cs[p] == Eating ==> t[p] == serving) // if eating, the current ticket number must be the one being served\n    }\n\n    constructor (processes: set<Process>)\n        ensures Valid() // postcondition\n    {\n        P := processes;\n        ticket, serving := 0,  0;\n        cs := map p | p in processes :: Thinking; // set initial state of every process to Thinking\n        t := map p | p in processes :: 0;\n\n    }\n\n    // atomic events to formalize for each process: request, enter, leave\n    // model each atomic event by a method\n\n    // atomicity: read or write just once in body\n    // method AtomicStep(p: Process)\n    //     requires Valid() && p in P && cs[p] == Thinking // Request(p) is only enabled when p is thinking\n    //     modifies this\n    //     ensures Valid()", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Request(p: Process)\n        requires Valid() && p in P && cs[p] == Thinking\n        modifies this\n        ensures Valid()", "vc-code": "{\n        t, ticket := t[p := ticket], ticket + 1; // map update p to ticket, update ticket\n        cs := cs[p := Hungry]; // map update p to Hungry state\n}", "vc-postamble": "// correctness: no two process are in eating state at same time\n    // prove that invariant implies condition\n    lemma MutualExclusion(p: Process, q: Process)\n        requires Valid() && p in P && q in P // if system is in valid state and both p, q are processes\n        requires cs[p] == Eating && cs[q] == Eating // both p, q are in Eating state\n        ensures p == q // p and q are the same process       \n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0640", "language": "dafny", "source": "dafnybench", "source_id": "dafny-rope_tmp_tmpl4v_njmy_Rope_getCharAtIndex", "vc-description": "", "vc-preamble": "module Rope {\nclass Rope {\nghost var Contents: string;\nghost var Repr: set<Rope>;\n\nvar data: string;\nvar weight: nat;\nvar left: Rope?;\nvar right: Rope?;\n\nghost predicate Valid() \n    reads this, Repr\n    ensures Valid() ==> this in Repr\n{\n    this in Repr &&\n    (left != null ==> \n        left in Repr &&\n        left.Repr < Repr && this !in left.Repr &&\n        left.Valid() &&\n        (forall child :: child in left.Repr ==> child.weight <= weight)) &&\n    (right != null ==> \n        right in Repr &&\n        right.Repr < Repr && this !in right.Repr &&\n        right.Valid()) &&\n    (left == null && right == null ==>\n        Repr == {this} &&\n        Contents == data &&\n        weight == |data| &&\n        data != \"\") &&\n    (left != null && right == null ==>\n        Repr == {this} + left.Repr &&\n        Contents == left.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") &&\n    (left == null && right != null ==>\n        Repr == {this} + right.Repr &&\n        Contents == right.Contents &&\n        weight == 0 &&\n        data == \"\") &&\n    (left != null && right != null ==>\n        Repr == {this} + left.Repr + right.Repr &&\n        left.Repr !! right.Repr &&\n        Contents == left.Contents + right.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") \n}\n\nlemma contentSizeGtZero()\n    requires Valid()\n    ensures |Contents| > 0\n    decreases Repr\n{}\n\nfunction getWeightsOfAllRightChildren(): nat\n    reads right, Repr\n    requires Valid()\n    decreases Repr\n    ensures right != null\n        ==> getWeightsOfAllRightChildren() == |right.Contents|\n{\n    if right == null then 0\n    else right.weight + right.getWeightsOfAllRightChildren()\n} \n\nfunction length(): nat\n    reads Repr\n    requires Valid()\n    ensures |Contents| == length()\n{\n    this.weight + getWeightsOfAllRightChildren()\n}\n\n// constructor for creating a terminal node\nconstructor Terminal(x: string)\n    requires x != \"\"\n    ensures Valid() && fresh(Repr)\n        && left == null && right == null\n        && data == x\n{ \n    data := x;\n    weight := |x|;\n    left := null;\n    right := null;\n    Contents := x;\n    Repr := {this};\n}   \n\npredicate isTerminal()\n    reads this, this.left, this.right\n{ left == null && right == null }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method getCharAtIndex(index: nat) returns (c: char)\n    requires Valid() && 0 <= index < |Contents|\n    ensures c == Contents[index]", "vc-code": "{\n    var nTemp := this;\n    var i := index;\n    while (!nTemp.isTerminal()) \n        invariant nTemp != null;\n        invariant nTemp.Valid()\n        invariant 0 <= i < |nTemp.Contents|   \n        invariant nTemp.Contents[i] == Contents[index] \n        decreases nTemp.Repr\n    {\n        if (i < nTemp.weight) {\n            nTemp := nTemp.left;\n        } else {\n            i := i - nTemp.weight;\n            nTemp := nTemp.right;\n        }\n    }\n    // Have reached the terminal node with index i\n    c := nTemp.data[i];\n}", "vc-postamble": "static method concat(n1: Rope?, n2: Rope?) returns (n: Rope?) \n    requires (n1 != null) ==> n1.Valid()\n    requires (n2 != null) ==> n2.Valid()\n    requires (n1 != null && n2 != null) ==> (n1.Repr !! n2.Repr)\n\n    ensures (n1 != null || n2 != null) <==> n != null && n.Valid()\n    ensures (n1 == null && n2 == null) <==> n == null\n    ensures (n1 == null && n2 != null)\n        ==> n == n2 && n != null && n.Valid() && n.Contents == n2.Contents\n    ensures (n1 != null && n2 == null)\n        ==> n == n1 && n != null && n.Valid() && n.Contents == n1.Contents\n    ensures (n1 != null && n2 != null)\n        ==> n != null && n.Valid()\n            && n.left == n1 && n.right == n2\n            && n.Contents == n1.Contents + n2.Contents\n            && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    if (n1 == null) {\n        n := n2;\n    } else if (n2 == null) {\n        n := n1;\n    } else {\n        n := new Rope.Terminal(\"placeholder\");\n        n.left := n1;\n        n.right := n2;\n        n.data := \"\";\n\n        var nTemp := n1;\n        var w := 0;\n        ghost var nodesTraversed : set<Rope> := {};\n\n        while (nTemp.right != null)\n            invariant nTemp != null\n            invariant nTemp.Valid()\n            invariant forall node :: node in nodesTraversed ==> node.weight <= w\n            invariant nodesTraversed == n1.Repr - nTemp.Repr\n            invariant nTemp.right == null ==> w + nTemp.weight == |n1.Contents|\n            invariant nTemp.right != null\n                ==> w + nTemp.weight + |nTemp.right.Contents| == |n1.Contents| \n            decreases nTemp.Repr\n        {\n            w := w + nTemp.weight;\n            assert w >= 0;\n            if (nTemp.left != null) {\n                nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n            } else {\n                nodesTraversed := nodesTraversed + {nTemp};\n            }\n            nTemp := nTemp.right;\n        }\n        w := w + nTemp.weight;\n        if (nTemp.left != null) {\n            nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n        } else {\n            nodesTraversed := nodesTraversed + {nTemp};\n        }\n        n.weight := w;\n        n.Contents := n1.Contents + n2.Contents;\n        n.Repr := {n} + n1.Repr + n2.Repr;\n        } \n} \n\n\n/**\n    Dafny needs help to guess that in our definition, every rope must\n    have non-empty Contents, otherwise it is represented by [null].\n\n    The lemma contentSizeGtZero(n) is thus important to prove the\n    postcondition of this method, in the two places where the lemma is\n    invoked.\n*/\nstatic method split(n: Rope, index: nat) returns (n1: Rope?, n2: Rope?) \n    requires n.Valid() && 0 <= index <= |n.Contents|\n    ensures index == 0\n        ==> n1 == null && n2 != null && n2.Valid()\n            && n2.Contents == n.Contents && fresh(n2.Repr - n.Repr)\n    ensures index == |n.Contents|\n        ==> n2 == null && n1 != null && n1.Valid()\n            && n1.Contents == n.Contents && fresh(n1.Repr - n.Repr)\n    ensures 0 < index < |n.Contents|\n        ==> n1 != null && n1.Valid() && n2 != null && n2.Valid()\n            && n1.Contents == n.Contents[..index]\n            && n2.Contents == n.Contents[index..]\n            && n1.Repr !! n2.Repr\n            && fresh(n1.Repr - n.Repr) && fresh(n2.Repr - n.Repr)\n    decreases n.Repr\n{\n    if (index == 0) {\n        n1 := null;\n        n2 := n;\n        n.contentSizeGtZero();\n        // assert index != |n.Contents|;\n    } else if (index < n.weight) {\n        if (n.left != null) {\n            var s1, s2 := split(n.left, index);\n            n1 := s1;\n            n2 := concat(s2, n.right);\n        } else {\n            // terminal node\n            assert n.isTerminal();\n            if (index == 0) {\n                n1 := null;\n                n2 := n;\n            } else {\n                n1 := new Rope.Terminal(n.data[..index]);\n                n2 := new Rope.Terminal(n.data[index..]);\n            }\n        }\n    } else if (index > n.weight) {\n        var s1, s2 := split(n.right, index - n.weight);\n        n1 := concat(n.left, s1);\n        n2 := s2;\n    } else {\n        // since [n.weight == index != 0], it means that [n] cannot be a\n        // non-terminal node with [left == null].\n        if (n.left != null && n.right == null) {\n            n1 := n.left;\n            n2 := null;\n        } else if (n.left != null && n.right != null) {\n            n.right.contentSizeGtZero();\n            // assert index != |n.Contents|;\n            n1 := n.left;\n            n2 := n.right;\n        } else {\n            assert n.left == null && n.right == null;\n            n1 := n;\n            n2 := null;\n        }\n    }\n}\n\nstatic method insert(n1: Rope, n2: Rope, index: nat) returns (n: Rope)\n    requires n1.Valid() && n2.Valid() && n1.Repr !! n2.Repr\n    requires 0 <= index < |n1.Contents|\n    ensures n.Valid()\n        && n.Contents ==\n            n1.Contents[..index] + n2.Contents + n1.Contents[index..]\n        && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    var n1BeforeIndex, n1AfterIndex := split(n1, index);\n    var firstPart := concat(n1BeforeIndex, n2);\n    n := concat(firstPart, n1AfterIndex);\n}\n\nstatic method delete(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == 0 && j == |n.Contents|) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[..i] + n.Contents[j..] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := concat(l1, r2);\n}\n\nstatic method substring(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == j) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[i..j] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := r1;\n}\n\n}\n// End of Rope Class\n}\n// End of Rope Module", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0641", "language": "dafny", "source": "dafnybench", "source_id": "dafny-rope_tmp_tmpl4v_njmy_Rope_report", "vc-description": "", "vc-preamble": "module Rope {\nclass Rope {\nghost var Contents: string;\nghost var Repr: set<Rope>;\n\nvar data: string;\nvar weight: nat;\nvar left: Rope?;\nvar right: Rope?;\n\nghost predicate Valid() \n    reads this, Repr\n    ensures Valid() ==> this in Repr\n{\n    this in Repr &&\n    (left != null ==> \n        left in Repr &&\n        left.Repr < Repr && this !in left.Repr &&\n        left.Valid() &&\n        (forall child :: child in left.Repr ==> child.weight <= weight)) &&\n    (right != null ==> \n        right in Repr &&\n        right.Repr < Repr && this !in right.Repr &&\n        right.Valid()) &&\n    (left == null && right == null ==>\n        Repr == {this} &&\n        Contents == data &&\n        weight == |data| &&\n        data != \"\") &&\n    (left != null && right == null ==>\n        Repr == {this} + left.Repr &&\n        Contents == left.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") &&\n    (left == null && right != null ==>\n        Repr == {this} + right.Repr &&\n        Contents == right.Contents &&\n        weight == 0 &&\n        data == \"\") &&\n    (left != null && right != null ==>\n        Repr == {this} + left.Repr + right.Repr &&\n        left.Repr !! right.Repr &&\n        Contents == left.Contents + right.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") \n}\n\nlemma contentSizeGtZero()\n    requires Valid()\n    ensures |Contents| > 0\n    decreases Repr\n{}\n\nfunction getWeightsOfAllRightChildren(): nat\n    reads right, Repr\n    requires Valid()\n    decreases Repr\n    ensures right != null\n        ==> getWeightsOfAllRightChildren() == |right.Contents|\n{\n    if right == null then 0\n    else right.weight + right.getWeightsOfAllRightChildren()\n} \n\nfunction length(): nat\n    reads Repr\n    requires Valid()\n    ensures |Contents| == length()\n{\n    this.weight + getWeightsOfAllRightChildren()\n}\n\n// constructor for creating a terminal node\nconstructor Terminal(x: string)\n    requires x != \"\"\n    ensures Valid() && fresh(Repr)\n        && left == null && right == null\n        && data == x\n{ \n    data := x;\n    weight := |x|;\n    left := null;\n    right := null;\n    Contents := x;\n    Repr := {this};\n}   \n\npredicate isTerminal()\n    reads this, this.left, this.right\n{ left == null && right == null }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method report(i: nat, j: nat) returns (s: string)\n    requires 0 <= i <= j <= |this.Contents|\n    requires Valid()\n    ensures s == this.Contents[i..j]\n    decreases Repr", "vc-code": "{\n    if i == j {\n        s := \"\";\n    } else {\n        if this.left == null && this.right == null {\n            s := data[i..j];\n        } else {\n            if (j <= this.weight) {\n                var s' := this.left.report(i, j);\n                s := s';\n            } else if (this.weight <= i) {\n                var s' := this.right.report(i - this.weight, j - this.weight);\n                s := s';\n            } else {\n                // removing this assertion causes error\n                assert i <= this.weight < j;\n                var s1 := this.left.report(i, this.weight);\n                var s2 := this.right.report(0, j - this.weight);\n                s := s1 + s2;\n            }\n        }\n    }\n}", "vc-postamble": "static method concat(n1: Rope?, n2: Rope?) returns (n: Rope?) \n    requires (n1 != null) ==> n1.Valid()\n    requires (n2 != null) ==> n2.Valid()\n    requires (n1 != null && n2 != null) ==> (n1.Repr !! n2.Repr)\n\n    ensures (n1 != null || n2 != null) <==> n != null && n.Valid()\n    ensures (n1 == null && n2 == null) <==> n == null\n    ensures (n1 == null && n2 != null)\n        ==> n == n2 && n != null && n.Valid() && n.Contents == n2.Contents\n    ensures (n1 != null && n2 == null)\n        ==> n == n1 && n != null && n.Valid() && n.Contents == n1.Contents\n    ensures (n1 != null && n2 != null)\n        ==> n != null && n.Valid()\n            && n.left == n1 && n.right == n2\n            && n.Contents == n1.Contents + n2.Contents\n            && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    if (n1 == null) {\n        n := n2;\n    } else if (n2 == null) {\n        n := n1;\n    } else {\n        n := new Rope.Terminal(\"placeholder\");\n        n.left := n1;\n        n.right := n2;\n        n.data := \"\";\n\n        var nTemp := n1;\n        var w := 0;\n        ghost var nodesTraversed : set<Rope> := {};\n\n        while (nTemp.right != null)\n            invariant nTemp != null\n            invariant nTemp.Valid()\n            invariant forall node :: node in nodesTraversed ==> node.weight <= w\n            invariant nodesTraversed == n1.Repr - nTemp.Repr\n            invariant nTemp.right == null ==> w + nTemp.weight == |n1.Contents|\n            invariant nTemp.right != null\n                ==> w + nTemp.weight + |nTemp.right.Contents| == |n1.Contents| \n            decreases nTemp.Repr\n        {\n            w := w + nTemp.weight;\n            assert w >= 0;\n            if (nTemp.left != null) {\n                nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n            } else {\n                nodesTraversed := nodesTraversed + {nTemp};\n            }\n            nTemp := nTemp.right;\n        }\n        w := w + nTemp.weight;\n        if (nTemp.left != null) {\n            nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n        } else {\n            nodesTraversed := nodesTraversed + {nTemp};\n        }\n        n.weight := w;\n        n.Contents := n1.Contents + n2.Contents;\n        n.Repr := {n} + n1.Repr + n2.Repr;\n        } \n} \n\n\n/**\n    Dafny needs help to guess that in our definition, every rope must\n    have non-empty Contents, otherwise it is represented by [null].\n\n    The lemma contentSizeGtZero(n) is thus important to prove the\n    postcondition of this method, in the two places where the lemma is\n    invoked.\n*/\nstatic method split(n: Rope, index: nat) returns (n1: Rope?, n2: Rope?) \n    requires n.Valid() && 0 <= index <= |n.Contents|\n    ensures index == 0\n        ==> n1 == null && n2 != null && n2.Valid()\n            && n2.Contents == n.Contents && fresh(n2.Repr - n.Repr)\n    ensures index == |n.Contents|\n        ==> n2 == null && n1 != null && n1.Valid()\n            && n1.Contents == n.Contents && fresh(n1.Repr - n.Repr)\n    ensures 0 < index < |n.Contents|\n        ==> n1 != null && n1.Valid() && n2 != null && n2.Valid()\n            && n1.Contents == n.Contents[..index]\n            && n2.Contents == n.Contents[index..]\n            && n1.Repr !! n2.Repr\n            && fresh(n1.Repr - n.Repr) && fresh(n2.Repr - n.Repr)\n    decreases n.Repr\n{\n    if (index == 0) {\n        n1 := null;\n        n2 := n;\n        n.contentSizeGtZero();\n        // assert index != |n.Contents|;\n    } else if (index < n.weight) {\n        if (n.left != null) {\n            var s1, s2 := split(n.left, index);\n            n1 := s1;\n            n2 := concat(s2, n.right);\n        } else {\n            // terminal node\n            assert n.isTerminal();\n            if (index == 0) {\n                n1 := null;\n                n2 := n;\n            } else {\n                n1 := new Rope.Terminal(n.data[..index]);\n                n2 := new Rope.Terminal(n.data[index..]);\n            }\n        }\n    } else if (index > n.weight) {\n        var s1, s2 := split(n.right, index - n.weight);\n        n1 := concat(n.left, s1);\n        n2 := s2;\n    } else {\n        // since [n.weight == index != 0], it means that [n] cannot be a\n        // non-terminal node with [left == null].\n        if (n.left != null && n.right == null) {\n            n1 := n.left;\n            n2 := null;\n        } else if (n.left != null && n.right != null) {\n            n.right.contentSizeGtZero();\n            // assert index != |n.Contents|;\n            n1 := n.left;\n            n2 := n.right;\n        } else {\n            assert n.left == null && n.right == null;\n            n1 := n;\n            n2 := null;\n        }\n    }\n}\n\nstatic method insert(n1: Rope, n2: Rope, index: nat) returns (n: Rope)\n    requires n1.Valid() && n2.Valid() && n1.Repr !! n2.Repr\n    requires 0 <= index < |n1.Contents|\n    ensures n.Valid()\n        && n.Contents ==\n            n1.Contents[..index] + n2.Contents + n1.Contents[index..]\n        && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    var n1BeforeIndex, n1AfterIndex := split(n1, index);\n    var firstPart := concat(n1BeforeIndex, n2);\n    n := concat(firstPart, n1AfterIndex);\n}\n\nstatic method delete(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == 0 && j == |n.Contents|) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[..i] + n.Contents[j..] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := concat(l1, r2);\n}\n\nstatic method substring(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == j) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[i..j] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := r1;\n}\n\n}\n// End of Rope Class\n}\n// End of Rope Module", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0642", "language": "dafny", "source": "dafnybench", "source_id": "dafny-rope_tmp_tmpl4v_njmy_Rope_toString", "vc-description": "", "vc-preamble": "module Rope {\nclass Rope {\nghost var Contents: string;\nghost var Repr: set<Rope>;\n\nvar data: string;\nvar weight: nat;\nvar left: Rope?;\nvar right: Rope?;\n\nghost predicate Valid() \n    reads this, Repr\n    ensures Valid() ==> this in Repr\n{\n    this in Repr &&\n    (left != null ==> \n        left in Repr &&\n        left.Repr < Repr && this !in left.Repr &&\n        left.Valid() &&\n        (forall child :: child in left.Repr ==> child.weight <= weight)) &&\n    (right != null ==> \n        right in Repr &&\n        right.Repr < Repr && this !in right.Repr &&\n        right.Valid()) &&\n    (left == null && right == null ==>\n        Repr == {this} &&\n        Contents == data &&\n        weight == |data| &&\n        data != \"\") &&\n    (left != null && right == null ==>\n        Repr == {this} + left.Repr &&\n        Contents == left.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") &&\n    (left == null && right != null ==>\n        Repr == {this} + right.Repr &&\n        Contents == right.Contents &&\n        weight == 0 &&\n        data == \"\") &&\n    (left != null && right != null ==>\n        Repr == {this} + left.Repr + right.Repr &&\n        left.Repr !! right.Repr &&\n        Contents == left.Contents + right.Contents &&\n        weight == |left.Contents| &&\n        data == \"\") \n}\n\nlemma contentSizeGtZero()\n    requires Valid()\n    ensures |Contents| > 0\n    decreases Repr\n{}\n\nfunction getWeightsOfAllRightChildren(): nat\n    reads right, Repr\n    requires Valid()\n    decreases Repr\n    ensures right != null\n        ==> getWeightsOfAllRightChildren() == |right.Contents|\n{\n    if right == null then 0\n    else right.weight + right.getWeightsOfAllRightChildren()\n} \n\nfunction length(): nat\n    reads Repr\n    requires Valid()\n    ensures |Contents| == length()\n{\n    this.weight + getWeightsOfAllRightChildren()\n}\n\n// constructor for creating a terminal node\nconstructor Terminal(x: string)\n    requires x != \"\"\n    ensures Valid() && fresh(Repr)\n        && left == null && right == null\n        && data == x\n{ \n    data := x;\n    weight := |x|;\n    left := null;\n    right := null;\n    Contents := x;\n    Repr := {this};\n}   \n\npredicate isTerminal()\n    reads this, this.left, this.right\n{ left == null && right == null }\n\nmethod report(i: nat, j: nat) returns (s: string)\n    requires 0 <= i <= j <= |this.Contents|\n    requires Valid()\n    ensures s == this.Contents[i..j]\n    decreases Repr\n{\n    if i == j {\n        s := \"\";\n    } else {\n        if this.left == null && this.right == null {\n            s := data[i..j];\n        } else {\n            if (j <= this.weight) {\n                var s' := this.left.report(i, j);\n                s := s';\n            } else if (this.weight <= i) {\n                var s' := this.right.report(i - this.weight, j - this.weight);\n                s := s';\n            } else {\n                // removing this assertion causes error\n                assert i <= this.weight < j;\n                var s1 := this.left.report(i, this.weight);\n                var s2 := this.right.report(0, j - this.weight);\n                s := s1 + s2;\n            }\n        }\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method toString() returns (s: string)\n    requires Valid()\n    ensures s == Contents", "vc-code": "{\n    s := report(0, this.length());\n}", "vc-postamble": "static method concat(n1: Rope?, n2: Rope?) returns (n: Rope?) \n    requires (n1 != null) ==> n1.Valid()\n    requires (n2 != null) ==> n2.Valid()\n    requires (n1 != null && n2 != null) ==> (n1.Repr !! n2.Repr)\n\n    ensures (n1 != null || n2 != null) <==> n != null && n.Valid()\n    ensures (n1 == null && n2 == null) <==> n == null\n    ensures (n1 == null && n2 != null)\n        ==> n == n2 && n != null && n.Valid() && n.Contents == n2.Contents\n    ensures (n1 != null && n2 == null)\n        ==> n == n1 && n != null && n.Valid() && n.Contents == n1.Contents\n    ensures (n1 != null && n2 != null)\n        ==> n != null && n.Valid()\n            && n.left == n1 && n.right == n2\n            && n.Contents == n1.Contents + n2.Contents\n            && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    if (n1 == null) {\n        n := n2;\n    } else if (n2 == null) {\n        n := n1;\n    } else {\n        n := new Rope.Terminal(\"placeholder\");\n        n.left := n1;\n        n.right := n2;\n        n.data := \"\";\n\n        var nTemp := n1;\n        var w := 0;\n        ghost var nodesTraversed : set<Rope> := {};\n\n        while (nTemp.right != null)\n            invariant nTemp != null\n            invariant nTemp.Valid()\n            invariant forall node :: node in nodesTraversed ==> node.weight <= w\n            invariant nodesTraversed == n1.Repr - nTemp.Repr\n            invariant nTemp.right == null ==> w + nTemp.weight == |n1.Contents|\n            invariant nTemp.right != null\n                ==> w + nTemp.weight + |nTemp.right.Contents| == |n1.Contents| \n            decreases nTemp.Repr\n        {\n            w := w + nTemp.weight;\n            assert w >= 0;\n            if (nTemp.left != null) {\n                nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n            } else {\n                nodesTraversed := nodesTraversed + {nTemp};\n            }\n            nTemp := nTemp.right;\n        }\n        w := w + nTemp.weight;\n        if (nTemp.left != null) {\n            nodesTraversed := nodesTraversed + nTemp.left.Repr + {nTemp};\n        } else {\n            nodesTraversed := nodesTraversed + {nTemp};\n        }\n        n.weight := w;\n        n.Contents := n1.Contents + n2.Contents;\n        n.Repr := {n} + n1.Repr + n2.Repr;\n        } \n} \n\n\n/**\n    Dafny needs help to guess that in our definition, every rope must\n    have non-empty Contents, otherwise it is represented by [null].\n\n    The lemma contentSizeGtZero(n) is thus important to prove the\n    postcondition of this method, in the two places where the lemma is\n    invoked.\n*/\nstatic method split(n: Rope, index: nat) returns (n1: Rope?, n2: Rope?) \n    requires n.Valid() && 0 <= index <= |n.Contents|\n    ensures index == 0\n        ==> n1 == null && n2 != null && n2.Valid()\n            && n2.Contents == n.Contents && fresh(n2.Repr - n.Repr)\n    ensures index == |n.Contents|\n        ==> n2 == null && n1 != null && n1.Valid()\n            && n1.Contents == n.Contents && fresh(n1.Repr - n.Repr)\n    ensures 0 < index < |n.Contents|\n        ==> n1 != null && n1.Valid() && n2 != null && n2.Valid()\n            && n1.Contents == n.Contents[..index]\n            && n2.Contents == n.Contents[index..]\n            && n1.Repr !! n2.Repr\n            && fresh(n1.Repr - n.Repr) && fresh(n2.Repr - n.Repr)\n    decreases n.Repr\n{\n    if (index == 0) {\n        n1 := null;\n        n2 := n;\n        n.contentSizeGtZero();\n        // assert index != |n.Contents|;\n    } else if (index < n.weight) {\n        if (n.left != null) {\n            var s1, s2 := split(n.left, index);\n            n1 := s1;\n            n2 := concat(s2, n.right);\n        } else {\n            // terminal node\n            assert n.isTerminal();\n            if (index == 0) {\n                n1 := null;\n                n2 := n;\n            } else {\n                n1 := new Rope.Terminal(n.data[..index]);\n                n2 := new Rope.Terminal(n.data[index..]);\n            }\n        }\n    } else if (index > n.weight) {\n        var s1, s2 := split(n.right, index - n.weight);\n        n1 := concat(n.left, s1);\n        n2 := s2;\n    } else {\n        // since [n.weight == index != 0], it means that [n] cannot be a\n        // non-terminal node with [left == null].\n        if (n.left != null && n.right == null) {\n            n1 := n.left;\n            n2 := null;\n        } else if (n.left != null && n.right != null) {\n            n.right.contentSizeGtZero();\n            // assert index != |n.Contents|;\n            n1 := n.left;\n            n2 := n.right;\n        } else {\n            assert n.left == null && n.right == null;\n            n1 := n;\n            n2 := null;\n        }\n    }\n}\n\nstatic method insert(n1: Rope, n2: Rope, index: nat) returns (n: Rope)\n    requires n1.Valid() && n2.Valid() && n1.Repr !! n2.Repr\n    requires 0 <= index < |n1.Contents|\n    ensures n.Valid()\n        && n.Contents ==\n            n1.Contents[..index] + n2.Contents + n1.Contents[index..]\n        && fresh(n.Repr - n1.Repr - n2.Repr)\n{\n    var n1BeforeIndex, n1AfterIndex := split(n1, index);\n    var firstPart := concat(n1BeforeIndex, n2);\n    n := concat(firstPart, n1AfterIndex);\n}\n\nstatic method delete(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == 0 && j == |n.Contents|) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[..i] + n.Contents[j..] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := concat(l1, r2);\n}\n\nstatic method substring(n: Rope, i: nat, j: nat) returns (m: Rope?)\n    requires n.Valid()\n    requires 0 <= i < j <= |n.Contents|\n    ensures (i == j) <==> m == null\n    ensures m != null ==>\n        m.Valid() &&\n        m.Contents == n.Contents[i..j] &&\n        fresh(m.Repr - n.Repr)\n{\n    var l1, l2 := split(n, i);\n    var r1, r2 := split(l2, j - i);\n    m := r1;\n}\n\n}\n// End of Rope Class\n}\n// End of Rope Module", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0645", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_8_SquareElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]", "vc-code": "{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\n        invariant 0 <= i <= a.Length\n        invariant squared.Length == a.Length\n        invariant forall k :: 0 <= k < i ==> squared[k] == a[k] * a[k]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0647", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_17_SquarePerimeter", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SquarePerimeter(side: int) returns (perimeter: int)\n    requires side > 0\n    ensures perimeter == 4 * side", "vc-code": "{\n    perimeter := 4 * side;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0649", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_58_HasOppositeSign", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method HasOppositeSign(a: int, b: int) returns (result: bool)\n  ensures result <==> (a < 0 && b > 0) || (a > 0 && b < 0)", "vc-code": "{\n  result := (a < 0 && b > 0) || (a > 0 && b < 0);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0650", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_59_NthOctagonalNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method NthOctagonalNumber(n: int) returns (octagonalNumber: int)\n    requires n >= 0\n    ensures octagonalNumber == n * (3 * n - 2)", "vc-code": "{\n    octagonalNumber := n * (3 * n - 2);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0651", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_61_CountSubstringsWithSumOfDigitsEqualToLength", "vc-description": "", "vc-preamble": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CountSubstringsWithSumOfDigitsEqualToLength(s: string) returns (count: int)\n    ensures count >= 0", "vc-code": "{\n    count := 0;\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n    {\n        var sum := 0;\n        for j := i to |s|\n            invariant i <= j <= |s|\n            invariant sum >= 0\n            invariant sum <= j - i\n        {\n            if j == |s| || !IsDigit(s[j]) {\n                if sum == j - i {\n                    count := count + 1;\n                }\n                break;\n            }\n            sum := sum + (s[j] as int - 48);\n            if sum > j - i + 1 {\n                break;\n            }\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0652", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_62_FindSmallest", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FindSmallest(s: array<int>) returns (min: int)\n  requires s.Length > 0\n  ensures forall i :: 0 <= i < s.Length ==> min <= s[i]\n  ensures exists i :: 0 <= i < s.Length && min == s[i]", "vc-code": "{\n  min := s[0];\n  for i := 1 to s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall k :: 0 <= k < i ==> min <= s[k]\n    invariant exists k :: 0 <= k < i && min == s[k]\n  {\n    if s[i] < min\n    {\n      min := s[i];\n    }\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0655", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_77_IsDivisibleBy11", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IsDivisibleBy11(n: int) returns (result: bool)\n  ensures result <==> n % 11 == 0", "vc-code": "{\n  result := n % 11 == 0;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0656", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_79_IsLengthOdd", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IsLengthOdd(s: string) returns (result: bool)\n    ensures result <==> |s| % 2 == 1", "vc-code": "{\n    result := |s| % 2 == 1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0657", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_80_TetrahedralNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method TetrahedralNumber(n: int) returns (t: int)\n    requires n >= 0\n    ensures t == n * (n + 1) * (n + 2) / 6", "vc-code": "{\n    t := n * (n + 1) * (n + 2) / 6;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0658", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_82_SphereVolume", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SphereVolume(radius: real) returns (volume: real)\n    requires radius > 0.0\n    ensures volume == 4.0/3.0 * 3.1415926535 * radius * radius * radius", "vc-code": "{\n    volume := 4.0/3.0 * 3.1415926535 * radius * radius * radius;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0659", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_85_SphereSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SphereSurfaceArea(radius: real) returns (area: real)\n    requires radius > 0.0\n    ensures area == 4.0 * 3.14159265358979323846 * radius * radius", "vc-code": "{\n    area := 4.0 * 3.14159265358979323846 * radius * radius;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0660", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_86_CenteredHexagonalNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CenteredHexagonalNumber(n: nat) returns (result: nat)\n    requires n >= 0\n    ensures result == 3 * n * (n - 1) + 1", "vc-code": "{\n    result := 3 * n * (n - 1) + 1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0661", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_89_ClosestSmaller", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ClosestSmaller(n: int) returns (m: int)\n    requires n > 0\n    ensures m + 1 == n", "vc-code": "{\n    m := n - 1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0664", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_101_KthElement", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method KthElement(arr: array<int>, k: int) returns (result: int)\n  requires 1 <= k <= arr.Length\n  ensures result == arr[k - 1]", "vc-code": "{\n  result := arr[k - 1];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0671", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_135_NthHexagonalNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method NthHexagonalNumber(n: int) returns (hexNum: int)\n    requires n >= 0\n    ensures hexNum == n * ((2 * n) - 1)", "vc-code": "{\n    hexNum := n * ((2 * n) - 1);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0672", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_139_CircleCircumference", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CircleCircumference(radius: real) returns (circumference: real)\n    requires radius > 0.0\n    ensures circumference == 2.0 * 3.14159265358979323846 * radius", "vc-code": "{\n    circumference := 2.0 * 3.14159265358979323846 * radius;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0688", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_257_Swap", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Swap(a: int, b: int) returns (result: seq<int>)\n    ensures |result| == 2\n    ensures result[0] == b\n    ensures result[1] == a", "vc-code": "{\n    result := [b, a];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0691", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_264_DogYears", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DogYears(humanYears: int) returns (dogYears: int)\n    requires humanYears >= 0\n    ensures dogYears == 7 * humanYears", "vc-code": "{\n    dogYears := 7 * humanYears;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0692", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_266_LateralSurfaceArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method LateralSurfaceArea(size: int) returns (area: int)\n    requires size > 0\n    ensures area == 4 * size * size", "vc-code": "{\n    area := 4 * size * size;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0693", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_267_SumOfSquaresOfFirstNOddNumbers", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method SumOfSquaresOfFirstNOddNumbers(n: int) returns (sum: int)\n    requires n >= 0\n    ensures sum == (n * (2 * n - 1) * (2 * n + 1)) / 3", "vc-code": "{\n    sum := 0;\n    var i := 1;\n    for k:=0 to n\n        invariant 0 <= k <= n\n        invariant sum == k * (2 * k - 1) * (2 * k + 1) / 3\n        invariant i == 2 * k + 1\n    {\n        sum := sum + i * i;\n        i := i + 2;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0694", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_268_StarNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method StarNumber(n: int) returns (star: int)\n    requires n >= 0\n    ensures star == 6 * n * (n - 1) + 1", "vc-code": "{\n    star := 6 * n * (n - 1) + 1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0695", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_269_AsciiValue", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method AsciiValue(c: char) returns (ascii: int)\n    ensures ascii == c as int", "vc-code": "{\n    ascii := c as int;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0697", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_276_CylinderVolume", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CylinderVolume(radius: real, height: real) returns (volume: real)\n    requires radius > 0.0\n    requires height > 0.0\n    ensures volume == 3.14159265359 * radius * radius * height", "vc-code": "{\n    volume := 3.14159265359 * radius * radius * height;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0698", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_279_NthDecagonalNumber", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method NthDecagonalNumber(n: int) returns (decagonal: int)\n    requires n >= 0\n    ensures decagonal == 4 * n * n - 3 * n", "vc-code": "{\n    decagonal := 4 * n * n - 3 * n;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0699", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_282_ElementWiseSubtraction", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]", "vc-code": "{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n        invariant 0 <= i <= a.Length\n        invariant result.Length == a.Length\n        invariant forall k :: 0 <= k < i ==> result[k] == a[k] - b[k]\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0702", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_292_Quotient", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Quotient(a: int, b: int) returns (result: int)\n    requires b != 0\n    ensures result == a / b", "vc-code": "{\n    result := a / b;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0704", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_307_DeepCopySeq", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DeepCopySeq(s: seq<int>) returns (copy: seq<int>)\n    ensures |copy| == |s|\n    ensures forall i :: 0 <= i < |s| ==> copy[i] == s[i]", "vc-code": "{\n    var newSeq: seq<int> := [];\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant |newSeq| == i\n        invariant forall k :: 0 <= k < i ==> newSeq[k] == s[k]\n    {\n        newSeq := newSeq + [s[i]];\n    }\n    return newSeq;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0705", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_309_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b: int) returns (maxValue: int)\n    ensures maxValue == a || maxValue == b\n    ensures maxValue >= a && maxValue >= b", "vc-code": "{\n    if a >= b {\n        maxValue := a;\n    } else {\n        maxValue := b;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0706", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_310_ToCharArray", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ToCharArray(s: string) returns (a: array<char>)\n    ensures a.Length == |s|\n    ensures forall i :: 0 <= i < |s| ==> a[i] == s[i]", "vc-code": "{\n    a := new char[|s|];\n    for i := 0 to |s|\n    invariant 0 <= i <= |s|\n    invariant a.Length == |s|\n    invariant forall k :: 0 <= k < i ==> a[k] == s[k]\n    {\n        a[i] := s[i];\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0707", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_312_ConeVolume", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ConeVolume(radius: real, height: real) returns (volume: real)\n    requires radius > 0.0 && height > 0.0\n    ensures volume == (1.0/3.0) * (3.14159265358979323846) * radius * radius * height", "vc-code": "{\n    volume := (1.0/3.0) * (3.14159265358979323846) * radius * radius * height;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0708", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_396_StartAndEndWithSameChar", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method StartAndEndWithSameChar(s: string) returns (result: bool)\n    requires |s| > 0\n    ensures result <==> s[0] == s[|s| - 1]", "vc-code": "{\n    result := s[0] == s[|s| - 1];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0709", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_397_MedianOfThree", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MedianOfThree(a: int, b: int, c: int) returns (median: int)\n    ensures median == a || median == b || median == c\n    ensures (median >= a && median <= b) || (median >= b && median <= a) || (median >= a && median <= c) || (median >= c && median <= a) || (median >= b && median <= c) || (median >= c && median <= b)", "vc-code": "{\n    if ((a <= b && b <= c) || (c <= b && b <= a)) {\n        median := b;\n    } else if ((b <= a && a <= c) || (c <= a && a <= b)) {\n        median := a;\n    } else {\n        median := c;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0712", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_404_Min", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Min(a: int, b: int) returns (minValue: int)\n    ensures minValue == a || minValue == b\n    ensures minValue <= a && minValue <= b", "vc-code": "{\n    if a <= b {\n        minValue := a;\n    } else {\n        minValue := b;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0713", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_406_IsOdd", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method IsOdd(n: int) returns (result: bool)\n    ensures result <==> n % 2 == 1", "vc-code": "{\n    result := n % 2 == 1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0725", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_445_MultiplyElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]", "vc-code": "{\n    result := [];\n    var i := 0;\n    while i < |a|\n        invariant 0 <= i <= |a|\n        invariant |result| == i\n        invariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0726", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_447_CubeElements", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CubeElements(a: array<int>) returns (cubed: array<int>)\n    ensures cubed.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> cubed[i] == a[i] * a[i] * a[i]", "vc-code": "{\n    var cubedArray := new int[a.Length];\n    for i := 0 to a.Length\n        invariant 0 <= i <= a.Length\n        invariant cubedArray.Length == a.Length\n        invariant forall k :: 0 <= k < i ==> cubedArray[k] == a[k] * a[k] * a[k]\n    {\n        cubedArray[i] := a[i] * a[i] * a[i];\n    }\n    return cubedArray;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0728", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_454_ContainsZ", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ContainsZ(s: string) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |s| && (s[i] == 'z' || s[i] == 'Z'))", "vc-code": "{\n    result := false;\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant result <==> (exists k :: 0 <= k < i && (s[k] == 'z' || s[k] == 'Z'))\n    {\n        if s[i] == 'z' || s[i] == 'Z' {\n            result := true;\n            break;\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0731", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_458_RectangleArea", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method RectangleArea(length: int, width: int) returns (area: int)\n    requires length > 0\n    requires width > 0\n    ensures area == length * width", "vc-code": "{\n    area := length * width;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0792", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_764_CountDigits", "vc-description": "", "vc-preamble": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method CountDigits(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count == | set i: int | 0 <= i < |s| && IsDigit(s[i])|", "vc-code": "{\n    var digits := set i: int | 0 <= i < |s| && IsDigit(s[i]);\n    count := |digits|;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0808", "language": "dafny", "source": "dafnybench", "source_id": "dafny-synthesis_task_id_808_ContainsK", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ContainsK(s: seq<int>, k: int) returns (result: bool)\n    ensures result <==> k in s", "vc-code": "{\n    result := false;\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant result <==> (exists j :: 0 <= j < i && s[j] == k)\n    {\n        if s[i] == k {\n            result := true;\n            break;\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0810", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_abs", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method abs(x: int) returns (y: int)\n    ensures true", "vc-code": "{\n    if x < 0 {\n        y := -x;\n    } else {\n        y :=  x;\n    }\n}", "vc-postamble": "/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0811", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_ex1", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n\n/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ex1(n: int)\n    requires true\n    ensures true", "vc-code": "{\n    var i := 0;\n    while i < n\n        invariant true\n        // decreases *    //  do not check termination\n    {\n        i := i + 1;\n    }\n    /** This is the property to prove: */\n    // assert i == n;\n}", "vc-postamble": "/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0812", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_find", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n\n/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method find(a: seq<int>, key: int) returns (index: int)\n    requires true\n    ensures true", "vc-code": "{\n    index := 0;\n    while index < |a|\n        invariant true \n        {\n            // index := index + 1;\n            if  a[index] == key  { \n                return 0;\n            }\n            index := index + 2;\n        }\n    index := -10;\n}", "vc-postamble": "//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0813", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_foo", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\nmethod abs(x: int) returns (y: int)\n    ensures true\n{\n    if x < 0 {\n        y := -x;\n    } else {\n        y :=  x;\n    }\n}\n\n/** Call abs */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method foo(x: int) \n    requires x >= 0", "vc-code": "{\n    var y := abs(x);\n    // assert( y == x);\n}", "vc-postamble": "/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0814", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_foo2", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n\n/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method foo2() \n    ensures false\n    decreases *", "vc-code": "{\n    while true \n        decreases *\n    {\n\n    }\n    assert false;\n}", "vc-postamble": "//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0815", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_max", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n\n/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(x: int, y: int) returns (m: int)\nrequires true;\nensures true;", "vc-code": "{\n    var r : int;\n    if x > y  {\n        r := 0;\n    } else {\n        r := 1;\n    }\n    m := r;\n    //  can use return r instead\n    // return m;\n}", "vc-postamble": "/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */\n\n/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0816", "language": "dafny", "source": "dafnybench", "source_id": "dafny-training_tmp_tmp_n2kixni_session1_training1_unique", "vc-description": "", "vc-preamble": "/*\n * Copyright 2021 ConsenSys Software Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may \n * not use this file except in compliance with the License. You may obtain \n * a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software dis-\n * tributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT \n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the \n * License for the specific language governing permissions and limitations \n * under the License.\n */\n\n/**\n *  Example 0.a.\n *  Add pre-cond to specify x >= 0 and a post cond of your choice.\n *  Counter-example generation.\n */\n\n/** Call abs */\n\n/**\n *  Example 0.b.\n *  The goal is to compute the maximum of x and y and return it in m.\n *  The current version is buggy and returns 0 is x > y and 1 if x <= 1.\n * \n *  Try to:\n *  1. write the post-condition that shows that max(x,y) (i.e. m) is larger than x and y.\n *  2. write a set of post-conditions that fully characterises max.\n *  3. fix the code and make sure it verifies.\n */\n\n/**\n *  Example 1.\n *  \n *  Try to prove \n *  1. the final assert statement (uncomment it and you may need to strengthen pre condition).\n *  2. termination, propose a decrease clause (to replace *)\n */\n\n/**\n *  Infinite loop.\n */\n\n//  Specify a post-condition and prove it.\n\n/**\n *  Example 2.\n *\n *  Find a key in an array.\n *\n *  @param      a   The array.\n *  @param      key The key to find.\n *  @returns        An index i such a[i] == key if key in a and -1 otherwise.\n *\n *  Try to:\n *  0.  uncomment line index := index + 2 and check problems\n *  1.  write the property defined by the @returns above\n *  2.  prove this property (you may add loop invariants)\n *\n *  @note       The code below is flawed on purpose.\n *              |a| is the length of a\n *              to test whether an integer `k` is in `a`: k in a (true\n *              iff exists 0 <= i < |a|, a[i] == k). \n *              And: !(k in a) <==> k !in a\n *              a[i..j] is the sub sequence a[i], ..., a[j - 1] \n *              a[..j] is a[0..j] and a[i..] is a[i..|a|]\n *              a[..] is same as a\n */\n\n//  Prove more complicated invariants with quantifiers.\n\n/**\n *  Palindrome checker.\n *  Example 3.\n *\n *  Check whether a sequence of letters is a palindrome.\n *\n *  Try to:\n *  1. write the algorithm to determine whether a string is a palindrome\n *  2. write the ensures clauses that specify the palidrome properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0..|a|] is same as a.  \n */\n\n/**\n *  Whether a sequence of ints is sorted (ascending).\n *  \n *  @param  a   A sequence on integers.\n *  @returns    Whether the sequence is sorted.\n */\npredicate sorted(a: seq<int>) \n{\n    forall j, k::0 <= j < k < |a|  ==> a[j] <= a[k]\n}\n\n/**\n *  Example 4.\n *\n *  Remove duplicates from a sorted sequence.\n *\n *  Try to:\n *  1. write the code to compute b\n *  2. write the ensures clauses that specify the remove duplicates properties\n *  3. verify algorithm. \n *\n *  Notes: a[k] accesses element k of a for 0 <= k < |a|\n *  a[i..j] is (a seq) with the first j elements minus the first i\n *  a[0.. |a| - 1] is same as a.  \n */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method unique(a: seq<int>) returns (b: seq<int>) \n    requires sorted(a)\n    ensures true", "vc-code": "{\n  return a;\n}", "vc-postamble": "/**\n *  Dafny compiles the Main method if it finds one in a file.\n */", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0817", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex01_Max", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Max(a: int, b: int) returns (c: int)\n    ensures c >= a && c >= b && (c == a || c == b)", "vc-code": "{\n    if (a >= b)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0818", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex02_Abs", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x: int) returns (y: int)\n    requires x < 0\n    ensures 0 < y\n    ensures y == -x", "vc-code": "{\n    return -x;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0819", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex03_Abs", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs(x: int) returns (y: int)\n    requires x == -1\n    ensures 0 <= y\n    ensures 0 <= x ==> y == x\n    ensures x < 0 ==> y == -x", "vc-code": "{\n    return x + 2;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0820", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex03_Abs2", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Abs2(x: real) returns (y: real)\n    requires x == -0.5\n    ensures 0.0 <= y\n    ensures 0.0 <= x ==> y == x\n    ensures x < 0.0 ==> y == -x", "vc-code": "{\n    return x + 1.0;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0821", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex09_ComputeFib", "vc-description": "", "vc-preamble": "function fib(n: nat): nat\n{\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n        fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFib(n: nat) returns (b: nat)\n    ensures b == fib(n)", "vc-code": "{\n    var i: int := 1;\n    if 0 <= n < 2 { return n; }\n    b := 1;\n    var c := 1;\n\n    while i < n\n        decreases n - i\n        invariant 0 < i <= n\n        invariant b == fib(i)\n        invariant c == fib(i+1)\n    {\n        b, c := c, b + c;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0822", "language": "dafny", "source": "dafnybench", "source_id": "dafny-workout_tmp_tmp0abkw6f8_starter_ex12_FindMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FindMax(a: array<int>) returns (max_idx: nat)\n    requires a.Length > 0\n    ensures 0 <= max_idx < a.Length\n    ensures forall j :: 0 <= j < a.Length ==> a[max_idx] >= a[j]", "vc-code": "{\n    max_idx := 0;\n    var i: nat := 1;\n    while i < a.Length\n        decreases a.Length - i\n        invariant 1 <= i <= a.Length\n        invariant 0 <= max_idx < i\n        invariant forall j :: 0 <= j < i ==> a[max_idx] >= a[j]\n    {\n        if a[i] > a[max_idx]\n        {\n            max_idx := i;\n        }\n        i := i + 1;\n    }\n    return max_idx;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0827", "language": "dafny", "source": "dafnybench", "source_id": "dafny_examples_tmp_tmp8qotd4ez_test_shuffle_getAllShuffledDataEntries", "vc-description": "", "vc-preamble": "method random(a: int, b: int) returns (r: int)\n//  requires a <= b\n  ensures a <= b ==> a <= r <= b\n\nmethod swap<T>(a: array<T>, i: int, j: int)\n  // requires a != null\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method getAllShuffledDataEntries<T(0)>(m_dataEntries: array<T>) returns (result: array<T>)\n  // requires m_dataEntries != null\n  // ensures result != null\n  ensures result.Length == m_dataEntries.Length\n  ensures multiset(result[..]) == multiset(m_dataEntries[..])", "vc-code": "{\n  result := new T[m_dataEntries.Length];\n  forall i | 0 <= i < m_dataEntries.Length {\n    result[i] := m_dataEntries[i];\n  }\n\n  assert result[..] == m_dataEntries[..];\n\n  var k := result.Length - 1;\n  while (k >= 0)\n    invariant multiset(result[..]) == multiset(m_dataEntries[..])\n  {\n    var i := random(0, k);\n    assert i >= 0 && i <= k;\n\n    if (i != k) {\n      swap(result, i, k);\n    }\n\n    k := k - 1;\n  }\n}", "vc-postamble": "lemma eqMultiset_t<T>(t: T, s1: seq<T>, s2: seq<T>)\n  requires multiset(s1) == multiset(s2)\n  ensures t in s1 <==> t in s2\n{\n  calc <==> {\n    t in s1;\n    t in multiset(s1);\n    // Not necessary:\n//    t in multiset(s2);\n//    t in s2;\n  }\n/*  \n  if (t in s1) {\n    assert t in multiset(s1);\n  }\n  else {\n    assert t !in multiset(s1);\n  }\n*/\n}\n\nlemma eqMultiset<T>(s1: seq<T>, s2: seq<T>)\n  requires multiset(s1) == multiset(s2)\n  ensures forall t :: t in s1 <==> t in s2\n{\n  forall t {\n    eqMultiset_t(t, s1, s2);\n  }\n}\n\nfunction set_of_seq<T>(s: seq<T>): set<T>\n{\n  set x: T | x in s :: x\n}\n\nlemma in_set_of_seq<T>(x: T, s: seq<T>)\n  ensures x in s <==> x in set_of_seq(s)\n\nlemma subset_set_of_seq<T>(s1: seq<T>, s2: seq<T>)\n  requires set_of_seq(s1) <= set_of_seq(s2)\n  ensures forall x :: x in s1 ==> x in s2", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0832", "language": "dafny", "source": "dafnybench", "source_id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_BinarySearch", "vc-description": "", "vc-preamble": "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n\npredicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method BinarySearch(a: array<int>, value: int) returns (index: int)\n  requires 0 <= a.Length && sorted(a)\n  ensures 0 <= index ==> index < a.Length && a[index] == value\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value", "vc-code": "{\n  var low := 0;\n  var high := a.Length - 1;\n  while low < high\n    invariant 0 <= low && high < a.Length\n    invariant forall k :: 0 <= k < a.Length && (k < low || k > high) ==> a[k] != value\n  {\n    var mid : int := (low + high) / 2;\n    assert 0 <= low <= mid < high < a.Length;\n    if a[mid] < value {\n      low := mid + 1;\n    } else if a[mid] > value {\n      high := mid - 1;\n    } else {\n      assert a[mid] == value;\n      return mid;\n    }\n  }\n  if low < a.Length && a[low] == value {\n    return low;\n  } else {\n    return -1;\n  }\n}", "vc-postamble": "// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\nlemma SkippingLemma(a: array<int>, j: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n  requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n  requires 0 <= j < a.Length\n  ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n  var i := j;\n  while i < j + a[j] && i < a.Length\n    invariant i < a.Length ==> a[i] >= a[j] - (i-j)\n    invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n  {\n    i := i + 1;\n  }\n}\n\n\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures count(a + b) == count(a) + count(b)\n{\n  if a == [] {\n    assert a+b == b;\n  } else {\n    // Unnecessary! DistributiveLemma(a[1..], b);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n  requires closed(subgraph) && closed(graph) && subgraph <= graph\n  requires root in subgraph && goal in graph - subgraph\n  ensures !pathSpecific(p, root, goal, graph)\n{\n  if |p| >= 2 && p[0] == root && p[1] in p[0].next {\n    DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n  }\n}\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n  requires closed(subgraph) && closed(graph) && subgraph <= graph\n  requires root in subgraph && goal in graph - subgraph\n  ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n  forall p { DisproofLemma(p, subgraph, root, goal, graph); }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0833", "language": "dafny", "source": "dafnybench", "source_id": "dafny_projects_tmp_tmpjutqwjv4_tutorial_tutorial_ComputeFib", "vc-description": "", "vc-preamble": "// Working through https://dafny.org/dafny/OnlineTutorial/guide\n\nfunction fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFib(n: nat) returns (ret: nat)\n  ensures ret == fib(n)", "vc-code": "{\n  var a := 0;\n  var b := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant a == fib(i)\n    invariant b == fib(i+1)\n  {\n    a, b := b, a+b;\n    i := i + 1;\n  }\n  assert i == n;\n\n  return a;\n}", "vc-postamble": "predicate sorted(a: array<int>)\n  reads a\n{\n  forall n, m :: 0 <= n < m < a.Length ==> a[n] <= a[m]\n}\n\n\n\n// https://dafny.org/dafny/OnlineTutorial/ValueTypes\n\nfunction update(s: seq<int>, i: int, v: int): seq<int>\n  requires 0 <= i < |s|\n  ensures update(s, i, v) == s[i := v]\n{\n  s[..i] + [v] + s[i+1..]\n}\n\n\n// https://dafny.org/dafny/OnlineTutorial/Lemmas\n\nlemma SkippingLemma(a: array<int>, j: int)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n  requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n  requires 0 <= j < a.Length\n  ensures forall i :: j <= i < j + a[j] && i < a.Length ==> a[i] != 0\n{\n  var i := j;\n  while i < j + a[j] && i < a.Length\n    invariant i < a.Length ==> a[i] >= a[j] - (i-j)\n    invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n  {\n    i := i + 1;\n  }\n}\n\n\n\nfunction count(a: seq<bool>): nat\n{\n  if |a| == 0 then 0 else\n  (if a[0] then 1 else 0) + count(a[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures count(a + b) == count(a) + count(b)\n{\n  if a == [] {\n    assert a+b == b;\n  } else {\n    // Unnecessary! DistributiveLemma(a[1..], b);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}\n\n\nclass Node\n{\n  var next: seq<Node>\n}\npredicate closed(graph: set<Node>)\n  reads graph\n{\n  forall i :: i in graph ==> forall k :: 0 <= k < |i.next| ==> i.next[k] in graph && i.next[k] != i\n}\npredicate path(p: seq<Node>, graph: set<Node>)\n  requires closed(graph) && 0 < |p|\n  reads graph\n{\n  p[0] in graph &&\n    (|p| > 1 ==> p[1] in p[0].next && // the first link is valid, if it exists\n     path(p[1..], graph)) // and the rest of the sequence is a valid\n}\npredicate pathSpecific(p: seq<Node>, start: Node, end: Node, graph: set<Node>)\n  requires closed(graph)\n  reads graph\n{\n  0 < |p| && // path is nonempty\n  start == p[0] && end == p[|p|-1] && // it starts and ends correctly\n  path(p, graph) // and it is a valid path\n}\n\nlemma DisproofLemma(p: seq<Node>, subgraph: set<Node>,\n                    root: Node, goal: Node, graph: set<Node>)\n  requires closed(subgraph) && closed(graph) && subgraph <= graph\n  requires root in subgraph && goal in graph - subgraph\n  ensures !pathSpecific(p, root, goal, graph)\n{\n  if |p| >= 2 && p[0] == root && p[1] in p[0].next {\n    DisproofLemma(p[1..], subgraph, p[1], goal, graph);\n  }\n}\n\nlemma ClosedLemma(subgraph: set<Node>, root: Node, goal: Node, graph: set<Node>)\n  requires closed(subgraph) && closed(graph) && subgraph <= graph\n  requires root in subgraph && goal in graph - subgraph\n  ensures !(exists p: seq<Node> :: pathSpecific(p, root, goal, graph))\n{\n  forall p { DisproofLemma(p, subgraph, root, goal, graph); }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0837", "language": "dafny", "source": "dafnybench", "source_id": "dafny_tmp_tmp59p638nn_examples_GenericSelectionSort_Ltm", "vc-description": "", "vc-preamble": "trait Comparable<T(==)> {\n    function Lt(x: T, y: T): bool\n}\n\n  trait Sorted<T(==)> extends Comparable<T> {\n\n    ghost predicate Ordered(a: array<T>, left: nat, right: nat)\n      reads a\n      requires left <= right <= a.Length\n    {\n      forall i: nat :: 0 < left <= i < right ==> Lt(a[i-1],a[i]) || a[i-1] == a[i]\n    }\n\n    twostate predicate Preserved(a: array<T>, left: nat, right: nat)\n      reads a\n      requires left <= right <= a.Length\n    {\n      multiset(a[left..right]) == multiset(old(a[left..right]))\n    }\n\n    twostate predicate Sorted(a: array<T>)\n      reads a\n    {\n      Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n    }\n\n  }\n\n//   trait SelectionSort<T(==)> extends Comparable<T>, Sorted<T> {\n\n//     method SelectionSort(a: array<T>)\n//       modifies a\n//       ensures Sorted(a)\n//     {\n//       for i := 0 to a.Length\n//         invariant Ordered(a,0,i)\n//         invariant Preserved(a,0,a.Length)\n//       {\n//         var minValue := a[i];\n//         var minPos := i;\n//         for j := i + 1 to a.Length\n//           invariant minPos < a.Length\n//           invariant a[minPos] == minValue\n//         {\n//           if Lt(a[j], minValue) {\n//             minValue := a[j];\n//             minPos := j;\n//           }\n//         }\n//         if i != minPos {\n//           a[i], a[minPos] := minValue, a[i];\n//         }\n//       }\n//     }\n\n//   }\n\n\nghost function Sum(x: int): nat\n{\n    if x <= 0 then 0 else x + Sum(x-1)\n}\n\ntrait Measurable<T(==)> extends Comparable<T> {\n\n    ghost var comparisonCount: nat", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Ltm(x: T, y: T) returns (b: bool)\n      modifies this`comparisonCount\n      ensures b ==> Lt(x,y)\n      ensures comparisonCount == old(comparisonCount) + 1", "vc-code": "{\n      comparisonCount := comparisonCount + 1;\n      b := Lt(x,y);\n}", "vc-postamble": "}\n\n  trait SelectionSort<T(==)> extends Comparable<T>, Measurable<T>, Sorted<T> {\n\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0838", "language": "dafny", "source": "dafnybench", "source_id": "dafny_tmp_tmp59p638nn_examples_GenericSelectionSort_SelectionSort", "vc-description": "", "vc-preamble": "trait Comparable<T(==)> {\n    function Lt(x: T, y: T): bool\n}\n\n  trait Sorted<T(==)> extends Comparable<T> {\n\n    ghost predicate Ordered(a: array<T>, left: nat, right: nat)\n      reads a\n      requires left <= right <= a.Length\n    {\n      forall i: nat :: 0 < left <= i < right ==> Lt(a[i-1],a[i]) || a[i-1] == a[i]\n    }\n\n    twostate predicate Preserved(a: array<T>, left: nat, right: nat)\n      reads a\n      requires left <= right <= a.Length\n    {\n      multiset(a[left..right]) == multiset(old(a[left..right]))\n    }\n\n    twostate predicate Sorted(a: array<T>)\n      reads a\n    {\n      Ordered(a,0,a.Length) && Preserved(a,0,a.Length)\n    }\n\n  }\n\n//   trait SelectionSort<T(==)> extends Comparable<T>, Sorted<T> {", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "//     method SelectionSort(a: array<T>)\n//       modifies a\n//       ensures Sorted(a)\n//     {\n//       for i := 0 to a.Length\n//         invariant Ordered(a,0,i)\n//         invariant Preserved(a,0,a.Length)\n//       {\n//         var minValue := a[i];\n//         var minPos := i;\n//         for j := i + 1 to a.Length\n//           invariant minPos < a.Length\n//           invariant a[minPos] == minValue\n//         {\n//           if Lt(a[j], minValue) {\n//             minValue := a[j];\n//             minPos := j;\n//           }\n//         }\n//         if i != minPos {\n//           a[i], a[minPos] := minValue, a[i];\n//         }\n//       }\n//     }\n\n//   }\n\n\n\nghost function Sum(x: int): nat", "vc-code": "{\n    if x <= 0 then 0 else x + Sum(x-1)\n}", "vc-postamble": "trait Measurable<T(==)> extends Comparable<T> {\n\n    ghost var comparisonCount: nat\n\n    method Ltm(x: T, y: T) returns (b: bool)\n      modifies this`comparisonCount\n      ensures b ==> Lt(x,y)\n      ensures comparisonCount == old(comparisonCount) + 1\n    {\n      comparisonCount := comparisonCount + 1;\n      b := Lt(x,y);\n    }\n\n}\n\n  trait SelectionSort<T(==)> extends Comparable<T>, Measurable<T>, Sorted<T> {\n\n    method SelectionSort(a: array<T>)\n      modifies a, this\n      requires comparisonCount == 0\n      ensures Sorted(a)\n      ensures comparisonCount <= a.Length * a.Length\n    {\n\n      for i := 0 to a.Length\n        invariant Ordered(a,0,i)\n        invariant Preserved(a,0,a.Length)\n        invariant comparisonCount == i * a.Length - Sum(i)\n      {\n        var minValue := a[i];\n        var minPos := i;\n        assert comparisonCount == i * a.Length - Sum(i) + (i + 1 - i) - 1;\n        for j := i + 1 to a.Length\n          invariant minPos < a.Length\n          invariant a[minPos] == minValue\n          invariant Preserved(a,0,a.Length)\n          invariant comparisonCount == i * a.Length - Sum(i) + (j - i) - 1\n        {\n          label L:\n          var cmp := Ltm(a[j], minValue);\n          assert a[..] == old@L(a[..]);\n          if cmp {\n            minValue := a[j];\n            minPos := j;\n          }\n          assert(i * a.Length - Sum(i) + (j - i) - 1) + 1 == i * a.Length - Sum(i) + ((j + 1) - i) - 1;\n        }\n        if i != minPos {\n          a[i], a[minPos] := minValue, a[i];\n        }\n        assert comparisonCount == (i+1) * a.Length - Sum(i+1);\n      }\n    }\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0841", "language": "dafny", "source": "dafnybench", "source_id": "dafny_tmp_tmp59p638nn_examples_derangement_end", "vc-description": "", "vc-preamble": "predicate derangement(s: seq<nat>) {\n    forall i :: 0 <= i < |s| ==> s[i] != i\n}\n\npredicate permutation(s: seq<nat>) {\n    forall i :: 0 <= i < |s| ==> i in s\n}\n\nfunction multisetRange(n: nat): multiset<nat> {\n    multiset(seq(n, i => i))\n}\n\npredicate distinct<A(==)>(s: seq<A>) {\n    forall x,y :: x != y && 0 <= x <= y < |s| ==> s[x] != s[y]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method end(links: seq<nat>)\n    requires |links| > 0\n    requires permutation(links)\n    requires derangement(links)\n    requires distinct(links)", "vc-code": "{\n    assume forall x :: x in links ==> 0 <= x < |links|;\n    assume forall x :: x in links ==> multiset(links)[x] ==1;\n    // assume multiset(links) == multisetRange(|links|);\n    var qAct: nat := links[0];\n    assert links[0] in links;\n    var i : nat := 0;\n    ghost var oldIndex := 0;\n    ghost var indices: multiset<nat> := multiset{0};\n    ghost var visited: multiset<nat> := multiset{};\n\n    while qAct != 0\n        invariant 0 <= oldIndex < |links|\n        invariant qAct == links[oldIndex]\n        invariant oldIndex in indices\n        invariant qAct in links\n        invariant indices == visited + multiset{0}\n        invariant forall x :: x in visited ==> exists k :: 0 <= k < |links| && links[k] == x && k in indices\n        invariant qAct !in visited\n        invariant 0 <= qAct < |links|\n        decreases multiset(links) - visited\n    {\n        ghost var oldVisit := visited;\n        ghost var oldqAct := qAct;\n        ghost var oldOldIndex := oldIndex;\n        oldIndex := qAct;\n        visited := visited + multiset{qAct};\n        indices := indices + multiset{qAct};\n        assert oldqAct in visited;\n        assert forall x :: x in visited ==> exists k :: 0 <= k < |links| && links[k] == x && k in indices;\n\n        qAct := links[qAct];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0842", "language": "dafny", "source": "dafnybench", "source_id": "dafny_tmp_tmp59p638nn_examples_minmax2_DifferenceMinMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DifferenceMinMax(a: array<int>) returns (diff: int)\n    requires a.Length > 0\n    ensures diff == (Max(a[..]) - Min(a[..]))", "vc-code": "{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\n        invariant 1 <= i <= a.Length\n        invariant minVal <= maxVal\n        invariant forall k :: 0 <= k < i ==> minVal <= a[k] && a[k] <= maxVal\n        invariant minVal == Min(a[..i])\n        invariant maxVal == Max(a[..i])\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n        assert a[..i+1][..i] == a[..i];\n    }\n    assert a[..a.Length] == a[..];\n    diff := maxVal - minVal;\n}", "vc-postamble": "function Min(a: seq<int>) : (m: int)\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n      var minPrefix := Min(a[..|a|-1]);\n      if a[|a|-1] <= minPrefix then a[|a|-1] else minPrefix\n}\n\nfunction Max(a: seq<int>) : (m: int)\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else\n      var maxPrefix := Max(a[..|a|-1]);\n      if a[|a|-1] >= maxPrefix then a[|a|-1] else maxPrefix\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0846", "language": "dafny", "source": "dafnybench", "source_id": "formal-methods-in-software-engineering_tmp_tmpe7fjnek6_Labs4_gr2_DivMod", "vc-description": "", "vc-preamble": "/*\nDafny include 2 limbaje:\n    * un limbaj pentru specificare \n        MSFOL (ce am discutat până acum)\n        adnotări care să ajute în procesul de verificare\n    * un limbaj pentru scris programe\n*/\n\n// Exemplu de program", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method DivMod(a: int, b: int) returns (q: int, r: int)\ndecreases *", "vc-code": "{\n        q := 0;\n        r := a;\n        while (r >= b)\n        decreases *\n        {\n            r := r - b;\n            q := q + 1;\n        }\n}", "vc-postamble": "/*\n    triple Hoare (| P |) S (| Q |) \n*/\n\n// varianta assume-assert\n\n// varianta requires-ensures\n\n\n/*\nregula pentru while\n*/\n\n// varianta cu assert\n/*\n*/\n\n// varianta cu invariant\n\n//specificarea sumei de patrate\nfunction SqrSumRec(n: int) : int\n    requires n >= 0\n{\n    if (n == 0) then 0 else n*n + SqrSumRec(n-1)\n}\n/*\n*/\n\n// verificarea programului pentru suma de patrate\n\n\n// SqrSumRec(n) = 0^2 + 1^2 + 2^2 + ... + n^2 == n(n+1)(2n+1)/6\nleast lemma L1(n: int)\n    requires n >= 0\n    ensures SqrSumRec(n) == n*(n+1)*(2*n + 1)/6\n{\n    //OK\n}\n\n/*\nfunction SqrSumBy6(n: int) : int\n{\n    n * (n + 1) * (2 * n + 1) \n}\n\ninductive lemma L(n: int) // it takes a while\n    decreases n\n    requires n >= 0\n    ensures  SqrSumBy6(n) == 6 * SqrSumRec(n)\n{\n    if (n == 0) {}\n    else {\n        assert n > 0;\n        L(n-1);\n        assert SqrSumBy6(n-1) == n*(n-1)*(2*n - 1);\n        assert SqrSumBy6(n-1) == 6*SqrSumRec(n-1);\n        assert 6*SqrSumRec(n-1) == n*(n-1)*(2*n - 1);\n        calc == {\n            n*((n-1)*(2*n - 1));\n            n*(2*n*(n-1) - n + 1);\n            n*(2*n*n - 3*n + 1);\n            n*(2*n*n - 3*n + 1);\n        }\n        calc == {\n            2*n*n + n;\n            (2*n + 1)*n;\n        }\n        calc == {\n            (2*n + 1)*n + (2*n + 1);\n            (2*n + 1)*(n+1);\n        }\n        calc == {\n            n*((n-1)*(2*n - 1)) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*(n-1) - n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1) + 6*n*n;\n            n*(2*n*n - 3*n + 1 + 6*n);\n            n*(2*n*n + 6*n - 3*n + 1);\n            n*(2*n*n + 3*n + 1);\n            n*(2*n*n + n + (2*n + 1));\n            n*((2*n + 1)*n + (2*n + 1));\n            n*((2*n + 1)*(n+1));\n        }\n    }\n}\n\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0859", "language": "dafny", "source": "dafnybench", "source_id": "fv2020-tms_tmp_tmpnp85b47l_modeling_concurrency_safety_Enter", "vc-description": "", "vc-preamble": "/*\n * Model of the ticket system and correctness theorem\n * Parts 4 and 5 in the paper\n */\ntype Process(==) = int  // Philosopher\n\ndatatype CState = Thinking | Hungry | Eating  // Control states\n\n// A class can have state, with multiple fields, methods, a constructor, and declare functions and lemmas\nclass TicketSystem\n{\n  var ticket: int  // Ticket dispenser\n  var serving: int  // Serving display\n\n  const P: set<Process>  // Fixed set of processes\n\n  // State for each process\n  var cs: map<Process, CState>  // (Partial) Map from process to state\n  var t: map<Process, int>  // (Partial) Map from process to ticket number\n\n  // Invariant of the system\n  // Checks that P is a subset of the domain/keys of each map\n  predicate Valid()\n    reads this  // Depends on the fields on the current class\n  {\n    && cs.Keys == t.Keys == P  // Alt. P <= cs.Keys && P <= t.Keys\n    && serving <= ticket\n    && (forall p ::  // ticket help is in range(serving, ticket)\n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  // No other process can have the ticket number equals to serving\n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  // We are serving the correct ticket number\n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n\n  // Initialize the ticket system\n  constructor (processes: set<Process>)\n    ensures Valid()  // Postcondition\n    ensures P == processes  // Connection between processes and ts.P\n  {\n    P := processes;\n    ticket, serving := 0, 0;  // Alt. ticket := serving;\n    // The two following use map comprehension\n    cs := map p | p in processes :: Thinking;  // The map from p, where p in processes, takes value Thinking\n    t := map p | p in processes :: 0;\n  }\n\n  // The next three methods are our atomic events\n  // A Philosopher is Thinking and gets Hungry\n\n  // A Philosopher is Hungry and enters the kitchen", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Enter(p: Process)\n    requires Valid() && p in P && cs[p] == Hungry  // Control process precondition\n    modifies this  // Depends on the fields on the current class\n    ensures Valid()  // Postcondition", "vc-code": "{\n    if t[p] == serving  // The kitchen is available for this Philosopher\n    {\n      cs := cs[p := Eating];  // Philosopher's state changes to Eating\n    }\n}", "vc-postamble": "// A Philosopher is done Eating and leaves the kitchen\n\n  // Ensures that no two processes are in the same state\n  lemma MutualExclusion(p: Process, q: Process)\n    // Antecedents\n    requires Valid() && p in P && q in P\n    requires cs[p] == Eating && cs[q] == Eating\n    // Conclusion/Proof goal\n    ensures p == q\n  {\n\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0860", "language": "dafny", "source": "dafnybench", "source_id": "fv2020-tms_tmp_tmpnp85b47l_modeling_concurrency_safety_Leave", "vc-description": "", "vc-preamble": "/*\n * Model of the ticket system and correctness theorem\n * Parts 4 and 5 in the paper\n */\ntype Process(==) = int  // Philosopher\n\ndatatype CState = Thinking | Hungry | Eating  // Control states\n\n// A class can have state, with multiple fields, methods, a constructor, and declare functions and lemmas\nclass TicketSystem\n{\n  var ticket: int  // Ticket dispenser\n  var serving: int  // Serving display\n\n  const P: set<Process>  // Fixed set of processes\n\n  // State for each process\n  var cs: map<Process, CState>  // (Partial) Map from process to state\n  var t: map<Process, int>  // (Partial) Map from process to ticket number\n\n  // Invariant of the system\n  // Checks that P is a subset of the domain/keys of each map\n  predicate Valid()\n    reads this  // Depends on the fields on the current class\n  {\n    && cs.Keys == t.Keys == P  // Alt. P <= cs.Keys && P <= t.Keys\n    && serving <= ticket\n    && (forall p ::  // ticket help is in range(serving, ticket)\n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  // No other process can have the ticket number equals to serving\n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  // We are serving the correct ticket number\n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n\n  // Initialize the ticket system\n  constructor (processes: set<Process>)\n    ensures Valid()  // Postcondition\n    ensures P == processes  // Connection between processes and ts.P\n  {\n    P := processes;\n    ticket, serving := 0, 0;  // Alt. ticket := serving;\n    // The two following use map comprehension\n    cs := map p | p in processes :: Thinking;  // The map from p, where p in processes, takes value Thinking\n    t := map p | p in processes :: 0;\n  }\n\n  // The next three methods are our atomic events\n  // A Philosopher is Thinking and gets Hungry\n\n  // A Philosopher is Hungry and enters the kitchen\n\n  // A Philosopher is done Eating and leaves the kitchen", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Leave(p: Process)\n    requires Valid() && p in P && cs[p] == Eating  // Control process precondition\n    modifies this  // Depends on the fields on the current class\n    ensures Valid()  // Postcondition", "vc-code": "{\n    //assert t[p] == serving;  // Ticket held by p is equal to serving\n    serving := serving + 1;  // Kitchen is ready to serve the next ticket holder\n    cs := cs[p := Thinking];  // Philosopher's state changes to Thinking\n}", "vc-postamble": "// Ensures that no two processes are in the same state\n  lemma MutualExclusion(p: Process, q: Process)\n    // Antecedents\n    requires Valid() && p in P && q in P\n    requires cs[p] == Eating && cs[q] == Eating\n    // Conclusion/Proof goal\n    ensures p == q\n  {\n\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0861", "language": "dafny", "source": "dafnybench", "source_id": "fv2020-tms_tmp_tmpnp85b47l_modeling_concurrency_safety_Request", "vc-description": "", "vc-preamble": "/*\n * Model of the ticket system and correctness theorem\n * Parts 4 and 5 in the paper\n */\ntype Process(==) = int  // Philosopher\n\ndatatype CState = Thinking | Hungry | Eating  // Control states\n\n// A class can have state, with multiple fields, methods, a constructor, and declare functions and lemmas\nclass TicketSystem\n{\n  var ticket: int  // Ticket dispenser\n  var serving: int  // Serving display\n\n  const P: set<Process>  // Fixed set of processes\n\n  // State for each process\n  var cs: map<Process, CState>  // (Partial) Map from process to state\n  var t: map<Process, int>  // (Partial) Map from process to ticket number\n\n  // Invariant of the system\n  // Checks that P is a subset of the domain/keys of each map\n  predicate Valid()\n    reads this  // Depends on the fields on the current class\n  {\n    && cs.Keys == t.Keys == P  // Alt. P <= cs.Keys && P <= t.Keys\n    && serving <= ticket\n    && (forall p ::  // ticket help is in range(serving, ticket)\n      p in P && cs[p] != Thinking\n      ==> serving <= t[p] < ticket\n    )\n    && (forall p, q ::  // No other process can have the ticket number equals to serving\n      p in P && q in P && p != q && cs[p] != Thinking && cs[q] != Thinking\n      ==> t[p] != t[q]\n    )\n    && (forall p ::  // We are serving the correct ticket number\n      p in P && cs[p] == Eating\n      ==> t[p] == serving\n    )\n  }\n\n  // Initialize the ticket system\n  constructor (processes: set<Process>)\n    ensures Valid()  // Postcondition\n    ensures P == processes  // Connection between processes and ts.P\n  {\n    P := processes;\n    ticket, serving := 0, 0;  // Alt. ticket := serving;\n    // The two following use map comprehension\n    cs := map p | p in processes :: Thinking;  // The map from p, where p in processes, takes value Thinking\n    t := map p | p in processes :: 0;\n  }\n\n  // The next three methods are our atomic events\n  // A Philosopher is Thinking and gets Hungry", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Request(p: Process)\n    requires Valid() && p in P && cs[p] == Thinking  // Control process precondition\n    modifies this  // Depends on the fields on the current class\n    ensures Valid()  // Postcondition", "vc-code": "{\n    t, ticket := t[p := ticket], ticket + 1;  // Philosopher gets current ticket, next ticket's number increases\n    cs := cs[p := Hungry];  // Philosopher's state changes to Hungry\n}", "vc-postamble": "// A Philosopher is Hungry and enters the kitchen\n\n  // A Philosopher is done Eating and leaves the kitchen\n\n  // Ensures that no two processes are in the same state\n  lemma MutualExclusion(p: Process, q: Process)\n    // Antecedents\n    requires Valid() && p in P && q in P\n    requires cs[p] == Eating && cs[q] == Eating\n    // Conclusion/Proof goal\n    ensures p == q\n  {\n\n  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0862", "language": "dafny", "source": "dafnybench", "source_id": "fv2020-tms_tmp_tmpnp85b47l_simple_tm_Step", "vc-description": "", "vc-preamble": "module ModelingTM {\n    type ProcessId = nat\n    type MemoryObject = nat\n    type TimeStamp = nat\n\n    class Operation {\n        const isWrite: bool\n        const memObject: MemoryObject\n    }\n\n    class Transaction {\n        const ops: seq<Operation>\n    }\n\n    // Process state : transaction progress and process memory.\n    class ProcessState {\n        // currentTx : id of tx being processed. txs.size() means done.\n        const currentTx: nat\n        // currentOp :\n        //      - tx.ops.size() represents tryCommit operation.\n        //      - -1 represents abort operation\n        //      - values in between represent read and write operations\n        const currentOp: int\n        // sub-operations of the operation, see the step function\n        const currentSubOp: nat\n\n        // Set of read objects with original observed timestamp.\n        const readSet: map<MemoryObject, TimeStamp>\n        // Set of written objects.\n        const writeSet: set<MemoryObject>\n\n        constructor () {\n            currentTx := 0;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n\n        constructor nextSubOp(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp\n            ensures this.currentSubOp == that.currentSubOp + 1\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp + 1;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n\n        constructor nextOp(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp + 1\n            ensures this.currentSubOp == 0\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp + 1;\n            currentSubOp := 0;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n\n        constructor abortTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == -1\n            ensures this.currentSubOp == 0\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := -1;\n            currentSubOp := 0;\n            readSet := that.readSet;\n            writeSet := that.writeSet;\n        }\n\n        constructor restartTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == 0\n            ensures this.currentSubOp == 0\n            ensures this.readSet == map[]\n            ensures this.writeSet == {}\n        {\n            currentTx := that.currentTx;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n\n        constructor nextTx(that: ProcessState)\n            ensures this.currentTx == that.currentTx + 1\n            ensures this.currentOp == 0\n            ensures this.currentSubOp == 0\n            ensures this.readSet == map[]\n            ensures this.writeSet == {}\n        {\n            currentTx := that.currentTx + 1;\n            currentOp := 0;\n            currentSubOp := 0;\n            readSet := map[];\n            writeSet := {};\n        }\n\n        constructor addToReadSet(that: ProcessState, obj: MemoryObject, ts: TimeStamp)\n            ensures currentTx == that.currentTx\n            ensures currentOp == that.currentOp\n            ensures currentSubOp == that.currentSubOp\n            ensures readSet.Keys == that.readSet.Keys + {obj}\n                && readSet[obj] == ts\n                && forall o :: o in readSet && o != obj ==> readSet[o] == that.readSet[o]\n            ensures writeSet == that.writeSet\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp;\n            readSet := that.readSet[obj := ts];\n            writeSet := that.writeSet;\n        }\n\n        constructor addToWriteSet(that: ProcessState, obj: MemoryObject)\n            ensures this.currentTx == that.currentTx\n            ensures this.currentOp == that.currentOp\n            ensures this.currentSubOp == that.currentSubOp\n            ensures this.readSet == that.readSet\n            ensures this.writeSet == that.writeSet + {obj}\n        {\n            currentTx := that.currentTx;\n            currentOp := that.currentOp;\n            currentSubOp := that.currentSubOp;\n            readSet := that.readSet;\n            writeSet := that.writeSet + {obj};\n        }\n    }\n\n    class TMSystem {\n        // Ordered list of transaction that each process should process\n        const txQueues : map<ProcessId, seq<Transaction>>\n        // State and memory of processes\n        const procStates : map<ProcessId, ProcessState>\n        // Dirty objects. (Replaces the object value in a real representation. Used for safety proof)\n        const dirtyObjs: set<MemoryObject>\n        // Object lock.\n        const lockedObjs: set<MemoryObject>\n        // Object timestamp. (Incremented at the end of any write transaction)\n        const objTimeStamps: map<MemoryObject, nat>\n\n        constructor (q: map<ProcessId, seq<Transaction>>) {\n            txQueues := q;\n            procStates := map[];\n            dirtyObjs := {};\n            lockedObjs := {};\n            objTimeStamps := map[];\n        }\n\n        constructor initTimestamp(that: TMSystem, obj: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps.Keys ==  that.objTimeStamps.Keys + {obj}\n                && objTimeStamps[obj] == 0\n                && forall o :: o in objTimeStamps && o != obj ==> objTimeStamps[o] == that.objTimeStamps[o]\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps[obj := 0];\n        }\n\n        constructor updateState(that: TMSystem, pid: ProcessId, state: ProcessState)\n            ensures txQueues == that.txQueues\n            ensures procStates.Keys == that.procStates.Keys + {pid}\n                && procStates[pid] == state\n                && forall p :: p in procStates && p != pid ==> procStates[p] == that.procStates[p]\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates[pid := state];\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n\n        constructor markDirty(that: TMSystem, obj: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs + {obj}\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs + {obj};\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n\n        constructor clearDirty(that: TMSystem, writeSet: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs - writeSet\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs - writeSet;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := that.objTimeStamps;\n        }\n\n        constructor acquireLock(that: TMSystem, o: MemoryObject)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs + {o}\n            ensures objTimeStamps == that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs + {o};\n            objTimeStamps := that.objTimeStamps;\n        }\n\n        constructor releaseLocks(that: TMSystem, objs: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs - objs\n            ensures objTimeStamps ==  that.objTimeStamps\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs - objs;\n            objTimeStamps := that.objTimeStamps;\n        }\n\n        constructor updateTimestamps(that: TMSystem, objs: set<MemoryObject>)\n            ensures txQueues == that.txQueues\n            ensures procStates == that.procStates\n            ensures dirtyObjs == that.dirtyObjs\n            ensures lockedObjs == that.lockedObjs\n            ensures objTimeStamps.Keys == that.objTimeStamps.Keys\n                && forall o :: o in that.objTimeStamps ==>\n                if(o in objs) then objTimeStamps[o] != that.objTimeStamps[o] else objTimeStamps[o] == that.objTimeStamps[o]\n        {\n            txQueues := that.txQueues;\n            procStates := that.procStates;\n            dirtyObjs := that.dirtyObjs;\n            lockedObjs := that.lockedObjs;\n            objTimeStamps := map o | o in that.objTimeStamps ::\n                if(o in objs) then (that.objTimeStamps[o] + 1) else that.objTimeStamps[o];\n        }\n\n        predicate stateValid(pid: ProcessId, state: ProcessState)\n            requires pid in procStates && state == procStates[pid]\n        {\n            && pid in txQueues\n            && state.currentTx <= |txQueues[pid]|\n            && if state.currentTx == |txQueues[pid]| then (\n                // Queue finished\n                && state.currentOp == 0\n                && state.currentSubOp == 0\n                && |state.readSet| == 0\n                && |state.writeSet| == 0\n            ) else if state.currentTx < |txQueues[pid]| then (\n                // Queue unfinished\n                && exists tx :: (\n                    && tx == txQueues[pid][state.currentTx]\n                    && state.currentOp <= |tx.ops|\n                    && state.currentOp >= -1\n                    && if (state.currentOp >= 0 && state.currentOp < |tx.ops|) then (\n                        // Read/Write operations have at most two subOps\n                        state.currentSubOp < 2\n                    ) else if state.currentOp == |tx.ops| then (\n                        // tryCommit has 4 subOps\n                        state.currentSubOp < 4\n                    ) else if state.currentOp == -1 then (\n                        // abort has 3 subOps\n                        state.currentSubOp < 3\n                    ) else false\n                )\n                && state.readSet.Keys <= objTimeStamps.Keys\n                && state.writeSet <= lockedObjs\n            ) else false\n        }\n\n        predicate validSystem()\n        {\n            && procStates.Keys <= txQueues.Keys\n            && dirtyObjs <= objTimeStamps.Keys\n            && lockedObjs <= objTimeStamps.Keys\n            && forall p, s :: p in procStates && s == procStates[p] ==> stateValid(p, s)\n        }\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Step(input: TMSystem, pid: ProcessId) returns (system: TMSystem)\n        requires pid in input.txQueues\n        requires pid in input.procStates\n        requires input.validSystem()\n        ensures system.validSystem()", "vc-code": "{\n        system := input;\n        var state: ProcessState := system.procStates[pid];\n        assert(system.stateValid(pid, state)); // Given by input.validSystem()\n        var txs := system.txQueues[pid];\n\n        if (state.currentTx >= |txs|) {\n            // Nothing left to do.\n            return;\n        }\n        var tx := txs[state.currentTx];\n\n        if (state.currentOp == |tx.ops|) {\n            // tryCommit\n            if(state.currentSubOp == 0) {\n                // Check locks\n                if !(forall o :: o in state.readSet ==> o in state.writeSet || o !in system.lockedObjs) {\n                    // Write detected (locked), aborting.\n                    state := new ProcessState.abortTx(state);\n                    system := new TMSystem.updateState(system, pid, state);\n                    assume(system.validSystem()); // TODO : Remove assumption.\n                    return;\n                }\n                // Continue to next sub-op.\n                state := new ProcessState.nextSubOp(state);\n            } else if (state.currentSubOp == 1) {\n                // Validate timestamps\n                if !(forall o :: o in state.readSet ==> state.readSet[o] == system.objTimeStamps[o]) {\n                    // Write detected (timestamp changed), aborting.\n                    state := new ProcessState.abortTx(state);\n                    system := new TMSystem.updateState(system, pid, state);\n                    assume(system.validSystem()); // TODO : Remove assumption.\n                    return;\n                }\n                // Can (and will) commit !\n                // The writeset can now be read safely by others so we can remove the dirty mark.\n                system := new TMSystem.clearDirty(system, state.writeSet);\n                // Continue to next sub-op.\n                state := new ProcessState.nextSubOp(state);\n            } else if (state.currentSubOp == 2) {\n                // Update timestamps\n                system := new TMSystem.updateTimestamps(system, state.writeSet);\n                // Continue to next sub-op.\n                state := new ProcessState.nextSubOp(state);\n            } else if (state.currentSubOp == 3) {\n                // Release locks\n                system := new TMSystem.releaseLocks(system, state.writeSet);\n                // Commited. Continue to next transaction.\n                state := new ProcessState.nextTx(state);\n            } else {\n                assert(false);\n            }\n        } else if (state.currentOp == -1) {\n            // Abort\n            if(state.currentSubOp == 0) {\n                assert(state.currentTx < |system.txQueues[pid]|);\n                // Restore written values (equivalent to removing dirty marks here).\n                system := new TMSystem.clearDirty(system, state.writeSet);\n                // Continue to next sub-op.\n                state := new ProcessState.nextSubOp(state);\n            } else if (state.currentSubOp == 1) {\n                // Update timestamps\n                system := new TMSystem.updateTimestamps(system, state.writeSet);\n                // Continue to next sub-op.\n                state := new ProcessState.nextSubOp(state);\n            } else if (state.currentSubOp == 2) {\n                // Release locks\n                system := new TMSystem.releaseLocks(system, state.writeSet);\n                // Restart transaction.\n                state := new ProcessState.restartTx(state);\n            } else {\n                assert(false);\n            }\n        } else if (state.currentOp >= 0 && state.currentOp < |tx.ops|) {\n            // Read/Write op\n            var op := tx.ops[state.currentOp];\n            var o := op.memObject;\n\n            // Init object timestamp if not present\n            if(o !in system.objTimeStamps) {\n                system := new TMSystem.initTimestamp(system, o);\n            }\n            assert(o in system.objTimeStamps);\n\n            if(op.isWrite) {\n                // Write\n                if(state.currentSubOp == 0) {\n                    if(!(op.memObject in state.writeSet)) {\n                        // trylock\n                        if(o in system.lockedObjs) {\n                            // Failed locking, aborting.\n                            state := new ProcessState.abortTx(state);\n                        } else {\n                            // Aquire lock. Continue to next sub-op.\n                            system := new TMSystem.acquireLock(system, o);\n                            state := new ProcessState.addToWriteSet(state, o);\n                            state := new ProcessState.nextSubOp(state);\n                        }\n                    } else {\n                        // Already in writeset, continue to next subOp.\n                        state := new ProcessState.nextSubOp(state);\n                    }\n                } else if (state.currentSubOp == 1) {\n                    // Do the write (equivalent to marking as dirty). Continue to next op.\n                    system := new TMSystem.markDirty(system, o);\n                    state := new ProcessState.nextOp(state);\n                } else {\n                    assert(false);\n                }\n            } else {\n                // Read operation\n                if(state.currentSubOp == 0) {\n                    if(o in state.writeSet || o in state.readSet) {\n                        // Already in writeSet or readSet, fast-skip to next op.\n                        state := new ProcessState.nextOp(state);\n                    } else {\n                        // Read timestamp and add to readSet. Continue to next sub-op.\n                        state := new ProcessState.addToReadSet(state, o, system.objTimeStamps[o]);\n                        state := new ProcessState.nextSubOp(state);\n                    }\n                } else if (state.currentSubOp == 1) {\n                    if(o in system.lockedObjs) {\n                        // Object is locked, aborting.\n                        state := new ProcessState.abortTx(state);\n                    } else {\n                        // All good. Continue to next op.\n                        state := new ProcessState.nextOp(state);\n                    }\n                } else {\n                    assert(false);\n                }\n            }\n        } else {\n            assert(false);\n        }\n        // Save the new state.\n        system := new TMSystem.updateState(system, pid, state);\n        assume(system.validSystem()); // TODO : Remove assumption.\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0863", "language": "dafny", "source": "dafnybench", "source_id": "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_Test_c___arrays_LinearSearch", "vc-description": "", "vc-preamble": "// RUN: %dafny /compile:3 /spillTargetCode:2 /compileTarget:cpp \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n\nnewtype uint32 = i:int | 0 <= i < 0x100000000", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method LinearSearch(a: array<uint32>, len:uint32, key: uint32) returns (n: uint32)\n  requires a.Length == len as int\n  ensures 0 <= n <= len\n  ensures n == len || a[n] == key", "vc-code": "{\n  n := 0;\n  while n < len\n    invariant n <= len\n  {\n    if a[n] == key {\n      return;\n    }\n    n := n + 1;\n  }\n}", "vc-postamble": "method PrintArray<A>(a:array?<A>, len:uint32)\n  requires a != null ==> len as int == a.Length\n{\n  if (a == null) {\n    print \"It's null\\n\";\n  } else {\n    var i:uint32 := 0;\n    while i < len {\n      print a[i], \" \";\n      i := i + 1;\n    }\n    print \"\\n\";\n  }\n}\n\ndatatype ArrayDatatype = AD(ar: array<uint32>)", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0864", "language": "dafny", "source": "dafnybench", "source_id": "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2_m", "vc-description": "", "vc-preamble": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m()\n     requires a.value == 11\n     modifies this, this.a", "vc-code": "{\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0865", "language": "dafny", "source": "dafnybench", "source_id": "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old3_mm", "vc-description": "", "vc-preamble": "class A {\n  var z1: array<nat>\n  var z2: array<nat>", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mm()\n    requires z1.Length > 10 && z1[0] == 7\n    requires z2.Length > 10 && z2[0] == 17\n    modifies z2", "vc-code": "{\n    var a: array<nat> := z1;\n    assert a[0] == 7;\n    a := z2;\n    assert a[0] == 17;\n    assert old(a[0]) == 17; // a is local with value z2\n    z2[0] := 27;\n    assert old(a[0]) == 17; // a is local, with current value of\n                            // z2; in pre-state z2[0] == 17\n    assert old(a)[0] == 27; // a is local, with current value of\n                            // z2; z2[0] is currently 27\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0866", "language": "dafny", "source": "dafnybench", "source_id": "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old_m", "vc-description": "", "vc-preamble": "class A {\n\n  var value: int", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this", "vc-code": "{\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\n    assert old(i) == 6; // i is local, but can't be changed anyway\n    assert old(j) == 18; // j is local and not affected by old\n    assert old@L(j) == 18; // j is local and not affected by old\n    assert old(value) == 42;\n    assert old@L(value) == 43;\n    assert old@M(value) == 44 && this.value == 44;\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0867", "language": "dafny", "source": "dafnybench", "source_id": "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise9_ComputeFib", "vc-description": "", "vc-preamble": "function fib(n: nat): nat\n{\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n                    fib(n - 1) + fib(n - 2)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method ComputeFib(n: nat) returns (b: nat)\n   ensures b == fib(n)  // Do not change this postcondition", "vc-code": "{\n    // Change the method body to instead use c as described.\n    // You will need to change both the initialization and the loop.\n    var i: int := 0;\n        b := 0;\n    var c := 1;\n    while i < n\n        invariant 0 <= i <= n\n        invariant b == fib(i)\n        invariant c == fib(i + 1)\n    {\n        b, c := c, c + b;\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0868", "language": "dafny", "source": "dafnybench", "source_id": "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise12_FindMax", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FindMax(a: array<int>) returns (i: int)\n    // Annotate this method with pre- and postconditions\n    // that ensure it behaves as described.\n    requires 0 < a.Length\n    ensures 0 <= i < a.Length\n    ensures forall k: int :: 0 <= k < a.Length ==> a[k] <= a[i]", "vc-code": "{\n    // Fill in the body that calculates the INDEX of the maximum.\n    var j := 0;\n    var max := a[0];\n        i := 1;\n    while i < a.Length\n        invariant 1 <= i <= a.Length\n        invariant forall k: int :: 0 <= k < i ==> max >= a[k]\n        invariant 0 <= j < a.Length\n        invariant a[j] == max\n        decreases a.Length - i\n    {\n        if max < a[i] {\n            max := a[i];\n            j := i;\n        }\n        i := i + 1;\n    }\n\n    i := j;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0869", "language": "dafny", "source": "dafnybench", "source_id": "lets-prove-blocking-queue_tmp_tmptd_aws1k_dafny_prod-cons_get", "vc-description": "", "vc-preamble": "/**\n *  A proof in Dafny of the non blocking property of a queue.\n *  @author Franck Cassez.\n *\n *  @note: based off Modelling Concurrency in Dafny, K.R.M. Leino\n *  @link{http://leino.science/papers/krml260.pdf}\n */\nmodule ProdCons {\n\n    //  A type for process id that supports equality (i.e. p == q is defined).\n    type Process(==) \n\n    //  A type for the elemets in the buffer.\n    type T\n\n    /**\n     *  The producer/consumer problem.\n     *  The set of processes is actuall irrelevant (included here because part of the \n     *  original problem statement ...)\n     */\n    class ProdCons { \n\n        /**\n         *  Set of processes in the system.\n         */\n        const P: set<Process>\n\n        /**\n         *  The maximal size of the buffer.\n         */\n        var maxBufferSize : nat \n\n        /**\n         *  The buffer.\n         */\n        var buffer : seq<T> \n\n        /**\n         *  Invariant.\n         *\n         *  Buffer should always less than maxBufferSize elements,\n         *  Set of processes is not empty\n         *  \n         */\n        predicate valid() \n            reads this\n        {\n            maxBufferSize > 0 && P != {} &&\n            0 <= |buffer| <= maxBufferSize \n        }\n\n        /**\n         *  Initialise set of processes and buffer and maxBufferSize\n         */\n        constructor (processes: set<Process>, m: nat ) \n            requires processes != {}        //  Non empty set of processes.\n            requires m >= 1                 //  Buffer as at least one cell.\n            ensures valid()                 //  After initilisation the invariant is true\n        { \n            P := processes;\n            buffer := [];\n            maxBufferSize := m;\n        }\n\n        /**\n         *  Enabledness of a put operation.\n         *  If enabled any process can perform a put.\n         */\n        predicate putEnabled(p : Process) \n            reads this\n        {\n            |buffer| < maxBufferSize\n        }\n\n        /** Event: a process puts an element in the queue.  */\n\n        /**\n         *  Enabledness of a get operation. \n         *  If enabled, any process can perform a get.\n         */\n        predicate getEnabled(p : Process) \n            reads this\n        {\n            |buffer| >= 1\n        }\n\n        /** Event: a process gets an element from the queue. */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method get(p: Process) \n            requires getEnabled(p)\n            requires valid()                //  Invariant is inductive\n            ensures |buffer| == |old(buffer)| - 1   //  this invariant is not needed and can be omitted\n            modifies this", "vc-code": "{\n           //   remove the first element of buffer.\n           //   note: Dafny implcitly proves that the tail operation can be performed\n           //   as a consequence of  |buffer| >= 1 (getEnabled()). \n           //   To see this, comment out the\n           //   requires and an error shows up.\n           buffer := buffer[1..];\n}", "vc-postamble": "/** Correctness theorem: no deadlock. \n         *  From any valid state, at least one process is enabled.\n         */\n        lemma noDeadlock() \n            requires valid() \n            ensures exists p :: p in P && (getEnabled(p) || putEnabled(p))\n\n            //  as processes are irrelevant, this could be simplified\n            //  into isBufferNotFull() or isBufferNotEmpty()\n        { \n          //    Dafny automatically proves this.  so we can leave the\n          //    body of this lemma empty.\n          //    But for the sake of clarity, here is the proof.\n\n          //    P is not empty so there is a process p in P\n          //    Reads as: select a p of type Process such that p in P\n          var p: Process :| p in P ;\n          //    Now we have a p.\n          //    We are going to use the fact that valid() must hold as it is a pre-condition\n            if ( |buffer| > 0 ) {\n                assert (getEnabled(p));\n            }\n            else {\n                //  You may comment out the following asserts and Dafny\n                //  can figure out the proof from the constraints that are\n                //  true in this case.\n                //  Becas=use |buffer| == 0 and maxBufferSize >= 1, we can do a put\n                assert(|buffer| == 0);\n                assert (|buffer| < maxBufferSize); \n                assert(putEnabled(p));\n            }\n        }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0870", "language": "dafny", "source": "dafnybench", "source_id": "lets-prove-blocking-queue_tmp_tmptd_aws1k_dafny_prod-cons_put", "vc-description": "", "vc-preamble": "/**\n *  A proof in Dafny of the non blocking property of a queue.\n *  @author Franck Cassez.\n *\n *  @note: based off Modelling Concurrency in Dafny, K.R.M. Leino\n *  @link{http://leino.science/papers/krml260.pdf}\n */\nmodule ProdCons {\n\n    //  A type for process id that supports equality (i.e. p == q is defined).\n    type Process(==) \n\n    //  A type for the elemets in the buffer.\n    type T\n\n    /**\n     *  The producer/consumer problem.\n     *  The set of processes is actuall irrelevant (included here because part of the \n     *  original problem statement ...)\n     */\n    class ProdCons { \n\n        /**\n         *  Set of processes in the system.\n         */\n        const P: set<Process>\n\n        /**\n         *  The maximal size of the buffer.\n         */\n        var maxBufferSize : nat \n\n        /**\n         *  The buffer.\n         */\n        var buffer : seq<T> \n\n        /**\n         *  Invariant.\n         *\n         *  Buffer should always less than maxBufferSize elements,\n         *  Set of processes is not empty\n         *  \n         */\n        predicate valid() \n            reads this\n        {\n            maxBufferSize > 0 && P != {} &&\n            0 <= |buffer| <= maxBufferSize \n        }\n\n        /**\n         *  Initialise set of processes and buffer and maxBufferSize\n         */\n        constructor (processes: set<Process>, m: nat ) \n            requires processes != {}        //  Non empty set of processes.\n            requires m >= 1                 //  Buffer as at least one cell.\n            ensures valid()                 //  After initilisation the invariant is true\n        { \n            P := processes;\n            buffer := [];\n            maxBufferSize := m;\n        }\n\n        /**\n         *  Enabledness of a put operation.\n         *  If enabled any process can perform a put.\n         */\n        predicate putEnabled(p : Process) \n            reads this\n        {\n            |buffer| < maxBufferSize\n        }\n\n        /** Event: a process puts an element in the queue.  */", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method put(p: Process, t : T) \n            requires valid()                \n            requires putEnabled(p)          //  |buffer| < maxBufferSize\n            modifies this", "vc-code": "{\n            buffer := buffer + [t] ;\n}", "vc-postamble": "/**\n         *  Enabledness of a get operation. \n         *  If enabled, any process can perform a get.\n         */\n        predicate getEnabled(p : Process) \n            reads this\n        {\n            |buffer| >= 1\n        }\n\n        /** Event: a process gets an element from the queue. */\n\n        /** Correctness theorem: no deadlock. \n         *  From any valid state, at least one process is enabled.\n         */\n        lemma noDeadlock() \n            requires valid() \n            ensures exists p :: p in P && (getEnabled(p) || putEnabled(p))\n\n            //  as processes are irrelevant, this could be simplified\n            //  into isBufferNotFull() or isBufferNotEmpty()\n        { \n          //    Dafny automatically proves this.  so we can leave the\n          //    body of this lemma empty.\n          //    But for the sake of clarity, here is the proof.\n\n          //    P is not empty so there is a process p in P\n          //    Reads as: select a p of type Process such that p in P\n          var p: Process :| p in P ;\n          //    Now we have a p.\n          //    We are going to use the fact that valid() must hold as it is a pre-condition\n            if ( |buffer| > 0 ) {\n                assert (getEnabled(p));\n            }\n            else {\n                //  You may comment out the following asserts and Dafny\n                //  can figure out the proof from the constraints that are\n                //  true in this case.\n                //  Becas=use |buffer| == 0 and maxBufferSize >= 1, we can do a put\n                assert(|buffer| == 0);\n                assert (|buffer| < maxBufferSize); \n                assert(putEnabled(p));\n            }\n        }\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0874", "language": "dafny", "source": "dafnybench", "source_id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_9_max", "vc-description": "", "vc-preamble": "function isMax(m: int, numbers: seq<int>): bool\n{\n    m in numbers &&\n    forall i :: 0 <= i < |numbers| ==> numbers[i] <= m\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max(numbers: seq<int>) returns (result: int)\nrequires numbers != []\nensures isMax(result, numbers)", "vc-code": "{\n    result := numbers[0];\n    for i := 1 to |numbers|\n    invariant isMax(result, numbers[0..i])\n    {\n        if numbers[i] > result {\n            result := numbers[i];\n        }\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0876", "language": "dafny", "source": "dafnybench", "source_id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_160_do_algebra", "vc-description": "", "vc-preamble": "function pow(base: int, exponent: int): int\n  requires exponent >= 0\n  decreases exponent\n{\n  if exponent == 0 then 1\n  else if exponent % 2 == 0 then pow(base * base, exponent / 2)\n  else base * pow(base, exponent - 1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method do_algebra(operators: seq<char>, operands: seq<int>) returns (result: int)\n  requires operators != [] && operands != [] && |operators| + 1 == |operands|\n  requires forall i :: 0 <= i < |operands| ==> operands[i] >= 0", "vc-code": "{\n  result := operands[0];\n  var i := 0;\n  while i < |operators|\n    invariant 0 <= i <= |operators|\n    decreases |operators| - i\n  {\n    var op := operators[i];\n    i := i + 1;\n    match op\n    {\n      case '+' =>\n        result := result + operands[i];\n      case '-' =>\n        result := result - operands[i];\n      case '*' =>\n        result := result * operands[i];\n      case '/' => \n        if operands[i] != 0 {\n            result := result / operands[i];\n        }\n      case '^' => \n        result := pow(result, operands[i]);\n      case _ =>\n    }\n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0877", "language": "dafny", "source": "dafnybench", "source_id": "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161_Reverse", "vc-description": "", "vc-preamble": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\n\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\n\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i]", "vc-code": "{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0879", "language": "dafny", "source": "dafnybench", "source_id": "metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_ex1_buscar", "vc-description": "", "vc-preamble": "/*\nBuscar\nr = 0\nenquanto(r<|a|){\n    se (a[r] == x) retorne r\n    r = r+1\n}\nretorne -1\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method buscar(a:array<int>, x:int) returns (r:int)\nensures r < 0 ==> forall i :: 0 <= i <a.Length ==> a[i] != x\nensures 0 <= r < a.Length ==> a[r] == x", "vc-code": "{\n    r := 0;\n    while r < a.Length\n    decreases a.Length - r\n    invariant 0 <= r <= a.Length\n    invariant forall i :: 0 <= i < r ==> a[i] != x\n    {\n        if a[r] == x\n        {\n            return r;\n        }\n        r := r + 1;\n    }\n    return -1;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0880", "language": "dafny", "source": "dafnybench", "source_id": "metodosFormais_tmp_tmp4q2kmya4_T1-MetodosFormais_examples_somatoriov2_somatorio", "vc-description": "", "vc-preamble": "function somaAteAberto(a:array<nat>, i:nat):nat\nrequires i <= a.Length\nreads a\n{\n    if i ==0\n    then 0\n    else a[i-1] + somaAteAberto(a,i-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method somatorio(a:array<nat>) returns (s:nat)\nensures s == somaAteAberto(a, a.Length)", "vc-code": "{\n    s := 0;\n    for i:= 0 to a.Length\n    invariant s == somaAteAberto(a,i)\n    {\n        s := s + a[i];\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0881", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_bibble_add", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\nmethod nit_add(b : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  // This is a useful fact for doing general form addition.\n  ensures  (carry == 0 || carry == 1)\n{\n  z := (x + y) % b;\n  carry := (x + y) / b;\n\n  // The last postcondition is a little too bold,\n  // so here is a proof of its correctness\n  assert x + y < b + b;\n  assert (x + y) / b < (b + b) / b;\n  assert (x + y) / b < 2;\n  assert carry < 2;\n  assert carry == 0 || carry == 1;\n}\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\nmethod nit_add_three(b : nat, c : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (c == 0 || c == 1)\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  ensures  (carry == 0 || carry == 1)\n{\n  if(c == 0) {\n    z, carry := nit_add(b, x, y);\n  } else {\n    z := (x + y + 1) % b;\n    carry := (x + y + 1) / b;\n\n    // Gigantic proof to show that (x + y + 1) / b will either == 1\n    // (meaning we need 1 set of b to contain x + y + 1)\n    // or (x + y + 1) == 0 (meaning we don't need a set of b to contian x + y + 1).\n    assert 0 <= b - 1;\n\n    assert 0 <= x < b;\n    assert 0 == x || 0 < x;\n    assert 0 < x ==> x <= b - 1;\n    assert 0 <= x <= b - 1;\n\n    assert 0 <= y < b;\n    assert 0 == y || 0 < y;\n    assert 0 <= b - 1;\n    assert 0 < y ==> y <= b - 1;\n    assert 0 <= y <= b - 1;\n\n    assert x + y <= (b - 1) + (b - 1);\n    assert x + y <= 2 * b - 2;\n    assert x + y + 1 <= 2 * b - 2 + 1;\n    assert x + y + 1 <= 2 * b - 1;\n    assert 2 * b - 1 < 2 * b;\n    assert x + y + 1 < 2 * b;\n    assert (x + y + 1) / b < 2;\n    assert (x + y + 1) / b == 0 || (x + y + 1) / b == 1;\n  }\n}\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method bibble_add(b : nat, p : seq<nat>, q : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  requires (bibble(b, q))\n  ensures  (bibble(b, r))", "vc-code": "{\n  var z3, c3 := nit_add(b, p[3], q[3]);\n  var z2, c2 := nit_add_three(b, c3, p[2], q[2]);\n  var z1, c1 := nit_add_three(b, c2, p[1], q[1]);\n  var z0, c0 := nit_add_three(b, c1, p[0], q[0]);\n\n  r := [z0, z1, z2, z3];\n}", "vc-postamble": "/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0882", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_bibble_flip", "vc-description": "", "vc-preamble": "method max_nit(b: nat) returns (nmax : nat)\n  requires (valid_base(b))\n  ensures (nitness(b, nmax))\n  ensures (is_max_nit(b, nmax))\n{\n  nmax := b - 1;\n}\n\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n\n// Liam Wynn, 3/13/2021, CS 510p\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\nmethod nit_flip(b: nat, n : nat) returns (nf : nat)\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness (b, nf))\n{\n  var mn : nat := max_nit(b);\n\n  // I found I could not just assert that\n  // 0 <= n <= mn. I had to do this long\n  // series of asserts to prove it.\n  assert 0 < n < b ==> n <= b - 1;\n  assert 0 == n ==> n <= b - 1;\n  assert n <= b - 1;\n  assert mn == b - 1;\n  assert 0 <= n <= mn;\n\n  // But from all the above, Dafny can figure\n  // out that nitness(b, mn - n) holds.\n  nf := mn - n;\n}\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method bibble_flip(b : nat, p : seq<nat>) returns (fp : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, fp))", "vc-code": "{\n  var n0 := nit_flip(b, p[0]);\n  var n1 := nit_flip(b, p[1]);\n  var n2 := nit_flip(b, p[2]);\n  var n3 := nit_flip(b, p[3]);\n\n  fp := [n0, n1, n2, n3];\n}", "vc-postamble": "/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0883", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_bibble_increment", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nmethod nit_add(b: nat, x: bool, y: bool) returns (z: bool, c: bool)\n{\n    z := x != y; // XOR\n    c := x && y; // AND\n}\n\n// Liam Wynn, 3/13/2021, CS 510p\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\nmethod bibble_add(b : nat, p : seq<nat>, q : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  requires (bibble(b, q))\n  ensures  (bibble(b, r))\n{\n  r := [0, 0, 0, 0];\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method bibble_increment(b : nat, p : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, r))", "vc-code": "{\n  var q : seq<nat> := [0, 0, 0, 1];\n  assert bibble(b, q);\n  r := bibble_add(b, p, q);\n}", "vc-postamble": "/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0884", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_max_nit", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method max_nit(b: nat) returns (nmax : nat)\n  requires (valid_base(b))\n  ensures (nitness(b, nmax))\n  ensures (is_max_nit(b, nmax))", "vc-code": "{\n  nmax := b - 1;\n}", "vc-postamble": "/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\n\n\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0885", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_n_complement", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nmethod bibble_add(b: nat, p: seq<nat>, q: seq<nat>) returns (r: seq<nat>)\n    requires |p| == |q|\n    ensures |r| == |p|\n{\n    r := p; // Placeholder implementation\n}\n\n// Liam Wynn, 3/13/2021, CS 510p\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\nmethod bibble_increment(b : nat, p : seq<nat>) returns (r : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, r))\n{\n  var q : seq<nat> := [0, 0, 0, 1];\n  assert bibble(b, q);\n  r := bibble_add(b, p, q);\n  assume false;\n}\n\nmethod max_nit(b: nat) returns (nmax : nat)\n  requires (valid_base(b))\n  ensures (nitness(b, nmax))\n  ensures (is_max_nit(b, nmax))\n{\n  nmax := b - 1;\n}\n\n\nmethod nit_flip(b: nat, n : nat) returns (nf : nat)\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness (b, nf))\n{\n  var mn : nat := max_nit(b);\n\n  // I found I could not just assert that\n  // 0 <= n <= mn. I had to do this long\n  // series of asserts to prove it.\n  assert 0 < n < b ==> n <= b - 1;\n  assert 0 == n ==> n <= b - 1;\n  assert n <= b - 1;\n  assert mn == b - 1;\n  assert 0 <= n <= mn;\n\n  // But from all the above, Dafny can figure\n  // out that nitness(b, mn - n) holds.\n  nf := mn - n;\n}\nmethod bibble_flip(b : nat, p : seq<nat>) returns (fp : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, fp))\n{\n  var n0 := nit_flip(b, p[0]);\n  var n1 := nit_flip(b, p[1]);\n  var n2 := nit_flip(b, p[2]);\n  var n3 := nit_flip(b, p[3]);\n\n  fp := [n0, n1, n2, n3];\n}\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method n_complement(b : nat, p : seq<nat>) returns (com : seq<nat>)\n  requires (valid_base(b))\n  requires (bibble(b, p))\n  ensures  (bibble(b, com))", "vc-code": "{\n  var fp := bibble_flip(b, p);\n  var fpi := bibble_increment(b, fp);\n  com := fpi;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0886", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_nit_add", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method nit_add(b : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  // This is a useful fact for doing general form addition.\n  ensures  (carry == 0 || carry == 1)", "vc-code": "{\n  z := (x + y) % b;\n  carry := (x + y) / b;\n\n  // The last postcondition is a little too bold,\n  // so here is a proof of its correctness\n  assert x + y < b + b;\n  assert (x + y) / b < (b + b) / b;\n  assert (x + y) / b < 2;\n  assert carry < 2;\n  assert carry == 0 || carry == 1;\n}", "vc-postamble": "/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\n\n\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0887", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_nit_add_three", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\nmethod nit_add(b : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  // This is a useful fact for doing general form addition.\n  ensures  (carry == 0 || carry == 1)\n{\n  z := (x + y) % b;\n  carry := (x + y) / b;\n\n  // The last postcondition is a little too bold,\n  // so here is a proof of its correctness\n  assert x + y < b + b;\n  assert (x + y) / b < (b + b) / b;\n  assert (x + y) / b < 2;\n  assert carry < 2;\n  assert carry == 0 || carry == 1;\n}\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method nit_add_three(b : nat, c : nat, x : nat, y : nat) returns (z : nat, carry : nat)\n  requires (valid_base(b))\n  requires (c == 0 || c == 1)\n  requires (nitness(b, x))\n  requires (nitness(b, y))\n  ensures  (nitness(b, z))\n  ensures  (nitness(b, carry))\n  ensures  (carry == 0 || carry == 1)", "vc-code": "{\n  if(c == 0) {\n    z, carry := nit_add(b, x, y);\n  } else {\n    z := (x + y + 1) % b;\n    carry := (x + y + 1) / b;\n\n    // Gigantic proof to show that (x + y + 1) / b will either == 1\n    // (meaning we need 1 set of b to contain x + y + 1)\n    // or (x + y + 1) == 0 (meaning we don't need a set of b to contian x + y + 1).\n    assert 0 <= b - 1;\n\n    assert 0 <= x < b;\n    assert 0 == x || 0 < x;\n    assert 0 < x ==> x <= b - 1;\n    assert 0 <= x <= b - 1;\n\n    assert 0 <= y < b;\n    assert 0 == y || 0 < y;\n    assert 0 <= b - 1;\n    assert 0 < y ==> y <= b - 1;\n    assert 0 <= y <= b - 1;\n\n    assert x + y <= (b - 1) + (b - 1);\n    assert x + y <= 2 * b - 2;\n    assert x + y + 1 <= 2 * b - 2 + 1;\n    assert x + y + 1 <= 2 * b - 1;\n    assert 2 * b - 1 < 2 * b;\n    assert x + y + 1 < 2 * b;\n    assert (x + y + 1) / b < 2;\n    assert (x + y + 1) / b == 0 || (x + y + 1) / b == 1;\n  }\n}", "vc-postamble": "/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\n\n\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0888", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_nit_flip", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/\n\n/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\nmethod max_nit(b: nat) returns (nmax : nat)\n  requires (valid_base(b))\n  ensures (nitness(b, nmax))\n  ensures (is_max_nit(b, nmax))\n{\n  nmax := b - 1;\n}\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method nit_flip(b: nat, n : nat) returns (nf : nat)\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness (b, nf))", "vc-code": "{\n  var mn : nat := max_nit(b);\n\n  // I found I could not just assert that\n  // 0 <= n <= mn. I had to do this long\n  // series of asserts to prove it.\n  assert 0 < n < b ==> n <= b - 1;\n  assert 0 == n ==> n <= b - 1;\n  assert n <= b - 1;\n  assert mn == b - 1;\n  assert 0 <= n <= mn;\n\n  // But from all the above, Dafny can figure\n  // out that nitness(b, mn - n) holds.\n  nf := mn - n;\n}", "vc-postamble": "/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\n\n\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0889", "language": "dafny", "source": "dafnybench", "source_id": "nitwit_tmp_tmplm098gxz_nit_nit_increment", "vc-description": "", "vc-preamble": "// Liam Wynn, 3/13/2021, CS 510p\n\n\nfunction sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\n/*\n  In this program, I'm hoping to define\n  N's complement: a generalized form of 2's complement.\n\n  I ran across this idea back in ECE 341, when I asked\n  the professor about a crackpot theoretical \"ternary machine\".\n  Looking into it, I came across a general form of 2's complement.\n\n  Suppose I had the following 4 nit word in base base 3:\n\n  1 2 0 1 (3)\n\n  Now, in two's complement, you \"flip\" the bits and add 1. In\n  n's complement, you flip the bits by subtracting the current\n  nit value from the largest possible nit value. Since our base\n  is 3, our highest possible nit value is 2:\n\n  1 0 2 1 (3)\n\n  Note how the 1's don't change (2 - 1 = 1), but the \"flipping\"\n  is demonstrated in the 2 and 0. flip(2) in base 3 = 0, and flip(0)\n  in base 3 = 2.\n\n  Now let's increment our flipped word:\n\n  1 0 2 2 (3)\n\n  Now, if this is truly the n's complement of 1 2 0 1 (3), their\n  sum should be 0:\n\n    1 1 1\n    1 2 0 1\n  + 1 0 2 2\n  ---------\n  1 0 0 0 0 (3)\n\n  Now, since our word size if 4 nits, the last nit gets dropped\n  giving us 0 0 0 0!\n\n  So basically I want to write a Dafny program that does the above\n  but verified. I don't know how far I will get, but I essentially\n  want to write an increment, addition, and flip procedures such\n  that:\n\n  sum(v, increment(flip(v)) = 0, where v is a 4 nit value in\n  a given base n.\n\n*/\n\n/*\n  In this program, we deal with bases that are explicitly greater\n  than or equal to 2. Without this fact, virtually all of our\n  postconditions will not be provable. We will run into issues\n  of dividing by 0 and what not.\n*/\npredicate valid_base(b : nat) {\n  b >= 2\n}\n\n/*\n  Now we are in a position to define a nit formally. We say\n  a natural number n is a \"nit\" of some base b if 0 <= n < b.\n  0 and 1 are 2-nits (\"bits\") since 0 <= 0 < 2 and 0 <= 1 < 2.\n*/\npredicate nitness(b : nat, n : nat)\n  requires (valid_base(b))\n{\n  0 <= n < b\n}\n\n/*\n  We define incrementing a nit (given its base). When you add two digits\n  together, you \"carry the one\" if the sum is >= 10.\n\n   1\n    7\n  + 3\n  ---\n   10\n\n  Addition simply takes two collections of things and merges them together.\n  Expressing the resulting collection in base 10 requires this strange\n  notion of \"carrying the one\". What it means is: the sum of 7 and 3\n  is one set of ten items, and nothing left over\". Or if I did 6 + 7,\n  that is \"one set of 10, and a set of 3\".\n\n  The same notion applies in other bases. 1 + 1 in base 2 is \"one set\n  of 2 and 0 sets of ones\".\n\n  We can express \"carrying\" by using division. Division by a base\n  tells us how many sets of that base we have. So 19 in base 10 is\n  \"1 set of 10, and 9 left over\". So modding tells us what's left\n  over and division tells us how much to carry (how many sets of the\n  base we have).\n*/", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method nit_increment(b : nat, n : nat) returns (sum : nat, carry : nat)\n  // Note: apparently, you need to explicitly put this here\n  // even though we've got it in the nitness predicate\n  requires (valid_base(b))\n  requires (nitness(b, n))\n  ensures (nitness(b, sum))\n  ensures (nitness(b, carry))", "vc-code": "{\n  sum := (n + 1) % b;\n  carry := (n + 1) / b;\n}", "vc-postamble": "/*\n  Okay next we are going to define the flip operation. In binary,\n  flip(0) = 1 and flip(1) = 0. We can generalize it to any base\n  by defining it as so:\n\n  let q be the max possible value of a given base. This\n  is b - 1. Given some nit n of b, the flip(n) is q - n.\n\n  For base 2, q = b - 1 = 2 - 1 = 1. flip(0) = 1 - 0 = 1,\n  and flip(1) = 1 - 1 = 0.\n\n  For base 3, q = 3 - 1 = 2. flip(0) = 2 - 0 = 2,\n  flip(1) = 2 - 1 = 1, and flip(2) = 2 - 2 = 0.\n\n  To begin with, we define a predicate is_max_nit which\n  is true if some natural q == b - 1.\n*/\npredicate is_max_nit(b : nat, q : nat) {\n  q == b - 1\n}\n\n/*\n  Next we define a meta-operator (on a base b) that\n  returns the max nit. To make Dafny (and our inner\n  mathmatician) happy, we need to require that b is\n  a valid base, and explicitly say max_nit(b) is\n  a nit of b, and that max_nit(b) is_max_nit(b).\n  I found these made the actual flip operation provable.\n*/\n\n/*\n  Now we define the flip operation proper. For this to work,\n  we need is_max_nit and a kind of silly proof to make Dafny\n  happy.\n*/\n\n/*\n  We will now take a detour back to addition. We want to define\n  a general version of nit_increment that allows you to add any two nits\n*/\n\n/*\n  It will come in handy to define a version of nit_add that takes\n  an additional argument c. Suppose I wanted to do base 2 addition\n  as follows:\n\n    1 1\n    0 1\n  +----\n\n  Doing one step would give us:\n\n    1\n    1 1\n    0 1\n  +----\n      0\n\n  This will allow us to do the above step nicely.\n*/\n\n/*\n  Whereas in binary computers, where we've the byte,\n  we will define a general version called a \"nyte\". A \"nyte\"\n  would be a collection of eight nits. However, for\n  simplicity's sake, we deal in half-nytes. A nibble is a\n  half-byte, so in our program we will call it a bibble.\n\n  So, a bibble given some valid_base b is a collection\n  of four nits.\n*/\npredicate bibble(b : nat, a : seq<nat>)\n{\n  valid_base(b) && \n  |a| == 4 && \n  forall n :: n in a ==> nitness(b, n)\n}\n\n/*\n  As with nits, we will define addition, increment, and flip operations.\n*/\n\n\n\n/*\n  The last part of the program: n's complement! It's the same as two's complement:\n  we flip all the nits and add 1.\n*/", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0890", "language": "dafny", "source": "dafnybench", "source_id": "protocol-verification-fa2023_tmp_tmpw6hy3mjp_demos_ch01_fast_exp_FastExp", "vc-description": "", "vc-preamble": "function sum(s: seq<int>, i: nat): int\n    requires i <= |s|\n{\n    if i == 0 then 0 else sum(s, i-1) + s[i-1]\n}\n\nfunction exp(b: nat, n: nat): nat {\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nlemma exp_sum(b: nat, n1: nat, n2: nat)\n  ensures exp(b, n1 + n2) == exp(b, n1) * exp(b, n2)\n{\n  if n1 == 0 {\n    return;\n  }\n  exp_sum(b, n1-1, n2);\n}\n\n// this \"auto\" version of exp_sum is convenient when we want to let Z3 figure\n// out how to use exp_sum rather than providing all the arguments ourselves\nlemma exp_sum_auto(b: nat)\n  ensures forall n1: nat, n2: nat :: exp(b, n1 + n2) == exp(b, n1) * exp(b, n2)\n{\n  forall n1: nat, n2: nat\n    ensures exp(b, n1 + n2) == exp(b, n1) * exp(b, n2) {\n    exp_sum(b, n1, n2);\n  }\n}\n\n/* A key aspect of this proof is that each iteration handles one bit of the\n * input. The best way I found to express its loop invariants is to compute and\n * refer to this sequence of bits, even if the code never materializes it. */\n\nfunction bits(n: nat): seq<bool>\n  decreases n\n{\n  if n == 0 then []\n  else [if (n % 2 == 0) then false else true] + bits(n/2)\n}\n\nfunction from_bits(s: seq<bool>): nat {\n  if s == [] then 0\n  else (if s[0] then 1 else 0) + 2 * from_bits(s[1..])\n}\n\nlemma bits_from_bits(n: nat)\n  ensures from_bits(bits(n)) == n\n{\n}\n\nlemma from_bits_append(s: seq<bool>, b: bool)\n  ensures from_bits(s + [b]) == from_bits(s) + exp(2, |s|) * (if b then 1 else 0)\n{\n  if s == [] {\n    return;\n  }\n  assert s == [s[0]] + s[1..];\n  from_bits_append(s[1..], b);\n  // from recursive call\n  assert from_bits(s[1..] + [b]) == from_bits(s[1..]) + exp(2, |s|-1) * (if b then 1 else 0);\n  exp_sum(2, |s|-1, 1);\n  assert (s + [b])[1..] == s[1..] + [b]; // observe\n  assert from_bits(s + [b]) == (if s[0] then 1 else 0) + 2 * from_bits(s[1..] + [b]);\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method FastExp(b: nat, n: nat) returns (r: nat)\n  ensures r == exp(b, n)", "vc-code": "{\n  // a is the exponent so far (see the invariant for the details)\n  var a := 1;\n  // c is b^(2^i) where i is the iteration number (see the invariant)\n  var c := b;\n  // we shadow n with a mutable variable since the loop modifies it at each\n  // iteration (it essentially tracks the remaining work, as expressed more\n  // precisely in the invariants)\n  var n := n;\n  // we will need to refer to the original value of n, which is shadowed, so to\n  // do that we store it in a ghost variable\n  ghost var n0 := n;\n  // to state the invariants we track the iteration count (but it's not used for\n  // the implementation, which only relies on n)\n  ghost var i: nat := 0;\n  bits_from_bits(n);\n  while n > 0\n    decreases n\n    invariant n <= n0\n    invariant i <= |bits(n0)|\n    // c is used to accumulate the exponent for the current bit\n    invariant c == exp(b, exp(2, i))\n    invariant bits(n) == bits(n0)[i..]\n    // n is the remaining work\n    invariant n == from_bits(bits(n0)[i..])\n    // a has the exponent using the bits of n0 through i\n    invariant a == exp(b, from_bits(bits(n0)[..i]))\n  {\n    ghost var n_loop_top := n;\n    if n % 2 == 1 {\n      assert bits(n)[0] == true;\n      // a accumulates bits(n0)[i..]. In this branch we drop a 1 bit from n and\n      // need to multiply in 2^i multiplications for that bit, which we get from\n      // c\n      a := a * c;\n      exp_sum(b, n0-n, i);\n      n := n / 2;\n      assert a == exp(b, from_bits(bits(n0)[..i]) + exp(2, i)) by {\n        exp_sum_auto(b);\n      }\n      assert bits(n0)[..i+1] == bits(n0)[..i] + [bits(n0)[i]];\n      from_bits_append(bits(n0)[..i], bits(n0)[i]);\n      assert a == exp(b, from_bits(bits(n0)[..i+1]));\n    } else {\n      assert bits(n)[0] == false;\n      n := n / 2;\n      assert bits(n0)[..i+1] == bits(n0)[..i] + [bits(n0)[i]];\n      from_bits_append(bits(n0)[..i], bits(n0)[i]);\n      // the new bit is a 0 so we don't need to change a to restore the\n      // invariant, we can just advance i\n      assert a == exp(b, from_bits(bits(n0)[..i+1]));\n    }\n    assert n == n_loop_top/2;\n    c := c * c;\n    // the invariant for c is relatively easy to maintain\n    assert c == exp(b, exp(2, i+1)) by {\n      exp_sum_auto(b);\n    }\n    i := i + 1;\n  }\n  // we need to prove that i covers all of bits(n0)\n  assert bits(n0)[..i] == bits(n0);\n  return a;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0891", "language": "dafny", "source": "dafnybench", "source_id": "pucrs-metodos-formais-t1_tmp_tmp7gvq3cw4_fila_concat", "vc-description": "", "vc-preamble": "/*\n    OK fila de tamanho ilimitado com arrays circulares\n    OK representação ghost: coleção de elementos da fila e qualquer outra informação necessária\n    OK predicate: invariante da representação abstrata associada à coleção do tipo fila\n\n    Operações\n        - OK construtor inicia fila fazia\n        - OK adicionar novo elemento na fila -> enfileira()\n        - OK remover um elemento da fila e retornar seu valor caso a fila contenha elementos  -> desenfileira()\n        - OK verificar se um elemento pertence a fila  -> contem()\n        - OK retornar numero de elementos da fila -> tamanho()\n        - OK verificar se a fila é vazia ou não -> estaVazia()\n        - OK concatenar duas filas retornando uma nova fila sem alterar nenhuma das outras -> concat()\n\n    OK criar método main testando a implementação \n    OK transformar uso de naturais para inteiros\n*/\n\nclass {:autocontracts}  Fila\n    {\n  var a: array<int>;\n  var cauda: nat;\n  const defaultSize: nat;\n\n  ghost var Conteudo: seq<int>;\n\n  // invariante\n  ghost predicate Valid()  {\n                        defaultSize > 0\n    && a.Length >= defaultSize\n    && 0 <= cauda <= a.Length\n    && Conteudo == a[0..cauda]\n    }\n\n    // inicia fila com 3 elementos\n    constructor ()\n      ensures Conteudo == []\n      ensures defaultSize == 3\n      ensures a.Length == 3\n      ensures fresh(a)\n    {\n    defaultSize := 3;\n    a := new int[3];\n    cauda := 0;\n    Conteudo := [];\n    }\n\n  function tamanho():nat\n    ensures tamanho() == |Conteudo|\n    {\n                    cauda\n    }\n\n  function estaVazia(): bool\n    ensures estaVazia() <==> |Conteudo| == 0\n    {\n                      cauda == 0\n    }\n\n  method enfileira(e:int)\n    ensures Conteudo == old(Conteudo) + [e]\n    {\n\n    if (cauda == a.Length) {\n      var novoArray := new int[cauda + defaultSize];\n      var i := 0;\n\n      forall i | 0 <= i < a.Length\n    {\n        novoArray[i] := a[i];\n    }\n      a := novoArray;\n    }\n\n    a[cauda] := e;\n    cauda := cauda + 1;\n    Conteudo := Conteudo + [e];\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method concat(f2: Fila) returns (r: Fila)\n    requires Valid()\n    requires f2.Valid()\n    ensures r.Conteudo == Conteudo + f2.Conteudo", "vc-code": "{\n    r := new Fila();\n\n    var i:= 0;\n\n    while i < cauda\n      invariant 0 <= i <= cauda\n      invariant 0 <= i <= r.cauda\n      invariant r.cauda <= r.a.Length\n      invariant fresh(r.Repr)\n      invariant r.Valid()\n      invariant r.Conteudo == Conteudo[0..i]\n    {\n      var valor := a[i];\n      r.enfileira(valor);\n      i := i + 1;\n    }\n\n    var j := 0;\n    while j < f2.cauda\n      invariant 0 <= j <= f2.cauda\n      invariant 0 <= j <= r.cauda\n      invariant r.cauda <= r.a.Length\n      invariant fresh(r.Repr)\n      invariant r.Valid()\n      invariant r.Conteudo == Conteudo + f2.Conteudo[0..j]\n    {\n      var valor := f2.a[j];\n      r.enfileira(valor);\n      j := j + 1;\n    }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0892", "language": "dafny", "source": "dafnybench", "source_id": "pucrs-metodos-formais-t1_tmp_tmp7gvq3cw4_fila_contem", "vc-description": "", "vc-preamble": "/*\n    OK fila de tamanho ilimitado com arrays circulares\n    OK representação ghost: coleção de elementos da fila e qualquer outra informação necessária\n    OK predicate: invariante da representação abstrata associada à coleção do tipo fila\n\n    Operações\n        - OK construtor inicia fila fazia\n        - OK adicionar novo elemento na fila -> enfileira()\n        - OK remover um elemento da fila e retornar seu valor caso a fila contenha elementos  -> desenfileira()\n        - OK verificar se um elemento pertence a fila  -> contem()\n        - OK retornar numero de elementos da fila -> tamanho()\n        - OK verificar se a fila é vazia ou não -> estaVazia()\n        - OK concatenar duas filas retornando uma nova fila sem alterar nenhuma das outras -> concat()\n\n    OK criar método main testando a implementação \n    OK transformar uso de naturais para inteiros\n*/\n\nclass {:autocontracts}  Fila\n    {\n  var a: array<int>;\n  var cauda: nat;\n  const defaultSize: nat;\n\n  ghost var Conteudo: seq<int>;\n\n  // invariante\n  ghost predicate Valid()  {\n                        defaultSize > 0\n    && a.Length >= defaultSize\n    && 0 <= cauda <= a.Length\n    && Conteudo == a[0..cauda]\n    }\n\n    // inicia fila com 3 elementos\n    constructor ()\n      ensures Conteudo == []\n      ensures defaultSize == 3\n      ensures a.Length == 3\n      ensures fresh(a)\n    {\n    defaultSize := 3;\n    a := new int[3];\n    cauda := 0;\n    Conteudo := [];\n    }\n\n  function tamanho():nat\n    ensures tamanho() == |Conteudo|\n    {\n                    cauda\n    }\n\n  function estaVazia(): bool\n    ensures estaVazia() <==> |Conteudo| == 0\n    {\n                      cauda == 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method contem(e: int) returns (r:bool)\n    ensures r <==> exists i :: 0 <= i < cauda && e == a[i]", "vc-code": "{\n    var i := 0;\n    r:= false;\n\n    while i < cauda\n      invariant 0 <= i <= cauda\n      invariant forall j: nat :: j < i ==> a[j] != e\n    {\n      if (a[i] == e) {\n        r:= true;\n        return;\n      }\n\n      i := i + 1;\n    }\n\n    return r;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0893", "language": "dafny", "source": "dafnybench", "source_id": "pucrs-metodos-formais-t1_tmp_tmp7gvq3cw4_fila_desenfileira", "vc-description": "", "vc-preamble": "/*\n    OK fila de tamanho ilimitado com arrays circulares\n    OK representação ghost: coleção de elementos da fila e qualquer outra informação necessária\n    OK predicate: invariante da representação abstrata associada à coleção do tipo fila\n\n    Operações\n        - OK construtor inicia fila fazia\n        - OK adicionar novo elemento na fila -> enfileira()\n        - OK remover um elemento da fila e retornar seu valor caso a fila contenha elementos  -> desenfileira()\n        - OK verificar se um elemento pertence a fila  -> contem()\n        - OK retornar numero de elementos da fila -> tamanho()\n        - OK verificar se a fila é vazia ou não -> estaVazia()\n        - OK concatenar duas filas retornando uma nova fila sem alterar nenhuma das outras -> concat()\n\n    OK criar método main testando a implementação \n    OK transformar uso de naturais para inteiros\n*/\n\nclass {:autocontracts}  Fila\n    {\n  var a: array<int>;\n  var cauda: nat;\n  const defaultSize: nat;\n\n  ghost var Conteudo: seq<int>;\n\n  // invariante\n  ghost predicate Valid()  {\n                        defaultSize > 0\n    && a.Length >= defaultSize\n    && 0 <= cauda <= a.Length\n    && Conteudo == a[0..cauda]\n    }\n\n    // inicia fila com 3 elementos\n    constructor ()\n      ensures Conteudo == []\n      ensures defaultSize == 3\n      ensures a.Length == 3\n      ensures fresh(a)\n    {\n    defaultSize := 3;\n    a := new int[3];\n    cauda := 0;\n    Conteudo := [];\n    }\n\n  function tamanho():nat\n    ensures tamanho() == |Conteudo|\n    {\n                    cauda\n    }\n\n  function estaVazia(): bool\n    ensures estaVazia() <==> |Conteudo| == 0\n    {\n                      cauda == 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method desenfileira() returns (e:int)\n    requires |Conteudo| > 0\n    ensures e == old(Conteudo)[0]\n    ensures Conteudo == old(Conteudo)[1..]", "vc-code": "{\n    e := a[0];\n    cauda := cauda - 1;\n    forall i | 0 <= i < cauda\n    {\n      a[i] := a[i+1];\n    }\n    Conteudo := a[0..cauda];\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0894", "language": "dafny", "source": "dafnybench", "source_id": "pucrs-metodos-formais-t1_tmp_tmp7gvq3cw4_fila_enfileira", "vc-description": "", "vc-preamble": "/*\n    OK fila de tamanho ilimitado com arrays circulares\n    OK representação ghost: coleção de elementos da fila e qualquer outra informação necessária\n    OK predicate: invariante da representação abstrata associada à coleção do tipo fila\n\n    Operações\n        - OK construtor inicia fila fazia\n        - OK adicionar novo elemento na fila -> enfileira()\n        - OK remover um elemento da fila e retornar seu valor caso a fila contenha elementos  -> desenfileira()\n        - OK verificar se um elemento pertence a fila  -> contem()\n        - OK retornar numero de elementos da fila -> tamanho()\n        - OK verificar se a fila é vazia ou não -> estaVazia()\n        - OK concatenar duas filas retornando uma nova fila sem alterar nenhuma das outras -> concat()\n\n    OK criar método main testando a implementação \n    OK transformar uso de naturais para inteiros\n*/\n\nclass {:autocontracts}  Fila\n    {\n  var a: array<int>;\n  var cauda: nat;\n  const defaultSize: nat;\n\n  ghost var Conteudo: seq<int>;\n\n  // invariante\n  ghost predicate Valid()  {\n                        defaultSize > 0\n    && a.Length >= defaultSize\n    && 0 <= cauda <= a.Length\n    && Conteudo == a[0..cauda]\n    }\n\n    // inicia fila com 3 elementos\n    constructor ()\n      ensures Conteudo == []\n      ensures defaultSize == 3\n      ensures a.Length == 3\n      ensures fresh(a)\n    {\n    defaultSize := 3;\n    a := new int[3];\n    cauda := 0;\n    Conteudo := [];\n    }\n\n  function tamanho():nat\n    ensures tamanho() == |Conteudo|\n    {\n                    cauda\n    }\n\n  function estaVazia(): bool\n    ensures estaVazia() <==> |Conteudo| == 0\n    {\n                      cauda == 0\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method enfileira(e:int)\n    ensures Conteudo == old(Conteudo) + [e]", "vc-code": "{\n    if (cauda == a.Length) {\n      var novoArray := new int[cauda + defaultSize];\n      var i := 0;\n\n      forall i | 0 <= i < a.Length\n    {\n        novoArray[i] := a[i];\n    }\n      a := novoArray;\n    }\n\n    a[cauda] := e;\n    cauda := cauda + 1;\n    Conteudo := Conteudo + [e];\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0895", "language": "dafny", "source": "dafnybench", "source_id": "se2011_tmp_tmp71eb82zt_ass1_ex6_Ceiling7", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Ceiling7(n:nat) returns (k:nat)\nrequires n >= 0\nensures k == n-(n%7)", "vc-code": "{\n    k := n-(n%7);\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0899", "language": "dafny", "source": "dafnybench", "source_id": "specTesting_tmp_tmpueam35lx_examples_sort_sort_quickSort", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\n\n\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\n\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)", "vc-code": "{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}", "vc-postamble": "lemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n        assert m3 == m1 - m2;\n        assert m4 == m1 - m2;\n    }\n\n\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n        assert multiset(s1[..|s1|-1]) == multiset(s2[..|s2|-1]) by {\n            assert s1 == s1[..|s1|-1] + [s1[|s1|-1]];\n            assert multiset(s1) == multiset(s1[..|s1|-1]) + multiset([s1[|s1|-1]]);\n\n            assert s2 == s2[..|s1|-1] + [s2[|s1|-1]];\n            assert multiset(s2) == multiset(s2[..|s1|-1]) + multiset([s2[|s1|-1]]);\n\n            assert multiset([s1[|s1|-1]]) == multiset([s2[|s1|-1]]);\n\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n            assert s2[|s2|-1] !in multiset(s1);\n            assert false;\n        } else {\n            assert s1[|s1|-1] !in multiset(s2);\n            assert false;\n        }\n    }\n}\n\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n\n    if (|curSeq| != |curSeq'|) {\n        assert |multiset(curSeq)| != |multiset(curSeq')|;\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\n\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0900", "language": "dafny", "source": "dafnybench", "source_id": "summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise02_solution_test_prime", "vc-description": "", "vc-preamble": "predicate divides(f:nat, i:nat)\n  requires 1<=f\n{\n  i % f == 0\n}\n\npredicate IsPrime(i:nat)\n{\n  && 1<i\n  && ( forall f :: 1 < f < i ==> !divides(f, i) )\n}\n\n// Convincing the proof to go through requires adding\n// a loop invariant and a triggering assert.", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method test_prime(i:nat) returns (result:bool)\n  requires 1<i\n  ensures result == IsPrime(i)", "vc-code": "{\n  var f := 2;\n  while (f < i)\n    // This loop invariant completes an inductive proof of the\n    // body of IsPrime. Go look at the IsPrime definition and\n    // see how this forall relates to it.\n    // Note that when f == i, this is IsPrime.\n    // Also note that, when the while loop exists, i<=f.\n    invariant forall g :: 1 < g < f ==> !divides(g, i)\n  {\n    if i % f == 0 {\n      // This assert is needed to witness that !IsPrime.\n      // !IsPrime is !forall !divides, which rewrites to exists divides.\n      // Dafny rarely triggers its way to a guess for an exists (apparently\n      // it's tough for Z3), but mention a witness and Z3's happy.\n      assert divides(f, i);\n      return false;\n    }\n    f := f + 1;\n  }\n  return true;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0901", "language": "dafny", "source": "dafnybench", "source_id": "summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_fast_sort", "vc-description": "", "vc-preamble": "predicate IsSorted(s:seq<int>)\n{\n  forall i :: 0 <= i < |s|-1 ==> s[i] <= s[i+1]\n}\n\npredicate SortSpec(input:seq<int>, output:seq<int>)\n{\n  && IsSorted(output)\n  && multiset(output) == multiset(input)\n}\n\n//lemma SequenceConcat(s:seq<int>, pivot:int)\n//  requires 0<=pivot<|s|\n//  ensures s[..pivot] + s[pivot..] == s\n//{\n//}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method fast_sort(input:seq<int>) returns (output:seq<int>)\n//  ensures SortSpec(input, output)", "vc-code": "{\n  output := [1, 2, 3];\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0902", "language": "dafny", "source": "dafnybench", "source_id": "summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_merge", "vc-description": "", "vc-preamble": "predicate IsSorted(s:seq<int>)\n{\n  forall i :: 0 <= i < |s|-1 ==> s[i] <= s[i+1]\n}\n\npredicate SortSpec(input:seq<int>, output:seq<int>)\n{\n  && IsSorted(output)\n  && multiset(output) == multiset(input)\n}\n\n//lemma SequenceConcat(s:seq<int>, pivot:int)\n//  requires 0<=pivot<|s|\n//  ensures s[..pivot] + s[pivot..] == s\n//{\n//}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method merge(a:seq<int>, b:seq<int>) returns (output:seq<int>)\n  requires IsSorted(a)\n  requires IsSorted(b)\n//  ensures IsSorted(output)\n  ensures SortSpec(a+b, output)\n  //decreases |a|+|b|", "vc-code": "{\n  var ai := 0;\n  var bi := 0;\n  output := [];\n  while ai < |a| || bi < |b|\n    invariant 0 <= ai <= |a|\n    invariant 0 <= bi <= |b|\n    invariant 0 < |output| && ai < |a| ==> output[|output|-1] <= a[ai]\n    invariant 0 < |output| && bi < |b| ==> output[|output|-1] <= b[bi]\n    invariant forall i :: 0 <= i < |output|-1 ==> output[i] <= output[i+1]\n    invariant multiset(output) == multiset(a[..ai]) + multiset(b[..bi])\n    decreases |a|-ai + |b|-bi\n  {\n    ghost var outputo := output;\n    ghost var ao := ai;\n    ghost var bo := bi;\n    if ai == |a| || (bi < |b| && a[ai] > b[bi]) {\n      output := output + [b[bi]];\n      bi := bi + 1;\n      assert b[bo..bi] == [b[bo]];  // discovered by calc\n    } else {\n      output := output + [a[ai]];\n      ai := ai + 1;\n      assert a[ao..ai] == [a[ao]];  // discovered by calc\n    }\n    assert a[..ai] == a[..ao] + a[ao..ai];  // discovered by calc\n    assert b[..bi] == b[..bo] + b[bo..bi];  // discovered by calc\n//    calc {\n//      multiset(a[..ai]) + multiset(b[..bi]);\n//      multiset(a[..ao] + a[ao..ai]) + multiset(b[..bo] + b[bo..bi]);\n//      multiset(a[..ao]) + multiset(a[ao..ai]) + multiset(b[..bo]) + multiset(b[bo..bi]);\n//      multiset(a[..ao]) + multiset(b[..bo]) + multiset(a[ao..ai]) + multiset(b[bo..bi]);\n//      multiset(outputo) + multiset(a[ao..ai]) + multiset(b[bo..bi]);\n//      multiset(output);\n//    }\n  }\n  assert a == a[..ai];  // derived by calc\n  assert b == b[..bi];\n//  calc {\n//    multiset(output);\n//    multiset(a[..ai]) + multiset(b[..bi]);\n//    multiset(a) + multiset(b);\n//    multiset(a + b);\n//  }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0903", "language": "dafny", "source": "dafnybench", "source_id": "summer-school-2020_tmp_tmpn8nf7zf0_chapter02_solutions_exercise03_solution_merge_sort", "vc-description": "", "vc-preamble": "predicate IsSorted(s:seq<int>)\n{\n  forall i :: 0 <= i < |s|-1 ==> s[i] <= s[i+1]\n}\n\npredicate SortSpec(input:seq<int>, output:seq<int>)\n{\n  && IsSorted(output)\n  && multiset(output) == multiset(input)\n}\n\n//lemma SequenceConcat(s:seq<int>, pivot:int)\n//  requires 0<=pivot<|s|\n//  ensures s[..pivot] + s[pivot..] == s\n//{\n//}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method merge_sort(input:seq<int>) returns (output:seq<int>)\n  ensures SortSpec(input, output)", "vc-code": "{\n  if |input| <= 1 {\n    output := input;\n  } else {\n    var pivotIndex := |input| / 2;\n    var left := input[..pivotIndex];\n    var right := input[pivotIndex..];\n    var leftSorted := left;\n    leftSorted := merge_sort(left);\n    var rightSorted := right;\n    rightSorted := merge_sort(right);\n    output := merge(leftSorted, rightSorted);\n    assert left + right == input; // derived via calc\n//    calc {\n//      multiset(output);\n//      multiset(leftSorted + rightSorted);\n//      multiset(leftSorted) + multiset(rightSorted);\n//      multiset(left) + multiset(right);\n//      multiset(left + right);\n//        { assert left + right == input; }\n//      multiset(input);\n//    }\n  }\n}", "vc-postamble": "method merge(a:seq<int>, b:seq<int>) returns (output:seq<int>)\n  requires IsSorted(a)\n  requires IsSorted(b)\n//  ensures IsSorted(output)\n  ensures SortSpec(a+b, output)\n  //decreases |a|+|b|\n{\n  var ai := 0;\n  var bi := 0;\n  output := [];\n  while ai < |a| || bi < |b|\n    invariant 0 <= ai <= |a|\n    invariant 0 <= bi <= |b|\n    invariant 0 < |output| && ai < |a| ==> output[|output|-1] <= a[ai]\n    invariant 0 < |output| && bi < |b| ==> output[|output|-1] <= b[bi]\n    invariant forall i :: 0 <= i < |output|-1 ==> output[i] <= output[i+1]\n    invariant multiset(output) == multiset(a[..ai]) + multiset(b[..bi])\n    decreases |a|-ai + |b|-bi\n  {\n    ghost var outputo := output;\n    ghost var ao := ai;\n    ghost var bo := bi;\n    if ai == |a| || (bi < |b| && a[ai] > b[bi]) {\n      output := output + [b[bi]];\n      bi := bi + 1;\n      assert b[bo..bi] == [b[bo]];  // discovered by calc\n    } else {\n      output := output + [a[ai]];\n      ai := ai + 1;\n      assert a[ao..ai] == [a[ao]];  // discovered by calc\n    }\n    assert a[..ai] == a[..ao] + a[ao..ai];  // discovered by calc\n    assert b[..bi] == b[..bo] + b[bo..bi];  // discovered by calc\n//    calc {\n//      multiset(a[..ai]) + multiset(b[..bi]);\n//      multiset(a[..ao] + a[ao..ai]) + multiset(b[..bo] + b[bo..bi]);\n//      multiset(a[..ao]) + multiset(a[ao..ai]) + multiset(b[..bo]) + multiset(b[bo..bi]);\n//      multiset(a[..ao]) + multiset(b[..bo]) + multiset(a[ao..ai]) + multiset(b[bo..bi]);\n//      multiset(outputo) + multiset(a[ao..ai]) + multiset(b[bo..bi]);\n//      multiset(output);\n//    }\n  }\n  assert a == a[..ai];  // derived by calc\n  assert b == b[..bi];\n//  calc {\n//    multiset(output);\n//    multiset(a[..ai]) + multiset(b[..bi]);\n//    multiset(a) + multiset(b);\n//    multiset(a + b);\n//  }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0904", "language": "dafny", "source": "dafnybench", "source_id": "t1_MF_tmp_tmpi_sqie4j_exemplos_classes_parte1_contadorV1b_Decrementa", "vc-description": "", "vc-preamble": "class Contador\n{\n    var valor: int;\n\n    //construtor anônimo\n    constructor ()\n      ensures valor == 0\n    {\n        valor := 0;\n    }\n\n    //construtor com nome\n    constructor Init(v:int)\n      ensures valor == v\n    {\n        valor := v;\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Decrementa()\n      modifies this\n      ensures valor == old(valor) - 1", "vc-code": "{\n        valor := valor -1 ;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0905", "language": "dafny", "source": "dafnybench", "source_id": "t1_MF_tmp_tmpi_sqie4j_exemplos_classes_parte1_contadorV1b_GetValor", "vc-description": "", "vc-preamble": "class Contador\n{\n    var valor: int;\n\n    //construtor anônimo\n    constructor ()\n      ensures valor == 0\n    {\n        valor := 0;\n    }\n\n    //construtor com nome\n    constructor Init(v:int)\n      ensures valor == v\n    {\n        valor := v;\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method GetValor() returns (v:int)\n      ensures v == valor", "vc-code": "{\n        return valor;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0906", "language": "dafny", "source": "dafnybench", "source_id": "t1_MF_tmp_tmpi_sqie4j_exemplos_classes_parte1_contadorV1b_Incrementa", "vc-description": "", "vc-preamble": "class Contador\n{\n    var valor: int;\n\n    //construtor anônimo\n    constructor ()\n      ensures valor == 0\n    {\n        valor := 0;\n    }\n\n    //construtor com nome\n    constructor Init(v:int)\n      ensures valor == v\n    {\n        valor := v;\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Incrementa()\n      modifies this\n      ensures valor == old(valor) + 1", "vc-code": "{\n        valor := valor + 1;\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0907", "language": "dafny", "source": "dafnybench", "source_id": "t1_MF_tmp_tmpi_sqie4j_exemplos_colecoes_arrays_ex4_Somatorio", "vc-description": "", "vc-preamble": "function SomaAte(a:array<nat>, i:nat):nat\n  requires 0 <= i <= a.Length\n  reads a\n{\n    if i == 0\n    then 0\n    else a[i-1] + SomaAte(a,i-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Somatorio(a:array<nat>) returns (s:nat)\n  ensures s == SomaAte(a,a.Length)", "vc-code": "{\n    var i := 0;\n    s := 0;\n    while i < a.Length\n      invariant 0 <= i && i <= a.Length\n      invariant s == SomaAte(a,i)\n    {\n        s := s + a[i];\n        i := i + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0909", "language": "dafny", "source": "dafnybench", "source_id": "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4_Fatorial", "vc-description": "", "vc-preamble": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)", "vc-code": "{\n    r := 1;\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant r == Fat(i)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0910", "language": "dafny", "source": "dafnybench", "source_id": "tangent-finder_tmp_tmpgyzf44ve_circles_Tangent", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Tangent(r: array<int>, x: array<int>) returns (b: bool)\n    requires forall i, j :: 0 <= i <= j < x.Length ==> x[i] <= x[j] // values in x will be in ascending order or empty\n    requires forall i, j :: (0 <= i < r.Length && 0 <= j < x.Length) ==> (r[i] >= 0 && x[j] >= 0)       // x and r will contain no negative values\n    ensures !b ==> forall i, j :: 0 <= i< r.Length && 0 <= j < x.Length ==> r[i] != x[j]   \n    ensures b ==> exists i, j :: 0 <= i< r.Length && 0 <= j < x.Length && r[i] == x[j]", "vc-code": "{\n    var tempB, tangentMissing, k, l := false, false, 0, 0;\n    while k != r.Length && !tempB\n        invariant 0 <= k <= r.Length\n        invariant tempB ==> exists i, j :: 0 <= i < r.Length && 0 <= j < x.Length && r[i] == x[j]\n        invariant !tempB ==> forall i, j :: (0 <= i<k && 0 <= j < x.Length) ==> r[i] != x[j]\n        decreases r.Length - k\n    {\n        l:= 0;\n        tangentMissing := false;\n        while l != x.Length && !tangentMissing\n            invariant 0 <= l <= x.Length\n            invariant tempB ==> exists i, j :: 0 <= i < r.Length && 0 <= j < x.Length && r[i] == x[j]\n            invariant !tempB ==> forall i :: 0 <= i< l ==> r[k] != x[i]\n            invariant tangentMissing ==> forall i :: (l <= i < x.Length) ==> r[k] != x[i]\n            decreases x.Length - l, !tempB, !tangentMissing\n        {\n\n            if  r[k] == x[l] {\n                tempB := true;\n            }\n            if (r[k] < x[l]) {\n                tangentMissing := true;\n            }\n            l := l + 1;\n        }\n        k := k + 1;\n    }\n    b := tempB;\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0911", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_addElement", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method addElement(element : int)\n        modifies this`elements\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures element in old(elements) ==> elements == old(elements)\n        ensures element !in old(elements) ==> |elements| == |old(elements)| + 1 && element in elements && forall i : int :: i in old(elements) ==> i in elements\n        ensures forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]", "vc-code": "{\n            if (element !in elements) {\n                elements := elements + [element];\n            }\n}", "vc-postamble": "//for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }\n\n\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0912", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_contains", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method contains(element : int) returns (contains : bool)\n        ensures contains == (element in elements)\n        ensures elements == old(elements)", "vc-code": "{\n            contains := false;\n            if (element in elements) {\n                contains := true;\n            }\n}", "vc-postamble": "//for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }\n\n\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0913", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_intersect", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }\n\n\n\n\n\n        //for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method intersect(s : Set) returns (intersection : Set)\n        requires forall i, j | 0 <= i < |s.elements| && 0 <= j < |s.elements| && i != j :: s.elements[i] != s.elements[j]\n        requires forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements| && i != j :: this.elements[i] != this.elements[j]\n        ensures forall i : int :: i in intersection.elements <==> i in s.elements && i in this.elements \n        ensures forall i : int :: i !in intersection.elements  <==> i !in s.elements || i !in this.elements\n        ensures forall j, k | 0 <= j < |intersection.elements| && 0 <= k < |intersection.elements| && j != k :: intersection.elements[j] != intersection.elements[k]\n        ensures fresh(intersection)", "vc-code": "{\n            intersection := new Set.Set0();\n            var inter: seq<int> := [];\n\n            var i := 0;\n            while (0 <= i < |this.elements|)\n            decreases |this.elements| - i\n            invariant 0 <= i < |this.elements| || i == 0\n            invariant forall j, k | 0 <= j < |inter| && 0 <= k < |inter| && j != k :: inter[j] != inter[k]\n            invariant forall j :: 0 <= j < i < |this.elements| ==> (this.elements[j] in inter <==> this.elements[j] in s.elements)\n            invariant forall j :: 0 <= j < |inter| ==> inter[j] in this.elements && inter[j] in s.elements\n            invariant |inter| <= i <= |this.elements|\n            {\n\n                var old_len := |inter|;\n                if (this.elements[i] in s.elements && this.elements[i] !in inter) {\n                    inter := inter + [this.elements[i]];\n                }\n                if (i == |this.elements| - 1) {\n                    assert(old_len + 1 == |inter| || old_len == |inter|);\n                    break;\n                }\n                assert(old_len + 1 == |inter| || old_len == |inter|);\n                i := i + 1;\n            }\n            intersection.elements := inter;\n}", "vc-postamble": "}\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0914", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_removeElement", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method removeElement(element : int)\n        modifies this`elements\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures element in old(elements) ==> |elements| == |old(elements)| - 1 && (forall i : int :: i in old(elements) && i != element <==> i in elements) && element !in elements\n        ensures element !in old(elements) ==> elements == old(elements)\n        ensures forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]", "vc-code": "{\n            if (element in elements) {\n                var i := 0;\n\n                while (0 <= i < |elements|)\n                decreases |elements| - i\n                invariant 0 <= i < |elements|\n                invariant forall j : int :: 0 <= j < i < |elements| ==> elements[j] != element\n                {\n                    if (elements[i] == element) {\n                        if (i < |elements| - 1 && i != -1) {\n                            elements := elements[..i] + elements[i+1..];\n                        } \n                        else if (i == |elements| - 1) {\n                            elements := elements[..i];\n                        }\n                        break;\n                    }\n                    i := i + 1;\n                }\n            }\n}", "vc-postamble": "//for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }\n\n\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0915", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_size", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method size() returns (size : int)\n        ensures size == |elements|", "vc-code": "{\n            size := |elements|;\n}", "vc-postamble": "//for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }\n\n\n    }\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0916", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_IntegerSet_dafny_IntegerSet_union", "vc-description": "", "vc-preamble": "module IntegerSet {\n\n    class Set {\n\n        var elements: seq<int>;\n\n        constructor Set0() \n        ensures this.elements == []\n        ensures |this.elements| == 0\n        {\n            this.elements := [];\n        }\n\n        constructor Set(elements: seq<int>)\n        requires forall i, j | 0 <= i < |elements| && 0 <= j < |elements| && j != i :: elements[i] != elements[j]\n        ensures this.elements == elements\n        ensures forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements|  && j != i:: this.elements[i] != this.elements[j]\n        {\n            this.elements := elements;\n        }\n\n\n\n\n\n        //for computing the length of the intersection of 2 sets\n        function intersect_length(s1 : seq<int>, s2 : seq<int>, count : int, start : int, stop : int) : int \n        requires 0 <= start <= stop\n        requires stop <= |s1|\n        decreases stop - start\n        {\n            if start == stop then count else (if s1[start] in s2 then intersect_length(s1, s2, count + 1, start + 1, stop) else intersect_length(s1, s2, count, start + 1, stop))\n        }\n\n        //for computing the length of the union of 2 sets\n        //pass in the length of s2 as the initial count\n        function union_length(s1 : seq<int>, s2 : seq<int>, count : int, i : int, stop : int) : int \n        requires 0 <= i <= stop\n        requires stop <= |s1|\n        decreases stop - i\n        {\n            if i == stop then count else (if s1[i] !in s2 then union_length(s1, s2, count + 1, i + 1, stop) else union_length(s1, s2, count, i + 1, stop))\n        }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method union(s : Set) returns (union : Set)\n        requires forall i, j | 0 <= i < |s.elements| && 0 <= j < |s.elements| && i != j :: s.elements[i] != s.elements[j]\n        requires forall i, j | 0 <= i < |this.elements| && 0 <= j < |this.elements| && i != j :: this.elements[i] != this.elements[j]\n        ensures forall i : int :: i in s.elements || i in this.elements <==> i in union.elements\n        ensures forall i : int :: i !in s.elements && i !in this.elements <==> i !in union.elements\n        ensures forall j, k | 0 <= j < |union.elements| && 0 <= k < |union.elements| && j != k :: union.elements[j] != union.elements[k]\n        ensures fresh(union)", "vc-code": "{\n            var elems := s.elements;\n            union := new Set.Set0();\n\n            var i := 0;\n            while (0 <= i < |this.elements|)\n            decreases |this.elements| - i\n            invariant 0 <= i < |this.elements| || i == 0\n            invariant forall j : int :: 0 <= j < |s.elements| ==> s.elements[j] in elems\n            invariant forall j : int :: 0 <= j < i < |this.elements| ==> (this.elements[j] in elems <==> (this.elements[j] in s.elements || this.elements[j] in this.elements))\n            invariant forall j :: 0 <= j < |elems| ==> elems[j] in this.elements || elems[j] in s.elements\n            invariant forall j, k :: 0 <= j < |elems| && 0 <= k < |elems| && j != k ==> elems[j] != elems[k]\n            {\n                if (this.elements[i] !in elems) {\n                    elems := elems + [this.elements[i]];\n                }\n                if (i == |this.elements| - 1) {\n                    break;\n                }\n                i := i + 1;\n            }\n\n            union.elements := elems;\n}", "vc-postamble": "}\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0917", "language": "dafny", "source": "dafnybench", "source_id": "test-generation-examples_tmp_tmptwyqofrp_RussianMultiplication_dafny_RussianMultiplication_mult", "vc-description": "", "vc-preamble": "module RussianMultiplication {\n\n    export provides mult", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mult(n0 : int, m0 : int) returns (res : int)\n    ensures res == (n0 * m0);", "vc-code": "{\n        var n, m : int;\n        res := 0;\n        if (n0 >= 0) {\n            n,m := n0, m0;\n        } \n        else {\n            n,m := -n0, -m0;\n        }\n        while (0 < n)\n        invariant (m * n + res) == (m0 * n0);\n        decreases n; \n        { \n            res := res + m; \n            n := n - 1; \n        }\n}", "vc-postamble": "}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0918", "language": "dafny", "source": "dafnybench", "source_id": "veri-sparse_tmp_tmp15fywna6_dafny_concurrent_poc_6_Run", "vc-description": "", "vc-preamble": "class Process {\n    var row: nat;\n    var curColumn: nat;\n    var opsLeft: nat;\n\n    constructor (init_row: nat, initOpsLeft: nat) \n        ensures row == init_row\n        ensures opsLeft == initOpsLeft\n        ensures curColumn == 0\n    {\n        row := init_row;\n        curColumn := 0;\n        opsLeft := initOpsLeft;\n    }\n}\n\nfunction sum(s : seq<nat>) : nat\n  ensures sum(s) == 0 ==> forall i :: 0 <= i < |s| ==> s[i] == 0\n{\n    if s == [] then 0 else s[0] + sum(s[1..])\n}\n\nlemma sum0(s : seq<nat>)\n  ensures sum(s) == 0 ==> forall i :: 0 <= i < |s| ==> s[i] == 0\n  {\n    if s == [] {\n    } else {\n      sum0(s[1..]);\n    }\n  }\n\nlemma sum_const(s : seq<nat>, x : nat)\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == x) ==> sum(s) == |s| * x \n  {\n  }\n\nlemma sum_eq(s1 : seq<nat>, s2 : seq<nat>)\n  requires |s1| == |s2|\n  requires forall i :: 0 <= i < |s1| ==> s1[i] == s2[i]\n  ensures sum(s1) == sum(s2)\n  {\n\n  }\n\nlemma sum_exept(s1 : seq<nat>, s2 : seq<nat>, x : nat, j : nat)\nrequires |s1| == |s2|\nrequires j < |s1|\nrequires forall i :: 0 <= i < |s1| ==> i != j ==> s1[i] == s2[i]\nrequires s1[j] == s2[j] + x\nensures sum(s1) == sum(s2) + x\n{\n    if s1 == [] {\n        assert(j >= |s1|);\n    } else {\n        if j == 0 {\n            assert (sum(s1) == s1[0] + sum(s1[1..]));\n            assert (sum(s2) == s2[0] + sum(s2[1..]));\n            sum_eq(s1[1..], s2[1..]);\n            assert sum(s1[1..]) == sum(s2[1..]);\n        } else {\n            sum_exept(s1[1..], s2[1..], x, j - 1);\n        }\n    }\n}\n\n\nfunction calcRow(M : array2<int>, x : seq<int>, row: nat, start_index: nat) : (product: int)\n    reads M\n    requires M.Length1 == |x|\n    requires row < M.Length0\n    requires start_index <= M.Length1\n    decreases M.Length1 - start_index\n{\n    if start_index == M.Length1 then\n        0\n    else\n        M[row, start_index] * x[start_index] + calcRow(M, x, row, start_index+1)\n}\n\nclass MatrixVectorMultiplier\n{   \n\n    ghost predicate Valid(M: array2<int>, x: seq<int>, y: array<int>, P: set<Process>, leftOvers : array<nat>)\n        reads this, y, P, M, leftOvers\n    {\n        M.Length0 == y.Length &&\n        M.Length1 == |x| &&\n        |P| == y.Length &&\n        |P| == leftOvers.Length &&\n\n        (forall p, q :: p in P && q in P && p != q ==> p.row != q.row) &&\n        (forall p, q :: p in P && q in P ==> p != q) &&\n        (forall p :: p in P ==> 0 <= p.row < |P|) &&\n        (forall p :: p in P ==> 0 <= p.curColumn <= M.Length1) &&\n        (forall p :: p in P ==> 0 <= p.opsLeft <= M.Length1) && \n        (forall p :: p in P ==> y[p.row] + calcRow(M, x, p.row, p.curColumn) == calcRow(M, x, p.row, 0)) &&\n        (forall p :: p in P ==> leftOvers[p.row] == p.opsLeft) &&\n        (forall p :: p in P ==> p.opsLeft == M.Length1 - p.curColumn) &&\n        (sum(leftOvers[..]) > 0 ==> exists p :: p in P && p.opsLeft > 0)\n    }\n\n\n    constructor (processes: set<Process>, M_: array2<int>, x_: seq<int>, y_: array<int>, leftOvers : array<nat>)\n        // Idea here is that we already have a set of processes such that each one is assigned one row.\n        // Daphny makes it a ginormous pain in the ass to actually create such a set, so we just assume\n        // we already have one.\n\n        //this states that the number of rows and processes are the same, and that there is one process\n        //for every row, and that no two processes are the same, nor do any two processes share the same\n        //row\n        requires (forall i :: 0 <= i < leftOvers.Length ==> leftOvers[i] == M_.Length1)\n        requires |processes| == leftOvers.Length \n        requires |processes| == M_.Length0\n        requires (forall p, q :: p in processes && q in processes && p != q ==> p.row !=  q.row)\n        requires (forall p, q :: p in processes && q in processes ==> p != q)\n        requires (forall p :: p in processes ==> 0 <= p.row < M_.Length0)\n\n        //initializes process start\n        requires (forall p :: p in processes ==> 0 == p.curColumn)\n        requires (forall p :: p in processes ==> p.opsLeft == M_.Length1)\n\n        requires (forall i :: 0 <= i < y_.Length ==> y_[i] == 0)\n        requires y_.Length == M_.Length0\n\n        requires |x_| == M_.Length1\n        requires M_.Length0 > 0\n        requires |x_| > 0\n        ensures (forall i :: 0 <= i < leftOvers.Length ==> leftOvers[i] == M_.Length1)\n        ensures Valid(M_, x_, y_, processes, leftOvers)\n    {\n\n    }\n\n    method processNext(M: array2<int>, x: seq<int>, y: array<int>, P : set<Process>, leftOvers : array<nat>)\n        requires Valid(M, x, y, P, leftOvers)\n        requires exists p :: (p in P && p.opsLeft > 0)\n        requires sum(leftOvers[..]) > 0\n        modifies this, y, P, leftOvers\n        requires (forall p, q :: p in P && q in P && p != q ==> p.row != q.row)\n\n        ensures Valid(M, x, y, P, leftOvers)\n        ensures sum(leftOvers[..]) == sum(old(leftOvers[..])) - 1\n    {\n        var p :| p in P && p.opsLeft > 0;\n        y[p.row] := y[p.row] + M[p.row, p.curColumn] * x[p.curColumn];\n        p.opsLeft := p.opsLeft - 1;\n        p.curColumn := p.curColumn + 1;\n        leftOvers[p.row] := leftOvers[p.row] - 1;\n        assert (forall i :: 0 <= i < leftOvers.Length ==> i != p.row ==> leftOvers[i] == old(leftOvers[i]));\n        assert (leftOvers[p.row] + 1 == old(leftOvers[p.row]));\n        assert((forall p :: p in P ==> leftOvers[p.row] == p.opsLeft));\n        sum_exept(old(leftOvers[..]), leftOvers[..], 1, p.row);\n    }\n\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Run(processes: set<Process>, M: array2<int>, x: array<int>) returns (y: array<int>)\n    requires |processes| == M.Length0\n    requires (forall p, q :: p in processes && q in processes && p != q ==> p.row !=  q.row)\n    requires (forall p, q :: p in processes && q in processes ==> p != q)\n    requires (forall p :: p in processes ==> 0 <= p.row < M.Length0)\n\n    requires (forall p :: p in processes ==> 0 == p.curColumn)\n    requires (forall p :: p in processes ==> p.opsLeft == M.Length1)\n\n    requires x.Length > 0\n    requires M.Length0 > 0\n    requires M.Length1 == x.Length\n    ensures M.Length0 == y.Length\n    modifies processes, M, x", "vc-code": "{\n    var i := 0;\n    y := new int[M.Length0](i => 0);\n\n    var leftOvers := new nat[M.Length0](i => M.Length1);\n\n    var mv := new MatrixVectorMultiplier(processes, M, x[..], y, leftOvers);\n    while sum(leftOvers[..]) > 0 && exists p :: (p in processes && p.opsLeft > 0)\n        invariant mv.Valid(M, x[..], y, processes, leftOvers)\n        invariant (forall p :: p in processes ==> y[p.row] + calcRow(M, x[..], p.row, p.curColumn) == calcRow(M, x[..], p.row, 0))\n        invariant sum(leftOvers[..]) >= 0\n        invariant (forall p, q :: p in processes && q in processes && p != q ==> p.row !=  q.row)\n        decreases sum(leftOvers[..])\n    {\n        mv.processNext(M, x[..], y, processes, leftOvers);\n    }\n    assert(sum(leftOvers[..]) == 0);\n    assert(forall i :: 0 <= i < y.Length ==> y[i] == calcRow(M, x[..], i, 0));\n}", "vc-postamble": "// lemma lemma_newProcessNotInSet(process: Process, processes: set<Process>)\n//     requires (forall p :: p in processes ==> p.row != process.row)\n//     ensures process !in processes\n// {\n// }\n\n// lemma diffRowMeansDiffProcess(p1: Process, p2: Process)\n//     requires p1.row != p2.row\n//     ensures p1 != p2\n// {\n// }\n\n\n// method createSetProcesses(numRows: nat, numColumns: nat) returns (processes: set<Process>)\n//     ensures |processes| == numRows\n//     ensures (forall p, q :: p in processes && q in processes ==> p != q)\n//     ensures (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row)\n//     ensures (forall p :: p in processes ==> 0 <= p.row < numRows)\n//     ensures (forall p :: p in processes ==> 0 == p.curColumn)\n//     ensures (forall p :: p in processes ==> p.opsLeft == numColumns)\n// {\n//     processes := {};\n//     assert (forall p, q :: p in processes && q in processes ==> p != q);\n//     assert (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row);\n//     var i := 0;\n//     while i < numRows\n//         invariant i == |processes|\n//         invariant 0 <= i <= numRows\n//         invariant (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row)\n//         invariant (forall p, q :: p in processes && q in processes ==> p != q)\n//     {\n//         var process := new Process(i, numColumns);\n//         processes := processes + {process};\n//         i := i + 1;\n//     }\n// }\n\n// method Main()\n// {\n//     var M: array2<int> := new int[3, 3];\n\n//     M[0,0] := 1;\n//     M[0,1] := 2;\n//     M[0,2] := 3;\n\n//     M[1,0] := 1;\n//     M[1,1] := 2;\n//     M[1,2] := 3;\n\n//     M[2,0] := 1;\n//     M[2,1] := 20;\n//     M[2,2] := 3;\n\n//     var x := new int[3];\n//     x[0] := 1;\n//     x[1] := -3;\n//     x[2] := 3;\n\n//     var p0: Process := new Process(0, 3);\n//     var p1: Process := new Process(1, 3);\n//     var p2: Process := new Process(2, 3);\n//     var processes := {p0, p1, p2};\n\n//     assert (p0 != p1 && p1 != p2 && p0 != p2);\n//     assert (forall p :: p in processes ==> p == p0 || p == p1 || p == p2);\n//     assert (exists p :: p in processes && p == p0);\n//     assert (exists p :: p in processes && p == p1);\n//     assert (exists p :: p in processes && p == p2);\n//     assert (forall p, q :: p in processes && q in processes ==> p.row != q.row);\n//     assert (forall p, q :: p in processes && q in processes ==> p != q);\n\n//     var y := Run(processes, M, x);\n\n//     for i := 0 to 3 {\n//         print \"output: \", y[i], \"\\n\";\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0919", "language": "dafny", "source": "dafnybench", "source_id": "veri-sparse_tmp_tmp15fywna6_dafny_concurrent_poc_6_processNext", "vc-description": "", "vc-preamble": "class Process {\n    var row: nat;\n    var curColumn: nat;\n    var opsLeft: nat;\n\n    constructor (init_row: nat, initOpsLeft: nat) \n        ensures row == init_row\n        ensures opsLeft == initOpsLeft\n        ensures curColumn == 0\n    {\n        row := init_row;\n        curColumn := 0;\n        opsLeft := initOpsLeft;\n    }\n}\n\nfunction sum(s : seq<nat>) : nat\n  ensures sum(s) == 0 ==> forall i :: 0 <= i < |s| ==> s[i] == 0\n{\n    if s == [] then 0 else s[0] + sum(s[1..])\n}\n\nlemma sum0(s : seq<nat>)\n  ensures sum(s) == 0 ==> forall i :: 0 <= i < |s| ==> s[i] == 0\n  {\n    if s == [] {\n    } else {\n      sum0(s[1..]);\n    }\n  }\n\nlemma sum_const(s : seq<nat>, x : nat)\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == x) ==> sum(s) == |s| * x \n  {\n  }\n\nlemma sum_eq(s1 : seq<nat>, s2 : seq<nat>)\n  requires |s1| == |s2|\n  requires forall i :: 0 <= i < |s1| ==> s1[i] == s2[i]\n  ensures sum(s1) == sum(s2)\n  {\n\n  }\n\nlemma sum_exept(s1 : seq<nat>, s2 : seq<nat>, x : nat, j : nat)\nrequires |s1| == |s2|\nrequires j < |s1|\nrequires forall i :: 0 <= i < |s1| ==> i != j ==> s1[i] == s2[i]\nrequires s1[j] == s2[j] + x\nensures sum(s1) == sum(s2) + x\n{\n    if s1 == [] {\n        assert(j >= |s1|);\n    } else {\n        if j == 0 {\n            assert (sum(s1) == s1[0] + sum(s1[1..]));\n            assert (sum(s2) == s2[0] + sum(s2[1..]));\n            sum_eq(s1[1..], s2[1..]);\n            assert sum(s1[1..]) == sum(s2[1..]);\n        } else {\n            sum_exept(s1[1..], s2[1..], x, j - 1);\n        }\n    }\n}\n\n\nfunction calcRow(M : array2<int>, x : seq<int>, row: nat, start_index: nat) : (product: int)\n    reads M\n    requires M.Length1 == |x|\n    requires row < M.Length0\n    requires start_index <= M.Length1\n    decreases M.Length1 - start_index\n{\n    if start_index == M.Length1 then\n        0\n    else\n        M[row, start_index] * x[start_index] + calcRow(M, x, row, start_index+1)\n}\n\nclass MatrixVectorMultiplier\n{   \n\n    ghost predicate Valid(M: array2<int>, x: seq<int>, y: array<int>, P: set<Process>, leftOvers : array<nat>)\n        reads this, y, P, M, leftOvers\n    {\n        M.Length0 == y.Length &&\n        M.Length1 == |x| &&\n        |P| == y.Length &&\n        |P| == leftOvers.Length &&\n\n        (forall p, q :: p in P && q in P && p != q ==> p.row != q.row) &&\n        (forall p, q :: p in P && q in P ==> p != q) &&\n        (forall p :: p in P ==> 0 <= p.row < |P|) &&\n        (forall p :: p in P ==> 0 <= p.curColumn <= M.Length1) &&\n        (forall p :: p in P ==> 0 <= p.opsLeft <= M.Length1) && \n        (forall p :: p in P ==> y[p.row] + calcRow(M, x, p.row, p.curColumn) == calcRow(M, x, p.row, 0)) &&\n        (forall p :: p in P ==> leftOvers[p.row] == p.opsLeft) &&\n        (forall p :: p in P ==> p.opsLeft == M.Length1 - p.curColumn) &&\n        (sum(leftOvers[..]) > 0 ==> exists p :: p in P && p.opsLeft > 0)\n    }\n\n\n    constructor (processes: set<Process>, M_: array2<int>, x_: seq<int>, y_: array<int>, leftOvers : array<nat>)\n        // Idea here is that we already have a set of processes such that each one is assigned one row.\n        // Daphny makes it a ginormous pain in the ass to actually create such a set, so we just assume\n        // we already have one.\n\n        //this states that the number of rows and processes are the same, and that there is one process\n        //for every row, and that no two processes are the same, nor do any two processes share the same\n        //row\n        requires (forall i :: 0 <= i < leftOvers.Length ==> leftOvers[i] == M_.Length1)\n        requires |processes| == leftOvers.Length \n        requires |processes| == M_.Length0\n        requires (forall p, q :: p in processes && q in processes && p != q ==> p.row !=  q.row)\n        requires (forall p, q :: p in processes && q in processes ==> p != q)\n        requires (forall p :: p in processes ==> 0 <= p.row < M_.Length0)\n\n        //initializes process start\n        requires (forall p :: p in processes ==> 0 == p.curColumn)\n        requires (forall p :: p in processes ==> p.opsLeft == M_.Length1)\n\n        requires (forall i :: 0 <= i < y_.Length ==> y_[i] == 0)\n        requires y_.Length == M_.Length0\n\n        requires |x_| == M_.Length1\n        requires M_.Length0 > 0\n        requires |x_| > 0\n        ensures (forall i :: 0 <= i < leftOvers.Length ==> leftOvers[i] == M_.Length1)\n        ensures Valid(M_, x_, y_, processes, leftOvers)\n    {\n\n    }", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method processNext(M: array2<int>, x: seq<int>, y: array<int>, P : set<Process>, leftOvers : array<nat>)\n        requires Valid(M, x, y, P, leftOvers)\n        requires exists p :: (p in P && p.opsLeft > 0)\n        requires sum(leftOvers[..]) > 0\n        modifies this, y, P, leftOvers\n        requires (forall p, q :: p in P && q in P && p != q ==> p.row != q.row)\n\n        ensures Valid(M, x, y, P, leftOvers)\n        ensures sum(leftOvers[..]) == sum(old(leftOvers[..])) - 1", "vc-code": "{\n        var p :| p in P && p.opsLeft > 0;\n        y[p.row] := y[p.row] + M[p.row, p.curColumn] * x[p.curColumn];\n        p.opsLeft := p.opsLeft - 1;\n        p.curColumn := p.curColumn + 1;\n        leftOvers[p.row] := leftOvers[p.row] - 1;\n        assert (forall i :: 0 <= i < leftOvers.Length ==> i != p.row ==> leftOvers[i] == old(leftOvers[i]));\n        assert (leftOvers[p.row] + 1 == old(leftOvers[p.row]));\n        assert((forall p :: p in P ==> leftOvers[p.row] == p.opsLeft));\n        sum_exept(old(leftOvers[..]), leftOvers[..], 1, p.row);\n}", "vc-postamble": "}\n\n\n\n// lemma lemma_newProcessNotInSet(process: Process, processes: set<Process>)\n//     requires (forall p :: p in processes ==> p.row != process.row)\n//     ensures process !in processes\n// {\n// }\n\n// lemma diffRowMeansDiffProcess(p1: Process, p2: Process)\n//     requires p1.row != p2.row\n//     ensures p1 != p2\n// {\n// }\n\n\n// method createSetProcesses(numRows: nat, numColumns: nat) returns (processes: set<Process>)\n//     ensures |processes| == numRows\n//     ensures (forall p, q :: p in processes && q in processes ==> p != q)\n//     ensures (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row)\n//     ensures (forall p :: p in processes ==> 0 <= p.row < numRows)\n//     ensures (forall p :: p in processes ==> 0 == p.curColumn)\n//     ensures (forall p :: p in processes ==> p.opsLeft == numColumns)\n// {\n//     processes := {};\n//     assert (forall p, q :: p in processes && q in processes ==> p != q);\n//     assert (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row);\n//     var i := 0;\n//     while i < numRows\n//         invariant i == |processes|\n//         invariant 0 <= i <= numRows\n//         invariant (forall p, q :: p in processes && q in processes && p != q ==> p.row != q.row)\n//         invariant (forall p, q :: p in processes && q in processes ==> p != q)\n//     {\n//         var process := new Process(i, numColumns);\n//         processes := processes + {process};\n//         i := i + 1;\n//     }\n// }\n\n// method Main()\n// {\n//     var M: array2<int> := new int[3, 3];\n\n//     M[0,0] := 1;\n//     M[0,1] := 2;\n//     M[0,2] := 3;\n\n//     M[1,0] := 1;\n//     M[1,1] := 2;\n//     M[1,2] := 3;\n\n//     M[2,0] := 1;\n//     M[2,1] := 20;\n//     M[2,2] := 3;\n\n//     var x := new int[3];\n//     x[0] := 1;\n//     x[1] := -3;\n//     x[2] := 3;\n\n//     var p0: Process := new Process(0, 3);\n//     var p1: Process := new Process(1, 3);\n//     var p2: Process := new Process(2, 3);\n//     var processes := {p0, p1, p2};\n\n//     assert (p0 != p1 && p1 != p2 && p0 != p2);\n//     assert (forall p :: p in processes ==> p == p0 || p == p1 || p == p2);\n//     assert (exists p :: p in processes && p == p0);\n//     assert (exists p :: p in processes && p == p1);\n//     assert (exists p :: p in processes && p == p2);\n//     assert (forall p, q :: p in processes && q in processes ==> p.row != q.row);\n//     assert (forall p, q :: p in processes && q in processes ==> p != q);\n\n//     var y := Run(processes, M, x);\n\n//     for i := 0 to 3 {\n//         print \"output: \", y[i], \"\\n\";\n//     }\n// }", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0922", "language": "dafny", "source": "dafnybench", "source_id": "verified-isort_tmp_tmp7hhb8ei__dafny_isort_Isort", "vc-description": "", "vc-preamble": "// Dafny is designed to be familiar to those programming in an OOP language like\n// Java, so, we have plain old ordinary mutable arrays rather than the functional\n// list data structures that we saw in Coq.  This means that unlike our Coq\n// and Python examples, we can sort our array in-place and avoid needing a whole\n// bunch of intermediary allocations.\n\n// Just as before, we need a way of defining what it means for an array of nats\n// to be sorted:\npredicate sorted(a: seq<nat>)\n{\n    true // TODO\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method Isort(a: array<nat>)\n    modifies a\n    ensures sorted(a[..])", "vc-code": "{\n    if a.Length == 0 {\n        return;\n    }\n\n    // Here is the thing that we have to get Dafny to understand:\n    //\n    // We are going to iterate from left to right in the input array.  As we\n    // progress, everything to the left of the current element is going to be\n    // in sorted order, so that when we finish iterating through the array all\n    // elements are going to be in their correct order.\n    //\n    // Let's look at some iteration of that main loop, where we're neither at the\n    // beginning nor at the end of the process:\n    // \n    //      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //  a | ✓ | ✓ | ✓ | ✓ | ✓ | = |   |   |   |   |   |   |   |   |   |   |\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //    \\------------------/^\n    //     These elements are |\n    //       in sorted order  n == 5: this element will be placed in its right place\n    //                                by the end of the current loop iteration...\n    //\n\n    // In particular, there is some j on [0..n) such that:\n    //\n    //      1. j on [1..n) when a[j-1] <= a[n] and a[j] > a[n];\n    //      2. j == 0      when a[0] > a[n].\n    //\n    //      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //  a | <=| <=| <=| > | > | = |   |   |   |   |   |   |   |   |   |   |\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //    \\----------/^\\-----/\n    //       <= a[n]  | > a[n]\n    //                |\n    //                +--- k == 3: This is the index of where a[5] should go!\n\n    // So, we'll shift all the elements on [j, n) over by one, so they're now \n    // located on [j+1, n+1), and then place the old value of a[n] into a[j].\n    //\n    //      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //  a | <=| <=| <=| = | > | > |   |   |   |   |   |   |   |   |   |   |\n    //    +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n    //    \\----------/     \\-----/\n    //       <= a[n]        > a[n]\n    //\n    // And now we have one more element in the correct place!  We are now ready\n    // to begin the next iteration of the loop.\n\n    var n := 1;\n    while n < a.Length\n    {\n\n        var curr := a[n];\n\n        // 1. Find our pivot position k, the location where we should insert the\n        // current value.\n        var k := n;\n        while k > 0 && a[k-1] > curr\n        {\n            k := k-1;\n        }\n\n        a[n] := a[n-1]; // Hack to help the verifier with invariant sorted(a[k..n+1])\n\n        // 2. Shift all elements between k and n to the right by one.\n        var j := n-1;\n        while j >= k\n        {\n            a[j+1] := a[j];\n            j := j-1;\n        }\n\n        // 3. Put curr in its place!\n        a[k] := curr;\n        n := n + 1;\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0925", "language": "dafny", "source": "dafnybench", "source_id": "vfag_tmp_tmpc29dxm1j_mergesort_mergesort", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mergesort(V : array?<int>, c : int, f : int) \n\n    requires V != null\n    requires c >= 0 && f <= V.Length\n\n    decreases f - c\n\n    modifies V", "vc-code": "{\n    if c < f {\n\n        var m : int ;\n    m := c + (f - c) / 2 ;\n\n        mergesort(V, c, m) ;\n        mergesort(V, m + 1, f) ;\n\n        mezclar(V, c, m, f) ;\n\n    }\n}", "vc-postamble": "method mezclar(V: array?<int>, c : int, m : int, f : int)\n\n    requires V != null\n    requires c <= m <= f\n    requires 0 <= c <= V.Length\n    requires 0 <= m <= V.Length\n    requires 0 <= f <= V.Length\n\n    modifies V\n\n{\n\n    var V1 : array?<int> ;\n    var j  : nat ;\n\n    V1 := new int[m - c + 1] ;\n    j  := 0 ;\n\n    while j < V1.Length && c + j < V.Length\n\n        invariant 0 <= j     <= V1.Length\n        invariant 0 <= c + j <= V.Length\n\n        decreases V1.Length - j\n\n    {\n\n            V1[j] := V[c + j] ;\n            j := j + 1 ;\n\n    }\n\n\n    var V2 : array?<int> ;\n    var k  : nat ;\n\n    V2 := new int[f - m] ; \n    k  := 0 ;\n\n    while k < V2.Length && m + k + 1 < V.Length\n\n        invariant 0 <= k     <= V2.Length\n        invariant 0 <= m + k <= V.Length\n\n        decreases V2.Length - k\n\n    {\n\n        V2[k] := V[m + k + 1] ;\n        k := k + 1 ;\n\n    }\n\n\n    var i : nat ;\n\n    i := 0 ;\n    j := 0 ;\n    k := 0 ;\n\n    while i < f - c + 1  && \n          j <= V1.Length && \n          k <= V2.Length && \n          c + i < V.Length\n\n        invariant 0 <= i <= f - c + 1\n\n        decreases f - c - i\n\n    {\n\n        if j >= V1.Length && k >= V2.Length {\n\n            break ;\n\n        }\n\n        else if j >= V1.Length {\n\n            V[c + i] := V2[k] ;\n            k := k + 1 ;\n\n        }\n\n        else if k >= V2.Length {\n\n            V[c + i] := V1[j] ;\n            j := j + 1 ;\n\n        }\n\n        else {\n\n            if V1[j] <= V2[k] {\n\n                V[c + i] := V1[j] ;\n                j := j + 1 ;\n\n            }\n\n            else if V1[j] > V2[k] {\n\n                V[c + i] := V2[k] ;\n                k := k + 1 ;\n\n            }\n\n        }\n\n        i := i + 1 ;\n\n    }\n\n}", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0926", "language": "dafny", "source": "dafnybench", "source_id": "vfag_tmp_tmpc29dxm1j_mergesort_mezclar", "vc-description": "", "vc-preamble": "", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mezclar(V: array?<int>, c : int, m : int, f : int)\n\n    requires V != null\n    requires c <= m <= f\n    requires 0 <= c <= V.Length\n    requires 0 <= m <= V.Length\n    requires 0 <= f <= V.Length\n\n    modifies V", "vc-code": "{\n    var V1 : array?<int> ;\n    var j  : nat ;\n\n    V1 := new int[m - c + 1] ;\n    j  := 0 ;\n\n    while j < V1.Length && c + j < V.Length\n\n        invariant 0 <= j     <= V1.Length\n        invariant 0 <= c + j <= V.Length\n\n        decreases V1.Length - j\n\n    {\n\n            V1[j] := V[c + j] ;\n            j := j + 1 ;\n\n    }\n\n\n    var V2 : array?<int> ;\n    var k  : nat ;\n\n    V2 := new int[f - m] ; \n    k  := 0 ;\n\n    while k < V2.Length && m + k + 1 < V.Length\n\n        invariant 0 <= k     <= V2.Length\n        invariant 0 <= m + k <= V.Length\n\n        decreases V2.Length - k\n\n    {\n\n        V2[k] := V[m + k + 1] ;\n        k := k + 1 ;\n\n    }\n\n\n    var i : nat ;\n\n    i := 0 ;\n    j := 0 ;\n    k := 0 ;\n\n    while i < f - c + 1  && \n          j <= V1.Length && \n          k <= V2.Length && \n          c + i < V.Length\n\n        invariant 0 <= i <= f - c + 1\n\n        decreases f - c - i\n\n    {\n\n        if j >= V1.Length && k >= V2.Length {\n\n            break ;\n\n        }\n\n        else if j >= V1.Length {\n\n            V[c + i] := V2[k] ;\n            k := k + 1 ;\n\n        }\n\n        else if k >= V2.Length {\n\n            V[c + i] := V1[j] ;\n            j := j + 1 ;\n\n        }\n\n        else {\n\n            if V1[j] <= V2[k] {\n\n                V[c + i] := V1[j] ;\n                j := j + 1 ;\n\n            }\n\n            else if V1[j] > V2[k] {\n\n                V[c + i] := V2[k] ;\n                k := k + 1 ;\n\n            }\n\n        }\n\n        i := i + 1 ;\n\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
{"id": "DD0927", "language": "dafny", "source": "dafnybench", "source_id": "vfag_tmp_tmpc29dxm1j_mergesort_ordenar_mergesort", "vc-description": "", "vc-preamble": "method mezclar(V: array<int>, c: int, m: int, f: int)\n    requires 0 <= c <= m < f <= V.Length\n    modifies V\n{\n    // Placeholder merge implementation\n}\n\nmethod ordenar_mergesort(V : array?<int>)\n\n    requires V != null\n\n    modifies V\n\n{\n\n    mergesort(V, 0, V.Length - 1) ;\n\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "method mergesort(V : array?<int>, c : int, f : int) \n\n    requires V != null\n    requires c >= 0 && f <= V.Length\n\n    decreases f - c\n\n    modifies V", "vc-code": "{\n    if c < f {\n\n        var m : int ;\n    m := c + (f - c) / 2 ;\n\n        mergesort(V, c, m) ;\n        mergesort(V, m + 1, f) ;\n\n        mezclar(V, c, m, f) ;\n\n    }\n}", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "weak_specs"}
