{"id": "DB0000", "language": "dafny", "source": "bignum", "source_id": "bignum_Add", "vc-description": "Bignum task: bignum_Add.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0001", "language": "dafny", "source": "bignum", "source_id": "bignum_Add_NormalizeBitString", "vc-description": "Bignum task: bignum_Add[NormalizeBitString].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// Remove leading zeros, except keep at least one digit\n\n// I added and proved some extra post-conditions:", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0002", "language": "dafny", "source": "bignum", "source_id": "bignum_Compare", "vc-description": "Bignum task: bignum_Compare.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0003", "language": "dafny", "source": "bignum", "source_id": "bignum_CompareUnequal", "vc-description": "Bignum task: bignum_CompareUnequal.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0004", "language": "dafny", "source": "bignum", "source_id": "bignum_Compare_CompareUnequal", "vc-description": "Bignum task: bignum_Compare[CompareUnequal].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0005", "language": "dafny", "source": "bignum", "source_id": "bignum_Compare_CompareUnequal_NormalizeBitString", "vc-description": "Bignum task: bignum_Compare[CompareUnequal,NormalizeBitString].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// Remove leading zeros, except keep at least one digit\n\n// I added and proved some extra post-conditions:", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}\n\nmethod CompareUnequal(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  requires |s1| > 0\n  requires |s1| > 1 ==> s1[0] != '0'\n  requires |s2| > 0\n  requires |s2| > 1 ==> s2[0] != '0'\n  requires |s1| > |s2|\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0006", "language": "dafny", "source": "bignum", "source_id": "bignum_Compare_NormalizeBitString", "vc-description": "Bignum task: bignum_Compare[NormalizeBitString].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// Remove leading zeros, except keep at least one digit\n\n// I added and proved some extra post-conditions:", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n\n  ensures ValidBitString(t)\n\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0007", "language": "dafny", "source": "bignum", "source_id": "bignum_DivMod", "vc-description": "Bignum task: bignum_DivMod.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0008", "language": "dafny", "source": "bignum", "source_id": "bignum_DivMod_Compare", "vc-description": "Bignum task: bignum_DivMod[Compare].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0009", "language": "dafny", "source": "bignum", "source_id": "bignum_DivMod_Compare_Sub", "vc-description": "Bignum task: bignum_DivMod[Compare,Sub].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Compare(s1: string, s2: string) returns (res: int)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures Str2Int(s1) < Str2Int(s2) ==> res == -1\n  ensures Str2Int(s1) == Str2Int(s2) ==> res == 0\n  ensures Str2Int(s1) > Str2Int(s2) ==> res == 1\n  decreases Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0010", "language": "dafny", "source": "bignum", "source_id": "bignum_DivMod_Sub", "vc-description": "Bignum task: bignum_DivMod[Sub].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0011", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp", "vc-description": "Bignum task: bignum_ModExp.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0012", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2", "vc-description": "Bignum task: bignum_ModExpPow2.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0013", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_Add", "vc-description": "Bignum task: bignum_ModExpPow2[Add].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0014", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_Add_DivMod", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0015", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_Add_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Add,DivMod,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0016", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_Add_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Add,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0017", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_DivMod", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0018", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[DivMod,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0019", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExpPow2[Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0020", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExpPow2_int", "vc-description": "Bignum task: bignum_ModExpPow2_int.\nImplement the method according to the Dafny specification.", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}", "vc-helpers": "", "vc-spec": "method ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0021", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add", "vc-description": "Bignum task: bignum_ModExp[Add].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0022", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0023", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0024", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0025", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0026", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0027", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0028", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_DivMod_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,DivMod,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0029", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0030", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0031", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0032", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0033", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_Mul", "vc-description": "Bignum task: bignum_ModExp[Add,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0034", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0035", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Add_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Add,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0036", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod", "vc-description": "Bignum task: bignum_ModExp[DivMod].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0037", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0038", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0039", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0040", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0041", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0042", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0043", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_DivMod_Zeroes", "vc-description": "Bignum task: bignum_ModExp[DivMod,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0044", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_ModExpPow2", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0045", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_ModExpPow2_Add_Zeroes_DivMod_Mul", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Add,Zeroes,DivMod,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}\n\nmethod DivMod(dividend: string, divisor: string) returns (quotient: string, remainder: string)\n  requires ValidBitString(dividend) && ValidBitString(divisor)\n  requires Str2Int(divisor) > 0\n  ensures ValidBitString(quotient) && ValidBitString(remainder)\n  ensures Str2Int(quotient) == Str2Int(dividend) / Str2Int(divisor)\n  ensures Str2Int(remainder) == Str2Int(dividend) % Str2Int(divisor)\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0046", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_ModExpPow2_Mul", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0047", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_ModExpPow2_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0048", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_ModExpPow2_Zeroes", "vc-description": "Bignum task: bignum_ModExp[ModExpPow2,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n// sy is power of 2 or zero\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod ModExpPow2(sx: string, sy: string, n: nat, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n\n  requires Str2Int(sy) == Exp_int(2,n) || Str2Int(sy) == 0\n  requires |sy| == n+1\n  requires Str2Int(sz) > 1\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n  decreases n\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0049", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Mul", "vc-description": "Bignum task: bignum_ModExp[Mul].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0050", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Mul_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Mul,Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0051", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_Zeroes", "vc-description": "Bignum task: bignum_ModExp[Zeroes].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.\n\n//requires y < Exp_int(2,n+1)\n\n//&& n > 0", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\nghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\npredicate AllZero(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0'\n}\n\nmethod Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp(sx: string, sy: string, sz: string) returns (res: string)\n  requires ValidBitString(sx) && ValidBitString(sy) &&  ValidBitString(sz)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Exp_int(Str2Int(sx), Str2Int(sy)) % Str2Int(sz)\n\n  requires |sy| > 0 && Str2Int(sz) > 1\n  decreases |sy|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0052", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_int", "vc-description": "Bignum task: bignum_ModExp_int.\nImplement the method according to the Dafny specification.\n\n//&& n > 0", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}", "vc-helpers": "", "vc-spec": "method ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0053", "language": "dafny", "source": "bignum", "source_id": "bignum_ModExp_int_ModExpPow2_int", "vc-description": "Bignum task: bignum_ModExp_int[ModExpPow2_int].\nImplement the method according to the Dafny specification.\n\n//&& n > 0", "vc-preamble": "ghost function Exp_int(x: nat, y:nat): nat\n{\n  if y == 0 then 1 else x * Exp_int(x, y - 1)\n}\n\nmethod ModExpPow2_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y == Exp_int(2, n)\n  requires z > 0\n  ensures res == Exp_int(x,y) % z\n  decreases n\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method ModExp_int(x: nat, y:nat, n:nat, z: nat) returns (res:nat)\n  requires y < Exp_int(2,n+1)\n  requires z > 1\n  ensures res == Exp_int(x,y) % z\n  decreases n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DB0054", "language": "dafny", "source": "bignum", "source_id": "bignum_Mul", "vc-description": "Bignum task: bignum_Mul.\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0055", "language": "dafny", "source": "bignum", "source_id": "bignum_Mul_Add", "vc-description": "Bignum task: bignum_Mul[Add].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0056", "language": "dafny", "source": "bignum", "source_id": "bignum_Mul_Add_NormalizeBitString", "vc-description": "Bignum task: bignum_Mul[Add,NormalizeBitString].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod Add(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) + Str2Int(s2)\n{\n  assume{:axiom} false;\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0057", "language": "dafny", "source": "bignum", "source_id": "bignum_Mul_NormalizeBitString", "vc-description": "Bignum task: bignum_Mul[NormalizeBitString].\nImplement the method according to the Dafny specification.\n\n// All characters must be '0' or '1'.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Mul(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) * Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0058", "language": "dafny", "source": "bignum", "source_id": "bignum_NormalizeBitString", "vc-description": "Bignum task: bignum_NormalizeBitString.\nImplement the method according to the Dafny specification.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0059", "language": "dafny", "source": "bignum", "source_id": "bignum_Sub", "vc-description": "Bignum task: bignums_Sub.\nImplement the method according to the Dafny specification.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0060", "language": "dafny", "source": "bignum", "source_id": "bignum_Sub_NormalizeBitstring", "vc-description": "Bignum task: bignums_Sub[NormalizeBitstring].\nImplement the method according to the Dafny specification.", "vc-preamble": "ghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}\n\nmethod NormalizeBitString(s: string) returns(t: string)\n  ensures ValidBitString(t)\n  ensures |t| > 0\n  ensures |t| > 1 ==> t[0] != '0'\n  ensures ValidBitString(s) ==> Str2Int(s) == Str2Int(t)\n{\n  assume{:axiom} false;\n}", "vc-helpers": "", "vc-spec": "method Sub(s1: string, s2: string) returns (res: string)\n  requires ValidBitString(s1) && ValidBitString(s2)\n  requires Str2Int(s1) >= Str2Int(s2)\n  ensures ValidBitString(res)\n  ensures Str2Int(res) == Str2Int(s1) - Str2Int(s2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DB0061", "language": "dafny", "source": "bignum", "source_id": "bignum_Zeros", "vc-description": "Bignum task: bignums_Zeros.\nImplement the method according to the Dafny specification.", "vc-preamble": "predicate AllZero(s: string)\n{\n  |s| == 0 || forall i | 0 <= i < |s| :: s[i] == '0'\n}\nghost function Str2Int(s: string): nat\n  requires ValidBitString(s)\n  decreases s\n{\n  if |s| == 0 then  0  else  (2 * Str2Int(s[0..|s|-1]) + (if s[|s|-1] == '1' then 1 else 0))\n}\npredicate ValidBitString(s: string)\n{\n  forall i | 0 <= i < |s| :: s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method Zeros(n: nat) returns (s: string)\n  ensures |s| == n\n  ensures ValidBitString(s)\n  ensures Str2Int(s) == 0\n  ensures AllZero(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
