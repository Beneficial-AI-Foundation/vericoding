vc-description: |-
  This verification task involves determining whether two athletes ran on the same circular track with barriers but started from different positions. Given a track of length L with n barriers, each athlete records distances to barriers from their starting position. The challenge is to verify if the recorded sequences represent the same track configuration with different starting points by checking if one sequence is a rotation of another.

vc-preamble: |-
  // ======= TASK =======
  // Given a circular track of length L with n barriers, two athletes run counterclockwise 
  // and record their distances to barriers from their starting positions. Determine if they 
  // ran on the same track (same barrier positions) but possibly started from different positions.
  
  // ======= SPEC REQUIREMENTS =======
  predicate validInputFormat(input: string)
  {
      var lines := split(input, '\n');
      |lines| >= 3 &&
      var firstLine := split(lines[0], ' ');
      |firstLine| >= 2 &&
      var n := parseInteger(firstLine[0]);
      var l := parseInteger(firstLine[1]);
      n > 0 && l > 0 && n <= l &&
      var xLine := split(lines[1], ' ');
      var yLine := split(lines[2], ' ');
      |xLine| == n && |yLine| == n
  }
  
  predicate sameTrackDifferentStart(n: int, l: int, x: seq<int>, y: seq<int>)
      requires n > 0 && |x| == n && |y| == n
  {
      var xExtended := x + [x[0] + l];
      var yExtended := y + [y[0] + l];
      var a := seq(n, i requires 0 <= i < n && i + 1 < |xExtended| => xExtended[i + 1] - xExtended[i]);
      var b := seq(n, i requires 0 <= i < n && i + 1 < |yExtended| => yExtended[i + 1] - yExtended[i]);
      exists rotation {:trigger b[(rotation + 0) % n]} :: 0 <= rotation < n && 
          (forall j :: 0 <= j < n ==> a[j] == b[(rotation + j) % n])
  }
  
  function split(s: string, delimiter: char): seq<string>
  {
      if |s| == 0 then [""]
      else
          var i := findChar(s, delimiter, 0);
          if i == -1 then [s]
          else if i == 0 then [""] + split(s[1..], delimiter)
          else if 0 < i < |s| then [s[0..i]] + split(s[i+1..], delimiter)
          else [s]
  }
  
  function findChar(s: string, c: char, start: int): int
      requires 0 <= start <= |s|
      decreases |s| - start
  {
      if start >= |s| then -1
      else if s[start] == c then start
      else findChar(s, c, start + 1)
  }
  
  function parseInteger(s: string): int
  {
      if |s| == 0 then 0
      else if s[0] == '-' then -parsePositiveInteger(s[1..])
      else parsePositiveInteger(s)
  }
  
  function parsePositiveInteger(s: string): int
  {
      if |s| == 0 then 0
      else if |s| == 1 then charToDigit(s[0])
      else parsePositiveInteger(s[0..|s|-1]) * 10 + charToDigit(s[|s|-1])
  }
  
  function charToDigit(c: char): int
  {
      if c == '0' then 0
      else if c == '1' then 1
      else if c == '2' then 2
      else if c == '3' then 3
      else if c == '4' then 4
      else if c == '5' then 5
      else if c == '6' then 6
      else if c == '7' then 7
      else if c == '8' then 8
      else if c == '9' then 9
      else 0
  }

vc-helpers: |-
  // ======= HELPERS =======

vc-spec: |-
  // ======= MAIN METHOD =======
  method solve(input: string) returns (output: string)
      requires |input| > 0
      ensures output == "YES" || output == "NO"
      ensures validInputFormat(input) ==> 
          (var lines := split(input, '\n');
           var firstLine := split(lines[0], ' ');
           var n := parseInteger(firstLine[0]);
           var l := parseInteger(firstLine[1]);
           var xLine := split(lines[1], ' ');
           var yLine := split(lines[2], ' ');
           var x := seq(n, i requires 0 <= i < n && i < |xLine| => parseInteger(xLine[i]));
           var y := seq(n, i requires 0 <= i < n && i < |yLine| => parseInteger(yLine[i]));
           (output == "YES" <==> sameTrackDifferentStart(n, l, x, y)) &&
           (output == "NO" <==> !sameTrackDifferentStart(n, l, x, y)))
      ensures !validInputFormat(input) ==> output == "NO"

vc-code: |-
  {
      var lines := split(input, '\n');
      if |lines| < 3 {
          return "NO";
      }

      var firstLine := split(lines[0], ' ');
      if |firstLine| < 2 {
          return "NO";
      }

      var n := parseInteger(firstLine[0]);
      var l := parseInteger(firstLine[1]);

      if n <= 0 || l <= 0 || n > l {
          return "NO";
      }

      var xLine := split(lines[1], ' ');
      var yLine := split(lines[2], ' ');

      if |xLine| != n || |yLine| != n {
          return "NO";
      }

      var x := seq(n, i requires 0 <= i < n && i < |xLine| => parseInteger(xLine[i]));
      var y := seq(n, i requires 0 <= i < n && i < |yLine| => parseInteger(yLine[i]));

      if sameTrackDifferentStart(n, l, x, y) {
          return "YES";
      } else {
          return "NO";
      }
  }

vc-postamble: |-
