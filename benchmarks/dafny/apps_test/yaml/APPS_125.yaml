vc-description: |-
  This verification task involves determining if a traffic accident is possible at a 4-way intersection. The intersection has 4 road parts numbered counter-clockwise (0,1,2,3), with each part having 4 traffic lights: left turn (l), straight (s), right turn (r), and pedestrian crossing (p). An accident occurs when a pedestrian crossing light is green AND a vehicle lane light is green that allows cars to reach or leave that same pedestrian crossing.

  The implementation should parse the input representing traffic light states and determine if any combination creates a potential accident scenario.

vc-preamble: |-
  // ======= TASK =======
  // Given a 4-way intersection with 4 road parts numbered counter-clockwise (0,1,2,3),
  // determine if a traffic accident is possible. Each road part has 4 traffic lights:
  // left turn (l), straight (s), right turn (r), and pedestrian crossing (p).
  // An accident occurs when a pedestrian crossing light is green AND a vehicle lane
  // light is green that allows cars to reach or leave that same pedestrian crossing.

  // ======= SPEC REQUIREMENTS =======
  predicate validInput(input: string)
  {
      var lines := splitLines(input);
      |lines| == 4 && 
      forall i :: 0 <= i < 4 ==> validLine(lines[i])
  }

  predicate validLine(line: string)
  {
      var numbers := parseNumbers(line);
      |numbers| == 4 && 
      forall i :: 0 <= i < 4 ==> (numbers[i] == 0 || numbers[i] == 1)
  }

  predicate accidentPossible(lanes: seq<seq<int>>)
      requires |lanes| == 4
      requires forall i :: 0 <= i < 4 ==> |lanes[i]| == 4
      requires forall i, j :: 0 <= i < 4 && 0 <= j < 4 ==> (lanes[i][j] == 0 || lanes[i][j] == 1)
  {
      exists partIdx :: 0 <= partIdx < 4 && (
          (lanes[partIdx][3] == 1 && (lanes[partIdx][0] == 1 || lanes[partIdx][1] == 1 || lanes[partIdx][2] == 1)) ||
          (lanes[partIdx][0] == 1 && lanes[(partIdx + 3) % 4][3] == 1) ||
          (lanes[partIdx][1] == 1 && lanes[(partIdx + 2) % 4][3] == 1) ||
          (lanes[partIdx][2] == 1 && lanes[(partIdx + 1) % 4][3] == 1)
      )
  }

vc-helpers: |-
  function splitLines(input: string): seq<string>
  {
      if |input| == 0 then []
      else splitLinesHelper(input, 0, "", [])
  }

  function splitLinesHelper(input: string, i: int, current: string, lines: seq<string>): seq<string>
      requires 0 <= i <= |input|
      decreases |input| - i
  {
      if i == |input| then
          if current != "" then lines + [current] else lines
      else if input[i] == '\n' then
          splitLinesHelper(input, i + 1, "", lines + [current])
      else
          splitLinesHelper(input, i + 1, current + [input[i]], lines)
  }

  function parseNumbers(line: string): seq<int>
  {
      parseNumbersHelper(line, 0, "", [])
  }

  function parseNumbersHelper(line: string, i: int, current: string, numbers: seq<int>): seq<int>
      requires 0 <= i <= |line|
      decreases |line| - i
  {
      if i == |line| then
          if current != "" && |current| > 0 && (forall j :: 0 <= j < |current| ==> '0' <= current[j] <= '9') then 
              numbers + [stringToInt(current)] 
          else numbers
      else if line[i] == ' ' then
          if current != "" && |current| > 0 && (forall j :: 0 <= j < |current| ==> '0' <= current[j] <= '9') then
              parseNumbersHelper(line, i + 1, "", numbers + [stringToInt(current)])
          else
              parseNumbersHelper(line, i + 1, "", numbers)
      else
          parseNumbersHelper(line, i + 1, current + [line[i]], numbers)
  }

  function stringToInt(s: string): int
      requires |s| > 0
      requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  {
      stringToIntHelper(s, 0, 0)
  }

  function stringToIntHelper(s: string, i: int, acc: int): int
      requires 0 <= i <= |s|
      requires forall j :: 0 <= j < |s| ==> '0' <= s[j] <= '9'
      decreases |s| - i
  {
      if i == |s| then acc
      else stringToIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
  }

  function parseInput(input: string): seq<seq<int>>
      requires validInput(input)
      ensures |parseInput(input)| == 4
      ensures forall i :: 0 <= i < 4 ==> |parseInput(input)[i]| == 4
      ensures forall i, j :: 0 <= i < 4 && 0 <= j < 4 ==> (parseInput(input)[i][j] == 0 || parseInput(input)[i][j] == 1)
  {
      var lines := splitLines(input);
      seq(4, i requires 0 <= i < 4 => parseNumbers(lines[i]))
  }

vc-spec: |-
  // ======= MAIN METHOD =======
  method solve(input: string) returns (output: string)
      requires |input| > 0
      requires validInput(input)
      ensures output == "YES" || output == "NO"
      ensures output == "YES" <==> accidentPossible(parseInput(input))

vc-code: |-
  {
      var lanes := parseInput(input);

      for partIdx := 0 to 4
          invariant 0 <= partIdx <= 4
          invariant forall k :: 0 <= k < partIdx ==> (
              !(lanes[k][3] == 1 && (lanes[k][0] == 1 || lanes[k][1] == 1 || lanes[k][2] == 1)) &&
              !(lanes[k][0] == 1 && lanes[(k + 3) % 4][3] == 1) &&
              !(lanes[k][1] == 1 && lanes[(k + 2) % 4][3] == 1) &&
              !(lanes[k][2] == 1 && lanes[(k + 1) % 4][3] == 1)
          )
      {
          if lanes[partIdx][3] == 1 && (lanes[partIdx][0] == 1 || lanes[partIdx][1] == 1 || lanes[partIdx][2] == 1) {
              assert accidentPossible(lanes);
              return "YES";
          }

          if lanes[partIdx][0] == 1 && lanes[(partIdx + 3) % 4][3] == 1 {
              assert accidentPossible(lanes);
              return "YES";
          }

          if lanes[partIdx][1] == 1 && lanes[(partIdx + 2) % 4][3] == 1 {
              assert accidentPossible(lanes);
              return "YES";
          }

          if lanes[partIdx][2] == 1 && lanes[(partIdx + 1) % 4][3] == 1 {
              assert accidentPossible(lanes);
              return "YES";
          }
      }

      assert !accidentPossible(lanes);
      return "NO";
  }

vc-postamble: |-
