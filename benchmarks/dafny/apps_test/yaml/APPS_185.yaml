vc-description: |-
  This verification task involves implementing a solution for Nastya's coin collection problem. Given n manholes with stones on top and coins underneath, Nastya starts at position k and needs to collect all coins with minimum moves. She can throw stones, move to adjacent positions, or collect coins from stone-free manholes.
  
  The implementation should correctly parse the input to extract n (number of manholes) and k (starting position), then calculate the minimum number of moves required using the optimal strategy.

vc-preamble: |-
  // ======= TASK =======
  // Find minimum moves for Nastya to collect all coins from n manholes.
  // Each manhole starts with one stone on top and one coin underneath.
  // Nastya starts at position k and can: throw stones, move adjacent, or collect coins from stone-free manholes.
  // Goal is to collect all n coins with minimum moves.

  // ======= SPEC REQUIREMENTS =======
  predicate validTwoIntegerInput(input: string)
  {
      var parts := splitFunction(input, ' ');
      |parts| >= 2 && 
      validIntegerString(parts[0]) && 
      validIntegerString(parts[1]) &&
      stringToIntFunction(parts[0]) >= 2 &&
      1 <= stringToIntFunction(parts[1]) <= stringToIntFunction(parts[0])
  }

  predicate validIntegerString(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  }

  function min(a: int, b: int): int
  {
      if a <= b then a else b
  }

  function splitFunction(s: string, delimiter: char): seq<string>
      ensures |splitFunction(s, delimiter)| >= 1
  {
      if |s| == 0 then [""]
      else 
          var firstDelim := findFirstDelimiter(s, delimiter, 0);
          if firstDelim == -1 then [s]
          else if firstDelim < |s| then [s[..firstDelim]] + splitFunction(s[firstDelim+1..], delimiter)
          else [s]
  }

  function findFirstDelimiter(s: string, delimiter: char, start: int): int
      requires 0 <= start
      ensures findFirstDelimiter(s, delimiter, start) == -1 || 
              (start <= findFirstDelimiter(s, delimiter, start) < |s|)
      decreases |s| - start
  {
      if start >= |s| then -1
      else if s[start] == delimiter then start
      else findFirstDelimiter(s, delimiter, start + 1)
  }

  function stringToIntFunction(s: string): int
      requires |s| > 0
      requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  {
      stringToIntHelper(s, 0)
  }

  function stringToIntHelper(s: string, acc: int): int
      requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  {
      if |s| == 0 then acc
      else stringToIntHelper(s[1..], acc * 10 + (s[0] as int - '0' as int))
  }

  function intToStringFunction(n: int): string
      requires n >= 0
      ensures |intToStringFunction(n)| > 0
  {
      if n == 0 then "0"
      else intToStringHelper(n, "")
  }

  function intToStringHelper(n: int, acc: string): string
      requires n >= 0
      ensures n == 0 ==> intToStringHelper(n, acc) == acc
      ensures n > 0 ==> |intToStringHelper(n, acc)| > |acc|
  {
      if n == 0 then acc
      else intToStringHelper(n / 10, [('0' as int + (n % 10)) as char] + acc)
  }

  // ======= HELPERS =======
  method split(s: string, delimiter: char) returns (parts: seq<string>)
      ensures |parts| >= 1
      ensures parts == splitFunction(s, delimiter)
  {
      parts := [];
      var current := "";
      var i := 0;

      while i < |s|
          invariant 0 <= i <= |s|
          invariant |parts| >= 0
      {
          if s[i] == delimiter {
              parts := parts + [current];
              current := "";
          } else {
              current := current + [s[i]];
          }
          i := i + 1;
      }

      parts := parts + [current];
      assume parts == splitFunction(s, delimiter);
  }

  method stringToInt(s: string) returns (result: int)
      requires |s| > 0
      requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
      ensures result == stringToIntFunction(s)
  {
      result := 0;
      var i := 0;
      while i < |s|
          invariant 0 <= i <= |s|
          invariant forall j :: 0 <= j < i ==> '0' <= s[j] <= '9'
      {
          result := result * 10 + (s[i] as int - '0' as int);
          i := i + 1;
      }
      assume result == stringToIntFunction(s);
  }

  method intToString(n: int) returns (result: string)
      requires n >= 0
      ensures |result| > 0
      ensures result == intToStringFunction(n)
  {
      if n == 0 {
          result := "0";
          return;
      }

      var digits: seq<char> := [];
      var temp := n;

      while temp > 0
          invariant temp >= 0
          invariant |digits| >= 0
      {
          var digit := temp % 10;
          digits := [('0' as int + digit) as char] + digits;
          temp := temp / 10;
      }

      result := "";
      var i := 0;
      while i < |digits|
          invariant 0 <= i <= |digits|
          invariant |result| == i
      {
          result := result + [digits[i]];
          i := i + 1;
      }
      assume result == intToStringFunction(n) && |result| > 0;
  }

vc-helpers: |-
  // <vc-helpers>
  // </vc-helpers>

vc-spec: |-
  // ======= MAIN METHOD =======
  method solve(input: string) returns (output: string)
      requires |input| > 0
      requires exists i :: 0 <= i < |input| && input[i] == ' '
      requires validTwoIntegerInput(input)
      ensures |output| > 0
      ensures validTwoIntegerInput(input) ==> 
          (var parts := splitFunction(input, ' ');
           var n := stringToIntFunction(parts[0]);
           var k := stringToIntFunction(parts[1]);
           n >= 2 && 1 <= k <= n ==>
              (if k == 1 || k == n then 
                  output == intToStringFunction(3 * n)
              else 
                  output == intToStringFunction(3 * n + min(k - 1, n - k))))

vc-code: |-
  {
      var parts := split(input, ' ');
      if |parts| >= 2 {
          var n := stringToInt(parts[0]);
          var k := stringToInt(parts[1]);

          var result: int;
          if k == 1 || k == n {
              result := 3 * n;
          } else {
              result := 3 * n + min(k - 1, n - k);
          }

          output := intToString(result);
      } else {
          output := "0";
      }
  }

vc-postamble: |-
