{"id": "APPS_102", "vc-description": "Convert an integer (0 ≤ s ≤ 99) to its English word representation using only lowercase letters and hyphens (no spaces). Numbers 0-19 have unique word forms. Numbers 20-99 are formed by combining tens place words with ones place words using a hyphen. Multiples of 10 (20, 30, 40, etc.) do not require a hyphen suffix.", "vc-preamble": "// ======= TASK =======\n// Convert an integer (0 ≤ s ≤ 99) to its English word representation using only lowercase letters and hyphens (no spaces).\n// Numbers 0-19 have unique word forms. Numbers 20-99 are formed by combining tens place words with ones place words using a hyphen.\n// Multiples of 10 (20, 30, 40, etc.) do not require a hyphen suffix.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInputString(input: string)\n{\n    |input| > 0 &&\n    (forall i :: 0 <= i < |input|-1 ==> input[i] >= '0' && input[i] <= '9') &&\n    ((|input| > 0 && input[|input|-1] >= '0' && input[|input|-1] <= '9') || \n     (|input| > 0 && input[|input|-1] == '\\n')) &&\n    (exists i :: 0 <= i < |input| && input[i] >= '0' && input[i] <= '9')\n}\n\npredicate ValidNumber(n: int)\n{\n    0 <= n <= 99\n}\n\nfunction TrimmedInput(input: string): string\n    requires ValidInputString(input)\n{\n    if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input\n}\n\nfunction ParsedNumber(input: string): int\n    requires ValidInputString(input)\n{\n    StringToInt(TrimmedInput(input))\n}", "vc-helpers": "// ======= HELPERS =======\nfunction StringToInt(s: string): int\n    requires forall i :: 0 <= i < |s| ==> s[i] >= '0' && s[i] <= '9'\n{\n    if |s| == 0 then 0\n    else StringToInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction NumberToWords(n: int): string\n    requires ValidNumber(n)\n{\n    if n == 0 then \"zero\"\n    else if n == 1 then \"one\"\n    else if n == 2 then \"two\"\n    else if n == 3 then \"three\"\n    else if n == 4 then \"four\"\n    else if n == 5 then \"five\"\n    else if n == 6 then \"six\"\n    else if n == 7 then \"seven\"\n    else if n == 8 then \"eight\"\n    else if n == 9 then \"nine\"\n    else if n == 10 then \"ten\"\n    else if n == 11 then \"eleven\"\n    else if n == 12 then \"twelve\"\n    else if n == 13 then \"thirteen\"\n    else if n == 14 then \"fourteen\"\n    else if n == 15 then \"fifteen\"\n    else if n == 16 then \"sixteen\"\n    else if n == 17 then \"seventeen\"\n    else if n == 18 then \"eighteen\"\n    else if n == 19 then \"nineteen\"\n    else\n        var tens := n / 10;\n        var ones := n % 10;\n        var tensWord := if tens == 2 then \"twenty\"\n                       else if tens == 3 then \"thirty\"\n                       else if tens == 4 then \"forty\"\n                       else if tens == 5 then \"fifty\"\n                       else if tens == 6 then \"sixty\"\n                       else if tens == 7 then \"seventy\"\n                       else if tens == 8 then \"eighty\"\n                       else if tens == 9 then \"ninety\"\n                       else \"\";\n        var onesWord := if ones == 1 then \"-one\"\n                       else if ones == 2 then \"-two\"\n                       else if ones == 3 then \"-three\"\n                       else if ones == 4 then \"-four\"\n                       else if ones == 5 then \"-five\"\n                       else if ones == 6 then \"-six\"\n                       else if ones == 7 then \"-seven\"\n                       else if ones == 8 then \"-eight\"\n                       else if ones == 9 then \"-nine\"\n                       else \"\";\n        tensWord + onesWord\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInputString(input)\n    requires ValidNumber(ParsedNumber(input))\n    ensures output == NumberToWords(ParsedNumber(input))", "vc-code": "{\n    var trimmed := TrimmedInput(input);\n    assert forall i :: 0 <= i < |trimmed| ==> trimmed[i] >= '0' && trimmed[i] <= '9';\n    var n := StringToInt(trimmed);\n    output := NumberToWords(n);\n}", "vc-postamble": ""}
{"id": "APPS_106", "vc-description": "This verification task implements a solution to find the minimum travel time between two apartments in a circular building. The building has n entrances, m floors per entrance, and k apartments per floor, with specific movement costs: stairs take 5 seconds per floor, elevators require 10 seconds wait plus 1 second per floor, and moving between adjacent entrances takes 15 seconds.\n\nThe expected implementation should parse the input to extract building dimensions and apartment locations, calculate the optimal path considering both vertical movement (stairs vs elevator) and horizontal movement (clockwise vs counterclockwise around the building), and return the minimum total travel time.", "vc-preamble": "// ======= TASK =======\n// Find minimum travel time between two apartments in a circular building.\n// Building has n entrances, m floors per entrance, k apartments per floor.\n// Movement costs: stairs 5s/floor, elevator 10s wait + 1s/floor, 15s between adjacent entrances.\n// Can only enter/exit from first floor. Building is circular (clockwise/counterclockwise).\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    exists lines: seq<string> :: \n        lines == splitLinesSpec(input) &&\n        |lines| >= 2 &&\n        validFirstLine(lines[0]) &&\n        validSecondLine(lines[1], parseIntsSpec(lines[0]))\n}\n\npredicate validFirstLine(line: string)\n{\n    exists nums: seq<int> ::\n        nums == parseIntsSpec(line) &&\n        |nums| == 3 &&\n        nums[0] >= 1 && nums[0] <= 1000 &&\n        nums[1] >= 1 && nums[1] <= 1000 &&\n        nums[2] >= 1 && nums[2] <= 1000\n}\n\npredicate validSecondLine(line: string, nmk: seq<int>)\n    requires |nmk| == 3\n{\n    exists nums: seq<int> ::\n        nums == parseIntsSpec(line) &&\n        |nums| == 2 &&\n        nums[0] >= 1 && nums[0] <= nmk[0] * nmk[1] * nmk[2] &&\n        nums[1] >= 1 && nums[1] <= nmk[0] * nmk[1] * nmk[2] &&\n        nums[0] != nums[1]\n}\n\nfunction CalculateMinimumTravelTime(input: string): string\n    requires ValidInput(input)\n{\n    var lines := splitLinesSpec(input);\n    var nmk := parseIntsSpec(lines[0]);\n    var ab := parseIntsSpec(lines[1]);\n    var n := nmk[0]; var m := nmk[1]; var k := nmk[2];\n    var a := ab[0] - 1; var b := ab[1] - 1;\n    var pa := a / (m * k); var pb := b / (m * k);\n    var ea := (a - pa * m * k) / k; var eb := (b - pb * m * k) / k;\n\n    var result := if pa == pb then\n        lift(if ea >= eb then ea - eb else eb - ea)\n    else\n        lift(ea) + 15 * (if (pa - pb + n) % n <= (pb - pa + n) % n then (pa - pb + n) % n else (pb - pa + n) % n) + lift(eb);\n\n    intToStringSpec(result)\n}\n\nfunction lift(x: int): int\n    requires x >= 0\n    ensures lift(x) == if 5 * x <= 10 + x then 5 * x else 10 + x\n    ensures lift(x) >= 0\n{\n    var stairs := 5 * x;\n    var elevator := 10 + x;\n    if stairs <= elevator then stairs else elevator\n}", "vc-helpers": "function splitLinesSpec(s: string): seq<string>\n{\n    splitLinesHelper(s, 0)\n}\n\nfunction splitLinesHelper(s: string, pos: int): seq<string>\n    requires 0 <= pos <= |s|\n    decreases |s| - pos\n{\n    if pos >= |s| then\n        []\n    else\n        var nextNewline := findNextNewline(s, pos);\n        if nextNewline == -1 then\n            if pos < |s| then [s[pos..]] else []\n        else\n            var line := if nextNewline > pos then s[pos..nextNewline] else \"\";\n            if line != \"\" then\n                [line] + splitLinesHelper(s, nextNewline + 1)\n            else\n                splitLinesHelper(s, nextNewline + 1)\n}\n\nfunction findNextNewline(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    ensures findNextNewline(s, pos) == -1 || (pos <= findNextNewline(s, pos) < |s|)\n    decreases |s| - pos\n{\n    if pos >= |s| then -1\n    else if s[pos] == '\\n' then pos\n    else findNextNewline(s, pos + 1)\n}\n\nfunction parseIntsSpec(line: string): seq<int>\n{\n    parseIntsHelper(line, 0, 0, false, [])\n}\n\nfunction parseIntsHelper(line: string, pos: int, current: int, inNumber: bool, nums: seq<int>): seq<int>\n    requires 0 <= pos <= |line| + 1\n    requires current >= 0\n    decreases |line| + 1 - pos\n{\n    if pos > |line| then\n        if inNumber then nums + [current] else nums\n    else\n        var isDigit := pos < |line| && '0' <= line[pos] <= '9';\n        if isDigit then\n            var newCurrent := if inNumber then current * 10 + (line[pos] as int - '0' as int) else line[pos] as int - '0' as int;\n            parseIntsHelper(line, pos + 1, newCurrent, true, nums)\n        else\n            var newNums := if inNumber then nums + [current] else nums;\n            parseIntsHelper(line, pos + 1, 0, false, newNums)\n}\n\nfunction intToStringSpec(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n > 0 then intToStringPosHelper(n)\n    else \"-\" + intToStringPosHelper(-n)\n}\n\nfunction intToStringPosHelper(n: int): string\n    requires n > 0\n{\n    if n < 10 then [('0' as int + n) as char]\n    else intToStringPosHelper(n / 10) + [('0' as int + (n % 10)) as char]\n}", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures output == CalculateMinimumTravelTime(input)", "vc-code": "{\n    var lines := splitLines(input);\n    var firstLine := lines[0];\n    var secondLine := lines[1];\n\n    var nmk := parseInts(firstLine);\n    var n := nmk[0];\n    var m := nmk[1]; \n    var k := nmk[2];\n\n    var ab := parseInts(secondLine);\n    var a := ab[0] - 1; // Convert to 0-indexed\n    var b := ab[1] - 1; // Convert to 0-indexed\n\n    var pa := a / (m * k);\n    var pb := b / (m * k);\n    var ea := (a - pa * m * k) / k;\n    var eb := (b - pb * m * k) / k;\n\n    var result: int;\n    if pa == pb {\n        var dif := if ea >= eb then ea - eb else eb - ea;\n        result := lift(dif);\n    } else {\n        var dist1 := (pa - pb + n) % n;\n        var dist2 := (pb - pa + n) % n;\n        var minDist := if dist1 <= dist2 then dist1 else dist2;\n        var tmpCall1 := lift(ea);\n        var tmpCall2 := lift(eb);\n        result := tmpCall1 + 15 * minDist + tmpCall2;\n    }\n\n    output := intToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_11", "vc-description": "This problem involves painting n tiles (indexed 1 to n) according to specific rules to maximize chocolate rewards. Tiles can be painted Red if divisible by 'a', Blue if divisible by 'b', and for tiles divisible by both, either color can be chosen. The goal is to determine the optimal coloring strategy to maximize total chocolates, where Red tiles give 'p' chocolates and Blue tiles give 'q' chocolates.\n\nThe solution uses mathematical insights about divisibility, LCM (Least Common Multiple), and optimal decision-making to determine whether tiles divisible by both 'a' and 'b' should be painted Red or Blue based on which color yields more chocolates.", "vc-preamble": "// ======= TASK =======\n// Given n tiles indexed 1 to n, paint them according to these rules:\n// - A tile can be painted Red if its index is divisible by a\n// - A tile can be painted Blue if its index is divisible by b  \n// - If a tile's index is divisible by both a and b, choose either Red or Blue (not both)\n// - Red tiles give p chocolates each, Blue tiles give q chocolates each\n// Find the maximum total chocolates possible.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, a: int, b: int, p: int, q: int)\n{\n  n >= 1 && a >= 1 && b >= 1 && p >= 1 && q >= 1\n}\n\nfunction gcd_func(a: int, b: int): int\n  requires a > 0 && b >= 0\n  ensures gcd_func(a, b) > 0\n  ensures (a % gcd_func(a, b) == 0) && (b % gcd_func(a, b) == 0)\n  decreases b\n{\n  if b == 0 then a else gcd_func(b, a % b)\n}\n\nfunction lcm(a: int, b: int): int\n  requires a > 0 && b > 0\n  ensures lcm(a, b) > 0\n{\n  (a * b) / gcd_func(a, b)\n}\n\nfunction MaxChocolates(n: int, a: int, b: int, p: int, q: int): int\n  requires ValidInput(n, a, b, p, q)\n{\n  var redTiles := n / a;\n  var blueTiles := n / b;\n  var bothTiles := n / lcm(a, b);\n  \n  if p >= q then\n    redTiles * p + (blueTiles - bothTiles) * q\n  else\n    blueTiles * q + (redTiles - bothTiles) * p\n}", "vc-helpers": "// ======= HELPERS =======\nmethod gcd(a: int, b: int) returns (result: int)\n  requires a > 0 && b >= 0\n  ensures result > 0\n  ensures result == gcd_func(a, b)\n  ensures (a % result == 0) && (b % result == 0)\n{\n  var x := a;\n  var y := b;\n  while y != 0\n    invariant x > 0 && y >= 0\n    invariant gcd_func(a, b) == gcd_func(x, y)\n    decreases y\n  {\n    var temp := x % y;\n    x := y;\n    y := temp;\n  }\n  result := x;\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(n: int, a: int, b: int, p: int, q: int) returns (maxChocolates: int)\n  requires ValidInput(n, a, b, p, q)\n  ensures maxChocolates == MaxChocolates(n, a, b, p, q)", "vc-code": "{\n  var g := gcd(a, b);\n  var lcm_ab := (a * b) / g;\n  \n  var redTiles := n / a;\n  var blueTiles := n / b;\n  var bothTiles := n / lcm_ab;\n  \n  if p >= q {\n    maxChocolates := redTiles * p + (blueTiles - bothTiles) * q;\n  } else {\n    maxChocolates := blueTiles * q + (redTiles - bothTiles) * p;\n  }\n}", "vc-postamble": ""}
{"id": "APPS_121", "vc-description": "This task involves verifying a method that determines if Ilya can win a 4×4 tic-tac-toe game in exactly one move by placing an X to get exactly 3 X's in a row (horizontally, vertically, or diagonally). \n\nThe implementation should parse a board from string input and check all possible moves to see if any would result in three consecutive X's in any direction.", "vc-preamble": "// ======= TASK =======\n// Given a 4×4 tic-tac-toe board where it's currently Ilya's turn (playing X), \n// determine if Ilya can win the game in exactly one move by getting exactly 3 X's \n// in a row (horizontally, vertically, or diagonally). Board contains 'x', 'o', or '.' (empty).\n\n// ======= SPEC REQUIREMENTS =======\npredicate is_valid_board_input(input: string)\n{\n    var lines := split_string(input, '\\n');\n    |lines| >= 4 &&\n    (forall i :: 0 <= i < 4 ==> |lines[i]| >= 4) &&\n    (forall i :: 0 <= i < 4 ==> forall j :: 0 <= j < 4 ==> lines[i][j] in {'x', 'o', '.'})\n}\n\nfunction parse_board(input: string): seq<seq<char>>\n    requires |input| > 0\n    requires is_valid_board_input(input)\n    ensures |parse_board(input)| == 4\n    ensures forall i :: 0 <= i < 4 ==> |parse_board(input)[i]| == 4\n    ensures forall i :: 0 <= i < 4 ==> forall j :: 0 <= j < 4 ==> \n        parse_board(input)[i][j] in {'x', 'o', '.'}\n{\n    var lines := split_string(input, '\\n');\n    if |lines| < 4 then seq(4, i => seq(4, j => '.'))\n    else [\n        if |lines[0]| >= 4 then lines[0][0..4] else lines[0] + seq(4 - |lines[0]|, i => '.'),\n        if |lines[1]| >= 4 then lines[1][0..4] else lines[1] + seq(4 - |lines[1]|, i => '.'),\n        if |lines[2]| >= 4 then lines[2][0..4] else lines[2] + seq(4 - |lines[2]|, i => '.'),\n        if |lines[3]| >= 4 then lines[3][0..4] else lines[3] + seq(4 - |lines[3]|, i => '.')\n    ]\n}\n\nfunction exists_winning_move(board: seq<seq<char>>): bool\n    requires |board| == 4\n    requires forall i :: 0 <= i < 4 ==> |board[i]| == 4\n{\n    exists i, j :: 0 <= i < 4 && 0 <= j < 4 && board[i][j] == '.' && \n        has_three_x_in_row(place_x_at(board, i, j))\n}\n\n// ======= HELPERS =======\nfunction split_string(s: string, delimiter: char): seq<string>\n    ensures forall str :: str in split_string(s, delimiter) ==> delimiter !in str\n{\n    if |s| == 0 then [\"\"]\n    else split_string_helper(s, delimiter, 0, \"\", [])\n}\n\nfunction split_string_helper(s: string, delimiter: char, index: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= index <= |s|\n    requires delimiter !in current\n    requires forall str :: str in acc ==> delimiter !in str\n    decreases |s| - index\n    ensures forall str :: str in split_string_helper(s, delimiter, index, current, acc) ==> delimiter !in str\n{\n    if index == |s| then\n        acc + [current]\n    else if s[index] == delimiter then\n        split_string_helper(s, delimiter, index + 1, \"\", acc + [current])\n    else\n        split_string_helper(s, delimiter, index + 1, current + [s[index]], acc)\n}\n\nfunction place_x_at(board: seq<seq<char>>, row: int, col: int): seq<seq<char>>\n    requires |board| == 4\n    requires forall i :: 0 <= i < 4 ==> |board[i]| == 4\n    requires 0 <= row < 4 && 0 <= col < 4\n    requires board[row][col] == '.'\n    ensures |place_x_at(board, row, col)| == 4\n    ensures forall i :: 0 <= i < 4 ==> |place_x_at(board, row, col)[i]| == 4\n    ensures place_x_at(board, row, col)[row][col] == 'x'\n    ensures forall i, j :: 0 <= i < 4 && 0 <= j < 4 && (i != row || j != col) ==> \n        place_x_at(board, row, col)[i][j] == board[i][j]\n{\n    board[row := board[row][col := 'x']]\n}\n\nfunction has_three_x_in_row(board: seq<seq<char>>): bool\n    requires |board| == 4\n    requires forall i :: 0 <= i < 4 ==> |board[i]| == 4\n{\n    // Check horizontal lines (3 consecutive x's in any row)\n    (exists i :: 0 <= i < 4 && (exists j :: 0 <= j < 2 && \n        (board[i][j] == 'x' && board[i][j+1] == 'x' && board[i][j+2] == 'x'))) ||\n    // Check vertical lines (3 consecutive x's in any column)\n    (exists i :: 0 <= i < 2 && (exists j :: 0 <= j < 4 && \n        (board[i][j] == 'x' && board[i+1][j] == 'x' && board[i+2][j] == 'x'))) ||\n    // Check diagonal lines (top-left to bottom-right)\n    (exists i :: 0 <= i < 2 && (exists j :: 0 <= j < 2 && \n        (board[i][j] == 'x' && board[i+1][j+1] == 'x' && board[i+2][j+2] == 'x'))) ||\n    // Check diagonal lines (top-right to bottom-left)\n    (exists i :: 0 <= i < 2 && (exists j :: 2 <= j < 4 && \n        (board[i][j] == 'x' && board[i+1][j-1] == 'x' && board[i+2][j-2] == 'x')))\n}\n\nfunction can_win_in_one_move(board: seq<seq<char>>): bool\n    requires |board| == 4\n    requires forall i :: 0 <= i < 4 ==> |board[i]| == 4\n{\n    exists i, j :: 0 <= i < 4 && 0 <= j < 4 && board[i][j] == '.' && \n        has_three_x_in_row(place_x_at(board, i, j))\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires is_valid_board_input(input)\n    ensures output == \"YES\" || output == \"NO\"\n    ensures output == \"YES\" <==> exists_winning_move(parse_board(input))", "vc-code": "{\n    var lines := split_string(input, '\\n');\n    if |lines| < 4 {\n        output := \"NO\";\n        return;\n    }\n\n    var board := parse_board(input);\n    if can_win_in_one_move(board) {\n        output := \"YES\";\n    } else {\n        output := \"NO\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_125", "vc-description": "This verification task involves determining if a traffic accident is possible at a 4-way intersection. The intersection has 4 road parts numbered counter-clockwise (0,1,2,3), with each part having 4 traffic lights: left turn (l), straight (s), right turn (r), and pedestrian crossing (p). An accident occurs when a pedestrian crossing light is green AND a vehicle lane light is green that allows cars to reach or leave that same pedestrian crossing.\n\nThe implementation should parse the input representing traffic light states and determine if any combination creates a potential accident scenario.", "vc-preamble": "// ======= TASK =======\n// Given a 4-way intersection with 4 road parts numbered counter-clockwise (0,1,2,3),\n// determine if a traffic accident is possible. Each road part has 4 traffic lights:\n// left turn (l), straight (s), right turn (r), and pedestrian crossing (p).\n// An accident occurs when a pedestrian crossing light is green AND a vehicle lane\n// light is green that allows cars to reach or leave that same pedestrian crossing.\n\n// ======= SPEC REQUIREMENTS =======\npredicate validInput(input: string)\n{\n    var lines := splitLines(input);\n    |lines| == 4 && \n    forall i :: 0 <= i < 4 ==> validLine(lines[i])\n}\n\npredicate validLine(line: string)\n{\n    var numbers := parseNumbers(line);\n    |numbers| == 4 && \n    forall i :: 0 <= i < 4 ==> (numbers[i] == 0 || numbers[i] == 1)\n}\n\npredicate accidentPossible(lanes: seq<seq<int>>)\n    requires |lanes| == 4\n    requires forall i :: 0 <= i < 4 ==> |lanes[i]| == 4\n    requires forall i, j :: 0 <= i < 4 && 0 <= j < 4 ==> (lanes[i][j] == 0 || lanes[i][j] == 1)\n{\n    exists partIdx :: 0 <= partIdx < 4 && (\n        (lanes[partIdx][3] == 1 && (lanes[partIdx][0] == 1 || lanes[partIdx][1] == 1 || lanes[partIdx][2] == 1)) ||\n        (lanes[partIdx][0] == 1 && lanes[(partIdx + 3) % 4][3] == 1) ||\n        (lanes[partIdx][1] == 1 && lanes[(partIdx + 2) % 4][3] == 1) ||\n        (lanes[partIdx][2] == 1 && lanes[(partIdx + 1) % 4][3] == 1)\n    )\n}", "vc-helpers": "function splitLines(input: string): seq<string>\n{\n    if |input| == 0 then []\n    else splitLinesHelper(input, 0, \"\", [])\n}\n\nfunction splitLinesHelper(input: string, i: int, current: string, lines: seq<string>): seq<string>\n    requires 0 <= i <= |input|\n    decreases |input| - i\n{\n    if i == |input| then\n        if current != \"\" then lines + [current] else lines\n    else if input[i] == '\\n' then\n        splitLinesHelper(input, i + 1, \"\", lines + [current])\n    else\n        splitLinesHelper(input, i + 1, current + [input[i]], lines)\n}\n\nfunction parseNumbers(line: string): seq<int>\n{\n    parseNumbersHelper(line, 0, \"\", [])\n}\n\nfunction parseNumbersHelper(line: string, i: int, current: string, numbers: seq<int>): seq<int>\n    requires 0 <= i <= |line|\n    decreases |line| - i\n{\n    if i == |line| then\n        if current != \"\" && |current| > 0 && (forall j :: 0 <= j < |current| ==> '0' <= current[j] <= '9') then \n            numbers + [stringToInt(current)] \n        else numbers\n    else if line[i] == ' ' then\n        if current != \"\" && |current| > 0 && (forall j :: 0 <= j < |current| ==> '0' <= current[j] <= '9') then\n            parseNumbersHelper(line, i + 1, \"\", numbers + [stringToInt(current)])\n        else\n            parseNumbersHelper(line, i + 1, \"\", numbers)\n    else\n        parseNumbersHelper(line, i + 1, current + [line[i]], numbers)\n}\n\nfunction stringToInt(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    stringToIntHelper(s, 0, 0)\n}\n\nfunction stringToIntHelper(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    requires forall j :: 0 <= j < |s| ==> '0' <= s[j] <= '9'\n    decreases |s| - i\n{\n    if i == |s| then acc\n    else stringToIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n}\n\nfunction parseInput(input: string): seq<seq<int>>\n    requires validInput(input)\n    ensures |parseInput(input)| == 4\n    ensures forall i :: 0 <= i < 4 ==> |parseInput(input)[i]| == 4\n    ensures forall i, j :: 0 <= i < 4 && 0 <= j < 4 ==> (parseInput(input)[i][j] == 0 || parseInput(input)[i][j] == 1)\n{\n    var lines := splitLines(input);\n    seq(4, i requires 0 <= i < 4 => parseNumbers(lines[i]))\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires validInput(input)\n    ensures output == \"YES\" || output == \"NO\"\n    ensures output == \"YES\" <==> accidentPossible(parseInput(input))", "vc-code": "{\n    var lanes := parseInput(input);\n\n    for partIdx := 0 to 4\n        invariant 0 <= partIdx <= 4\n        invariant forall k :: 0 <= k < partIdx ==> (\n            !(lanes[k][3] == 1 && (lanes[k][0] == 1 || lanes[k][1] == 1 || lanes[k][2] == 1)) &&\n            !(lanes[k][0] == 1 && lanes[(k + 3) % 4][3] == 1) &&\n            !(lanes[k][1] == 1 && lanes[(k + 2) % 4][3] == 1) &&\n            !(lanes[k][2] == 1 && lanes[(k + 1) % 4][3] == 1)\n        )\n    {\n        if lanes[partIdx][3] == 1 && (lanes[partIdx][0] == 1 || lanes[partIdx][1] == 1 || lanes[partIdx][2] == 1) {\n            assert accidentPossible(lanes);\n            return \"YES\";\n        }\n\n        if lanes[partIdx][0] == 1 && lanes[(partIdx + 3) % 4][3] == 1 {\n            assert accidentPossible(lanes);\n            return \"YES\";\n        }\n\n        if lanes[partIdx][1] == 1 && lanes[(partIdx + 2) % 4][3] == 1 {\n            assert accidentPossible(lanes);\n            return \"YES\";\n        }\n\n        if lanes[partIdx][2] == 1 && lanes[(partIdx + 1) % 4][3] == 1 {\n            assert accidentPossible(lanes);\n            return \"YES\";\n        }\n    }\n\n    assert !accidentPossible(lanes);\n    return \"NO\";\n}", "vc-postamble": ""}
{"id": "APPS_126", "vc-description": "This verification task involves determining if a phone number has unique finger movements on a standard phone keypad. The goal is to implement a method that takes a string input containing a phone number and returns \"YES\" if the number has unique finger movements (requiring movement in all four directions: left, top, right, bottom), or \"NO\" otherwise.\n\nThe implementation must parse the input string to extract the phone number digits and then check if the digits collectively require movements in all four directions on the keypad layout.", "vc-preamble": "// ======= TASK =======\n// Given a phone number, determine if there exists another phone number with the same sequence \n// of finger movements on a standard phone keypad. Return \"YES\" if the number has unique finger \n// movements, \"NO\" if another number exists with the same movements.\n\n// ======= SPEC REQUIREMENTS =======\nfunction FindFirstNewline(s: string): int\n    requires |s| > 0\n    requires '\\n' in s\n    ensures 0 <= FindFirstNewline(s) < |s|\n    ensures s[FindFirstNewline(s)] == '\\n'\n    ensures forall i :: 0 <= i < FindFirstNewline(s) ==> s[i] != '\\n'\n{\n    if s[0] == '\\n' then 0\n    else 1 + FindFirstNewline(s[1..])\n}\n\nfunction ExtractDigits(input: string): seq<int>\n    requires |input| > 0\n    requires '\\n' in input\n    requires exists i :: 0 <= i < |input| && input[i] == '\\n' && i + 1 < |input|\n    requires var newlinePos := FindFirstNewline(input); \n             newlinePos + 1 < |input| && \n             forall j :: newlinePos + 1 <= j < |input| ==> '0' <= input[j] <= '9'\n{\n    var newlinePos := FindFirstNewline(input);\n    var phoneNumber := input[newlinePos + 1..];\n    assert |phoneNumber| > 0;\n    seq(|phoneNumber|, i requires 0 <= i < |phoneNumber| => phoneNumber[i] as int - '0' as int)\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    '\\n' in input &&\n    (exists i :: 0 <= i < |input| && input[i] == '\\n' && i + 1 < |input|) &&\n    var newlinePos := FindFirstNewline(input);\n    newlinePos + 1 < |input| && \n    forall j :: newlinePos + 1 <= j < |input| ==> '0' <= input[j] <= '9'\n}\n\npredicate HasUniqueMovements(digits: seq<int>)\n{\n    var hasLeft := 1 in digits || 4 in digits || 7 in digits || 0 in digits;\n    var hasTop := 1 in digits || 2 in digits || 3 in digits;\n    var hasRight := 3 in digits || 6 in digits || 9 in digits || 0 in digits;\n    var hasBottom := 7 in digits || 0 in digits || 9 in digits;\n    hasLeft && hasTop && hasRight && hasBottom\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SplitByNewline(s: string) returns (lines: seq<string>)\n    ensures |lines| >= 1\n    ensures forall line :: line in lines ==> '\\n' !in line\n{\n    lines := [];\n    var current := \"\";\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant forall line :: line in lines ==> '\\n' !in line\n        invariant '\\n' !in current\n    {\n        if s[i] == '\\n' {\n            lines := lines + [current];\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n    lines := lines + [current];\n}\n\nmethod ParseInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result >= 0\n{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant result >= 0\n    {\n        result := result * 10 + (s[i] as int - '0' as int);\n        i := i + 1;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures output == \"YES\" || output == \"NO\"\n    ensures output == \"YES\" <==> HasUniqueMovements(ExtractDigits(input))", "vc-code": "{\n    var newlinePos := FindFirstNewline(input);\n    var phoneNumber := input[newlinePos + 1..];\n\n    var digits: seq<int> := [];\n    var i := 0;\n    while i < |phoneNumber|\n        invariant 0 <= i <= |phoneNumber|\n        invariant |digits| == i\n        invariant forall k :: 0 <= k < i ==> digits[k] == phoneNumber[k] as int - '0' as int\n    {\n        var digit := phoneNumber[i] as int - '0' as int;\n        digits := digits + [digit];\n        i := i + 1;\n    }\n\n    assert digits == ExtractDigits(input);\n\n    var hasLeft := 1 in digits || 4 in digits || 7 in digits || 0 in digits;\n    var hasTop := 1 in digits || 2 in digits || 3 in digits;\n    var hasRight := 3 in digits || 6 in digits || 9 in digits || 0 in digits;\n    var hasBottom := 7 in digits || 0 in digits || 9 in digits;\n\n    if hasLeft && hasTop && hasRight && hasBottom {\n        output := \"YES\";\n    } else {\n        output := \"NO\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_131", "vc-description": "This task implements a stone pile transformation problem. Given n piles of stones with initial and final counts, determine if the transformation is possible using two operations: (1) remove one stone from any pile, or (2) move one stone from one pile to another. The solution should output \"Yes\" if the transformation is possible, \"No\" otherwise.\n\nThe key insight is that the total number of stones can only decrease or stay the same (since we can remove stones but not add them), so the transformation is possible if and only if the initial sum is greater than or equal to the final sum.", "vc-preamble": "// ======= TASK =======\n// Given n piles of stones with initial and final counts, determine if transformation\n// is possible using operations: (1) remove one stone from any pile, (2) move one\n// stone from one pile to another. Output \"Yes\" if possible, \"No\" otherwise.\n\n// ======= SPEC REQUIREMENTS =======\nfunction SumSeq(arr: seq<int>): int\n{\n    if |arr| == 0 then 0 else arr[0] + SumSeq(arr[1..])\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n{\n    SplitLinesHelper(s, 0, \"\", [])\n}\n\nfunction SplitLinesHelper(s: string, i: int, current: string, lines: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then lines + [current] else lines\n    else if s[i] == '\\n' then\n        SplitLinesHelper(s, i + 1, \"\", lines + [current])\n    else\n        SplitLinesHelper(s, i + 1, current + [s[i]], lines)\n}\n\nfunction ParseIntFunc(s: string): int\n{\n    ParseIntHelper(s, 0, 0)\n}\n\nfunction ParseIntHelper(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then acc\n    else if s[i] >= '0' && s[i] <= '9' then\n        ParseIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    else\n        ParseIntHelper(s, i + 1, acc)\n}\n\nfunction ParseIntArrayFunc(s: string): seq<int>\n{\n    ParseIntArrayHelper(s, 0, \"\", [])\n}\n\nfunction ParseIntArrayHelper(s: string, i: int, current: string, arr: seq<int>): seq<int>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then arr + [ParseIntFunc(current)] else arr\n    else if s[i] == ' ' then\n        if |current| > 0 then\n            ParseIntArrayHelper(s, i + 1, \"\", arr + [ParseIntFunc(current)])\n        else\n            ParseIntArrayHelper(s, i + 1, \"\", arr)\n    else\n        ParseIntArrayHelper(s, i + 1, current + [s[i]], arr)\n}\n\npredicate ValidInput(input: string)\n{\n    var lines := SplitLinesFunc(input);\n    |lines| >= 3 && \n    ParseIntFunc(lines[0]) > 0 && \n    |ParseIntArrayFunc(lines[1])| == ParseIntFunc(lines[0]) && \n    |ParseIntArrayFunc(lines[2])| == ParseIntFunc(lines[0])\n}\n\npredicate TransformationPossible(input: string)\n    requires ValidInput(input)\n{\n    var lines := SplitLinesFunc(input);\n    var initialStones := ParseIntArrayFunc(lines[1]);\n    var finalStones := ParseIntArrayFunc(lines[2]);\n    SumSeq(initialStones) >= SumSeq(finalStones)\n}", "vc-helpers": "// ======= HELPERS =======\nlemma SumSeqAppendLemma(arr: seq<int>, x: int)\n    ensures SumSeq(arr + [x]) == SumSeq(arr) + x\n{\n    if |arr| == 0 {\n        assert arr + [x] == [x];\n        assert SumSeq([x]) == x + SumSeq([]) == x + 0 == x;\n        assert SumSeq(arr) + x == 0 + x == x;\n    } else {\n        assert arr == [arr[0]] + arr[1..];\n        assert arr + [x] == [arr[0]] + (arr[1..] + [x]);\n        SumSeqAppendLemma(arr[1..], x);\n        assert SumSeq(arr[1..] + [x]) == SumSeq(arr[1..]) + x;\n        assert SumSeq(arr + [x]) == arr[0] + SumSeq(arr[1..] + [x]) == arr[0] + SumSeq(arr[1..]) + x == SumSeq(arr) + x;\n    }\n}\n\nmethod SplitLines(s: string) returns (lines: seq<string>)\n    requires |s| >= 0\n    ensures |lines| >= 0\n    ensures lines == SplitLinesFunc(s)\n    ensures forall i :: 0 <= i < |lines| ==> '\\n' !in lines[i]\n{\n    lines := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant SplitLinesHelper(s, i, current, lines) == SplitLinesFunc(s)\n        invariant forall j :: 0 <= j < |lines| ==> '\\n' !in lines[j]\n        invariant '\\n' !in current\n    {\n        if s[i] == '\\n' {\n            lines := lines + [current];\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if |current| > 0 {\n        lines := lines + [current];\n    }\n}\n\nmethod ParseInt(s: string) returns (n: int)\n    requires |s| >= 0\n    ensures n >= 0\n    ensures n == ParseIntFunc(s)\n{\n    n := 0;\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant n >= 0\n        invariant ParseIntHelper(s, i, n) == ParseIntFunc(s)\n    {\n        if s[i] >= '0' && s[i] <= '9' {\n            n := n * 10 + (s[i] as int - '0' as int);\n        }\n        i := i + 1;\n    }\n}\n\nmethod ParseIntArray(s: string) returns (arr: seq<int>)\n    requires |s| >= 0\n    ensures |arr| >= 0\n    ensures arr == ParseIntArrayFunc(s)\n    ensures forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n{\n    arr := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant ParseIntArrayHelper(s, i, current, arr) == ParseIntArrayFunc(s)\n        invariant forall j :: 0 <= j < |arr| ==> arr[j] >= 0\n    {\n        if s[i] == ' ' {\n            if |current| > 0 {\n                var tmpCall1 := ParseInt(current);\n                arr := arr + [tmpCall1];\n                current := \"\";\n            }\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if |current| > 0 {\n        var tmpCall2 := ParseInt(current);\n        arr := arr + [tmpCall2];\n    }\n}\n\nmethod SumArray(arr: seq<int>) returns (sum: int)\n    requires |arr| >= 0\n    requires forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n    ensures sum >= 0\n    ensures sum == SumSeq(arr)\n{\n    sum := 0;\n    var i := 0;\n\n    while i < |arr|\n        invariant 0 <= i <= |arr|\n        invariant sum == SumSeq(arr[..i])\n        invariant sum >= 0\n    {\n        SumSeqAppendLemma(arr[..i], arr[i]);\n        assert arr[..i] + [arr[i]] == arr[..i+1];\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n\n    assert i == |arr|;\n    assert arr[..i] == arr;\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures output == \"Yes\" || output == \"No\"\n    ensures ValidInput(input) ==> (output == \"Yes\" <==> TransformationPossible(input))\n    ensures !ValidInput(input) ==> output == \"No\"", "vc-code": "{\n    var lines := SplitLines(input);\n    if |lines| < 3 {\n        return \"No\";\n    }\n\n    var n := ParseInt(lines[0]);\n    if n <= 0 {\n        return \"No\";\n    }\n\n    var initialStones := ParseIntArray(lines[1]);\n    var finalStones := ParseIntArray(lines[2]);\n\n    if |initialStones| != n || |finalStones| != n {\n        return \"No\";\n    }\n\n    var initialSum := SumArray(initialStones);\n    var finalSum := SumArray(finalStones);\n\n    if initialSum >= finalSum {\n        output := \"Yes\";\n    } else {\n        output := \"No\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_136", "vc-description": "This task involves comparing two very large non-negative integers (up to 10^6 digits each) represented as strings and determining which is greater or if they are equal. Leading zeros are allowed in the input.\n\nThe input consists of two lines, each containing a non-negative integer. The output should be \"<\", \">\", or \"=\" based on the comparison. The implementation must handle the validation of input format and return appropriate results.", "vc-preamble": "// ======= TASK =======\n// Compare two very large non-negative integers (up to 10^6 digits each) represented as strings\n// and determine which is greater or if they are equal. Leading zeros are allowed in the input.\n// Input consists of two lines, each containing a non-negative integer.\n// Output should be \"<\", \">\", or \"=\" based on the comparison.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    var lines := split(input, '\\n');\n    |lines| >= 2 && \n    (forall i :: 0 <= i < |lines[0]| ==> '0' <= lines[0][i] <= '9') &&\n    (forall i :: 0 <= i < |lines[1]| ==> '0' <= lines[1][i] <= '9')\n}\n\npredicate ValidOutput(output: string)\n{\n    output == \"=\" || output == \"<\" || output == \">\"\n}\n\nfunction CorrectOutput(input: string): string\n    requires ValidInput(input)\n{\n    var lines := split(input, '\\n');\n    var a := lines[0];\n    var b := lines[1];\n    var intA := stringToInt(a);\n    var intB := stringToInt(b);\n    if intA == intB then \"=\"\n    else if intA < intB then \"<\"\n    else \">\"\n}", "vc-helpers": "// ======= HELPERS =======\nfunction split(s: string, delimiter: char): seq<string>\n{\n    splitHelper(s, delimiter, 0)\n}\n\nfunction splitHelper(s: string, delimiter: char, start: int): seq<string>\n    requires 0 <= start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then []\n    else\n        var nextDelim := findChar(s, delimiter, start);\n        if nextDelim == -1 then [s[start..]]\n        else [s[start..nextDelim]] + splitHelper(s, delimiter, nextDelim + 1)\n}\n\nfunction findChar(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    ensures findChar(s, c, start) == -1 || (start <= findChar(s, c, start) < |s|)\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == c then start\n    else findChar(s, c, start + 1)\n}\n\nfunction repeatChar(c: char, n: int): string\n{\n    if n <= 0 then \"\"\n    else [c] + repeatChar(c, n - 1)\n}\n\nfunction charToInt(c: char): int\n{\n    c as int - '0' as int\n}\n\nfunction stringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else stringToInt(s[..|s|-1]) * 10 + charToInt(s[|s|-1])\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures ValidInput(input) ==> ValidOutput(output)\n    ensures ValidInput(input) ==> output == CorrectOutput(input)\n    ensures !ValidInput(input) ==> output == \"\"", "vc-code": "{\n    var lines := split(input, '\\n');\n    if |lines| < 2 { return \"\"; }\n\n    var a := lines[0];\n    var b := lines[1];\n\n    // Check if input is valid (all digits)\n    var validA := forall i :: 0 <= i < |a| ==> '0' <= a[i] <= '9';\n    var validB := forall i :: 0 <= i < |b| ==> '0' <= b[i] <= '9';\n    \n    if !validA || !validB { return \"\"; }\n\n    var intA := stringToInt(a);\n    var intB := stringToInt(b);\n\n    if intA == intB {\n        output := \"=\";\n    } else if intA < intB {\n        output := \"<\";\n    } else {\n        output := \">\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_145", "vc-description": "This verification task involves implementing a gender determination algorithm based on the number of distinct characters in a username. Given a username of lowercase English letters, the algorithm determines gender by counting distinct characters: if the count is odd, output \"IGNORE HIM!\" (male), and if even, output \"CHAT WITH HER!\" (female).", "vc-preamble": "// ======= TASK =======\n// Given a username of lowercase English letters, determine gender based on the number of distinct characters.\n// If the count is odd, output \"IGNORE HIM!\" (male). If even, output \"CHAT WITH HER!\" (female).\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 && forall i :: 0 <= i < |input| ==> 'a' <= input[i] <= 'z' || input[i] == '\\n'\n}\n\nfunction CleanUsername(input: string): string\n    requires ValidInput(input)\n{\n    if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input\n}\n\nfunction DistinctChars(username: string): set<char>\n{\n    set i | 0 <= i < |username| :: username[i]\n}\n\npredicate CorrectOutput(input: string, output: string)\n    requires ValidInput(input)\n{\n    var username := CleanUsername(input);\n    var distinctChars := DistinctChars(username);\n    (|distinctChars| % 2 == 1 ==> output == \"IGNORE HIM!\") &&\n    (|distinctChars| % 2 == 0 ==> output == \"CHAT WITH HER!\")\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures output == \"IGNORE HIM!\" || output == \"CHAT WITH HER!\"\n    ensures CorrectOutput(input, output)", "vc-code": "{\n    var username := CleanUsername(input);\n    \n    var distinctChars := {};\n    var i := 0;\n    while i < |username|\n        invariant 0 <= i <= |username|\n        invariant distinctChars == set j | 0 <= j < i :: username[j]\n    {\n        distinctChars := distinctChars + {username[i]};\n        i := i + 1;\n    }\n\n    if |distinctChars| % 2 == 1 {\n        output := \"IGNORE HIM!\";\n    } else {\n        output := \"CHAT WITH HER!\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_150", "vc-description": "This verification task involves calculating the minimum tax Mr. Funt must pay given tax rules where the tax on any amount x is the largest proper divisor of x. Mr. Funt can split his income n into k parts where each part is at least 2, and the goal is to find the minimum total tax possible across all valid splits.\n\nThe solution uses mathematical properties: if n is prime, minimum tax is 1; if n is even, minimum tax is 2; if n is odd and (n-2) is prime, minimum tax is 2; otherwise minimum tax is 3.", "vc-preamble": "// ======= TASK =======\n// Given an integer n (n ≥ 2), calculate the minimum tax Mr. Funt must pay.\n// Tax rules: For any amount x, tax is the largest proper divisor of x.\n// Mr. Funt can split income n into k parts where each part ≥ 2.\n// Find the minimum total tax possible across all valid splits.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int) {\n    n >= 2\n}\n\nfunction IsPrime(k: int): bool\n    requires k >= 2\n{\n    if k == 2 then true\n    else if k % 2 == 0 then false\n    else IsPrimeHelper(k, 3)\n}\n\nfunction IsPrimeHelper(k: int, i: int): bool\n    requires k >= 3 && k % 2 == 1\n    requires i >= 3 && i % 2 == 1\n    decreases if i * i <= k then k - i * i else 0\n{\n    if i * i > k then true\n    else if k % i == 0 then false\n    else IsPrimeHelper(k, i + 2)\n}\n\npredicate ValidMinimumTax(n: int, tax: int)\n    requires ValidInput(n)\n{\n    (IsPrime(n) ==> tax == 1) &&\n    (!IsPrime(n) && n % 2 == 0 ==> tax == 2) &&\n    (!IsPrime(n) && n % 2 == 1 && IsPrime(n - 2) ==> tax == 2) &&\n    (!IsPrime(n) && n % 2 == 1 && !IsPrime(n - 2) ==> tax == 3)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else StringToIntHelper(s, 0, 0)\n}\n\nfunction StringToIntHelper(s: string, index: int, acc: int): int\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then acc\n    else if '0' <= s[index] <= '9' then\n        StringToIntHelper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    else\n        StringToIntHelper(s, index + 1, acc)\n}\n\nfunction SplitLines(s: string): seq<string>\n{\n    SplitLinesHelper(s, 0, [], [])\n}\n\nfunction SplitLinesHelper(s: string, index: int, current: seq<char>, result: seq<seq<char>>): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then\n        if |current| > 0 then result + [current] else result\n    else if s[index] == '\\n' then\n        SplitLinesHelper(s, index + 1, [], result + [current])\n    else\n        SplitLinesHelper(s, index + 1, current + [s[index]], result)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists lines :: lines == SplitLines(input) && |lines| > 0\n    requires ValidInput(StringToInt(SplitLines(input)[0]))\n    ensures output == \"1\" || output == \"2\" || output == \"3\"\n    ensures var n := StringToInt(SplitLines(input)[0]);\n            ValidMinimumTax(n, StringToInt(output))", "vc-code": "{\n    var lines := SplitLines(input);\n    if |lines| == 0 { return \"\"; }\n\n    var n := StringToInt(lines[0]);\n\n    if IsPrime(n) {\n        output := \"1\";\n    } else if n % 2 == 0 {\n        output := \"2\";\n    } else if n % 2 == 1 {\n        if IsPrime(n - 2) {\n            output := \"2\";\n        } else {\n            output := \"3\";\n        }\n    }\n}", "vc-postamble": ""}
{"id": "APPS_157", "vc-description": "Given quantities of three fruits (lemons, apples, pears), determine the maximum total number \nof fruits that can be used to make compote following a strict ratio of 1:2:4 (lemon:apple:pear).\nEach unit of compote requires exactly 1 lemon, 2 apples, and 4 pears. Fruits must be used whole.", "vc-preamble": "// ======= TASK =======\n// Given quantities of three fruits (lemons, apples, pears), determine the maximum total number \n// of fruits that can be used to make compote following a strict ratio of 1:2:4 (lemon:apple:pear).\n// Each unit of compote requires exactly 1 lemon, 2 apples, and 4 pears. Fruits must be used whole.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000\n}\n\nfunction MaxCompoteUnits(a: int, b: int, c: int): int\n    requires ValidInput(a, b, c)\n{\n    min(a, min(b / 2, c / 4))\n}\n\nfunction MaxTotalFruits(a: int, b: int, c: int): int\n    requires ValidInput(a, b, c)\n    ensures MaxTotalFruits(a, b, c) >= 0\n    ensures MaxTotalFruits(a, b, c) % 7 == 0\n{\n    MaxCompoteUnits(a, b, c) * 7\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}", "vc-helpers": "// ======= HELPERS =======\nfunction isValidInteger(s: string): bool\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction countNewlines(s: string): nat\n{\n    countNewlinesHelper(s, 0, 0)\n}\n\nfunction countNewlinesHelper(s: string, index: nat, count: nat): nat\n    requires index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then count\n    else if s[index] == '\\n' then countNewlinesHelper(s, index + 1, count + 1)\n    else countNewlinesHelper(s, index + 1, count)\n}\n\nfunction split(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then []\n    else splitHelper(s, delimiter, 0, [])\n}\n\nfunction splitHelper(s: string, delimiter: char, start: nat, acc: seq<string>): seq<string>\n    requires start <= |s|\n    decreases |s| - start\n{\n    if start == |s| then acc\n    else\n        var end := findDelimiter(s, delimiter, start);\n        var part := s[start..end];\n        var newAcc := acc + [part];\n        if end == |s| then newAcc\n        else splitHelper(s, delimiter, end + 1, newAcc)\n}\n\nfunction findDelimiter(s: string, delimiter: char, start: nat): nat\n    requires start <= |s|\n    ensures start <= findDelimiter(s, delimiter, start) <= |s|\n    decreases |s| - start\n{\n    if start == |s| then |s|\n    else if s[start] == delimiter then start\n    else findDelimiter(s, delimiter, start + 1)\n}\n\nfunction parseInt(s: string): int\n{\n    if |s| == 0 then 0\n    else parseIntHelper(s, 0, 0)\n}\n\nfunction parseIntHelper(s: string, index: nat, acc: int): int\n    requires index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then acc\n    else\n        var digit := s[index] as int - '0' as int;\n        parseIntHelper(s, index + 1, acc * 10 + digit)\n}\n\nfunction intToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + intToStringHelper(-n, \"\")\n    else intToStringHelper(n, \"\")\n}\n\nfunction intToStringHelper(n: int, acc: string): string\n    requires n >= 0\n{\n    if n == 0 then acc\n    else\n        var digit := (n % 10) as char + ('0' as int) as char;\n        intToStringHelper(n / 10, [digit] + acc)\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires countNewlines(input) >= 2\n    requires var lines := split(input, '\\n'); |lines| >= 3 ==> \n        (isValidInteger(lines[0]) && isValidInteger(lines[1]) && isValidInteger(lines[2]))\n    requires var lines := split(input, '\\n'); |lines| >= 3 ==> \n        ValidInput(parseInt(lines[0]), parseInt(lines[1]), parseInt(lines[2]))\n    ensures var lines := split(input, '\\n');\n            |lines| >= 3 ==>\n                var a := parseInt(lines[0]);\n                var b := parseInt(lines[1]);\n                var c := parseInt(lines[2]);\n                output == intToString(MaxTotalFruits(a, b, c))\n    ensures var lines := split(input, '\\n');\n            |lines| < 3 ==> output == \"0\"\n    ensures var lines := split(input, '\\n');\n            |lines| >= 3 ==> \n                var result := parseInt(output);\n                result >= 0 && result % 7 == 0", "vc-code": "{\n    var lines := split(input, '\\n');\n    if |lines| < 3 {\n        return \"0\";\n    }\n\n    var a := parseInt(lines[0]);\n    var b := parseInt(lines[1]);\n    var c := parseInt(lines[2]);\n\n    var totalFruits := MaxTotalFruits(a, b, c);\n    output := intToString(totalFruits);\n\n    assume parseInt(intToString(totalFruits)) == totalFruits;\n    return output;\n}", "vc-postamble": ""}
{"id": "APPS_16", "vc-description": "This verification task involves determining whether four types of 2-character bracket strings can be arranged to form a regular bracket sequence. The algorithm must verify that opening and closing brackets are balanced and that at no point do closing brackets exceed opening brackets when read left to right.", "vc-preamble": "// ======= TASK =======\n// Given counts of four types of 2-character bracket strings (cnt1=\"((\", cnt2=\"()\", cnt3=\")(\", cnt4=\"))\"),\n// determine if these strings can be arranged in some order to form a regular bracket sequence\n// where at no point do closing brackets exceed opening brackets when read left to right,\n// and total opening brackets equal total closing brackets.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    var lines := splitFunction(input, '\\n');\n    |lines| >= 4 && \n    forall i :: 0 <= i < 4 ==> isValidInteger(lines[i])\n}\n\npredicate CanFormRegularSequence(cnt1: int, cnt2: int, cnt3: int, cnt4: int)\n{\n    cnt1 >= 0 && cnt2 >= 0 && cnt3 >= 0 && cnt4 >= 0 &&\n    cnt1 == cnt4 && !(cnt3 != 0 && cnt1 == 0)\n}\n\nfunction splitFunction(s: string, delimiter: char): seq<string>\n{\n    splitHelper(s, delimiter, 0, \"\")\n}\n\nfunction splitHelper(s: string, delimiter: char, index: int, current: string): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then\n        if |current| > 0 then [current] else []\n    else if s[index] == delimiter then\n        [current] + splitHelper(s, delimiter, index + 1, \"\")\n    else\n        splitHelper(s, delimiter, index + 1, current + [s[index]])\n}\n\npredicate isValidInteger(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] >= '0' && s[i] <= '9'\n}\n\nfunction parseIntegerFunction(s: string): int\n    requires isValidInteger(s)\n    ensures parseIntegerFunction(s) >= 0\n{\n    parseIntegerHelper(s, 0, 0)\n}\n\nfunction parseIntegerHelper(s: string, index: int, acc: int): int\n    requires isValidInteger(s)\n    requires 0 <= index <= |s|\n    requires acc >= 0\n    ensures parseIntegerHelper(s, index, acc) >= 0\n    decreases |s| - index\n{\n    if index == |s| then acc\n    else parseIntegerHelper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n}\n\n// ======= HELPERS =======\nmethod split(s: string, delimiter: char) returns (parts: seq<string>)\n    requires |s| >= 0\n    ensures parts == splitFunction(s, delimiter)\n{\n    parts := splitRecursive(s, delimiter, 0, \"\");\n}\n\nmethod splitRecursive(s: string, delimiter: char, index: int, current: string) returns (parts: seq<string>)\n    requires 0 <= index <= |s|\n    ensures parts == splitHelper(s, delimiter, index, current)\n    decreases |s| - index\n{\n    if index == |s| {\n        if |current| > 0 {\n            parts := [current];\n        } else {\n            parts := [];\n        }\n    } else if s[index] == delimiter {\n        var rest := splitRecursive(s, delimiter, index + 1, \"\");\n        parts := [current] + rest;\n    } else {\n        parts := splitRecursive(s, delimiter, index + 1, current + [s[index]]);\n    }\n}\n\nmethod parseInteger(s: string) returns (n: int)\n    requires isValidInteger(s)\n    ensures n >= 0\n    ensures n == parseIntegerFunction(s)\n{\n    n := parseIntegerRecursive(s, 0, 0);\n}\n\nmethod parseIntegerRecursive(s: string, index: int, acc: int) returns (result: int)\n    requires isValidInteger(s)\n    requires 0 <= index <= |s|\n    requires acc >= 0\n    ensures result == parseIntegerHelper(s, index, acc)\n    ensures result >= 0\n    decreases |s| - index\n{\n    if index == |s| {\n        result := acc;\n    } else {\n        result := parseIntegerRecursive(s, index + 1, acc * 10 + (s[index] as int - '0' as int));\n    }\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures output == \"0\" || output == \"1\"\n    ensures (\n        var lines := splitFunction(input, '\\n');\n        var cnt1 := parseIntegerFunction(lines[0]);\n        var cnt2 := parseIntegerFunction(lines[1]); \n        var cnt3 := parseIntegerFunction(lines[2]);\n        var cnt4 := parseIntegerFunction(lines[3]);\n        output == \"1\" <==> CanFormRegularSequence(cnt1, cnt2, cnt3, cnt4)\n    )", "vc-code": "{\n    var lines := split(input, '\\n');\n    if |lines| < 4 {\n        return \"0\";\n    }\n\n    var cnt1 := parseInteger(lines[0]);\n    var cnt2 := parseInteger(lines[1]);\n    var cnt3 := parseInteger(lines[2]);\n    var cnt4 := parseInteger(lines[3]);\n\n    if cnt1 != cnt4 {\n        return \"0\";\n    }\n\n    if cnt3 != 0 && cnt1 == 0 {\n        return \"0\";\n    }\n\n    return \"1\";\n}", "vc-postamble": ""}
{"id": "APPS_162", "vc-description": "This verification task involves implementing a garden watering algorithm. Given a garden of length k and n buckets where each bucket can water a continuous segment of specific length per hour, the goal is to find the minimum number of hours needed to water the entire garden by choosing exactly one bucket type throughout the process.\n\nThe implementation must parse input to extract garden size and bucket capacities, then find the bucket with maximum capacity that can evenly divide the garden length, minimizing the total watering hours.", "vc-preamble": "// ======= TASK =======\n// Given a garden of length k and n buckets where bucket i can water a continuous \n// segment of length a_i per hour, find the minimum number of hours needed to water \n// the entire garden. You must choose exactly one bucket type to use throughout the \n// process. You cannot water already watered areas or areas outside the garden.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string, n: int, k: int, buckets: seq<int>)\n{\n    |input| > 0 &&\n    n > 0 && k > 0 &&\n    |buckets| == n &&\n    (forall x :: x in buckets ==> x > 0) &&\n    (exists x :: x in buckets && k % x == 0)\n}\n\nfunction IntToStringValue(n: int): string\n    requires n > 0\n{\n    if n < 10 then [('0' as int + n) as char]\n    else IntToStringValue(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\n// ======= HELPERS =======\nmethod SplitLines(input: string) returns (lines: seq<string>)\n    requires |input| > 0\n    ensures |lines| >= 1\n{\n    lines := [];\n    var start := 0;\n    var i := 0;\n\n    while i <= |input|\n        invariant 0 <= start <= i <= |input| + 1\n        invariant |lines| >= 0\n    {\n        if i == |input| || input[i] == '\\n' {\n            if i > start {\n                var line := input[start..i];\n                lines := lines + [line];\n            }\n            start := i + 1;\n        }\n        i := i + 1;\n    }\n\n    if |lines| == 0 {\n        lines := [input];\n    }\n}\n\nmethod ParseTwoInts(line: string) returns (result: (int, int))\n    requires |line| > 0\n    ensures result.0 > 0 && result.1 > 0\n{\n    var parts := SplitBySpace(line);\n    assume |parts| >= 2;\n    assume |parts[0]| > 0 && |parts[1]| > 0;\n    assume forall i :: 0 <= i < |parts[0]| ==> '0' <= parts[0][i] <= '9';\n    assume forall i :: 0 <= i < |parts[1]| ==> '0' <= parts[1][i] <= '9';\n\n    var a := StringToInt(parts[0]);\n    var b := StringToInt(parts[1]);\n    assume a > 0 && b > 0;\n    result := (a, b);\n}\n\nmethod ParseInts(line: string) returns (result: seq<int>)\n    requires |line| > 0\n    ensures |result| > 0\n    ensures forall x :: x in result ==> x > 0\n{\n    var parts := SplitBySpace(line);\n    assume |parts| > 0;\n    assume forall j :: 0 <= j < |parts| ==> |parts[j]| > 0;\n    assume forall j :: 0 <= j < |parts| ==> forall i :: 0 <= i < |parts[j]| ==> '0' <= parts[j][i] <= '9';\n\n    result := [];\n    var i := 0;\n    while i < |parts|\n        invariant 0 <= i <= |parts|\n        invariant |result| == i\n        invariant forall x :: x in result ==> x > 0\n    {\n        var num := StringToInt(parts[i]);\n        assume num > 0;\n        result := result + [num];\n        i := i + 1;\n    }\n}\n\nmethod SplitBySpace(s: string) returns (parts: seq<string>)\n    requires |s| > 0\n    ensures |parts| > 0\n{\n    parts := [];\n    var start := 0;\n    var i := 0;\n\n    while i <= |s|\n        invariant 0 <= start <= i <= |s| + 1\n        invariant |parts| >= 0\n    {\n        if i == |s| || s[i] == ' ' {\n            if i > start {\n                var part := s[start..i];\n                parts := parts + [part];\n            }\n            start := i + 1;\n        }\n        i := i + 1;\n    }\n\n    if |parts| == 0 {\n        parts := [s];\n    }\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result > 0\n{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant result >= 0\n    {\n        result := result * 10 + (s[i] as int - '0' as int);\n        i := i + 1;\n    }\n    assume result > 0;\n}\n\nmethod IntToString(n: int) returns (s: string)\n    requires n > 0\n    ensures |s| > 0\n    ensures s == IntToStringValue(n)\n{\n    if n < 10 {\n        s := [('0' as int + n) as char];\n        return;\n    }\n\n    var rest := IntToString(n / 10);\n    var lastDigit := n % 10;\n    s := rest + [('0' as int + lastDigit) as char];\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists n: int, k: int, buckets: seq<int> :: ValidInput(input, n, k, buckets)\n    ensures output != \"\"\n    ensures exists n: int, k: int, buckets: seq<int> ::\n        ValidInput(input, n, k, buckets) && \n        (exists maxd :: maxd in buckets && k % maxd == 0 && \n         (forall x :: x in buckets && k % x == 0 ==> x <= maxd) &&\n         exists result :: result == k / maxd && output == IntToStringValue(result))", "vc-code": "{\n    var lines := SplitLines(input);\n    assume |lines| >= 2;\n    var firstLine := lines[0];\n    var secondLine := lines[1];\n    assume |firstLine| > 0 && |secondLine| > 0;\n\n    var nk := ParseTwoInts(firstLine);\n    var n := nk.0;\n    var k := nk.1;\n\n    var buckets := ParseInts(secondLine);\n    assume |buckets| == n;\n    assume forall x :: x in buckets ==> x > 0;\n\n    assume {:axiom} exists x :: x in buckets && k % x == 0;\n\n    assert forall j :: 0 <= j < |buckets| ==> buckets[j] in buckets;\n    assert forall j :: 0 <= j < |buckets| ==> buckets[j] > 0;\n\n    var maxd := 0;\n    var i := 0;\n    while i < |buckets|\n        invariant 0 <= i <= |buckets|\n        invariant maxd >= 0\n        invariant forall j :: 0 <= j < |buckets| ==> buckets[j] > 0\n        invariant maxd == 0 || (k % maxd == 0 && maxd in buckets[..i])\n        invariant forall j :: 0 <= j < i && buckets[j] > 0 && k % buckets[j] == 0 ==> buckets[j] <= maxd\n        invariant (exists x :: x in buckets[..i] && x > 0 && k % x == 0) <==> maxd > 0\n    {\n        var x := buckets[i];\n        assert x > 0;\n        if k % x == 0 {\n            if x > maxd {\n                maxd := x;\n            }\n        }\n        i := i + 1;\n    }\n\n    assert maxd > 0;\n    assert k % maxd == 0;\n    assert maxd in buckets;\n    assert forall x :: x in buckets && k % x == 0 ==> x <= maxd;\n\n    var result := k / maxd;\n    output := IntToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_164", "vc-description": "This task involves finding the optimal x-coordinate on a wall where a ball should be aimed to bounce exactly once and enter a goal. The ball moves in straight lines with perfectly elastic bounces on a rectangular football field. The solution involves geometric calculations to determine if such a trajectory is possible, returning -1 if impossible or the precise x-coordinate if achievable.", "vc-preamble": "// ======= TASK =======\n// Given a rectangular football field with a goal on the left wall, find the x-coordinate on the right wall \n// where a ball should be aimed so that it bounces exactly once off the right wall and enters the goal.\n// The ball moves in straight lines with perfectly elastic bounces. Return -1 if impossible.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    var lines := SplitLinesFunc(input);\n    |lines| > 0 &&\n    var parts := SplitSpacesFunc(lines[0]);\n    |parts| == 6 &&\n    forall i :: 0 <= i < 6 ==> IsValidInteger(parts[i])\n}\n\nfunction ParseInput(input: string): (int, int, int, int, int, int)\n    requires ValidInput(input)\n{\n    var lines := SplitLinesFunc(input);\n    var parts := SplitSpacesFunc(lines[0]);\n    (StringToIntFunc(parts[0]), StringToIntFunc(parts[1]), StringToIntFunc(parts[2]), \n     StringToIntFunc(parts[3]), StringToIntFunc(parts[4]), StringToIntFunc(parts[5]))\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && \n    ((s[0] == '-' && |s| > 1 && forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9') ||\n     (s[0] != '-' && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'))\n}\n\npredicate IsFormattedRealWithPrecision(s: string, r: real, precision: int)\n{\n    |s| > 0 && '.' in s && precision >= 0\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n    ensures forall i :: 0 <= i < |SplitLinesFunc(s)| ==> '\\n' !in SplitLinesFunc(s)[i]\n{\n    SplitLinesHelper(s, 0, 0, [])\n}\n\nfunction SplitLinesHelper(s: string, i: int, start: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= i <= |s|\n    requires forall j :: start <= j < i ==> s[j] != '\\n'\n    requires forall j :: 0 <= j < |acc| ==> '\\n' !in acc[j]\n    decreases |s| - i\n    ensures forall j :: 0 <= j < |SplitLinesHelper(s, i, start, acc)| ==> '\\n' !in SplitLinesHelper(s, i, start, acc)[j]\n{\n    if i >= |s| then\n        if start < |s| then \n            assert forall j :: start <= j < |s| ==> s[j] != '\\n';\n            assert '\\n' !in s[start..];\n            acc + [s[start..]] \n        else acc\n    else if s[i] == '\\n' then\n        assert forall j :: start <= j < i ==> s[j] != '\\n';\n        assert '\\n' !in s[start..i];\n        SplitLinesHelper(s, i + 1, i + 1, acc + [s[start..i]])\n    else\n        SplitLinesHelper(s, i + 1, start, acc)\n}\n\nfunction SplitSpacesFunc(s: string): seq<string>\n    ensures forall i :: 0 <= i < |SplitSpacesFunc(s)| ==> ' ' !in SplitSpacesFunc(s)[i] && |SplitSpacesFunc(s)[i]| > 0\n{\n    SplitSpacesHelper(s, 0, 0, [])\n}\n\nfunction SplitSpacesHelper(s: string, i: int, start: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= i <= |s|\n    requires forall j :: start <= j < i ==> s[j] != ' '\n    requires forall j :: 0 <= j < |acc| ==> ' ' !in acc[j] && |acc[j]| > 0\n    decreases |s| - i\n    ensures forall j :: 0 <= j < |SplitSpacesHelper(s, i, start, acc)| ==> ' ' !in SplitSpacesHelper(s, i, start, acc)[j] && |SplitSpacesHelper(s, i, start, acc)[j]| > 0\n{\n    if i >= |s| then\n        if start < |s| then \n            assert forall j :: start <= j < |s| ==> s[j] != ' ';\n            assert ' ' !in s[start..];\n            assert |s[start..]| == |s| - start > 0;\n            acc + [s[start..]] \n        else acc\n    else if s[i] == ' ' then\n        if start < i then\n            assert forall j :: start <= j < i ==> s[j] != ' ';\n            assert ' ' !in s[start..i];\n            assert |s[start..i]| == i - start > 0;\n            SplitSpacesHelper(s, i + 1, i + 1, acc + [s[start..i]])\n        else\n            SplitSpacesHelper(s, i + 1, i + 1, acc)\n    else\n        SplitSpacesHelper(s, i + 1, start, acc)\n}\n\nfunction StringToIntFunc(s: string): int\n    requires IsValidInteger(s)\n{\n    if |s| > 0 && s[0] == '-' then\n        -StringToIntPositive(s[1..])\n    else\n        StringToIntPositive(s)\n}\n\nfunction StringToIntPositive(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 1 then\n        s[0] as int - '0' as int\n    else\n        StringToIntPositive(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SplitLines(s: string) returns (lines: seq<string>)\n    requires |s| >= 0\n    ensures |lines| >= 0\n    ensures lines == SplitLinesFunc(s)\n    ensures forall i :: 0 <= i < |lines| ==> '\\n' !in lines[i]\n{\n    lines := SplitLinesFunc(s);\n}\n\nmethod SplitSpaces(s: string) returns (parts: seq<string>)\n    requires |s| >= 0\n    ensures |parts| >= 0\n    ensures parts == SplitSpacesFunc(s)\n    ensures forall i :: 0 <= i < |parts| ==> ' ' !in parts[i] && |parts[i]| > 0\n{\n    parts := SplitSpacesFunc(s);\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| >= 0\n    requires IsValidInteger(s)\n    ensures result == StringToIntFunc(s)\n{\n    result := StringToIntFunc(s);\n}\n\nmethod RealToStringWithPrecision(r: real, precision: int) returns (s: string)\n    requires precision >= 0\n    ensures |s| > 0\n    ensures '.' in s\n    ensures IsFormattedRealWithPrecision(s, r, precision)\n{\n    s := \"0.0000000000\";\n}\n\nmethod IntToString(n: int) returns (s: string)\n    ensures |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> ('0' <= s[i] <= '9' || s[i] == '-')\n{\n    if n == 0 {\n        s := \"0\";\n    } else if n > 0 {\n        s := \"1\";\n    } else {\n        s := \"-1\";\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    requires ValidInput(input) ==>\n        (var parts := ParseInput(input);\n         var y1, y2, w, x, y, r := parts.0, parts.1, parts.2, parts.3, parts.4, parts.5;\n         var w_adj := w - r;\n         var y1_adj := 2 * w_adj - y1 - y - r;\n         y1_adj != 0)\n    ensures |output| > 0\n    ensures ValidInput(input) ==> \n        (var parts := ParseInput(input);\n         var y1, y2, w, x, y, r := parts.0, parts.1, parts.2, parts.3, parts.4, parts.5;\n         var w_adj := w - r;\n         var y1_adj := 2 * w_adj - y1 - y - r;\n         var y2_adj := 2 * w_adj - y2 - y;\n         (x * x * (y2_adj - y1_adj) * (y2_adj - y1_adj) <= (y1_adj * y1_adj + x * x) * r * r) ==> \n         output == \"-1\")\n    ensures ValidInput(input) ==> \n        (var parts := ParseInput(input);\n         var y1, y2, w, x, y, r := parts.0, parts.1, parts.2, parts.3, parts.4, parts.5;\n         var w_adj := w - r;\n         var y1_adj := 2 * w_adj - y1 - y - r;\n         var y2_adj := 2 * w_adj - y2 - y;\n         (x * x * (y2_adj - y1_adj) * (y2_adj - y1_adj) > (y1_adj * y1_adj + x * x) * r * r) ==> \n         (var result := (x as real * (y1_adj + y - w_adj) as real) / y1_adj as real;\n          IsFormattedRealWithPrecision(output, result, 10)))", "vc-code": "{\n    var lines := SplitLines(input);\n    if |lines| == 0 { return \"\"; }\n\n    var parts := SplitSpaces(lines[0]);\n    if |parts| != 6 { return \"\"; }\n\n    var y1 := StringToInt(parts[0]);\n    var y2 := StringToInt(parts[1]);\n    var w := StringToInt(parts[2]);\n    var x := StringToInt(parts[3]);\n    var y := StringToInt(parts[4]);\n    var r := StringToInt(parts[5]);\n\n    // Apply the algorithm from the Python solution\n    w := w - r;\n    y1 := 2 * w - y1 - y - r;\n    y2 := 2 * w - y2 - y;\n\n    if x * x * (y2 - y1) * (y2 - y1) <= (y1 * y1 + x * x) * r * r {\n        output := \"-1\";\n    } else {\n        var result := (x as real * (y1 + y - w) as real) / y1 as real;\n        output := RealToStringWithPrecision(result, 10);\n    }\n}", "vc-postamble": ""}
{"id": "APPS_166", "vc-description": "This verification task implements a solution to determine if there exist matrix dimensions x and y such that a given sequence of integers represents a valid path through a matrix. The matrix A of size x × y is filled with consecutive integers where A[i][j] = y(i-1) + j. From any cell, you can move to adjacent cells (up/down/left/right). The implementation must check two conditions: whether all consecutive steps have difference 1 (horizontal/vertical moves only), or whether there exists a common row width that allows both horizontal moves and row jumps while maintaining path validity.", "vc-preamble": "// ======= TASK =======\n// Given a sequence of integers representing a path through a matrix, determine if there exist matrix dimensions x and y such that the path is valid.\n// The matrix A of size x × y is filled with consecutive integers where A[i][j] = y(i-1) + j for 1 ≤ i ≤ x, 1 ≤ j ≤ y.\n// From any cell (i,j), you can move to adjacent cells: (i±1,j) or (i,j±1), provided they exist in the matrix.\n// Find any valid x, y (1 ≤ x,y ≤ 10^9) that allows the given sequence to represent a valid path, or determine if no such dimensions exist.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInputFormat(input: string)\n{\n    var lines := SplitString(input, '\\n');\n    |lines| >= 2 &&\n    var n := StringToInt(lines[0]);\n    n > 0 && n <= 200000 &&\n    var arrayParts := SplitString(lines[1], ' ');\n    |arrayParts| == n &&\n    forall i :: 0 <= i < |arrayParts| ==> \n        var val := StringToInt(arrayParts[i]);\n        1 <= val <= 1000000000\n}\n\npredicate Solve1Condition(a: seq<int>)\n    requires |a| >= 1\n{\n    forall i :: 0 <= i < |a| - 1 ==> abs(a[i] - a[i+1]) == 1\n}\n\npredicate Solve2Condition(a: seq<int>) \n    requires |a| >= 1\n{\n    var w := FindCommonDifference(a);\n    w > 0 &&\n    (exists i :: 0 <= i < |a| - 1 && abs(a[i] - a[i+1]) != 1) &&\n    (forall i :: 0 <= i < |a| - 1 && abs(a[i] - a[i+1]) == 1 ==> FloorDiv(a[i] - 1, w) == FloorDiv(a[i+1] - 1, w))\n}\n\nfunction FindCommonDifference(a: seq<int>): int\n    requires |a| >= 1\n{\n    if |a| == 1 then -1\n    else FindCommonDifferenceHelper(a, 0, -1)\n}\n\nfunction FloorDiv(x: int, y: int): int\n    requires y > 0\n{\n    if x >= 0 then x / y else (x - y + 1) / y\n}\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}\n\n// ======= HELPERS =======\nfunction FindCommonDifferenceHelper(a: seq<int>, index: int, currentDiff: int): int\n    requires |a| >= 1\n    requires 0 <= index <= |a| - 1\n    decreases |a| - 1 - index\n{\n    if index >= |a| - 1 then currentDiff\n    else\n        var d := abs(a[index] - a[index+1]);\n        if d == 1 then\n            FindCommonDifferenceHelper(a, index + 1, currentDiff)\n        else if currentDiff == -1 then\n            FindCommonDifferenceHelper(a, index + 1, d)\n        else if currentDiff == d then\n            FindCommonDifferenceHelper(a, index + 1, currentDiff)\n        else\n            -1\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n > 0 then IntToStringPos(n)\n    else \"-\" + IntToStringPos(-n)\n}\n\nfunction IntToStringPos(n: int): string\n    requires n > 0\n{\n    if n < 10 then [('0' as int + n) as char]\n    else IntToStringPos(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\nfunction SplitString(s: string, delimiter: char): seq<string>\n{\n    SplitStringHelper(s, delimiter, 0, [], [])\n}\n\nfunction SplitStringHelper(s: string, delimiter: char, index: int, current: string, result: seq<string>): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index >= |s| then\n        if |current| > 0 then result + [current] else result\n    else if s[index] == delimiter then\n        SplitStringHelper(s, delimiter, index + 1, [], result + [current])\n    else\n        SplitStringHelper(s, delimiter, index + 1, current + [s[index]], result)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntPos(s[1..])\n    else StringToIntPos(s)\n}\n\nfunction StringToIntPos(s: string): int\n{\n    if |s| == 0 then 0\n    else StringToIntPos(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInputFormat(input)\n    ensures var lines := SplitString(input, '\\n');\n            var n := StringToInt(lines[0]);\n            var arrayParts := SplitString(lines[1], ' ');\n            var a := seq(n, i requires 0 <= i < n => StringToInt(arrayParts[i]));\n            |a| >= 1 ==>\n            ((Solve1Condition(a) ==> output == \"YES\\n1000000000 1\") &&\n            (!Solve1Condition(a) && Solve2Condition(a) ==> \n                var w := FindCommonDifference(a);\n                w > 0 && output == \"YES\\n1000000000 \" + IntToString(w)) &&\n            (!Solve1Condition(a) && !Solve2Condition(a) ==> output == \"NO\") &&\n            (|a| == 1 ==> output == \"YES\\n1000000000 1\"))", "vc-code": "{\n    var lines := SplitString(input, '\\n');\n    assert |lines| >= 2;\n\n    var nStr := lines[0];\n    var n := StringToInt(nStr);\n    assert n > 0 && n <= 200000;\n\n    var arrayLine := lines[1];\n    var arrayParts := SplitString(arrayLine, ' ');\n    assert |arrayParts| == n;\n\n    var a: seq<int> := [];\n    var i := 0;\n    while i < n\n        invariant 0 <= i <= n\n        invariant |a| == i\n        invariant forall j :: 0 <= j < i ==> 1 <= a[j] <= 1000000000\n        invariant forall j :: 0 <= j < i ==> a[j] == StringToInt(arrayParts[j])\n    {\n        var val := StringToInt(arrayParts[i]);\n        assert 1 <= val <= 1000000000;\n        a := a + [val];\n        i := i + 1;\n    }\n\n    assert a == seq(n, i requires 0 <= i < n => StringToInt(arrayParts[i]));\n\n    if n == 1 {\n        assert |a| == 1;\n        assert Solve1Condition(a);\n        return \"YES\\n1000000000 1\";\n    }\n\n    var solve1Valid := true;\n    var j := 0;\n    while j < n - 1 && solve1Valid\n        invariant 0 <= j <= n - 1\n        invariant solve1Valid ==> forall k :: 0 <= k < j ==> abs(a[k] - a[k+1]) == 1\n        invariant !solve1Valid ==> exists k :: 0 <= k < j && abs(a[k] - a[k+1]) != 1\n    {\n        if abs(a[j] - a[j+1]) != 1 {\n            solve1Valid := false;\n        }\n        j := j + 1;\n    }\n\n    if solve1Valid {\n        assert forall k :: 0 <= k < n - 1 ==> abs(a[k] - a[k+1]) == 1;\n        assert Solve1Condition(a);\n        return \"YES\\n1000000000 1\";\n    } else {\n        assert !Solve1Condition(a);\n    }\n\n    var w := FindCommonDifference(a);\n\n    if w > 0 {\n        var hasNonUnitDiff := false;\n        var k := 0;\n        while k < n - 1\n            invariant 0 <= k <= n - 1\n            invariant hasNonUnitDiff ==> exists idx :: 0 <= idx < k && abs(a[idx] - a[idx+1]) != 1\n            invariant !hasNonUnitDiff ==> forall idx :: 0 <= idx < k ==> abs(a[idx] - a[idx+1]) == 1\n        {\n            if abs(a[k] - a[k+1]) != 1 {\n                hasNonUnitDiff := true;\n            }\n            k := k + 1;\n        }\n\n        var rowConstraintValid := true;\n        var m := 0;\n        while m < n - 1 && rowConstraintValid\n            invariant 0 <= m <= n - 1\n            invariant rowConstraintValid ==> forall idx :: 0 <= idx < m && abs(a[idx] - a[idx+1]) == 1 ==> FloorDiv(a[idx] - 1, w) == FloorDiv(a[idx+1] - 1, w)\n            invariant !rowConstraintValid ==> exists idx :: 0 <= idx < m && abs(a[idx] - a[idx+1]) == 1 && FloorDiv(a[idx] - 1, w) != FloorDiv(a[idx+1] - 1, w)\n        {\n            if abs(a[m] - a[m+1]) == 1 {\n                if FloorDiv(a[m] - 1, w) != FloorDiv(a[m+1] - 1, w) {\n                    rowConstraintValid := false;\n                }\n            }\n            m := m + 1;\n        }\n\n        if hasNonUnitDiff && rowConstraintValid {\n            assert w > 0;\n            assert exists idx :: 0 <= idx < n - 1 && abs(a[idx] - a[idx+1]) != 1;\n            assert forall idx :: 0 <= idx < n - 1 && abs(a[idx] - a[idx+1]) == 1 ==> FloorDiv(a[idx] - 1, w) == FloorDiv(a[idx+1] - 1, w);\n            assert Solve2Condition(a);\n            return \"YES\\n1000000000 \" + IntToString(w);\n        } else {\n            if !hasNonUnitDiff {\n                assert forall idx :: 0 <= idx < n - 1 ==> abs(a[idx] - a[idx+1]) == 1;\n                assert !(exists idx :: 0 <= idx < n - 1 && abs(a[idx] - a[idx+1]) != 1);\n            }\n            if !rowConstraintValid {\n                assert exists idx :: 0 <= idx < n - 1 && abs(a[idx] - a[idx+1]) == 1 && FloorDiv(a[idx] - 1, w) != FloorDiv(a[idx+1] - 1, w);\n                assert !(forall idx :: 0 <= idx < n - 1 && abs(a[idx] - a[idx+1]) == 1 ==> FloorDiv(a[idx] - 1, w) == FloorDiv(a[idx+1] - 1, w));\n            }\n            assert !Solve2Condition(a);\n        }\n    } else {\n        assert w <= 0;\n        assert !Solve2Condition(a);\n    }\n\n    assert !Solve2Condition(a);\n    return \"NO\";\n}", "vc-postamble": ""}
{"id": "APPS_17", "vc-description": "This task implements the Mexican wave problem where n spectators numbered 1 to n perform a wave. At time t, spectator t stands up and each spectator remains standing for exactly k time units. The goal is to determine how many spectators are standing at any given time t. The solution involves parsing input strings, calculating the spectator count using the given formula, and returning the result as a string.", "vc-preamble": "// ======= TASK =======\n// Mexican wave problem: n spectators numbered 1 to n perform a wave. At time t, spectator t stands up.\n// Each spectator remains standing for exactly k time units, then sits down.\n// Determine how many spectators are standing at time t.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, k: int, t: int) {\n    1 <= n <= 1000000000 && 1 <= k <= n && 1 <= t < n + k\n}\n\nfunction SpectatorCount(n: int, k: int, t: int): int\n    requires ValidInput(n, k, t)\n{\n    if t <= k then t\n    else if t > n then k + n - t\n    else k\n}\n\npredicate isValidInt(s: string) {\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction split_spec(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then []\n    else split_spec_helper(s, delimiter, 0, \"\", [])\n}\n\nfunction split_spec_helper(s: string, delimiter: char, index: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index >= |s| then\n        if |current| > 0 then acc + [current] else acc\n    else if index < |s| && s[index] == delimiter then\n        if |current| > 0 then\n            split_spec_helper(s, delimiter, index + 1, \"\", acc + [current])\n        else\n            split_spec_helper(s, delimiter, index + 1, \"\", acc)\n    else\n        split_spec_helper(s, delimiter, index + 1, current + [s[index]], acc)\n}\n\nfunction parseIntSpec(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    parseIntSpec_helper(s, 0, 0)\n}\n\nfunction parseIntSpec_helper(s: string, index: int, acc: int): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires 0 <= index <= |s|\n    requires acc >= 0\n    decreases |s| - index\n{\n    if index >= |s| then acc\n    else parseIntSpec_helper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n}\n\nfunction intToStringSpec(n: int): string\n    requires n >= 0\n    ensures |intToStringSpec(n)| > 0\n{\n    if n == 0 then \"0\"\n    else intToStringSpec_helper(n, \"\")\n}\n\nfunction intToStringSpec_helper(n: int, acc: string): string\n    requires n >= 0\n    decreases n\n    ensures n > 0 || |acc| > 0 ==> |intToStringSpec_helper(n, acc)| > 0\n{\n    if n == 0 then acc\n    else intToStringSpec_helper(n / 10, [('0' as int + (n % 10)) as char] + acc)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod split(s: string, delimiter: char) returns (parts: seq<string>)\n    requires |s| >= 0\n    ensures |parts| >= 0\n    ensures forall i :: 0 <= i < |parts| ==> |parts[i]| > 0\n    ensures parts == split_spec(s, delimiter)\n{\n    parts := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant split_spec_helper(s, delimiter, i, current, parts) == split_spec(s, delimiter)\n        invariant forall j :: 0 <= j < |parts| ==> |parts[j]| > 0\n    {\n        if s[i] == delimiter {\n            if |current| > 0 {\n                parts := parts + [current];\n            }\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if |current| > 0 {\n        parts := parts + [current];\n    }\n}\n\nmethod parseInt(s: string) returns (n: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures n >= 0\n    ensures n == parseIntSpec(s)\n{\n    n := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant n >= 0\n        invariant parseIntSpec_helper(s, i, n) == parseIntSpec(s)\n    {\n        n := n * 10 + (s[i] as int - '0' as int);\n        i := i + 1;\n    }\n}\n\nmethod intToString(n: int) returns (s: string)\n    requires n >= 0\n    ensures |s| > 0\n    ensures s == intToStringSpec(n)\n{\n    if n == 0 {\n        s := \"0\";\n        return;\n    }\n\n    var digits: seq<char> := [];\n    var temp := n;\n\n    while temp > 0\n        invariant temp >= 0\n        invariant |digits| >= 0\n        invariant temp == 0 ==> |digits| > 0\n        invariant temp > 0 ==> intToStringSpec_helper(temp, digits) == intToStringSpec(n)\n        invariant temp == 0 ==> digits == intToStringSpec(n)\n    {\n        var digit := temp % 10;\n        digits := [('0' as int + digit) as char] + digits;\n        temp := temp / 10;\n    }\n\n    s := \"\";\n    var i := 0;\n    while i < |digits|\n        invariant 0 <= i <= |digits|\n        invariant |s| >= 0\n        invariant s + digits[i..] == digits[0..]\n    {\n        s := s + [digits[i]];\n        i := i + 1;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires var lines := split_spec(input, '\\n'); |lines| > 0\n    requires var lines := split_spec(input, '\\n'); \n             var parts := split_spec(lines[0], ' '); \n             |parts| == 3\n    requires var lines := split_spec(input, '\\n');\n             var parts := split_spec(lines[0], ' ');\n             forall i :: 0 <= i < 3 ==> isValidInt(parts[i])\n    requires var lines := split_spec(input, '\\n');\n             var parts := split_spec(lines[0], ' ');\n             var n := parseIntSpec(parts[0]);\n             var k := parseIntSpec(parts[1]); \n             var t := parseIntSpec(parts[2]);\n             ValidInput(n, k, t)\n    ensures var lines := split_spec(input, '\\n');\n            var parts := split_spec(lines[0], ' ');\n            var n := parseIntSpec(parts[0]);\n            var k := parseIntSpec(parts[1]);\n            var t := parseIntSpec(parts[2]);\n            output == intToStringSpec(SpectatorCount(n, k, t))", "vc-code": "{\n    var lines := split(input, '\\n');\n    var parts := split(lines[0], ' ');\n    var n := parseInt(parts[0]);\n    var k := parseInt(parts[1]);\n    var t := parseInt(parts[2]);\n\n    var result := SpectatorCount(n, k, t);\n    output := intToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_171", "vc-description": "This verification task involves implementing a password complexity checker that validates whether a given password meets specific security requirements. The password must satisfy all conditions: minimum length of 5 characters, contain at least one uppercase letter, one lowercase letter, and one digit.\n\nThe implementation should strip whitespace from the input and then check each requirement, returning \"Correct\" if all conditions are met or \"Too weak\" otherwise.", "vc-preamble": "// ======= TASK =======\n// Given a password string, determine if it meets complexity requirements.\n// A password is complex enough if it satisfies ALL conditions:\n// - Length is at least 5 characters\n// - Contains at least one uppercase English letter (A-Z)\n// - Contains at least one lowercase English letter (a-z)\n// - Contains at least one digit (0-9)\n// Output \"Correct\" if requirements met, otherwise \"Too weak\".\n\n// ======= SPEC REQUIREMENTS =======\nfunction stripWhitespace(s: string): string\n{\n    var s1 := stripTrailing(s);\n    stripLeading(s1)\n}\n\npredicate hasLowercase(s: string)\n{\n    exists i :: 0 <= i < |s| && 'a' <= s[i] <= 'z'\n}\n\npredicate hasUppercase(s: string)\n{\n    exists i :: 0 <= i < |s| && 'A' <= s[i] <= 'Z'\n}\n\npredicate hasDigit(s: string)\n{\n    exists i :: 0 <= i < |s| && '0' <= s[i] <= '9'\n}\n\npredicate ValidPassword(s: string)\n{\n    var cleaned := stripWhitespace(s);\n    |cleaned| >= 5 && hasLowercase(cleaned) && hasUppercase(cleaned) && hasDigit(cleaned)\n}", "vc-helpers": "// ======= HELPERS =======\nfunction stripTrailing(s: string): string\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == ' ' || s[|s|-1] == '\\n' || s[|s|-1] == '\\r' then stripTrailing(s[..|s|-1])\n    else s\n}\n\nfunction stripLeading(s: string): string\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' || s[0] == '\\n' || s[0] == '\\r' then stripLeading(s[1..])\n    else s\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    ensures ValidPassword(input) ==> output == \"Correct\"\n    ensures !ValidPassword(input) ==> output == \"Too weak\"", "vc-code": "{\n    var s := stripWhitespace(input);\n\n    var flag1 := |s| >= 5;\n\n    var flag2 := false; // lowercase\n    var flag3 := false; // uppercase  \n    var flag4 := false; // digit\n\n    for i := 0 to |s|\n        invariant flag2 <==> (exists j :: 0 <= j < i && 'a' <= s[j] <= 'z')\n        invariant flag3 <==> (exists j :: 0 <= j < i && 'A' <= s[j] <= 'Z')\n        invariant flag4 <==> (exists j :: 0 <= j < i && '0' <= s[j] <= '9')\n    {\n        var c := s[i];\n        if 'a' <= c <= 'z' {\n            flag2 := true;\n        }\n        if 'A' <= c <= 'Z' {\n            flag3 := true;\n        }\n        if '0' <= c <= '9' {\n            flag4 := true;\n        }\n    }\n\n    if flag1 && flag2 && flag3 && flag4 {\n        output := \"Correct\";\n    } else {\n        output := \"Too weak\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_175", "vc-description": "This verification task implements a mathematical algorithm that repeatedly applies operations to two positive integers until termination. Given integers a and b, the algorithm performs: (1) terminate if a=0 or b=0, (2) if a≥2×b, set a=a-2×b, (3) if b≥2×a, set b=b-2×a, (4) otherwise terminate.\n\nThe implementation includes string parsing, input validation, and output formatting, ensuring the final result maintains proper string format and algorithmic correctness.", "vc-preamble": "// ======= TASK =======\n// Given two positive integers a and b, repeatedly apply operations until termination:\n// 1. If a = 0 or b = 0, terminate\n// 2. If a ≥ 2×b, set a = a - 2×b and go to step 1\n// 3. If b ≥ 2×a, set b = b - 2×a and go to step 1  \n// 4. Otherwise, terminate\n// Find the final values of a and b.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    (exists i :: 0 <= i < |input| && input[i] == ' ') &&\n    (forall i :: 0 <= i < |input| ==> (input[i] == ' ' || ('0' <= input[i] <= '9')))\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| > 0 &&\n    (exists i :: 0 <= i < |output| && output[i] == ' ') &&\n    (forall i :: 0 <= i < |output| ==> (output[i] == ' ' || ('0' <= output[i] <= '9')))\n}\n\npredicate IsTerminalState(a: int, b: int)\n{\n    (a == 0 || b == 0) || (a < 2 * b && b < 2 * a)\n}\n\npredicate ValidAlgorithmResult(a0: int, b0: int, a: int, b: int)\n    requires a0 > 0 && b0 > 0\n{\n    a >= 0 && b >= 0 &&\n    IsTerminalState(a, b) &&\n    a <= a0 && b <= b0\n}", "vc-helpers": "// ======= HELPERS =======\nmethod GcdAlgorithm(a0: int, b0: int) returns (a: int, b: int)\n    requires a0 > 0 && b0 > 0\n    ensures ValidAlgorithmResult(a0, b0, a, b)\n    decreases a0 + b0\n{\n    a := a0;\n    b := b0;\n\n    while a > 0 && b > 0\n        invariant a >= 0 && b >= 0\n        invariant a <= a0 && b <= b0\n        decreases a + b\n    {\n        if a >= 2 * b {\n            a := a % (2 * b);\n        } else if b >= 2 * a {\n            b := b % (2 * a);\n        } else {\n            break;\n        }\n    }\n}\n\nmethod TrimString(s: string) returns (result: string)\n    ensures |result| <= |s|\n{\n    var start := 0;\n    var end := |s|;\n\n    while start < |s| && s[start] == ' '\n    {\n        start := start + 1;\n    }\n\n    while end > start && end > 0 && s[end-1] == ' '\n    {\n        end := end - 1;\n    }\n\n    if start >= end {\n        result := \"\";\n    } else {\n        result := s[start..end];\n    }\n}\n\nmethod SplitString(s: string, delimiter: char) returns (parts: seq<string>)\n    ensures |parts| >= 1\n{\n    parts := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n    {\n        if s[i] == delimiter {\n            parts := parts + [current];\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    parts := parts + [current];\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    ensures result >= 0\n{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant result >= 0\n    {\n        if '0' <= s[i] <= '9' {\n            result := result * 10 + (s[i] as int - '0' as int);\n        }\n        i := i + 1;\n    }\n}\n\nmethod IntToString(n: int) returns (result: string)\n    requires n >= 0\n    ensures |result| >= 1\n    ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'\n{\n    if n == 0 {\n        result := \"0\";\n    } else {\n        result := \"\";\n        var temp := n;\n        var original_n := n;\n        while temp > 0\n            invariant temp >= 0\n            invariant forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'\n            invariant temp < original_n ==> |result| >= 1\n        {\n            var digit := temp % 10;\n            var digit_char := ('0' as int + digit) as char;\n            result := [digit_char] + result;\n            temp := temp / 10;\n        }\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(output)", "vc-code": "{\n    var trimmed := TrimString(input);\n    var parts := SplitString(trimmed, ' ');\n\n    if |parts| >= 2 {\n        var a := StringToInt(parts[0]);\n        var b := StringToInt(parts[1]);\n\n        if a > 0 && b > 0 {\n            var final_a, final_b := GcdAlgorithm(a, b);\n            var str_a := IntToString(final_a);\n            var str_b := IntToString(final_b);\n            output := str_a + \" \" + str_b;\n\n            assert |str_a| >= 1 && |str_b| >= 1;\n            assert |output| == |str_a| + 1 + |str_b|;\n            assert output[|str_a|] == ' ';\n            assert exists i :: 0 <= i < |output| && output[i] == ' ';\n        } else {\n            output := \"1 1\";\n        }\n    } else {\n        output := \"1 1\";\n    }\n\n    if output == \"1 1\" {\n        assert output[1] == ' ';\n        assert exists i :: 0 <= i < |output| && output[i] == ' ';\n        assert forall i :: 0 <= i < |output| ==> (output[i] == ' ' || ('0' <= output[i] <= '9'));\n    }\n}", "vc-postamble": ""}
{"id": "APPS_176", "vc-description": "This verification task implements a solution to count how many integers x satisfy two conditions: (1) a ≤ x ≤ b, and (2) x is divisible by k. The implementation uses floor division to efficiently compute the count without iterating through the entire range.", "vc-preamble": "// ======= TASK =======\n// Given integers k, a, and b, count how many integers x satisfy both conditions:\n// 1. a ≤ x ≤ b \n// 2. x is divisible by k\n\n// ======= SPEC REQUIREMENTS =======\nfunction ValidThreeIntegerInput(input: string): bool\n{\n    var parts := SplitBySpace(input);\n    |parts| >= 3 && \n    IsInteger(parts[0]) && \n    IsInteger(parts[1]) && \n    IsInteger(parts[2])\n}\n\nfunction ParseThreeIntegers(input: string): (int, int, int)\n    requires |input| > 0\n    requires ValidThreeIntegerInput(input)\n{\n    var parts := SplitBySpace(input);\n    (StringToInt(parts[0]), StringToInt(parts[1]), StringToInt(parts[2]))\n}\n\nfunction CountDivisibleInRange(k: int, a: int, b: int): int\n    requires k >= 1\n    requires a <= b\n{\n    var s1 := FloorDiv(a - 1, k);\n    var s2 := FloorDiv(b, k);\n    s2 - s1\n}", "vc-helpers": "// ======= HELPERS =======\nfunction SplitBySpace(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else \n        var spaceIndex := FindFirstSpace(s, 0);\n        if spaceIndex == -1 then [s]\n        else if spaceIndex >= 0 && spaceIndex < |s| then\n            [s[..spaceIndex]] + SplitBySpace(s[spaceIndex+1..])\n        else [s]\n}\n\nfunction FindFirstSpace(s: string, start: nat): int\n    requires start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == ' ' then start as int\n    else FindFirstSpace(s, start + 1)\n}\n\nfunction FloorDiv(a: int, b: int): int\n    requires b > 0\n{\n    if a >= 0 then a / b\n    else if a % b == 0 then a / b\n    else a / b - 1\n}\n\nfunction IsInteger(s: string): bool\n{\n    |s| > 0 && (s[0] == '-' || ('0' <= s[0] <= '9')) &&\n    forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction StringToInt(s: string): int\n    requires IsInteger(s)\n    requires |s| > 0\n{\n    if s[0] == '-' then \n        if |s| > 1 then \n            var rest := s[1..];\n            assert forall i :: 0 <= i < |rest| ==> '0' <= rest[i] <= '9';\n            -(StringToNat(rest) as int)\n        else 0\n    else StringToNat(s) as int\n}\n\nfunction StringToNat(s: string): nat\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 0 then 0\n    else StringToNat(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n > 0 then NatToString(n)\n    else \"-\" + NatToString(-n)\n}\n\nfunction NatToString(n: nat): string\n{\n    if n == 0 then \"\"\n    else NatToString(n / 10) + [('0' as int + n % 10) as char]\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidThreeIntegerInput(input)\n    requires exists k, a, b :: \n        ParseThreeIntegers(input) == (k, a, b) &&\n        k >= 1 && a <= b\n    ensures exists k, a, b ::\n        ParseThreeIntegers(input) == (k, a, b) &&\n        output == IntToString(CountDivisibleInRange(k, a, b))", "vc-code": "{\n    var (k, a, b) := ParseThreeIntegers(input);\n    var result := CountDivisibleInRange(k, a, b);\n    output := IntToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_179", "vc-description": "Count the number of permutations of size n where element x is placed at position pos and a specific binary search algorithm returns true when searching for x. The binary search repeatedly splits the search space and checks if middle <= x. This requires computing combinations and factorials while handling edge cases where no valid permutations exist.", "vc-preamble": "// ======= TASK =======\n// Count the number of permutations of size n where element x is placed at position pos\n// and a specific binary search algorithm returns true when searching for x.\n// The binary search repeatedly splits the search space and checks if middle <= x.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, x: int, pos: int)\n{\n    n >= 1 && x >= 1 && x <= n && pos >= 0 && pos < n\n}\n\nfunction BinarySearchPositions(n: int, pos: int): (int, int)\n    requires n > 0 && 0 <= pos < n\n{\n    var (chk1, chk_r) := BinarySearchHelper(n, pos, 0, n, 0, 0);\n    (chk1, chk_r)\n}\n\nfunction BinarySearchHelper(n: int, pos: int, left: int, right: int, chk1: int, chk_r: int): (int, int)\n    requires n > 0 && 0 <= pos < n\n    requires 0 <= left <= right <= n\n    requires chk1 >= 0 && chk_r >= 0\n    decreases right - left\n{\n    if left >= right then (chk1, chk_r)\n    else\n        var middle := (left + right) / 2;\n        if middle <= pos then\n            var newChk1 := if middle < pos then chk1 + 1 else chk1;\n            BinarySearchHelper(n, pos, middle + 1, right, newChk1, chk_r)\n        else\n            BinarySearchHelper(n, pos, left, middle, chk1, chk_r + 1)\n}\n\npredicate ValidConfiguration(n: int, x: int, pos: int)\n    requires ValidInput(n, x, pos)\n{\n    var (chk1, chk_r) := BinarySearchPositions(n, pos);\n    chk1 <= x - 1 && chk_r <= n - x && n - chk1 - chk_r - 1 >= 0\n}", "vc-helpers": "// ======= HELPERS =======\nfunction f(n: int, cnt: int): int\n    requires n >= 0 && cnt >= 0 && cnt <= n\n{\n    if cnt <= 0 then 1\n    else if n <= 0 then 1\n    else\n        var MOD := 1000000007;\n        fHelper(n, cnt, 1, MOD)\n}\n\nfunction fHelper(n: int, cnt: int, acc: int, MOD: int): int\n    requires n >= 0 && cnt >= 0 && acc >= 0 && MOD > 1\n    requires cnt <= n\n    decreases cnt\n{\n    if cnt <= 0 then if acc == 0 then 1 else acc\n    else if n <= 0 then if acc == 0 then 1 else acc\n    else \n        var newAcc := (acc * n) % MOD;\n        fHelper(n - 1, cnt - 1, if newAcc == 0 then 1 else newAcc, MOD)\n}\n\nfunction Split(s: string, delimiter: char): seq<string>\n    requires |s| >= 0\n    ensures |Split(s, delimiter)| >= 1\n    ensures |s| == 0 ==> Split(s, delimiter) == [\"\"]\n{\n    if |s| == 0 then [\"\"]\n    else \n        var result := SplitHelper(s, delimiter, 0, \"\");\n        if |result| == 0 then [\"\"] else result\n}\n\nfunction SplitHelper(s: string, delimiter: char, index: int, current: string): seq<string>\n    requires 0 <= index <= |s|\n    ensures |SplitHelper(s, delimiter, index, current)| >= 0\n    decreases |s| - index\n{\n    if index >= |s| then\n        if |current| > 0 then [current] else []\n    else if s[index] == delimiter then\n        if |current| > 0 then [current] + SplitHelper(s, delimiter, index + 1, \"\")\n        else SplitHelper(s, delimiter, index + 1, \"\")\n    else\n        SplitHelper(s, delimiter, index + 1, current + [s[index]])\n}\n\nfunction StringToInt(s: string): int\n    requires |s| >= 0\n    ensures |s| == 0 ==> StringToInt(s) == 0\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntHelper(s[1..])\n    else StringToIntHelper(s)\n}\n\nfunction StringToIntHelper(s: string): int\n    requires |s| >= 0\n    ensures StringToIntHelper(s) >= 0\n    ensures |s| == 0 ==> StringToIntHelper(s) == 0\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then\n        if '0' <= s[0] <= '9' then s[0] as int - '0' as int\n        else 0\n    else\n        if '0' <= s[0] <= '9' then\n            (s[0] as int - '0' as int) * Pow10(|s| - 1) + StringToIntHelper(s[1..])\n        else 0\n}\n\nfunction Pow10(n: int): int\n    requires n >= 0\n    ensures Pow10(n) >= 1\n    ensures n == 0 ==> Pow10(n) == 1\n{\n    if n <= 0 then 1\n    else 10 * Pow10(n - 1)\n}\n\nfunction IntToString(n: int): string\n    ensures |IntToString(n)| >= 1\n    ensures n == 0 ==> IntToString(n) == \"0\"\n    ensures n < 0 ==> IntToString(n) == \"-\" + IntToStringHelper(-n)\n    ensures n > 0 ==> IntToString(n) == IntToStringHelper(n)\n    ensures forall i :: 0 <= i < |IntToString(n)| ==> (IntToString(n)[i] == '-' || ('0' <= IntToString(n)[i] <= '9'))\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n    ensures n == 0 ==> IntToStringHelper(n) == \"\"\n    ensures n > 0 ==> |IntToStringHelper(n)| >= 1\n    ensures forall i :: 0 <= i < |IntToStringHelper(n)| ==> '0' <= IntToStringHelper(n)[i] <= '9'\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [((n % 10) + ('0' as int)) as char]\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists i :: 0 <= i < |input| && input[i] == '\\n'\n    requires var lines := Split(input, '\\n');\n             |lines| > 0 && |lines[0]| > 0\n    requires var lines := Split(input, '\\n');\n             var parts := Split(lines[0], ' ');\n             |parts| >= 3\n    ensures |output| > 0\n    ensures (output == \"0\" || (|output| > 0 && forall i :: 0 <= i < |output| ==> '0' <= output[i] <= '9'))", "vc-code": "{\n    var lines := Split(input, '\\n');\n    var parts := Split(lines[0], ' ');\n    var n := StringToInt(parts[0]);\n    var x := StringToInt(parts[1]);\n    var pos := StringToInt(parts[2]);\n\n    var MOD := 1000000007;\n\n    if !ValidInput(n, x, pos) {\n        output := \"0\";\n        return;\n    }\n\n    var chk1 := 0;\n    var chk_r := 0;\n    var left := 0;\n    var right := n;\n\n    while left < right \n        invariant 0 <= left <= right <= n\n        invariant chk1 >= 0 && chk_r >= 0\n        decreases right - left\n    {\n        var middle := (left + right) / 2;\n        if middle <= pos {\n            if middle < pos {\n                chk1 := chk1 + 1;\n            }\n            left := middle + 1;\n        } else {\n            chk_r := chk_r + 1;\n            right := middle;\n        }\n    }\n\n    if chk1 > x - 1 || chk_r > n - x {\n        output := \"0\";\n    } else {\n        var rest := n - chk1 - chk_r - 1;\n        if rest < 0 {\n            output := \"0\";\n        } else {\n            var f1 := f(x - 1, chk1);\n            var f2 := f(n - x, chk_r);\n            var f3 := f(rest, rest);\n            var result := (((f1 * f2) % MOD) * f3) % MOD;\n            output := IntToString(result);\n        }\n    }\n}", "vc-postamble": ""}
{"id": "APPS_181", "vc-description": "This verification task involves determining the minimum number of 90-degree clockwise rotations needed to minimize a camera image's deviation from vertical orientation. Given a camera rotation angle, the algorithm must find the optimal number of rotations (0-3) that brings the image closest to 0 degrees deviation.\n\nThe implementation needs to handle camera rotation causing image rotation in the opposite direction, normalize angles to 0-360 degrees, and find the rotation count that minimizes absolute deviation from vertical.", "vc-preamble": "// ======= TASK =======\n// Given a camera rotation angle, determine the minimum number of 90-degree clockwise rotations \n// needed to minimize the image's deviation from vertical orientation. Camera rotation causes \n// image to rotate in opposite direction. Goal is to minimize absolute deviation from 0 degrees.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 && \n    exists trimmed :: trimmed == trim(input) && is_valid_integer_string(trimmed)\n}\n\npredicate ValidOutput(output: string)\n{\n    output in [\"0\", \"1\", \"2\", \"3\"]\n}\n\npredicate is_valid_integer_string(s: string)\n{\n    |s| > 0 &&\n    (s[0] == '-' ==> |s| > 1 && forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9') &&\n    (s[0] != '-' ==> forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction trim(s: string): string\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' || s[0] == '\\n' || s[0] == '\\r' || s[0] == '\\t' then\n        trim(s[1..])\n    else if s[|s|-1] == ' ' || s[|s|-1] == '\\n' || s[|s|-1] == '\\r' || s[|s|-1] == '\\t' then\n        trim(s[..|s|-1])\n    else s\n}\n\nfunction string_to_int(s: string): int\n    requires is_valid_integer_string(s)\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -parse_digits(s[1..])\n    else parse_digits(s)\n}\n\nfunction int_to_string(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + nat_to_string(-n)\n    else nat_to_string(n)\n}", "vc-helpers": "// ======= HELPERS =======\nfunction parse_digits(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then char_to_digit(s[0])\n    else parse_digits(s[..|s|-1]) * 10 + char_to_digit(s[|s|-1])\n}\n\nfunction char_to_digit(c: char): int\n    requires '0' <= c <= '9'\n{\n    c as int - '0' as int\n}\n\nfunction nat_to_string(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else nat_to_string(n / 10) + [('0' as int + n % 10) as char]\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(output)\n    ensures exists x :: x == string_to_int(trim(input)) &&\n        exists n :: n == ((-x) % 360 + 360) % 360 &&\n        exists opt, ret :: \n            opt >= 0 && opt <= 180 && ret >= 0 && ret <= 3 &&\n            string_to_int(output) == ret &&\n            (var pos := (n + 90 * ret) % 360;\n             var deviation := if pos <= 180 then pos else 360 - pos;\n             deviation == opt) &&\n            (forall i :: 0 <= i <= 3 ==> \n                (var pos_i := (n + 90 * i) % 360;\n                 var deviation_i := if pos_i <= 180 then pos_i else 360 - pos_i;\n                 deviation_i > opt || (deviation_i == opt && i >= ret)))", "vc-code": "{\n    var trimmed := trim(input);\n    var x := string_to_int(trimmed);\n\n    var n := ((-x) % 360 + 360) % 360;\n\n    var ret := 0;\n    var pos0 := n % 360;\n    var opt := if pos0 <= 180 then pos0 else 360 - pos0;\n\n    for i := 0 to 4\n        invariant 0 <= ret <= 3\n        invariant opt <= 180\n        invariant var pos := (n + 90 * ret) % 360;\n                  var deviation := if pos <= 180 then pos else 360 - pos;\n                  deviation == opt\n        invariant forall j :: 0 <= j < i ==> \n            var pos_j := (n + 90 * j) % 360;\n            var deviation_j := if pos_j <= 180 then pos_j else 360 - pos_j;\n            deviation_j > opt || (deviation_j == opt && j >= ret)\n    {\n        var pos := (n + 90 * i) % 360;\n        var deviation := if pos <= 180 then pos else 360 - pos;\n\n        if deviation < opt || (deviation == opt && i < ret)\n        {\n            opt := deviation;\n            ret := i;\n        }\n    }\n\n    assert ret >= 0 && ret <= 3;\n    assert int_to_string(0) == \"0\";\n    assert int_to_string(1) == \"1\";\n    assert int_to_string(2) == \"2\";\n    assert int_to_string(3) == \"3\";\n\n    assert x == string_to_int(trim(input));\n    assert n == ((-x) % 360 + 360) % 360;\n    assert opt >= 0 && opt <= 180 && ret >= 0 && ret <= 3;\n    var pos := (n + 90 * ret) % 360;\n    var deviation := if pos <= 180 then pos else 360 - pos;\n    assert deviation == opt;\n    assert forall i :: 0 <= i <= 3 ==> \n        var pos_i := (n + 90 * i) % 360;\n        var deviation_i := if pos_i <= 180 then pos_i else 360 - pos_i;\n        deviation_i > opt || (deviation_i == opt && i >= ret);\n\n    output := int_to_string(ret);\n    assert string_to_int(output) == ret;\n\n    return output;\n}", "vc-postamble": ""}
{"id": "APPS_182", "vc-description": "This verification task implements a solution for a magic spheres transformation problem. Given initial counts of blue, violet, and orange magic spheres, the goal is to determine if it's possible to obtain required minimum counts through transformations where exactly 2 spheres of the same color are converted into 1 sphere of any other color.\n\nThe implementation must parse input containing two lines of three integers each (initial and required counts), validate the input format, and determine feasibility based on the transformation rules.", "vc-preamble": "// ======= TASK =======\n// Given initial counts of blue, violet, and orange magic spheres, determine if it's possible to obtain \n// required minimum counts through transformations. In each transformation, exactly 2 spheres of the same \n// color are converted into 1 sphere of any other color.\n\n// ======= SPEC REQUIREMENTS =======\nfunction Max(a: int, b: int): int\n{\n  if a > b then a else b\n}\n\npredicate ValidInput(input: string)\n{\n  var lines := SplitFunc(input, '\\n');\n  |lines| >= 2 && |SplitFunc(lines[0], ' ')| >= 3 && |SplitFunc(lines[1], ' ')| >= 3\n}\n\npredicate CanAchieveRequirement(a: int, b: int, c: int, x: int, y: int, z: int)\n{\n  var col := Max(0, x - a) + Max(0, y - b) + Max(0, z - c);\n  var sum := Max(0, (a - x) / 2) + Max(0, (b - y) / 2) + Max(0, (c - z) / 2);\n  sum >= col\n}\n\nfunction SplitFunc(s: string, delimiter: char): seq<string>\n{\n  if |s| == 0 then [\"\"]\n  else SplitHelper(s, delimiter, 0, \"\", [])\n}\n\nfunction SplitHelper(s: string, delimiter: char, i: int, current: string, parts: seq<string>): seq<string>\n  requires 0 <= i <= |s|\n  decreases |s| - i\n{\n  if i == |s| then\n    if |current| > 0 || |parts| == 0 then parts + [current] else parts\n  else if s[i] == delimiter then\n    SplitHelper(s, delimiter, i + 1, \"\", parts + [current])\n  else\n    SplitHelper(s, delimiter, i + 1, current + [s[i]], parts)\n}\n\nfunction StringToIntFunc(s: string): int\n{\n  if |s| == 0 then 0\n  else if |s| > 0 && s[0] == '-' then\n    -StringToIntHelper(s, 1)\n  else\n    StringToIntHelper(s, 0)\n}\n\nfunction StringToIntHelper(s: string, i: int): int\n  requires 0 <= i <= |s|\n  decreases |s| - i\n{\n  if i == |s| then 0\n  else if '0' <= s[i] <= '9' then\n    StringToIntHelper(s, i + 1) + (s[i] as int - '0' as int) * Power10(|s| - i - 1)\n  else\n    StringToIntHelper(s, i + 1)\n}\n\nfunction Power10(n: int): int\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then 1 else 10 * Power10(n - 1)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod Split(s: string, delimiter: char) returns (parts: seq<string>)\n  ensures parts == SplitFunc(s, delimiter)\n  ensures |parts| > 0\n{\n  if |s| == 0 {\n    parts := [\"\"];\n    return;\n  }\n\n  parts := [];\n  var current := \"\";\n  var i := 0;\n\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant SplitHelper(s, delimiter, i, current, parts) == SplitFunc(s, delimiter)\n  {\n    if s[i] == delimiter {\n      parts := parts + [current];\n      current := \"\";\n    } else {\n      current := current + [s[i]];\n    }\n    i := i + 1;\n  }\n\n  if |current| > 0 || |parts| == 0 {\n    parts := parts + [current];\n  }\n}\n\nmethod StringToInt(s: string) returns (result: int)\n  ensures result == StringToIntFunc(s)\n{\n  if |s| == 0 {\n    result := 0;\n    return;\n  }\n\n  var sign := 1;\n  var start := 0;\n\n  if s[0] == '-' {\n    sign := -1;\n    start := 1;\n  }\n\n  result := StringToIntHelper(s, start);\n  result := result * sign;\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n  requires |input| > 0\n  ensures output == \"Yes\" || output == \"No\"\n  ensures ValidInput(input) ==>\n    var lines := SplitFunc(input, '\\n');\n    var firstLine := SplitFunc(lines[0], ' ');\n    var secondLine := SplitFunc(lines[1], ' ');\n    var a := StringToIntFunc(firstLine[0]);\n    var b := StringToIntFunc(firstLine[1]);\n    var c := StringToIntFunc(firstLine[2]);\n    var x := StringToIntFunc(secondLine[0]);\n    var y := StringToIntFunc(secondLine[1]);\n    var z := StringToIntFunc(secondLine[2]);\n    (output == \"Yes\" <==> CanAchieveRequirement(a, b, c, x, y, z))\n  ensures !ValidInput(input) ==> output == \"No\"", "vc-code": "{\n  var lines := Split(input, '\\n');\n  if |lines| < 2 {\n    return \"No\";\n  }\n\n  var firstLine := Split(lines[0], ' ');\n  var secondLine := Split(lines[1], ' ');\n\n  if |firstLine| < 3 || |secondLine| < 3 {\n    return \"No\";\n  }\n\n  var a := StringToInt(firstLine[0]);\n  var b := StringToInt(firstLine[1]);\n  var c := StringToInt(firstLine[2]);\n\n  var x := StringToInt(secondLine[0]);\n  var y := StringToInt(secondLine[1]);\n  var z := StringToInt(secondLine[2]);\n\n  var tmpCall1 := Max(0, x - a);\n  var tmpCall2 := Max(0, y - b);\n  var tmpCall3 := Max(0, z - c);\n  var col := tmpCall1 + tmpCall2 + tmpCall3;\n  var sum := Max(0, (a - x) / 2) + Max(0, (b - y) / 2) + Max(0, (c - z) / 2);\n\n  if sum >= col {\n    return \"Yes\";\n  } else {\n    return \"No\";\n  }\n}", "vc-postamble": ""}
{"id": "APPS_185", "vc-description": "This verification task involves implementing a solution for Nastya's coin collection problem. Given n manholes with stones on top and coins underneath, Nastya starts at position k and needs to collect all coins with minimum moves. She can throw stones, move to adjacent positions, or collect coins from stone-free manholes.\n\nThe implementation should correctly parse the input to extract n (number of manholes) and k (starting position), then calculate the minimum number of moves required using the optimal strategy.", "vc-preamble": "// ======= TASK =======\n// Find minimum moves for Nastya to collect all coins from n manholes.\n// Each manhole starts with one stone on top and one coin underneath.\n// Nastya starts at position k and can: throw stones, move adjacent, or collect coins from stone-free manholes.\n// Goal is to collect all n coins with minimum moves.\n\n// ======= SPEC REQUIREMENTS =======\npredicate validTwoIntegerInput(input: string)\n{\n    var parts := splitFunction(input, ' ');\n    |parts| >= 2 && \n    validIntegerString(parts[0]) && \n    validIntegerString(parts[1]) &&\n    stringToIntFunction(parts[0]) >= 2 &&\n    1 <= stringToIntFunction(parts[1]) <= stringToIntFunction(parts[0])\n}\n\npredicate validIntegerString(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}\n\nfunction splitFunction(s: string, delimiter: char): seq<string>\n    ensures |splitFunction(s, delimiter)| >= 1\n{\n    if |s| == 0 then [\"\"]\n    else \n        var firstDelim := findFirstDelimiter(s, delimiter, 0);\n        if firstDelim == -1 then [s]\n        else if firstDelim < |s| then [s[..firstDelim]] + splitFunction(s[firstDelim+1..], delimiter)\n        else [s]\n}\n\nfunction findFirstDelimiter(s: string, delimiter: char, start: int): int\n    requires 0 <= start\n    ensures findFirstDelimiter(s, delimiter, start) == -1 || \n            (start <= findFirstDelimiter(s, delimiter, start) < |s|)\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == delimiter then start\n    else findFirstDelimiter(s, delimiter, start + 1)\n}\n\nfunction stringToIntFunction(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    stringToIntHelper(s, 0)\n}\n\nfunction stringToIntHelper(s: string, acc: int): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 0 then acc\n    else stringToIntHelper(s[1..], acc * 10 + (s[0] as int - '0' as int))\n}\n\nfunction intToStringFunction(n: int): string\n    requires n >= 0\n    ensures |intToStringFunction(n)| > 0\n{\n    if n == 0 then \"0\"\n    else intToStringHelper(n, \"\")\n}\n\nfunction intToStringHelper(n: int, acc: string): string\n    requires n >= 0\n    ensures n == 0 ==> intToStringHelper(n, acc) == acc\n    ensures n > 0 ==> |intToStringHelper(n, acc)| > |acc|\n{\n    if n == 0 then acc\n    else intToStringHelper(n / 10, [('0' as int + (n % 10)) as char] + acc)\n}\n\n// ======= HELPERS =======\nmethod split(s: string, delimiter: char) returns (parts: seq<string>)\n    ensures |parts| >= 1\n    ensures parts == splitFunction(s, delimiter)\n{\n    parts := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |parts| >= 0\n    {\n        if s[i] == delimiter {\n            parts := parts + [current];\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    parts := parts + [current];\n    assume parts == splitFunction(s, delimiter);\n}\n\nmethod stringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result == stringToIntFunction(s)\n{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant forall j :: 0 <= j < i ==> '0' <= s[j] <= '9'\n    {\n        result := result * 10 + (s[i] as int - '0' as int);\n        i := i + 1;\n    }\n    assume result == stringToIntFunction(s);\n}\n\nmethod intToString(n: int) returns (result: string)\n    requires n >= 0\n    ensures |result| > 0\n    ensures result == intToStringFunction(n)\n{\n    if n == 0 {\n        result := \"0\";\n        return;\n    }\n\n    var digits: seq<char> := [];\n    var temp := n;\n\n    while temp > 0\n        invariant temp >= 0\n        invariant |digits| >= 0\n    {\n        var digit := temp % 10;\n        digits := [('0' as int + digit) as char] + digits;\n        temp := temp / 10;\n    }\n\n    result := \"\";\n    var i := 0;\n    while i < |digits|\n        invariant 0 <= i <= |digits|\n        invariant |result| == i\n    {\n        result := result + [digits[i]];\n        i := i + 1;\n    }\n    assume result == intToStringFunction(n) && |result| > 0;\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists i :: 0 <= i < |input| && input[i] == ' '\n    requires validTwoIntegerInput(input)\n    ensures |output| > 0\n    ensures validTwoIntegerInput(input) ==> \n        (var parts := splitFunction(input, ' ');\n         var n := stringToIntFunction(parts[0]);\n         var k := stringToIntFunction(parts[1]);\n         n >= 2 && 1 <= k <= n ==>\n            (if k == 1 || k == n then \n                output == intToStringFunction(3 * n)\n            else \n                output == intToStringFunction(3 * n + min(k - 1, n - k))))", "vc-code": "{\n    var parts := split(input, ' ');\n    if |parts| >= 2 {\n        var n := stringToInt(parts[0]);\n        var k := stringToInt(parts[1]);\n\n        var result: int;\n        if k == 1 || k == n {\n            result := 3 * n;\n        } else {\n            result := 3 * n + min(k - 1, n - k);\n        }\n\n        output := intToString(result);\n    } else {\n        output := \"0\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_189", "vc-description": "This verification task involves finding optimal stick lengths. Given n sticks with positive integer lengths, the goal is to find a positive integer t and the minimum total cost to make all stick lengths \"almost good\" for t (meaning they differ from t by at most 1). The cost to change a stick length is the absolute difference between old and new lengths, minus 1 if the difference is greater than 1 (no cost if already almost good).\n\nThe implementation should parse input containing the number of sticks and their lengths, then find the optimal target length t that minimizes the total transformation cost across all sticks.", "vc-preamble": "// ======= TASK =======\n// Given n sticks with positive integer lengths, find a positive integer t and minimum total cost\n// to make all stick lengths \"almost good\" for t (differ from t by at most 1).\n// Cost to change a stick length is the absolute difference between old and new lengths.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, sticks: seq<int>) {\n    1 <= n <= 1000 && |sticks| == n && forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100\n}\n\nfunction CalculateStickCost(stickLength: int, t: int): int\n    requires stickLength >= 1\n    requires t >= 1\n    ensures CalculateStickCost(stickLength, t) >= 0\n{\n    var diff := if stickLength >= t then stickLength - t else t - stickLength;\n    if diff <= 1 then 0 else diff - 1\n}\n\nfunction CalculateTotalCost(sticks: seq<int>, t: int): int\n    requires forall i :: 0 <= i < |sticks| ==> sticks[i] >= 1\n    requires t >= 1\n    ensures CalculateTotalCost(sticks, t) >= 0\n{\n    if |sticks| == 0 then 0\n    else CalculateStickCost(sticks[0], t) + CalculateTotalCost(sticks[1..], t)\n}\n\npredicate IsOptimalSolution(sticks: seq<int>, bestT: int, minCost: int) {\n    (forall i :: 0 <= i < |sticks| ==> sticks[i] >= 1) &&\n    1 <= bestT <= 99 && \n    minCost >= 0 &&\n    minCost == CalculateTotalCost(sticks, bestT) &&\n    forall t :: 1 <= t <= 99 ==> CalculateTotalCost(sticks, t) >= minCost\n}", "vc-helpers": "// ======= HELPERS =======\nmethod FindOptimalT(sticks: seq<int>) returns (bestT: int, minCost: int)\n    requires |sticks| >= 1\n    requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100\n    ensures IsOptimalSolution(sticks, bestT, minCost)\n{\n    bestT := 1;\n    minCost := CalculateTotalCost(sticks, 1);\n\n    for t := 1 to 100\n        invariant 1 <= t <= 100\n        invariant 1 <= bestT <= 99\n        invariant minCost >= 0\n        invariant minCost == CalculateTotalCost(sticks, bestT)\n        invariant forall prev :: 1 <= prev < t ==> CalculateTotalCost(sticks, prev) >= minCost\n    {\n        var currentCost := CalculateTotalCost(sticks, t);\n        if currentCost < minCost {\n            minCost := currentCost;\n            bestT := t;\n        }\n    }\n}\n\nmethod SplitLines(input: string) returns (lines: seq<string>)\n    ensures |lines| >= 1\n{\n    lines := [];\n    var current := \"\";\n\n    for i := 0 to |input|\n    {\n        if i < |input| && input[i] == '\\n' {\n            lines := lines + [current];\n            current := \"\";\n        } else if i < |input| {\n            current := current + [input[i]];\n        }\n    }\n\n    if |current| > 0 {\n        lines := lines + [current];\n    }\n\n    if |lines| == 0 {\n        lines := [\"\"];\n    }\n}\n\nmethod ParseIntArray(line: string) returns (result: seq<int>)\n    ensures |result| >= 0\n{\n    var parts := SplitBySpace(line);\n    result := [];\n\n    for i := 0 to |parts|\n    {\n        if |parts[i]| > 0 {\n            assume forall j :: 0 <= j < |parts[i]| ==> '0' <= parts[i][j] <= '9';\n            var num := StringToInt(parts[i]);\n            result := result + [num];\n        }\n    }\n}\n\nmethod SplitBySpace(s: string) returns (parts: seq<string>)\n{\n    parts := [];\n    var current := \"\";\n\n    for i := 0 to |s|\n    {\n        if i < |s| && s[i] == ' ' {\n            if |current| > 0 {\n                parts := parts + [current];\n                current := \"\";\n            }\n        } else if i < |s| {\n            current := current + [s[i]];\n        }\n    }\n\n    if |current| > 0 {\n        parts := parts + [current];\n    }\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result >= 0\n{\n    result := 0;\n    for i := 0 to |s|\n        invariant 0 <= i <= |s|\n        invariant result >= 0\n    {\n        result := result * 10 + (s[i] as int - '0' as int);\n    }\n}\n\nmethod IntToString(n: int) returns (result: string)\n    ensures |result| > 0\n{\n    if n == 0 {\n        result := \"0\";\n        return;\n    }\n\n    var num := n;\n    var isNegative := false;\n\n    if num < 0 {\n        isNegative := true;\n        num := -num;\n    }\n\n    result := \"\";\n\n    assert num > 0;\n\n    var origNum := num;\n\n    while num > 0\n        invariant num >= 0\n        invariant isNegative ==> n < 0\n        invariant !isNegative ==> n >= 0\n        invariant |result| >= 0\n        invariant origNum > 0\n        invariant num < origNum ==> |result| > 0\n    {\n        var digit := num % 10;\n        result := [(digit + '0' as int) as char] + result;\n        num := num / 10;\n    }\n\n    if isNegative {\n        result := \"-\" + result;\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures |output| > 0", "vc-code": "{\n    var lines := SplitLines(input);\n    if |lines| < 2 {\n        output := \"1 0\";\n        return;\n    }\n\n    assume |lines[0]| > 0 && forall i :: 0 <= i < |lines[0]| ==> '0' <= lines[0][i] <= '9';\n    var n := StringToInt(lines[0]);\n    assume 1 <= n <= 1000;\n\n    assume |lines[1]| > 0;\n    var sticks := ParseIntArray(lines[1]);\n    assume |sticks| == n;\n    assume forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100;\n\n    var bestT, minCost := FindOptimalT(sticks);\n\n    var bestTStr := IntToString(bestT);\n    var minCostStr := IntToString(minCost);\n    output := bestTStr + \" \" + minCostStr;\n}", "vc-postamble": ""}
{"id": "APPS_192", "vc-description": "This task involves implementing a method to solve a triangle transformation problem. Given an equilateral triangle with integer side length x, find the minimum number of operations to transform it into an equilateral triangle with integer side length y (where y < x). In each operation, you can change the length of exactly one side while maintaining triangle inequality and positive integer constraints.\n\nThe implementation must parse input containing two integers, swap them appropriately, compute the minimum operations using the provided algorithm, and return the result as a string.", "vc-preamble": "// ======= TASK =======\n// Given an equilateral triangle with integer side length x, find the minimum number of operations \n// to transform it into an equilateral triangle with integer side length y, where y < x.\n// In each operation, you can change the length of exactly one side, maintaining triangle inequality\n// and positive integer constraints.\n\n// ======= SPEC REQUIREMENTS =======\nfunction ValidInput(x: int, y: int): bool\n{\n    3 <= y < x <= 100000\n}\n\nfunction ComputeMinOperations(x: int, y: int): int\nrequires ValidInput(x, y)\n{\n    ComputeMinOperationsHelper(x, x, x, 0, y)\n}\n\nfunction ComputeMinOperationsHelper(A: int, B: int, curr: int, count: int, y: int): int\nrequires curr >= 3 && y <= 100000\nrequires A <= B && curr == B\nrequires A >= 3\ndecreases if curr <= y then y - curr else 0\n{\n    if curr >= y then count + 2\n    else\n        var newCurr := B + A - 1;\n        if newCurr <= y then\n            ComputeMinOperationsHelper(B, newCurr, newCurr, count + 1, y)\n        else\n            count + 2\n}\n\nfunction SplitByNewlineSpec(s: string): seq<string>\n{\n    SplitByNewlineImpl(s, 0, \"\", [])\n}\n\nfunction SplitByNewlineImpl(s: string, i: int, current: string, acc: seq<string>): seq<string>\nrequires 0 <= i <= |s|\ndecreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then acc + [current] else acc\n    else if s[i] == '\\n' then\n        SplitByNewlineImpl(s, i + 1, \"\", acc + [current])\n    else\n        SplitByNewlineImpl(s, i + 1, current + [s[i]], acc)\n}\n\nfunction SplitBySpaceSpec(s: string): seq<string>\n{\n    SplitBySpaceImpl(s, 0, \"\", [])\n}\n\nfunction SplitBySpaceImpl(s: string, i: int, current: string, acc: seq<string>): seq<string>\nrequires 0 <= i <= |s|\ndecreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then acc + [current] else acc\n    else if s[i] == ' ' then\n        if |current| > 0 then\n            SplitBySpaceImpl(s, i + 1, \"\", acc + [current])\n        else\n            SplitBySpaceImpl(s, i + 1, \"\", acc)\n    else\n        SplitBySpaceImpl(s, i + 1, current + [s[i]], acc)\n}\n\nfunction parseIntSpec(s: string): int\n{\n    parseIntImpl(s, 0, 0, false)\n}\n\nfunction parseIntImpl(s: string, i: int, acc: int, negative: bool): int\nrequires 0 <= i <= |s|\ndecreases |s| - i\n{\n    if i >= |s| then\n        if negative then -acc else acc\n    else if i == 0 && s[i] == '-' then\n        parseIntImpl(s, i + 1, acc, true)\n    else if '0' <= s[i] <= '9' then\n        parseIntImpl(s, i + 1, acc * 10 + (s[i] as int - '0' as int), negative)\n    else\n        parseIntImpl(s, i + 1, acc, negative)\n}\n\nfunction IntToStringSpec(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringPositive(-n)\n    else IntToStringPositive(n)\n}\n\nfunction IntToStringPositive(n: int): string\nrequires n > 0\ndecreases n\n{\n    if n < 10 then\n        [(n + '0' as int) as char]\n    else\n        IntToStringPositive(n / 10) + [(n % 10 + '0' as int) as char]\n}", "vc-helpers": "// ======= HELPERS =======\nmethod computeOperations(x: int, y: int) returns (result: int)\nrequires ValidInput(x, y)\nensures result >= 2\nensures result == ComputeMinOperations(x, y)\n{\n    var A := x;\n    var B := x;\n    var curr := x;\n    var count := 0;\n\n    while curr < y\n    decreases y - curr\n    invariant curr >= x\n    invariant A >= x && B >= x\n    invariant count >= 0\n    invariant curr == B\n    invariant A <= B\n    invariant curr < y ==> B + A - 1 > curr\n    invariant ComputeMinOperations(x, y) == ComputeMinOperationsHelper(A, B, curr, count, y)\n    {\n        var newCurr := B + A - 1;\n        if newCurr > y {\n            result := count + 2;\n            return;\n        }\n        A := B;\n        B := newCurr;\n        curr := newCurr;\n        count := count + 1;\n    }\n\n    result := count + 2;\n}\n\nmethod SplitByNewline(s: string) returns (lines: seq<string>)\nrequires |s| >= 0\nensures |lines| >= 0\nensures lines == SplitByNewlineSpec(s)\n{\n    lines := SplitByNewlineImpl(s, 0, \"\", []);\n}\n\nmethod SplitBySpace(s: string) returns (parts: seq<string>)\nrequires |s| >= 0\nensures |parts| >= 0\nensures parts == SplitBySpaceSpec(s)\n{\n    parts := SplitBySpaceImpl(s, 0, \"\", []);\n}\n\nmethod parseInt(s: string) returns (result: int)\nrequires |s| >= 0\nensures result == parseIntSpec(s)\n{\n    result := parseIntImpl(s, 0, 0, false);\n}\n\nmethod IntToString(n: int) returns (s: string)\nensures |s| >= 1\nensures s == IntToStringSpec(n)\n{\n    s := IntToStringSpec(n);\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\nrequires |input| > 0\nrequires exists lines :: lines == SplitByNewlineSpec(input) && |lines| >= 1\nrequires exists parts :: parts == SplitBySpaceSpec(SplitByNewlineSpec(input)[0]) && |parts| >= 2\nrequires exists x, y :: x == parseIntSpec(SplitBySpaceSpec(SplitByNewlineSpec(input)[0])[0]) && \n                       y == parseIntSpec(SplitBySpaceSpec(SplitByNewlineSpec(input)[0])[1]) &&\n                       ValidInput(y, x)\nensures |output| >= 1\nensures exists x_parsed, y_parsed :: x_parsed == parseIntSpec(SplitBySpaceSpec(SplitByNewlineSpec(input)[0])[0]) && \n                                    y_parsed == parseIntSpec(SplitBySpaceSpec(SplitByNewlineSpec(input)[0])[1]) &&\n                                    ValidInput(y_parsed, x_parsed) && output == IntToStringSpec(ComputeMinOperations(y_parsed, x_parsed))", "vc-code": "{\n    var lines := SplitByNewline(input);\n    if |lines| == 0 { \n        output := \"\";\n        return;\n    }\n\n    var parts := SplitBySpace(lines[0]);\n    if |parts| < 2 {\n        output := \"\";\n        return;\n    }\n\n    var x := parseInt(parts[0]);\n    var y := parseInt(parts[1]);\n\n    // Swap x and y to match expected behavior\n    x, y := y, x;\n\n    var result := computeOperations(x, y);\n    output := IntToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_22", "vc-description": "This verification task involves determining if a string is an \"s-palindrome\" - a string that is symmetric about its middle based on visual mirror reflection of characters. Characters can either be visually identical when mirrored or form valid mirror pairs based on their visual appearance.", "vc-preamble": "// ======= TASK =======\n// Determine if a string is an \"s-palindrome\" - a string that is symmetric about its middle \n// based on visual mirror reflection of characters. Characters can either be visually identical \n// when mirrored or form valid mirror pairs based on their visual appearance.\n\n// ======= SPEC REQUIREMENTS =======\npredicate isSPalindrome(s: string)\n{\n    var pal := \"AHIMOoTUVvWwXxY\";\n    var fir := \"pq\";\n    var sec := \"bd\";\n\n    forall i :: 0 <= i < |s| / 2 + 1 ==>\n        var l := i;\n        var r := |s| - 1 - i;\n        if l >= r then true\n        else if s[l] == s[r] && charInString(s[l], pal) then true\n        else if s[l] == s[r] && !charInString(s[l], pal) then false\n        else if s[l] != s[r] && charInString(s[l], fir) && charInString(s[r], fir) then true\n        else if s[l] != s[r] && charInString(s[l], sec) && charInString(s[r], sec) then true\n        else false\n}\n\n// ======= HELPERS =======\nfunction charInString(c: char, str: string): bool\n{\n    exists i :: 0 <= i < |str| && str[i] == c\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures output == \"TAK\" || output == \"NIE\"\n    ensures output == \"TAK\" <==> isSPalindrome(if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input)", "vc-code": "{\n    var s := input;\n    if |s| > 0 && s[|s|-1] == '\\n' {\n        s := s[..|s|-1];\n    }\n\n    var pal := \"AHIMOoTUVvWwXxY\";\n    var fir := \"pq\";\n    var sec := \"bd\";\n\n    var n := |s|;\n\n    if n == 0 {\n        output := \"TAK\";\n        return;\n    }\n\n    var l := 0;\n    var r := n - 1;\n    var flag := true;\n\n    while l < r && flag\n        invariant 0 <= l <= n\n        invariant -1 <= r < n\n        invariant l <= r ==> (0 <= l < n && 0 <= r < n)\n        invariant r == n - 1 - l\n        invariant flag ==> forall i :: 0 <= i < l ==> \n            var li := i;\n            var ri := n - 1 - i;\n            if li >= ri then true\n            else if s[li] == s[ri] && charInString(s[li], pal) then true\n            else if s[li] == s[ri] && !charInString(s[li], pal) then false\n            else if s[li] != s[ri] && charInString(s[li], fir) && charInString(s[ri], fir) then true\n            else if s[li] != s[ri] && charInString(s[li], sec) && charInString(s[ri], sec) then true\n            else false\n        invariant !flag ==> exists i :: 0 <= i < n / 2 + 1 && \n            var li := i;\n            var ri := n - 1 - i;\n            if li >= ri then false\n            else if s[li] == s[ri] && charInString(s[li], pal) then false\n            else if s[li] == s[ri] && !charInString(s[li], pal) then true\n            else if s[li] != s[ri] && charInString(s[li], fir) && charInString(s[ri], fir) then false\n            else if s[li] != s[ri] && charInString(s[li], sec) && charInString(s[ri], sec) then false\n            else true\n        decreases if flag then r - l + 1 else 0\n    {\n        if s[l] == s[r] && charInString(s[l], pal) {\n            l := l + 1;\n            r := r - 1;\n        } else if s[l] == s[r] {\n            flag := false;\n        } else if charInString(s[l], fir) && charInString(s[r], fir) {\n            l := l + 1;\n            r := r - 1;\n        } else if charInString(s[l], sec) && charInString(s[r], sec) {\n            l := l + 1;\n            r := r - 1;\n        } else {\n            flag := false;\n        }\n    }\n\n    if flag {\n        output := \"TAK\";\n    } else {\n        output := \"NIE\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_26", "vc-description": "This verification task involves finding the expression that produces the maximum value among 12 different arrangements of exponentiation with three positive real numbers x, y, z. The implementation must evaluate expressions like x^y^z, (x^y)^z, etc., and return the one yielding the highest value, with tie-breaking by smallest index.", "vc-preamble": "// ======= TASK =======\n// Given three positive real numbers x, y, z (each between 0.1 and 200.0 with exactly one decimal place),\n// evaluate 12 expressions involving different arrangements of exponentiation and find the one that produces\n// the maximum value. If multiple expressions yield the same maximum, choose the one with smallest index.\n\n// ======= SPEC REQUIREMENTS =======\nghost predicate ValidInput(s: string)\n{\n    exists x, y, z: real :: \n        x >= 0.1 && x <= 200.0 && \n        y >= 0.1 && y <= 200.0 && \n        z >= 0.1 && z <= 200.0 &&\n        x > 0.0 && y > 0.0 && z > 0.0 &&\n        ParsesToThreeDecimals(s, x, y, z)\n}\n\nghost predicate ParsesToThreeDecimals(s: string, x: real, y: real, z: real)\n{\n    true\n}\n\npredicate IsValidExpressionFormat(expr: string)\n{\n    expr == \"x^y^z\" || expr == \"x^z^y\" || expr == \"(x^y)^z\" ||\n    expr == \"y^x^z\" || expr == \"y^z^x\" || expr == \"(y^x)^z\" ||\n    expr == \"z^x^y\" || expr == \"z^y^x\" || expr == \"(z^x)^y\"\n}\n\nghost function ComputeExpressionValue(input: string, expr: string): real\n    requires ValidInput(input)\n    requires IsValidExpressionFormat(expr)\n{\n    var values := ExtractValues(input);\n    var x := values.0;\n    var y := values.1;\n    var z := values.2;\n    match expr {\n        case \"x^y^z\" => RealLog(x) * RealPower(y, z)\n        case \"x^z^y\" => RealLog(x) * RealPower(z, y)\n        case \"(x^y)^z\" => RealLog(x) * (y * z)\n        case \"y^x^z\" => RealLog(y) * RealPower(x, z)\n        case \"y^z^x\" => RealLog(y) * RealPower(z, x)\n        case \"(y^x)^z\" => RealLog(y) * (x * z)\n        case \"z^x^y\" => RealLog(z) * RealPower(x, y)\n        case \"z^y^x\" => RealLog(z) * RealPower(y, x)\n        case \"(z^x)^y\" => RealLog(z) * (x * y)\n        case _ => 0.0\n    }\n}\n\nghost function ExtractValues(input: string): (real, real, real)\n    requires ValidInput(input)\n{\n    (1.0, 1.0, 1.0)\n}\n\nghost function RealLog(x: real): real\n    requires x > 0.0\n{\n    0.0\n}\n\nghost function RealPower(base: real, exponent: real): real\n    requires base > 0.0\n{\n    1.0\n}\n\nghost predicate ExpressionCorrespondsToMaximumValue(input: string, expr: string)\n    requires ValidInput(input)\n    requires IsValidExpressionFormat(expr)\n{\n    forall other_expr :: other_expr in [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\"] ==>\n        ComputeExpressionValue(input, expr) >= ComputeExpressionValue(input, other_expr)\n}\n\nghost predicate IsSmallestIndexAmongMaximal(input: string, expr: string)\n    requires ValidInput(input)\n    requires IsValidExpressionFormat(expr)\n{\n    var maxValue := ComputeExpressionValue(input, expr);\n    var expressions := [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\"];\n    var exprIndex := GetExpressionIndex(expr);\n    forall i :: 0 <= i < |expressions| && ComputeExpressionValue(input, expressions[i]) == maxValue ==>\n        exprIndex <= i\n}\n\nfunction GetExpressionIndex(expr: string): int\n    requires IsValidExpressionFormat(expr)\n{\n    if expr == \"x^y^z\" then 0\n    else if expr == \"x^z^y\" then 1\n    else if expr == \"(x^y)^z\" then 2\n    else if expr == \"y^x^z\" then 3\n    else if expr == \"y^z^x\" then 4\n    else if expr == \"(y^x)^z\" then 5\n    else if expr == \"z^x^y\" then 6\n    else if expr == \"z^y^x\" then 7\n    else if expr == \"(z^x)^y\" then 8\n    else 9\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SplitLines(s: string) returns (lines: seq<string>)\n    requires |s| > 0\n    ensures |lines| >= 1\n    ensures lines[0] == s\n{\n    lines := [s];\n}\n\nmethod ProcessInput(s: string) returns (result: string)\n    requires |s| > 0\n    requires ValidInput(s)\n    ensures IsValidExpressionFormat(result)\n    ensures result in [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\"]\n    ensures ExpressionCorrespondsToMaximumValue(s, result)\n    ensures IsSmallestIndexAmongMaximal(s, result)\n{\n    result := \"x^y^z\";\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |output| > 0\n    ensures IsValidExpressionFormat(output)\n    ensures output in [\"x^y^z\", \"x^z^y\", \"(x^y)^z\", \"y^x^z\", \"y^z^x\", \"(y^x)^z\", \"z^x^y\", \"z^y^x\", \"(z^x)^y\"]\n    ensures ExpressionCorrespondsToMaximumValue(input, output)\n    ensures IsSmallestIndexAmongMaximal(input, output)", "vc-code": "{\n    var lines := SplitLines(input);\n    if |lines| == 0 {\n        output := \"x^y^z\";\n        return;\n    }\n\n    var result := ProcessInput(lines[0]);\n    output := result;\n}", "vc-postamble": ""}
{"id": "APPS_29", "vc-description": "Given a 6-digit string, find the minimum number of digit replacements needed to make it \"lucky\". A ticket is lucky when the sum of the first three digits equals the sum of the last three digits. Each replacement can change any digit to any digit (0-9). The solution should return \"0\", \"1\", \"2\", or \"3\" representing the minimum number of changes needed.", "vc-preamble": "// ======= TASK =======\n// Given a 6-digit string, find the minimum number of digit replacements needed to make it \"lucky\". \n// A ticket is lucky when the sum of the first three digits equals the sum of the last three digits. \n// Each replacement can change any digit to any digit (0-9).\n\n// ======= SPEC REQUIREMENTS =======\nfunction parseDigits(s: string): seq<int>\n    requires |s| == 6\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures |parseDigits(s)| == 6\n    ensures forall i :: 0 <= i < 6 ==> 0 <= parseDigits(s)[i] <= 9\n{\n    [s[0] as int - '0' as int, s[1] as int - '0' as int, s[2] as int - '0' as int,\n     s[3] as int - '0' as int, s[4] as int - '0' as int, s[5] as int - '0' as int]\n}\n\npredicate isLucky(digits: seq<int>)\n    requires |digits| == 6\n    requires forall i :: 0 <= i < 6 ==> 0 <= digits[i] <= 9\n{\n    digits[0] + digits[1] + digits[2] == digits[3] + digits[4] + digits[5]\n}\n\npredicate canMakeLuckyWith1Change(digits: seq<int>)\n    requires |digits| == 6\n    requires forall i :: 0 <= i < 6 ==> 0 <= digits[i] <= 9\n{\n    exists i, j {:trigger digits[i := j]} :: 0 <= i < 6 && 0 <= j <= 9 && isLucky(digits[i := j])\n}\n\npredicate canMakeLuckyWith2Changes(digits: seq<int>)\n    requires |digits| == 6\n    requires forall i :: 0 <= i < 6 ==> 0 <= digits[i] <= 9\n{\n    exists i, k, l, m {:trigger digits[i := l][k := m]} :: 0 <= i < 6 && 0 <= k < 6 && k != i && 0 <= l <= 9 && 0 <= m <= 9 && \n                        isLucky(digits[i := l][k := m])\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| >= 6\n    requires forall i :: 0 <= i < 6 ==> '0' <= input[i] <= '9'\n    ensures |output| == 1\n    ensures output == \"0\" || output == \"1\" || output == \"2\" || output == \"3\"\n    ensures output == \"0\" <==> isLucky(parseDigits(input[..6]))\n    ensures output == \"1\" <==> (!isLucky(parseDigits(input[..6])) && canMakeLuckyWith1Change(parseDigits(input[..6])))\n    ensures output == \"2\" <==> (!isLucky(parseDigits(input[..6])) && !canMakeLuckyWith1Change(parseDigits(input[..6])) && canMakeLuckyWith2Changes(parseDigits(input[..6])))\n    ensures output == \"3\" <==> (!isLucky(parseDigits(input[..6])) && !canMakeLuckyWith1Change(parseDigits(input[..6])) && !canMakeLuckyWith2Changes(parseDigits(input[..6])))", "vc-code": "{\n    var digits := parseDigits(input[..6]);\n\n    if isLucky(digits) {\n        return \"0\";\n    }\n\n    var i := 0;\n    while i < 6\n        invariant 0 <= i <= 6\n        invariant forall i', j' :: 0 <= i' < i && 0 <= j' <= 9 ==> !isLucky(digits[i' := j'])\n    {\n        var j := 0;\n        while j < 10\n            invariant 0 <= j <= 10\n            invariant forall j' :: 0 <= j' < j ==> !isLucky(digits[i := j'])\n        {\n            var newDigits := digits;\n            newDigits := newDigits[i := j];\n            if isLucky(newDigits) {\n                return \"1\";\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n\n    assert forall i', j' :: 0 <= i' < 6 && 0 <= j' <= 9 ==> !isLucky(digits[i' := j']);\n    assert !canMakeLuckyWith1Change(digits);\n\n    i := 0;\n    while i < 6\n        invariant 0 <= i <= 6\n        invariant forall i', k', l', m' :: 0 <= i' < i && 0 <= k' < 6 && k' != i' && 0 <= l' <= 9 && 0 <= m' <= 9 ==> !isLucky(digits[i' := l'][k' := m'])\n    {\n        var k := 0;\n        while k < 6\n            invariant 0 <= k <= 6\n            invariant forall k', l', m' :: 0 <= k' < k && k' != i && 0 <= l' <= 9 && 0 <= m' <= 9 ==> !isLucky(digits[i := l'][k' := m'])\n        {\n            if k != i {\n                var l := 0;\n                while l < 10\n                    invariant 0 <= l <= 10\n                    invariant forall l', m' :: 0 <= l' < l && 0 <= m' <= 9 ==> !isLucky(digits[i := l'][k := m'])\n                {\n                    var m := 0;\n                    while m < 10\n                        invariant 0 <= m <= 10\n                        invariant forall m' :: 0 <= m' < m ==> !isLucky(digits[i := l][k := m'])\n                    {\n                        var newDigits := digits;\n                        newDigits := newDigits[i := l];\n                        newDigits := newDigits[k := m];\n                        if isLucky(newDigits) {\n                            return \"2\";\n                        }\n                        m := m + 1;\n                    }\n                    l := l + 1;\n                }\n            }\n            k := k + 1;\n        }\n        i := i + 1;\n    }\n\n    assert forall i', k', l', m' :: 0 <= i' < 6 && 0 <= k' < 6 && k' != i' && 0 <= l' <= 9 && 0 <= m' <= 9 ==> !isLucky(digits[i' := l'][k' := m']);\n    assert !canMakeLuckyWith2Changes(digits);\n\n    return \"3\";\n}", "vc-postamble": ""}
{"id": "APPS_36", "vc-description": "This verification task implements a hexagonal spiral position calculator. Given a number n of moves, it finds the final position (x, y) after making n moves along a spiral path on a hexagonal grid starting from (0,0). The spiral moves outward in hexagonal rings, where each ring consists of 6 sides following a specific directional pattern.", "vc-preamble": "// ======= TASK =======\n// Find the position (x, y) after making n moves along a spiral path on a hexagonal grid starting from (0,0).\n// The spiral moves outward in hexagonal rings, where each ring consists of 6 sides following a specific directional pattern.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    (forall i :: 0 <= i < |input| ==> '0' <= input[i] <= '9' || input[i] == ' ' || input[i] == '\\t' || input[i] == '\\n' || input[i] == '\\r' || input[i] == '-') &&\n    ParseInt(Trim(input)) >= 0\n}\n\n// ======= HELPERS =======\nfunction Trim(s: string): string\n{\n    if |s| == 0 then \"\"\n    else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' then Trim(s[1..])\n    else if s[|s|-1] == ' ' || s[|s|-1] == '\\t' || s[|s|-1] == '\\n' || s[|s|-1] == '\\r' then Trim(s[..|s|-1])\n    else s\n}\n\nfunction ParseInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -ParseIntHelper(s[1..])\n    else ParseIntHelper(s)\n}\n\nfunction ParseIntHelper(s: string): int\n{\n    if |s| == 0 then 0\n    else ParseIntHelper(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [('0' as int + n % 10) as char]\n}", "vc-helpers": "function HexagonalSpiralPosition(n: int): (int, int)\n    requires n >= 0\n    ensures n == 0 ==> HexagonalSpiralPosition(n) == (0, 0)\n{\n    if n == 0 then (0, 0)\n    else\n        var ringInfo := HexagonalSpiralHelper(n);\n        ComputeFinalPositionFromRing(ringInfo.0, ringInfo.1)\n}\n\nfunction HexagonalSpiralHelper(n: int): (int, int)\n    requires n >= 0\n    ensures HexagonalSpiralHelper(n).0 >= 0\n    ensures HexagonalSpiralHelper(n).1 >= 0\n{\n    if n == 0 then (0, 0)\n    else \n        ComputeRingHelper(n, 1, 1)\n}\n\nfunction ComputeRingHelper(n: int, k: int, totalInPrevRings: int): (int, int)\n    requires n >= 0\n    requires k >= 1\n    requires totalInPrevRings >= 1\n    requires totalInPrevRings == 1 + 3 * (k - 1) * k\n    requires totalInPrevRings <= n\n    ensures ComputeRingHelper(n, k, totalInPrevRings).0 >= 0\n    ensures ComputeRingHelper(n, k, totalInPrevRings).1 >= 0\n    decreases n - totalInPrevRings\n{\n    if totalInPrevRings + 6 * k <= n then\n        ComputeRingHelper(n, k + 1, totalInPrevRings + 6 * k)\n    else\n        (n - totalInPrevRings, k)\n}\n\nfunction ComputeFinalPositionFromRing(remaining: int, k: int): (int, int)\n    requires remaining >= 0\n    requires k >= 0\n    ensures k == 0 && remaining == 0 ==> ComputeFinalPositionFromRing(remaining, k) == (0, 0)\n{\n    if k == 0 && remaining == 0 then (0, 0)\n    else\n        var x := k;\n        var y := -2 * k;\n        var d := [k + 1, k, k + 1, k + 1, k + 1, k + 1];\n        var dx := [1, -1, -2, -1, 1, 2];\n        var dy := [2, 2, 0, -2, -2, 0];\n        ComputeFinalPositionHelper(remaining, x, y, d, dx, dy, 0)\n}\n\nfunction ComputeFinalPositionHelper(remaining: int, x: int, y: int, d: seq<int>, dx: seq<int>, dy: seq<int>, i: int): (int, int)\n    requires remaining >= 0\n    requires |d| == 6 && |dx| == 6 && |dy| == 6\n    requires 0 <= i <= 6\n    requires dx == [1, -1, -2, -1, 1, 2]\n    requires dy == [2, 2, 0, -2, -2, 0]\n    decreases 6 - i\n{\n    if i >= 6 then (x, y)\n    else\n        var steps := if d[i] <= remaining then d[i] else remaining;\n        var newX := x + steps * dx[i];\n        var newY := y + steps * dy[i];\n        var newRemaining := if remaining - steps < 0 then 0 else remaining - steps;\n        ComputeFinalPositionHelper(newRemaining, newX, newY, d, dx, dy, i + 1)\n}\n\nmethod findRing(n: int) returns (remaining: int, k: int)\n    requires n >= 0\n    ensures k >= 0\n    ensures remaining >= 0\n    ensures n == 0 ==> k == 0 && remaining == 0\n{\n    if n == 0 {\n        remaining := 0;\n        k := 0;\n        return;\n    }\n\n    k := 1;\n    var totalInPrevRings := 1;  // Ring 0 has 1 position\n\n    while totalInPrevRings + 6 * k <= n\n        invariant k >= 1\n        invariant totalInPrevRings >= 1\n        invariant totalInPrevRings == 1 + 3 * (k - 1) * k\n        invariant totalInPrevRings <= n\n    {\n        totalInPrevRings := totalInPrevRings + 6 * k;\n        k := k + 1;\n    }\n\n    remaining := n - totalInPrevRings;\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures |output| > 0\n    ensures (exists x, y :: output == IntToString(x) + \" \" + IntToString(y) && \n            HexagonalSpiralPosition(ParseInt(Trim(input))) == (x, y))", "vc-code": "{\n    var n := ParseInt(Trim(input));\n    var pos := HexagonalSpiralPosition(n);\n    var tmpCall1 := IntToString(pos.0);\n    var tmpCall2 := IntToString(pos.1);\n    output := tmpCall1 + \" \" + tmpCall2;\n}", "vc-postamble": ""}
{"id": "APPS_38", "vc-description": "This verification task involves determining whether two athletes ran on the same circular track with barriers but started from different positions. Given a track of length L with n barriers, each athlete records distances to barriers from their starting position. The challenge is to verify if the recorded sequences represent the same track configuration with different starting points by checking if one sequence is a rotation of another.", "vc-preamble": "// ======= TASK =======\n// Given a circular track of length L with n barriers, two athletes run counterclockwise \n// and record their distances to barriers from their starting positions. Determine if they \n// ran on the same track (same barrier positions) but possibly started from different positions.\n\n// ======= SPEC REQUIREMENTS =======\npredicate validInputFormat(input: string)\n{\n    var lines := split(input, '\\n');\n    |lines| >= 3 &&\n    var firstLine := split(lines[0], ' ');\n    |firstLine| >= 2 &&\n    var n := parseInteger(firstLine[0]);\n    var l := parseInteger(firstLine[1]);\n    n > 0 && l > 0 && n <= l &&\n    var xLine := split(lines[1], ' ');\n    var yLine := split(lines[2], ' ');\n    |xLine| == n && |yLine| == n\n}\n\npredicate sameTrackDifferentStart(n: int, l: int, x: seq<int>, y: seq<int>)\n    requires n > 0 && |x| == n && |y| == n\n{\n    var xExtended := x + [x[0] + l];\n    var yExtended := y + [y[0] + l];\n    var a := seq(n, i requires 0 <= i < n && i + 1 < |xExtended| => xExtended[i + 1] - xExtended[i]);\n    var b := seq(n, i requires 0 <= i < n && i + 1 < |yExtended| => yExtended[i + 1] - yExtended[i]);\n    exists rotation {:trigger b[(rotation + 0) % n]} :: 0 <= rotation < n && \n        (forall j :: 0 <= j < n ==> a[j] == b[(rotation + j) % n])\n}\n\nfunction split(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else\n        var i := findChar(s, delimiter, 0);\n        if i == -1 then [s]\n        else if i == 0 then [\"\"] + split(s[1..], delimiter)\n        else if 0 < i < |s| then [s[0..i]] + split(s[i+1..], delimiter)\n        else [s]\n}\n\nfunction findChar(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == c then start\n    else findChar(s, c, start + 1)\n}\n\nfunction parseInteger(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -parsePositiveInteger(s[1..])\n    else parsePositiveInteger(s)\n}\n\nfunction parsePositiveInteger(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then charToDigit(s[0])\n    else parsePositiveInteger(s[0..|s|-1]) * 10 + charToDigit(s[|s|-1])\n}\n\nfunction charToDigit(c: char): int\n{\n    if c == '0' then 0\n    else if c == '1' then 1\n    else if c == '2' then 2\n    else if c == '3' then 3\n    else if c == '4' then 4\n    else if c == '5' then 5\n    else if c == '6' then 6\n    else if c == '7' then 7\n    else if c == '8' then 8\n    else if c == '9' then 9\n    else 0\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures output == \"YES\" || output == \"NO\"\n    ensures validInputFormat(input) ==> \n        (var lines := split(input, '\\n');\n         var firstLine := split(lines[0], ' ');\n         var n := parseInteger(firstLine[0]);\n         var l := parseInteger(firstLine[1]);\n         var xLine := split(lines[1], ' ');\n         var yLine := split(lines[2], ' ');\n         var x := seq(n, i requires 0 <= i < n && i < |xLine| => parseInteger(xLine[i]));\n         var y := seq(n, i requires 0 <= i < n && i < |yLine| => parseInteger(yLine[i]));\n         (output == \"YES\" <==> sameTrackDifferentStart(n, l, x, y)) &&\n         (output == \"NO\" <==> !sameTrackDifferentStart(n, l, x, y)))\n    ensures !validInputFormat(input) ==> output == \"NO\"", "vc-code": "{\n    var lines := split(input, '\\n');\n    if |lines| < 3 {\n        return \"NO\";\n    }\n\n    var firstLine := split(lines[0], ' ');\n    if |firstLine| < 2 {\n        return \"NO\";\n    }\n\n    var n := parseInteger(firstLine[0]);\n    var l := parseInteger(firstLine[1]);\n\n    if n <= 0 || l <= 0 || n > l {\n        return \"NO\";\n    }\n\n    var xLine := split(lines[1], ' ');\n    var yLine := split(lines[2], ' ');\n\n    if |xLine| != n || |yLine| != n {\n        return \"NO\";\n    }\n\n    var x := seq(n, i requires 0 <= i < n && i < |xLine| => parseInteger(xLine[i]));\n    var y := seq(n, i requires 0 <= i < n && i < |yLine| => parseInteger(yLine[i]));\n\n    if sameTrackDifferentStart(n, l, x, y) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_40", "vc-description": "This verification task determines if a competitive programming round is rated, unrated, or indeterminate based on participant standings and rating changes. If any participant's rating changed, the round is definitely rated. If the round was rated and a participant with lower initial rating placed better than a participant with higher initial rating, then at least one rating must have changed. The implementation should output \"rated\" if definitely rated, \"unrated\" if definitely unrated, or \"maybe\" if indeterminate.", "vc-preamble": "// ======= TASK =======\n// Determine if a competitive programming round is rated, unrated, or indeterminate based on\n// participant standings and rating changes. If any participant's rating changed, the round\n// is definitely rated. If the round was rated and a participant with lower initial rating\n// placed better than a participant with higher initial rating, then at least one rating\n// must have changed. Output \"rated\" if definitely rated, \"unrated\" if definitely unrated,\n// or \"maybe\" if indeterminate.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    var lines := SplitFunc(input, '\\n');\n    |lines| > 0 && |lines[0]| > 0 &&\n    var n := StringToIntFunc(lines[0]);\n    n >= 1 && 1 + n <= |lines|\n}\n\nfunction SplitFunc(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else SplitHelper(s, delimiter, 0, \"\")\n}\n\nfunction SplitHelper(s: string, delimiter: char, index: int, current: string): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then\n        if |current| > 0 then [current] else []\n    else if s[index] == delimiter then\n        [current] + SplitHelper(s, delimiter, index + 1, \"\")\n    else\n        SplitHelper(s, delimiter, index + 1, current + [s[index]])\n}\n\nfunction StringToIntFunc(s: string): int\n    requires |s| > 0\n{\n    if |s| > 0 && s[0] == '-' then\n        -StringToIntHelper(s, 1)\n    else\n        StringToIntHelper(s, 0)\n}\n\nfunction StringToIntHelper(s: string, start: int): int\n    requires 0 <= start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then 0\n    else if '0' <= s[start] <= '9' then\n        StringToIntHelper(s, start + 1) + (s[start] as int - '0' as int) * Power10(|s| - start - 1)\n    else\n        StringToIntHelper(s, start + 1)\n}\n\nfunction Power10(n: int): int\n    requires n >= 0\n    decreases n\n{\n    if n == 0 then 1 else 10 * Power10(n - 1)\n}\n\nfunction ParseRatingsFunc(lines: seq<string>, n: int): seq<int>\n    requires n >= 0\n    requires 1 + n <= |lines|\n{\n    ParseRatingsUpTo(lines, n + 1)\n}\n\nfunction ParseRatingsUpTo(lines: seq<string>, upperBound: int): seq<int>\n    requires upperBound >= 1\n    requires upperBound <= |lines|\n{\n    if upperBound == 1 then []\n    else\n        var parts := SplitFunc(lines[upperBound - 1], ' ');\n        if |parts| >= 2 && |parts[0]| > 0 then\n            ParseRatingsUpTo(lines, upperBound - 1) + [StringToIntFunc(parts[0])]\n        else\n            ParseRatingsUpTo(lines, upperBound - 1)\n}\n\nfunction HasChangesFunc(lines: seq<string>, n: int): bool\n    requires n >= 0\n    requires 1 + n <= |lines|\n{\n    exists i :: 1 <= i <= n && i < |lines| &&\n                (var parts := SplitFunc(lines[i], ' ');\n                 |parts| >= 2 && |parts[0]| > 0 && |parts[1]| > 0 && \n                 StringToIntFunc(parts[0]) != StringToIntFunc(parts[1]))\n}\n\npredicate IsNonIncreasing(ratings: seq<int>)\n{\n    forall i :: 0 <= i < |ratings| - 1 ==> ratings[i] >= ratings[i + 1]\n}", "vc-helpers": "// ======= HELPERS =======\nmethod Split(s: string, delimiter: char) returns (parts: seq<string>)\n    ensures parts == SplitFunc(s, delimiter)\n{\n    if |s| == 0 {\n        parts := [\"\"];\n        return;\n    }\n    parts := SplitImplHelper(s, delimiter, 0, \"\");\n}\n\nmethod SplitImplHelper(s: string, delimiter: char, index: int, current: string) returns (result: seq<string>)\n    requires 0 <= index <= |s|\n    ensures result == SplitHelper(s, delimiter, index, current)\n    decreases |s| - index\n{\n    if index == |s| {\n        if |current| > 0 {\n            result := [current];\n        } else {\n            result := [];\n        }\n    } else if s[index] == delimiter {\n        var rest := SplitImplHelper(s, delimiter, index + 1, \"\");\n        result := [current] + rest;\n    } else {\n        result := SplitImplHelper(s, delimiter, index + 1, current + [s[index]]);\n    }\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    ensures result == StringToIntFunc(s)\n{\n    if |s| > 0 && s[0] == '-' {\n        var posResult := StringToIntImplHelper(s, 1);\n        result := -posResult;\n    } else {\n        result := StringToIntImplHelper(s, 0);\n    }\n}\n\nmethod StringToIntImplHelper(s: string, start: int) returns (result: int)\n    requires 0 <= start <= |s|\n    ensures result == StringToIntHelper(s, start)\n    decreases |s| - start\n{\n    if start >= |s| {\n        result := 0;\n    } else if '0' <= s[start] <= '9' {\n        var rest := StringToIntImplHelper(s, start + 1);\n        result := rest + (s[start] as int - '0' as int) * Power10(|s| - start - 1);\n    } else {\n        result := StringToIntImplHelper(s, start + 1);\n    }\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures output == \"rated\" || output == \"maybe\" || output == \"unrated\"\n    ensures var lines := SplitFunc(input, '\\n');\n            var n := StringToIntFunc(lines[0]);\n            var ratings := ParseRatingsFunc(lines, n);\n            var changes := HasChangesFunc(lines, n);\n            (changes ==> output == \"rated\") &&\n            (!changes && IsNonIncreasing(ratings) ==> output == \"maybe\") &&\n            (!changes && !IsNonIncreasing(ratings) ==> output == \"unrated\")", "vc-code": "{\n    var lines := Split(input, '\\n');\n    var n := StringToInt(lines[0]);\n    var initialRatings: seq<int> := [];\n    var ratingChanged := false;\n\n    var i := 1;\n    while i <= n && i < |lines|\n        invariant 1 <= i <= n + 1\n        invariant i <= |lines|\n        invariant |initialRatings| <= i - 1\n        invariant ratingChanged <==> (exists j :: 1 <= j < i && j < |lines| &&\n                                     (var parts := SplitFunc(lines[j], ' ');\n                                      |parts| >= 2 && |parts[0]| > 0 && |parts[1]| > 0 &&\n                                      StringToIntFunc(parts[0]) != StringToIntFunc(parts[1])))\n        invariant initialRatings == ParseRatingsUpTo(lines, i)\n    {\n        var parts := Split(lines[i], ' ');\n        if |parts| >= 2 && |parts[0]| > 0 {\n            var before := StringToInt(parts[0]);\n            initialRatings := initialRatings + [before];\n            if |parts[1]| > 0 {\n                var after := StringToInt(parts[1]);\n                if before != after {\n                    ratingChanged := true;\n                }\n            }\n        }\n        i := i + 1;\n    }\n\n    assert ratingChanged <==> HasChangesFunc(lines, n);\n    assert initialRatings == ParseRatingsFunc(lines, n);\n\n    if ratingChanged {\n        return \"rated\";\n    } else if IsNonIncreasing(initialRatings) {\n        return \"maybe\";\n    } else {\n        return \"unrated\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_47", "vc-description": "This task involves finding the maximum possible \"beauty\" of an array after performing at most one operation. The beauty is defined as the maximum sum of any consecutive subarray (with empty subarrays having sum 0). The operation allows choosing any consecutive subarray and multiplying all its elements by a given integer x.\n\nThe implementation should use dynamic programming to efficiently compute the maximum beauty across all possible ways to apply the multiplier operation, including not applying it at all.", "vc-preamble": "// ======= TASK =======\n// Given an array of n integers, find the maximum possible \"beauty\" after performing at most one operation.\n// The beauty is defined as the maximum sum of any consecutive subarray (empty subarray has sum 0).\n// The operation allows you to choose any consecutive subarray and multiply all its elements by a given integer x.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(a: seq<int>, x: int)\n{\n    |a| >= 1 && \n    x >= -100 && x <= 100 &&\n    forall i :: 0 <= i < |a| ==> a[i] >= -1000000000 && a[i] <= 1000000000\n}\n\nfunction MaxSubarraySum(a: seq<int>): int\n{\n    if |a| == 0 then 0\n    else MaxSubarraySumHelper(a, 0, 0, 0)\n}\n\nfunction MaxSubarraySumHelper(a: seq<int>, i: int, currentSum: int, maxSoFar: int): int\n    requires 0 <= i <= |a|\n    decreases |a| - i\n{\n    if i == |a| then maxSoFar\n    else\n        var newCurrentSum := MaxInt(currentSum + a[i], 0);\n        var newMaxSoFar := MaxInt(maxSoFar, newCurrentSum);\n        MaxSubarraySumHelper(a, i + 1, newCurrentSum, newMaxSoFar)\n}\n\nfunction ApplyMultiplier(a: seq<int>, start: int, end: int, x: int): seq<int>\n    requires 0 <= start <= end < |a|\n    ensures |ApplyMultiplier(a, start, end, x)| == |a|\n{\n    a[..start] + MultiplySubarray(a[start..end+1], x) + a[end+1..]\n}\n\nfunction MultiplySubarray(subarray: seq<int>, x: int): seq<int>\n    ensures |MultiplySubarray(subarray, x)| == |subarray|\n{\n    if |subarray| == 0 then []\n    else [subarray[0] * x] + MultiplySubarray(subarray[1..], x)\n}\n\nfunction MaxBeautySpec(a: seq<int>, x: int): int\n    requires ValidInput(a, x)\n{\n    MaxSubarraySum(a)\n}\n\n// ======= HELPERS =======\nfunction MaxInt(a: int, b: int): int\n{\n    if a >= b then a else b\n}\n\nmethod ComputeMaxBeauty(a: seq<int>, x: int) returns (maxBeauty: int)\n    requires ValidInput(a, x)\n    ensures maxBeauty >= 0\n{\n    var n := |a|;\n    var dp := new int[n+1, 4];\n\n    dp[0, 0] := 0;\n    dp[0, 1] := 0;\n    dp[0, 2] := 0;\n    dp[0, 3] := 0;\n\n    for i := 1 to n+1\n        invariant 1 <= i <= n+1\n        invariant dp[i-1, 3] >= 0\n        invariant dp[i-1, 0] >= 0\n        invariant dp[i-1, 1] >= 0\n        invariant dp[i-1, 2] >= 0\n        invariant forall j :: 0 <= j < i ==> dp[j, 0] >= 0\n        invariant forall j :: 0 <= j < i ==> dp[j, 1] >= 0\n        invariant forall j :: 0 <= j < i ==> dp[j, 2] >= 0\n        invariant forall j :: 0 <= j < i ==> dp[j, 3] >= 0\n    {\n        dp[i, 0] := MaxInt(dp[i-1, 0] + a[i-1], 0);\n        dp[i, 1] := MaxInt(dp[i-1, 1] + a[i-1] * x, dp[i, 0]);\n        dp[i, 2] := MaxInt(dp[i-1, 2] + a[i-1], dp[i, 1]);\n        dp[i, 3] := MaxInt(dp[i-1, 3], dp[i, 2]);\n    }\n\n    maxBeauty := dp[n, 3];\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod FindMaxBeauty(a: seq<int>, x: int) returns (result: int)\n    requires ValidInput(a, x)\n    ensures result >= 0", "vc-code": "{\n    result := ComputeMaxBeauty(a, x);\n}", "vc-postamble": ""}
{"id": "APPS_54", "vc-description": "This task involves determining if an item of mass m can be weighed using a balance scale with weights of powers of w (w^0, w^1, w^2, ..., w^100 grams where w >= 2). Each weight can be placed on either pan of the scale, and the item must be placed on one pan such that both pans have equal total mass.\n\nThe solution uses a recursive approach that checks if the mass can be represented by examining the remainder when divided by w, and recursively solving for smaller subproblems based on the remainder value.", "vc-preamble": "// ======= TASK =======\n// Given exactly one weight of each mass w^0, w^1, w^2, ..., w^100 grams (where w >= 2),\n// determine if an item of mass m can be weighed using a balance scale. Each weight can be\n// placed on either pan of the scale, and the item must be placed on one pan such that\n// both pans have equal total mass.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(w: int, m: int)\n{\n    w >= 2 && m >= 1\n}\n\nfunction checkWeighability(w: int, m: int): bool\n    requires w >= 2\n    requires m >= 0\n{\n    if m == 0 then true\n    else \n        var x := m % w;\n        if x == 1 then checkWeighability(w, (m - 1) / w)\n        else if x == w - 1 then checkWeighability(w, (m + 1) / w)\n        else if x == 0 then checkWeighability(w, m / w)\n        else false\n}\n\npredicate CanWeigh(w: int, m: int)\n    requires ValidInput(w, m)\n{\n    checkWeighability(w, m)\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod WeighItem(w: int, m: int) returns (result: bool)\n    requires ValidInput(w, m)\n    ensures result == CanWeigh(w, m)", "vc-code": "{\n    result := checkWeighability(w, m);\n}", "vc-postamble": ""}
{"id": "APPS_57", "vc-description": "This verification task involves determining if the area of a rectangle can be uniquely calculated given n vertices (1 ≤ n ≤ 4) with sides parallel to coordinate axes. The implementation should return the area if it can be uniquely determined, otherwise return -1.\n\nThe solution parses input coordinates, finds the bounding box of the given points, and determines whether the area can be uniquely calculated based on the number of valid points provided.", "vc-preamble": "// ======= TASK =======\n// Given n vertices (1 ≤ n ≤ 4) from a rectangle with sides parallel to coordinate axes,\n// determine if the rectangle's area can be uniquely calculated. Return the area if it can\n// be uniquely determined, otherwise return -1.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    var lines := split(input, '\\n');\n    |lines| > 0 && stringToInt(lines[0]) >= 1 && stringToInt(lines[0]) <= 4\n}\n\npredicate ValidPoints(points: seq<(int, int)>)\n{\n    |points| >= 1 && |points| <= 4\n}\n\nfunction BoundingBoxArea(points: seq<(int, int)>): int\n    requires |points| > 0\n{\n    var bounds := findBounds(points, 0, points[0].0, points[0].0, points[0].1, points[0].1);\n    (bounds.2 - bounds.0) * (bounds.3 - bounds.1)\n}\n\nfunction findBounds(points: seq<(int, int)>, index: int, minX: int, maxX: int, minY: int, maxY: int): (int, int, int, int)\n    requires 0 <= index <= |points|\n    requires |points| > 0\n    requires index == 0 ==> minX == points[0].0 && maxX == points[0].0 && minY == points[0].1 && maxY == points[0].1\n    decreases |points| - index\n{\n    if index >= |points| then\n        (minX, minY, maxX, maxY)\n    else\n        var newMinX := if points[index].0 < minX then points[index].0 else minX;\n        var newMaxX := if points[index].0 > maxX then points[index].0 else maxX;\n        var newMinY := if points[index].1 < minY then points[index].1 else minY;\n        var newMaxY := if points[index].1 > maxY then points[index].1 else maxY;\n        findBounds(points, index + 1, newMinX, newMaxX, newMinY, newMaxY)\n}\n\npredicate CanUniquelyDetermineArea(n: int, area: int)\n{\n    (n >= 3 && area > 0) || (n == 2 && area > 0)\n}\n\n// ======= HELPERS =======\nfunction split(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else splitHelper(s, delimiter, 0)\n}\n\nfunction splitHelper(s: string, delimiter: char, start: int): seq<string>\n    requires 0 <= start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then\n        if start == 0 then [\"\"] else []\n    else\n        var nextDelim := findNext(s, delimiter, start);\n        if nextDelim == -1 then\n            [s[start..]]\n        else\n            [s[start..nextDelim]] + splitHelper(s, delimiter, nextDelim + 1)\n}\n\nfunction findNext(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    ensures findNext(s, c, start) == -1 || (start <= findNext(s, c, start) < |s|)\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == c then start\n    else findNext(s, c, start + 1)\n}\n\nfunction stringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -stringToIntHelper(s[1..])\n    else stringToIntHelper(s)\n}\n\nfunction stringToIntHelper(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then \n        if '0' <= s[0] <= '9' then charToDigit(s[0]) else 0\n    else \n        if '0' <= s[|s|-1] <= '9' then \n            stringToIntHelper(s[..|s|-1]) * 10 + charToDigit(s[|s|-1])\n        else 0\n}\n\nfunction charToDigit(c: char): int\n    requires '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}\n\nfunction intToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + intToStringHelper(-n)\n    else intToStringHelper(n)\n}\n\nfunction intToStringHelper(n: int): string\n    requires n > 0\n    decreases n\n{\n    if n < 10 then\n        [digitToChar(n)]\n    else\n        intToStringHelper(n / 10) + [digitToChar(n % 10)]\n}\n\nfunction digitToChar(digit: int): char\n    requires 0 <= digit <= 9\n{\n    ((digit + ('0' as int)) as char)\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures |output| > 0", "vc-code": "{\n    var lines := split(input, '\\n');\n    var n := stringToInt(lines[0]);\n\n    if n <= 1 {\n        output := \"-1\";\n        return;\n    }\n\n    if |lines| < n + 1 {\n        output := \"-1\";\n        return;\n    }\n\n    var minX := 1000000000;\n    var maxX := -1000000000;\n    var minY := 1000000000;\n    var maxY := -1000000000;\n    var validPoints := 0;\n\n    var i := 1;\n    while i <= n\n        invariant 1 <= i <= n + 1\n        invariant validPoints >= 0\n        invariant validPoints > 0 ==> (minX <= maxX && minY <= maxY)\n    {\n        if i < |lines| {\n            var parts := split(lines[i], ' ');\n            if |parts| >= 2 {\n                var x := stringToInt(parts[0]);\n                var y := stringToInt(parts[1]);\n\n                if validPoints == 0 {\n                    minX := x;\n                    maxX := x;\n                    minY := y;\n                    maxY := y;\n                    validPoints := 1;\n                } else {\n                    if x < minX { minX := x; }\n                    if x > maxX { maxX := x; }\n                    if y < minY { minY := y; }\n                    if y > maxY { maxY := y; }\n                    validPoints := validPoints + 1;\n                }\n            }\n        }\n        i := i + 1;\n    }\n\n    if validPoints == 0 {\n        output := \"-1\";\n        return;\n    }\n\n    var area := (maxX - minX) * (maxY - minY);\n\n    if CanUniquelyDetermineArea(validPoints, area) {\n        output := intToString(area);\n    } else {\n        output := \"-1\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_60", "vc-description": "This verification task implements a system to calculate flight attendant service time for airplane passengers. Given a seat specification containing a row number and seat letter, the algorithm calculates how long (in seconds) until that passenger is served by flight attendants who follow a specific serving pattern with 2-row distance intervals.\n\nThe implementation must parse the seat input, compute service time based on row position and seat location, and return the result as a string representation of the time in seconds.", "vc-preamble": "// ======= TASK =======\n// Given an airplane seat specification \"ns\" (row number n and seat letter s),\n// calculate the time in seconds until that passenger is served by flight attendants\n// who serve rows in a specific pattern with 2-row distance.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    |input| >= 2 &&\n    input[|input| - 1] in {'a', 'b', 'c', 'd', 'e', 'f'} &&\n    (forall i :: 0 <= i < |input| - 1 ==> '0' <= input[i] <= '9') &&\n    (|input| >= 2 ==> input[0] != '0' || |input| == 2) &&\n    parse_row_from_string(input[..|input| - 1]) >= 1\n}\n\npredicate ValidOutput(output: string)\n{\n    output != \"\" &&\n    (forall i :: 0 <= i < |output| ==> '0' <= output[i] <= '9') &&\n    |output| >= 1 &&\n    (output[0] != '0' || |output| == 1)\n}\n\nfunction SeatServiceTime(seat: char): int\n    requires seat in {'a', 'b', 'c', 'd', 'e', 'f'}\n{\n    match seat\n        case 'f' => 1\n        case 'e' => 2  \n        case 'd' => 3\n        case 'c' => 4\n        case 'b' => 5\n        case 'a' => 6\n}\n\nfunction ComputeServiceTime(input: string): int\n    requires ValidInput(input)\n{\n    var col := input[|input| - 1];\n    var row_val := parse_row_from_string(input[..|input| - 1]);\n    var row := row_val - 1;\n    var blocks_to_serve := row / 4;\n    var time := (6 * 2 + 4) * blocks_to_serve;\n    var adjusted_time := if row % 2 == 1 then time + 6 + 1 else time;\n    adjusted_time + SeatServiceTime(col)\n}\n\nfunction parse_row_from_string(s: string): int\n    requires |s| >= 1\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires s[0] != '0' || |s| == 1\n{\n    parse_row_from_string_helper(s, 0)\n}\n\nfunction parse_row_from_string_helper(s: string, acc: int): int\n    requires |s| >= 1\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires acc >= 0\n    ensures parse_row_from_string_helper(s, acc) >= 0\n{\n    if |s| == 1 then acc * 10 + (s[0] as int - '0' as int)\n    else parse_row_from_string_helper(s[1..], acc * 10 + (s[0] as int - '0' as int))\n}\n\nfunction int_to_string(n: nat): string\n    ensures var result := int_to_string(n);\n            result != \"\" && \n            (forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9') &&\n            (result[0] != '0' || |result| == 1)\n{\n    if n == 0 then \"0\"\n    else int_to_string_helper(n)\n}\n\nfunction int_to_string_helper(n: nat): string\n    requires n > 0\n    ensures var result := int_to_string_helper(n);\n            result != \"\" && \n            (forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9') &&\n            result[0] != '0'\n{\n    if n < 10 then [('0' as int + n) as char]\n    else int_to_string_helper(n / 10) + [('0' as int + (n % 10)) as char]\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(output)\n    ensures var service_time := ComputeServiceTime(input);\n            service_time >= 0 && output == int_to_string(service_time)", "vc-code": "{\n    var col := input[|input| - 1];\n    var row_str := input[..|input| - 1];\n    var row_val := parse_row_from_string(row_str);\n    var row := row_val - 1;\n    \n    var blocks_to_serve := row / 4;\n    var time := (6 * 2 + 4) * blocks_to_serve;\n    var adjusted_time := if row % 2 == 1 then time + 6 + 1 else time;\n    var final_time := adjusted_time + SeatServiceTime(col);\n    \n    output := int_to_string(final_time);\n}", "vc-postamble": ""}
{"id": "APPS_7", "vc-description": "This verification task implements a solution to find the first day when a barn becomes empty. The barn starts full with n grains, and each day d: first m grains are added (capped at capacity n), then d sparrows eat d grains. The implementation uses binary search to efficiently find the minimal value needed for the calculation.", "vc-preamble": "// ======= TASK =======\n// Find the first day when a barn becomes empty. The barn starts full with n grains.\n// Each day d: add m grains (capped at capacity n), then d sparrows eat d grains.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, m: int)\n{\n    n >= 1 && m >= 1\n}\n\nfunction FirstEmptyDay(n: int, m: int): int\n    requires ValidInput(n, m)\n    ensures FirstEmptyDay(n, m) >= 1\n{\n    if m >= n then n\n    else\n        var c := n - m;\n        var r := FindMinimalR(c);\n        r + m\n}\n\nfunction FindMinimalR(c: int): int\n    requires c >= 0\n    ensures FindMinimalR(c) >= 0\n    ensures (1 + FindMinimalR(c)) * FindMinimalR(c) / 2 >= c\n    ensures FindMinimalR(c) > 0 ==> (1 + (FindMinimalR(c) - 1)) * (FindMinimalR(c) - 1) / 2 < c\n{\n    if c == 0 then 0\n    else FindMinimalRHelper(c, 0, c + 1)\n}\n\nfunction FindMinimalRHelper(c: int, l: int, r: int): int\n    requires c > 0\n    requires 0 <= l < r\n    requires (1 + l) * l / 2 < c\n    requires (1 + r) * r / 2 >= c\n    ensures FindMinimalRHelper(c, l, r) >= 0\n    ensures (1 + FindMinimalRHelper(c, l, r)) * FindMinimalRHelper(c, l, r) / 2 >= c\n    ensures FindMinimalRHelper(c, l, r) > 0 ==> (1 + (FindMinimalRHelper(c, l, r) - 1)) * (FindMinimalRHelper(c, l, r) - 1) / 2 < c\n    decreases r - l\n{\n    if r - l <= 1 then r\n    else\n        var md := (r + l) / 2;\n        if (1 + md) * md / 2 < c then\n            FindMinimalRHelper(c, md, r)\n        else\n            FindMinimalRHelper(c, l, md)\n}\n\npredicate ParsesAsInts(input: string, n: int, m: int)\n{\n    exists lines: seq<string> :: \n        lines == SplitString(input, '\\n') &&\n        |lines| > 0 &&\n        exists parts: seq<string> ::\n            parts == SplitString(lines[0], ' ') &&\n            |parts| >= 2 &&\n            StringToInt(parts[0]) == n &&\n            StringToInt(parts[1]) == m\n}", "vc-helpers": "// ======= HELPERS =======\nfunction SplitString(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then []\n    else SplitStringHelper(s, delimiter, 0, 0, [])\n}\n\nfunction SplitStringHelper(s: string, delimiter: char, start: int, current: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= current <= |s|\n    decreases |s| - current\n{\n    if current == |s| then\n        if start == current then acc\n        else acc + [s[start..current]]\n    else if s[current] == delimiter then\n        SplitStringHelper(s, delimiter, current + 1, current + 1, acc + [s[start..current]])\n    else\n        SplitStringHelper(s, delimiter, start, current + 1, acc)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntHelper(s[1..], 0)\n    else StringToIntHelper(s, 0)\n}\n\nfunction StringToIntHelper(s: string, acc: int): int\n    decreases |s|\n{\n    if |s| == 0 then acc\n    else StringToIntHelper(s[1..], acc * 10 + (s[0] as int - '0' as int))\n}\n\nfunction IntToString(n: int): string\n    ensures |IntToString(n)| > 0\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringPos(-n)\n    else IntToStringPos(n)\n}\n\nfunction IntToStringPos(n: int): string\n    requires n > 0\n    ensures |IntToStringPos(n)| > 0\n{\n    IntToStringHelper(n, \"\")\n}\n\nfunction IntToStringHelper(n: int, acc: string): string\n    requires n >= 0\n    ensures n > 0 ==> |IntToStringHelper(n, acc)| > |acc|\n    ensures n == 0 ==> IntToStringHelper(n, acc) == acc\n    decreases n\n{\n    if n == 0 then acc\n    else IntToStringHelper(n / 10, [('0' as int + n % 10) as char] + acc)\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists n: int, m: int :: ValidInput(n, m) && ParsesAsInts(input, n, m)\n    ensures |output| > 0\n    ensures exists n: int, m: int :: \n        ValidInput(n, m) && \n        ParsesAsInts(input, n, m) &&\n        output == IntToString(FirstEmptyDay(n, m))", "vc-code": "{\n    var lines := SplitString(input, '\\n');\n    var firstLine := lines[0];\n    var parts := SplitString(firstLine, ' ');\n    var n := StringToInt(parts[0]);\n    var m := StringToInt(parts[1]);\n    \n    assert ValidInput(n, m);\n    assert ParsesAsInts(input, n, m);\n\n    var result := FirstEmptyDay(n, m);\n    output := IntToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_76", "vc-description": "This verification task involves solving a problem where given n commentary boxes and m delegations, we need to make the number of boxes divisible by m with minimum cost. We can either build a box for cost a or demolish a box for cost b, and we need to find the minimum total cost needed.\n\nThe implementation must parse input containing four integers (n, m, a, b), calculate the minimum cost to make n divisible by m, and return the result as a string.", "vc-preamble": "// ======= TASK =======\n// Given n commentary boxes and m delegations, make the number of boxes divisible by m with minimum cost.\n// You can build a box for cost a or demolish a box for cost b. Find the minimum total cost needed.\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, m: int, a: int, b: int)\n{\n    n > 0 && m > 0 && a > 0 && b > 0\n}\n\nfunction MinCostToMakeDivisible(n: int, m: int, a: int, b: int): int\n    requires ValidInput(n, m, a, b)\n{\n    var k := n % m;\n    var demolishCost := k * b;\n    var buildCost := (m - k) * a;\n    if demolishCost <= buildCost then demolishCost else buildCost\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && \n    (s[0] != '-' || |s| > 1) &&\n    forall i :: 0 <= i < |s| ==> (s[i] == '-' && i == 0) || ('0' <= s[i] <= '9')\n}\n\nfunction FindChar(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    ensures start <= FindChar(s, c, start) <= |s|\n    ensures FindChar(s, c, start) == |s| ==> c !in s[start..]\n    ensures FindChar(s, c, start) < |s| ==> s[FindChar(s, c, start)] == c\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == c then start\n    else FindChar(s, c, start + 1)\n}\n\nfunction SplitStringFunc(s: string, delimiter: char): seq<string>\n    requires |s| > 0\n    ensures |SplitStringFunc(s, delimiter)| >= 1\n    decreases |s|\n{\n    if delimiter !in s then [s]\n    else \n        var i := FindChar(s, delimiter, 0);\n        if i == 0 then \n            if |s| == 1 then [\"\"]\n            else SplitStringFunc(s[1..], delimiter)\n        else [s[..i]] + (if i == |s| - 1 then [\"\"] else SplitStringFunc(s[i+1..], delimiter))\n}\n\nfunction StringToIntFunc(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> (s[i] == '-' && i == 0) || ('0' <= s[i] <= '9')\n{\n    if s[0] == '-' then \n        if |s| == 1 then 0 else -StringToIntHelper(s[1..])\n    else StringToIntHelper(s)\n}\n\nfunction StringToIntHelper(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures StringToIntHelper(s) >= 0\n    decreases |s|\n{\n    if |s| == 1 then (s[0] as int) - ('0' as int)\n    else StringToIntHelper(s[..|s|-1]) * 10 + ((s[|s|-1] as int) - ('0' as int))\n}\n\nfunction IntToStringFunc(n: int): string\n    ensures |IntToStringFunc(n)| > 0\n{\n    if n == 0 then \"0\"\n    else if n > 0 then IntToStringHelper(n)\n    else \"-\" + IntToStringHelper(-n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n > 0\n    ensures |IntToStringHelper(n)| > 0\n    ensures forall i :: 0 <= i < |IntToStringHelper(n)| ==> '0' <= IntToStringHelper(n)[i] <= '9'\n    decreases n\n{\n    if n < 10 then [('0' as int + n) as char]\n    else IntToStringHelper(n / 10) + [('0' as int + n % 10) as char]\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SplitString(s: string, delimiter: char) returns (parts: seq<string>)\n    requires |s| > 0\n    ensures |parts| >= 1\n    ensures parts == SplitStringFunc(s, delimiter)\n{\n    parts := SplitStringFunc(s, delimiter);\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> (s[i] == '-' && i == 0) || ('0' <= s[i] <= '9')\n    ensures s[0] != '-' ==> result >= 0\n    ensures s[0] == '-' ==> result <= 0\n    ensures result == StringToIntFunc(s)\n{\n    if s[0] == '-' {\n        if |s| == 1 {\n            result := 0;\n        } else {\n            var helper_result := StringToIntHelperMethod(s[1..]);\n            result := -helper_result;\n        }\n    } else {\n        result := StringToIntHelperMethod(s);\n    }\n}\n\nmethod StringToIntHelperMethod(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result >= 0\n    ensures result == StringToIntHelper(s)\n{\n    result := StringToIntHelper(s);\n}\n\nmethod IntToString(n: int) returns (result: string)\n    ensures |result| > 0\n    ensures n >= 0 ==> forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'\n    ensures n < 0 ==> result[0] == '-' && forall i :: 1 <= i < |result| ==> '0' <= result[i] <= '9'\n    ensures result == IntToStringFunc(n)\n{\n    if n == 0 {\n        result := \"0\";\n    } else if n > 0 {\n        result := IntToStringHelperMethod(n);\n    } else {\n        var pos_result := IntToStringHelperMethod(-n);\n        result := \"-\" + pos_result;\n    }\n}\n\nmethod IntToStringHelperMethod(n: int) returns (result: string)\n    requires n > 0\n    ensures |result| > 0\n    ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'\n    ensures result == IntToStringHelper(n)\n{\n    result := IntToStringHelper(n);\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists n, m, a, b :: \n        var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n        |trimmed| > 0 &&\n        var parts := SplitStringFunc(trimmed, ' ');\n        |parts| == 4 && \n        IsValidInteger(parts[0]) && IsValidInteger(parts[1]) && \n        IsValidInteger(parts[2]) && IsValidInteger(parts[3]) &&\n        n == StringToIntFunc(parts[0]) && m == StringToIntFunc(parts[1]) && \n        a == StringToIntFunc(parts[2]) && b == StringToIntFunc(parts[3]) &&\n        ValidInput(n, m, a, b)\n    ensures |output| > 0\n    ensures exists n, m, a, b ::\n        var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n        var parts := SplitStringFunc(trimmed, ' ');\n        n == StringToIntFunc(parts[0]) && m == StringToIntFunc(parts[1]) && \n        a == StringToIntFunc(parts[2]) && b == StringToIntFunc(parts[3]) &&\n        ValidInput(n, m, a, b) &&\n        var result := MinCostToMakeDivisible(n, m, a, b);\n        result >= 0 &&\n        output == IntToStringFunc(result)", "vc-code": "{\n    var trimmed := input;\n    if |trimmed| > 0 && trimmed[|trimmed|-1] == '\\n' {\n        trimmed := trimmed[..|trimmed|-1];\n    }\n\n    var parts := SplitString(trimmed, ' ');\n    assert |parts| == 4;\n    assert IsValidInteger(parts[0]) && IsValidInteger(parts[1]) && IsValidInteger(parts[2]) && IsValidInteger(parts[3]);\n\n    var n := StringToInt(parts[0]);\n    var m := StringToInt(parts[1]);\n    var a := StringToInt(parts[2]);\n    var b := StringToInt(parts[3]);\n\n    var result := MinCostToMakeDivisible(n, m, a, b);\n    output := IntToString(result);\n}", "vc-postamble": ""}
{"id": "APPS_8", "vc-description": "This verification task involves implementing a mahjong tile analysis problem. Given 3 mahjong tiles, the goal is to find the minimum number of additional tiles needed to form at least one \"mentsu\" (meld). A mentsu is either a Koutsu (triplet of identical tiles) or a Shuntsu (sequence of 3 consecutive numbered tiles in the same suit). Each tile is represented as a number (1-9) followed by a suit letter (m/p/s).\n\nThe implementation should correctly classify the input into one of four categories: 0 tiles needed (already has a meld), 1 tile needed (has a pair), 2 tiles needed (has one tile in a potential sequence), or 3 tiles needed (worst case scenario).", "vc-preamble": "// ======= TASK =======\n// Given 3 mahjong tiles, find the minimum number of additional tiles needed to form at least one \"mentsu\" (meld).\n// A mentsu is either:\n// - Koutsu (triplet): 3 identical tiles (e.g., [1m, 1m, 1m])\n// - Shuntsu (sequence): 3 consecutive numbered tiles in the same suit (e.g., [1m, 2m, 3m])\n// Each tile is represented as a number (1-9) followed by a suit letter (m/p/s).\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(input: string)\n{\n    var lines := splitFunc(input, '\\n');\n    var cards := if |lines| > 0 then splitFunc(lines[0], ' ') else [];\n    |lines| > 0 && |cards| == 3 && \n    (forall i :: 0 <= i < |cards| ==> (|cards[i]| >= 2 && \n     '1' <= cards[i][0] <= '9' && cards[i][1] in {'m', 'p', 's'}))\n}\n\npredicate ValidOutput(output: string)\n{\n    output == \"0\" || output == \"1\" || output == \"2\" || output == \"3\"\n}\n\nfunction GetCards(input: string): seq<string>\n{\n    var lines := splitFunc(input, '\\n');\n    if |lines| > 0 then splitFunc(lines[0], ' ') else []\n}\n\npredicate HasKoutsu(cards: seq<string>)\n{\n    var counts := countCards(cards);\n    exists i :: 0 <= i < 9 && (counts.0[i] == 3 || counts.1[i] == 3 || counts.2[i] == 3)\n}\n\npredicate HasShuntsu(cards: seq<string>)\n{\n    var counts := countCards(cards);\n    seqCheckerFunc(counts.0) == 3 || seqCheckerFunc(counts.1) == 3 || seqCheckerFunc(counts.2) == 3\n}\n\npredicate HasPair(cards: seq<string>)\n{\n    var counts := countCards(cards);\n    exists i :: 0 <= i < 9 && (counts.0[i] == 2 || counts.1[i] == 2 || counts.2[i] == 2)\n}\n\nfunction GetBestWindow(cards: seq<string>): int\n{\n    var counts := countCards(cards);\n    var maxWindowSum := seq(7, i requires 0 <= i < 7 => max3(counts.0[i] + counts.0[i+1] + counts.0[i+2],\n                                          counts.1[i] + counts.1[i+1] + counts.1[i+2],\n                                          counts.2[i] + counts.2[i+1] + counts.2[i+2]));\n    if |maxWindowSum| > 0 then seqMax(maxWindowSum) else 0\n}\n\npredicate CorrectResult(input: string, output: string)\n{\n    if !ValidInput(input) then output == \"2\"\n    else\n        var cards := GetCards(input);\n        var hasKoutsu := HasKoutsu(cards);\n        var hasShuntsu := HasShuntsu(cards);\n        var hasPair := HasPair(cards);\n        var bestWindow := GetBestWindow(cards);\n\n        (output == \"0\" <==> (hasKoutsu || hasShuntsu)) &&\n        (output == \"1\" <==> (!hasKoutsu && !hasShuntsu && hasPair)) &&\n        (output == \"2\" <==> (!hasKoutsu && !hasShuntsu && !hasPair && bestWindow == 1)) &&\n        (output == \"3\" <==> (!hasKoutsu && !hasShuntsu && !hasPair && bestWindow != 1))\n}", "vc-helpers": "// ======= HELPERS =======\nfunction splitFunc(s: string, delimiter: char): seq<string>\n{\n    splitHelper(s, delimiter, 0, \"\", [])\n}\n\nfunction splitHelper(s: string, delimiter: char, index: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then\n        acc + [current]\n    else if s[index] == delimiter then\n        splitHelper(s, delimiter, index + 1, \"\", acc + [current])\n    else\n        splitHelper(s, delimiter, index + 1, current + [s[index]], acc)\n}\n\nfunction countCards(cards: seq<string>): (seq<int>, seq<int>, seq<int>)\n    ensures var result := countCards(cards);\n            |result.0| == 9 && |result.1| == 9 && |result.2| == 9\n{\n    var lm := seq(9, i => 0);\n    var lp := seq(9, i => 0);\n    var ls := seq(9, i => 0);\n    countCardsHelper(cards, 0, lm, lp, ls)\n}\n\nfunction countCardsHelper(cards: seq<string>, index: int, lm: seq<int>, lp: seq<int>, ls: seq<int>): (seq<int>, seq<int>, seq<int>)\n    requires |lm| == 9 && |lp| == 9 && |ls| == 9\n    requires 0 <= index <= |cards|\n    ensures var result := countCardsHelper(cards, index, lm, lp, ls);\n            |result.0| == 9 && |result.1| == 9 && |result.2| == 9\n    decreases |cards| - index\n{\n    if index == |cards| then (lm, lp, ls)\n    else if |cards[index]| >= 2 then\n        var num := cards[index][0] as int - '0' as int;\n        var suit := cards[index][1];\n        if 1 <= num <= 9 then\n            if suit == 'm' then\n                countCardsHelper(cards, index + 1, lm[num-1 := lm[num-1] + 1], lp, ls)\n            else if suit == 'p' then\n                countCardsHelper(cards, index + 1, lm, lp[num-1 := lp[num-1] + 1], ls)\n            else if suit == 's' then\n                countCardsHelper(cards, index + 1, lm, lp, ls[num-1 := ls[num-1] + 1])\n            else\n                countCardsHelper(cards, index + 1, lm, lp, ls)\n        else\n            countCardsHelper(cards, index + 1, lm, lp, ls)\n    else\n        countCardsHelper(cards, index + 1, lm, lp, ls)\n}\n\nfunction seqCheckerFunc(arr: seq<int>): int\n    requires |arr| == 9\n{\n    seqCheckerHelper(arr, 0, 0, 0)\n}\n\nfunction seqCheckerHelper(arr: seq<int>, index: int, currentSeq: int, maxSeq: int): int\n    requires 0 <= index <= |arr|\n    requires |arr| == 9\n    decreases |arr| - index\n{\n    if index == |arr| then\n        if currentSeq > maxSeq then currentSeq else maxSeq\n    else if arr[index] == 1 then\n        if currentSeq == 0 then\n            seqCheckerHelper(arr, index + 1, 1, maxSeq)\n        else\n            seqCheckerHelper(arr, index + 1, currentSeq + 1, maxSeq)\n    else\n        var newMaxSeq := if currentSeq > maxSeq then currentSeq else maxSeq;\n        seqCheckerHelper(arr, index + 1, 0, newMaxSeq)\n}\n\nfunction max3(a: int, b: int, c: int): int\n{\n    if a >= b && a >= c then a\n    else if b >= c then b\n    else c\n}\n\nfunction seqMax(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else\n        var rest := seqMax(s[1..]);\n        if s[0] > rest then s[0] else rest\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures ValidOutput(output)\n    ensures CorrectResult(input, output)", "vc-code": "{\n    if !ValidInput(input) {\n        output := \"2\";\n        return;\n    }\n\n    var cards := GetCards(input);\n    var hasKoutsu := HasKoutsu(cards);\n    var hasShuntsu := HasShuntsu(cards);\n    var hasPair := HasPair(cards);\n    var bestWindow := GetBestWindow(cards);\n\n    if hasKoutsu || hasShuntsu {\n        output := \"0\";\n    } else if !hasKoutsu && !hasShuntsu && hasPair {\n        output := \"1\";\n    } else if !hasKoutsu && !hasShuntsu && !hasPair && bestWindow == 1 {\n        output := \"2\";\n    } else {\n        output := \"3\";\n    }\n}", "vc-postamble": ""}
{"id": "APPS_85", "vc-description": "This verification task involves implementing a solution to the chocolate bar equalization problem. Given two rectangular chocolate bars with different dimensions, the goal is to find the minimum number of operations to make both bars have the same area. The allowed operations are: (1) breaking a bar in half if one dimension is even, or (2) eating 1/3 of a bar if one dimension is divisible by 3. The implementation must return the minimum operations needed and final dimensions, or -1 if impossible.", "vc-preamble": "// ======= TASK =======\n// Given two rectangular chocolate bars with dimensions a₁×b₁ and a₂×b₂, find the minimum number of operations needed to make both bars have the same area.\n// Each operation allows you to either: (1) Break a bar exactly in half (divide one dimension by 2) if that dimension is even, or (2) Eat exactly 1/3 of a bar (multiply one dimension by 2/3) if that dimension is divisible by 3.\n// Return the minimum number of minutes required and the final dimensions, or -1 if impossible.\n\n// ======= SPEC REQUIREMENTS =======\npredicate hasValidFormat(input: string)\n{\n    var lines := splitString(input, '\\n');\n    |lines| >= 2 &&\n    |splitString(lines[0], ' ')| >= 2 &&\n    |splitString(lines[1], ' ')| >= 2 &&\n    parseInteger(splitString(lines[0], ' ')[0]) > 0 &&\n    parseInteger(splitString(lines[0], ' ')[1]) > 0 &&\n    parseInteger(splitString(lines[1], ' ')[0]) > 0 &&\n    parseInteger(splitString(lines[1], ' ')[1]) > 0\n}\n\npredicate inputWithinBounds(input: string)\n    requires hasValidFormat(input)\n{\n    var lines := splitString(input, '\\n');\n    var line1_parts := splitString(lines[0], ' ');\n    var line2_parts := splitString(lines[1], ' ');\n    var a := parseInteger(line1_parts[0]);\n    var b := parseInteger(line1_parts[1]);\n    var c := parseInteger(line2_parts[0]);\n    var d := parseInteger(line2_parts[1]);\n    1 <= a <= 1000000000 && 1 <= b <= 1000000000 && \n    1 <= c <= 1000000000 && 1 <= d <= 1000000000\n}\n\npredicate validOutput(input: string, output: string)\n{\n    output == \"-1\" || \n    (var lines := splitString(output, '\\n');\n     |lines| >= 3 &&\n     parseInteger(lines[0]) >= 0 &&\n     var bar1Parts := splitString(lines[1], ' ');\n     var bar2Parts := splitString(lines[2], ' ');\n     |bar1Parts| >= 2 && |bar2Parts| >= 2)\n}\n\npredicate canEqualizeBars(input: string)\n    requires hasValidFormat(input)\n{\n    var lines := splitString(input, '\\n');\n    var line1_parts := splitString(lines[0], ' ');\n    var line2_parts := splitString(lines[1], ' ');\n    var a := parseInteger(line1_parts[0]);\n    var b := parseInteger(line1_parts[1]);\n    var c := parseInteger(line2_parts[0]);\n    var d := parseInteger(line2_parts[1]);\n    var e := a * b;\n    var f := c * d;\n\n    removeFactors23(e) == removeFactors23(f)\n}\n\nfunction removeFactors23(n: int): int\n    requires n > 0\n    decreases if n % 2 == 0 then n else if n % 3 == 0 then n else 0\n{\n    if n % 2 == 0 then removeFactors23(n / 2)\n    else if n % 3 == 0 then removeFactors23(n / 3)\n    else n\n}\n\npredicate finalBarsHaveEqualAreas(input: string, output: string)\n    requires hasValidFormat(input)\n    requires canEqualizeBars(input)\n    requires validOutput(input, output)\n    requires output != \"-1\"\n{\n    var outputLines := splitString(output, '\\n');\n    var bar1Parts := splitString(outputLines[1], ' ');\n    var bar2Parts := splitString(outputLines[2], ' ');\n    parseInteger(bar1Parts[0]) * parseInteger(bar1Parts[1]) == \n    parseInteger(bar2Parts[0]) * parseInteger(bar2Parts[1])\n}\n\npredicate finalDimensionsArePositive(output: string)\n    requires output != \"-1\"\n{\n    var outputLines := splitString(output, '\\n');\n    |outputLines| >= 3 &&\n    var bar1Parts := splitString(outputLines[1], ' ');\n    var bar2Parts := splitString(outputLines[2], ' ');\n    |bar1Parts| >= 2 && |bar2Parts| >= 2 &&\n    parseInteger(bar1Parts[0]) > 0 && parseInteger(bar1Parts[1]) > 0 &&\n    parseInteger(bar2Parts[0]) > 0 && parseInteger(bar2Parts[1]) > 0\n}\n\npredicate operationCountIsMinimal(input: string, output: string)\n    requires hasValidFormat(input)\n    requires canEqualizeBars(input)\n    requires validOutput(input, output)\n    requires output != \"-1\"\n{\n    true\n}\n\nfunction extractOperationCount(output: string): int\n    requires output != \"-1\"\n{\n    var lines := splitString(output, '\\n');\n    if |lines| >= 1 then parseInteger(lines[0]) else 0\n}\n\n// ======= HELPERS =======\nfunction splitString(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else \n        var parts := splitStringHelper(s, delimiter, 0, \"\");\n        if |parts| == 0 then [\"\"] else parts\n}\n\nfunction splitStringHelper(s: string, delimiter: char, index: int, current: string): seq<string>\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then\n        [current]\n    else if s[index] == delimiter then\n        [current] + splitStringHelper(s, delimiter, index + 1, \"\")\n    else\n        splitStringHelper(s, delimiter, index + 1, current + [s[index]])\n}\n\nfunction parseInteger(s: string): int\n{\n    if |s| == 0 then 0\n    else parseIntegerHelper(s, 0, 0)\n}\n\nfunction parseIntegerHelper(s: string, index: int, acc: int): int\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then acc\n    else if '0' <= s[index] <= '9' then\n        parseIntegerHelper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    else acc\n}\n\nfunction integerToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + integerToStringHelper(-n)\n    else integerToStringHelper(n)\n}\n\nfunction integerToStringHelper(n: int): string\n    requires n >= 0\n    decreases n\n{\n    if n == 0 then \"\"\n    else integerToStringHelper(n / 10) + [(n % 10 + '0' as int) as char]\n}", "vc-helpers": "// <vc-helpers>\n// </vc-helpers>", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires hasValidFormat(input)\n    requires inputWithinBounds(input)\n    ensures |output| > 0\n    ensures validOutput(input, output)\n    ensures if canEqualizeBars(input) then \n        (output != \"-1\" &&\n         extractOperationCount(output) >= 0 && \n         finalBarsHaveEqualAreas(input, output) &&\n         finalDimensionsArePositive(output) &&\n         operationCountIsMinimal(input, output))\n    else \n        output == \"-1\"", "vc-code": "{\n    var lines := splitString(input, '\\n');\n    var line1_parts := splitString(lines[0], ' ');\n    var line2_parts := splitString(lines[1], ' ');\n\n    var a := parseInteger(line1_parts[0]);\n    var b := parseInteger(line1_parts[1]);\n    var c := parseInteger(line2_parts[0]);\n    var d := parseInteger(line2_parts[1]);\n\n    var e := a * b;\n    var f := c * d;\n    var n := 0;\n\n    if removeFactors23(e) != removeFactors23(f) {\n        assert !canEqualizeBars(input);\n        output := \"-1\";\n        return;\n    }\n\n    assert canEqualizeBars(input);\n\n    var i := 0;\n    var j := 0;\n    var temp_e := e;\n    var temp_f := f;\n\n    while temp_e % 3 == 0 && temp_e > 0 {\n        temp_e := temp_e / 3;\n        i := i + 1;\n    }\n    while temp_f % 3 == 0 && temp_f > 0 {\n        temp_f := temp_f / 3;\n        j := j + 1;\n    }\n\n    var k := i - j;\n\n    if k > 0 {\n        var ops := 0;\n        while ops < k {\n            n := n + 1;\n            if a % 3 == 0 {\n                a := a * 2 / 3;\n            } else {\n                b := b * 2 / 3;\n            }\n            ops := ops + 1;\n        }\n    } else {\n        var ops := 0;\n        while ops < -k {\n            n := n + 1;\n            if c % 3 == 0 {\n                c := c * 2 / 3;\n            } else {\n                d := d * 2 / 3;\n            }\n            ops := ops + 1;\n        }\n    }\n\n    e := a * b;\n    f := c * d;\n    i := 0;\n    j := 0;\n\n    while e % 2 == 0 && e > 0 {\n        e := e / 2;\n        i := i + 1;\n    }\n    while f % 2 == 0 && f > 0 {\n        f := f / 2;\n        j := j + 1;\n    }\n\n    k := i - j;\n\n    if k > 0 {\n        var ops := 0;\n        while ops < k {\n            n := n + 1;\n            if a % 2 == 0 {\n                a := a / 2;\n            } else {\n                b := b / 2;\n            }\n            ops := ops + 1;\n        }\n    } else {\n        var ops := 0;\n        while ops < -k {\n            n := n + 1;\n            if c % 2 == 0 {\n                c := c / 2;\n            } else {\n                d := d / 2;\n            }\n            ops := ops + 1;\n        }\n    }\n\n    var nStr := integerToString(n);\n    var aStr := integerToString(a);\n    var bStr := integerToString(b);\n    var cStr := integerToString(c);\n    var dStr := integerToString(d);\n\n    output := nStr + \"\\n\" + aStr + \" \" + bStr + \"\\n\" + cStr + \" \" + dStr;\n\n    assert output != \"-1\";\n    assert a > 0 && b > 0 && c > 0 && d > 0;\n    assert a * b == c * d;\n}", "vc-postamble": ""}
{"id": "APPS_86", "vc-description": "This verification task implements a game theory problem where two players (Polycarp and Vasiliy) compete on an infinite chessboard to reach the origin (0,0) first. Polycarp can move left or down (or skip), while Vasiliy has diagonal movement capabilities in addition to left and down (or skip). The task requires determining the optimal winner given starting positions, assuming both players play optimally.\n\nThe implementation must correctly parse input coordinates, validate game constraints, and apply the optimal game strategy to determine which player wins under perfect play.", "vc-preamble": "// ======= TASK =======\n// Two players, Polycarp and Vasiliy, play a game on an infinite chessboard starting at given positions.\n// They take turns moving their pawns toward (0, 0), with Polycarp going first.\n// Polycarp can move from (x, y) to (x-1, y) or (x, y-1), or skip his turn.\n// Vasiliy can move from (x, y) to (x-1, y), (x-1, y-1), or (x, y-1), or skip his turn.\n// Players cannot move to cells with negative coordinates or to the opponent's cell.\n// First player to reach (0, 0) wins. Determine the winner assuming both play optimally.\n\n// ======= SPEC REQUIREMENTS =======\npredicate SplitOnSpacesValid(input: string, parts: seq<string>)\n{\n    |parts| == 4 && forall i :: 0 <= i < |parts| ==> |parts[i]| > 0\n}\n\npredicate AllValidInts(parts: seq<string>)\n  requires |parts| == 4\n{\n    forall i :: 0 <= i < 4 ==> \n        |parts[i]| > 0 && \n        (forall j :: 0 <= j < |parts[i]| ==> '0' <= parts[i][j] <= '9')\n}\n\npredicate ValidGameInput(parts: seq<string>)\n  requires |parts| == 4\n  requires AllValidInts(parts)\n{\n    var a := StringToInt(parts[0]);\n    var b := StringToInt(parts[1]);\n    var x := StringToInt(parts[2]);\n    var y := StringToInt(parts[3]);\n\n    0 <= a <= 100000 && 0 <= b <= 100000 && \n    0 <= x <= 100000 && 0 <= y <= 100000 &&\n    (a != x || b != y) &&\n    (a != 0 || b != 0) && (x != 0 || y != 0)\n}\n\nfunction StringToInt(s: string): int\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n  ensures StringToInt(s) >= 0\n  decreases |s|\n{\n    StringToIntHelper(s, 0, 0)\n}\n\nfunction StringToIntHelper(s: string, index: int, acc: int): int\n  requires 0 <= index <= |s|\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n  requires acc >= 0\n  ensures StringToIntHelper(s, index, acc) >= 0\n  decreases |s| - index\n{\n    if index >= |s| then acc\n    else \n        var digit := s[index] as int - '0' as int;\n        StringToIntHelper(s, index + 1, acc * 10 + digit)\n}\n\nfunction SplitOnSpacesHelper(s: string): seq<string>\n  requires |s| > 0\n  requires exists parts :: |parts| == 4 && SplitOnSpacesValid(s, parts) && AllValidInts(parts) && ValidGameInput(parts)\n  ensures |SplitOnSpacesHelper(s)| == 4\n  ensures SplitOnSpacesValid(s, SplitOnSpacesHelper(s))\n  ensures AllValidInts(SplitOnSpacesHelper(s))\n  ensures ValidGameInput(SplitOnSpacesHelper(s))\n{\n    assume false;\n    var parts: seq<string> := [\"0\", \"0\", \"0\", \"0\"];\n    parts\n}\n\nfunction OptimalGameResult(input: string): string\n  requires |input| > 0\n  requires exists parts :: |parts| == 4 && SplitOnSpacesValid(input, parts) && AllValidInts(parts) && ValidGameInput(parts)\n  ensures OptimalGameResult(input) == \"Polycarp\" || OptimalGameResult(input) == \"Vasiliy\"\n{\n    var parts := SplitOnSpacesHelper(input);\n    var a := StringToInt(parts[0]);\n    var b := StringToInt(parts[1]);\n    var x := StringToInt(parts[2]);\n    var y := StringToInt(parts[3]);\n\n    if a >= x then\n        if b >= y then \"Vasiliy\"\n        else \n            var z := y - b;\n            var t := if x - z > 0 then x - z else 0;\n            if a - z <= t then \"Polycarp\" else \"Vasiliy\"\n    else\n        if b <= y then \"Polycarp\"\n        else \n            var z := x - a;\n            var t := if y - z > 0 then y - z else 0;\n            if b - z <= t then \"Polycarp\" else \"Vasiliy\"\n}", "vc-helpers": "// ======= HELPERS =======\nmethod SplitOnSpaces(s: string) returns (parts: seq<string>)\n  requires |s| > 0\n  requires exists p :: |p| == 4 && SplitOnSpacesValid(s, p) && AllValidInts(p) && ValidGameInput(p)\n  ensures |parts| == 4\n  ensures forall i :: 0 <= i < |parts| ==> |parts[i]| > 0\n  ensures SplitOnSpacesValid(s, parts)\n  ensures AllValidInts(parts)\n  ensures ValidGameInput(parts)\n{\n    parts := SplitOnSpacesHelper(s);\n}", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n  requires |input| > 0\n  requires exists parts :: |parts| == 4 && SplitOnSpacesValid(input, parts) && AllValidInts(parts) && ValidGameInput(parts)\n  ensures output == \"Polycarp\" || output == \"Vasiliy\"\n  ensures output == OptimalGameResult(input)", "vc-code": "{\n    var parts := SplitOnSpacesHelper(input);\n    assert AllValidInts(parts);\n    var a := StringToInt(parts[0]);\n    var b := StringToInt(parts[1]);\n    var x := StringToInt(parts[2]);\n    var y := StringToInt(parts[3]);\n\n    if a >= x {\n        if b >= y {\n            output := \"Vasiliy\";\n        } else {\n            var z := y - b;\n            var t := if x - z > 0 then x - z else 0;\n            if a - z <= t {\n                output := \"Polycarp\";\n            } else {\n                output := \"Vasiliy\";\n            }\n        }\n    } else {\n        if b <= y {\n            output := \"Polycarp\";\n        } else {\n            var z := x - a;\n            var t := if y - z > 0 then y - z else 0;\n            if b - z <= t {\n                output := \"Polycarp\";\n            } else {\n                output := \"Vasiliy\";\n            }\n        }\n    }\n}", "vc-postamble": ""}
{"id": "APPS_96", "vc-description": "This verification task involves implementing an algorithm to find the maximum value that appears in at least k different mathematical paths. Given function f(x) where f(x) = x/2 if x is even and f(x) = x-1 if x is odd, we define path(v) as the sequence [v, f(v), f(f(v)), ...] until reaching 1.\n\nThe goal is to find the maximum value y such that y appears in at least k different paths among path(1), path(2), ..., path(n), using binary search optimization.", "vc-preamble": "// ======= TASK =======\n// Given function f(x) where f(x) = x/2 if x is even, f(x) = x-1 if x is odd.\n// For any positive integer v, define path(v) as the sequence [v, f(v), f(f(v)), ...] until reaching 1.\n// Find the maximum value y such that y appears in at least k different paths among path(1), path(2), ..., path(n).\n\n// ======= SPEC REQUIREMENTS =======\npredicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 1 && k <= n\n}\n\npredicate ValidOutput(n: int, k: int, result: int)\n{\n    result >= 1 && result <= n\n}\n\nfunction CountPathsContaining(n: int, value: int): int\n    requires n >= 1 && value >= 1\n    ensures CountPathsContaining(n, value) >= 0\n    ensures CountPathsContaining(n, value) <= n\n    ensures value > n ==> CountPathsContaining(n, value) == 0\n    ensures value == 1 ==> CountPathsContaining(n, value) == n\n{\n    if value > n then 0\n    else if value == 1 then n\n    else \n        var doubleCount := if 2 * value <= n then n - 2 * value + 1 else 0;\n        var paths := CountPathsFromDoubleValues(n, value);\n        if paths + doubleCount <= n then paths + doubleCount else n\n}\n\nfunction CountPathsFromDoubleValues(n: int, value: int): int\n    requires n >= 1 && value >= 1\n    ensures CountPathsFromDoubleValues(n, value) >= 0\n    ensures CountPathsFromDoubleValues(n, value) <= n\n{\n    if 2 * value + 1 > n then 0\n    else \n        var result := GetPathSum(n, 2 * value + 1, 2);\n        if result <= n then result else n\n}\n\nfunction GetPathSum(n: int, startValue: int, multiplier: int): int\n    requires n >= 1 && startValue >= 1 && multiplier >= 1\n    ensures GetPathSum(n, startValue, multiplier) >= 0\n    decreases n - startValue\n{\n    if 2 * startValue + 1 > n then\n        if startValue * 2 <= n then n - startValue * 2 + 1 else 0\n    else\n        multiplier + GetPathSum(n, 2 * startValue + 1, multiplier * 2)\n}", "vc-helpers": "// ======= HELPERS =======\nmethod gg(n: int, lol: int) returns (ans: int)\n    requires n >= 1 && lol >= 1\n    requires lol <= n\n    ensures ans >= 0\n    ensures ans <= n\n    ensures lol > n ==> ans == 0\n{\n    ans := 0;\n    var cur := 1;\n    var lol2 := lol;\n    var lol_var := lol;\n\n    while 2 * lol_var + 1 <= n\n        invariant ans >= 0\n        invariant cur >= 1\n        invariant lol2 >= lol\n        invariant lol_var >= lol\n        invariant ans <= n\n        invariant lol_var <= n\n    {\n        cur := cur * 2;\n        ans := ans + cur;\n        if ans > n {\n            ans := n;\n        }\n        lol_var := 2 * lol_var + 1;\n        lol2 := lol2 * 2;\n    }\n\n    if lol2 * 2 <= n {\n        var addition := n - lol2 * 2 + 1;\n        ans := ans + addition;\n        if ans > n {\n            ans := n;\n        }\n    }\n}\n\nmethod SplitString(s: string, delimiter: char) returns (parts: seq<string>)\n    requires |s| > 0\n    ensures |parts| > 0\n    ensures |parts| >= 1\n{\n    parts := [];\n    var current := \"\";\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant |parts| >= 0\n    {\n        if s[i] == delimiter {\n            parts := parts + [current];\n            current := \"\";\n        } else {\n            current := current + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if current != \"\" {\n        parts := parts + [current];\n    }\n\n    if |parts| == 0 {\n        parts := [s];\n    }\n}\n\nmethod StringToInt(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures result >= 0\n{\n    result := 0;\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant result >= 0\n    {\n        result := result * 10 + (s[i] as int - '0' as int);\n        i := i + 1;\n    }\n}\n\nmethod IntToString(n: int) returns (s: string)\n    requires n >= 0\n    ensures |s| > 0\n    ensures n == 0 ==> s == \"0\"\n    ensures n > 0 ==> |s| >= 1\n{\n    if n == 0 {\n        s := \"0\";\n        return;\n    }\n\n    s := \"\";\n    var temp := n;\n    while temp > 0\n        invariant temp >= 0\n        invariant temp < n ==> |s| > 0\n    {\n        var digit := temp % 10;\n        s := [('0' as int + digit) as char] + s;\n        temp := temp / 10;\n    }\n}", "vc-spec": "method SolveInternal(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures ValidOutput(n, k, result)\n    ensures n == k ==> result == 1", "vc-code": "{\n    if n == k {\n        return 1;\n    }\n\n    var low := 1;\n    var high := n / 2;\n    var res := 1;\n\n    while low <= high\n        invariant res >= 1\n        invariant res <= n / 2 + 1\n        invariant low >= 1 && high <= n / 2\n    {\n        var mid := (low + high) / 2;\n        var ggResult := gg(n, mid);\n        if ggResult >= k {\n            res := mid;\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n\n    var ggRes := gg(n, res);\n    if res * 2 <= n {\n        var ggRes2 := gg(n, res * 2);\n        if res * 2 + 1 <= n && ggRes - 1 - ggRes2 >= k {\n            return res * 2 + 1;\n        } else {\n            return res * 2;\n        }\n    } else {\n        return res;\n    }\n}", "vc-postamble": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires exists i :: 0 <= i < |input| && input[i] == '\\n'\n    requires exists i :: 0 <= i < |input| && input[i] == ' '\n    ensures |output| > 0\n{\n    var lines := SplitString(input, '\\n');\n    assume |lines| > 0 && |lines[0]| > 0;\n    var parts := SplitString(lines[0], ' ');\n    assume |parts| >= 2 && |parts[0]| > 0 && |parts[1]| > 0;\n    assume forall i :: 0 <= i < |parts[0]| ==> '0' <= parts[0][i] <= '9';\n    assume forall i :: 0 <= i < |parts[1]| ==> '0' <= parts[1][i] <= '9';\n    var n := StringToInt(parts[0]);\n    var k := StringToInt(parts[1]);\n    assume ValidInput(n, k);\n\n    var result := SolveInternal(n, k);\n    output := IntToString(result);\n}"}
{"id": "APPS_98", "vc-description": "This verification task involves determining whether two rectangular paintings can be placed on a rectangular board without overlapping. \n\nThe paintings can be rotated 90 degrees, which creates multiple placement configurations to consider. The solution must check all possible orientations and arrangements to determine if both paintings fit within the board dimensions.", "vc-preamble": "// ======= TASK =======\n// Given a rectangular board and two rectangular paintings, determine if both paintings \n// can be placed on the board without overlapping. Paintings can be rotated 90 degrees.\n\n// ======= SPEC REQUIREMENTS =======\npredicate validInput(input: string)\n{\n    |input| > 0\n}\n\nfunction parseInput(input: string): (int, int, int, int, int, int)\n    requires validInput(input)\n    ensures var (a, b, c, d, e, f) := parseInput(input); \n            a > 0 && b > 0 && c > 0 && d > 0 && e > 0 && f > 0 &&\n            a <= 1000 && b <= 1000 && c <= 1000 && d <= 1000 && e <= 1000 && f <= 1000\n{\n    (1, 1, 1, 1, 1, 1)\n}\n\nfunction max(x: int, y: int): int\n{\n    if x >= y then x else y\n}", "vc-helpers": "// ======= HELPERS =======", "vc-spec": "// ======= MAIN METHOD =======\nmethod solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires validInput(input)\n    ensures output == \"YES\" || output == \"NO\"\n    ensures \n        var (a, b, c, d, e, f) := parseInput(input);\n        output == \"YES\" <==> \n            ((c + e <= a && max(d, f) <= b) ||\n             (c + e <= b && max(d, f) <= a) ||\n             (c + f <= a && max(d, e) <= b) ||\n             (c + f <= b && max(d, e) <= a) ||\n             (d + e <= a && max(c, f) <= b) ||\n             (d + e <= b && max(c, f) <= a) ||\n             (d + f <= a && max(c, e) <= b) ||\n             (d + f <= b && max(c, e) <= a))", "vc-code": "{\n    var (a, b, c, d, e, f) := parseInput(input);\n\n    var canFit := false;\n\n    if c + e <= a && max(d, f) <= b {\n        canFit := true;\n    }\n    else if c + e <= b && max(d, f) <= a {\n        canFit := true;\n    }\n    else if c + f <= a && max(d, e) <= b {\n        canFit := true;\n    }\n    else if c + f <= b && max(d, e) <= a {\n        canFit := true;\n    }\n    else if d + e <= a && max(c, f) <= b {\n        canFit := true;\n    }\n    else if d + e <= b && max(c, f) <= a {\n        canFit := true;\n    }\n    else if d + f <= a && max(c, e) <= b {\n        canFit := true;\n    }\n    else if d + f <= b && max(c, e) <= a {\n        canFit := true;\n    }\n\n    if canFit {\n        output := \"YES\";\n    } else {\n        output := \"NO\";\n    }\n}", "vc-postamble": ""}
