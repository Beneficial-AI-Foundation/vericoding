vc-preamble: |-
  method sort_array(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures |sorted| == |s|
    ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 == 0 ==>
      forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]
    ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 != 0 ==>
      forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  method reverse(s: seq<int>) returns (rev: seq<int>)
    // post-conditions-start
    ensures |rev| == |s|
    ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma MultisetPreservedInSort(s: seq<int>, sorted: seq<int>)
    requires |s| == |sorted|
    requires forall i :: 0 <= i < |s| ==> s[i] in multiset(sorted)
    requires forall i :: 0 <= i < |sorted| ==> sorted[i] in multiset(s)
    ensures multiset(s) == multiset(sorted)
  {
  }
  
  lemma SortedProperty(arr: array<int>, len: int)
    requires 0 <= len <= arr.Length
    requires forall i, j :: 0 <= i < j < len ==> arr[i] <= arr[j]
    ensures forall i, j :: 0 <= i < j < len ==> arr[i] <= arr[j]
  {
  }
  
  lemma MultisetPreservedAfterSwap(arr: array<int>, i: int, j: int, n: int, original: multiset<int>)
    requires 0 <= i < j < n <= arr.Length
    requires multiset(arr[0..n]) == original
    ensures multiset(arr[0..i] + [arr[j]] + arr[i+1..j] + [arr[i]] + arr[j+1..n]) == original
  {
    var prefix := arr[0..i];
    var middle := arr[i+1..j];
    var suffix := arr[j+1..n];
    assert arr[0..n] == prefix + [arr[i]] + middle + [arr[j]] + suffix;
    assert multiset(arr[0..n]) == multiset(prefix) + multiset{arr[i]} + multiset(middle) + multiset{arr[j]} + multiset(suffix);
    assert arr[0..i] + [arr[j]] + arr[i+1..j] + [arr[i]] + arr[j+1..n] == prefix + [arr[j]] + middle + [arr[i]] + suffix;
    assert multiset(arr[0..i] + [arr[j]] + arr[i+1..j] + [arr[i]] + arr[j+1..n]) == 
           multiset(prefix) + multiset{arr[j]} + multiset(middle) + multiset{arr[i]} + multiset(suffix);
  }
  
  lemma ArraySliceMultisetEquality(arr: array<int>, s: seq<int>)
    requires |s| == arr.Length
    requires forall i :: 0 <= i < |s| ==> arr[i] == s[i]
    ensures multiset(arr[0..arr.Length]) == multiset(s)
  {
    assert arr[0..arr.Length] == s;
  }
  
  lemma BubbleSortMaintainsSorted(arr: array<int>, n: int, i: int, j: int)
    requires 0 <= i < n <= arr.Length
    requires 0 <= j < n - i - 1
    requires forall k, l :: 0 <= k < l <= i ==> arr[k] <= arr[l]
    requires forall k :: 0 <= k <= i ==> arr[k] <= arr[j]
    requires j + 1 < n
    ensures forall k, l :: 0 <= k < l <= i ==> arr[k] <= arr[l]
    ensures forall k :: 0 <= k <= i ==> arr[k] <= arr[j+1]
  {
  }
  
  lemma SwapPreservesMultiset(arr: array<int>, i: int, j: int)
    requires 0 <= i < arr.Length && 0 <= j < arr.Length
    modifies arr
    ensures multiset(arr[0..arr.Length]) == multiset(old(arr[0..arr.Length]))
  {
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    if |s| <= 1 {
      sorted := s;
      return;
    }
    
    var arr := new int[|s|];
    forall i | 0 <= i < |s| {
      arr[i] := s[i];
    }
    
    ArraySliceMultisetEquality(arr, s);
    
    var n := |s|;
    var i := 0;
    while i < n - 1
      invariant 0 <= i <= n - 1
      invariant forall k, l :: 0 <= k < l <= i ==> arr[k] <= arr[l]
      invariant forall k :: 0 <= k < n ==> arr[k] in multiset(s)
      invariant multiset(arr[0..n]) == multiset(s)
      invariant n == arr.Length
      invariant forall k :: 0 <= k <= i ==> forall l :: i+1 <= l < n ==> arr[k] <= arr[l]
      modifies arr
    {
      var j := 0;
      while j < n - i - 1
        invariant 0 <= j <= n - i - 1
        invariant forall k, l :: 0 <= k < l <= i ==> arr[k] <= arr[l]
        invariant forall k :: 0 <= k < n ==> arr[k] in multiset(s)
        invariant multiset(arr[0..n]) == multiset(s)
        invariant forall k :: 0 <= k <= i ==> forall l :: i+1 <= l <= j && l < n ==> arr[k] <= arr[l]
        invariant forall k :: 0 <= k <= j && k <= i ==> forall l :: j+1 <= l < n - i && l < n ==> arr[k] <= arr[l]
        invariant forall k :: 0 <= k <= j ==> arr[k] <= arr[j] || k > i
        modifies arr
      {
        if arr[j] > arr[j + 1] {
          SwapPreservesMultiset(arr, j, j + 1);
          var temp := arr[j];
          arr[j] := arr[j + 1];
          arr[j + 1] := temp;
        }
        j := j + 1;
      }
      i := i + 1;
    }
    
    sorted := arr[0..n];
  }

vc-postamble: |-


