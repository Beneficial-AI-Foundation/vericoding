vc-preamble: |-
  method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)
      // post-conditions-start
      ensures multiset(s) == multiset(sorted)
      ensures |s| == |sorted| == |strange|
      ensures forall i :: 0 <= i < |s| && i % 2 == 0 ==> strange[i] == sorted[i / 2]
      ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> strange[i] == sorted[|s| - (i - 1) / 2 - 1]
      // post-conditions-end
  {
    assume{:axiom} false;
  }
  method strange_sort_list(s: seq<int>) returns (strange: seq<int>)
      // post-conditions-start
      ensures |s| == |strange|
      // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma InsertionSortPreservesMultiset(s: seq<int>, sorted: seq<int>, i: int, j: int, temp: int)
    requires 0 <= i < |s|
    requires 0 <= j <= i
    requires sorted == s[..i] + [temp] + s[i+1..]
    requires temp == s[i]
    ensures multiset(sorted) == multiset(s)
  {
    assert s == s[..i] + [s[i]] + s[i+1..];
    assert multiset(s[..i] + [s[i]] + s[i+1..]) == multiset(s[..i]) + multiset([s[i]]) + multiset(s[i+1..]);
    assert multiset(s[..i] + [temp] + s[i+1..]) == multiset(s[..i]) + multiset([temp]) + multiset(s[i+1..]);
  }
  
  lemma InsertionSortMaintainsOrder(arr: seq<int>, i: int, j: int)
    requires 0 <= j <= i < |arr|
    requires forall k, l :: 0 <= k < l < j ==> arr[k] <= arr[l]
    ensures forall k, l :: 0 <= k < l < j ==> arr[k] <= arr[l]
  {
  }
  
  lemma MultisetPreservationAfterSwap(s: seq<int>, s': seq<int>, i: int, j: int)
    requires 0 <= i < |s| && 0 <= j < |s|
    requires |s'| == |s|
    requires s'[i] == s[j] && s'[j] == s[i]
    requires forall k :: 0 <= k < |s| && k != i && k != j ==> s'[k] == s[k]
    ensures multiset(s) == multiset(s')
  {
    if i == j {
      assert s == s';
    } else {
      var minIdx := if i < j then i else j;
      var maxIdx := if i < j then j else i;
      assert s == s[..minIdx] + [s[minIdx]] + s[minIdx+1..maxIdx] + [s[maxIdx]] + s[maxIdx+1..];
      assert s' == s'[..minIdx] + [s'[minIdx]] + s'[minIdx+1..maxIdx] + [s'[maxIdx]] + s'[maxIdx+1..];
    }
  }
  
  lemma MultisetPreservationAfterUpdate(s: seq<int>, s': seq<int>, idx: int, val: int)
    requires 0 <= idx < |s|
    requires |s'| == |s|
    requires s'[idx] == val
    requires forall k :: 0 <= k < |s| && k != idx ==> s'[k] == s[k]
    requires val == s[idx]
    ensures multiset(s) == multiset(s')
  {
    assert s' == s[..idx] + [val] + s[idx+1..];
    assert s == s[..idx] + [s[idx]] + s[idx+1..];
  }
  
  lemma SwapPreservesMultiset(arr: seq<int>, arr': seq<int>, i: int, j: int)
    requires 0 <= i < |arr| && 0 <= j < |arr|
    requires |arr'| == |arr|
    requires arr'[i] == arr[j] && arr'[j] == arr[i]
    requires forall k :: 0 <= k < |arr| && k != i && k != j ==> arr'[k] == arr[k]
    ensures multiset(arr) == multiset(arr')
  {
    MultisetPreservationAfterSwap(arr, arr', i, j);
  }
  
  lemma MultisetPreservationInsertion(sorted: seq<int>, j: int, key: int)
    requires 0 <= j < |sorted|
    ensures multiset(sorted[j := key]) == multiset(sorted) + multiset([key]) - multiset([sorted[j]])
  {
    var oldVal := sorted[j];
    var newSorted := sorted[j := key];
    assert newSorted == sorted[..j] + [key] + sorted[j+1..];
    assert sorted == sorted[..j] + [oldVal] + sorted[j+1..];
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    if |s| == 0 {
      return s;
    } else if |s| == 1 {
      return s;
    }
    
    sorted := s;
    var i := 1;
    
    while i < |sorted|
      invariant 1 <= i <= |sorted|
      invariant |sorted| == |s|
      invariant multiset(sorted) == multiset(s)
      invariant forall k, l :: 0 <= k < l < i ==> sorted[k] <= sorted[l]
    {
      var key := sorted[i];
      var j := i;
      
      while j > 0 && sorted[j-1] > key
        invariant 0 <= j <= i
        invariant |sorted| == |s|
        invariant multiset(sorted) + multiset([key]) == multiset(s) + multiset([sorted[j]])
        invariant forall k, l :: 0 <= k < l < j ==> sorted[k] <= sorted[l]
        invariant forall k, l :: j < k < l <= i ==> sorted[k] <= sorted[l]
        invariant forall k :: j < k <= i ==> key <= sorted[k]
        invariant j == 0 || sorted[j-1] > key
      {
        sorted := sorted[j := sorted[j-1]];
        j := j - 1;
      }
      
      sorted := sorted[j := key];
      i := i + 1;
    }
  }

vc-postamble: |-


