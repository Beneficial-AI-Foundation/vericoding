vc-preamble: |-
  function IsLowerCase(s: string) : bool
  {
    forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'
  }
  function IsUpperCase(s: string) : bool
  {
    forall i :: 0 <= i < |s| ==> 'A' <= s[i] <= 'Z'
  }
  type DictCase = map<string, string>

vc-helpers: |-
  lemma EmptyMapHasNoKeys(dict: map<string, string>)
    ensures dict == map[] ==> forall k :: k !in dict
  {
  }
  
  method ExistsNonLowerCaseKey(dict: map<string, string>) returns (foundKey: bool, key: string)
    ensures foundKey ==> key in dict && !IsLowerCase(key)
    ensures !foundKey ==> forall k :: k in dict ==> IsLowerCase(k)
  {
    foundKey := false;
    key := "";
    
    var keys := dict.Keys;
    var keySeq := SetToSeq(keys);
    
    var i := 0;
    while i < |keySeq|
      invariant 0 <= i <= |keySeq|
      invariant !foundKey ==> forall j :: 0 <= j < i ==> IsLowerCase(keySeq[j])
      invariant foundKey ==> key in dict && !IsLowerCase(key)
    {
      var k := keySeq[i];
      if !IsLowerCase(k) {
        foundKey := true;
        key := k;
        return;
      }
      i := i + 1;
    }
  }
  
  method ExistsNonUpperCaseKey(dict: map<string, string>) returns (foundKey: bool, key: string)
    ensures foundKey ==> key in dict && !IsUpperCase(key)
    ensures !foundKey ==> forall k :: k in dict ==> IsUpperCase(k)
  {
    foundKey := false;
    key := "";
    
    var keys := dict.Keys;
    var keySeq := SetToSeq(keys);
    
    var i := 0;
    while i < |keySeq|
      invariant 0 <= i <= |keySeq|
      invariant !foundKey ==> forall j :: 0 <= j < i ==> IsUpperCase(keySeq[j])
      invariant foundKey ==> key in dict && !IsUpperCase(key)
    {
      var k := keySeq[i];
      if !IsUpperCase(k) {
        foundKey := true;
        key := k;
        return;
      }
      i := i + 1;
    }
  }
  
  method SetToSeq<T>(s: set<T>) returns (result: seq<T>)
    ensures forall x :: x in s <==> x in result
    ensures |result| == |s|
  {
    result := [];
    var remaining := s;
    while remaining != {}
      invariant forall x :: x in result ==> x in s
      invariant forall x :: x in remaining ==> x in s
      invariant forall x :: x in s ==> x in result || x in remaining
      invariant forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]
      invariant remaining * (set x | x in result) == {}
      invariant |result| + |remaining| == |s|
      decreases |remaining|
    {
      var x :| x in remaining;
      result := result + [x];
      remaining := remaining - {x};
    }
  }

vc-description: |-
  function_signature: def check_dict_case(s : dict[str, str]) -> bool
  Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False. The function should return False is the given dictionary is empty. Note(George): Modified the problem to use strings only for both keys and values.

vc-spec: |-
  method CheckDictCase(dict: DictCase) returns (result: bool)
    // post-conditions-start
    ensures dict == map[] ==> !result
    ensures result ==> (forall k :: k in dict ==> IsLowerCase(k)) || (forall k :: k in dict ==> IsUpperCase(k))
    ensures !result ==> dict == map[] || ((exists k :: k in dict && !IsLowerCase(k)) && (exists k :: k in dict && !IsUpperCase(k)))
    // post-conditions-end

vc-code: |-
  {
    if dict == map[] {
      result := false;
      return;
    }
    
    var hasNonLowerCase, nonLowerKey := ExistsNonLowerCaseKey(dict);
    var hasNonUpperCase, nonUpperKey := ExistsNonUpperCaseKey(dict);
    
    if !hasNonLowerCase {
      result := true;
    } else if !hasNonUpperCase {
      result := true;
    } else {
      result := false;
    }
  }

vc-postamble: |-


