vc-preamble: |-


vc-helpers: |-
  lemma SetCardinalityHelper(s: string, i: int)
    requires 0 <= i <= |s|
    ensures |set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j])| <= i
  {
    var target_set := set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j]);
    var index_set := set k {:trigger} | 0 <= k < i;
    assert forall j :: j in target_set ==> 0 <= j < i;
    assert target_set <= index_set;
    SubsetCardinalityLemma(target_set, index_set);
    FiniteSetCardinalityLemma(i);
  }
  
  lemma SubsetCardinalityLemma<T>(s1: set<T>, s2: set<T>)
    requires s1 <= s2
    ensures |s1| <= |s2|
  {
    if s1 == {} {
      assert |s1| == 0 && |s2| >= 0;
    } else {
      var x :| x in s1;
      assert x in s2;
      var s1' := s1 - {x};
      var s2' := s2 - {x};
      assert s1' <= s2';
      SubsetCardinalityLemma(s1', s2');
    }
  }
  
  lemma FiniteSetCardinalityLemma(i: int)
    requires i >= 0
    ensures |set k {:trigger} | 0 <= k < i| == i
  {
    if i == 0 {
      assert (set k | 0 <= k < 0) == {};
    } else {
      var prev_set := set k | 0 <= k < i-1;
      var curr_set := set k | 0 <= k < i;
      assert curr_set == prev_set + {i-1};
      assert (i-1) !in prev_set;
      FiniteSetCardinalityLemma(i-1);
    }
  }
  
  lemma SetUnionProperty(s: string, i: int)
    requires 0 <= i < |s|
    ensures (set j | 0 <= j < i+1 && j % 2 == 0 && is_upper_vowel(s[j])) ==
            (set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j])) +
            (if i % 2 == 0 && is_upper_vowel(s[i]) then {i} else {})
  {
    var left_set := set j | 0 <= j < i+1 && j % 2 == 0 && is_upper_vowel(s[j]);
    var base_set := set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j]);
    var add_set := if i % 2 == 0 && is_upper_vowel(s[i]) then {i} else {};
    
    assert forall j :: j in left_set ==> (0 <= j < i || j == i) && j % 2 == 0 && is_upper_vowel(s[j]);
    assert forall j :: j in base_set ==> j in left_set;
    
    if i % 2 == 0 && is_upper_vowel(s[i]) {
      assert i in left_set;
      assert left_set == base_set + {i};
    } else {
      assert i !in left_set;
      assert left_set == base_set;
    }
  }
  
  lemma SetSizeIncrease(s: string, i: int)
    requires 0 <= i < |s|
    requires i % 2 == 0 && is_upper_vowel(s[i])
    ensures |set j | 0 <= j < i+1 && j % 2 == 0 && is_upper_vowel(s[j])| == 
            |set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j])| + 1
  {
    SetUnionProperty(s, i);
    var base_set := set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j]);
    assert i !in base_set;
  }

vc-description: |-
  function_signature: def count_upper(s : String) -> Int
  Given a string s, count the number of uppercase vowels in even indices.

vc-spec: |-
  method count_upper(s: string) returns (cnt: int)
    // post-conditions-start
    ensures cnt == |set i | 0 <= i < |s| && i % 2 == 0 && is_upper_vowel(s[i])|
    // post-conditions-end

vc-code: |-
  {
    SetCardinalityHelper(s, |s|);
    cnt := 0;
    var i := 0;
    
    while i < |s|
      invariant 0 <= i <= |s|
      invariant cnt == |set j | 0 <= j < i && j % 2 == 0 && is_upper_vowel(s[j])|
    {
      if i % 2 == 0 && is_upper_vowel(s[i]) {
        SetSizeIncrease(s, i);
        cnt := cnt + 1;
      } else {
        SetUnionProperty(s, i);
      }
      i := i + 1;
    }
  }

vc-postamble: |-
  function is_upper_vowel(c: char) : bool {
    c == 'A' || c == 'E' || c == 'U' || c == 'I' || c == 'O'
  }
  // pure-end

