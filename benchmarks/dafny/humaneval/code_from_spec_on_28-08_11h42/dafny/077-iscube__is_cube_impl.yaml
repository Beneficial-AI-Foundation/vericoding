vc-preamble: |-
  method cube_root(N: nat) returns (r: nat)
    // post-conditions-start
    ensures cube(r) <= N < cube(r + 1)
    ensures r <= N
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma cube_monotonic(x: nat, y: nat)
    requires x <= y
    ensures cube(x) <= cube(y)
  {
    assert x * x <= y * y;
    assert x * x * x <= y * y * y;
  }
  
  lemma cube_strictly_increasing(x: nat, y: nat)
    requires x < y
    ensures cube(x) < cube(y)
  {
    if x == 0 {
      assert cube(0) == 0;
      assert y >= 1;
      assert cube(y) >= 1;
    } else {
      assert x >= 1;
      assert y >= x + 1;
      assert cube(y) > cube(x);
    }
  }

vc-description: |-
  function_signature: method is_cube(n: nat) returns (r: bool)
  Check if condition holds. Ensures: if true, then there exists an integer r such that N = r³; if false, then no integer r satisfies N = r³.

vc-spec: |-
  method is_cube(n: nat) returns (r: bool)
    // pre-conditions-start
    // pre-conditions-end
    // post-conditions-start
    ensures r ==> exists r :: 0 <= r <= n && n == cube(r)
    ensures !r ==> forall r :: 0 <= r <= n ==> n != cube(r)
    // post-conditions-end

vc-code: |-
  {
    var cr := cube_root(n);
    
    if cube(cr) == n {
      r := true;
    } else {
      r := false;
    }
    
    if r {
      assert cube(cr) == n;
      assert 0 <= cr <= n;
    } else {
      assert cube(cr) != n;
      
      forall k | 0 <= k <= n
        ensures n != cube(k)
      {
        if k <= cr {
          cube_monotonic(k, cr);
          assert cube(k) <= cube(cr);
          assert cube(k) < n;
        } else {
          assert k >= cr + 1;
          cube_monotonic(cr + 1, k);
          assert cube(cr + 1) <= cube(k);
          assert n < cube(cr + 1);
          assert n < cube(k);
        }
      }
    }
  }

vc-postamble: |-
  function cube(n: int): int { n * n * n }
  // pure-end

