vc-preamble: |-
  function popcount(n: nat): nat {
    if n == 0 then 0
    else popcount(n / 2) + n % 2
  }

vc-helpers: |-
  lemma PopcountBounds(n: nat)
    ensures 0 <= popcount(n)
  {
    if n == 0 {
    } else {
      PopcountBounds(n / 2);
    }
  }
  
  lemma PopcountMonotonic(a: nat, b: nat)
    requires a <= b
    ensures popcount(a) <= popcount(b) || popcount(a) > popcount(b)
  {
  }
  
  predicate SortedByPopcount(s: seq<nat>)
  {
    forall i, j :: 0 <= i < j < |s| ==> popcount(s[i]) <= popcount(s[j])
  }
  
  lemma InsertionPreservesMultiset(s: seq<nat>, elem: nat, pos: int)
    requires 0 <= pos <= |s|
    ensures multiset(s[..pos] + [elem] + s[pos..]) == multiset(s) + multiset{elem}
  {
    var result := s[..pos] + [elem] + s[pos..];
    assert s == s[..pos] + s[pos..];
    assert result == s[..pos] + [elem] + s[pos..];
    assert multiset(result) == multiset(s[..pos]) + multiset([elem]) + multiset(s[pos..]);
    assert multiset(result) == multiset(s[..pos]) + multiset{elem} + multiset(s[pos..]);
    assert multiset(s) == multiset(s[..pos]) + multiset(s[pos..]);
    assert multiset(result) == multiset(s) + multiset{elem};
  }
  
  lemma SortedInsertMaintainsSorted(s: seq<nat>, elem: nat, pos: int)
    requires SortedByPopcount(s)
    requires 0 <= pos <= |s|
    requires pos == 0 || popcount(s[pos-1]) <= popcount(elem)
    requires pos == |s| || popcount(elem) <= popcount(s[pos])
    ensures SortedByPopcount(s[..pos] + [elem] + s[pos..])
  {
    var result := s[..pos] + [elem] + s[pos..];
    forall i, j | 0 <= i < j < |result|
      ensures popcount(result[i]) <= popcount(result[j])
    {
      if i < pos && j < pos {
        assert result[i] == s[i] && result[j] == s[j];
      } else if i < pos && j == pos {
        assert result[i] == s[i] && result[j] == elem;
      } else if i < pos && j > pos {
        assert result[i] == s[i] && result[j] == s[j-1];
      } else if i == pos && j > pos {
        assert result[i] == elem && result[j] == s[j-1];
      } else if i > pos && j > pos {
        assert result[i] == s[i-1] && result[j] == s[j-1];
      }
    }
  }
  
  lemma MultisetSliceExtension(s: seq<nat>, k: int)
    requires 0 <= k < |s|
    ensures multiset(s[..k+1]) == multiset(s[..k]) + multiset{s[k]}
  {
    assert s[..k+1] == s[..k] + [s[k]];
    assert multiset(s[..k+1]) == multiset(s[..k] + [s[k]]);
    assert multiset(s[..k+1]) == multiset(s[..k]) + multiset([s[k]]);
    assert multiset(s[..k+1]) == multiset(s[..k]) + multiset{s[k]};
  }
  
  lemma MultisetLoopInvariant(s: seq<nat>, sorted: seq<nat>, k: int, elem: nat, old_sorted: seq<nat>, pos: int)
    requires 0 <= k < |s|
    requires elem == s[k]
    requires multiset(old_sorted) == multiset(s[..k])
    requires 0 <= pos <= |old_sorted|
    requires multiset(sorted) == multiset(old_sorted) + multiset{elem}
    ensures multiset(sorted) == multiset(s[..k+1])
  {
    MultisetSliceExtension(s, k);
    assert multiset(s[..k+1]) == multiset(s[..k]) + multiset{s[k]};
    assert multiset(s[..k+1]) == multiset(old_sorted) + multiset{elem};
    assert multiset(sorted) == multiset(s[..k+1]);
  }
  
  lemma FinalMultisetEquality(s: seq<nat>, sorted: seq<nat>)
    requires |s| == |sorted|
    requires multiset(sorted) == multiset(s[..|s|])
    ensures multiset(s) == multiset(sorted)
  {
    assert s[..|s|] == s;
  }

vc-description: |-
  function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int
  Please write a function that sorts an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.

vc-spec: |-
  method sort_array(s: seq<nat>) returns (sorted: seq<nat>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> popcount(sorted[i]) <= popcount(sorted[j])
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    sorted := [];
    
    for k := 0 to |s|
      invariant 0 <= k <= |s|
      invariant |sorted| == k
      invariant SortedByPopcount(sorted)
      invariant multiset(sorted) == multiset(s[..k])
    {
      var elem := s[k];
      var pos := 0;
      var old_sorted := sorted;
      
      while pos < |sorted| && popcount(sorted[pos]) <= popcount(elem)
        invariant 0 <= pos <= |sorted|
        invariant forall i :: 0 <= i < pos ==> popcount(sorted[i]) <= popcount(elem)
        invariant sorted == old_sorted
      {
        pos := pos + 1;
      }
      
      assert pos == 0 || popcount(sorted[pos-1]) <= popcount(elem);
      assert pos == |sorted| || popcount(elem) <= popcount(sorted[pos]);
      
      InsertionPreservesMultiset(sorted, elem, pos);
      SortedInsertMaintainsSorted(sorted, elem, pos);
      MultisetSliceExtension(s, k);
      
      sorted := sorted[..pos] + [elem] + sorted[pos..];
      
      MultisetLoopInvariant(s, sorted, k, elem, old_sorted, pos);
    }
    
    FinalMultisetEquality(s, sorted);
  }

vc-postamble: |-


