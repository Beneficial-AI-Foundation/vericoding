vc-preamble: |-
  method maximum(s: seq<int>, k: int) returns (result: seq<int>)
    // pre-conditions-start
    requires 1 <= k <= |s|
    requires 1 <= |s| <= 1000
    requires forall x :: x in s ==> -1000 <= x <= 1000
    // pre-conditions-end
    // post-conditions-start
    ensures |result| == k
    ensures forall i, j :: 0 <= i < j < k ==> result[i] <= result[j]
    ensures forall x :: x in result ==> x in s
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma MultisetPreservesElements<T>(s: seq<T>, sorted: seq<T>)
    requires multiset(s) == multiset(sorted)
    ensures forall x :: x in s ==> x in sorted
    ensures forall x :: x in sorted ==> x in s
  {
  }
  
  lemma SortedSliceIsSorted(s: seq<int>, i: int, j: int)
    requires forall x, y :: 0 <= x < y < |s| ==> s[x] <= s[y]
    requires 0 <= i <= j <= |s|
    ensures forall x, y :: 0 <= x < y < j - i ==> {:trigger s[i + x], s[i + y]} s[i + x] <= s[i + y]
  {
  }
  
  lemma MultisetConcat<T>(a: seq<T>, b: seq<T>, c: seq<T>)
    ensures multiset(a + b + c) == multiset(a) + multiset(b) + multiset(c)
  {
  }
  
  lemma SortedConcatenation(less: seq<int>, equal: seq<int>, greater: seq<int>, pivot: int)
    requires forall x :: x in less ==> x < pivot
    requires forall x :: x in equal ==> x == pivot
    requires forall x :: x in greater ==> x > pivot
    requires forall i, j :: 0 <= i < j < |less| ==> less[i] <= less[j]
    requires forall i, j :: 0 <= i < j < |greater| ==> greater[i] <= greater[j]
    ensures forall i, j :: 0 <= i < j < |less + equal + greater| ==> (less + equal + greater)[i] <= (less + equal + greater)[j]
  {
    var result := less + equal + greater;
    forall i, j | 0 <= i < j < |result|
      ensures result[i] <= result[j]
    {
      if i < |less| && j < |less| {
        // both in less part
      } else if i >= |less| && i < |less| + |equal| && j >= |less| && j < |less| + |equal| {
        // both in equal part
      } else if i >= |less| + |equal| && j >= |less| + |equal| {
        // both in greater part
      } else if i < |less| && j >= |less| && j < |less| + |equal| {
        // i in less, j in equal
        assert result[i] in less && result[j] in equal;
      } else if i < |less| && j >= |less| + |equal| {
        // i in less, j in greater
        assert result[i] in less && result[j] in greater;
      } else if i >= |less| && i < |less| + |equal| && j >= |less| + |equal| {
        // i in equal, j in greater
        assert result[i] in equal && result[j] in greater;
      }
    }
  }
  
  lemma QuicksortTermination(s: seq<int>, less: seq<int>, greater: seq<int>)
    requires |s| > 1
    requires exists pivot :: (forall x :: x in less ==> x < pivot) && (forall x :: x in greater ==> x > pivot)
    ensures |less| < |s|
    ensures |greater| < |s|
  {
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && s[i] == sorted[j]
    ensures forall x :: x in s ==> x in sorted
    ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && sorted[i] == s[j]
    ensures forall x :: x in sorted ==> x in s

vc-code: |-
  {
    if |s| <= 1 {
      return s;
    }
    
    var pivot := s[0];
    var less : seq<int> := [];
    var equal : seq<int> := [];
    var greater : seq<int> := [];
    
    var i := 0;
    while i < |s|
      invariant 0 <= i <= |s|
      invariant multiset(less + equal + greater) == multiset(s[..i])
      invariant forall x :: x in less ==> x < pivot
      invariant forall x :: x in equal ==> x == pivot
      invariant forall x :: x in greater ==> x > pivot
    {
      if s[i] < pivot {
        less := less + [s[i]];
      } else if s[i] == pivot {
        equal := equal + [s[i]];
      } else {
        greater := greater + [s[i]];
      }
      i := i + 1;
    }
    
    assert multiset(less + equal + greater) == multiset(s);
    assert |less| < |s| || |greater| < |s|;
    
    var sortedLess := SortSeq(less);
    var sortedGreater := SortSeq(greater);
    
    sorted := sortedLess + equal + sortedGreater;
    
    MultisetConcat(sortedLess, equal, sortedGreater);
    assert multiset(sorted) == multiset(sortedLess) + multiset(equal) + multiset(sortedGreater);
    assert multiset(sorted) == multiset(less) + multiset(equal) + multiset(greater);
    assert multiset(sorted) == multiset(s);
    
    SortedConcatenation(sortedLess, equal, sortedGreater, pivot);
  }

vc-postamble: |-


