vc-preamble: |-
  function psum(s: seq<int>): int
  {
      if |s| == 0 then 0
      else psum(s[..(|s|)-1]) + s[ |s| - 1 ]
  }

vc-helpers: |-
  lemma psum_prefix_property(s: seq<int>, i: int)
      requires 0 <= i <= |s|
      ensures psum(s[..i]) == if i == 0 then 0 else psum(s[..i-1]) + s[i-1]
  {
      if i == 0 {
          assert s[..0] == [];
      } else {
          assert s[..i] == s[..i-1] + [s[i-1]];
      }
  }
  
  lemma psum_monotonic_helper(s: seq<int>, i: int)
      requires 0 <= i < |s|
      ensures psum(s[..i+1]) == psum(s[..i]) + s[i]
  {
      psum_prefix_property(s, i+1);
  }
  
  lemma psum_invariant_preservation(ops: seq<int>, i: int, current_sum: int)
      requires 0 <= i < |ops|
      requires current_sum == psum(ops[..i])
      requires forall j : int :: 0 <= j <= i ==> psum(ops[..j]) >= 0
      requires current_sum + ops[i] >= 0
      ensures forall j : int :: 0 <= j <= i + 1 ==> psum(ops[..j]) >= 0
  {
      forall j : int | 0 <= j <= i + 1
          ensures psum(ops[..j]) >= 0
      {
          if j <= i {
              assert psum(ops[..j]) >= 0;
          } else {
              assert j == i + 1;
              psum_monotonic_helper(ops, i);
              assert psum(ops[..j]) == psum(ops[..i]) + ops[i] == current_sum + ops[i] >= 0;
          }
      }
  }

vc-description: |-
  function_signature: def below_zero(operations: List[int]) -> bool
  You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.

vc-spec: |-
  method below_zero(ops: seq<int>) returns (res : bool)
      // post-conditions-start
      ensures res ==> forall i : int :: 0 <= i <= |ops| ==> psum(ops[..i]) >= 0
      ensures !res ==> exists i : int :: 0 <= i <= |ops| && psum(ops[..i]) < 0
      // post-conditions-end

vc-code: |-
  {
      res := true;
      var i := 0;
      var current_sum := 0;
      
      while i < |ops|
          invariant 0 <= i <= |ops|
          invariant current_sum == psum(ops[..i])
          invariant res ==> forall j : int :: 0 <= j <= i ==> psum(ops[..j]) >= 0
          invariant !res ==> exists j : int :: 0 <= j <= i && psum(ops[..j]) < 0
      {
          if current_sum < 0 {
              res := false;
              break;
          }
          
          current_sum := current_sum + ops[i];
          psum_monotonic_helper(ops, i);
          i := i + 1;
          
          if res && current_sum < 0 {
              res := false;
          }
          
          if res {
              psum_invariant_preservation(ops, i-1, psum(ops[..i-1]));
          }
      }
      
      if res && current_sum < 0 {
          res := false;
      }
  }

vc-postamble: |-


