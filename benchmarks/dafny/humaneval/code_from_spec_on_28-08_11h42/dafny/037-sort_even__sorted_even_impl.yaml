vc-preamble: |-


vc-helpers: |-
  lemma MultisetPreservedAfterUpdate(s: seq<int>, sorted: seq<int>, evenIndices: seq<int>, sortedEvenValues: seq<int>)
    requires |s| == |sorted|
    requires |evenIndices| == |sortedEvenValues|
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |s|
    requires forall k :: 0 <= k < |evenIndices| ==> evenIndices[k] % 2 == 0
    requires forall i :: 0 <= i < |s| && i % 2 == 1 ==> sorted[i] == s[i]
    requires forall k :: 0 <= k < |evenIndices| ==> sorted[evenIndices[k]] == s[evenIndices[k]]
    requires multiset(s) == multiset(sorted)
    requires multiset(sortedEvenValues) == multiset(seq(|evenIndices|, k requires 0 <= k < |evenIndices| => s[evenIndices[k]]))
    ensures multiset(s) == multiset(UpdateEvenPositions(sorted, evenIndices, sortedEvenValues))
  
  function UpdateEvenPositions(s: seq<int>, evenIndices: seq<int>, sortedValues: seq<int>): seq<int>
    requires |evenIndices| == |sortedValues|
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |s|
    decreases |evenIndices|
  {
    if |evenIndices| == 0 then s
    else 
      var updated := s[evenIndices[0] := sortedValues[0]];
      UpdateEvenPositions(updated, evenIndices[1..], sortedValues[1..])
  }
  
  lemma UpdatePreservesOddPositions(s: seq<int>, evenIndices: seq<int>, sortedValues: seq<int>)
    requires |evenIndices| == |sortedValues|
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |s|
    requires forall k :: 0 <= k < |evenIndices| ==> evenIndices[k] % 2 == 0
    ensures |UpdateEvenPositions(s, evenIndices, sortedValues)| == |s|
    ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> 
      UpdateEvenPositions(s, evenIndices, sortedValues)[i] == s[i]
  
  lemma UpdatePreservesLength(s: seq<int>, evenIndices: seq<int>, sortedValues: seq<int>)
    requires |evenIndices| == |sortedValues|
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |s|
    ensures |UpdateEvenPositions(s, evenIndices, sortedValues)| == |s|
  
  function ExtractEvenElements(s: seq<int>): seq<int>
    requires |s| > 0
  {
    seq((|s| + 1) / 2, i requires 0 <= i < (|s| + 1) / 2 => s[2 * i])
  }
  
  function GetEvenIndices(n: int): seq<int>
    requires n >= 0
  {
    seq((n + 1) / 2, i => 2 * i)
  }
  
  lemma EvenIndicesProperties(n: int)
    requires n > 0
    ensures forall k :: 0 <= k < |GetEvenIndices(n)| ==> GetEvenIndices(n)[k] % 2 == 0
    ensures forall k :: 0 <= k < |GetEvenIndices(n)| ==> 0 <= GetEvenIndices(n)[k] < n
  
  lemma ExtractEvenElementsProperties(s: seq<int>)
    requires |s| > 0
    ensures |ExtractEvenElements(s)| == |GetEvenIndices(|s|)|
    ensures forall k :: 0 <= k < |ExtractEvenElements(s)| ==> 
      ExtractEvenElements(s)[k] == s[GetEvenIndices(|s|)[k]]
  
  lemma SortedEvenOrderPreserved(evenIndices: seq<int>, sortedValues: seq<int>, result: seq<int>)
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |result|
    requires forall k :: 0 <= k < |evenIndices| ==> evenIndices[k] % 2 == 0
    requires |evenIndices| == |sortedValues|
    requires forall i, j :: 0 <= i < j < |sortedValues| ==> sortedValues[i] <= sortedValues[j]
    requires forall k :: 0 <= k < |evenIndices| ==> result[evenIndices[k]] == sortedValues[k]
    ensures forall i, j :: 0 <= i < j && 2 * i < |result| && 2 * j < |result| ==>
      result[2 * i] <= result[2 * j]
  
  lemma UpdateEvenPositionsCorrect(s: seq<int>, evenIndices: seq<int>, sortedValues: seq<int>)
    requires |evenIndices| == |sortedValues|
    requires forall k :: 0 <= k < |evenIndices| ==> 0 <= evenIndices[k] < |s|
    ensures forall k :: 0 <= k < |evenIndices| ==> 
      UpdateEvenPositions(s, evenIndices, sortedValues)[evenIndices[k]] == sortedValues[k]
  
  method SortSequence(s: seq<int>) returns (sorted: seq<int>)
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
  {
    sorted := s;
    var i := 0;
    while i < |sorted|
      invariant 0 <= i <= |sorted|
      invariant |sorted| == |s|
      invariant multiset(s) == multiset(sorted)
      invariant forall p, q :: 0 <= p < q < i ==> sorted[p] <= sorted[q]
      invariant forall p, q :: 0 <= p < i <= q < |sorted| ==> sorted[p] <= sorted[q]
    {
      var minIndex := i;
      var j := i + 1;
      while j < |sorted|
        invariant i <= minIndex < |sorted|
        invariant i + 1 <= j <= |sorted|
        invariant forall k :: i <= k < j ==> sorted[minIndex] <= sorted[k]
      {
        if sorted[j] < sorted[minIndex] {
          minIndex := j;
        }
        j := j + 1;
      }
      if minIndex != i {
        var temp := sorted[i];
        sorted := sorted[i := sorted[minIndex]];
        sorted := sorted[minIndex := temp];
      }
      i := i + 1;
    }
  }

vc-description: |-
  function_signature: method sorted_even(a: seq<int>) returns (sorted: seq<int>)
  Sort elements. Requires: requires size of asize of  > 0. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.

vc-spec: |-
  method sorted_even(a: seq<int>) returns (sorted: seq<int>)
    // pre-conditions-start
    requires |a| > 0
    // pre-conditions-end
    // post-conditions-start
    ensures |sorted| == |a|
    ensures forall i, j :: 0 <= i < j && 2 * i < |sorted| && 2 * j < |sorted| ==>
        sorted[2 * i] <= sorted[2 * j]
        ensures forall i :: 0 <= i < |a| && i % 2 == 1 ==> sorted[i] == a[i]
        ensures multiset(a) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    var evenIndices := GetEvenIndices(|a|);
    var evenElements := ExtractEvenElements(a);
    var sortedEvenElements := SortSequence(evenElements);
    
    EvenIndicesProperties(|a|);
    ExtractEvenElementsProperties(a);
    
    sorted := UpdateEvenPositions(a, evenIndices, sortedEvenElements);
    
    UpdatePreservesOddPositions(a, evenIndices, sortedEvenElements);
    UpdateEvenPositionsCorrect(a, evenIndices, sortedEvenElements);
    
    assert forall i :: 0 <= i < |a| && i % 2 == 1 ==> sorted[i] == a[i];
    assert |sorted| == |a|;
    
    assert multiset(evenElements) == multiset(sortedEvenElements);
    assert forall i, j :: 0 <= i < j < |sortedEvenElements| ==> sortedEvenElements[i] <= sortedEvenElements[j];
    
    assert forall k :: 0 <= k < |evenIndices| ==> sorted[evenIndices[k]] == sortedEvenElements[k];
    SortedEvenOrderPreserved(evenIndices, sortedEvenElements, sorted);
    
    MultisetPreservedAfterUpdate(a, a, evenIndices, evenElements);
    assert multiset(a) == multiset(sorted);
  }

vc-postamble: |-
  method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)
    // pre-conditions-start
    requires |s| == |p|
    // pre-conditions-end
    // post-conditions-start
    ensures |sorted| == |s|
    ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]
    ensures multiset(s) == multiset(sorted)
    ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]
    // post-conditions-end
  {
    assume{:axiom} false;
  }

