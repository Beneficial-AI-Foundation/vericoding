vc-preamble: |-
  function CalcBal(s: seq<int>, i: int, j: int) : int 
      requires 0 <= i <= j <= |s|
  {
      if i == j then 0
      else (if s[j - 1] == 0 then 1 else -1) + CalcBal(s, i, j - 1)
  }

vc-helpers: |-
  lemma CalcBalProperty(s: seq<int>, i: int, j: int, k: int)
      requires 0 <= i <= j <= k <= |s|
      ensures CalcBal(s, i, k) == CalcBal(s, i, j) + CalcBal(s, j, k)
  {
      if j == k {
      } else {
          CalcBalProperty(s, i, j, k - 1);
      }
  }
  
  lemma CalcBalMonotonic(s: seq<int>, i: int, j: int)
      requires 0 <= i <= j <= |s|
      requires forall k :: 0 <= k < |s| ==> s[k] == 0 || s[k] == 1
      ensures j > i ==> CalcBal(s, i, j) == CalcBal(s, i, j - 1) + (if s[j - 1] == 0 then 1 else -1)
  {
  }

vc-description: |-
  function_signature: def correct_bracketing(brackets: str) -> Bool
  brackets is a string of "<" and ">". return True if every opening bracket has a corresponding closing bracket, i.e., (each open bracket is properly closed)

vc-spec: |-
  method correct_bracketing(s: seq<int>) returns (b: bool)
      // pre-conditions-start
      requires forall i :: 0 <= i < |s| ==> s[i] == 0 || s[i] == 1
      // pre-conditions-end
      // post-conditions-start
      ensures (forall i :: 0 <= i <= |s| ==> CalcBal(s, 0, i) >= 0) ==> b
      ensures b ==> (forall i :: 0 <= i <= |s| ==> CalcBal(s, 0, i) >= 0)
      // post-conditions-end

vc-code: |-
  {
      b := true;
      var i := 0;
      while i <= |s|
          invariant 0 <= i <= |s| + 1
          invariant b ==> (forall k :: 0 <= k < i ==> CalcBal(s, 0, k) >= 0)
          invariant !b ==> (exists k :: 0 <= k < i && CalcBal(s, 0, k) < 0)
      {
          if i == |s| + 1 {
              break;
          }
          
          if CalcBal(s, 0, i) < 0 {
              b := false;
              return;
          }
          
          i := i + 1;
      }
  }

vc-postamble: |-


