vc-preamble: |-
  function factorial(n: nat): nat
    decreases n
  {
    if n == 0 then 1 else n * factorial(n - 1)
  }
  function special_factorial_rec(n: nat): nat
    decreases n
  {
    if n == 0 then 1 else factorial(n) * special_factorial_rec(n - 1)
  }

vc-helpers: |-
  function special_factorial(n: nat): nat
    decreases n
  {
    if n == 0 then 1 else factorial(n) * special_factorial(n - 1)
  }
  
  lemma SpecialFactorialCorrect(n: nat)
    ensures special_factorial(n) == special_factorial_rec(n)
    decreases n
  {
    if n == 0 {
      assert special_factorial(0) == 1 == special_factorial_rec(0);
    } else {
      SpecialFactorialCorrect(n - 1);
      assert special_factorial(n) == factorial(n) * special_factorial(n - 1);
      assert special_factorial_rec(n) == factorial(n) * special_factorial_rec(n - 1);
      assert special_factorial(n) == special_factorial_rec(n);
    }
  }

vc-description: |-
  function_signature: def special_factorial(n: int) -> int
  The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1! where n > 0. Please write a function that computes the Brazilian factorial.

vc-spec: |-
  method BrazilianFactorial(n: int) returns (result: int)
    requires n > 0
    ensures result == special_factorial(n as nat)

vc-code: |-
  {
    result := 1;
    var i := 1;
    while i <= n
      decreases n - i
      invariant 1 <= i <= n + 1
      invariant result == special_factorial((i - 1) as nat)
    {
      result := result * factorial(i as nat);
      i := i + 1;
    }
  }

vc-postamble: |-


