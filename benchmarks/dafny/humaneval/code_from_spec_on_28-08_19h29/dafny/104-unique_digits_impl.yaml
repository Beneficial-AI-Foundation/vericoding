vc-preamble: |-
  function HasNoEvenDigit(n: int) : bool
    decreases n
  {
    n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && HasNoEvenDigit(n / 10)))
  }

vc-helpers: |-
  predicate IsSorted(xs: seq<nat>)
  {
    forall i, j :: 0 <= i < j < |xs| ==> xs[i] <= xs[j]
  }
  
  predicate IsUnique(xs: seq<nat>)
  {
    forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]
  }
  
  lemma SortedInsertMaintainsSorted(sorted: seq<nat>, elem: nat, pos: nat)
    requires IsSorted(sorted)
    requires 0 <= pos <= |sorted|
    requires pos == 0 || sorted[pos-1] <= elem
    requires pos == |sorted| || elem <= sorted[pos]
    ensures IsSorted(sorted[..pos] + [elem] + sorted[pos..])
  {
  }
  
  lemma SortedInsertMaintainsUnique(sorted: seq<nat>, elem: nat, pos: nat)
    requires IsUnique(sorted)
    requires 0 <= pos <= |sorted|
    requires forall i :: 0 <= i < |sorted| ==> sorted[i] != elem
    ensures IsUnique(sorted[..pos] + [elem] + sorted[pos..])
  {
  }

vc-description: |-
  function_signature: def unique_digits(x: List[nat]) -> List[nat]
  Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.

vc-spec: |-
  method UniqueDigits(x: seq<nat>) returns (result: seq<nat>)
    requires forall i :: 0 <= i < |x| ==> x[i] > 0
    ensures IsSorted(result)
    ensures IsUnique(result)
    ensures forall i :: 0 <= i < |result| ==> HasNoEvenDigit(result[i])
    ensures forall i :: 0 <= i < |x| ==> (HasNoEvenDigit(x[i]) ==> exists j :: 0 <= j < |result| && result[j] == x[i])

vc-code: |-
  {
    var filtered: seq<nat> := [];
    var i := 0;
    while i < |x|
      invariant 0 <= i <= |x|
      invariant forall k :: 0 <= k < |filtered| ==> HasNoEvenDigit(filtered[k])
      invariant forall k :: 0 <= k < i ==> (HasNoEvenDigit(x[k]) ==> exists m :: 0 <= m < |filtered| && filtered[m] == x[k])
    {
      if HasNoEvenDigit(x[i]) {
        filtered := filtered + [x[i]];
      }
      i := i + 1;
    }
  
    var sortedUnique: seq<nat> := [];
    var j := 0;
    while j < |filtered|
      invariant 0 <= j <= |filtered|
      invariant IsSorted(sortedUnique)
      invariant IsUnique(sortedUnique)
      invariant forall k :: 0 <= k < |sortedUnique| ==> exists m :: 0 <= m < j && filtered[m] == sortedUnique[k]
      invariant forall m :: 0 <= m < j ==> (exists k :: 0 <= k < |sortedUnique| && sortedUnique[k] == filtered[m])
    {
      var found := false;
      var k := 0;
      while k < |sortedUnique|
        invariant 0 <= k <= |sortedUnique|
        invariant found ==> exists m :: 0 <= m < k && sortedUnique[m] == filtered[j]
      {
        if sortedUnique[k] == filtered[j] {
          found := true;
          break;
        }
        k := k + 1;
      }
      if !found {
        var pos := 0;
        while pos < |sortedUnique| && sortedUnique[pos] < filtered[j]
          invariant 0 <= pos <= |sortedUnique|
          invariant pos > 0 ==> sortedUnique[pos-1] < filtered[j]
        {
          pos := pos + 1;
        }
        assert pos == 0 || sortedUnique[pos-1] <= filtered[j];
        assert pos == |sortedUnique| || filtered[j] <= sortedUnique[pos];
        assert forall i :: 0 <= i < k ==> sortedUnique[i] != filtered[j];
        SortedInsertMaintainsSorted(sortedUnique, filtered[j], pos);
        SortedInsertMaintainsUnique(sortedUnique, filtered[j], pos);
        sortedUnique := sortedUnique[..pos] + [filtered[j]] + sortedUnique[pos..];
      }
      j := j + 1;
    }
    result := sortedUnique;
  }

vc-postamble: |-


