vc-preamble: |-
  function comparison(a : string, b : string, i : int): bool
      requires 0 <= i <= |a| && 0 <= i <= |b|
      decreases |a| - i
      decreases |b| - i
      ensures (a == b) ==> comparison(a, b, i)
  {
      if (i < |a| && i < |b|) then
          if a[i] < b[i] then
              true
          else if a[i] > b[i] then
              false
          else
              comparison(a, b, i + 1)
      else
          if |a| <= |b| then
              true
          else
              false
  }
  method sort_strings(list: seq<string>) returns (sorted: seq<string>)
      ensures |sorted| == |list|
      ensures multiset(sorted) == multiset(list)
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  // Helper predicate to check if a sequence of strings is sorted by length
  predicate IsSortedByLength(s: seq<string>)
  {
      forall i, j :: 0 <= i < j < |s| ==> |s[i]| <= |s[j]|
  }
  
  // Helper lemma to prove multiset properties during concatenation
  lemma MultisetConcat(left: seq<string>, equal: seq<string>, right: seq<string>)
      ensures multiset(left) + multiset(equal) + multiset(right) == multiset(left + equal + right)
  {
  }
  
  // Helper lemma to ensure sorted concatenation preserves order
  lemma SortedConcat(left: seq<string>, equal: seq<string>, right: seq<string>)
      requires IsSortedByLength(left)
      requires IsSortedByLength(right)
      requires IsSortedByLength(equal)
      requires |equal| > 0 ==> forall i :: 0 <= i < |left| ==> |left[i]| < |equal[0]|
      requires |equal| > 0 ==> forall i :: 0 <= i < |right| ==> |equal[0]| < |right[i]|
      requires |equal| == 0 ==> forall i :: 0 <= i < |left| ==> forall j :: 0 <= j < |right| ==> |left[i]| < |right[j]|
      ensures IsSortedByLength(left + equal + right)
  {
      if |left| == 0 && |equal| == 0 {
          assert IsSortedByLength(right);
      } else if |left| == 0 {
          assert IsSortedByLength(equal + right);
      } else if |equal| == 0 {
          assert IsSortedByLength(left + right);
      } else {
          assert IsSortedByLength(left + equal + right);
      }
  }

vc-description: |-
  function_signature: method sort_lengths(list: seq<string>) returns (sorted: seq<string>)
  Sort elements. Requires: the condition holds for all values. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation.

vc-spec: |-
  method sort_lengths(list: seq<string>) returns (sorted: seq<string>)
      requires true
      ensures |sorted| == |list|
      ensures multiset(sorted) == multiset(list)
      ensures IsSortedByLength(sorted)
      decreases |list|

vc-code: |-
  {
      if |list| <= 1 {
          return list;
      }
      
      var pivot := list[|list| / 2];
      var left: seq<string> := [];
      var right: seq<string> := [];
      var equal: seq<string> := [];
      
      var i := 0;
      while i < |list|
          invariant 0 <= i <= |list|
          invariant multiset(left) + multiset(right) + multiset(equal) == multiset(list[..i])
          invariant forall x :: 0 <= x < |left| ==> |left[x]| < |pivot|
          invariant forall x :: 0 <= x < |right| ==> |right[x]| > |pivot|
          invariant forall x :: 0 <= x < |equal| ==> |equal[x]| == |pivot|
      {
          if |list[i]| < |pivot| {
              left := left + [list[i]];
          } else if |list[i]| > |pivot| {
              right := right + [list[i]];
          } else {
              equal := equal + [list[i]];
          }
          i := i + 1;
      }
      
      var sortedLeft := sort_lengths(left);
      var sortedRight := sort_lengths(right);
      
      MultisetConcat(sortedLeft, equal, sortedRight);
      SortedConcat(sortedLeft, equal, sortedRight);
      sorted := sortedLeft + equal + sortedRight;
  }

vc-postamble: |-
  method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)
      requires |list| > 0
      ensures |sorted| <= |list|
      ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0
      ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|
      ensures multiset(sorted) <= multiset(list)
  {
    assume{:axiom} false;
  }

