vc-preamble: |-
  method is_prime(k: int) returns (result: bool)
    // pre-conditions-start
    requires k >= 2
    // pre-conditions-end
    // post-conditions-start
    ensures result ==> forall i :: 2 <= i < k ==> k % i != 0
    ensures !result ==> exists j :: 2 <= j < k && k % j == 0
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function is_prime_pred(k: int) : bool
  {
    forall i :: 2 <= i < k ==> k % i != 0
  }

vc-helpers: |-
  // Helper lemma to prove properties about prime factors
  lemma PrimeFactorExists(n: int)
    requires n >= 2
    ensures exists p :: 2 <= p <= n && is_prime_pred(p) && n % p == 0
  {
    var i := 2;
    while i <= n
      invariant 2 <= i <= n + 1
      invariant forall j :: 2 <= j < i ==> n % j != 0 || !is_prime_pred(j)
    {
      if n % i == 0 {
        if is_prime_pred(i) {
          return;
        } else {
          assert exists k :: 2 <= k < i && i % k == 0;
          var k :| 2 <= k < i && i % k == 0;
          assert n % k == 0;
        }
      }
      i := i + 1;
    }
  }
  
  // Lemma to assist in proving the largest prime factor
  lemma LargestPrimeFactorExists(n: int)
    requires n >= 2
    ensures exists p :: 2 <= p <= n && is_prime_pred(p) && n % p == 0 && 
                       forall q :: p < q <= n && is_prime_pred(q) ==> n % q != 0
  {
    var primeFactors := set p | 2 <= p <= n && is_prime_pred(p) && n % p == 0;
    assert primeFactors != {} by {
      PrimeFactorExists(n);
    }
    var largest := 2;
    for p in primeFactors {
      if p > largest {
        largest := p;
      }
    }
    assert largest in primeFactors;
    assert forall q :: largest < q <= n && is_prime_pred(q) ==> n % q != 0;
  }

vc-description: |-
  function_signature: method largest_prime_factor(n: int) returns (largest: int)
  Process input. Requires: the result is at least the specified value. Ensures: returns the correct size/count.

vc-spec: |-
  method largest_prime_factor(n: int) returns (largest: int)
    requires n >= 2
    ensures 2 <= largest <= n
    ensures is_prime_pred(largest)
    ensures n % largest == 0
    ensures forall p :: largest < p <= n && is_prime_pred(p) ==> n % p != 0

vc-code: |-
  {
    var i := n;
    while i >= 2
      invariant 2 <= i <= n + 1
      invariant forall p :: i < p <= n && is_prime_pred(p) ==> n % p != 0
    {
      if n % i == 0 {
        var isPrime := true;
        var j := 2;
        while j * j <= i
          invariant 2 <= j <= i + 1
          invariant isPrime ==> forall k :: 2 <= k < j ==> i % k != 0
        {
          if i % j == 0 {
            isPrime := false;
            break;
          }
          j := j + 1;
        }
        if isPrime && i >= 2 {
          return i;
        }
      }
      i := i - 1;
    }
    assert false by {
      LargestPrimeFactorExists(n);
      assert exists p :: 2 <= p <= n && is_prime_pred(p) && n % p == 0 && 
                         forall q :: p < q <= n && is_prime_pred(q) ==> n % q != 0;
    }
  }

vc-postamble: |-


