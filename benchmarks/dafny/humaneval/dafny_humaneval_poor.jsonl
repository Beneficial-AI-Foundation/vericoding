{"id": "DH0093", "language": "dafny", "source": "humaneval", "source_id": "humaneval_091", "vc-description": "This verification task involves implementing a method to count the number of sentences that start with the word \"I\". Sentences are separated by '.', '?' or '!' characters. The implementation should parse the input string into sentences, trim whitespace from each sentence, extract the first word, and check if it equals \"I\".\n\nThe expected implementation should use the provided helper functions to split sentences, trim whitespace, and count sentences starting with \"I\", ensuring the result matches the functional specification.", "vc-preamble": "\npredicate ValidInput(s: string) { true }\n\nfunction starts_with_I(s: string): bool\n{\n    var trimmed := trim(s);\n    if |trimmed| == 0 then false\n    else\n        var first_word := get_first_word(trimmed);\n        first_word == \"I\"\n}\n\nfunction get_first_word(s: string): string\n    requires |s| > 0\n    decreases |s|\n{\n    get_first_word_helper(s, 0)\n}\n\nfunction split_sentences(S: string): seq<string>\n    ensures forall i :: 0 <= i < |split_sentences(S)| ==> |split_sentences(S)[i]| >= 0\n{\n    if |S| == 0 then []\n    else\n        var sentences := [];\n        var current := \"\";\n        var i := 0;\n        split_sentences_helper(S, i, current, sentences)\n}\n\nfunction count_sentences_starting_with_I(S: string): int\n    ensures count_sentences_starting_with_I(S) >= 0\n    ensures S == \"\" ==> count_sentences_starting_with_I(S) == 0\n    ensures count_sentences_starting_with_I(S) <= |split_sentences(S)|\n{\n    var sentences := split_sentences(S);\n    count_bored_sentences(sentences)\n}\n\nfunction get_first_word_helper(s: string, i: int): string\n    requires 0 <= i <= |s|\n    requires |s| > 0\n    decreases |s| - i\n{\n    if i == |s| || s[i] == ' ' then s[0..i]\n    else get_first_word_helper(s, i + 1)\n}\n\nfunction split_sentences_helper(S: string, i: int, current: string, sentences: seq<string>): seq<string>\n    requires 0 <= i <= |S|\n    ensures forall j :: 0 <= j < |split_sentences_helper(S, i, current, sentences)| ==> |split_sentences_helper(S, i, current, sentences)[j]| >= 0\n    decreases |S| - i\n{\n    if i == |S| then\n        if |current| > 0 then sentences + [current] else sentences\n    else if S[i] == '.' || S[i] == '?' || S[i] == '!' then\n        var new_sentences := if |current| > 0 then sentences + [current] else sentences;\n        split_sentences_helper(S, i + 1, \"\", new_sentences)\n    else\n        split_sentences_helper(S, i + 1, current + [S[i]], sentences)\n}\n\nfunction trim(s: string): string\n    ensures |trim(s)| <= |s|\n{\n    trim_left(trim_right(s))\n}\n\nfunction trim_left(s: string): string\n    ensures |trim_left(s)| <= |s|\n    decreases |s|\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' then trim_left(s[1..])\n    else s\n}\n\nfunction trim_right(s: string): string\n    ensures |trim_right(s)| <= |s|\n    decreases |s|\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == ' ' then trim_right(s[..|s|-1])\n    else s\n}\n\nfunction count_bored_sentences(sentences: seq<string>): int\n    requires forall i :: 0 <= i < |sentences| ==> |sentences[i]| >= 0\n    ensures count_bored_sentences(sentences) >= 0\n    ensures count_bored_sentences(sentences) <= |sentences|\n    ensures count_bored_sentences(sentences) == |set i | 0 <= i < |sentences| && starts_with_I(sentences[i])|\n    decreases |sentences|\n{\n    if |sentences| == 0 then 0\n    else\n        var count := if starts_with_I(sentences[0]) then 1 else 0;\n        var rest_count := count_bored_sentences(sentences[1..]);\n\n        var full_set := set i | 0 <= i < |sentences| && starts_with_I(sentences[i]);\n        var first_set := if starts_with_I(sentences[0]) then {0} else {};\n        var rest_set := set i | 1 <= i < |sentences| && starts_with_I(sentences[i]);\n        var tail_set := set j | 0 <= j < |sentences[1..]| && starts_with_I(sentences[1..][j]);\n\n        assert full_set == first_set + rest_set;\n        assert forall j :: 0 <= j < |sentences[1..]| ==> sentences[1..][j] == sentences[j+1];\n        assert forall i :: i in rest_set ==> (i-1) in tail_set;\n        assert forall j :: j in tail_set ==> (j+1) in rest_set;\n\n        var f := map i | i in rest_set :: i-1;\n        var g := map j | j in tail_set :: j+1;\n        assert forall i :: i in rest_set ==> f[i] in tail_set;\n        assert forall j :: j in tail_set ==> g[j] in rest_set;\n        assert forall i :: i in rest_set ==> g[f[i]] == i;\n        assert forall j :: j in tail_set ==> f[g[j]] == j;\n\n        assert |rest_set| == |tail_set|;\n        assert |full_set| == |first_set| + |tail_set|;\n\n        count + rest_count\n}", "vc-helpers": "", "vc-spec": "method CountSentencesStartingWithI(S: string) returns (count: int)\n    requires ValidInput(S)\n    ensures count >= 0\n    ensures S == \"\" ==> count == 0\n    ensures count <= |split_sentences(S)|\n    ensures count == count_sentences_starting_with_I(S)\n    ensures count == |set i | 0 <= i < |split_sentences(S)| && starts_with_I(split_sentences(S)[i])|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "timeout"}
{"id": "DH0142", "language": "dafny", "source": "humaneval", "source_id": "humaneval_140", "vc-description": "This verification task involves implementing a string transformation method that replaces spaces according to specific rules: individual spaces or pairs of consecutive spaces become underscores (one per space), while sequences of more than 2 consecutive spaces become a single dash. The implementation must preserve the order of non-space characters and satisfy several correctness predicates.", "vc-preamble": "\npredicate ValidInput(text: string)\n{\n    true\n}\n\npredicate IsSpaceSequence(text: string, start: int, end: int)\n    requires 0 <= start <= end < |text|\n{\n    (forall k :: start <= k <= end ==> text[k] == ' ') &&\n    (start == 0 || text[start-1] != ' ') &&\n    (end == |text|-1 || text[end+1] != ' ')\n}\n\npredicate ValidResult(text: string, result: string)\n{\n    |result| <= |text| &&\n    (text == \"\" ==> result == \"\") &&\n    (forall i :: 0 <= i < |result| ==> result[i] != ' ') &&\n    (forall i :: 0 <= i < |result| ==> result[i] == '_' || result[i] == '-' || result[i] in text) &&\n    ((forall i :: 0 <= i < |text| ==> text[i] != ' ') ==> result == text) &&\n    (forall i :: 0 <= i < |text| && text[i] != ' ' ==> text[i] in result)\n}\n\npredicate PreservesOrder(text: string, result: string)\n{\n    forall i, j :: 0 <= i < j < |text| && text[i] != ' ' && text[j] != ' ' ==>\n        exists i', j' :: 0 <= i' < j' < |result| && result[i'] == text[i] && result[j'] == text[j]\n}\n\npredicate CorrectSpaceTransformation(text: string, result: string)\n{\n    (forall start, end :: (0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end)) ==>\n        ((end - start + 1 <= 2 ==> (exists pos :: 0 <= pos < |result| - (end - start) && \n            (forall i :: pos <= i <= pos + (end - start) ==> result[i] == '_'))) &&\n        (end - start + 1 > 2 ==> (exists pos :: 0 <= pos < |result| && result[pos] == '-'))) &&\n    (forall i :: 0 <= i < |result| && result[i] == '_' ==> \n        exists start, end :: 0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end) && end - start + 1 <= 2) &&\n    (forall i :: 0 <= i < |result| && result[i] == '-' ==> \n        exists start, end :: 0 <= start <= end < |text| && \n        IsSpaceSequence(text, start, end) && end - start + 1 > 2)\n}", "vc-helpers": "", "vc-spec": "method fix_spaces(text: string) returns (result: string)\n    requires ValidInput(text)\n    ensures ValidResult(text, result)\n    ensures PreservesOrder(text, result)\n    ensures CorrectSpaceTransformation(text, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": "", "qa-issue": 1, "qa-issue-type": "timeout"}
