vc-preamble: |-
  datatype Option<T> = None | Some(T)
  function getVal(mx : Option<int>) : int
      requires mx != None
  {
      match mx {
          case Some(n) => n
      }
  }

vc-helpers: |-
  predicate HasAtLeastTwoDistinct(lst: seq<int>)
  {
      exists i, j :: 0 <= i < |lst| && 0 <= j < |lst| && i != j && lst[i] != lst[j]
  }
  
  function SetOfSeq(lst: seq<int>): set<int>
  {
      set x | x in lst
  }
  
  function SmallerElements(lst: seq<int>, x: int): seq<int>
  {
      seq(i | 0 <= i < |lst| && lst[i] < x, lst[i])
  }
  
  predicate AllSame(lst: seq<int>)
  {
      forall i, j :: 0 <= i < |lst| && 0 <= j < |lst| ==> lst[i] == lst[j]
  }
  
  lemma DistinctElementsLemma(lst: seq<int>)
      ensures HasAtLeastTwoDistinct(lst) <==> |SetOfSeq(lst)| >= 2
  {
  }
  
  function FindSecondSmallest(lst: seq<int>): Option<int>
  {
      if |lst| == 0 then None
      else
          var min1 := Min(lst);
          var remaining := seq(i | 0 <= i < |lst| && lst[i] != min1, lst[i]);
          if |remaining| == 0 then None
          else Some(Min(remaining))
  }
  
  function Min(lst: seq<int>): int
      requires |lst| > 0
  {
      if |lst| == 1 then lst[0]
      else
          var rest_min := Min(lst[1..]);
          if lst[0] <= rest_min then lst[0] else rest_min
  }
  
  lemma MinIsSmallest(lst: seq<int>)
      requires |lst| > 0
      ensures forall i :: 0 <= i < |lst| ==> Min(lst) <= lst[i]
      ensures Min(lst) in lst
  {
  }
  
  lemma SecondSmallestCorrect(lst: seq<int>)
      requires |lst| > 0
      ensures match FindSecondSmallest(lst) {
          case None => !HasAtLeastTwoDistinct(lst)
          case Some(x) => 
              HasAtLeastTwoDistinct(lst) &&
              x in lst &&
              (exists y :: y in lst && y < x) &&
              AllSame(SmallerElements(lst, x))
      }
  {
      MinIsSmallest(lst);
      if |lst| == 0 {}
      else {
          var min1 := Min(lst);
          var remaining := seq(i | 0 <= i < |lst| && lst[i] != min1, lst[i]);
          if |remaining| == 0 {
              assert !HasAtLeastTwoDistinct(lst);
          } else {
              var min2 := Min(remaining);
              MinIsSmallest(remaining);
              assert HasAtLeastTwoDistinct(lst);
              assert min2 in lst;
              assert min1 < min2;
              assert AllSame(SmallerElements(lst, min2));
          }
      }
  }

vc-description: |-
  function_signature: def next_smallest(lst: List[int]) -> Optional[int]
  You are given a list of integers. Write a function next_smallest() that returns the 2nd smallest element of the list. Return None if there is no such element. TODO(George): Remove this when being reviewed The spec is defined as: if result is none there is no second smallest element, which exists in a finite list iff there are at least two distinct elements in the list. If result is some x, then x is the second smallest element of the list, the spec obtains the sublist of elements smaller than the result, and checks that this sublist does not contain two distinct elements (they are all the same).

vc-spec: |-
  function next_smallest(lst: seq<int>): Option<int>
      ensures match next_smallest(lst) {
          case None => !HasAtLeastTwoDistinct(lst)
          case Some(x) => 
              HasAtLeastTwoDistinct(lst) &&
              x in lst &&
              (exists y :: y in lst && y < x) &&
              AllSame(SmallerElements(lst, x))
      }

vc-code: |-
  {
      if |lst| == 0 then {
          None
      } else {
          SecondSmallestCorrect(lst);
          FindSecondSmallest(lst)
      }
  }

vc-postamble: |-


