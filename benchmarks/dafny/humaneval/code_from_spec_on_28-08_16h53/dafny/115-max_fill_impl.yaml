vc-preamble: |-


vc-helpers: |-
  function sum(s: seq<int>) : int {
      if |s| == 0 then 0 else s[0] + sum(s[1..])
  }
  
  function sum_nat(s: seq<nat>) : int {
      if |s| == 0 then 0 else s[0] as int + sum_nat(s[1..])
  }
  
  function gen_seq(grid: seq<seq<nat>>, capacity: nat, len: nat): seq<int>
    requires capacity > 0
    requires len <= |grid|
    requires forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1
  {
    seq(len, j requires 0 <= j < len => (sum_nat(grid[j]) + capacity as int - 1) / capacity as int)
  }
  
  lemma sum_gen_seq_property(grid: seq<seq<nat>>, capacity: nat, i: int)
    requires capacity > 0
    requires 0 <= i <= |grid|
    requires forall k, j :: 0 <= k < |grid| && 0 <= j < |grid[k]| ==> grid[k][j] == 0 || grid[k][j] == 1
    ensures sum(gen_seq(grid, capacity, i)) == if i == 0 then 0 else sum(gen_seq(grid, capacity, i-1)) + (sum_nat(grid[i-1]) + capacity as int - 1) / capacity as int
  {
    if i == 0 {
      assert gen_seq(grid, capacity, 0) == [];
    } else {
      var seq1 := gen_seq(grid, capacity, i-1);
      var seq2 := gen_seq(grid, capacity, i);
      assert seq2 == seq1 + [(sum_nat(grid[i-1]) + capacity as int - 1) / capacity as int];
      sum_append_property(seq1, (sum_nat(grid[i-1]) + capacity as int - 1) / capacity as int);
    }
  }
  
  lemma sum_append_property(s: seq<int>, x: int)
    ensures sum(s + [x]) == sum(s) + x
  {
    if |s| == 0 {
      assert s + [x] == [x];
    } else {
      calc {
        sum(s + [x]);
        == s[0] + sum((s + [x])[1..]);
        == s[0] + sum(s[1..] + [x]);
        == { sum_append_property(s[1..], x); }
        s[0] + sum(s[1..]) + x;
        == sum(s) + x;
      }
    }
  }

vc-description: |-
  function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int
  You are given a rectangular grid of wells. Each row represents a single well, and each 1 in a row represents a single unit of water. Each well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. Your task is to use the buckets to empty the wells. Output the number of times you need to lower the buckets. Constraints: * all wells have the same length * 1 <= grid.length <= 10^2 * 1 <= grid[:,1].length <= 10^2 * grid[i][j] -> 0 | 1 * 1 <= capacity <= 10

vc-spec: |-
  method max_fill_count(grid: seq<seq<nat>>, capacity: nat) returns (result: int)
    requires capacity > 0
    requires forall i :: 0 <= i < |grid| ==> forall j :: 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1
    requires |grid| > 0 ==> forall i :: 0 <= i < |grid| ==> |grid[i]| == |grid[0]|
    ensures result >= 0
    ensures result == sum(gen_seq(grid, capacity, |grid|))

vc-code: |-
  {
    if |grid| == 0 {
      result := 0;
      return;
    }
    
    result := 0;
    var i := 0;
    
    while i < |grid|
      invariant 0 <= i <= |grid|
      invariant result == sum(gen_seq(grid, capacity, i))
    {
      var water_in_well := sum_nat(grid[i]);
      var buckets_needed := (water_in_well + capacity as int - 1) / capacity as int;
      sum_gen_seq_property(grid, capacity, i + 1);
      result := result + buckets_needed;
      i := i + 1;
    }
  }

vc-postamble: |-
  function gen_seq(grid: seq<seq<nat>>, capacity: nat, len: nat): seq<int>
    requires capacity > 0
    requires len <= |grid|
    requires forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1
  {
    seq(len, j requires 0 <= j < len => (sum(grid[j]) + capacity - 1) / capacity)
  }
  // pure-end
  function sum(s: seq<int>) : int {
      if |s| == 0 then 0 else s[0] + sum(s[1..])
  }
  // pure-end

