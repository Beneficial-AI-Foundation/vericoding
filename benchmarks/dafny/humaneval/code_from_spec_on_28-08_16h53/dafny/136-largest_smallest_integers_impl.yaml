vc-preamble: |-
  datatype Option<T> = None | Some(value: T)
  function get_value(o: Option<int>): int
    requires o.Some?
    ensures get_value(o) == o.value
  {
    o.value
  }

vc-helpers: |-
  lemma helper_largest_neg_preserved(lst: seq<int>, i: int, largest_neg: Option<int>)
    requires 0 <= i < |lst|
    requires (largest_neg.Some? ==> (largest_neg.value < 0 && largest_neg.value in lst[..i] && 
             forall x :: x in lst[..i] && x < 0 ==> x <= largest_neg.value))
    requires (largest_neg.None? ==> forall x :: x in lst[..i] ==> x >= 0)
    requires lst[i] >= 0
    ensures (largest_neg.Some? ==> (largest_neg.value < 0 && largest_neg.value in lst[..i+1] && 
            forall x :: x in lst[..i+1] && x < 0 ==> x <= largest_neg.value))
    ensures (largest_neg.None? ==> forall x :: x in lst[..i+1] ==> x >= 0)
  {
    assert lst[..i+1] == lst[..i] + [lst[i]];
  }
  
  lemma helper_smallest_pos_preserved(lst: seq<int>, i: int, smallest_pos: Option<int>)
    requires 0 <= i < |lst|
    requires (smallest_pos.Some? ==> (smallest_pos.value > 0 && smallest_pos.value in lst[..i] && 
             forall x :: x in lst[..i] && x > 0 ==> x >= smallest_pos.value))
    requires (smallest_pos.None? ==> forall x :: x in lst[..i] ==> x <= 0)
    requires lst[i] <= 0
    ensures (smallest_pos.Some? ==> (smallest_pos.value > 0 && smallest_pos.value in lst[..i+1] && 
            forall x :: x in lst[..i+1] && x > 0 ==> x >= smallest_pos.value))
    ensures (smallest_pos.None? ==> forall x :: x in lst[..i+1] ==> x <= 0)
  {
    assert lst[..i+1] == lst[..i] + [lst[i]];
  }

vc-description: |-
  function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]
  Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.

vc-spec: |-
  method largest_smallest_integers(lst: seq<int>) returns (largest_neg: Option<int>, smallest_pos: Option<int>)
    ensures (largest_neg.Some? ==> (largest_neg.value < 0 && largest_neg.value in lst && 
             forall x :: x in lst && x < 0 ==> x <= largest_neg.value)) &&
            (largest_neg.None? ==> forall x :: x in lst ==> x >= 0) &&
            (smallest_pos.Some? ==> (smallest_pos.value > 0 && smallest_pos.value in lst && 
             forall x :: x in lst && x > 0 ==> x >= smallest_pos.value)) &&
            (smallest_pos.None? ==> forall x :: x in lst ==> x <= 0)

vc-code: |-
  {
    largest_neg := None;
    smallest_pos := None;
    
    var i := 0;
    while i < |lst|
      invariant 0 <= i <= |lst|
      invariant (largest_neg.Some? ==> (largest_neg.value < 0 && largest_neg.value in lst[..i] && 
                forall x :: x in lst[..i] && x < 0 ==> x <= largest_neg.value))
      invariant (largest_neg.None? ==> forall x :: x in lst[..i] ==> x >= 0)
      invariant (smallest_pos.Some? ==> (smallest_pos.value > 0 && smallest_pos.value in lst[..i] && 
                forall x :: x in lst[..i] && x > 0 ==> x >= smallest_pos.value))
      invariant (smallest_pos.None? ==> forall x :: x in lst[..i] ==> x <= 0)
    {
      if lst[i] < 0 {
        if largest_neg.None? || lst[i] > largest_neg.value {
          largest_neg := Some(lst[i]);
        }
        helper_smallest_pos_preserved(lst, i, smallest_pos);
      } else if lst[i] > 0 {
        if smallest_pos.None? || lst[i] < smallest_pos.value {
          smallest_pos := Some(lst[i]);
        }
        helper_largest_neg_preserved(lst, i, largest_neg);
      } else {
        helper_largest_neg_preserved(lst, i, largest_neg);
        helper_smallest_pos_preserved(lst, i, smallest_pos);
      }
      i := i + 1;
    }
  }

vc-postamble: |-


