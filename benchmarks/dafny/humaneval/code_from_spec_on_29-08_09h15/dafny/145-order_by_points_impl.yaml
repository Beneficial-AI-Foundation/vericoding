vc-preamble: |-
  function digits_sum_pos(n: int): int
    requires n >= 0
  {
    if n < 10 then n else digits_sum_pos(n / 10) + n % 10
  }
  function digits_sum(n: int): int {
    if n < 0 then digits_sum_pos(-n) else digits_sum_pos(n)
  }

vc-helpers: |-
  lemma digits_sum_pos_non_negative(n: int)
    requires n >= 0
    ensures digits_sum_pos(n) >= 0
  {
    if n < 10 {
    } else {
      digits_sum_pos_non_negative(n / 10);
    }
  }
  
  lemma multiset_preservation_append(s1: seq<int>, s2: seq<int>, x: int)
    ensures multiset(s1 + [x] + s2) == multiset([x]) + multiset(s1 + s2)
  {
    assert multiset(s1 + [x] + s2) == multiset(s1) + multiset([x]) + multiset(s2);
    assert multiset(s1 + s2) == multiset(s1) + multiset(s2);
    assert multiset([x]) + multiset(s1 + s2) == multiset([x]) + multiset(s1) + multiset(s2);
  }
  
  lemma multiset_preservation_insert(s: seq<int>, x: int, pos: int)
    requires 0 <= pos <= |s|
    ensures multiset(s[..pos] + [x] + s[pos..]) == multiset([x]) + multiset(s)
  {
    assert s == s[..pos] + s[pos..];
    multiset_preservation_append(s[..pos], s[pos..], x);
    assert multiset(s[..pos] + [x] + s[pos..]) == multiset([x]) + multiset(s[..pos] + s[pos..]);
    assert multiset(s[..pos] + s[pos..]) == multiset(s);
  }
  
  lemma insertion_sort_maintains_order(s: seq<int>, x: int, pos: int)
    requires 0 <= pos <= |s|
    requires forall i, j :: 0 <= i < j < |s| ==> digits_sum(s[i]) <= digits_sum(s[j])
    requires pos == 0 || digits_sum(s[pos-1]) <= digits_sum(x)
    requires pos == |s| || digits_sum(x) <= digits_sum(s[pos])
    ensures forall i, j :: 0 <= i < j < |s[..pos] + [x] + s[pos..]| ==> 
      digits_sum((s[..pos] + [x] + s[pos..])[i]) <= digits_sum((s[..pos] + [x] + s[pos..])[j])
  {
  }
  
  lemma find_position_correct(s: seq<int>, x: int, pos: int)
    requires 0 <= pos <= |s|
    requires forall i, j :: 0 <= i < j < |s| ==> digits_sum(s[i]) <= digits_sum(s[j])
    requires forall k :: 0 <= k < pos ==> digits_sum(s[k]) <= digits_sum(x)
    requires pos < |s| ==> digits_sum(x) <= digits_sum(s[pos])
    ensures pos == 0 || digits_sum(s[pos-1]) <= digits_sum(x)
    ensures pos == |s| || digits_sum(x) <= digits_sum(s[pos])
  {
  }
  
  lemma multiset_step_preservation(old_s: seq<int>, new_s: seq<int>, orig_s: seq<int>, i: int)
    requires 0 <= i < |orig_s|
    requires multiset(old_s) == multiset(orig_s[..i])
    requires multiset(new_s) == multiset([orig_s[i]]) + multiset(old_s)
    ensures multiset(new_s) == multiset(orig_s[..i+1])
  {
    assert orig_s[..i+1] == orig_s[..i] + [orig_s[i]];
    assert multiset(orig_s[..i+1]) == multiset(orig_s[..i]) + multiset([orig_s[i]]);
  }
  
  lemma sequence_prefix_complete<T>(s: seq<T>)
    ensures s[..|s|] == s
  {
  }

vc-description: |-
  function_signature: def order_by_points(nums: List[int]) -> List[int]
  Write a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.

vc-spec: |-
  method order_by_points(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> digits_sum(sorted[i]) <= digits_sum(sorted[j])
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    sorted := [];
    
    for i := 0 to |s|
      invariant 0 <= i <= |s|
      invariant |sorted| == i
      invariant forall j, k :: 0 <= j < k < |sorted| ==> digits_sum(sorted[j]) <= digits_sum(sorted[k])
      invariant multiset(sorted) == multiset(s[..i])
    {
      var x := s[i];
      var pos := 0;
      
      while pos < |sorted| && digits_sum(sorted[pos]) <= digits_sum(x)
        invariant 0 <= pos <= |sorted|
        invariant forall k :: 0 <= k < pos ==> digits_sum(sorted[k]) <= digits_sum(x)
      {
        pos := pos + 1;
      }
      
      find_position_correct(sorted, x, pos);
      
      var new_sorted := sorted[..pos] + [x] + sorted[pos..];
      
      multiset_preservation_insert(sorted, x, pos);
      insertion_sort_maintains_order(sorted, x, pos);
      multiset_step_preservation(sorted, new_sorted, s, i);
      
      sorted := new_sorted;
    }
    
    sequence_prefix_complete(s);
  }

vc-postamble: |-


