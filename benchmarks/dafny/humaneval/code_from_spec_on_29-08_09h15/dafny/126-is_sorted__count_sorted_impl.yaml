vc-preamble: |-
  method is_sorted(a: seq<int>) returns (f: bool)
    // post-conditions-start
    ensures f == forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> count_set(a, a[i]) <= 2
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma count_set_properties(a: seq<int>, x: int)
    ensures count_set(a, x) >= 0
    ensures count_set(a, x) <= |a|
  {
    var s := set i | 0 <= i < |a| && a[i] == x;
    assert s <= set i | 0 <= i < |a|;
    assert |s| <= |set i | 0 <= i < |a||;
    assert |set i | 0 <= i < |a|| == |a|;
  }
  
  lemma count_set_singleton(a: seq<int>, x: int, pos: int)
    requires 0 <= pos < |a|
    requires a[pos] == x
    requires forall i :: 0 <= i < |a| && i != pos ==> a[i] != x
    ensures count_set(a, x) == 1
  {
    var s := set i | 0 <= i < |a| && a[i] == x;
    assert pos in s;
    forall i | i in s
      ensures i == pos
    {
      assert 0 <= i < |a| && a[i] == x;
      if i != pos {
        assert a[i] != x;
        assert false;
      }
    }
    assert s == {pos};
    assert |s| == 1;
  }
  
  lemma sorted_occurrences_contiguous(a: seq<int>, x: int, i: int, j: int)
    requires forall k, l :: 0 <= k <= l < |a| ==> a[k] <= a[l]
    requires 0 <= i < j < |a|
    requires a[i] == x && a[j] == x
    requires forall k :: i < k < j ==> a[k] != x
    ensures false
  {
    if i + 1 < j {
      var mid := i + 1;
      assert a[i] <= a[mid] <= a[j];
      assert a[i] == x && a[j] == x;
      assert a[mid] != x;
      if a[mid] < x {
        assert a[mid] < a[i];
        assert false;
      } else if a[mid] > x {
        assert a[j] < a[mid];
        assert false;
      } else {
        assert a[mid] == x;
        assert false;
      }
    } else {
      assert j == i + 1;
      assert !(i < i + 1 < j);
    }
  }
  
  lemma sorted_find_all_occurrences(a: seq<int>, x: int, start: int)
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= start < |a|
    requires a[start] == x
    requires start == 0 || a[start - 1] < x
    ensures forall i :: 0 <= i < |a| && a[i] == x ==> start <= i
    ensures forall i :: start <= i < |a| && a[i] > x ==> forall j :: i <= j < |a| ==> a[j] >= x
  {
    forall i | 0 <= i < |a| && a[i] == x
      ensures start <= i
    {
      if i < start {
        assert a[i] <= a[start - 1];
        assert a[start - 1] < x;
        assert a[i] < x;
        assert false;
      }
    }
  }
  
  lemma set_equality_lemma(a: seq<int>, x: int, pos: int, end: int)
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= pos < end <= |a|
    requires forall i :: pos <= i < end ==> a[i] == x
    requires pos == 0 || a[pos - 1] < x
    requires end == |a| || a[end] > x
    ensures (set i | 0 <= i < |a| && a[i] == x) == (set i | pos <= i < end && a[i] == x)
  {
    var left_set := set i | 0 <= i < |a| && a[i] == x;
    var right_set := set i | pos <= i < end && a[i] == x;
    
    forall i | i in left_set
      ensures i in right_set
    {
      assert 0 <= i < |a| && a[i] == x;
      if i < pos {
        if pos > 0 {
          assert a[i] <= a[pos - 1];
          assert a[pos - 1] < x;
          assert a[i] < x;
          assert false;
        } else {
          assert false;
        }
      } else if i >= end {
        if end < |a| {
          assert a[end] <= a[i];
          assert a[end] > x;
          assert a[i] > x;
          assert false;
        } else {
          assert false;
        }
      } else {
        assert pos <= i < end && a[i] == x;
      }
    }
    
    forall i | i in right_set
      ensures i in left_set
    {
      assert pos <= i < end && a[i] == x;
      assert 0 <= i < |a| && a[i] == x;
    }
  }
  
  lemma range_set_size(pos: int, end: int, x: int)
    requires pos < end
    ensures |set i | pos <= i < end| == end - pos
  {
    var s := set i | pos <= i < end;
    assert s == set i | pos <= i < end;
    
    if end == pos + 1 {
      assert s == {pos};
      assert |s| == 1;
      assert end - pos == 1;
    } else {
      range_set_size(pos, end - 1, x);
      var s_prev := set i | pos <= i < end - 1;
      assert s == s_prev + {end - 1};
      assert end - 1 !in s_prev;
      assert |s| == |s_prev| + 1;
      assert |s_prev| == end - 1 - pos;
      assert |s| == end - pos;
    }
  }

vc-description: |-
  function_signature: method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)
  Count occurrences. Requires: the condition holds for all values; the size is bounded; returns the correct value; returns the correct size/count. Ensures: returns the correct value.

vc-spec: |-
  method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)
    // pre-conditions-start
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= pos < |a|
    requires a[pos] == x
    requires pos == 0 || a[pos - 1] < x
    // pre-conditions-end
    // post-conditions-start
    ensures count == count_set(a, x)
    // post-conditions-end

vc-code: |-
  {
    count := 1;
    var end := pos + 1;
    
    while end < |a| && a[end] == x
      invariant pos < end <= |a|
      invariant forall i :: pos <= i < end ==> a[i] == x
      invariant end == |a| || a[end] != x
      invariant count == end - pos
    {
      count := count + 1;
      end := end + 1;
    }
    
    assert forall i :: pos <= i < end ==> a[i] == x;
    assert end == |a| || a[end] > x;
    assert pos == 0 || a[pos - 1] < x;
    
    set_equality_lemma(a, x, pos, end);
    assert (set i | 0 <= i < |a| && a[i] == x) == (set i | pos <= i < end && a[i] == x);
    
    range_set_size(pos, end, x);
    assert |set i | pos <= i < end| == end - pos;
    assert count == end - pos;
    assert count == |set i | pos <= i < end && a[i] == x|;
    assert count == |set i | 0 <= i < |a| && a[i] == x|;
    assert count == count_set(a, x);
  }

vc-postamble: |-
  function count_set(a: seq<int>, x: int): int {
    |set i | 0 <= i < |a| && a[i] == x|
  }
  // pure-end

