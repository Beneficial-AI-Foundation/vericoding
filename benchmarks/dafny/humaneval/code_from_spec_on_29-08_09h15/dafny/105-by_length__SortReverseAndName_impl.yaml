vc-preamble: |-


vc-helpers: |-
  lemma NumberToNameInSet(n: int)
    requires 1 <= n <= 9
    ensures NumberToName(n) in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
  {
    // The proof is automatic given the definition of NumberToName
  }
  
  lemma FilterPreservesSize<T>(s: seq<T>, p: T -> bool)
    ensures |FilterSeq(s, p)| <= |s|
  {
    if |s| == 0 {
      // Base case: empty sequence
    } else {
      // Inductive case
      FilterPreservesSize(s[1..], p);
    }
  }
  
  function FilterSeq<T>(s: seq<T>, p: T -> bool): seq<T>
  {
    if |s| == 0 then []
    else if p(s[0]) then [s[0]] + FilterSeq(s[1..], p)
    else FilterSeq(s[1..], p)
  }
  
  function MapSeq<T, U>(s: seq<T>, f: T -> U): seq<U>
    requires forall i :: 0 <= i < |s| ==> f.requires(s[i])
  {
    if |s| == 0 then []
    else [f(s[0])] + MapSeq(s[1..], f)
  }
  
  lemma MapSeqLength<T, U>(s: seq<T>, f: T -> U)
    requires forall i :: 0 <= i < |s| ==> f.requires(s[i])
    ensures |MapSeq(s, f)| == |s|
  {
    if |s| == 0 {
      // Base case
    } else {
      // Inductive case
      MapSeqLength(s[1..], f);
    }
  }
  
  lemma MapSeqProperty<T, U>(s: seq<T>, f: T -> U)
    requires forall i :: 0 <= i < |s| ==> f.requires(s[i])
    ensures |MapSeq(s, f)| == |s|
    ensures forall i :: 0 <= i < |s| ==> MapSeq(s, f)[i] == f(s[i])
  {
    if |s| == 0 {
      // Base case
    } else {
      // Inductive case
      MapSeqProperty(s[1..], f);
    }
  }
  
  lemma FilteredElementsInRange(s: seq<int>, p: int -> bool)
    requires forall x :: p(x) <==> (1 <= x <= 9)
    ensures forall i :: 0 <= i < |FilterSeq(s, p)| ==> 1 <= FilterSeq(s, p)[i] <= 9
  {
    if |s| == 0 {
      // Base case
    } else {
      if p(s[0]) {
        FilteredElementsInRange(s[1..], p);
      } else {
        FilteredElementsInRange(s[1..], p);
      }
    }
  }
  
  lemma NumberToNameRequiresForFiltered(s: seq<int>)
    requires forall i :: 0 <= i < |s| ==> 1 <= s[i] <= 9
    ensures forall i :: 0 <= i < |s| ==> NumberToName.requires(s[i])
  {
    // The proof follows from the precondition and the requires clause of NumberToName
  }

vc-description: |-
  function_signature: method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)
  Sort elements. Ensures: the size is bounded; the condition holds for all values.

vc-spec: |-
  method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)
    // post-conditions-start
    ensures |result| <= |arr|
    ensures forall i :: 0 <= i < |result| ==>
      result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    // post-conditions-end

vc-code: |-
  {
    var sorted := SortSeq(arr);
    var reversed := reverse(sorted);
    var filtered := FilterSeq(reversed, x => 1 <= x <= 9);
    
    FilterPreservesSize(reversed, x => 1 <= x <= 9);
    assert |filtered| <= |reversed|;
    assert |reversed| == |sorted|;
    assert |sorted| == |arr|;
    assert |filtered| <= |arr|;
    
    FilteredElementsInRange(reversed, x => 1 <= x <= 9);
    assert forall i :: 0 <= i < |filtered| ==> 1 <= filtered[i] <= 9;
    
    NumberToNameRequiresForFiltered(filtered);
    assert forall i :: 0 <= i < |filtered| ==> NumberToName.requires(filtered[i]);
    
    result := MapSeq(filtered, NumberToName);
    
    MapSeqLength(filtered, NumberToName);
    assert |result| == |filtered|;
    assert |result| <= |arr|;
    
    MapSeqProperty(filtered, NumberToName);
    forall i | 0 <= i < |result|
      ensures result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    {
      assert result[i] == NumberToName(filtered[i]);
      assert 1 <= filtered[i] <= 9;
      NumberToNameInSet(filtered[i]);
    }
  }

vc-postamble: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  method reverse(s: seq<int>) returns (rev: seq<int>)
    // post-conditions-start
    ensures |rev| == |s|
    ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function NumberToName(n: int): string
    requires 1 <= n <= 9
  {
    match n
    case 1 => "One"
    case 2 => "Two"
    case 3 => "Three"
    case 4 => "Four"
    case 5 => "Five"
    case 6 => "Six"
    case 7 => "Seven"
    case 8 => "Eight"
    case 9 => "Nine"
  }
  // pure-end

