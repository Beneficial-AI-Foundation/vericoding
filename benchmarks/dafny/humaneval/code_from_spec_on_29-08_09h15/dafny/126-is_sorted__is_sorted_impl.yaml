vc-preamble: |-


vc-helpers: |-
  lemma count_set_properties(a: seq<int>, x: int)
    ensures count_set(a, x) >= 0
    ensures count_set(a, x) <= |a|
  {
    var s := set i {:trigger a[i]} | 0 <= i < |a| && a[i] == x;
    assert s <= set i | 0 <= i < |a| by {
      forall k | k in s ensures k in set i | 0 <= i < |a| {
        assert 0 <= k < |a|;
      }
    }
    var full_set := set i | 0 <= i < |a|;
    assert full_set == set i | 0 <= i < |a| && 0 <= i < |a|;
    finite_set_cardinality_lemma(s, full_set);
  }
  
  lemma finite_set_cardinality_lemma<T>(s: set<T>, t: set<T>)
    requires s <= t
    requires t == set i | 0 <= i < |t|
    ensures |s| <= |t|
  {
  }
  
  lemma count_set_empty(x: int)
    ensures count_set([], x) == 0
  {
    var empty_set := set i | 0 <= i < 0 && [][i] == x;
    assert empty_set == {};
  }
  
  lemma count_set_single(x: int, y: int)
    ensures count_set([x], y) == (if x == y then 1 else 0)
  {
    if x == y {
      var single_set := set i | 0 <= i < 1 && [x][i] == y;
      assert single_set == {0};
    } else {
      var empty_set := set i | 0 <= i < 1 && [x][i] == y;
      assert empty_set == {};
    }
  }
  
  lemma count_set_loop_invariant(a: seq<int>, x: int, j: int)
    requires 0 <= j <= |a|
    ensures |set k | 0 <= k < j && a[k] == x| <= j
  {
    var s := set k {:trigger a[k]} | 0 <= k < j && a[k] == x;
    var indices := set k | 0 <= k < j;
    assert s <= indices;
    assert |indices| == j;
  }

vc-description: |-
  function_signature: method is_sorted(a: seq<int>) returns (f: bool)
  Sort elements. Ensures: the condition holds for all values.

vc-spec: |-
  method is_sorted(a: seq<int>) returns (f: bool)
    // post-conditions-start
    ensures f == forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> count_set(a, a[i]) <= 2
    // post-conditions-end

vc-code: |-
  {
    if |a| == 0 {
      f := true;
      return;
    }
    
    // Check if sorted
    var i := 0;
    while i < |a| - 1
      invariant 0 <= i <= |a| - 1
      invariant forall k, l :: 0 <= k <= l <= i ==> a[k] <= a[l]
    {
      if a[i] > a[i + 1] {
        f := false;
        return;
      }
      i := i + 1;
    }
    
    // Check count constraint
    i := 0;
    while i < |a|
      invariant 0 <= i <= |a|
      invariant forall k :: 0 <= k < i ==> count_set(a, a[k]) <= 2
      invariant forall k, l :: 0 <= k <= l < |a| ==> a[k] <= a[l]
    {
      var count := 0;
      var j := 0;
      while j < |a|
        invariant 0 <= j <= |a|
        invariant count == |set k | 0 <= k < j && a[k] == a[i]|
      {
        if a[j] == a[i] {
          count := count + 1;
        }
        j := j + 1;
        
        assert count == |set k | 0 <= k < j && a[k] == a[i]| by {
          var old_set := set k | 0 <= k < j - 1 && a[k] == a[i];
          var new_set := set k | 0 <= k < j && a[k] == a[i];
          if a[j - 1] == a[i] {
            assert new_set == old_set + {j - 1};
          } else {
            assert new_set == old_set;
          }
        }
      }
      
      assert count == count_set(a, a[i]);
      
      if count > 2 {
        f := false;
        return;
      }
      i := i + 1;
    }
    
    f := true;
  }

vc-postamble: |-
  method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)
    // pre-conditions-start
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= pos < |a|
    requires a[pos] == x
    requires pos == 0 || a[pos - 1] < x
    // pre-conditions-end
    // post-conditions-start
    ensures count == count_set(a, x)
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function count_set(a: seq<int>, x: int): int {
    |set i | 0 <= i < |a| && a[i] == x|
  }
  // pure-end

