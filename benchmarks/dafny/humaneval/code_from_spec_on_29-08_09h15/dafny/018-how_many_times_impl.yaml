vc-preamble: |-


vc-helpers: |-
  lemma SubstringAtPositionUnique(s: string, substr: string, i: int, j: int)
      requires 0 <= i <= |s| - |substr|
      requires 0 <= j <= |s| - |substr|
      requires s[i..i+|substr|] == substr
      requires s[j..j+|substr|] == substr
      ensures i == j ==> true
  {
  }
  
  lemma CountingLemma(s: string, substr: string, n: int)
      requires 0 <= n <= |s| - |substr| + 1
      requires |substr| > 0
      ensures |set i {:trigger s[i..i+|substr|]} | 0 <= i < n && 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr| 
           == |set i {:trigger s[i..i+|substr|]} | 0 <= i < n && s[i..i+|substr|] == substr|
  {
      assert forall i {:trigger s[i..i+|substr|]} :: (0 <= i < n && 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr) 
                      <==> (0 <= i < n && s[i..i+|substr|] == substr);
  }
  
  lemma SetEquivalence(s: string, substr: string, n: int)
      requires n == |s| - |substr| + 1
      requires |substr| > 0
      requires |substr| <= |s|
      ensures (set j {:trigger s[j..j+|substr|]} | 0 <= j < n && s[j..j+|substr|] == substr) 
           == (set j {:trigger s[j..j+|substr|]} | 0 <= j <= |s| - |substr| && s[j..j+|substr|] == substr)
  {
      assert n - 1 == |s| - |substr|;
      assert forall j {:trigger s[j..j+|substr|]} :: (0 <= j < n && s[j..j+|substr|] == substr)
                      <==> (0 <= j <= |s| - |substr| && s[j..j+|substr|] == substr);
  }
  
  lemma EmptySubstringLemma(s: string, substr: string)
      requires |substr| == 0
      ensures |set i | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr| == |s| + 1
  {
      assert substr == "";
      assert forall i :: 0 <= i <= |s| ==> s[i..i] == "";
      var S := set i | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr;
      assert S == set i | 0 <= i <= |s|;
      assert |S| == |s| + 1;
  }
  
  lemma TooLongSubstringLemma(s: string, substr: string)
      requires |substr| > |s|
      ensures (set i | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr) == {}
  {
      assert |s| - |substr| < 0;
      assert forall i :: !(0 <= i <= |s| - |substr|);
  }
  
  lemma IncrementLemma(s: string, substr: string, i: int, oldTimes: int)
      requires 0 <= i <= |s| - |substr|
      requires |substr| > 0
      requires oldTimes == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr|
      requires s[i..i+|substr|] == substr
      ensures oldTimes + 1 == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i + 1 && s[j..j+|substr|] == substr|
  {
      var oldSet := set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr;
      var newSet := set j {:trigger s[j..j+|substr|]} | 0 <= j < i + 1 && s[j..j+|substr|] == substr;
      assert i in newSet;
      assert newSet == oldSet + {i};
      assert i !in oldSet;
  }
  
  lemma NoIncrementLemma(s: string, substr: string, i: int, oldTimes: int)
      requires 0 <= i <= |s| - |substr|
      requires |substr| > 0
      requires oldTimes == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr|
      requires s[i..i+|substr|] != substr
      ensures oldTimes == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i + 1 && s[j..j+|substr|] == substr|
  {
      var oldSet := set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr;
      var newSet := set j {:trigger s[j..j+|substr|]} | 0 <= j < i + 1 && s[j..j+|substr|] == substr;
      assert i !in newSet;
      assert newSet == oldSet;
  }

vc-description: |-
  function_signature: def how_many_times(string: str, substring: str) -> int
  Find how many times a given substring can be found in the original string. Count overlaping cases.

vc-spec: |-
  method how_many_times(s: string, substr: string) returns (times: int)
      // post-condition-start
      ensures times == |set i {:trigger} | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr|
      // post-condition-end

vc-code: |-
  {
      if |substr| == 0 {
          times := |s| + 1;
          EmptySubstringLemma(s, substr);
          return;
      }
      
      if |substr| > |s| {
          times := 0;
          TooLongSubstringLemma(s, substr);
          return;
      }
      
      times := 0;
      var i := 0;
      
      while i <= |s| - |substr|
          invariant 0 <= i <= |s| - |substr| + 1
          invariant times == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr|
      {
          if s[i..i+|substr|] == substr {
              IncrementLemma(s, substr, i, times);
              times := times + 1;
          } else {
              NoIncrementLemma(s, substr, i, times);
          }
          i := i + 1;
      }
      
      assert times == |set j {:trigger s[j..j+|substr|]} | 0 <= j < i && s[j..j+|substr|] == substr|;
      assert i == |s| - |substr| + 1;
      CountingLemma(s, substr, i);
      SetEquivalence(s, substr, i);
      assert times == |set j {:trigger s[j..j+|substr|]} | 0 <= j <= |s| - |substr| && s[j..j+|substr|] == substr|;
  }

vc-postamble: |-


