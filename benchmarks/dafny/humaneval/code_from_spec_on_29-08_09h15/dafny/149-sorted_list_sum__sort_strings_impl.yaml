vc-preamble: |-
  function comparison(a : string, b : string, i : int): bool
      requires 0 <= i <= |a| && 0 <= i <= |b|
      decreases |a| - i
      decreases |b| - i
      ensures (a == b) ==> comparison(a, b, i)
  {
      if (i < |a| && i < |b|) then
          if a[i] < b[i] then
              true
          else if a[i] > b[i] then
              false
          else
              comparison(a, b, i + 1)
      else
          if |a| <= |b| then
              true
          else
              false
  }

vc-helpers: |-
  lemma comparison_is_total_order(a: string, b: string)
      ensures comparison(a, b, 0) || comparison(b, a, 0)
      ensures comparison(a, b, 0) && comparison(b, a, 0) ==> a == b
  {
      comparison_total_order_helper(a, b, 0);
      comparison_antisymmetric_helper(a, b, 0);
  }
  
  lemma comparison_total_order_helper(a: string, b: string, i: int)
      requires 0 <= i <= |a| && 0 <= i <= |b|
      ensures comparison(a, b, i) || comparison(b, a, i)
      decreases |a| - i + |b| - i
  {
      if (i < |a| && i < |b|) {
          if a[i] < b[i] {
          } else if a[i] > b[i] {
          } else {
              comparison_total_order_helper(a, b, i + 1);
          }
      }
  }
  
  lemma comparison_antisymmetric_helper(a: string, b: string, i: int)
      requires 0 <= i <= |a| && 0 <= i <= |b|
      ensures comparison(a, b, i) && comparison(b, a, i) ==> a[i..] == b[i..]
      decreases |a| - i + |b| - i
  {
      if (i < |a| && i < |b|) {
          if a[i] < b[i] {
          } else if a[i] > b[i] {
          } else {
              comparison_antisymmetric_helper(a, b, i + 1);
          }
      }
  }
  
  lemma comparison_transitive(a: string, b: string, c: string)
      requires comparison(a, b, 0) && comparison(b, c, 0)
      ensures comparison(a, c, 0)
  {
      comparison_transitive_helper(a, b, c, 0);
  }
  
  lemma comparison_transitive_helper(a: string, b: string, c: string, i: int)
      requires 0 <= i <= |a| && 0 <= i <= |b| && 0 <= i <= |c|
      requires comparison(a, b, i) && comparison(b, c, i)
      ensures comparison(a, c, i)
      decreases |a| - i + |b| - i + |c| - i
  {
      if (i < |a| && i < |b| && i < |c|) {
          if a[i] < b[i] {
          } else if b[i] < c[i] {
          } else if a[i] == b[i] && b[i] == c[i] {
              comparison_transitive_helper(a, b, c, i + 1);
          }
      }
  }
  
  lemma comparison_reflexive(a: string)
      ensures comparison(a, a, 0)
  {
  }
  
  method insert_sorted(sorted: seq<string>, x: string) returns (result: seq<string>)
      requires forall i, j :: 0 <= i < j < |sorted| ==> comparison(sorted[i], sorted[j], 0)
      ensures |result| == |sorted| + 1
      ensures multiset(result) == multiset(sorted) + multiset{x}
      ensures forall i, j :: 0 <= i < j < |result| ==> comparison(result[i], result[j], 0)
  {
      var pos := 0;
      while pos < |sorted| && !comparison(x, sorted[pos], 0)
          invariant 0 <= pos <= |sorted|
          invariant forall k :: 0 <= k < pos ==> !comparison(x, sorted[k], 0)
          invariant forall k :: 0 <= k < pos ==> comparison(sorted[k], x, 0)
      {
          comparison_is_total_order(x, sorted[pos]);
          pos := pos + 1;
      }
      result := sorted[..pos] + [x] + sorted[pos..];
      
      forall i, j | 0 <= i < j < |result|
          ensures comparison(result[i], result[j], 0)
      {
          if i < pos && j == pos {
              assert result[i] == sorted[i];
              assert result[j] == x;
          } else if i == pos && j > pos {
              assert result[i] == x;
              assert result[j] == sorted[j-1];
              if pos < |sorted| {
                  comparison_is_total_order(x, sorted[pos]);
                  assert comparison(x, sorted[pos], 0);
                  comparison_transitive(x, sorted[pos], sorted[j-1]);
              }
          } else if i < pos && j > pos {
              assert result[i] == sorted[i];
              assert result[j] == sorted[j-1];
          }
      }
  }

vc-description: |-
  function_signature: method sort_strings(list: seq<string>) returns (sorted: seq<string>)
  Sort elements. Ensures: returns the correct size/count; returns a sorted permutation of the input.

vc-spec: |-
  method sort_strings(list: seq<string>) returns (sorted: seq<string>)
      ensures |sorted| == |list|
      ensures multiset(sorted) == multiset(list)

vc-code: |-
  {
      sorted := [];
      var i := 0;
      while i < |list|
          invariant 0 <= i <= |list|
          invariant |sorted| == i
          invariant multiset(sorted) == multiset(list[..i])
          invariant forall x, y :: 0 <= x < y < |sorted| ==> comparison(sorted[x], sorted[y], 0)
      {
          var old_sorted := sorted;
          sorted := insert_sorted(sorted, list[i]);
          
          assert multiset(sorted) == multiset(old_sorted) + multiset{list[i]};
          assert multiset(old_sorted) == multiset(list[..i]);
          assert list[..i+1] == list[..i] + [list[i]];
          assert multiset(list[..i+1]) == multiset(list[..i]) + multiset{list[i]};
          
          i := i + 1;
      }
      assert i == |list|;
      assert list[..i] == list;
      assert multiset(sorted) == multiset(list[..i]);
  }

vc-postamble: |-
  method sort_lengths(list: seq<string>) returns (sorted: seq<string>)
      requires forall i : int :: 0 <= i < |list| ==> |list[i]| % 2 == 0
      ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0
      ensures |sorted| == |list|
      ensures multiset(sorted) == multiset(list)
      ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|
  {
    assume{:axiom} false;
  }
  method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)
      requires |list| > 0
      ensures |sorted| <= |list|
      ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0
      ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|
      ensures multiset(sorted) <= multiset(list)
  {
    assume{:axiom} false;
  }

