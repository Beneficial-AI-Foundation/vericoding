vc-preamble: |-
  datatype Option<T> = None | Some(value: T)
  function get_value(o: Option<int>): int
    requires o.Some?
    ensures get_value(o) == o.value
  {
    o.value
  }

vc-helpers: |-
  lemma InArrayImpliesIndex<T>(arr: seq<T>, x: T)
    requires x in arr
    ensures exists i :: 0 <= i < |arr| && arr[i] == x
  {
  }
  
  lemma ArraySliceInclusion<T>(arr: seq<T>, i: int)
    requires 0 <= i < |arr|
    ensures arr[i] in arr[0..i+1]
  {
  }
  
  lemma ArraySliceToFullArray<T>(arr: seq<T>, x: T, i: int)
    requires 0 <= i <= |arr|
    requires x in arr[0..i]
    ensures x in arr
  {
  }

vc-description: |-
  function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]
  Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.

vc-spec: |-
  method largest_smallest_integers(arr: seq<int>) returns (a: Option<int>, b: Option<int>)
    // post-conditions-start
    ensures a.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] >= 0
    ensures a.Some? ==> get_value(a) in arr && get_value(a) < 0
    ensures a.Some? ==> forall i :: 0 <= i < |arr| && arr[i] < 0 ==> arr[i] <= get_value(a)
    ensures b.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] <= 0
    ensures b.Some? ==> get_value(b) in arr && get_value(b) > 0
    ensures b.Some? ==> forall i :: 0 <= i < |arr| && arr[i] > 0 ==> arr[i] >= get_value(b)
    // post-conditions-end

vc-code: |-
  {
    a := None;
    b := None;
    
    for i := 0 to |arr|
      invariant a.None? ==> forall j :: 0 <= j < i ==> arr[j] >= 0
      invariant a.Some? ==> get_value(a) < 0
      invariant a.Some? ==> exists k :: 0 <= k < i && arr[k] == get_value(a)
      invariant a.Some? ==> forall j :: 0 <= j < i && arr[j] < 0 ==> arr[j] <= get_value(a)
      invariant b.None? ==> forall j :: 0 <= j < i ==> arr[j] <= 0
      invariant b.Some? ==> get_value(b) > 0
      invariant b.Some? ==> exists k :: 0 <= k < i && arr[k] == get_value(b)
      invariant b.Some? ==> forall j :: 0 <= j < i && arr[j] > 0 ==> arr[j] >= get_value(b)
    {
      if arr[i] < 0 {
        if a.None? || arr[i] > get_value(a) {
          a := Some(arr[i]);
        }
      }
      
      if arr[i] > 0 {
        if b.None? || arr[i] < get_value(b) {
          b := Some(arr[i]);
        }
      }
    }
  }

vc-postamble: |-


