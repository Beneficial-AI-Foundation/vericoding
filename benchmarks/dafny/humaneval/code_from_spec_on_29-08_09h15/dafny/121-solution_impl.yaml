vc-preamble: |-


vc-helpers: |-
  lemma SumEmptySeq(s: seq<int>)
    requires |s| == 0
    ensures sum(s, seq(0, i requires 0 <= i < 0 => false)) == 0
  {
  }
  
  lemma SumRecursive(s: seq<int>, p: seq<bool>)
    requires |s| == |p|
    requires |s| > 0
    ensures sum(s, p) == (if p[0] then s[0] else 0) + sum(s[1..], p[1..])
  {
  }
  
  lemma SumPredicateEquivalence(numbers: seq<int>, i: int)
    requires 0 <= i < |numbers|
    ensures (i % 2 == 0 && numbers[i] % 2 == 1) == (seq(|numbers|, j requires 0 <= j < |numbers| => j % 2 == 0 && numbers[j] % 2 == 1)[i])
  {
  }
  
  lemma SumInvariantMaintenance(numbers: seq<int>, s: int, i: int)
    requires 0 <= i < |numbers|
    requires s == sum(numbers[..i], seq(i, j requires 0 <= j < i => j % 2 == 0 && numbers[j] % 2 == 1))
    ensures s + (if i % 2 == 0 && numbers[i] % 2 == 1 then numbers[i] else 0) == 
            sum(numbers[..i+1], seq(i+1, j requires 0 <= j < i+1 => j % 2 == 0 && numbers[j] % 2 == 1))
  {
    var newS := s + (if i % 2 == 0 && numbers[i] % 2 == 1 then numbers[i] else 0);
    var predicateNew := seq(i+1, j requires 0 <= j < i+1 => j % 2 == 0 && numbers[j] % 2 == 1);
    var predicateOld := seq(i, j requires 0 <= j < i => j % 2 == 0 && numbers[j] % 2 == 1);
    
    assert numbers[..i+1] == numbers[..i] + [numbers[i]];
    assert predicateNew == predicateOld + [i % 2 == 0 && numbers[i] % 2 == 1];
    
    SumRecursive(numbers[..i+1], predicateNew);
    assert sum(numbers[..i+1], predicateNew) == 
           (if predicateNew[0] then numbers[..i+1][0] else 0) + sum((numbers[..i+1])[1..], predicateNew[1..]);
    
    if i == 0 {
      assert numbers[..i] == [];
      assert predicateOld == [];
      assert sum(numbers[..i], predicateOld) == 0;
    } else {
      assert (numbers[..i+1])[1..] == numbers[1..i+1];
      assert predicateNew[1..] == predicateOld[1..] + [i % 2 == 0 && numbers[i] % 2 == 1];
    }
    
    assert numbers[..i+1][i] == numbers[i];
    assert predicateNew[i] == (i % 2 == 0 && numbers[i] % 2 == 1);
  }

vc-description: |-
  function_signature: def solution(lst: List[int]) -> int
  Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.

vc-spec: |-
  method solution(numbers: seq<int>) returns (s: int)
    // post-conditions-start
    ensures s == sum(numbers, seq(|numbers|, i requires 0 <= i < |numbers| => i % 2 == 0 && numbers[i] % 2 == 1))
    // post-conditions-end

vc-code: |-
  {
    s := 0;
    var i := 0;
    
    while i < |numbers|
      invariant 0 <= i <= |numbers|
      invariant s == sum(numbers[..i], seq(i, j requires 0 <= j < i => j % 2 == 0 && numbers[j] % 2 == 1))
    {
      var oldS := s;
      if i % 2 == 0 && numbers[i] % 2 == 1 {
        s := s + numbers[i];
      }
      SumInvariantMaintenance(numbers, oldS, i);
      i := i + 1;
    }
    
    assert numbers[..|numbers|] == numbers;
    assert seq(|numbers|, j requires 0 <= j < |numbers| => j % 2 == 0 && numbers[j] % 2 == 1) == 
           seq(|numbers|, j requires 0 <= j < |numbers| => j % 2 == 0 && numbers[j] % 2 == 1);
  }

vc-postamble: |-
  function sum(s: seq<int>, p: seq<bool>) : int
    requires |s| == |p|
  {
    if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sum(s[1..], p[1..])
  }
  // pure-end

