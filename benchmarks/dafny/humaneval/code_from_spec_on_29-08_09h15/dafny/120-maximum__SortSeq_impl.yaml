vc-preamble: |-
  method maximum(s: seq<int>, k: int) returns (result: seq<int>)
    // pre-conditions-start
    requires 1 <= k <= |s|
    requires 1 <= |s| <= 1000
    requires forall x :: x in s ==> -1000 <= x <= 1000
    // pre-conditions-end
    // post-conditions-start
    ensures |result| == k
    ensures forall i, j :: 0 <= i < j < k ==> result[i] <= result[j]
    ensures forall x :: x in result ==> x in s
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma InsertPreservesMultiset(arr: array<int>, i: int, key: int, old_contents: multiset<int>)
    requires 0 <= i <= arr.Length
    requires old_contents == multiset(arr[..i]) + multiset([key]) + multiset(arr[i..])
    ensures multiset(arr[..]) == old_contents
  {
    assert arr[..] == arr[..i] + arr[i..];
    assert multiset(arr[..]) == multiset(arr[..i]) + multiset(arr[i..]);
  }
    
  lemma InsertionSortPreservesMultiset(arr: array<int>, old_contents: multiset<int>)
    requires old_contents == multiset(arr[..])
    ensures multiset(arr[..]) == old_contents
  {
  }
  
  lemma SortedUpTo(arr: array<int>, i: int)
    requires 0 <= i <= arr.Length
    ensures forall j, k :: 0 <= j < k < i ==> arr[j] <= arr[k]
  {
    if i <= 1 {
      assert forall j, k :: 0 <= j < k < i ==> arr[j] <= arr[k];
    }
  }
  
  lemma ArraySliceProperties(arr: array<int>)
    ensures |arr[..]| == arr.Length
    ensures forall i :: 0 <= i < arr.Length ==> arr[i] in arr[..]
    ensures forall x :: x in arr[..] ==> exists i :: 0 <= i < arr.Length && arr[i] == x
  {
  }
  
  lemma MultisetEquivalence(s: seq<int>, arr: array<int>)
    requires |s| == arr.Length
    requires forall i :: 0 <= i < |s| ==> arr[i] == s[i]
    ensures multiset(arr[..]) == multiset(s)
  {
    if |s| == 0 {
      assert multiset(arr[..]) == multiset{} == multiset(s);
    } else {
      assert arr[..] == s;
      assert multiset(arr[..]) == multiset(s);
    }
  }
  
  lemma SortedTransitivity(arr: array<int>, i: int, key: int)
    requires 0 < i <= arr.Length
    requires forall j, k :: 0 <= j < k < i ==> arr[j] <= arr[k]
    requires forall j :: 0 <= j < i ==> arr[j] <= key
    ensures forall j, k :: 0 <= j < k < i + 1 ==> (if k == i then arr[j] <= key else arr[j] <= arr[k])
  {
  }
  
  lemma MultisetPreservedByShift(arr: array<int>, j: int, old_multiset: multiset<int>)
    requires 0 <= j < arr.Length - 1
    requires old_multiset == multiset(arr[..])
    ensures multiset(arr[..]) == old_multiset
  {
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && s[i] == sorted[j]
    ensures forall x :: x in s ==> x in sorted
    ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && sorted[i] == s[j]
    ensures forall x :: x in sorted ==> x in s

vc-code: |-
  {
    if |s| == 0 {
      return [];
    }
    
    var arr := new int[|s|];
    forall i | 0 <= i < |s| {
      arr[i] := s[i];
    }
    
    MultisetEquivalence(s, arr);
    
    var i := 1;
    while i < arr.Length
      invariant 1 <= i <= arr.Length
      invariant forall j, k :: 0 <= j < k < i ==> arr[j] <= arr[k]
      invariant multiset(arr[..]) == multiset(s)
    {
      var key := arr[i];
      var j := i - 1;
      
      ghost var old_multiset := multiset(arr[..]);
      
      while j >= 0 && arr[j] > key
        invariant -1 <= j < i
        invariant forall k :: j + 2 <= k <= i ==> arr[k] >= key
        invariant forall k :: 0 <= k <= j ==> k + 1 > arr.Length || arr[k] <= arr[k + 1] || k + 1 > j
        invariant forall a, b :: 0 <= a < b <= j ==> arr[a] <= arr[b]
        invariant forall a, b :: j + 2 <= a < b <= i ==> arr[a] <= arr[b]
        invariant j >= 0 ==> forall a :: 0 <= a <= j ==> arr[a] <= key
        invariant multiset(arr[..]) == multiset(s)
      {
        arr[j + 1] := arr[j];
        j := j - 1;
      }
      
      arr[j + 1] := key;
      
      assert forall a, b :: 0 <= a < b < i + 1 ==> arr[a] <= arr[b];
      
      i := i + 1;
    }
    
    sorted := arr[..];
    
    assert forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j];
    assert |sorted| == |s|;
    assert multiset(s) == multiset(sorted);
    ArraySliceProperties(arr);
  }

vc-postamble: |-


