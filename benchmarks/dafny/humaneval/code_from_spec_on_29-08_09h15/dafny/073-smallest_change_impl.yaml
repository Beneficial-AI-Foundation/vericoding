vc-preamble: |-


vc-helpers: |-
  lemma SetComprehensionCard(s: seq<int>) 
    ensures |set i {:trigger} | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i]| <= |s| / 2
  {
    var mismatched := set i {:trigger} | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i];
    var all_indices := set i {:trigger i} | 0 <= i < |s| / 2;
    
    if |s| == 0 {
      assert all_indices == {};
      assert mismatched == {};
    } else {
      var half := |s| / 2;
      assert all_indices == set i {:trigger i} | 0 <= i < half;
      
      var k := 0;
      var partial := {};
      while k < half
        invariant 0 <= k <= half
        invariant partial == set i {:trigger i} | 0 <= i < k
        invariant |partial| == k
      {
        partial := partial + {k};
        k := k + 1;
      }
      assert partial == all_indices;
      assert |all_indices| == half;
    }
    
    forall i | i in mismatched 
      ensures i in all_indices
    {
      assert 0 <= i < |s| / 2;
      assert i in all_indices;
    }
    
    assert mismatched <= all_indices;
  }
  
  lemma CardinalitySubset<T>(A: set<T>, B: set<T>)
    requires A <= B
    ensures |A| <= |B|
  {
    if A == {} {
      assert |A| == 0;
      assert 0 <= |B|;
    } else {
      var x :| x in A;
      var A' := A - {x};
      var B' := B - {x};
      assert A' <= B';
      CardinalitySubset(A', B');
      assert |A| == |A'| + 1;
      if x in B {
        assert |B| == |B'| + 1;
        assert |A| <= |B|;
      } else {
        assert false;
      }
    }
  }
  
  lemma SequenceBound(s: seq<int>)
    ensures |s| < 0x8000_0000
  {
    assert |s| >= 0;
  }
  
  lemma SetComprehensionFinite(s: seq<int>)
    ensures |set i {:trigger} | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i]| < 0x8000_0000
  {
    SetComprehensionCard(s);
    assert |set i {:trigger} | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i]| <= |s| / 2;
    SequenceBound(s);
    assert |s| / 2 < 0x8000_0000;
  }

vc-description: |-
  function_signature: def smallest_change(arr: List[int]) -> int
  Given an array arr of integers, find the minimum number of elements that need to be changed to make the array palindromic. A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.

vc-spec: |-
  method smallest_change(s: seq<int>) returns (c: int)
    // post-conditions-start
    ensures c == |set i | 0 <= i < |s| / 2 && s[i] != s[|s| - 1 - i]|
    // post-conditions-end

vc-code: |-
  {
    SequenceBound(s);
    SetComprehensionFinite(s);
    
    c := 0;
    var i := 0;
    var mismatched := {};
    
    while i < |s| / 2
      invariant 0 <= i <= |s| / 2
      invariant mismatched == set j {:trigger} | 0 <= j < i && s[j] != s[|s| - 1 - j]
      invariant c == |mismatched|
    {
      if s[i] != s[|s| - 1 - i] {
        mismatched := mismatched + {i};
        c := c + 1;
      }
      i := i + 1;
    }
    
    assert mismatched == set j {:trigger} | 0 <= j < |s| / 2 && s[j] != s[|s| - 1 - j];
  }

vc-postamble: |-


