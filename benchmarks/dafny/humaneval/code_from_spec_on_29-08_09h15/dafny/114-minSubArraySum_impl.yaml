vc-preamble: |-
  function Sum(a: seq<int>, s: int, t: int): int
    requires 0 <= s <= t <= |a|
  {
    if s == t then 0 else Sum(a, s, t-1) + a[t-1]
  }

vc-helpers: |-
  lemma SumAdditive(a: seq<int>, s: int, t: int, u: int)
    requires 0 <= s <= t <= u <= |a|
    ensures Sum(a, s, u) == Sum(a, s, t) + Sum(a, t, u)
  {
    if t == u {
      assert Sum(a, t, u) == 0;
      assert Sum(a, s, u) == Sum(a, s, t);
    } else {
      SumAdditive(a, s, t, u-1);
      assert Sum(a, s, u) == Sum(a, s, u-1) + a[u-1];
      assert Sum(a, s, u-1) == Sum(a, s, t) + Sum(a, t, u-1);
      assert Sum(a, t, u) == Sum(a, t, u-1) + a[u-1];
    }
  }
  
  lemma SumSingle(a: seq<int>, i: int)
    requires 0 <= i < |a|
    ensures Sum(a, i, i+1) == a[i]
  {
  }
  
  lemma SumNonNegative(a: seq<int>, s: int, t: int)
    requires 0 <= s <= t <= |a|
    requires forall i :: s <= i < t ==> a[i] >= 0
    ensures Sum(a, s, t) >= 0
  {
    if s == t {
    } else {
      SumNonNegative(a, s, t-1);
    }
  }
  
  lemma EmptySum(a: seq<int>, p: int, q: int)
    requires 0 <= p <= q <= |a|
    requires p == q
    ensures Sum(a, p, q) == 0
  {
  }
  
  lemma EmptySumNonNegative(s: int)
    requires s <= 0
    ensures 0 >= s
  {
  }

vc-description: |-
  function_signature: def minSubArraySum(nums : list[int]) -> int
  Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.

vc-spec: |-
  method minSubArraySum(a: seq<int>) returns (s: int)
    // post-conditions-start
    ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) >= s
    ensures exists k, m :: 0 <= k <= m <= |a| && s == Sum(a, k, m)
    // post-conditions-end

vc-code: |-
  {
    if |a| == 0 {
      s := 0;
      EmptySum(a, 0, 0);
      return;
    }
    
    s := a[0];
    var current_sum := a[0];
    var best_start := 0;
    var best_end := 1;
    
    SumSingle(a, 0);
    
    var i := 1;
    var current_start := 0;
    
    while i < |a|
      invariant 1 <= i <= |a|
      invariant 0 <= best_start < best_end <= i
      invariant s == Sum(a, best_start, best_end)
      invariant 0 <= current_start <= i
      invariant current_start < i ==> current_sum == Sum(a, current_start, i)
      invariant forall p, q :: 0 <= p < q <= i ==> Sum(a, p, q) >= s
    {
      var new_start := current_start;
      var new_sum := current_sum + a[i];
      
      if a[i] < new_sum {
        new_start := i;
        new_sum := a[i];
      }
      
      if new_sum < s {
        s := new_sum;
        best_start := new_start;
        best_end := i + 1;
      }
      
      forall p, q | 0 <= p < q <= i+1
        ensures Sum(a, p, q) >= s
      {
        if q <= i {
          assert Sum(a, p, q) >= s;
        } else {
          assert q == i+1;
          if p == new_start {
            if new_start == i {
              SumSingle(a, i);
              assert Sum(a, p, q) == a[i] == new_sum >= s;
            } else {
              SumAdditive(a, new_start, i, i+1);
              assert Sum(a, p, q) == Sum(a, new_start, i) + a[i];
              assert Sum(a, new_start, i) == current_sum;
              assert Sum(a, p, q) == current_sum + a[i] == new_sum >= s;
            }
          } else if p > new_start {
            SumAdditive(a, p, i, i+1);
            assert Sum(a, p, q) == Sum(a, p, i) + a[i];
            if new_start == i {
              assert Sum(a, p, i) >= 0;
              assert Sum(a, p, q) >= a[i] == new_sum >= s;
            } else {
              SumAdditive(a, new_start, p, i);
              assert Sum(a, new_start, i) == Sum(a, new_start, p) + Sum(a, p, i);
              assert Sum(a, p, i) == current_sum - Sum(a, new_start, p);
              assert Sum(a, p, q) == current_sum - Sum(a, new_start, p) + a[i];
              assert Sum(a, p, q) == new_sum - Sum(a, new_start, p);
              assert Sum(a, new_start, p) >= s;
              if new_sum >= s {
                assert Sum(a, p, q) >= s - Sum(a, new_start, p) >= s - s;
                assert Sum(a, p, q) >= 0;
                if s <= 0 {
                  assert Sum(a, p, q) >= s;
                } else {
                  assert Sum(a, p, q) >= new_sum - s >= s - s;
                  assert Sum(a, p, q) >= 0 >= s;
                }
              }
            }
          } else {
            SumAdditive(a, p, i, i+1);
            assert Sum(a, p, q) == Sum(a, p, i) + a[i];
            if new_start == i {
              assert Sum(a, p, i) >= 0;
              assert Sum(a, p, q) >= a[i] >= s;
            } else {
              assert p < new_start;
              SumAdditive(a, p, new_start, i);
              assert Sum(a, p, i) == Sum(a, p, new_start) + Sum(a, new_start, i);
              assert Sum(a, p, i) == Sum(a, p, new_start) + current_sum;
              assert Sum(a, p, q) == Sum(a, p, new_start) + current_sum + a[i];
              assert Sum(a, p, q) == Sum(a, p, new_start) + new_sum;
              assert Sum(a, p, new_start) >= s;
              assert Sum(a, p, q) >= s + new_sum;
              if new_sum >= 0 {
                assert Sum(a, p, q) >= s;
              } else {
                assert Sum(a, p, q) >= s + new_sum >= s + s;
                if s <= 0 {
                  assert Sum(a, p, q) >= 2 * s >= s;
                }
              }
            }
          }
        }
      }
      
      current_start := new_start;
      current_sum := new_sum;
      
      i := i + 1;
    }
    
    forall p, q | 0 <= p <= q <= |a|
      ensures Sum(a, p, q) >= s
    {
      if p == q {
        EmptySum(a, p, q);
        assert Sum(a, p, q) == 0;
        EmptySumNonNegative(s);
      } else {
        assert Sum(a, p, q) >= s;
      }
    }
  }

vc-postamble: |-


