vc-preamble: |-
  function popcount(n: nat): nat {
    if n == 0 then 0
    else popcount(n / 2) + n % 2
  }

vc-helpers: |-
  lemma PopcountStable(a: nat, b: nat)
    requires popcount(a) == popcount(b)
    ensures popcount(a) <= popcount(b)
  {
  }
  
  lemma PopcountTransitive(a: nat, b: nat, c: nat)
    requires popcount(a) <= popcount(b) && popcount(b) <= popcount(c)
    ensures popcount(a) <= popcount(c)
  {
  }
  
  predicate SortedByPopcount(s: seq<nat>)
  {
    forall i, j :: 0 <= i < j < |s| ==> 
      popcount(s[i]) < popcount(s[j]) || 
      (popcount(s[i]) == popcount(s[j]) && s[i] <= s[j])
  }
  
  lemma InsertionSortPreservesMultiset(s: seq<nat>, sorted: seq<nat>)
    requires |s| == |sorted|
    requires multiset(s) == multiset(sorted)
    ensures multiset(s) == multiset(sorted)
  {
  }
  
  lemma InsertMaintainsSorted(arr: seq<nat>, key: nat, pos: int)
    requires 0 <= pos <= |arr|
    requires SortedByPopcount(arr)
    requires forall k :: 0 <= k < pos ==> 
      popcount(arr[k]) < popcount(key) || 
      (popcount(arr[k]) == popcount(key) && arr[k] <= key)
    ensures SortedByPopcount(arr[..pos] + [key] + arr[pos..])
  {
    var result := arr[..pos] + [key] + arr[pos..];
    forall i, j | 0 <= i < j < |result|
      ensures popcount(result[i]) < popcount(result[j]) || 
              (popcount(result[i]) == popcount(result[j]) && result[i] <= result[j])
    {
      if i < pos && j == pos {
        assert result[i] == arr[i];
        assert result[j] == key;
      } else if i == pos && j > pos {
        assert result[i] == key;
        assert result[j] == arr[j-1];
        assert arr[j-1] == arr[pos + (j - pos - 1)];
      } else if i < pos && j > pos {
        assert result[i] == arr[i];
        assert result[j] == arr[j-1];
        assert SortedByPopcount(arr);
      } else if i < pos && j < pos {
        assert result[i] == arr[i];
        assert result[j] == arr[j];
        assert SortedByPopcount(arr);
      } else if i > pos && j > pos {
        assert result[i] == arr[i-1];
        assert result[j] == arr[j-1];
        assert SortedByPopcount(arr);
      }
    }
  }
  
  lemma MultisetPreservedBySwap(s: seq<nat>, i: int, j: int, val: nat)
    requires 0 <= i < |s|
    requires multiset(s) == multiset(s[i := val])
    ensures multiset(s) == multiset(s[i := val])
  {
  }

vc-description: |-
  function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int
  Please write a function that sorts an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.

vc-spec: |-
  method sort_array(s: seq<nat>) returns (sorted: seq<nat>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> popcount(sorted[i]) <= popcount(sorted[j])
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  {
    sorted := s;
    
    if |sorted| <= 1 {
      return;
    }
    
    var i := 1;
    while i < |sorted|
      invariant 1 <= i <= |sorted|
      invariant |sorted| == |s|
      invariant multiset(sorted) == multiset(s)
      invariant forall x, y :: 0 <= x < y < i ==> 
        popcount(sorted[x]) <= popcount(sorted[y])
    {
      var key := sorted[i];
      var j := i - 1;
      
      while j >= 0 && popcount(sorted[j]) > popcount(key)
        invariant -1 <= j < i
        invariant |sorted| == |s|
        invariant multiset(sorted) == multiset(s)
        invariant forall x, y :: 0 <= x < y < i + 1 && (y <= j || x > j + 1) ==> 
          popcount(sorted[x]) <= popcount(sorted[y])
        invariant forall k :: j + 2 <= k <= i ==> 
          popcount(key) <= popcount(sorted[k])
      {
        sorted := sorted[j+1 := sorted[j]];
        j := j - 1;
      }
      
      sorted := sorted[j+1 := key];
      
      i := i + 1;
    }
  }

vc-postamble: |-


