vc-preamble: |-


vc-helpers: |-
  lemma set_cardinality_lemma(s: seq<int>)
    ensures |set i | 0 <= i < |s| && digits_sum(s[i]) > 0| <= |s|
  {
    var target_set := set i | 0 <= i < |s| && digits_sum(s[i]) > 0;
    var all_indices := set i | 0 <= i < |s|;
    assert target_set <= all_indices;
    set_indices_cardinality(s);
    assert |all_indices| == |s|;
  }
  
  lemma set_indices_cardinality(s: seq<int>)
    ensures |set i | 0 <= i < |s|| == |s|
  {
    if |s| == 0 {
      assert set i | 0 <= i < |s| == {};
    } else {
      var prev_s := s[..|s|-1];
      set_indices_cardinality(prev_s);
      var prev_set := set i | 0 <= i < |prev_s|;
      var curr_set := set i | 0 <= i < |s|;
      assert curr_set == prev_set + {|s|-1};
      assert |s|-1 !in prev_set;
    }
  }
  
  lemma count_set_equivalence(s: seq<int>, i: nat)
    requires i <= |s|
    ensures |set j | 0 <= j < i && digits_sum(s[j]) > 0| <= i
  {
    var target_set := set j | 0 <= j < i && digits_sum(s[j]) > 0;
    var all_indices := set j | 0 <= j < i;
    assert target_set <= all_indices;
  }
  
  lemma count_increment_lemma(s: seq<int>, i: nat)
    requires i < |s|
    requires digits_sum(s[i]) > 0
    ensures |set j | 0 <= j < i+1 && digits_sum(s[j]) > 0| == |set j | 0 <= j < i && digits_sum(s[j]) > 0| + 1
  {
    var prev_set := set j | 0 <= j < i && digits_sum(s[j]) > 0;
    var curr_set := set j | 0 <= j < i+1 && digits_sum(s[j]) > 0;
    assert curr_set == prev_set + {i};
    assert i !in prev_set;
  }
  
  lemma count_no_increment_lemma(s: seq<int>, i: nat)
    requires i < |s|
    requires digits_sum(s[i]) <= 0
    ensures |set j | 0 <= j < i+1 && digits_sum(s[j]) > 0| == |set j | 0 <= j < i && digits_sum(s[j]) > 0|
  {
    var prev_set := set j | 0 <= j < i && digits_sum(s[j]) > 0;
    var curr_set := set j | 0 <= j < i+1 && digits_sum(s[j]) > 0;
    assert curr_set == prev_set;
  }

vc-description: |-
  function_signature: def count_nums(arr: List[int]) -> int
  Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.

vc-spec: |-
  method count_nums(s: seq<int>) returns (cnt: nat)
    // post-conditions-start
    ensures cnt == |set i | 0 <= i < |s| && digits_sum(s[i]) > 0|
    // post-conditions-end

vc-code: |-
  {
    cnt := 0;
    var i := 0;
    
    while i < |s|
      invariant 0 <= i <= |s|
      invariant cnt == |set j | 0 <= j < i && digits_sum(s[j]) > 0|
    {
      if digits_sum(s[i]) > 0 {
        count_increment_lemma(s, i);
        cnt := cnt + 1;
      } else {
        count_no_increment_lemma(s, i);
      }
      i := i + 1;
    }
    
    set_cardinality_lemma(s);
  }

vc-postamble: |-
  function digits_sum(x: int): int
    decreases abs(x)
  {
    if abs(x) < 10 then x else x % 10 + digits_sum(x / 10)
  }
  // pure-end
  function abs(x: int): int
    ensures abs(x) >= 0
    ensures abs(x) == x || abs(x) == -x
  {
    if x >= 0 then x else -x
  }
  // pure-end

