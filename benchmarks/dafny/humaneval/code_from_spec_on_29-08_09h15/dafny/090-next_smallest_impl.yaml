vc-preamble: |-
  datatype Option<T> = None | Some(T)
  function getVal(mx : Option<int>) : int
      requires mx != None
  {
      match mx {
          case Some(n) => n
      }
  }

vc-helpers: |-
  lemma DistinctElementsLemma(s: seq<int>, min1: int, min2: int)
      requires |s| >= 2
      requires min1 in s && min2 in s
      requires min1 < min2
      requires forall i :: 0 <= i < |s| ==> s[i] >= min1
      requires forall i :: 0 <= i < |s| && s[i] != min1 ==> s[i] >= min2
      ensures forall x, y :: 0 <= x < y < |s| ==> s[x] <= min2 || s[y] <= min2
  {
      forall x, y | 0 <= x < y < |s|
      ensures s[x] <= min2 || s[y] <= min2
      {
          assert s[x] >= min1 && s[y] >= min1;
          if s[x] > min2 {
              assert s[x] > min2 >= min1;
              assert s[x] != min1;
              assert s[x] >= min2;
          }
          if s[y] > min2 {
              assert s[y] > min2 >= min1;
              assert s[y] != min1;
              assert s[y] >= min2;
          }
          assert s[x] <= min2 || s[y] <= min2;
      }
  }
  
  lemma AllElementsSameLemma(s: seq<int>)
      requires |s| >= 2
      requires forall i, j :: 0 <= i < |s| && 0 <= j < |s| ==> s[i] == s[j]
      ensures forall x, y :: 0 <= x < y < |s| ==> s[x] <= s[0] || s[y] <= s[0]
  {
      var elem := s[0];
      forall x, y | 0 <= x < y < |s|
      ensures s[x] <= elem || s[y] <= elem
      {
          assert s[x] == elem && s[y] == elem;
      }
  }

vc-description: |-
  function_signature: def next_smallest(lst: List[int]) -> Optional[int]
  You are given a list of integers. Write a function next_smallest() that returns the 2nd smallest element of the list. Return None if there is no such element. TODO(George): Remove this when being reviewed The spec is defined as: if result is none there is no second smallest element, which exists in a finite list iff there are at least two distinct elements in the list. If result is some x, then x is the second smallest element of the list, the spec obtains the sublist of elements smaller than the result, and checks that this sublist does not contain two distinct elements (they are all the same).

vc-spec: |-
  method rolling_max(s: seq<int>) returns (res: Option<int>) 
      // post-conditions-start
      ensures res == None <==> |s| < 2
      ensures res != None ==> exists x :: 0 <= x < |s| && s[x] == getVal(res)
      ensures forall x, y :: 0 <= x < y < |s| ==> s[x] <= getVal(res) || s[y] <= getVal(res)
      // post-conditions-end

vc-code: |-
  {
      if |s| < 2 {
          return None;
      }
      
      var min1 := s[0];
      var min2 := s[0];
      var found_distinct := false;
      
      var i := 1;
      while i < |s|
          invariant 1 <= i <= |s|
          invariant min1 <= min2
          invariant min1 in s[0..i] && min2 in s[0..i]
          invariant forall k :: 0 <= k < i ==> s[k] >= min1
          invariant found_distinct <==> (min1 < min2)
          invariant found_distinct ==> forall k :: 0 <= k < i && s[k] != min1 ==> s[k] >= min2
          invariant !found_distinct ==> forall k :: 0 <= k < i ==> s[k] == min1
      {
          if s[i] < min1 {
              min2 := min1;
              min1 := s[i];
              found_distinct := true;
          } else if s[i] < min2 && s[i] != min1 {
              min2 := s[i];
              found_distinct := true;
          }
          i := i + 1;
      }
      
      if !found_distinct {
          assert forall k :: 0 <= k < |s| ==> s[k] == min1;
          assert forall j, k :: 0 <= j < |s| && 0 <= k < |s| ==> s[j] == s[k];
          assert |s| >= 2;
          AllElementsSameLemma(s);
          return None;
      }
      
      assert found_distinct;
      assert min1 < min2;
      assert min1 in s && min2 in s;
      assert forall k :: 0 <= k < |s| ==> s[k] >= min1;
      assert forall k :: 0 <= k < |s| && s[k] != min1 ==> s[k] >= min2;
      DistinctElementsLemma(s, min1, min2);
      return Some(min2);
  }

vc-postamble: |-


