vc-preamble: |-
  function sumc(s: seq<int>, p: seq<bool>) : int
      requires |s| == |p|
      {
          if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])
      }
  function add_conditon(lst: seq<int>) : (p : seq<bool>)
      ensures |lst| == |p|
      {
          seq(|lst|, i requires 0 <= i < |lst| => i % 2 == 1 && lst[i] % 2 == 0)
      }

vc-helpers: |-
  lemma sumc_empty(s: seq<int>, p: seq<bool>)
      requires |s| == |p| == 0
      ensures sumc(s, p) == 0
  {
  }
  
  lemma sumc_single(s: seq<int>, p: seq<bool>)
      requires |s| == |p| == 1
      ensures sumc(s, p) == (if p[0] then s[0] else 0)
  {
  }
  
  lemma sumc_decompose(s: seq<int>, p: seq<bool>)
      requires |s| == |p| > 0
      ensures sumc(s, p) == (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])
  {
  }
  
  lemma add_condition_properties(lst: seq<int>)
      ensures |add_conditon(lst)| == |lst|
      ensures forall i :: 0 <= i < |lst| ==> add_conditon(lst)[i] == (i % 2 == 1 && lst[i] % 2 == 0)
  {
  }
  
  lemma add_condition_slice_equiv(v: seq<int>, i: int)
      requires 0 <= i <= |v|
      ensures add_conditon(v)[..i] == add_conditon(v[..i])
  {
      if i == 0 {
          assert v[..0] == [];
          assert add_conditon(v)[..0] == [];
          assert add_conditon(v[..0]) == add_conditon([]);
      } else {
          var slice_v := v[..i];
          var cond_v := add_conditon(v);
          var cond_slice_v := add_conditon(slice_v);
          
          assert |slice_v| == i;
          assert |cond_v| == |v|;
          assert |cond_slice_v| == i;
          assert |cond_v[..i]| == i;
          
          forall j | 0 <= j < i
              ensures cond_v[..i][j] == cond_slice_v[j]
          {
              assert cond_v[..i][j] == cond_v[j];
              assert cond_v[j] == (j % 2 == 1 && v[j] % 2 == 0);
              assert slice_v[j] == v[j];
              assert cond_slice_v[j] == (j % 2 == 1 && slice_v[j] % 2 == 0);
              assert cond_slice_v[j] == (j % 2 == 1 && v[j] % 2 == 0);
          }
      }
  }
  
  lemma sumc_extension(v: seq<int>, i: int)
      requires 0 <= i < |v|
      ensures sumc(v[..i+1], add_conditon(v[..i+1])) == 
              sumc(v[..i], add_conditon(v[..i])) + (if (i % 2 == 1 && v[i] % 2 == 0) then v[i] else 0)
  {
      var v_i := v[..i];
      var v_i1 := v[..i+1];
      var p_i := add_conditon(v_i);
      var p_i1 := add_conditon(v_i1);
      
      assert v_i1 == v_i + [v[i]];
      assert |v_i1| == i + 1;
      assert |p_i1| == i + 1;
      
      if i == 0 {
          assert v_i == [];
          assert sumc(v_i, p_i) == 0;
          assert sumc(v_i1, p_i1) == (if p_i1[0] then v_i1[0] else 0);
          assert p_i1[0] == (0 % 2 == 1 && v[0] % 2 == 0);
          assert v_i1[0] == v[0];
      } else {
          sumc_decompose(v_i1, p_i1);
          assert sumc(v_i1, p_i1) == (if p_i1[0] then v_i1[0] else 0) + sumc(v_i1[1..], p_i1[1..]);
          
          assert |v_i1| == i + 1;
          assert v_i1[0] == v[0];
          assert v_i1[1..] == v[1..i+1];
          assert v[1..i+1] == (v[..i+1])[1..];
          assert (v[..i+1])[1..] == v[1..][..i];
          assert v[1..][..i] == v_i;
          
          assert |p_i1| == i + 1;
          assert p_i1[0] == (0 % 2 == 1 && v_i1[0] % 2 == 0);
          
          forall j | 0 <= j < i
              ensures p_i1[1..][j] == p_i[j]
          {
              assert p_i1[1..][j] == p_i1[j+1];
              assert p_i1[j+1] == ((j+1) % 2 == 1 && v_i1[j+1] % 2 == 0);
              assert v_i1[j+1] == v[j+1];
              assert p_i[j] == (j % 2 == 1 && v_i[j] % 2 == 0);
              assert v_i[j] == v[j];
              assert v[j] == v[j+1];
          }
          
          assert p_i1[1..] == p_i;
          assert sumc(v_i1, p_i1) == (if p_i1[0] then v_i1[0] else 0) + sumc(v_i, p_i);
          
          assert p_i1[i] == (i % 2 == 1 && v_i1[i] % 2 == 0);
          assert v_i1[i] == v[i];
          assert p_i1[i] == (i % 2 == 1 && v[i] % 2 == 0);
      }
  }

vc-description: |-
  function_signature: def solve(n: list[int]) -> int
  Given a non-empty list of integers lst, add the even elements that are at odd indices.

vc-spec: |-
  method add(v: seq<int>) returns (r : int)
      // post-conditions-start
      ensures r == sumc(v, add_conditon(v))
      // post-conditions-end

vc-code: |-
  {
      if |v| == 0 {
          r := 0;
          return;
      }
      
      r := 0;
      var i := 0;
      
      while i < |v|
          invariant 0 <= i <= |v|
          invariant r == sumc(v[..i], add_conditon(v[..i]))
      {        
          if i % 2 == 1 && v[i] % 2 == 0 {
              r := r + v[i];
          }
          i := i + 1;
          
          sumc_extension(v, i - 1);
          assert r == sumc(v[..i], add_conditon(v[..i]));
      }
      
      assert v[..|v|] == v;
      add_condition_slice_equiv(v, |v|);
      assert add_conditon(v[..|v|]) == add_conditon(v);
  }

vc-postamble: |-
  // pure-end

