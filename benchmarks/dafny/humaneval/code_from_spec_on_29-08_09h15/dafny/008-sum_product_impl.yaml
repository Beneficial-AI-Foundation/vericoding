vc-preamble: |-
  function sum(s: seq<int>) : int {
      if |s| == 0 then 0 else s[0] + sum(s[1..])
  }
  function prod(s: seq<int>) : int {
      if |s| == 0 then 1 else s[0] * prod(s[1..])
  }

vc-helpers: |-
  lemma sum_append_one(s: seq<int>, x: int)
      ensures sum(s + [x]) == sum(s) + x
  {
      if |s| == 0 {
          assert s + [x] == [x];
          assert sum([x]) == x + sum([]);
          assert sum([]) == 0;
      } else {
          assert s + [x] == [s[0]] + (s[1..] + [x]);
          sum_append_one(s[1..], x);
          assert sum(s[1..] + [x]) == sum(s[1..]) + x;
          assert sum(s + [x]) == s[0] + sum(s[1..] + [x]);
          assert sum(s + [x]) == s[0] + sum(s[1..]) + x;
          assert sum(s + [x]) == sum(s) + x;
      }
  }
  
  lemma prod_append_one(s: seq<int>, x: int)
      ensures prod(s + [x]) == prod(s) * x
  {
      if |s| == 0 {
          assert s + [x] == [x];
          assert prod([x]) == x * prod([]);
          assert prod([]) == 1;
      } else {
          assert s + [x] == [s[0]] + (s[1..] + [x]);
          prod_append_one(s[1..], x);
          assert prod(s[1..] + [x]) == prod(s[1..]) * x;
          assert prod(s + [x]) == s[0] * prod(s[1..] + [x]);
          assert prod(s + [x]) == s[0] * prod(s[1..]) * x;
          assert prod(s + [x]) == prod(s) * x;
      }
  }

vc-description: |-
  function_signature: def sum_product(numbers: List[int]) -> Tuple[int, int]
  For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should be equal to 1.

vc-spec: |-
  method sum_product(numbers: seq<int>) returns (s : int, p : int)
      // post-condition-start
      ensures s == sum(numbers)
      ensures p == prod(numbers)
      // post-condition-end

vc-code: |-
  {
    s := 0;
    p := 1;
    
    for i := 0 to |numbers|
      invariant s == sum(numbers[..i])
      invariant p == prod(numbers[..i])
    {
      assert numbers[..i+1] == numbers[..i] + [numbers[i]];
      sum_append_one(numbers[..i], numbers[i]);
      prod_append_one(numbers[..i], numbers[i]);
      s := s + numbers[i];
      p := p * numbers[i];
    }
    assert numbers[..|numbers|] == numbers;
  }

vc-postamble: |-


