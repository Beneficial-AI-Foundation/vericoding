vc-preamble: |-
  method is_prime(k: int) returns (result: bool)
    // pre-conditions-start
    requires k >= 2
    // pre-conditions-end
    // post-conditions-start
    ensures result ==> forall i :: 2 <= i < k ==> k % i != 0
    ensures !result ==> exists j :: 2 <= j < k && k % j == 0
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function is_prime_pred(k: int) : bool
  {
    forall i :: 2 <= i < k ==> k % i != 0
  }

vc-helpers: |-
  lemma PrimeFactorExists(n: int)
    requires n >= 2
    ensures exists p :: 1 <= p <= n && p > 1 && is_prime_pred(p) && n % p == 0
  {
    var p := 2;
    var found := false;
    var i := 2;
    while i <= n
      invariant 2 <= i <= n + 1
      invariant !found ==> forall j :: 2 <= j < i ==> n % j != 0
      invariant found ==> 2 <= p <= i - 1 && n % p == 0
    {
      if n % i == 0 {
        p := i;
        found := true;
        if i == n {
          break;
        }
      }
      i := i + 1;
    }
    if found {
      assert 1 <= p <= n && n % p == 0;
    } else {
      assert n > 1;
      assert is_prime_pred(n);
      assert exists p :: p == n && 1 <= p <= n && p > 1 && is_prime_pred(p) && n % p == 0;
    }
  }
  
  method find_smallest_prime_factor(n: int) returns (p: int)
    requires n >= 2
    ensures 1 <= p <= n
    ensures n % p == 0
    ensures p > 1 ==> is_prime_pred(p)
    ensures forall j :: 2 <= j < p ==> n % j != 0
  {
    p := 2;
    while p < n
      invariant 2 <= p <= n
      invariant forall j :: 2 <= j < p ==> n % j != 0
    {
      if n % p == 0 {
        return;
      }
      p := p + 1;
    }
    return p;
  }

vc-description: |-
  function_signature: method largest_prime_factor(n: int) returns (largest: int)
  Process input. Requires: the result is at least the specified value. Ensures: returns the correct size/count.

vc-spec: |-
  method largest_prime_factor(n: int) returns (largest: int)
    // pre-conditions-start
    requires n >= 2
    // pre-conditions-end
    // post-conditions-start
    ensures 1 <= largest <= n && (largest == 1 || (largest > 1 && is_prime_pred(largest)))
    // post-conditions-end

vc-code: |-
  method LargestPrimeFactor(n: int) returns (largest: int)
    requires n >= 2
    ensures 1 <= largest <= n && (largest == 1 || (largest > 1 && is_prime_pred(largest)))
    ensures largest > 1 ==> n % largest == 0
  {
    var current := n;
    largest := 1;
    while current > 1
      invariant 1 <= current <= n
      invariant 1 <= largest <= current || largest <= n
      invariant largest > 1 ==> is_prime_pred(largest)
      invariant largest > 1 ==> n % largest == 0
    {
      var p := find_smallest_prime_factor(current);
      if p > 1 {
        if p > largest {
          largest := p;
        }
        current := current / p;
      } else {
        current := 1;
      }
    }
  }

vc-postamble: |-


