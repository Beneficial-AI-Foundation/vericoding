vc-preamble: |-


vc-helpers: |-
  function max_seq_empty(lst: seq<int>): int
    requires |lst| == 0
    ensures max_seq_empty(lst) == 0
  {
    0
  }
  
  lemma MaxSeqProperties(lst: seq<int>)
    requires |lst| > 0
    ensures exists i :: 0 <= i < |lst| && lst[i] == max_seq(lst)
  {
    if |lst| == 1 {
      assert lst[0] == max_seq(lst);
    } else {
      MaxSeqProperties(lst[1..]);
      var suf := max_seq(lst[1..]);
      if lst[0] > suf {
        assert max_seq(lst) == lst[0];
      } else {
        assert max_seq(lst) == suf;
        var i :| 0 <= i < |lst[1..]| && lst[1..][i] == suf;
        assert lst[1 + i] == suf;
      }
    }
  }
  
  lemma FilterPrimesNotEmpty(lst: seq<nat>)
    requires exists i :: 0 <= i < |lst| && is_prime(lst[i])
    ensures |filter_primes(lst)| > 0
  {
    var i :| 0 <= i < |lst| && is_prime(lst[i]);
    if i == 0 {
      assert is_prime(lst[0]);
      assert |filter_primes(lst)| > 0;
    } else {
      FilterPrimesNotEmpty(lst[1..]);
    }
  }

vc-description: |-
  function_signature: def sum_largest_prime(lst : list[int]) -> int
  You are given a list of integers. You need to find the largest prime value and return the sum of its digits. Note(George): Modified to use List of nats because all examples are nats.

vc-spec: |-
  method skjkasdkd(lst: seq<nat>) returns (dsum: nat)
    // pre-conditions-start
    requires exists i :: 0 <= i < |lst| && is_prime(lst[i])
    // pre-conditions-end
    // post-conditions-start
    ensures dsum == digits_sum(max_seq(filter_primes(lst)))
    // post-conditions-end

vc-code: |-
  {
    var filtered := filter_primes(lst);
    assert |filtered| > 0 by {
      FilterPrimesNotEmpty(lst);
    }
    var max_val := max_seq(filtered);
    dsum := digits_sum(max_val);
  }

vc-postamble: |-
  function digits_sum(x: nat): nat {
    if x == 0 then 0 else x % 10 + digits_sum(x / 10)
  }
  // pure-end
  function max_seq(lst: seq<int>): (max: int)
    // pre-conditions-start
    requires |lst| > 0
    // pre-conditions-end
    // post-conditions-start
    ensures forall i :: 0 <= i < |lst| ==> lst[i] <= max
    // post-conditions-end
  {
    // impl-start
    if |lst| == 1
      then lst[0]
      else
        var suf := max_seq(lst[1..]);
        max(lst[0], suf)
    // impl-end
  }
  function filter_primes(lst: seq<int>): (primes: seq<int>)
    // post-conditions-start
    ensures forall i :: 0 <= i < |primes| ==> is_prime(primes[i])
    ensures forall i :: 0 <= i < |lst| && is_prime(lst[i]) ==> lst[i] in primes
    // post-conditions-end
  {
    // impl-start
    if |lst| == 0
      then []
      else
        var tail := filter_primes(lst[1..]);
        (if is_prime(lst[0]) then [lst[0]] else []) + tail
    // impl-end
  }
  // pure-end
  function max(a: int, b: int): int
    ensures max(a, b) == a || max(a, b) == b
    ensures max(a, b) >= a && max(a, b) >= b
  {
    if a > b then a else b
  }
  // pure-end
  function is_prime(k: int) : bool {
    k != 1 && forall i :: 2 <= i < k ==> k % i != 0
  }
  // pure-end

