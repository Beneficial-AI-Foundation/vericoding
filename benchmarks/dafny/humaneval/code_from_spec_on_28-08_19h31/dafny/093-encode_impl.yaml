vc-preamble: |-


vc-helpers: |-
  function rot2_mod(c: char): char
    requires is_vowel(c)
    ensures is_vowel(rot2_mod(c))
  {
    var vowels_lower := ['a', 'e', 'i', 'o', 'u'];
    var vowels_upper := ['A', 'E', 'I', 'O', 'U'];
    if 'a' <= c <= 'z' then
      var idx := 0;
      var found := false;
      var k := 0;
      while k < 5
        invariant 0 <= k <= 5
        invariant !found ==> idx == 0
        invariant found ==> 0 <= idx < 5 && vowels_lower[idx] == c
      {
        if vowels_lower[k] == c {
          idx := k;
          found := true;
        }
        k := k + 1;
      }
      var new_idx := (idx + 2) % 5;
      vowels_lower[new_idx]
    else
      var idx := 0;
      var found := false;
      var k := 0;
      while k < 5
        invariant 0 <= k <= 5
        invariant !found ==> idx == 0
        invariant found ==> 0 <= idx < 5 && vowels_upper[idx] == c
      {
        if vowels_upper[k] == c {
          idx := k;
          found := true;
        }
        k := k + 1;
      }
      var new_idx := (idx + 2) % 5;
      vowels_upper[new_idx]
  }
  
  lemma Rot2PreservesVowel(c: char)
    requires is_vowel(c)
    ensures is_vowel(rot2_mod(c))
  {
  }

vc-description: |-
  function_signature: def encode(s : str) -> str
  Write a function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that vowel in the english alphabet. Assume only letters.

vc-spec: |-
  method encode(s: string) returns (t: string)
    // pre-conditions-start
    requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z' || 'A' <= s[i] <= 'Z'
    // pre-conditions-end
    // post-conditions-start
    ensures |s| == |t|
    ensures forall i :: 0 <= i < |s| && is_vowel(s[i]) ==> t[i] == rot2(swap_case(s[i]))
    ensures forall i :: 0 <= i < |s| && !is_vowel(s[i]) ==> t[i] == swap_case(s[i])
    // post-conditions-end

vc-code: |-
  method encode(s: string) returns (t: string)
    requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z' || 'A' <= s[i] <= 'Z'
    ensures |s| == |t|
    ensures forall i :: 0 <= i < |s| && is_vowel(s[i]) ==> t[i] == rot2_mod(swap_case(s[i]))
    ensures forall i :: 0 <= i < |s| && !is_vowel(s[i]) ==> t[i] == swap_case(s[i])
  {
    var res := new char[|s|];
    var i := 0;
    while i < |s|
      invariant 0 <= i <= |s|
      invariant forall k :: 0 <= k < i && is_vowel(s[k]) ==> res[k] == rot2_mod(swap_case(s[k]))
      invariant forall k :: 0 <= k < i && !is_vowel(s[k]) ==> res[k] == swap_case(s[k])
    {
      var swapped := swap_case(s[i]);
      if is_vowel(s[i]) {
        res[i] := rot2_mod(swapped);
      } else {
        res[i] := swapped;
      }
      i := i + 1;
    }
    t := res[..];
  }

vc-postamble: |-
  function swap_case(c: char): char
    // pre-conditions-start
    requires 'a' <= c <= 'z' || 'A' <= c <= 'Z'
    // pre-conditions-end
    // post-conditions-start
    ensures 'a' <= c <= 'z' ==> 'A' <= swap_case(c) <= 'Z'
    ensures 'A' <= c <= 'Z' ==> 'a' <= swap_case(c) <= 'z'
    ensures is_vowel(swap_case(c)) == is_vowel(c)
    // post-conditions-end
  {
    // impl-start
    if 'a' <= c <= 'z' then
      'A' + (c - 'a')
    else
      'a' + (c - 'A')
    // impl-end
  }
  // pure-end
  function rot2(c: char): char
    requires is_vowel(c)
  {
      (c as int + 2) as char
  }
  // pure-end
  function is_vowel(c: char) : bool {
      (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')
      || (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')
  }
  // pure-end

