vc-preamble: |-
  function sumc(s: seq<int>, p: seq<bool>) : int
      requires |s| == |p|
      {
          if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])
      }
  function add_conditon(lst: seq<int>) : (p : seq<bool>)
      ensures |lst| == |p|
      {
          seq(|lst|, i requires 0 <= i < |lst| => i % 2 == 1 && lst[i] % 2 == 0)
      }

vc-helpers: |-
  function sumc_helper(s: seq<int>, p: seq<bool>, i: int) : int
      requires |s| == |p|
      requires 0 <= i <= |s|
      decreases |s| - i
  {
      if i == |s| then 0 else (if p[i] then s[i] else 0) + sumc_helper(s, p, i + 1)
  }
  
  lemma SumcEquivalence(s: seq<int>, p: seq<bool>)
      requires |s| == |p|
      ensures sumc(s, p) == sumc_helper(s, p, 0)
  {
      if |s| == 0 {
          assert sumc(s, p) == 0;
          assert sumc_helper(s, p, 0) == 0;
      } else {
          calc {
              sumc(s, p);
              == (if p[0] then s[0] else 0) + sumc(s[1..], p[1..]);
              { SumcEquivalence(s[1..], p[1..]); }
              == (if p[0] then s[0] else 0) + sumc_helper(s[1..], p[1..], 0);
              == sumc_helper(s, p, 0);
          }
      }
  }

vc-description: |-
  function_signature: def solve(n: list[int]) -> int
  Given a non-empty list of integers lst, add the even elements that are at odd indices.

vc-spec: |-
  method add(v: seq<int>) returns (r : int)
      // post-conditions-start
      ensures r == sumc(v, add_conditon(v))
      // post-conditions-end

vc-code: |-
  method add(v: seq<int>) returns (r : int)
      // post-conditions-start
      ensures r == sumc(v, add_conditon(v))
      // post-conditions-end
  {
      var p := add_conditon(v);
      var result := 0;
      var i := 0;
      while i < |v|
          invariant 0 <= i <= |v|
          invariant result == sumc_helper(v[0..i], p[0..i], 0)
      {
          if p[i] {
              result := result + v[i];
          }
          i := i + 1;
      }
      SumcEquivalence(v, p);
      r := result;
  }

vc-postamble: |-
  // pure-end

