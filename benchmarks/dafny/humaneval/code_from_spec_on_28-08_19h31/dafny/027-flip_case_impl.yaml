vc-preamble: |-
  function lower(c: char) : bool
      {
          'a' <= c <= 'z'
      }
  function upper(c: char) : bool
      {
          'A' <= c <= 'Z'
      }
  function alpha(c: char) : bool
      {
          lower(c) || upper(c)
      }
  function flip_char(c: char) : (C: char)
          ensures lower(c) <==> upper(C)
          ensures upper(c) <==> lower(C)
      {
          if lower(c) then c - 'a' + 'A' else
          if upper(c) then c + 'a' - 'A' else c
      }

vc-helpers: |-
  lemma FlipCharPreservesAlpha(c: char)
    ensures alpha(c) ==> alpha(flip_char(c))
  {
    if alpha(c) {
      if lower(c) {
        assert flip_char(c) == c - 'a' + 'A';
        assert 'A' <= flip_char(c) <= 'Z';
      } else if upper(c) {
        assert flip_char(c) == c + 'a' - 'A';
        assert 'a' <= flip_char(c) <= 'z';
      }
    }
  }

vc-description: |-
  function_signature: def flip_case(string: str) -> str
  For a given string, flip lowercase characters to uppercase and uppercase to lowercase.

vc-spec: |-
  method flip_case(s: string) returns (S: string)
      // post-conditions-start
      ensures |S| == |s|
      ensures forall i :: 0 <= i < |s| ==> (lower(s[i]) <==> upper(S[i]))
      ensures forall i :: 0 <= i < |s| ==> (upper(s[i]) <==> lower(S[i]))
      // post-conditions-end

vc-code: |-
  {
    var res: array<char> := new char[|s|];
    var i: int := 0;
    while i < |s|
      invariant 0 <= i <= |s|
      invariant forall k :: 0 <= k < i ==> lower(s[k]) ==> upper(res[k])
      invariant forall k :: 0 <= k < i ==> upper(s[k]) ==> lower(res[k])
      invariant forall k :: 0 <= k < i ==> !alpha(s[k]) ==> res[k] == s[k]
    {
      res[i] := flip_char(s[i]);
      i := i + 1;
    }
    var result: string := res[..];
    return result;
  }

vc-postamble: |-


