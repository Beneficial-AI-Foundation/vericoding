vc-preamble: |-


vc-helpers: |-
  function count_nums_helper(s: seq<int>, i: int): nat
    decreases |s| - i
    requires 0 <= i <= |s|
    ensures count_nums_helper(s, i) == |set k | i <= k < |s| && digits_sum(s[k]) > 0|
  {
    if i == |s| then 0
    else if digits_sum(s[i]) > 0 then 1 + count_nums_helper(s, i + 1)
    else count_nums_helper(s, i + 1)
  }
  
  lemma count_nums_helper_lemma(s: seq<int>)
    ensures count_nums_helper(s, 0) == |set i | 0 <= i < |s| && digits_sum(s[i]) > 0|
  {
    // No additional proof needed as the postcondition holds from the function definition
  }

vc-description: |-
  function_signature: def count_nums(arr: List[int]) -> int
  Write a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: e.g. -123 has signed digits -1, 2, and 3.

vc-spec: |-
  method count_nums(s: seq<int>) returns (cnt: nat)
    // post-conditions-start
    ensures cnt == |set i | 0 <= i < |s| && digits_sum(s[i]) > 0|
    // post-conditions-end

vc-code: |-
  method CountNums(s: seq<int>) returns (cnt: nat)
    ensures cnt == |set i | 0 <= i < |s| && digits_sum(s[i]) > 0|
  {
    var i := 0;
    var count := 0;
    while i < |s|
      invariant 0 <= i <= |s|
      invariant count == |set k | 0 <= k < i && digits_sum(s[k]) > 0|
    {
      if digits_sum(s[i]) > 0 {
        count := count + 1;
      }
      i := i + 1;
    }
    cnt := count;
  }

vc-postamble: |-
  function digits_sum(x: int): int
    decreases abs(x)
  {
    if abs(x) < 10 then x else x % 10 + digits_sum(x / 10)
  }
  // pure-end
  function abs(x: int): int
    ensures abs(x) >= 0
    ensures abs(x) == x || abs(x) == -x
  {
    if x >= 0 then x else -x
  }
  // pure-end

