vc-preamble: |-
  function iterate_to_odd(n: nat): nat
    requires n % 2 == 0
    requires n > 0
    ensures iterate_to_odd(n) % 2 == 1
  {
    if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)
  }
  function next_odd_collatz(n: nat): nat
    requires n > 0
  {
    if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)
  }
  method next_odd_collatz_iter(n: nat) returns (next: nat)
    // pre-conditions-start
    requires n > 0
    // pre-conditions-end
    // post-conditions-start
    ensures next % 2 == 1
    ensures next == next_odd_collatz(n)
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)
    decreases *
    requires n > 1
    ensures forall i :: 0 <= i < |odd_collatz| ==> odd_collatz[i] % 2 == 1
    ensures forall i :: 1 <= i < |odd_collatz| ==> odd_collatz[i] == next_odd_collatz(odd_collatz[i - 1])
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma IterateToOddPreservesPositivity(n: nat)
    requires n > 0
    requires n % 2 == 0
    ensures iterate_to_odd(n) > 0
  {
    if (n / 2) % 2 == 1 {
      assert n / 2 > 0;
    } else {
      IterateToOddPreservesPositivity(n / 2);
    }
  }
  
  lemma NextOddCollatzPreservesPositivity(n: nat)
    requires n > 0
    ensures next_odd_collatz(n) > 0
  {
    if n % 2 == 0 {
      IterateToOddPreservesPositivity(n);
    } else {
      assert 3 * n + 1 > 0;
      assert (3 * n + 1) % 2 == 0;
      IterateToOddPreservesPositivity(3 * n + 1);
    }
  }
  
  lemma MinInRemaining(remaining: seq<nat>, min_idx: nat, i: nat)
    requires 0 <= min_idx < |remaining|
    requires 0 <= i <= |remaining|
    ensures forall k :: 0 <= k < i ==> remaining[min_idx] <= remaining[k]
  {
  }

vc-description: |-
  function_signature: method get_odd_collatz(n: nat) returns (sorted: seq<int>)
  Retrieve elements. Requires: requires n > 1. Ensures: the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.

vc-spec: |-
  method get_odd_collatz(n: nat) returns (sorted: seq<int>)
    decreases *
    requires n > 1
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1

vc-code: |-
  {
    var odd_collatz := get_odd_collatz_unsorted(n);
    sorted := [];
    var remaining := odd_collatz;
    while |remaining| > 0
      decreases |remaining|
      invariant forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
      invariant forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1
      invariant multiset(remaining) + multiset(sorted) == multiset(odd_collatz)
    {
      var min_idx := 0;
      var i := 1;
      while i < |remaining|
        decreases |remaining| - i
        invariant 0 <= min_idx < |remaining|
        invariant forall k :: 0 <= k < i ==> remaining[min_idx] <= remaining[k]
      {
        if remaining[i] < remaining[min_idx] {
          min_idx := i;
        }
        i := i + 1;
      }
      var min_val := remaining[min_idx];
      sorted := sorted + [min_val];
      remaining := if min_idx < |remaining| - 1 then remaining[..min_idx] + remaining[min_idx+1..] else remaining[..min_idx];
      assert multiset(remaining) + multiset(sorted) == multiset(odd_collatz) by {
        assert multiset(remaining + [min_val]) == multiset(remaining) + multiset([min_val]);
      }
      assert forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j] by {
        if |sorted| > 1 {
          var last_idx := |sorted| - 1;
          assert sorted[last_idx] == min_val;
          assert forall k :: 0 <= k < |remaining| ==> min_val <= remaining[k];
          assert forall k :: 0 <= k < last_idx ==> sorted[k] <= min_val;
        }
      }
      assert forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1 by {
        assert sorted[|sorted|-1] == min_val;
        assert min_val in multiset(odd_collatz);
        assert forall k :: 0 <= k < |odd_collatz| ==> odd_collatz[k] % 2 == 1;
      }
    }
  }

vc-postamble: |-


