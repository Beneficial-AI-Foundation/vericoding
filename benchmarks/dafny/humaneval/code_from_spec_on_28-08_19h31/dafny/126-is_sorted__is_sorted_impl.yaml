vc-preamble: |-


vc-helpers: |-
  function countSet(a: seq<int>, x: int): int {
    |set i | 0 <= i < |a| && a[i] == x|
  }
  
  method computeCountSorted(a: seq<int>, x: int, pos: int) returns (count: int)
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= pos < |a|
    requires a[pos] == x
    requires pos == 0 || a[pos - 1] < x
    ensures count == countSet(a, x)
  {
    var i := pos;
    count := 0;
    while i < |a| && a[i] == x
      invariant pos <= i <= |a|
      invariant count == i - pos
      invariant forall j :: pos <= j < i ==> a[j] == x
      invariant i < |a| ==> a[i] >= x
      invariant pos > 0 ==> a[pos - 1] < x
    {
      count := count + 1;
      i := i + 1;
    }
    assert forall j :: pos <= j < i ==> a[j] == x;
    assert i == |a| || a[i] > x;
    assert count == |set j: int | pos <= j < i && a[j] == x|;
  }

vc-description: |-
  function_signature: method is_sorted(a: seq<int>) returns (f: bool)
  Sort elements. Ensures: the condition holds for all values.

vc-spec: |-
  method is_sorted(a: seq<int>) returns (f: bool)
    // post-conditions-start
    ensures f == forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> count_set(a, a[i]) <= 2
    // post-conditions-end

vc-code: |-
  method isSorted(a: seq<int>) returns (f: bool)
    ensures f == (forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j] && forall i :: 0 <= i < |a| ==> countSet(a, a[i]) <= 2)
  {
    if |a| == 0 {
      return true;
    }
  
    var isSortedFlag := true;
    var i := 0;
    while i < |a| - 1
      invariant 0 <= i <= |a| - 1
      invariant isSortedFlag ==> forall k :: 0 <= k <= i ==> (k + 1 < |a| ==> a[k] <= a[k+1])
    {
      if a[i] > a[i + 1] {
        isSortedFlag := false;
        break;
      }
      i := i + 1;
    }
    if !isSortedFlag {
      return false;
    }
  
    var countsValid := true;
    i := 0;
    while i < |a|
      invariant 0 <= i <= |a|
      invariant countsValid ==> forall k :: 0 <= k < i ==> countSet(a, a[k]) <= 2
    {
      if i > 0 && a[i] == a[i - 1] {
        i := i + 1;
        continue;
      }
      var count := 0;
      if isSortedFlag && (i == 0 || a[i - 1] < a[i]) {
        count := computeCountSorted(a, a[i], i);
        if count > 2 {
          countsValid := false;
          break;
        }
      }
      i := i + 1;
    }
  
    return isSortedFlag && countsValid;
  }

vc-postamble: |-
  method count_sorted(a: seq<int>, x: int, pos: int) returns (count: int)
    // pre-conditions-start
    requires forall i, j :: 0 <= i <= j < |a| ==> a[i] <= a[j]
    requires 0 <= pos < |a|
    requires a[pos] == x
    requires pos == 0 || a[pos - 1] < x
    // pre-conditions-end
    // post-conditions-start
    ensures count == count_set(a, x)
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function count_set(a: seq<int>, x: int): int {
    |set i | 0 <= i < |a| && a[i] == x|
  }
  // pure-end

