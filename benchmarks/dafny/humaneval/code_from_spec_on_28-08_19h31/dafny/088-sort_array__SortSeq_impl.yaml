vc-preamble: |-
  method sort_array(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures |sorted| == |s|
    ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 == 0 ==>
      forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]
    ensures |s| > 0 && (s[0] + s[|s| - 1]) % 2 != 0 ==>
      forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  method reverse(s: seq<int>) returns (rev: seq<int>)
    // post-conditions-start
    ensures |rev| == |s|
    ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma MultisetPreservation(s: seq<int>, sorted: seq<int>)
    ensures multiset(s) == multiset(sorted) ==> |s| == |sorted|
  {
  }
  
  function Partition(s: seq<int>, pivot: int): (seq<int>, seq<int>)
    ensures var (left, right) := Partition(s, pivot);
            multiset(left) + multiset(right) == multiset(s)
    ensures var (left, right) := Partition(s, pivot);
            forall x :: x in left ==> x <= pivot
    ensures var (left, right) := Partition(s, pivot);
            forall x :: x in right ==> x > pivot
  {
    if |s| == 0 then ([], [])
    else
      var head := s[0];
      var tail := s[1..];
      var (leftTail, rightTail) := Partition(tail, pivot);
      if head <= pivot then
        ([head] + leftTail, rightTail)
      else
        (leftTail, [head] + rightTail)
  }
  
  lemma PartitionLength(s: seq<int>, pivot: int)
    ensures var (left, right) := Partition(s, pivot);
            |left| + |right| == |s|
  {
    if |s| == 0 {
    } else {
      var head := s[0];
      var tail := s[1..];
      var (leftTail, rightTail) := Partition(tail, pivot);
      PartitionLength(tail, pivot);
    }
  }
  
  lemma PartitionMultiset(s: seq<int>, pivot: int)
    ensures var (left, right) := Partition(s, pivot);
            multiset(left) + multiset(right) == multiset(s)
  {
    if |s| == 0 {
    } else {
      var head := s[0];
      var tail := s[1..];
      var (leftTail, rightTail) := Partition(tail, pivot);
      PartitionMultiset(tail, pivot);
      if head <= pivot {
        assert multiset([head] + leftTail) == multiset([head]) + multiset(leftTail);
      } else {
        assert multiset([head] + rightTail) == multiset([head]) + multiset(rightTail);
      }
    }
  }
  
  lemma SortedConcat(left: seq<int>, right: seq<int>)
    requires forall i, j :: 0 <= i < j < |left| ==> left[i] <= left[j]
    requires forall i, j :: 0 <= i < j < |right| ==> right[i] <= right[j]
    requires |left| > 0 && |right| > 0 ==> left[|left| - 1] <= right[0]
    ensures forall i, j :: 0 <= i < j < |left + right| ==> (left + right)[i] <= (left + right)[j]
  {
    if |left| == 0 || |right| == 0 {
    } else {
      var combined := left + right;
      forall i, j | 0 <= i < j < |combined|
        ensures combined[i] <= combined[j]
      {
        if i < |left| && j < |left| {
          assert combined[i] == left[i];
          assert combined[j] == left[j];
        } else if i < |left| && j >= |left| {
          assert combined[i] == left[i];
          assert combined[j] == right[j - |left|];
          assert left[i] <= left[|left| - 1];
          assert left[|left| - 1] <= right[0];
          assert right[0] <= right[j - |left|];
        } else {
          assert combined[i] == right[i - |left|];
          assert combined[j] == right[j - |left|];
        }
      }
    }
  }
  
  lemma PartitionProperties(s: seq<int>, pivot: int)
    ensures var (left, right) := Partition(s, pivot);
            |left| < |s| || |right| < |s|
  {
    if |s| == 0 {
    } else {
      var head := s[0];
      var tail := s[1..];
      var (leftTail, rightTail) := Partition(tail, pivot);
      PartitionProperties(tail, pivot);
      if head <= pivot {
        assert |[head] + leftTail| == 1 + |leftTail|;
        assert |rightTail| < |tail| || |leftTail| < |tail|;
      } else {
        assert |[head] + rightTail| == 1 + |rightTail|;
        assert |leftTail| < |tail| || |rightTail| < |tail|;
      }
    }
  }
  
  lemma PartitionPivotRelation(s: seq<int>, pivot: int)
    ensures var (left, right) := Partition(s, pivot);
            |left| > 0 ==> left[|left| - 1] <= pivot
    ensures var (left, right) := Partition(s, pivot);
            |right| > 0 ==> right[0] > pivot
  {
    if |s| == 0 {
    } else {
      var head := s[0];
      var tail := s[1..];
      var (leftTail, rightTail) := Partition(tail, pivot);
      PartitionPivotRelation(tail, pivot);
      if head <= pivot {
        if |leftTail| == 0 {
          assert ([head] + leftTail)[|[head] + leftTail| - 1] == head <= pivot;
        } else {
          assert ([head] + leftTail)[|[head] + leftTail| - 1] == leftTail[|leftTail| - 1] <= pivot;
        }
      } else {
        if |rightTail| == 0 {
          assert ([head] + rightTail)[0] == head > pivot;
        } else {
          assert ([head] + rightTail)[0] == head > pivot;
        }
      }
    }
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end

vc-code: |-
  method QuickSort(s: seq<int>) returns (sorted: seq<int>)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    decreases |s|
  {
    if |s| <= 1 {
      return s;
    }
    
    var pivotIndex := |s| / 2;
    var pivot := s[pivotIndex];
    var (left, right) := Partition(s, pivot);
    
    PartitionLength(s, pivot);
    PartitionMultiset(s, pivot);
    PartitionProperties(s, pivot);
    PartitionPivotRelation(s, pivot);
    
    var sortedLeft := QuickSort(left);
    var sortedRight := QuickSort(right);
    
    if |sortedLeft| > 0 && |sortedRight| > 0 {
      assert forall i, j :: 0 <= i < j < |sortedLeft| ==> sortedLeft[i] <= sortedLeft[j];
      assert forall i, j :: 0 <= i < j < |sortedRight| ==> sortedRight[i] <= sortedRight[j];
      assert sortedLeft[|sortedLeft| - 1] <= pivot;
      assert pivot < sortedRight[0];
      assert sortedLeft[|sortedLeft| - 1] <= sortedRight[0];
    }
    
    SortedConcat(sortedLeft, sortedRight);
    sorted := sortedLeft + sortedRight;
  }

vc-postamble: |-


