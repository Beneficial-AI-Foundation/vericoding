vc-preamble: |-
  function fibfib(n: nat): nat
    decreases n
  {
    if n == 0 || n == 1 then 0
    else if n == 2 then 1
    else fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)
  }

vc-helpers: |-
  lemma FibFibInduction(n: nat)
    ensures fibfib(n) >= 0
    decreases n
  {
    if n == 0 || n == 1 {
      assert fibfib(n) == 0;
    } else if n == 2 {
      assert fibfib(n) == 1;
    } else {
      calc {
        fibfib(n);
        fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3);
        >= { FibFibInduction(n - 1); FibFibInduction(n - 2); FibFibInduction(n - 3); }
        0 + 0 + 0;
        0;
      }
    }
  }

vc-description: |-
  function_signature: def fibfib(n: int)
  The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows: fibfib(0) == 0 fibfib(1) == 0 fibfib(2) == 1 fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3). Please write a function to efficiently compute the n-th element of the fibfib number sequence. Note(Meghana): While the specification asks for an efficient computation of fibfib, we cannot enforce this constraint currently.

vc-spec: |-
  method ComputeFibFib(n: nat) returns (result: nat)
    // post-conditions-start
    ensures result == fibfib(n)
    // post-conditions-end

vc-code: |-
  {
    if n == 0 || n == 1 {
      return 0;
    } else if n == 2 {
      return 1;
    } else {
      var a := 0;
      var b := 0;
      var c := 1;
      var i := 3;
      while i <= n
        invariant 3 <= i <= n + 1
        invariant a == fibfib(i - 3)
        invariant b == fibfib(i - 2)
        invariant c == fibfib(i - 1)
      {
        var next := a + b + c;
        a := b;
        b := c;
        c := next;
        i := i + 1;
      }
      return c;
    }
  }

vc-postamble: |-


