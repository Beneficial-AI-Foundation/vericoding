vc-preamble: |-
  function ParenthesesDepth(s: string, i: int, j: int): int
      decreases j - i 
      requires 0 <= i <= j <= |s|
  {
      if i == j then
          0
      else if s[i] == '(' then
          ParenthesesDepth(s, i+1, j) + 1
      else if s[i] == ')' then
          ParenthesesDepth(s, i+1, j) - 1
      else
          ParenthesesDepth(s, i+1, j)
  }
  function InnerDepthsPositive(s: string) : bool
  {
      forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) > 0
  }
  function InnerDepthsNonnegative(s: string) : bool
  {
      forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) >= 0
  }

vc-helpers: |-
  lemma DepthSplitLemma(s: string, i: int, mid: int, j: int)
    requires 0 <= i <= mid <= j <= |s|
    ensures ParenthesesDepth(s, i, j) == ParenthesesDepth(s, i, mid) + ParenthesesDepth(s, mid, j)
    decreases j - i
  {
    if i == j {
    } else {
      if i < mid {
        calc {
          ParenthesesDepth(s, i, j);
          == 
          if s[i] == '(' then ParenthesesDepth(s, i+1, j) + 1
          else if s[i] == ')' then ParenthesesDepth(s, i+1, j) - 1
          else ParenthesesDepth(s, i+1, j);
          == { DepthSplitLemma(s, i+1, mid, j); }
          if s[i] == '(' then (ParenthesesDepth(s, i+1, mid) + ParenthesesDepth(s, mid, j)) + 1
          else if s[i] == ')' then (ParenthesesDepth(s, i+1, mid) + ParenthesesDepth(s, mid, j)) - 1
          else (ParenthesesDepth(s, i+1, mid) + ParenthesesDepth(s, mid, j));
          == 
          (if s[i] == '(' then ParenthesesDepth(s, i+1, mid) + 1
           else if s[i] == ')' then ParenthesesDepth(s, i+1, mid) - 1
           else ParenthesesDepth(s, i+1, mid)) + ParenthesesDepth(s, mid, j);
          == 
          ParenthesesDepth(s, i, mid) + ParenthesesDepth(s, mid, j);
        }
      } else {
        assert i == mid;
      }
    }
  }
  
  lemma NonnegativeDepthSplit(s: string, split: int)
    requires 0 <= split <= |s|
    requires InnerDepthsNonnegative(s)
    requires ParenthesesDepth(s, 0, |s|) == 0
    ensures ParenthesesDepth(s, 0, split) >= 0
    ensures ParenthesesDepth(s, split, |s|) == - ParenthesesDepth(s, 0, split)
  {
    DepthSplitLemma(s, 0, split, |s|);
    assert ParenthesesDepth(s, 0, |s|) == ParenthesesDepth(s, 0, split) + ParenthesesDepth(s, split, |s|);
    assert ParenthesesDepth(s, 0, |s|) == 0;
    if split > 0 && split < |s| {
      assert InnerDepthsNonnegative(s);
      assert ParenthesesDepth(s, 0, split) >= 0;
    }
  }
  
  lemma DepthTranslation(s: string, start: int, i: int)
    requires 0 <= start <= i <= |s|
    ensures ParenthesesDepth(s[start..i], 0, i - start) == ParenthesesDepth(s, start, i)
  {
    if start == i {
    } else {
      var sub := s[start..i];
      if s[start] == '(' {
        calc {
          ParenthesesDepth(sub, 0, |sub|);
          == ParenthesesDepth(sub, 1, |sub|) + 1;
          == { DepthTranslation(s, start+1, i); }
          ParenthesesDepth(s, start+1, i) + 1;
          == ParenthesesDepth(s, start, i);
        }
      } else if s[start] == ')' {
        calc {
          ParenthesesDepth(sub, 0, |sub|);
          == ParenthesesDepth(sub, 1, |sub|) - 1;
          == { DepthTranslation(s, start+1, i); }
          ParenthesesDepth(s, start+1, i) - 1;
          == ParenthesesDepth(s, start, i);
        }
      } else {
        calc {
          ParenthesesDepth(sub, 0, |sub|);
          == ParenthesesDepth(sub, 1, |sub|);
          == { DepthTranslation(s, start+1, i); }
          ParenthesesDepth(s, start+1, i);
          == ParenthesesDepth(s, start, i);
        }
      }
    }
  }
  
  lemma DepthUpdate(s: string, start: int, i: int)
    requires 0 <= start <= i < |s|
    ensures ParenthesesDepth(s, start, i+1) == ParenthesesDepth(s, start, i) + if s[i] == '(' then 1 else if s[i] == ')' then -1 else 0
  {
    calc {
      ParenthesesDepth(s, start, i+1);
      == if s[i] == '(' then ParenthesesDepth(s, i+1, i+1) + 1 + ParenthesesDepth(s, start, i)
         else if s[i] == ')' then ParenthesesDepth(s, i+1, i+1) - 1 + ParenthesesDepth(s, start, i)
         else ParenthesesDepth(s, start, i);
      == ParenthesesDepth(s, start, i) + if s[i] == '(' then 1 else if s[i] == ')' then -1 else 0;
    }
  }
  
  lemma PositiveDepthInGroup(s: string, start: int, end: int, k: int)
    requires 0 <= start <= k < end <= |s|
    requires ParenthesesDepth(s, start, end) == 0
    requires InnerDepthsNonnegative(s)
    requires start < end
    ensures ParenthesesDepth(s, start, k) > 0
  {
    DepthSplitLemma(s, 0, start, k);
    DepthSplitLemma(s, 0, start, end);
    if start > 0 {
      assert ParenthesesDepth(s, 0, start) == 0;
      assert ParenthesesDepth(s, 0, end) == 0;
      assert ParenthesesDepth(s, 0, k) == ParenthesesDepth(s, 0, start) + ParenthesesDepth(s, start, k);
      assert ParenthesesDepth(s, 0, end) == ParenthesesDepth(s, 0, start) + ParenthesesDepth(s, start, end);
      assert ParenthesesDepth(s, start, k) == ParenthesesDepth(s, 0, k);
      assert ParenthesesDepth(s, 0, k) > 0;
    } else {
      assert ParenthesesDepth(s, 0, k) > 0;
    }
  }

vc-description: |-
  function_signature: def separate_paren_groups(paren_string: str) -> List[str]
  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.

vc-spec: |-
  method separate_paren_groups(paren_string: string) returns (res : seq<string>)
      // pre-conditions-start
      requires ParenthesesDepth(paren_string, 0, |paren_string|) == 0
      requires InnerDepthsNonnegative(paren_string)
      // pre-conditions-end
      // post-conditions-start
      ensures forall k :: 0 <= k < |res| ==> ParenthesesDepth(res[k], 0, |res[k]|) == 0
      ensures forall k :: 0 <= k < |res| ==> InnerDepthsPositive(res[k])
      // post-conditions-end

vc-code: |-
  method SeparateParenGroups(paren_string: string) returns (res: seq<string>)
    requires ParenthesesDepth(paren_string, 0, |paren_string|) == 0
    requires InnerDepthsNonnegative(paren_string)
    ensures forall k :: 0 <= k < |res| ==> ParenthesesDepth(res[k], 0, |res[k]|) == 0
    ensures forall k :: 0 <= k < |res| ==> InnerDepthsPositive(res[k])
  {
    var result: seq<string> := [];
    var start := 0;
    var i := 0;
    var current_depth := 0;
  
    while i < |paren_string|
      invariant 0 <= start <= i <= |paren_string|
      invariant current_depth == ParenthesesDepth(paren_string, start, i)
      invariant start == i ==> current_depth == 0
      invariant forall k :: start <= k < i ==> ParenthesesDepth(paren_string, start, k) >= 0
      invariant start > 0 ==> ParenthesesDepth(paren_string, 0, start) == 0
      invariant start > 0 ==> forall k :: 0 <= k < start ==> ParenthesesDepth(paren_string, 0, k) >= 0
      invariant forall s :: s in result ==> ParenthesesDepth(s, 0, |s|) == 0
      invariant forall s :: s in result ==> InnerDepthsPositive(s)
    {
      if paren_string[i] == '(' {
        current_depth := current_depth + 1;
      } else if paren_string[i] == ')' {
        current_depth := current_depth - 1;
      }
      DepthUpdate(paren_string, start, i);
      assert current_depth == ParenthesesDepth(paren_string, start, i+1);
      
      if current_depth == 0 && start < i {
        var group := paren_string[start..i+1];
        DepthTranslation(paren_string, start, i+1);
        assert ParenthesesDepth(group, 0, |group|) == 0;
        assert InnerDepthsPositive(group) by {
          forall k | 0 < k < |group| {
            DepthTranslation(paren_string, start, start + k);
            PositiveDepthInGroup(paren_string, start, i+1, start + k);
            assert ParenthesesDepth(group, 0, k) > 0;
          }
        }
        result := result + [group];
        start := i + 1;
      }
      i := i + 1;
    }
    
    if start < |paren_string| {
      var group := paren_string[start..|paren_string|];
      DepthTranslation(paren_string, start, |paren_string|);
      assert ParenthesesDepth(group, 0, |group|) == 0;
      assert InnerDepthsPositive(group) by {
        forall k | 0 < k < |group| {
          DepthTranslation(paren_string, start, start + k);
          PositiveDepthInGroup(paren_string, start, |paren_string|, start + k);
          assert ParenthesesDepth(group, 0, k) > 0;
        }
      }
      result := result + [group];
    }
    
    res := result;
  }

vc-postamble: |-


