vc-preamble: |-


vc-helpers: |-
  lemma digit_count_property(n: nat)
    ensures digit_count(n) == even_count(n) + odd_count(n)
  {
    if n == 0 {
    } else {
      digit_count_property(n / 10);
    }
  }
  
  function digit_count(n: nat): nat {
    if n == 0 then 0
    else 1 + digit_count(n / 10)
  }

vc-description: |-
  function_signature: method even_odd_count(n: nat) returns (even: nat, odd: nat)
  Given an integer, return a tuple that has the number of even and odd digits respectively.

vc-spec: |-
  method even_odd_count(n: nat) returns (even: nat, odd: nat)
    ensures even == even_count(n)
    ensures odd == odd_count(n)

vc-code: |-
  {
    even := 0;
    odd := 0;
    var num := n;
    
    while num > 0
      invariant even + even_count(num) == even_count(n)
      invariant odd + odd_count(num) == odd_count(n)
    {
      if num % 2 == 0 {
        even := even + 1;
      } else {
        odd := odd + 1;
      }
      num := num / 10;
    }
  }

vc-postamble: |-
  function odd_count(n: nat): nat {
    if n == 0 then 0
    else odd_count(n / 10) + n % 2
  }
  // pure-end
  function even_count(n: nat): nat
  {
    if n == 0 then 0
    else even_count(n / 10) + (1 - n % 2)
  }
  // pure-end

