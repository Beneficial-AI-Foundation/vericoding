vc-preamble: |-
  function IsLowerCase(s: string) : bool
  {
    forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'
  }
  function IsUpperCase(s: string) : bool
  {
    forall i :: 0 <= i < |s| ==> 'A' <= s[i] <= 'Z'
  }
  type DictCase = map<string, string>

vc-helpers: |-
  lemma KeysNotEmpty(dict: DictCase)
    requires dict != map[]
    ensures dict.Keys != {}
  {
  }
  
  lemma SetToSeqPreservesElements<T>(s: set<T>)
    ensures forall x :: x in s <==> x in SetToSeq(s)
  {
    if s == {} {
    } else {
      var y :| y in s;
      SetToSeqPreservesElements(s - {y});
    }
  }
  
  lemma SetToSeqCorrectness(keys: set<string>, keySeq: seq<string>)
    requires keySeq == SetToSeq(keys)
    requires keys != {}
    ensures forall i :: 0 <= i < |keySeq| ==> keySeq[i] in keys
    ensures forall key :: key in keys ==> key in keySeq
  {
    SetToSeqPreservesElements(keys);
  }
  
  lemma LoopInvariantCorrectness(keys: set<string>, keySeq: seq<string>, i: int, allLower: bool, allUpper: bool)
    requires keySeq == SetToSeq(keys)
    requires 0 <= i <= |keySeq|
    requires allLower ==> forall j :: 0 <= j < i ==> IsLowerCase(keySeq[j])
    requires allUpper ==> forall j :: 0 <= j < i ==> IsUpperCase(keySeq[j])
    requires forall j :: 0 <= j < |keySeq| ==> keySeq[j] in keys
    requires forall key :: key in keys ==> key in keySeq
    requires i == |keySeq|
    ensures (allLower || allUpper) == ((forall key :: key in keys ==> IsLowerCase(key)) || (forall key :: key in keys ==> IsUpperCase(key)))
  {
    SetToSeqPreservesElements(keys);
    if allLower {
      forall key | key in keys
        ensures IsLowerCase(key)
      {
        assert key in keySeq;
        var j :| 0 <= j < |keySeq| && keySeq[j] == key;
        assert IsLowerCase(keySeq[j]);
      }
    }
    if allUpper {
      forall key | key in keys
        ensures IsUpperCase(key)
      {
        assert key in keySeq;
        var j :| 0 <= j < |keySeq| && keySeq[j] == key;
        assert IsUpperCase(keySeq[j]);
      }
    }
  }
  
  function SetToSeq<T>(s: set<T>): seq<T>
    decreases s
  {
    if s == {} then [] else
      var x :| x in s; 
      [x] + SetToSeq(s - {x})
  }

vc-description: |-
  function_signature: def check_dict_case(s : dict[str, str]) -> bool
  Given a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False. The function should return False is the given dictionary is empty. Note(George): Modified the problem to use strings only for both keys and values.

vc-spec: |-
  method CheckDictCase(dict: DictCase) returns (result: bool)
    ensures result == (dict != map[] && 
      ((forall key :: key in dict ==> IsLowerCase(key)) ||
       (forall key :: key in dict ==> IsUpperCase(key))))

vc-code: |-
  {
    if dict == map[] {
      return false;
    }
    
    var keys := dict.Keys;
    KeysNotEmpty(dict);
    
    var allLower := true;
    var allUpper := true;
    
    var keySeq := SetToSeq(keys);
    SetToSeqCorrectness(keys, keySeq);
    var i := 0;
    
    while i < |keySeq|
      invariant 0 <= i <= |keySeq|
      invariant allLower ==> forall j :: 0 <= j < i ==> IsLowerCase(keySeq[j])
      invariant allUpper ==> forall j :: 0 <= j < i ==> IsUpperCase(keySeq[j])
      invariant forall j :: 0 <= j < |keySeq| ==> keySeq[j] in keys
      invariant forall key :: key in keys ==> key in keySeq
    {
      var key := keySeq[i];
      if !IsLowerCase(key) {
        allLower := false;
      }
      if !IsUpperCase(key) {
        allUpper := false;
      }
      i := i + 1;
    }
    
    LoopInvariantCorrectness(keys, keySeq, i, allLower, allUpper);
    return allLower || allUpper;
  }

vc-postamble: |-


