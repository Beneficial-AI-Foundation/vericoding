vc-preamble: |-
  method cube_root(N: nat) returns (r: nat)
    // post-conditions-start
    ensures cube(r) <= N < cube(r + 1)
    ensures r <= N
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  lemma CubeMonotonic(a: nat, b: nat)
    requires a <= b
    ensures cube(a) <= cube(b)
  {
    assert a * a <= b * b;
    assert a * a * a <= b * b * b;
  }
  
  lemma CubeStrictlyIncreasing(a: nat, b: nat)
    requires a < b
    ensures cube(a) < cube(b)
  {
    if a == 0 {
      assert cube(a) == 0;
      assert cube(b) > 0;
    } else {
      assert a * a < b * b;
      assert a * a * a < b * b * b;
    }
  }
  
  lemma NoCubeExists(n: nat, candidate: nat)
    requires cube(candidate) > n
    requires forall k: nat :: k < candidate ==> cube(k) < n
    ensures forall k: nat :: cube(k) != n
  {
    forall k: nat ensures cube(k) != n {
      if k < candidate {
        assert cube(k) < n;
      } else if k == candidate {
        assert cube(k) > n;
      } else {
        assert k > candidate;
        CubeStrictlyIncreasing(candidate, k);
        assert cube(k) > cube(candidate) > n;
      }
    }
  }

vc-description: |-
  function_signature: method is_cube(n: nat) returns (r: bool)
  Check if condition holds. Ensures: if true, then there exists an integer r such that N = r³; if false, then no integer r satisfies N = r³.

vc-spec: |-
  method is_cube(n: nat) returns (r: bool)
    ensures r <==> exists k: nat :: cube(k) == n

vc-code: |-
  {
    var candidate := 0;
    while cube(candidate) < n
      invariant forall k: nat :: k < candidate ==> cube(k) < n
      decreases n - cube(candidate)
    {
      candidate := candidate + 1;
    }
    
    if cube(candidate) == n {
      r := true;
    } else {
      r := false;
      assert cube(candidate) > n;
      assert forall k: nat :: k < candidate ==> cube(k) < n;
      NoCubeExists(n, candidate);
      assert forall k: nat :: cube(k) != n;
    }
  }

vc-postamble: |-
  function cube(n: int): int { n * n * n }
  // pure-end

