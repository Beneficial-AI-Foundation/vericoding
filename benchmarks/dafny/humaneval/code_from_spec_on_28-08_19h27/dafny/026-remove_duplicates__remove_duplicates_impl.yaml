vc-preamble: |-
  function count_rec(a: seq<int>, x: int): int {
    if |a| == 0 then 0
    else count_rec(a[1..], x) + (if a[0] == x then 1 else 0)
  }

vc-helpers: |-
  lemma count_rec_property(a: seq<int>, x: int)
    ensures count_rec(a, x) == |set i | 0 <= i < |a| && a[i] == x|
  {
    if |a| == 0 {
      assert a == [];
      assert (set i | 0 <= i < |a| && a[i] == x) == {};
    } else {
      count_rec_property(a[1..], x);
      var tail_set := set i | 0 <= i < |a[1..]| && a[1..][i] == x;
      var full_set := set i | 0 <= i < |a| && a[i] == x;
      var shifted_tail_set := set i | 1 <= i < |a| && a[i] == x;
      
      // Prove bijection between tail_set and shifted_tail_set
      assert forall j :: j in tail_set <==> (j+1) in shifted_tail_set by {
        forall j | j in tail_set ensures (j+1) in shifted_tail_set {
          assert 0 <= j < |a[1..]| && a[1..][j] == x;
          assert 1 <= j+1 < |a| && a[j+1] == x;
        }
        forall j | (j+1) in shifted_tail_set ensures j in tail_set {
          assert 1 <= j+1 < |a| && a[j+1] == x;
          assert 0 <= j < |a[1..]| && a[1..][j] == x;
        }
      }
      
      // Use bijection to prove equal cardinality
      assert |tail_set| == |shifted_tail_set| by {
        var f := map j | j in tail_set :: j+1;
        assert forall j :: j in tail_set ==> f[j] in shifted_tail_set;
        forall k | k in shifted_tail_set ensures exists j :: j in tail_set && f[j] == k {
          var j := k - 1;
          assert j in tail_set;
          assert f[j] == k;
        }
      }
      
      if a[0] == x {
        assert full_set == {0} + shifted_tail_set;
        assert 0 !in shifted_tail_set;
        assert |full_set| == 1 + |shifted_tail_set|;
        assert |full_set| == 1 + |tail_set|;
      } else {
        assert full_set == shifted_tail_set;
        assert |full_set| == |shifted_tail_set|;
        assert |full_set| == |tail_set|;
      }
    }
  }
  
  predicate all_unique(a: seq<int>) {
    forall i, j :: 0 <= i < j < |a| ==> a[i] != a[j]
  }
  
  lemma count_rec_monotonic(a: seq<int>, x: int, i: int)
    requires 0 <= i <= |a|
    ensures count_rec(a[..i], x) <= count_rec(a, x)
  {
    if i == |a| {
      assert a[..i] == a;
    } else {
      count_rec_property(a[..i], x);
      count_rec_property(a, x);
      var prefix_set := set j | 0 <= j < i && a[j] == x;
      var full_set := set j | 0 <= j < |a| && a[j] == x;
      
      forall k | k in prefix_set ensures k in full_set {
        assert 0 <= k < i && a[k] == x;
        assert 0 <= k < |a| && a[k] == x;
      }
      
      assert prefix_set <= full_set;
      assert |prefix_set| <= |full_set|;
    }
  }

vc-description: |-
  function_signature: method remove_duplicates(a: seq<int>) returns (result: seq<int>)
  Process input. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values.

vc-spec: |-
  method remove_duplicates(a: seq<int>) returns (result: seq<int>)
    ensures all_unique(result)
    ensures forall x :: x in result <==> x in a

vc-code: |-
  {
    result := [];
    var i := 0;
    
    while i < |a|
      invariant 0 <= i <= |a|
      invariant all_unique(result)
      invariant forall x :: x in result ==> x in a[..i]
      invariant forall x :: x in a[..i] ==> (x in result <==> (exists j :: 0 <= j < i && a[j] == x))
    {
      if a[i] !in result {
        result := result + [a[i]];
      }
      i := i + 1;
    }
    
    assert a[..i] == a;
  }

vc-postamble: |-
  method count(a: seq<int>, x: int) returns (cnt: int)
    // post-conditions-start
    ensures cnt == |set i | 0 <= i < |a| && a[i] == x|
    ensures cnt == count_rec(a, x)
    // post-conditions-end
  {
    assume{:axiom} false;
  }

