vc-preamble: |-
  function Sum(a: seq<int>, s: int, t: int): int
    requires 0 <= s <= t <= |a|
  {
    if s == t then 0 else Sum(a, s, t-1) + a[t-1]
  }

vc-helpers: |-
  lemma SumMonotonic(a: seq<int>, s: int, t1: int, t2: int)
    requires 0 <= s <= t1 <= t2 <= |a|
    requires forall i :: s <= i < t2 ==> a[i] >= 0
    ensures Sum(a, s, t1) <= Sum(a, s, t2)
  {
    if t1 == t2 {
      // Base case: Sum(a, s, t1) == Sum(a, s, t2)
    } else {
      // Inductive case
      SumMonotonic(a, s, t1, t2-1);
      assert Sum(a, s, t2) == Sum(a, s, t2-1) + a[t2-1];
      assert a[t2-1] >= 0;
    }
  }
  
  lemma SumProperty(a: seq<int>, s: int, t: int, k: int)
    requires 0 <= s <= k <= t <= |a|
    ensures Sum(a, s, t) == Sum(a, s, k) + Sum(a, k, t)
  {
    if k == t {
      // Base case
    } else {
      SumProperty(a, s, t-1, k);
      assert Sum(a, s, t) == Sum(a, s, t-1) + a[t-1];
      assert Sum(a, s, t-1) == Sum(a, s, k) + Sum(a, k, t-1);
      assert Sum(a, k, t) == Sum(a, k, t-1) + a[t-1];
    }
  }
  
  lemma SumSingle(a: seq<int>, i: int)
    requires 0 <= i < |a|
    ensures Sum(a, i, i+1) == a[i]
  {
  }
  
  lemma HelperInvariant(nums: seq<int>, result: int, k: int, currentStart: int, currentSum: int)
    requires |nums| > 0
    requires 0 < k <= |nums|
    requires 0 <= currentStart < k
    requires currentSum == Sum(nums, currentStart, k)
    requires exists i, j :: 0 <= i <= j < k && result == Sum(nums, i, j+1)
    requires forall i, j :: 0 <= i <= j < k-1 ==> result <= Sum(nums, i, j+1)
    requires result <= currentSum
    ensures forall i, j :: 0 <= i <= j < k ==> result <= Sum(nums, i, j+1)
  {
    forall i, j | 0 <= i <= j < k 
      ensures result <= Sum(nums, i, j+1)
    {
      if j < k-1 {
        assert result <= Sum(nums, i, j+1);
      } else {
        assert j == k-1;
        if i <= currentStart {
          SumProperty(nums, i, k, currentStart);
          assert Sum(nums, i, k) == Sum(nums, i, currentStart) + Sum(nums, currentStart, k);
          assert Sum(nums, currentStart, k) == currentSum;
          assert result <= currentSum;
          assert Sum(nums, i, currentStart) + currentSum >= currentSum;
          assert Sum(nums, i, k) >= currentSum >= result;
        } else {
          assert currentStart < i <= j == k-1;
          SumProperty(nums, currentStart, k, i);
          assert Sum(nums, currentStart, k) == Sum(nums, currentStart, i) + Sum(nums, i, k);
          assert currentSum == Sum(nums, currentStart, i) + Sum(nums, i, k);
          assert Sum(nums, i, k) <= currentSum;
          assert result <= currentSum;
          assert Sum(nums, i, j+1) == Sum(nums, i, k) <= currentSum;
          assert result <= Sum(nums, i, j+1);
        }
      }
    }
  }

vc-description: |-
  function_signature: def minSubArraySum(nums : list[int]) -> int
  Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums.

vc-spec: |-
  method minSubArraySum(nums: seq<int>) returns (result: int)
    requires |nums| > 0
    ensures exists i, j :: 0 <= i <= j < |nums| && result == Sum(nums, i, j+1)
    ensures forall i, j :: 0 <= i <= j < |nums| ==> result <= Sum(nums, i, j+1)

vc-code: |-
  {
    result := nums[0];
    var currentSum := nums[0];
    var currentStart := 0;
    var resultStart := 0;
    var resultEnd := 0;
    
    for k := 1 to |nums|
      invariant result <= currentSum
      invariant 0 <= resultStart <= resultEnd < k && result == Sum(nums, resultStart, resultEnd+1)
      invariant exists i, j :: 0 <= i <= j < k && result == Sum(nums, i, j+1)
      invariant forall i, j :: 0 <= i <= j < k-1 ==> result <= Sum(nums, i, j+1)
      invariant 0 <= currentStart < k && currentSum == Sum(nums, currentStart, k)
    {
      if nums[k] < currentSum + nums[k] {
        currentSum := nums[k];
        currentStart := k;
      } else {
        currentSum := currentSum + nums[k];
      }
      
      if currentSum < result {
        result := currentSum;
        resultStart := currentStart;
        resultEnd := k;
      }
      
      HelperInvariant(nums, result, k+1, currentStart, currentSum);
    }
  }

vc-postamble: |-


