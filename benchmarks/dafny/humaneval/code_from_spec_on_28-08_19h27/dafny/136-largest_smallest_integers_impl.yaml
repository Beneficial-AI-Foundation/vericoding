vc-preamble: |-
  datatype Option<T> = None | Some(value: T)
  function get_value(o: Option<int>): int
    requires o.Some?
    ensures get_value(o) == o.value
  {
    o.value
  }

vc-helpers: |-
  lemma SequenceSliceProperty<T>(s: seq<T>)
    ensures s[..|s|] == s
  {
  }
  
  lemma SliceContainment<T>(s: seq<T>, i: int, x: T)
    requires 0 <= i <= |s|
    requires x in s[..i]
    ensures x in s
  {
  }
  
  lemma SliceExtension<T>(s: seq<T>, i: int)
    requires 0 <= i < |s|
    ensures s[..i+1] == s[..i] + [s[i]]
    ensures s[i] in s[..i+1]
    ensures forall x :: x in s[..i] ==> x in s[..i+1]
  {
  }

vc-description: |-
  function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]
  Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.

vc-spec: |-
  method largest_smallest_integers(lst: seq<int>) returns (a: Option<int>, b: Option<int>)
    ensures a.Some? ==> (a.value < 0 && a.value in lst && forall x :: x in lst && x < 0 ==> x <= a.value)
    ensures a.None? ==> forall x :: x in lst ==> x >= 0
    ensures b.Some? ==> (b.value > 0 && b.value in lst && forall x :: x in lst && x > 0 ==> x >= b.value)
    ensures b.None? ==> forall x :: x in lst ==> x <= 0

vc-code: |-
  {
    var largest_neg: Option<int> := None;
    var smallest_pos: Option<int> := None;
    
    for i := 0 to |lst|
      invariant largest_neg.Some? ==> (largest_neg.value < 0 && largest_neg.value in lst[..i] && forall x :: x in lst[..i] && x < 0 ==> x <= largest_neg.value)
      invariant largest_neg.None? ==> forall x :: x in lst[..i] ==> x >= 0
      invariant smallest_pos.Some? ==> (smallest_pos.value > 0 && smallest_pos.value in lst[..i] && forall x :: x in lst[..i] && x > 0 ==> x >= smallest_pos.value)
      invariant smallest_pos.None? ==> forall x :: x in lst[..i] ==> x <= 0
    {
      var current := lst[i];
      SliceExtension(lst, i);
      
      if current < 0 {
        if largest_neg.None? || current > largest_neg.value {
          largest_neg := Some(current);
        }
        assert forall x :: x in lst[..i+1] && x < 0 ==> x <= largest_neg.value;
      } else if current > 0 {
        if smallest_pos.None? || current < smallest_pos.value {
          smallest_pos := Some(current);
        }
        assert forall x :: x in lst[..i+1] && x > 0 ==> x >= smallest_pos.value;
      }
      
      // Help maintain invariants for the case when current == 0
      if current == 0 {
        assert current >= 0 && current <= 0;
      }
    }
    
    SequenceSliceProperty(lst);
    forall x | x in lst[..|lst|] ensures x in lst { SliceContainment(lst, |lst|, x); }
    
    a := largest_neg;
    b := smallest_pos;
  }

vc-postamble: |-


