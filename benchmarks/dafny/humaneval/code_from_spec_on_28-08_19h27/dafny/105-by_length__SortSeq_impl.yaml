vc-preamble: |-
  method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)
    // post-conditions-start
    ensures |result| <= |arr|
    ensures forall i :: 0 <= i < |result| ==>
      result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    // post-conditions-end
  {
    assume{:axiom} false;
  }

vc-helpers: |-
  predicate sorted(s: seq<int>)
  {
    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
  }
  
  predicate multiset_eq<T(==)>(s1: seq<T>, s2: seq<T>)
  {
    multiset(s1) == multiset(s2)
  }
  
  lemma SwapPreservesMultiset(s: seq<int>, i: int, j: int)
    requires 0 <= i < |s| && 0 <= j < |s|
    ensures multiset(s[i := s[j]][j := s[i]]) == multiset(s)
  {
  }
  
  lemma SwapPreservesSortedPrefix(s: seq<int>, k: int, i: int, j: int)
    requires 0 <= k <= i < j < |s|
    requires forall x, y :: 0 <= x < y < k ==> s[x] <= s[y]
    ensures forall x, y {:trigger s[i := s[j]][j := s[i]][x], s[i := s[j]][j := s[i]][y]} :: 0 <= x < y < k ==> s[i := s[j]][j := s[i]][x] <= s[i := s[j]][j := s[i]][y]
  {
  }
  
  lemma SwapMaintainsOrder(s: seq<int>, j: int)
    requires 1 <= j < |s|
    requires s[j-1] > s[j]
    requires forall x, y :: 0 <= x < y < j-1 ==> s[x] <= s[y]
    requires forall x, y :: j < x < y < |s| ==> s[x] <= s[y]
    ensures var s' := s[j-1 := s[j]][j := s[j-1]];
      forall x, y :: 0 <= x < y < j ==> s'[x] <= s'[y]
  {
    var s' := s[j-1 := s[j]][j := s[j-1]];
    forall x, y | 0 <= x < y < j
      ensures s'[x] <= s'[y]
    {
      if x == j-1 {
        assert s'[x] == s[j];
        if y == j-1 {
          assert false;
        } else {
          assert y < j-1;
          assert s'[y] == s[y];
          assert s[j] <= s[y];
        }
      } else if y == j-1 {
        assert s'[x] == s[x];
        assert s'[y] == s[j];
        assert s[x] <= s[j];
      } else {
        assert s'[x] == s[x] && s'[y] == s[y];
        assert s[x] <= s[y];
      }
    }
  }

vc-description: |-
  function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)
  Sort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.

vc-spec: |-
  method SortSeq(s: seq<int>) returns (result: seq<int>)
    ensures |result| == |s|
    ensures sorted(result)
    ensures multiset_eq(result, s)

vc-code: |-
  {
    result := s;
    
    var i := 0;
    while i < |result|
      invariant 0 <= i <= |result|
      invariant |result| == |s|
      invariant multiset_eq(result, s)
      invariant forall x, y :: 0 <= x < y < i ==> result[x] <= result[y]
    {
      var j := i;
      while j > 0 && result[j-1] > result[j]
        invariant 0 <= j <= i
        invariant |result| == |s|
        invariant multiset_eq(result, s)
        invariant forall x, y :: 0 <= x < y < j ==> result[x] <= result[y]
        invariant forall x, y :: j < x < y <= i ==> result[x] <= result[y]
        invariant forall x :: j < x <= i ==> result[j] <= result[x]
      {
        SwapPreservesMultiset(result, j-1, j);
        SwapMaintainsOrder(result, j);
        result := result[j-1 := result[j]][j := result[j-1]];
        j := j - 1;
      }
      i := i + 1;
    }
  }

vc-postamble: |-
  method reverse(s: seq<int>) returns (rev: seq<int>)
    // post-conditions-start
    ensures |rev| == |s|
    ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function NumberToName(n: int): string
    requires 1 <= n <= 9
  {
    match n
    case 1 => "One"
    case 2 => "Two"
    case 3 => "Three"
    case 4 => "Four"
    case 5 => "Five"
    case 6 => "Six"
    case 7 => "Seven"
    case 8 => "Eight"
    case 9 => "Nine"
  }
  // pure-end

