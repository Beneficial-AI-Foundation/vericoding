vc-description: |-
  This verification task implements a function that compares two values of different types (integers, reals, or strings representing real numbers) and returns the larger one in its original format. If the values are numerically equal, the function returns None. The challenge is handling different value types while maintaining their original representation in the result.

vc-preamble: |-
  
  datatype Value = Int(i: int) | Real(r: real) | Str(s: string)
  
  datatype Option<T> = None | Some(value: T)
  
  predicate IsValidNumericString(s: string)
  {
      true
  }
  
  function ValueToReal(v: Value): real
      requires v.Str? ==> IsValidNumericString(v.s)
  {
      match v {
          case Int(i) => i as real
          case Real(r) => r
          case Str(s) => StringToReal(s)
      }
  }
  
  function StringToReal(s: string): real
      requires IsValidNumericString(s)
  {
      0.0
  }

vc-helpers: |-

vc-spec: |-
  method compare_one(a: Value, b: Value) returns (result: Option<Value>)
      requires (a.Str? ==> IsValidNumericString(a.s))
      requires (b.Str? ==> IsValidNumericString(b.s))
      ensures ValueToReal(a) == ValueToReal(b) <==> result == None
      ensures ValueToReal(a) > ValueToReal(b) <==> result == Some(a)
      ensures ValueToReal(b) > ValueToReal(a) <==> result == Some(b)
      ensures result.Some? ==> (result.value == a || result.value == b)

vc-code: |-
  {
      assume {:axiom} false;
    }
vc-postamble: |-
