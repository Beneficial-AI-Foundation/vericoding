{"id": "DH0000", "language": "dafny", "source": "humaneval", "source_id": "humaneval_000", "vc-description": "This verification task involves implementing a method to determine if any two numbers in a given list have an absolute difference less than a specified threshold. The implementation uses nested loops to compare all pairs of elements and returns true as soon as a close pair is found, or false if no such pair exists.", "vc-preamble": "\npredicate ValidInput(numbers: seq<real>, threshold: real)\n{\n    true\n}\n\nfunction AbsDiff(a: real, b: real): real\n{\n    if a >= b then a - b else b - a\n}\n\npredicate HasCloseElements(numbers: seq<real>, threshold: real)\n{\n    exists i, j :: 0 <= i < j < |numbers| && AbsDiff(numbers[i], numbers[j]) < threshold\n}", "vc-helpers": "", "vc-spec": "method has_close_elements(numbers: seq<real>, threshold: real) returns (result: bool)\n    requires ValidInput(numbers, threshold)\n    ensures result == HasCloseElements(numbers, threshold)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0001", "language": "dafny", "source": "humaneval", "source_id": "humaneval_001_separate-paren-groups", "vc-description": "function_signature: def separate_paren_groups(paren_string: str) -> List[str]\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to separate those group into separate strings and return the list of those. Separate groups are balanced (each open brace is properly closed) and not nested within each other Ignore any spaces in the input string.", "vc-preamble": "function ParenthesesDepth(s: string, i: int, j: int): int\n    decreases j - i \n    requires 0 <= i <= j <= |s|\n{\n    if i == j then\n        0\n    else if s[i] == '(' then\n        ParenthesesDepth(s, i+1, j) + 1\n    else if s[i] == ')' then\n        ParenthesesDepth(s, i+1, j) - 1\n    else\n        ParenthesesDepth(s, i+1, j)\n}\nfunction InnerDepthsPositive(s: string) : bool\n{\n    forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) > 0\n}\nfunction InnerDepthsNonnegative(s: string) : bool\n{\n    forall i :: 0 < i < |s| ==> ParenthesesDepth(s, 0, i) >= 0\n}", "vc-helpers": "", "vc-spec": "method separate_paren_groups(paren_string: string) returns (res : seq<string>)\n\n    requires ParenthesesDepth(paren_string, 0, |paren_string|) == 0\n    requires InnerDepthsNonnegative(paren_string)\n\n    ensures forall k :: 0 <= k < |res| ==> ParenthesesDepth(res[k], 0, |res[k]|) == 0\n    ensures forall k :: 0 <= k < |res| ==> InnerDepthsPositive(res[k])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0002", "language": "dafny", "source": "humaneval", "source_id": "humaneval_002", "vc-description": "This task implements a function to extract the decimal (fractional) part of a positive floating point number. Given a number like 3.5, it should return 0.5, and for 1.25, it should return 0.25. The implementation involves subtracting the floor (integer part) from the original number.", "vc-preamble": "\npredicate ValidInput(number: real)\n{\n    number >= 0.0\n}\n\npredicate ValidOutput(result: real, input: real)\n{\n    0.0 <= result < 1.0 && result == input - Floor(input)\n}\n\nfunction Floor(x: real): real\n    ensures Floor(x) <= x < Floor(x) + 1.0\n{\n    if x >= 0.0 then\n        FloorNonnegative(x)\n    else\n        -CeilNonnegative(-x)\n}\n\nfunction FloorNonnegative(x: real): real\n    requires x >= 0.0\n    ensures FloorNonnegative(x) <= x < FloorNonnegative(x) + 1.0\n    ensures FloorNonnegative(x) >= 0.0\n{\n    FloorHelper(x, 0)\n}\n\nfunction FloorHelper(x: real, n: int): real\n    requires x >= 0.0\n    requires n >= 0\n    ensures FloorHelper(x, n) <= x + n as real < FloorHelper(x, n) + 1.0\n    ensures FloorHelper(x, n) >= n as real\n    decreases x\n{\n    if x < 1.0 then \n        n as real\n    else \n        FloorHelper(x - 1.0, n + 1)\n}\n\nfunction CeilNonnegative(x: real): real\n    requires x >= 0.0\n    ensures CeilNonnegative(x) >= x\n    ensures x > 0.0 ==> CeilNonnegative(x) < x + 1.0\n{\n    if x == 0.0 then \n        0.0\n    else if FloorNonnegative(x) == x then\n        x\n    else\n        FloorNonnegative(x) + 1.0\n}", "vc-helpers": "", "vc-spec": "method truncate_number(number: real) returns (result: real)\n    requires ValidInput(number)\n    ensures ValidOutput(result, number)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0003", "language": "dafny", "source": "humaneval", "source_id": "humaneval_003", "vc-description": "Given a list of integers representing bank account operations (positive for deposits, negative for withdrawals), determine if the account balance ever drops below zero. The account starts with a balance of zero.", "vc-preamble": "\nfunction sum_prefix(ops: seq<int>, len: nat): int\n  requires len <= |ops|\n{\n  if len == 0 then 0\n  else sum_prefix(ops, len-1) + ops[len-1]\n}", "vc-helpers": "", "vc-spec": "method below_zero(operations: seq<int>) returns (result: bool)\n  ensures result <==> (exists i :: 0 < i <= |operations| && sum_prefix(operations, i) < 0)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0004", "language": "dafny", "source": "humaneval", "source_id": "humaneval_004", "vc-description": "This task implements the calculation of Mean Absolute Deviation (MAD) for a sequence of floating-point numbers. The MAD is defined as the average of the absolute deviations from the arithmetic mean of the data set.\n\nThe implementation should calculate the arithmetic mean, compute absolute deviations from this mean for each element, and then return the average of these absolute deviations while ensuring the result is non-negative.", "vc-preamble": "\nfunction sum(numbers: seq<real>): real\n{\n    if |numbers| == 0 then 0.0\n    else numbers[0] + sum(numbers[1..])\n}\n\nfunction abs(x: real): real\n{\n    if x >= 0.0 then x else -x\n}\n\npredicate ValidInput(numbers: seq<real>)\n{\n    |numbers| > 0\n}\n\nfunction ArithmeticMean(numbers: seq<real>): real\n    requires ValidInput(numbers)\n{\n    sum(numbers) / (|numbers| as real)\n}\n\nfunction AbsoluteDeviations(numbers: seq<real>): seq<real>\n    requires ValidInput(numbers)\n{\n    seq(|numbers|, i requires 0 <= i < |numbers| => abs(numbers[i] - ArithmeticMean(numbers)))\n}\n\nfunction MAD(numbers: seq<real>): real\n    requires ValidInput(numbers)\n{\n    sum(AbsoluteDeviations(numbers)) / (|numbers| as real)\n}\nlemma sum_non_negative(numbers: seq<real>)\n    requires forall i :: 0 <= i < |numbers| ==> numbers[i] >= 0.0\n    ensures sum(numbers) >= 0.0\n{\n    if |numbers| == 0 {\n    } else {\n        sum_non_negative(numbers[1..]);\n    }\n}", "vc-helpers": "", "vc-spec": "method mean_absolute_deviation(numbers: seq<real>) returns (result: real)\n    requires ValidInput(numbers)\n    ensures result >= 0.0\n    ensures result == MAD(numbers)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0005", "language": "dafny", "source": "humaneval", "source_id": "humaneval_005", "vc-description": "This verification task involves implementing a method that inserts a delimiter between every two consecutive elements in a sequence of integers. The method should handle edge cases like empty sequences or single-element sequences, and for longer sequences, it should produce a result with alternating original elements and delimiters.", "vc-preamble": "\npredicate ValidInput(numbers: seq<int>, delimiter: int)\n{\n    true // Any sequence and delimiter are valid inputs\n}\n\npredicate ValidOutput(numbers: seq<int>, delimiter: int, result: seq<int>)\n{\n    if |numbers| <= 1 then\n        result == numbers\n    else\n        |result| == 2 * |numbers| - 1 &&\n        (forall i :: 0 <= i < |numbers| ==> result[2 * i] == numbers[i]) &&\n        (forall i :: 0 <= i < |numbers| - 1 ==> result[2 * i + 1] == delimiter)\n}", "vc-helpers": "", "vc-spec": "method InsertDelimiter(numbers: seq<int>, delimiter: int) returns (result: seq<int>)\n    requires ValidInput(numbers, delimiter)\n    ensures ValidOutput(numbers, delimiter, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0006", "language": "dafny", "source": "humaneval", "source_id": "humaneval_006", "vc-description": "This verification task implements a parser for nested parentheses strings. Given a string containing groups of nested parentheses separated by spaces, the goal is to find the maximum nesting depth for each group independently. The implementation must correctly split the input by spaces, calculate nesting depths, and return a sequence of maximum depths corresponding to each group.", "vc-preamble": "\nfunction SplitBySpacesResult(s: string): seq<string>\n    requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    ensures forall i :: 0 <= i < |SplitBySpacesResult(s)| ==> forall j :: 0 <= j < |SplitBySpacesResult(s)[i]| ==> SplitBySpacesResult(s)[i][j] == '(' || SplitBySpacesResult(s)[i][j] == ')'\n    ensures |s| == 0 ==> |SplitBySpacesResult(s)| == 0\n{\n    if |s| == 0 then []\n    else\n        var groups := [];\n        var current_group := \"\";\n        var i := 0;\n        SplitBySpacesHelper(s, i, current_group, groups)\n}\n\nfunction MaxNestingDepth(group: string): int\n    requires forall i :: 0 <= i < |group| ==> group[i] == '(' || group[i] == ')'\n    ensures MaxNestingDepth(group) >= 0\n{\n    MaxNestingDepthHelper(group, 0, 0, 0)\n}\n\nfunction SplitBySpacesHelper(s: string, i: int, current_group: string, groups: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    requires forall k :: 0 <= k < |s| ==> s[k] == '(' || s[k] == ')' || s[k] == ' '\n    requires forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'\n    requires forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'\n    ensures forall k :: 0 <= k < |SplitBySpacesHelper(s, i, current_group, groups)| ==> forall j :: 0 <= j < |SplitBySpacesHelper(s, i, current_group, groups)[k]| ==> SplitBySpacesHelper(s, i, current_group, groups)[k][j] == '(' || SplitBySpacesHelper(s, i, current_group, groups)[k][j] == ')'\n    decreases |s| - i\n{\n    if i == |s| then\n        if |current_group| > 0 then groups + [current_group] else groups\n    else if s[i] == ' ' then\n        if |current_group| > 0 then\n            SplitBySpacesHelper(s, i + 1, \"\", groups + [current_group])\n        else\n            SplitBySpacesHelper(s, i + 1, current_group, groups)\n    else\n        SplitBySpacesHelper(s, i + 1, current_group + [s[i]], groups)\n}\n\nfunction MaxNestingDepthHelper(group: string, index: int, current_depth: int, max_depth: int): int\n    requires 0 <= index <= |group|\n    requires max_depth >= 0\n    decreases |group| - index\n    ensures MaxNestingDepthHelper(group, index, current_depth, max_depth) >= 0\n{\n    if index == |group| then max_depth\n    else if group[index] == '(' then\n        var new_current := current_depth + 1;\n        var new_max := if new_current > max_depth then new_current else max_depth;\n        MaxNestingDepthHelper(group, index + 1, new_current, new_max)\n    else if group[index] == ')' then\n        MaxNestingDepthHelper(group, index + 1, current_depth - 1, max_depth)\n    else\n        MaxNestingDepthHelper(group, index + 1, current_depth, max_depth)\n}\n\nmethod SplitBySpaces(s: string) returns (groups: seq<string>)\n    requires forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')' || s[i] == ' '\n    ensures forall i :: 0 <= i < |groups| ==> ' ' !in groups[i]\n    ensures forall i :: 0 <= i < |groups| ==> forall j :: 0 <= j < |groups[i]| ==> groups[i][j] == '(' || groups[i][j] == ')'\n    ensures |s| == 0 ==> |groups| == 0\n    ensures groups == SplitBySpacesResult(s)\n{\n    groups := [];\n    var current_group := \"\";\n\n    if |s| == 0 {\n        return;\n    }\n\n    var i := 0;\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant ' ' !in current_group\n        invariant forall k :: 0 <= k < |groups| ==> ' ' !in groups[k]\n        invariant forall k :: 0 <= k < |groups| ==> forall j :: 0 <= j < |groups[k]| ==> groups[k][j] == '(' || groups[k][j] == ')'\n        invariant forall j :: 0 <= j < |current_group| ==> current_group[j] == '(' || current_group[j] == ')'\n        invariant SplitBySpacesResult(s) == SplitBySpacesHelper(s, i, current_group, groups)\n    {\n        if s[i] == ' ' {\n            if |current_group| > 0 {\n                groups := groups + [current_group];\n                current_group := \"\";\n            }\n        } else {\n            current_group := current_group + [s[i]];\n        }\n        i := i + 1;\n    }\n\n    if |current_group| > 0 {\n        groups := groups + [current_group];\n    }\n}", "vc-helpers": "", "vc-spec": "method parse_nested_parens(paren_string: string) returns (result: seq<int>)\n    requires forall i :: 0 <= i < |paren_string| ==> paren_string[i] == '(' || paren_string[i] == ')' || paren_string[i] == ' '\n    ensures |result| == |SplitBySpacesResult(paren_string)|\n    ensures forall i :: 0 <= i < |result| ==> result[i] >= 0\n    ensures |paren_string| == 0 ==> |result| == 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] == MaxNestingDepth(SplitBySpacesResult(paren_string)[i])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0007", "language": "dafny", "source": "humaneval", "source_id": "humaneval_007", "vc-description": "This task implements a string filtering function that takes a list of strings and a substring, returning a new list containing only the strings that contain the given substring. The filtering should preserve the original order of matching strings and be case-sensitive.", "vc-preamble": "\nfunction contains_substring(s: string, sub: string): bool\n{\n    if |sub| == 0 then true\n    else if |sub| > |s| then false\n    else exists i {:trigger s[i..i+|sub|]} :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub\n}\n\nfunction filter_sequence(strings: seq<string>, substring: string): seq<string>\n{\n    filter_sequence_helper(strings, substring, |strings|)\n}\n\nfunction filter_sequence_helper(strings: seq<string>, substring: string, n: int): seq<string>\n    requires 0 <= n <= |strings|\n{\n    if n == 0 then []\n    else if contains_substring(strings[n-1], substring) then\n        filter_sequence_helper(strings, substring, n-1) + [strings[n-1]]\n    else\n        filter_sequence_helper(strings, substring, n-1)\n}", "vc-helpers": "", "vc-spec": "method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)\n    ensures |result| <= |strings|\n    ensures forall i :: 0 <= i < |result| ==> result[i] in strings\n    ensures forall i :: 0 <= i < |result| ==> contains_substring(result[i], substring)\n    ensures forall i :: 0 <= i < |strings| && contains_substring(strings[i], substring) ==> strings[i] in result\n    ensures forall i, j :: 0 <= i < j < |result| ==> \n        exists k1, k2 :: 0 <= k1 < k2 < |strings| && result[i] == strings[k1] && result[j] == strings[k2]\n    ensures forall s :: s in result <==> (s in strings && contains_substring(s, substring))\n    ensures result == filter_sequence(strings, substring)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0008", "language": "dafny", "source": "humaneval", "source_id": "humaneval_008", "vc-description": "This verification task implements a method to compute both the sum and product of all integers in a given sequence. For an empty list, the method should return (0, 1) representing the empty sum and empty product respectively. The implementation uses iterative computation while maintaining loop invariants to ensure correctness.", "vc-preamble": "\nfunction SumSeq(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + SumSeq(s[1..])\n}\n\nfunction ProductSeq(s: seq<int>): int\n{\n    if |s| == 0 then 1\n    else s[0] * ProductSeq(s[1..])\n}\nlemma SumSeqAppend(s: seq<int>, x: int)\n    ensures SumSeq(s + [x]) == SumSeq(s) + x\n{\n    if |s| == 0 {\n        assert s + [x] == [x];\n        assert SumSeq([x]) == x + SumSeq([]);\n        assert SumSeq([]) == 0;\n    } else {\n        assert s == [s[0]] + s[1..];\n        assert s + [x] == [s[0]] + (s[1..] + [x]);\n        SumSeqAppend(s[1..], x);\n    }\n}\n\nlemma ProductSeqAppend(s: seq<int>, x: int)\n    ensures ProductSeq(s + [x]) == ProductSeq(s) * x\n{\n    if |s| == 0 {\n        assert s + [x] == [x];\n        assert ProductSeq([x]) == x * ProductSeq([]);\n        assert ProductSeq([]) == 1;\n    } else {\n        assert s == [s[0]] + s[1..];\n        assert s + [x] == [s[0]] + (s[1..] + [x]);\n        ProductSeqAppend(s[1..], x);\n    }\n}", "vc-helpers": "", "vc-spec": "method sum_product(numbers: seq<int>) returns (sum: int, product: int)\n    ensures sum == SumSeq(numbers)\n    ensures product == ProductSeq(numbers)\n    ensures |numbers| == 0 ==> sum == 0 && product == 1", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0009", "language": "dafny", "source": "humaneval", "source_id": "humaneval_009", "vc-description": "This verification task implements a rolling maximum function that takes a list of integers and returns a list where each element represents the maximum value encountered from the beginning of the list up to and including the current position.", "vc-preamble": "\nfunction max_up_to(numbers: seq<int>, index: int): int\n    requires 0 <= index < |numbers|\n{\n    if index == 0 then numbers[0]\n    else \n        var prev_max := max_up_to(numbers, index - 1);\n        if numbers[index] > prev_max then numbers[index] else prev_max\n}", "vc-helpers": "", "vc-spec": "method rolling_max(numbers: seq<int>) returns (result: seq<int>)\n    ensures |result| == |numbers|\n    ensures |numbers| == 0 ==> |result| == 0\n    ensures |numbers| > 0 ==> |result| > 0\n    ensures forall i :: 0 <= i < |result| ==> \n        result[i] == max_up_to(numbers, i)\n    ensures forall i :: 0 <= i < |result| ==> \n        forall j :: 0 <= j <= i ==> numbers[j] <= result[i]\n    ensures forall i :: 0 <= i < |result| ==> \n        exists j :: 0 <= j <= i && numbers[j] == result[i]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0010", "language": "dafny", "source": "humaneval", "source_id": "humaneval_010_is_palindrome__make_palindrome", "vc-description": "function_signature: method make_palindrome(s: string) returns (result: string)\nProcess input. Ensures: the size is bounded; the result is a palindrome; ensures starts_with(result, s).", "vc-preamble": "function is_palindrome(s : string) : bool {\n    forall k :: 0 <= k < |s| ==> s[k] == s[|s| - 1 - k]\n}\n\nfunction starts_with(result : string, s : string) : bool {\n    |result| >= |s| && forall k :: 0 <= k < |s| ==> result[k] == s[k]\n}", "vc-helpers": "", "vc-spec": "method make_palindrome(s: string) returns (result: string)\n\n    ensures |result| <= 2 * |s|\n    ensures is_palindrome(result)\n    ensures starts_with(result, s)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0011", "language": "dafny", "source": "humaneval", "source_id": "humaneval_011", "vc-description": "This task implements a bitwise XOR operation on two binary strings of equal length. Given two strings containing only '0' and '1' characters, the method should return a new string where each position contains '0' if the corresponding characters in the input strings are the same, and '1' if they are different.", "vc-preamble": "\npredicate is_binary_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method string_xor(a: string, b: string) returns (result: string)\n    requires |a| == |b|\n    requires is_binary_string(a)\n    requires is_binary_string(b)\n    ensures |result| == |a|\n    ensures is_binary_string(result)\n    ensures forall i :: 0 <= i < |a| ==> \n        (a[i] == b[i] ==> result[i] == '0') &&\n        (a[i] != b[i] ==> result[i] == '1')", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0012", "language": "dafny", "source": "humaneval", "source_id": "humaneval_012", "vc-description": "This task involves finding the longest string in a sequence of strings. If multiple strings have the same maximum length, the method should return the first one that appears in the list. If the list is empty, it should return None using an Option type.", "vc-preamble": "\ndatatype Option<T> = Some(value: T) | None\n\npredicate ValidResult(strings: seq<string>, result: Option<string>)\n{\n    if |strings| == 0 then\n        result == None\n    else\n        result.Some? &&\n        (exists i :: (0 <= i < |strings| && strings[i] == result.value &&\n        (forall s :: s in strings ==> |result.value| >= |s|) &&\n        (forall j :: 0 <= j < i ==> |strings[j]| < |result.value|)))\n}", "vc-helpers": "", "vc-spec": "method longest(strings: seq<string>) returns (result: Option<string>)\n    ensures ValidResult(strings, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0013", "language": "dafny", "source": "humaneval", "source_id": "humaneval_013", "vc-description": "This task involves implementing the greatest common divisor (GCD) function for two integers. The GCD is the largest positive integer that divides both numbers without remainder, with special cases for zero values.\n\nThe implementation should use the Euclidean algorithm, which repeatedly applies the property that GCD(a,b) = GCD(b, a mod b) until one operand becomes zero.", "vc-preamble": "\nfunction abs(x: int): nat\n{\n    if x >= 0 then x else -x\n}\n\npredicate divides(d: int, n: int)\n{\n    if d == 0 then n == 0 else n % d == 0\n}", "vc-helpers": "", "vc-spec": "method greatest_common_divisor(a: int, b: int) returns (result: nat)\n    ensures result > 0 <==> (a != 0 || b != 0)\n    ensures result == 0 <==> (a == 0 && b == 0)\n    ensures divides(result, a) && divides(result, b)\n    ensures forall d: int :: d > 0 && divides(d, a) && divides(d, b) ==> d <= result", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0014", "language": "dafny", "source": "humaneval", "source_id": "humaneval_014", "vc-description": "Given a string, return a list of all its prefixes ordered from shortest to longest. A prefix is a substring that starts from the beginning of the original string.", "vc-preamble": "\npredicate ValidPrefixes(s: string, result: seq<string>)\n{\n    |result| == |s| &&\n    forall i :: 0 <= i < |result| ==> result[i] == s[0..i+1]\n}", "vc-helpers": "", "vc-spec": "method all_prefixes(s: string) returns (result: seq<string>)\n    ensures ValidPrefixes(s, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0015", "language": "dafny", "source": "humaneval", "source_id": "humaneval_016", "vc-description": "Count the number of distinct characters in a string, ignoring case differences. The implementation should return an integer representing the count of unique characters, treating 'A' and 'a' as the same character through case-insensitive comparison.", "vc-preamble": "\nfunction to_lower_char(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}", "vc-helpers": "", "vc-spec": "method count_distinct_characters(s: string) returns (count: int)\n    ensures count >= 0\n    ensures count <= |s|\n    ensures count == |set i | 0 <= i < |s| :: to_lower_char(s[i])|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0016", "language": "dafny", "source": "humaneval", "source_id": "humaneval_018_how_many_times", "vc-description": "function_signature: def how_many_times(string: str, substring: str) -> int\nFind how many times a given substring can be found in the original string. Count overlaping cases.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method how_many_times(s: string, substr: string) returns (times: int)\n\n    ensures times == |set i {:trigger} | 0 <= i <= |s| - |substr| && s[i..i+|substr|] == substr|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0017", "language": "dafny", "source": "humaneval", "source_id": "humaneval_020", "vc-description": "Given a list of numbers with at least two elements, find the pair of numbers with the smallest absolute difference between them. Return the pair as a tuple ordered from smaller to larger value. The implementation uses nested loops to compare all pairs and track the minimum difference found.", "vc-preamble": "\nfunction AbsDiff(x: real, y: real): real\n{\n  if x >= y then x - y else y - x\n}\n\npredicate ValidInput(numbers: seq<real>)\n{\n  |numbers| >= 2\n}\n\npredicate IsOptimalPair(numbers: seq<real>, pair: (real, real))\n{\n  pair.0 in numbers &&\n  pair.1 in numbers &&\n  pair.0 <= pair.1 &&\n  forall i, j :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j ==>\n    AbsDiff(numbers[i], numbers[j]) >= AbsDiff(pair.0, pair.1)\n}", "vc-helpers": "", "vc-spec": "method find_closest_elements(numbers: seq<real>) returns (result: (real, real))\n  requires ValidInput(numbers)\n  ensures IsOptimalPair(numbers, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0018", "language": "dafny", "source": "humaneval", "source_id": "humaneval_021_rescale_to_unit", "vc-description": "function_signature: def rescale_to_unit(numbers: List[float]) -> List[float]\nGiven list of numbers (of at least two elements), apply a linear transform to that list, such that the smallest number will become 0 and the largest will become 1", "vc-preamble": "function affine(x: real, shift: real, scale: real) : real\n    requires scale > 0.0\n{\n    (x + shift) / scale\n}\nfunction affine_seq(s: seq<real>, r: seq<real>, shift: real, scale: real) : bool\n  requires scale > 0.0\n  requires |r| == |s|\n{\n  forall i :: 0 <= i < |s| ==> r[i] == affine(s[i], shift, scale)\n}", "vc-helpers": "", "vc-spec": "method rescale_to_unit(s: seq<real>) returns (r : seq<real>)\n\n  requires |s| >= 2\n  requires exists i, j : int :: (0 <= i < j < |s|) && s[i] != s[j]\n\n  ensures |r| == |s|\n  ensures forall i : int :: 0 <= i < |s| ==> 0.0 <= r[i] <= 1.0\n  ensures exists i : int :: 0 <= i < |s| && r[i] == 0.0\n  ensures exists i : int :: 0 <= i < |s| && r[i] == 1.0\n  ensures exists shift, scale :: scale > 0.0 && affine_seq(s, r, shift, scale)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0019", "language": "dafny", "source": "humaneval", "source_id": "humaneval_022", "vc-description": "Given a list containing values of various types, return a new list containing only the integer values. In Python, booleans are considered integers (True=1, False=0), so they should be included in the result. The task requires implementing a function that filters a sequence of mixed-type values to extract only integers and boolean values (converted to 0/1).", "vc-preamble": "\ndatatype Value = IntVal(i: int) | BoolVal(b: bool) | StringVal(s: string) | RealVal(r: real) | OtherVal\n\npredicate ValidInput(values: seq<Value>)\n{\n    true  // All sequences of Value are valid input\n}\n\nfunction IntegerValues(values: seq<Value>) : seq<int>\n{\n    if |values| == 0 then []\n    else \n        match values[0]\n        case IntVal(i) => [i] + IntegerValues(values[1..])\n        case BoolVal(b) => [if b then 1 else 0] + IntegerValues(values[1..])\n        case _ => IntegerValues(values[1..])\n}\n\npredicate ValidOutput(input: seq<Value>, output: seq<int>)\n{\n    output == IntegerValues(input)\n}", "vc-helpers": "", "vc-spec": "method filter_integers(values: seq<Value>) returns (result: seq<int>)\n    requires ValidInput(values)\n    ensures ValidOutput(values, result)\n    ensures |result| <= |values|\n    ensures forall x :: x in result ==> \n        exists i :: 0 <= i < |values| && (values[i] == IntVal(x) || (values[i].BoolVal? && x == (if values[i].b then 1 else 0)))\n    ensures forall i :: 0 <= i < |values| && values[i].IntVal? ==> values[i].i in result\n    ensures forall i :: 0 <= i < |values| && values[i].BoolVal? ==> (if values[i].b then 1 else 0) in result", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0020", "language": "dafny", "source": "humaneval", "source_id": "humaneval_023", "vc-description": "Implement a function that returns the length of a given string. The function should handle empty strings and return 0 for them. For non-empty strings, it should return the count of characters.", "vc-preamble": "\npredicate ValidInput(s: string)\n{\n    true\n}\n\nfunction CorrectLength(s: string): int\n{\n    |s|\n}", "vc-helpers": "", "vc-spec": "method strlen(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result >= 0\n    ensures result == CorrectLength(s)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0021", "language": "dafny", "source": "humaneval", "source_id": "humaneval_024_largest-divisor", "vc-description": "function_signature: def largest_divisor(n: int) -> int\nFor a given number n, find the largest number that divides n evenly, smaller than n", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method largest_divisor(n: int) returns (d : int)\n\n  requires n > 1\n\n  ensures 1 <= d < n\n  ensures n % d == 0\n  ensures forall k :: d < k < n ==> n % k != 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0022", "language": "dafny", "source": "humaneval", "source_id": "humaneval_025", "vc-description": "Given a positive integer n, return a list of its prime factors in ascending order. Each prime factor should appear in the list as many times as it divides n (i.e., according to its multiplicity in the prime factorization).", "vc-preamble": "predicate isPrime(n: int)\n{\n    n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nfunction product(factors: seq<int>): int\n{\n    if |factors| == 0 then 1\n    else factors[0] * product(factors[1..])\n}\n\npredicate isNonDecreasing(factors: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |factors| ==> factors[i] <= factors[j]\n}\nlemma ProductAppend(factors: seq<int>, x: int)\n    ensures product(factors + [x]) == product(factors) * x\n{\n    if |factors| == 0 {\n        assert factors + [x] == [x];\n        assert product([x]) == x * product([]) == x * 1 == x;\n        assert product(factors) * x == 1 * x == x;\n    } else {\n        assert (factors + [x])[0] == factors[0];\n        assert (factors + [x])[1..] == factors[1..] + [x];\n        ProductAppend(factors[1..], x);\n        assert product(factors[1..] + [x]) == product(factors[1..]) * x;\n        assert product(factors + [x]) == factors[0] * product(factors[1..] + [x]);\n        assert product(factors + [x]) == factors[0] * product(factors[1..]) * x;\n        assert product(factors + [x]) == product(factors) * x;\n    }\n}", "vc-helpers": "", "vc-spec": "method factorize(n: int) returns (factors: seq<int>)\n    ensures n <= 1 ==> |factors| == 0\n    ensures n > 1 ==> product(factors) == n\n    ensures forall i :: 0 <= i < |factors| ==> isPrime(factors[i])\n    ensures isNonDecreasing(factors)\n    ensures forall i :: 0 <= i < |factors| ==> factors[i] >= 2", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0023", "language": "dafny", "source": "humaneval", "source_id": "humaneval_026_remove_duplicates__count", "vc-description": "function_signature: method count(a: seq<int>, x: int) returns (cnt: int)\nCount occurrences. Ensures: returns the correct count; returns the correct count.", "vc-preamble": "function count_rec(a: seq<int>, x: int): int {\n  if |a| == 0 then 0\n  else count_rec(a[1..], x) + (if a[0] == x then 1 else 0)\n}", "vc-helpers": "", "vc-spec": "method count(a: seq<int>, x: int) returns (cnt: int)\n\n  ensures cnt == |set i | 0 <= i < |a| && a[i] == x|\n  ensures cnt == count_rec(a, x)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0024", "language": "dafny", "source": "humaneval", "source_id": "humaneval_026_remove_duplicates__remove_duplicates", "vc-description": "function_signature: method remove_duplicates(a: seq<int>) returns (result: seq<int>)\nProcess input. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values.", "vc-preamble": "function count_rec(a: seq<int>, x: int): int {\n  if |a| == 0 then 0\n  else count_rec(a[1..], x) + (if a[0] == x then 1 else 0)\n}", "vc-helpers": "", "vc-spec": "method remove_duplicates(a: seq<int>) returns (result: seq<int>)\n\n  requires forall i :: 0 <= i < |a| ==> count_rec(a, a[i]) >= 1\n\n  ensures forall i :: 0 <= i < |result| ==> count_rec(a, result[i]) == 1\n  ensures forall i :: 0 <= i < |a| ==> (a[i] in result <==> count_rec(a, a[i]) == 1)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0025", "language": "dafny", "source": "humaneval", "source_id": "humaneval_027", "vc-description": "This verification task involves implementing a string case-flipping function that converts all lowercase letters to uppercase and all uppercase letters to lowercase, while leaving non-alphabetic characters unchanged. The implementation should process each character in the input string and return a new string with the appropriate case transformations.", "vc-preamble": "\npredicate IsLowercase(c: char) {\n    'a' <= c <= 'z'\n}\n\npredicate IsUppercase(c: char) {\n    'A' <= c <= 'Z'\n}\n\nfunction FlipChar(c: char): char {\n    if IsLowercase(c) then c - 'a' + 'A'\n    else if IsUppercase(c) then c - 'A' + 'a'\n    else c\n}\n\npredicate ValidFlipCase(s: string, result: string) {\n    |result| == |s| &&\n    forall i :: 0 <= i < |s| ==> result[i] == FlipChar(s[i])\n}", "vc-helpers": "", "vc-spec": "method flip_case(s: string) returns (result: string)\n    ensures ValidFlipCase(s, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0026", "language": "dafny", "source": "humaneval", "source_id": "humaneval_028", "vc-description": "This task involves implementing string concatenation. Given a sequence of strings, return a single string that is the concatenation of all strings in the list in order. The implementation should match the behavior of a recursive specification function.", "vc-preamble": "\nfunction concat_strings(strings: seq<string>, index: nat): string\n    requires index <= |strings|\n    decreases |strings| - index\n{\n    if index == |strings| then \"\"\n    else strings[index] + concat_strings(strings, index + 1)\n}", "vc-helpers": "", "vc-spec": "method concatenate(strings: seq<string>) returns (result: string)\n    ensures result == concat_strings(strings, 0)\n    ensures |strings| == 0 ==> result == \"\"", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0027", "language": "dafny", "source": "humaneval", "source_id": "humaneval_029_filter_by_prefix", "vc-description": "function_signature: def filter_by_prefix(strings: List[str], prefix: str) -> List[str]\nFilter an input list of strings only for ones that start with a given prefix.", "vc-preamble": "function starts_with(s: string, p: string): bool {\n  |p| == 0 || (|s| != 0 && |s| >= |p| && s[0] == p[0] && starts_with(s[1..], p[1..]))\n}", "vc-helpers": "", "vc-spec": "method filter_by_prefix(xs: seq<string>, p: string) returns (filtered: seq<string>)\n\n  ensures forall i :: 0 <= i < |filtered| ==> starts_with(filtered[i], p)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0028", "language": "dafny", "source": "humaneval", "source_id": "humaneval_030", "vc-description": "This task implements a function to filter positive numbers from a list of integers. The function should return a new sequence containing only the positive numbers (greater than 0) while preserving their original order from the input sequence.", "vc-preamble": "\npredicate IsPositive(x: int)\n{\n    x > 0\n}\n\npredicate AllPositive(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> IsPositive(s[i])\n}\n\npredicate AllElementsFromOriginal(result: seq<int>, original: seq<int>)\n{\n    forall x :: x in result ==> x in original\n}\n\npredicate ContainsAllPositives(result: seq<int>, original: seq<int>)\n{\n    forall i :: 0 <= i < |original| && IsPositive(original[i]) ==> original[i] in result\n}\n\npredicate PreservesOrder(result: seq<int>, original: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |result| ==> \n        (exists k1, k2 :: (0 <= k1 < k2 < |original| && original[k1] == result[i] && original[k2] == result[j] &&\n        forall k :: k1 < k < k2 ==> !IsPositive(original[k])))\n}\n\nfunction CountPositives(s: seq<int>): int\n{\n    |set x | x in s && IsPositive(x)|\n}", "vc-helpers": "", "vc-spec": "method get_positive(l: seq<int>) returns (result: seq<int>)\n    ensures AllPositive(result)\n    ensures AllElementsFromOriginal(result, l)\n    ensures ContainsAllPositives(result, l)\n    ensures |result| == CountPositives(l)\n    ensures PreservesOrder(result, l)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0029", "language": "dafny", "source": "humaneval", "source_id": "humaneval_031", "vc-description": "This verification task involves implementing a method to determine if a positive integer is a prime number. A prime number is defined as a natural number greater than 1 that has exactly two distinct positive divisors: 1 and itself.\n\nThe implementation should efficiently check for primality by testing divisibility up to the square root of the input number, with optimizations for even numbers.", "vc-preamble": "\npredicate is_prime_number(n: int)\n{\n    n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "", "vc-spec": "method is_prime(n: int) returns (result: bool)\n    ensures result <==> is_prime_number(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0030", "language": "dafny", "source": "humaneval", "source_id": "humaneval_033_sort_third__SortSeqPred", "vc-description": "function_signature: method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; returns a sorted permutation of the input; the result is sorted according to the ordering relation.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n\n  requires |s| == |p|\n\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0031", "language": "dafny", "source": "humaneval", "source_id": "humaneval_033_sort_third__sort_third", "vc-description": "function_signature: method sort_third(a: seq<int>) returns (sorted_even: seq<int>)\nSort elements. Requires: requires size of asize of  > 0. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method sort_third(a: seq<int>) returns (sorted_even: seq<int>)\n\n  requires |a| > 0\n\n  ensures |sorted_even| == |a|\n  ensures forall i, j :: 0 <= i < j < |sorted_even| && i % 3 == 0 && j % 3 == 0 ==>\n      sorted_even[i] <= sorted_even[j]\n  ensures forall i :: 0 <= i < |a| && i % 3 != 0 ==> sorted_even[i] == a[i]\n  ensures multiset(a) == multiset(sorted_even)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0032", "language": "dafny", "source": "humaneval", "source_id": "humaneval_034_unique__SortSeq", "vc-description": "function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0033", "language": "dafny", "source": "humaneval", "source_id": "humaneval_034_unique__unique", "vc-description": "function_signature: method unique(s: seq<int>) returns (result: seq<int>)\nProcess input. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method unique(s: seq<int>) returns (result: seq<int>)\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0034", "language": "dafny", "source": "humaneval", "source_id": "humaneval_034_unique__uniqueSorted", "vc-description": "function_signature: method uniqueSorted(s: seq<int>) returns (result: seq<int>)\nSort elements. Requires: the condition holds for all values. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method uniqueSorted(s: seq<int>) returns (result: seq<int>)\n\n    requires forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures forall x :: x in result ==> x in s\n    ensures forall x :: x in s ==> x in result", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0035", "language": "dafny", "source": "humaneval", "source_id": "humaneval_035", "vc-description": "Find and return the maximum element in a given list of numbers. The list must be non-empty, and the maximum element is the largest value present in the list, which must be an actual element of the list.", "vc-preamble": "\npredicate ValidInput(l: seq<int>)\n{\n    |l| > 0\n}\n\npredicate IsMaxElement(l: seq<int>, max_val: int)\n{\n    max_val in l && forall i :: 0 <= i < |l| ==> l[i] <= max_val\n}\nfunction max_element_func(l: seq<int>): int\n    requires |l| > 0\n    ensures max_element_func(l) in l\n    ensures forall i :: 0 <= i < |l| ==> l[i] <= max_element_func(l)\n{\n    if |l| == 1 then l[0]\n    else\n        var rest_max := max_element_func(l[1..]);\n        if l[0] > rest_max then l[0] else rest_max\n}", "vc-helpers": "", "vc-spec": "method FindMaxElement(l: seq<int>) returns (max_val: int)\n    requires ValidInput(l)\n    ensures IsMaxElement(l, max_val)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0036", "language": "dafny", "source": "humaneval", "source_id": "humaneval_036_fizz_buzz__count7", "vc-description": "function_signature: method count7(x: nat) returns (count: nat)\nCount occurrences. Ensures: returns the correct value.", "vc-preamble": "function count7_r(x: nat): nat {\n  var lst := if x % 10 == 7 then 1 else 0;\n  if x < 10 then lst else lst + count7_r(x / 10)\n}\n\nfunction sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}", "vc-helpers": "", "vc-spec": "method count7(x: nat) returns (count: nat) \n\n  ensures count == count7_r(x)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0037", "language": "dafny", "source": "humaneval", "source_id": "humaneval_036_fizz_buzz__fizz_buzz", "vc-description": "function_signature: method fizz_buzz(n: nat) returns (result: nat)\nProcess input. Requires: returns the correct size/count. Ensures: returns the correct value.", "vc-preamble": "function count7_r(x: nat): nat {\n  var lst := if x % 10 == 7 then 1 else 0;\n  if x < 10 then lst else lst + count7_r(x / 10)\n}\n\nfunction sum(s: seq<int>) : int {\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}", "vc-helpers": "", "vc-spec": "method fizz_buzz(n: nat) returns (result: nat)\n\n  ensures result == sum(\n    seq(n, i requires 0 <= i < n => (if i % 11 == 0 || i % 13 == 0 then count7_r(i) else 0))\n  )", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0038", "language": "dafny", "source": "humaneval", "source_id": "humaneval_037_sort_even__SortSeqPred", "vc-description": "function_signature: method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\nSort elements. Requires: returns the correct size/count. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; returns a sorted permutation of the input; the result is sorted according to the ordering relation.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SortSeqPred(s: seq<int>, p: seq<bool>) returns (sorted: seq<int>)\n\n  requires |s| == |p|\n\n  ensures |sorted| == |s|\n  ensures forall i, j :: 0 <= i < j < |sorted| && p[i] && p[j] ==> sorted[i] <= sorted[j]\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| && !p[i] ==> sorted[i] == s[i]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0039", "language": "dafny", "source": "humaneval", "source_id": "humaneval_037_sort_even__sorted_even", "vc-description": "function_signature: method sorted_even(a: seq<int>) returns (sorted: seq<int>)\nSort elements. Requires: requires size of asize of  > 0. Ensures: returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method sorted_even(a: seq<int>) returns (sorted: seq<int>)\n\n  requires |a| > 0\n\n  ensures |sorted| == |a|\n  ensures forall i, j :: 0 <= i < j && 2 * i < |sorted| && 2 * j < |sorted| ==>\n      sorted[2 * i] <= sorted[2 * j]\n      ensures forall i :: 0 <= i < |a| && i % 2 == 1 ==> sorted[i] == a[i]\n      ensures multiset(a) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0040", "language": "dafny", "source": "humaneval", "source_id": "humaneval_038_encode_cyclic__decode_cyclic", "vc-description": "function_signature: method decode_cyclic(s: seq<int>) returns (res: seq<int>)\nDecode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method decode_cyclic(s: seq<int>) returns (res: seq<int>)\n\n    ensures |s| == |res|\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 2])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i - 1])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0041", "language": "dafny", "source": "humaneval", "source_id": "humaneval_038_encode_cyclic__encode_cyclic", "vc-description": "function_signature: method encode_cyclic(s: seq<int>) returns (res: seq<int>)\nEncode data. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method encode_cyclic(s: seq<int>) returns (res: seq<int>) \n\n    ensures |s| == |res|\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 0 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 1 ==> res[i] == s[i + 1])\n    ensures forall i :: 0 <= i < |s| - |s| % 3 ==> (i % 3 == 2 ==> res[i] == s[i - 2])\n    ensures forall i :: |s| - |s| % 3 <= i < |s| ==> (res[i] == s[i])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0042", "language": "dafny", "source": "humaneval", "source_id": "humaneval_040", "vc-description": "This verification task involves implementing a method to determine if there exist three distinct elements at different positions in a list of integers that sum to zero. The implementation should exhaustively check all possible combinations of three indices and return true if any triple sums to zero.", "vc-preamble": "\npredicate HasTripleSumToZero(l: seq<int>)\n{\n    exists i, j, k :: 0 <= i < j < k < |l| && l[i] + l[j] + l[k] == 0\n}", "vc-helpers": "", "vc-spec": "method triples_sum_to_zero(l: seq<int>) returns (result: bool)\n    ensures result == HasTripleSumToZero(l)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0043", "language": "dafny", "source": "humaneval", "source_id": "humaneval_041", "vc-description": "Given n cars moving left-to-right and n cars moving right-to-left on a straight infinite road, all at the same speed, calculate the total number of collisions. Cars pass through each other when they collide and continue moving. Each left-moving car will collide with each right-moving car exactly once, resulting in n * n total collisions.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 0\n}\n\nfunction CollisionCount(n: int): int\n    requires ValidInput(n)\n{\n    n * n\n}\n\npredicate ValidResult(n: int, result: int)\n    requires ValidInput(n)\n{\n    result == CollisionCount(n) && result >= 0\n}", "vc-helpers": "", "vc-spec": "method car_race_collision(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures ValidResult(n, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0044", "language": "dafny", "source": "humaneval", "source_id": "humaneval_042", "vc-description": "This task implements a function to increment each element in a list of integers by 1. Given a sequence of integers, the function should return a new sequence where each element is the corresponding element from the input sequence plus one.", "vc-preamble": "\npredicate ValidInput(l: seq<int>)\n{\n    true\n}\n\npredicate CorrectOutput(l: seq<int>, result: seq<int>)\n{\n    |result| == |l| && \n    forall i :: 0 <= i < |l| ==> result[i] == l[i] + 1\n}", "vc-helpers": "", "vc-spec": "method incr_list(l: seq<int>) returns (result: seq<int>)\n    requires ValidInput(l)\n    ensures CorrectOutput(l, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0045", "language": "dafny", "source": "humaneval", "source_id": "humaneval_043", "vc-description": "Given a list of integers, determine if there exist two distinct elements at different positions that sum to zero. This task requires implementing an efficient algorithm to check for the existence of such a pair.", "vc-preamble": "\npredicate HasPairSumToZero(l: seq<int>)\n{\n    exists i, j :: 0 <= i < j < |l| && l[i] + l[j] == 0\n}", "vc-helpers": "", "vc-spec": "method pairs_sum_to_zero(l: seq<int>) returns (result: bool)\n    ensures result == HasPairSumToZero(l)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0046", "language": "dafny", "source": "humaneval", "source_id": "humaneval_044", "vc-description": "This verification task implements a function to convert an integer from base 10 to a specified base (where base < 10) and return its string representation. The implementation should correctly handle the conversion process by repeatedly dividing by the target base to extract digits, then reversing the resulting digit sequence to produce the final string representation.", "vc-preamble": "\nfunction power_of_base(base: int, exp: int): int\n  requires base >= 2\n  requires exp >= 0\n  ensures power_of_base(base, exp) > 0\n{\n  if exp == 0 then 1 else base * power_of_base(base, exp - 1)\n}\n\nfunction digits_to_int(digits: seq<char>, base: int): int\n  requires base >= 2\n  requires forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base\n{\n  if |digits| == 0 then 0\n  else (digits[0] as int) - ('0' as int) + base * digits_to_int(digits[1..], base)\n}\n\nfunction string_to_int_in_base(s: string, base: int): int\n  requires base >= 2\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9' && (s[i] as int) - ('0' as int) < base\n  ensures string_to_int_in_base(s, base) >= 0\n{\n  if |s| == 1 then\n    (s[0] as int) - ('0' as int)\n  else\n    string_to_int_in_base(s[..|s|-1], base) * base + ((s[|s|-1] as int) - ('0' as int))\n}\nlemma digits_reversal_lemma(digits: seq<char>, reversed: seq<char>, base: int)\n  requires base >= 2\n  requires |digits| == |reversed| > 0\n  requires forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9' && (digits[i] as int) - ('0' as int) < base\n  requires forall i :: 0 <= i < |reversed| ==> reversed[i] == digits[|digits| - 1 - i]\n  ensures string_to_int_in_base(reversed, base) == digits_to_int(digits, base)\n{\n  if |digits| == 1 {\n    assert reversed[0] == digits[0];\n  } else {\n    var tail_digits := digits[1..];\n    var head_reversed := reversed[..|reversed|-1];\n\n    assert |tail_digits| == |head_reversed|;\n    assert forall i :: 0 <= i < |tail_digits| ==> head_reversed[i] == tail_digits[|tail_digits| - 1 - i];\n\n    digits_reversal_lemma(tail_digits, head_reversed, base);\n\n    assert string_to_int_in_base(reversed, base) == \n           string_to_int_in_base(head_reversed, base) * base + ((reversed[|reversed|-1] as int) - ('0' as int));\n    assert digits_to_int(digits, base) == \n           ((digits[0] as int) - ('0' as int)) + base * digits_to_int(tail_digits, base);\n    assert string_to_int_in_base(head_reversed, base) == digits_to_int(tail_digits, base);\n    assert reversed[|reversed|-1] == digits[0];\n  }\n}", "vc-helpers": "", "vc-spec": "method change_base(x: int, base: int) returns (result: string)\n  requires base >= 2 && base < 10\n  requires x >= 0\n  ensures x == 0 ==> result == \"0\"\n  ensures x > 0 ==> |result| > 0 && result[0] != '0'\n  ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9' && (result[i] as int) - ('0' as int) < base\n  ensures x > 0 ==> string_to_int_in_base(result, base) == x", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0047", "language": "dafny", "source": "humaneval", "source_id": "humaneval_045", "vc-description": "This task involves calculating the area of a triangle given the length of its base and height using the standard formula: Area = (base × height) ÷ 2. The implementation should handle non-negative inputs and ensure the result is also non-negative.", "vc-preamble": "\npredicate ValidInput(base: real, height: real)\n{\n    base >= 0.0 && height >= 0.0\n}\n\nfunction TriangleAreaFormula(base: real, height: real): real\n{\n    (base * height) / 2.0\n}\nfunction triangle_area(a: real, h: real): real\n    requires a >= 0.0\n    requires h >= 0.0\n    ensures triangle_area(a, h) >= 0.0\n    ensures triangle_area(a, h) == (a * h) / 2.0\n    ensures (a == 0.0 || h == 0.0) ==> triangle_area(a, h) == 0.0\n{\n    (a * h) / 2.0\n}", "vc-helpers": "", "vc-spec": "method CalculateTriangleArea(base: real, height: real) returns (area: real)\n    requires ValidInput(base, height)\n    ensures area >= 0.0\n    ensures area == TriangleAreaFormula(base, height)\n    ensures (base == 0.0 || height == 0.0) ==> area == 0.0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0048", "language": "dafny", "source": "humaneval", "source_id": "humaneval_046", "vc-description": "This task implements an iterative solution to compute the n-th element of the Fib4 sequence. The Fib4 sequence is defined with base cases fib4(0)=0, fib4(1)=0, fib4(2)=2, fib4(3)=0, and for n≥4, fib4(n) = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n\nThe implementation must be iterative and efficient, using a sliding window approach to maintain the last 4 values instead of recursion, while proving equivalence to the recursive specification.", "vc-preamble": "\nfunction fib4_func(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0\n    else if n == 1 then 0\n    else if n == 2 then 2\n    else if n == 3 then 0\n    else fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4)\n}", "vc-helpers": "", "vc-spec": "method fib4(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == fib4_func(n)\n    ensures n == 0 ==> result == 0\n    ensures n == 1 ==> result == 0\n    ensures n == 2 ==> result == 2\n    ensures n == 3 ==> result == 0\n    ensures n >= 4 ==> result == fib4_func(n-1) + fib4_func(n-2) + fib4_func(n-3) + fib4_func(n-4)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0049", "language": "dafny", "source": "humaneval", "source_id": "humaneval_047", "vc-description": "This verification task implements a median function for a sequence of real numbers. For odd-length lists, it returns the middle element after sorting. For even-length lists, it returns the average of the two middle elements after sorting.\n\nThe implementation uses helper functions for insertion sort and includes comprehensive specifications to ensure the sorted list preserves the original multiset and maintains proper ordering.", "vc-preamble": "\nfunction InsertSorted(x: real, sorted: seq<real>): seq<real>\n{\n    if |sorted| == 0 then [x]\n    else if x <= sorted[0] then [x] + sorted\n    else [sorted[0]] + InsertSorted(x, sorted[1..])\n}\n\nfunction Sort(s: seq<real>): seq<real>\n{\n    if |s| == 0 then []\n    else InsertSorted(s[0], Sort(s[1..]))\n}\n\npredicate IsSorted(s: seq<real>) {\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction Multiset(s: seq<real>): multiset<real> {\n    if |s| == 0 then multiset{}\n    else multiset{s[0]} + Multiset(s[1..])\n}\n\npredicate ValidInput(l: seq<real>) {\n    |l| > 0\n}\n\nfunction MedianValue(l: seq<real>): real\n    requires ValidInput(l)\n{\n    var sorted_list := Sort(l);\n    var n := |sorted_list|;\n    if n % 2 == 1 then\n        sorted_list[n / 2]\n    else\n        (sorted_list[n / 2 - 1] + sorted_list[n / 2]) / 2.0\n}\nlemma InsertSortedPreservesOrder(x: real, sorted: seq<real>)\n    requires IsSorted(sorted)\n    ensures IsSorted(InsertSorted(x, sorted))\n{\n    if |sorted| == 0 {\n    } else if x <= sorted[0] {\n    } else {\n        InsertSortedPreservesOrder(x, sorted[1..]);\n        var result := InsertSorted(x, sorted[1..]);\n        assert IsSorted(result);\n        if |result| > 0 {\n            assert sorted[0] <= result[0];\n        }\n        assert IsSorted([sorted[0]] + result);\n    }\n}\n\nlemma SortProducesOrder(s: seq<real>)\n    ensures IsSorted(Sort(s))\n{\n    if |s| == 0 {\n    } else {\n        SortProducesOrder(s[1..]);\n        InsertSortedPreservesOrder(s[0], Sort(s[1..]));\n    }\n}\n\nlemma InsertSortedPreservesMultiset(x: real, sorted: seq<real>)\n    ensures Multiset(InsertSorted(x, sorted)) == multiset{x} + Multiset(sorted)\n{\n    if |sorted| == 0 {\n    } else if x <= sorted[0] {\n    } else {\n        InsertSortedPreservesMultiset(x, sorted[1..]);\n    }\n}\n\nlemma SortPreservesMultiset(s: seq<real>)\n    ensures Multiset(Sort(s)) == Multiset(s)\n{\n    if |s| == 0 {\n    } else {\n        SortPreservesMultiset(s[1..]);\n        InsertSortedPreservesMultiset(s[0], Sort(s[1..]));\n    }\n}", "vc-helpers": "", "vc-spec": "method median(l: seq<real>) returns (result: real)\n    requires ValidInput(l)\n    ensures result == MedianValue(l)\n    ensures var sorted_list := Sort(l);\n            var n := |sorted_list|;\n            n % 2 == 1 ==> result == sorted_list[n / 2]\n    ensures var sorted_list := Sort(l);\n            var n := |sorted_list|;\n            n % 2 == 0 ==> result == (sorted_list[n / 2 - 1] + sorted_list[n / 2]) / 2.0\n    ensures IsSorted(Sort(l))\n    ensures Multiset(Sort(l)) == Multiset(l)\n    ensures |l| == 1 ==> result == l[0]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0050", "language": "dafny", "source": "humaneval", "source_id": "humaneval_048", "vc-description": "Determine if a given string is a palindrome (reads the same forwards and backwards). The comparison should be case-insensitive, requiring implementation of a case conversion function and a palindrome checking predicate.", "vc-preamble": "\nfunction to_lower(c: char): char\n{\n    if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}\n\npredicate IsPalindrome(text: string)\n{\n    forall i :: 0 <= i < |text| ==> to_lower(text[i]) == to_lower(text[|text| - 1 - i])\n}", "vc-helpers": "", "vc-spec": "method is_palindrome(text: string) returns (result: bool)\n  ensures result <==> IsPalindrome(text)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0051", "language": "dafny", "source": "humaneval", "source_id": "humaneval_049", "vc-description": "This verification task involves implementing efficient modular exponentiation to compute 2^n mod p. The method should use binary exponentiation (repeated squaring) for optimal O(log n) time complexity, maintaining appropriate loop invariants to prove correctness.", "vc-preamble": "\nfunction power(base: int, exp: nat): int\n{\n    if exp == 0 then 1\n    else base * power(base, exp - 1)\n}", "vc-helpers": "", "vc-spec": "method modp(n: int, p: int) returns (result: int)\n    requires n >= 0 && p > 0\n    ensures result >= 0 && result < p\n    ensures result == power(2, n) % p", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0052", "language": "dafny", "source": "humaneval", "source_id": "humaneval_050_encode_shift__decode_shift", "vc-description": "function_signature: method decode_shift(s: string) returns (t: string)\nDecode data. Requires: the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values.", "vc-preamble": "function encode_char(c: char): char\n\n  requires 'a' <= c <= 'z'\n\n  ensures 'a' <= encode_char(c) <= 'z'\n\n{\n\n  ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n\n}\nfunction decode_char(c: char): char\n\n  requires 'a' <= c <= 'z'\n\n  ensures 'a' <= decode_char(c) <= 'z'\n  ensures encode_char(decode_char(c)) == c\n\n{\n\n  ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n\n}", "vc-helpers": "", "vc-spec": "method decode_shift(s: string) returns (t: string)\n\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == decode_char(s[i])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0053", "language": "dafny", "source": "humaneval", "source_id": "humaneval_050_encode_shift__encode_shift", "vc-description": "function_signature: method encode_shift(s: string) returns (t: string)\nEncode data. Requires: the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values.", "vc-preamble": "function encode_char(c: char): char\n\n  requires 'a' <= c <= 'z'\n\n  ensures 'a' <= encode_char(c) <= 'z'\n\n{\n\n  ((c as int - 'a' as int + 5) % 26 + 'a' as int) as char\n\n}\nfunction decode_char(c: char): char\n\n  requires 'a' <= c <= 'z'\n\n  ensures 'a' <= decode_char(c) <= 'z'\n  ensures encode_char(decode_char(c)) == c\n\n{\n\n  ((c as int - 'a' as int - 5) % 26 + 'a' as int) as char\n\n}", "vc-helpers": "", "vc-spec": "method encode_shift(s: string) returns (t: string)\n\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n\n  ensures |s| == |t|\n  ensures forall i :: 0 <= i < |s| ==> t[i] == encode_char(s[i])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0054", "language": "dafny", "source": "humaneval", "source_id": "humaneval_051", "vc-description": "This verification task involves removing all vowels (both lowercase and uppercase) from a given string and returning the resulting string. Vowels are defined as the characters: a, e, i, o, u, A, E, I, O, U. The implementation must preserve the order of non-vowel characters and ensure the result contains only characters from the original string that are not vowels.", "vc-preamble": "\npredicate IsVowel(c: char) {\n    c in {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n}\n\npredicate ValidResult(text: string, result: string) {\n    && |result| <= |text|\n    && (forall i :: 0 <= i < |result| ==> !IsVowel(result[i]))\n    && (forall i, j :: 0 <= i < j < |result| ==> \n        (exists k, l :: (0 <= k < l < |text| && text[k] == result[i] && text[l] == result[j] &&\n        !IsVowel(text[k]) && !IsVowel(text[l]))))\n    && ((forall i :: 0 <= i < |text| ==> IsVowel(text[i])) ==> result == \"\")\n    && (forall i :: 0 <= i < |text| && !IsVowel(text[i]) ==> text[i] in result)\n    && (forall c :: c in result ==> c in text && !IsVowel(c))\n}", "vc-helpers": "", "vc-spec": "method remove_vowels(text: string) returns (result: string)\n    ensures ValidResult(text, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0055", "language": "dafny", "source": "humaneval", "source_id": "humaneval_052", "vc-description": "This verification task implements a method to check if all integers in a given list are strictly less than a specified threshold value. The method should return true if and only if every element in the sequence satisfies the threshold condition.", "vc-preamble": "\npredicate BelowThreshold(l: seq<int>, t: int)\n{\n    forall i :: 0 <= i < |l| ==> l[i] < t\n}", "vc-helpers": "", "vc-spec": "method CheckBelowThreshold(l: seq<int>, t: int) returns (result: bool)\n    ensures result == BelowThreshold(l, t)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0056", "language": "dafny", "source": "humaneval", "source_id": "humaneval_053", "vc-description": "This verification task implements a simple addition function that takes two integers as input and returns their sum. The implementation should correctly add the two input integers and satisfy the postcondition that the result equals the mathematical sum of the inputs.", "vc-preamble": "\npredicate ValidInput(x: int, y: int)\n{\n    true\n}\n\nfunction CorrectSum(x: int, y: int): int\n{\n    x + y\n}", "vc-helpers": "", "vc-spec": "method add(x: int, y: int) returns (result: int)\n    requires ValidInput(x, y)\n    ensures result == CorrectSum(x, y)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0057", "language": "dafny", "source": "humaneval", "source_id": "humaneval_054", "vc-description": "This task involves determining if two strings contain exactly the same set of unique characters, regardless of character frequency or order. The implementation should compare the set of characters in each string and return true if they are identical sets.", "vc-preamble": "\nfunction CharSet(s: string): set<char>\n{\n    set c | c in s\n}", "vc-helpers": "", "vc-spec": "method same_chars(s0: string, s1: string) returns (result: bool)\n    ensures result == (CharSet(s0) == CharSet(s1))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0058", "language": "dafny", "source": "humaneval", "source_id": "humaneval_055", "vc-description": "This task involves computing the n-th Fibonacci number using 1-based indexing, where fib(1) = 1 and fib(2) = 1. The implementation should efficiently calculate the result for positive integers n.\n\nThe solution uses an iterative approach with loop invariants to maintain correctness while avoiding the exponential time complexity of a naive recursive implementation.", "vc-preamble": "\npredicate ValidInput(n: int) {\n    n > 0\n}\n\nfunction fib_spec(n: int): int\n    requires n > 0\n{\n    if n == 1 then 1\n    else if n == 2 then 1\n    else fib_spec(n-1) + fib_spec(n-2)\n}", "vc-helpers": "", "vc-spec": "method fib(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == fib_spec(n)\n    ensures result > 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0059", "language": "dafny", "source": "humaneval", "source_id": "humaneval_056", "vc-description": "This verification task implements a bracket matching algorithm that determines if a string containing only \"<\" and \">\" characters has properly nested brackets. Every opening bracket \"<\" must have a corresponding closing bracket \">\" and they must be correctly nested, meaning at no point should the number of closing brackets exceed the number of opening brackets in any prefix.", "vc-preamble": "\nfunction count_brackets_prefix(s: string, end: int, bracket: char): int\n    requires 0 <= end <= |s|\n    requires bracket == '<' || bracket == '>'\n{\n    if end == 0 then 0\n    else if s[end-1] == bracket then 1 + count_brackets_prefix(s, end-1, bracket)\n    else count_brackets_prefix(s, end-1, bracket)\n}\n\npredicate ValidBracketString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '<' || s[i] == '>'\n}\n\npredicate ProperlyNested(brackets: string)\n    requires ValidBracketString(brackets)\n{\n    (forall k :: 0 <= k <= |brackets| ==> \n        count_brackets_prefix(brackets, k, '<') >= count_brackets_prefix(brackets, k, '>')) &&\n    count_brackets_prefix(brackets, |brackets|, '<') == count_brackets_prefix(brackets, |brackets|, '>')\n}", "vc-helpers": "", "vc-spec": "method correct_bracketing(brackets: string) returns (result: bool)\n    requires ValidBracketString(brackets)\n    ensures result <==> ProperlyNested(brackets)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0060", "language": "dafny", "source": "humaneval", "source_id": "humaneval_057", "vc-description": "This verification task implements a function to determine if a list of numbers is monotonic. A list is monotonic if it is either entirely non-decreasing (monotonically increasing) or entirely non-increasing (monotonically decreasing). Empty lists and single-element lists are considered monotonic, and lists with equal consecutive elements are allowed.", "vc-preamble": "\nfunction monotonic(l: seq<int>): bool\n    ensures |l| <= 1 ==> monotonic(l) == true\n    ensures |l| > 1 ==> (monotonic(l) == (\n        (forall i :: 0 <= i < |l| - 1 ==> l[i] <= l[i + 1]) ||\n        (forall i :: 0 <= i < |l| - 1 ==> l[i] >= l[i + 1])\n    ))\n{\n    if |l| <= 1 then true\n    else\n        var increasing := forall i :: 0 <= i < |l| - 1 ==> l[i] <= l[i + 1];\n        var decreasing := forall i :: 0 <= i < |l| - 1 ==> l[i] >= l[i + 1];\n        increasing || decreasing\n}", "vc-helpers": "", "vc-spec": "method IsMonotonic(l: seq<int>) returns (result: bool)\n    ensures result == monotonic(l)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0061", "language": "dafny", "source": "humaneval", "source_id": "humaneval_058_common", "vc-description": "function_signature: def common(l1: List[Int], l2: List[Int]) -> List[Int]\nReturn sorted unique common elements for two lists.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method common(l1 : seq<int>, l2 : seq<int>) returns (c : set<int>)\n\n    ensures forall i :: i in c ==> i in l1 && i in l2\n    ensures forall i :: i in l1 && i in l2 ==> i in c", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0062", "language": "dafny", "source": "humaneval", "source_id": "humaneval_059", "vc-description": "This verification task implements an algorithm to find the largest prime factor of a composite integer n (where n > 1 and n is not prime). The algorithm uses trial division, first removing all factors of 2, then checking odd factors up to the square root of the remaining number.\n\nThe implementation must ensure that the returned result is indeed a prime number, divides n, and is the largest such prime factor among all factors of n.", "vc-preamble": "\npredicate is_prime(n: int)\n{\n    n > 1 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nfunction power_of_2_factor(n: int, current: int): int\n    requires n > 0 && current > 0\n    decreases current\n{\n    if current % 2 != 0 then 1\n    else 2 * power_of_2_factor(n, current / 2)\n}", "vc-helpers": "", "vc-spec": "method largest_prime_factor(n: int) returns (result: int)\n    requires n > 1\n    requires !is_prime(n)\n    ensures result > 1\n    ensures n % result == 0\n    ensures forall k :: k > result && n % k == 0 ==> !is_prime(k)\n    ensures is_prime(result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0063", "language": "dafny", "source": "humaneval", "source_id": "humaneval_060", "vc-description": "This verification task implements the computation of the sum of all integers from 1 to n inclusive, where n is a positive integer. The expected implementation should use the well-known mathematical formula n*(n+1)/2 for efficiency.", "vc-preamble": "\npredicate ValidInput(n: int)\n{\n    n >= 1\n}\n\nfunction SumFromOneToN(n: int): int\n    requires n >= 1\n{\n    n * (n + 1) / 2\n}", "vc-helpers": "", "vc-spec": "method sum_to_n(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == SumFromOneToN(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0064", "language": "dafny", "source": "humaneval", "source_id": "humaneval_062", "vc-description": "This task involves computing the derivative of a polynomial given its coefficients. Given a sequence of coefficients where xs[i] represents the coefficient of x^i, the method should return the derivative coefficients where [a₀, a₁, a₂, ...] becomes [a₁, 2a₂, 3a₃, ...].", "vc-preamble": "\npredicate ValidInput(xs: seq<int>)\n{\n    true  // Any sequence of coefficients is valid input\n}\n\nfunction DerivativeLength(xs: seq<int>): nat\n{\n    if |xs| <= 1 then 0 else |xs| - 1\n}\n\npredicate CorrectDerivativeCoefficients(xs: seq<int>, result: seq<int>)\n{\n    (|xs| <= 1 ==> result == []) &&\n    (|xs| > 1 ==> (|result| == |xs| - 1 && \n                  (forall j :: 0 <= j < |result| ==> result[j] == (j + 1) * xs[j + 1])))\n}", "vc-helpers": "", "vc-spec": "method derivative(xs: seq<int>) returns (result: seq<int>)\n    requires ValidInput(xs)\n    ensures CorrectDerivativeCoefficients(xs, result)\n    ensures |result| == DerivativeLength(xs)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0065", "language": "dafny", "source": "humaneval", "source_id": "humaneval_063", "vc-description": "This verification task involves implementing the FibFib sequence, which is a modified Fibonacci sequence. The FibFib sequence is defined with base cases fibfib(0) = 0, fibfib(1) = 0, fibfib(2) = 1, and for n >= 3, fibfib(n) = fibfib(n-1) + fibfib(n-2) + fibfib(n-3). The expected implementation should efficiently compute the n-th element using dynamic programming rather than naive recursion.", "vc-preamble": "\nfunction fibfib_spec(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 0\n    else if n == 1 then 0\n    else if n == 2 then 1\n    else fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3)\n}", "vc-helpers": "", "vc-spec": "method fibfib(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == fibfib_spec(n)\n    ensures n == 0 ==> result == 0\n    ensures n == 1 ==> result == 0\n    ensures n == 2 ==> result == 1\n    ensures n >= 3 ==> result == fibfib_spec(n-1) + fibfib_spec(n-2) + fibfib_spec(n-3)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0066", "language": "dafny", "source": "humaneval", "source_id": "humaneval_064_vowels_count", "vc-description": "function_signature: def remove_vowels(string: str) -> Nat\nWrite a function vowels_count which takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a vowel, but only when it is at the end of the given word.", "vc-preamble": "function is_vowel(c: char): bool\n  ensures is_vowel(c) <==> c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n{\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}", "vc-helpers": "", "vc-spec": "method vowel_count(s: string) returns (count: int)\n\n  ensures count >= 0\n  ensures count == |(set i | 0 <= i < |s| && is_vowel(s[i]))| + if |s| > 0 && s[|s| - 1] == 'y' then 1 else 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0067", "language": "dafny", "source": "humaneval", "source_id": "humaneval_065", "vc-description": "This verification task implements a circular right shift operation on the digits of an integer. Given an integer x and a shift amount, the method performs a circular right shift on the digits of x and returns the result as a string. A circular right shift moves digits from the end to the beginning. If the shift amount exceeds the number of digits in x, the method returns the digits of x in reversed order instead.", "vc-preamble": "\nfunction intToString(x: int): string\n    requires x >= 0\n    ensures |intToString(x)| >= 1\n    ensures forall i :: 0 <= i < |intToString(x)| ==> '0' <= intToString(x)[i] <= '9'\n{\n    if x == 0 then \"0\"\n    else intToStringHelper(x, \"\")\n}\n\nfunction intToStringHelper(x: int, acc: string): string\n    requires x >= 0\n    requires forall i :: 0 <= i < |acc| ==> '0' <= acc[i] <= '9'\n    ensures forall i :: 0 <= i < |intToStringHelper(x, acc)| ==> '0' <= intToStringHelper(x, acc)[i] <= '9'\n    ensures x > 0 ==> |intToStringHelper(x, acc)| > |acc|\n{\n    if x == 0 then acc\n    else intToStringHelper(x / 10, [((x % 10) + '0' as int) as char] + acc)\n}\n\nfunction reverseString(s: string): string\n    ensures |reverseString(s)| == |s|\n    ensures forall i :: 0 <= i < |s| ==> reverseString(s)[i] == s[|s| - 1 - i]\n{\n    if |s| <= 1 then s\n    else reverseString(s[1..]) + [s[0]]\n}", "vc-helpers": "", "vc-spec": "method circular_shift(x: int, shift: int) returns (result: string)\n    ensures |result| == |intToString(if x < 0 then -x else x)|\n    ensures shift > |intToString(if x < 0 then -x else x)| ==> \n            result == reverseString(intToString(if x < 0 then -x else x))\n    ensures shift <= |intToString(if x < 0 then -x else x)| && |intToString(if x < 0 then -x else x)| > 0 ==>\n            (var digits := intToString(if x < 0 then -x else x);\n             var n := |digits|;\n             var normalizedShift := shift % n;\n             normalizedShift == 0 ==> result == digits)\n    ensures shift <= |intToString(if x < 0 then -x else x)| && |intToString(if x < 0 then -x else x)| > 0 ==>\n            (var digits := intToString(if x < 0 then -x else x);\n             var n := |digits|;\n             var normalizedShift := shift % n;\n             normalizedShift > 0 ==> result == digits[n - normalizedShift..] + digits[..n - normalizedShift])\n    ensures forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0068", "language": "dafny", "source": "humaneval", "source_id": "humaneval_066", "vc-description": "This task involves calculating the sum of ASCII values of all uppercase letters in a string. The function should return 0 for empty strings and only consider characters from 'A' to 'Z' as uppercase. The implementation needs to be verified with an iterative method that maintains proper loop invariants.", "vc-preamble": "\nfunction sumOfUppercaseASCII(s: string): int\n    ensures sumOfUppercaseASCII(s) >= 0\n{\n    if |s| == 0 then 0\n    else \n        var c := s[0];\n        var rest := sumOfUppercaseASCII(s[1..]);\n        if 'A' <= c && c <= 'Z' then (c as int) + rest\n        else rest\n}\nlemma sumOfUppercaseASCII_lemma(s: string, c: char)\n    ensures sumOfUppercaseASCII(s + [c]) == \n            if 'A' <= c && c <= 'Z' then sumOfUppercaseASCII(s) + (c as int)\n            else sumOfUppercaseASCII(s)\n{\n    if |s| == 0 {\n        assert s + [c] == [c];\n        assert sumOfUppercaseASCII([c]) == (if 'A' <= c && c <= 'Z' then (c as int) else 0);\n        assert sumOfUppercaseASCII(s) == 0;\n    } else {\n        assert (s + [c])[0] == s[0];\n        assert (s + [c])[1..] == s[1..] + [c];\n        sumOfUppercaseASCII_lemma(s[1..], c);\n    }\n}", "vc-helpers": "", "vc-spec": "method digitSum(s: string) returns (result: int)\n    ensures result >= 0\n    ensures result == sumOfUppercaseASCII(s)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0069", "language": "dafny", "source": "humaneval", "source_id": "humaneval_067", "vc-description": "Given a string containing quantities of apples and oranges and the total number of fruits, calculate the number of mangoes. The basket contains only apples, oranges, and mangoes. The implementation must extract numbers from the input string, sum them up, and subtract from the total to find the number of mangoes.", "vc-preamble": "\npredicate ValidInput(n: int) {\n    n >= 0\n}\n\nfunction sum_of_numbers_in_string(s: string): int\n{\n    var numbers := extract_numbers_from_string(s);\n    sum_sequence(numbers)\n}\n\nfunction extract_numbers_from_string(s: string): seq<int>\n{\n    extract_numbers_helper(s, 0, 0, false, [])\n}\n\nfunction sum_sequence(numbers: seq<int>): int\n{\n    if |numbers| == 0 then 0\n    else numbers[0] + sum_sequence(numbers[1..])\n}\nfunction extract_numbers_helper(s: string, i: int, current_number: int, in_number: bool, numbers: seq<int>): seq<int>\n    decreases |s| - i\n    requires 0 <= i <= |s|\n    requires current_number >= 0\n{\n    if i == |s| then\n        if in_number then numbers + [current_number] else numbers\n    else\n        var c := s[i];\n        if '0' <= c <= '9' then\n            var digit := c as int - '0' as int;\n            extract_numbers_helper(s, i + 1, current_number * 10 + digit, true, numbers)\n        else\n            if in_number then\n                extract_numbers_helper(s, i + 1, 0, false, numbers + [current_number])\n            else\n                extract_numbers_helper(s, i + 1, 0, false, numbers)\n}\n\nmethod extract_numbers_from_string_imperative(s: string) returns (numbers: seq<int>)\n    ensures numbers == extract_numbers_from_string(s)\n{\n    numbers := [];\n    var current_number := 0;\n    var in_number := false;\n    var i := 0;\n\n    while i < |s|\n        invariant 0 <= i <= |s|\n        invariant current_number >= 0\n        invariant !in_number ==> current_number == 0\n        invariant extract_numbers_helper(s, i, current_number, in_number, numbers) == extract_numbers_from_string(s)\n    {\n        var c := s[i];\n        if '0' <= c <= '9' {\n            var digit := c as int - '0' as int;\n            current_number := current_number * 10 + digit;\n            in_number := true;\n        } else {\n            if in_number {\n                numbers := numbers + [current_number];\n                current_number := 0;\n                in_number := false;\n            }\n        }\n        i := i + 1;\n    }\n\n    if in_number {\n        numbers := numbers + [current_number];\n    }\n\n    assert numbers == extract_numbers_from_string(s);\n}", "vc-helpers": "", "vc-spec": "method fruit_distribution(s: string, n: int) returns (mangoes: int)\n    requires ValidInput(n)\n    ensures mangoes == n - sum_of_numbers_in_string(s)\n    ensures mangoes >= 0 <==> n >= sum_of_numbers_in_string(s)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0070", "language": "dafny", "source": "humaneval", "source_id": "humaneval_068", "vc-description": "This verification task implements a function that finds the smallest even value in an array of non-negative integers and returns it along with its index. If multiple occurrences of the same smallest even value exist, it should return the one with the smallest index. If no even values exist or the array is empty, it returns an empty list.\n\nThe implementation must correctly handle edge cases and maintain loop invariants to prove that the returned result satisfies all the postconditions, including finding the true minimum even value and the earliest index for that value.", "vc-preamble": "\npredicate ValidInput(arr: seq<int>)\n{\n    forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n}\n\npredicate HasEvenValue(arr: seq<int>)\n{\n    exists i :: 0 <= i < |arr| && arr[i] % 2 == 0\n}\n\nfunction SmallestEvenValue(arr: seq<int>): int\n    requires HasEvenValue(arr)\n{\n    SmallestEvenValueHelper(arr, 0, -1)\n}\n\nfunction SmallestEvenValueHelper(arr: seq<int>, index: int, current_min: int): int\n    requires 0 <= index <= |arr|\n    decreases |arr| - index\n{\n    if index >= |arr| then current_min\n    else if arr[index] % 2 == 0 then\n        if current_min == -1 || arr[index] < current_min then\n            SmallestEvenValueHelper(arr, index + 1, arr[index])\n        else\n            SmallestEvenValueHelper(arr, index + 1, current_min)\n    else\n        SmallestEvenValueHelper(arr, index + 1, current_min)\n}\n\nfunction FirstIndexOfValue(arr: seq<int>, value: int): int\n    requires exists i :: 0 <= i < |arr| && arr[i] == value\n    decreases |arr|\n{\n    if |arr| > 0 && arr[0] == value then 0\n    else 1 + FirstIndexOfValue(arr[1..], value)\n}", "vc-helpers": "", "vc-spec": "method pluck(arr: seq<int>) returns (result: seq<int>)\n    requires ValidInput(arr)\n    ensures |arr| == 0 ==> |result| == 0\n    ensures !HasEvenValue(arr) ==> |result| == 0\n    ensures HasEvenValue(arr) ==> |result| == 2\n    ensures |result| == 2 ==> 0 <= result[1] < |arr|\n    ensures |result| == 2 ==> arr[result[1]] == result[0]\n    ensures |result| == 2 ==> result[0] % 2 == 0\n    ensures |result| == 2 ==> forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 ==> result[0] <= arr[i]\n    ensures |result| == 2 ==> forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 && arr[i] == result[0] ==> result[1] <= i", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0071", "language": "dafny", "source": "humaneval", "source_id": "humaneval_069", "vc-description": "This verification task involves finding the greatest integer in a list whose frequency is greater than or equal to its own value. Given a non-empty list of positive integers, the implementation should return this greatest qualifying integer, or -1 if no such integer exists.\n\nThe task requires building a frequency map for all elements in the list, then identifying which elements have frequencies meeting the criteria, and finally selecting the maximum among those valid elements.", "vc-preamble": "\nfunction count(s: seq<int>, x: int): int\n{\n    |set i | 0 <= i < |s| && s[i] == x|\n}\n\nfunction max_seq(s: seq<int>): int\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> s[i] <= max_seq(s)\n    ensures max_seq(s) in s\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= max_seq(s[1..]) then s[0]\n    else max_seq(s[1..])\n}\n\npredicate ValidInput(lst: seq<int>)\n{\n    |lst| > 0 && forall i :: 0 <= i < |lst| ==> lst[i] > 0\n}\n\npredicate ValidResult(lst: seq<int>, result: int)\n    requires ValidInput(lst)\n{\n    var frequency := map x | x in lst :: x := count(lst, x);\n    if result == -1 then\n        forall x :: x in frequency ==> frequency[x] < x\n    else\n        result > 0 &&\n        result in frequency && \n        frequency[result] >= result &&\n        forall y :: y in frequency && frequency[y] >= y ==> y <= result\n}\nlemma count_append_lemma(s: seq<int>, elem: int, x: int)\n    ensures count(s + [elem], x) == count(s, x) + (if x == elem then 1 else 0)\n{\n    var s' := s + [elem];\n    var original_indices := set i | 0 <= i < |s| && s[i] == x;\n    var new_indices := set i | 0 <= i < |s'| && s'[i] == x;\n\n    assert forall i :: 0 <= i < |s| ==> s'[i] == s[i];\n    assert original_indices == set i | 0 <= i < |s| && s'[i] == x;\n\n    if x == elem {\n        assert s'[|s|] == elem == x;\n        assert new_indices == original_indices + {|s|};\n        assert |s| !in original_indices;\n        assert |new_indices| == |original_indices| + 1;\n    } else {\n        assert s'[|s|] == elem != x;\n        assert new_indices == original_indices;\n        assert |new_indices| == |original_indices|;\n    }\n}", "vc-helpers": "", "vc-spec": "method search(lst: seq<int>) returns (result: int)\n    requires ValidInput(lst)\n    ensures ValidResult(lst, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0072", "language": "dafny", "source": "humaneval", "source_id": "humaneval_070_strange_sort_list__strange_sort_list_helper", "vc-description": "function_signature: method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\nSort elements. Ensures: returns a sorted permutation of the input; returns the correct size/count; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method strange_sort_list_helper(s: seq<int>) returns (sorted: seq<int>, strange: seq<int>)\n\n    ensures multiset(s) == multiset(sorted)\n    ensures |s| == |sorted| == |strange|\n    ensures forall i :: 0 <= i < |s| && i % 2 == 0 ==> strange[i] == sorted[i / 2]\n    ensures forall i :: 0 <= i < |s| && i % 2 == 1 ==> strange[i] == sorted[|s| - (i - 1) / 2 - 1]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0073", "language": "dafny", "source": "humaneval", "source_id": "humaneval_072", "vc-description": "This task determines if an object will fly based on two conditions: the given list of numbers must be palindromic, and the sum of all elements must be within a specified weight limit. The implementation needs to check both conditions and return true only if both are satisfied.", "vc-preamble": "\npredicate is_palindrome(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nfunction sum_elements(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + sum_elements(s[1..])\n}", "vc-helpers": "", "vc-spec": "method will_it_fly(q: seq<int>, w: int) returns (result: bool)\n    ensures result == (is_palindrome(q) && sum_elements(q) <= w)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0074", "language": "dafny", "source": "humaneval", "source_id": "humaneval_073", "vc-description": "This verification task involves finding the minimum number of elements that must be changed to make an array palindromic. A palindromic array reads the same forwards and backwards. The solution should count the number of mismatched pairs between corresponding positions from the start and end of the array.", "vc-preamble": "\nfunction count_mismatched_pairs(arr: seq<int>): int\n{\n    count_mismatched_pairs_up_to(arr, |arr| / 2)\n}\n\nfunction count_mismatched_pairs_up_to(arr: seq<int>, limit: int): int\n    requires 0 <= limit <= |arr| / 2\n{\n    if limit == 0 then 0\n    else \n        (if arr[limit-1] != arr[|arr| - limit] then 1 else 0) + \n        count_mismatched_pairs_up_to(arr, limit - 1)\n}\n\npredicate can_make_palindromic_with_changes(arr: seq<int>, num_changes: int)\n{\n    num_changes >= 0 && num_changes >= count_mismatched_pairs(arr)\n}", "vc-helpers": "", "vc-spec": "method smallest_change(arr: seq<int>) returns (changes: int)\n    ensures changes >= 0\n    ensures changes <= |arr| / 2\n    ensures changes == count_mismatched_pairs(arr)\n    ensures (|arr| <= 1) ==> (changes == 0)\n    ensures forall c :: 0 <= c < changes ==> !can_make_palindromic_with_changes(arr, c)\n    ensures can_make_palindromic_with_changes(arr, changes)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0075", "language": "dafny", "source": "humaneval", "source_id": "humaneval_074", "vc-description": "This task implements a function that compares two lists of strings by their total character count. Given two lists of strings, the function should return the list that has the smaller total character count across all its strings. If both lists have the same total character count, return the first list.", "vc-preamble": "\nfunction total_chars(lst: seq<string>): nat\n{\n    if |lst| == 0 then 0\n    else |lst[0]| + total_chars(lst[1..])\n}\nlemma total_chars_prefix(lst: seq<string>, i: nat)\n    requires 0 <= i < |lst|\n    ensures total_chars(lst[..i+1]) == total_chars(lst[..i]) + |lst[i]|\n{\n    if i == 0 {\n        assert lst[..1] == [lst[0]];\n        assert total_chars(lst[..1]) == |lst[0]| + total_chars([]);\n        assert total_chars([]) == 0;\n    } else {\n        assert lst[..i+1] == [lst[0]] + (lst[1..])[..i];\n        assert lst[..i] == [lst[0]] + (lst[1..])[..i-1];\n        assert lst[i] == (lst[1..])[i-1];\n        total_chars_prefix(lst[1..], i-1);\n        assert total_chars((lst[1..])[..i]) == total_chars((lst[1..])[..i-1]) + |(lst[1..])[i-1]|;\n        assert total_chars(lst[..i+1]) == |lst[0]| + total_chars((lst[1..])[..i]);\n        assert total_chars(lst[..i]) == |lst[0]| + total_chars((lst[1..])[..i-1]);\n    }\n}", "vc-helpers": "", "vc-spec": "method total_match(lst1: seq<string>, lst2: seq<string>) returns (result: seq<string>)\n    ensures result == lst1 || result == lst2\n    ensures total_chars(lst1) <= total_chars(lst2) ==> result == lst1\n    ensures total_chars(lst1) > total_chars(lst2) ==> result == lst2", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0076", "language": "dafny", "source": "humaneval", "source_id": "humaneval_075", "vc-description": "This verification task implements a method to determine if a given integer (less than 100) is the product of exactly 3 prime numbers, counting repetitions. The method performs prime factorization and checks if exactly 3 prime factors (with repetitions) multiply to the original number.\n\nThe expected implementation uses trial division to find all prime factors, starting with factors of 2, then checking odd numbers up to the square root, and finally handling any remaining prime factor greater than the square root.", "vc-preamble": "\npredicate is_prime_number(n: int)\n{\n  n >= 2 && forall k: int :: 2 <= k < n ==> n % k != 0\n}\n\nfunction seq_product(factors: seq<int>): int\n  decreases |factors|\n{\n  if |factors| == 0 then 1\n  else factors[0] * seq_product(factors[1..])\n}\n\nfunction power(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nlemma seq_product_append_lemma(s: seq<int>, x: int)\n  ensures seq_product(s + [x]) == seq_product(s) * x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n    assert seq_product([x]) == x;\n    assert seq_product(s) == 1;\n  } else {\n    assert s == [s[0]] + s[1..];\n    assert s + [x] == [s[0]] + (s[1..] + [x]);\n    seq_product_append_lemma(s[1..], x);\n    assert seq_product(s[1..] + [x]) == seq_product(s[1..]) * x;\n    assert seq_product(s + [x]) == s[0] * seq_product(s[1..] + [x]);\n    assert seq_product(s + [x]) == s[0] * (seq_product(s[1..]) * x);\n    assert seq_product(s + [x]) == (s[0] * seq_product(s[1..])) * x;\n    assert seq_product(s + [x]) == seq_product(s) * x;\n  }\n}", "vc-helpers": "", "vc-spec": "method is_multiply_prime(a: int) returns (result: bool)\n  requires a >= 0 && a < 100\n  ensures a < 8 ==> result == false\n  ensures result == true <==> (exists p1: int, p2: int, p3: int :: \n    p1 >= 2 && p2 >= 2 && p3 >= 2 && \n    is_prime_number(p1) && is_prime_number(p2) && is_prime_number(p3) &&\n    a == p1 * p2 * p3)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0077", "language": "dafny", "source": "humaneval", "source_id": "humaneval_076_is_simple_power", "vc-description": "function_signature: def is_simple_power(x: int, n: int) -> bool\nYour task is to write a function that returns true if a number x is a simple power of n and false in other cases. x is a simple power of n if n**int=x", "vc-preamble": "function power(x: nat, y: nat): nat {\n    if y == 0 then 1 else x * power(x, y-1)\n}", "vc-helpers": "", "vc-spec": "method is_simple_power(x: nat, n: int) returns (ans : bool)\n\n    requires x > 0\n\n    ensures ans <==> exists y :: n == power(x, y)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0078", "language": "dafny", "source": "humaneval", "source_id": "humaneval_077_iscube__cube_root", "vc-description": "function_signature: method cube_root(N: nat) returns (r: nat)\nFind the integer cube root. Ensures: the result r is the largest integer such that r³ ≤ N < (r+1)³; the result is at most N.", "vc-preamble": "function cube(n: int): int { n * n * n }", "vc-helpers": "", "vc-spec": "method cube_root(N: nat) returns (r: nat)\n\n  ensures cube(r) <= N < cube(r + 1)\n  ensures r <= N", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0079", "language": "dafny", "source": "humaneval", "source_id": "humaneval_077_iscube__is_cube", "vc-description": "function_signature: method is_cube(n: nat) returns (r: bool)\nCheck if condition holds. Ensures: if true, then there exists an integer r such that N = r³; if false, then no integer r satisfies N = r³.", "vc-preamble": "function cube(n: int): int { n * n * n }", "vc-helpers": "", "vc-spec": "method is_cube(n: nat) returns (r: bool)\n\n  ensures r ==> exists r :: 0 <= r <= n && n == cube(r)\n  ensures !r ==> forall r :: 0 <= r <= n ==> n != cube(r)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0080", "language": "dafny", "source": "humaneval", "source_id": "humaneval_078", "vc-description": "This task involves counting hexadecimal digits that represent prime numbers in a given hexadecimal string. The prime hexadecimal digits are: 2, 3, 5, 7, B (decimal 11), and D (decimal 13). The implementation should iterate through the string and count occurrences of these specific characters.", "vc-preamble": "\npredicate is_hex_char(c: char)\n{\n    c in \"0123456789ABCDEF\"\n}\n\npredicate is_valid_hex_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> is_hex_char(s[i])\n}\n\npredicate is_prime_hex_digit(c: char)\n{\n    c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D'\n}\n\nfunction count_prime_hex_digits(s: string): int\n{\n    if |s| == 0 then 0\n    else (if is_prime_hex_digit(s[0]) then 1 else 0) + count_prime_hex_digits(s[1..])\n}\nlemma append_count_lemma(s: string, c: char)\n    ensures count_prime_hex_digits(s + [c]) == count_prime_hex_digits(s) + (if is_prime_hex_digit(c) then 1 else 0)\n{\n    if |s| == 0 {\n        assert s + [c] == [c];\n        assert count_prime_hex_digits([c]) == (if is_prime_hex_digit(c) then 1 else 0) + count_prime_hex_digits([]);\n    } else {\n        assert s + [c] == [s[0]] + s[1..] + [c];\n        assert s + [c] == [s[0]] + (s[1..] + [c]);\n        append_count_lemma(s[1..], c);\n    }\n}", "vc-helpers": "", "vc-spec": "method hex_key(num: string) returns (count: int)\n    requires is_valid_hex_string(num)\n    ensures count >= 0\n    ensures count <= |num|\n    ensures count == count_prime_hex_digits(num)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0081", "language": "dafny", "source": "humaneval", "source_id": "humaneval_079_decimal_to_binary", "vc-description": "function_signature: def decimal_to_binary(decimal: nat) -> string\nYou will be given a number in decimal form and your task is to convert it to binary format. The function should return a string, with each character representing a binary number. Each character in the string will be '0' or '1'.", "vc-preamble": "type stringBin = s: string |\n  |s| > 0 && (|s| > 1 ==> s[0] != '0') &&\n  forall i | 0 <= i < |s| :: s[i] in \"01\"\n  witness \"1\"\n\nfunction decimal_to_binary_helper(n: nat): stringBin \n\n  ensures binary_to_decimal(decimal_to_binary_helper(n)) == n\n\n{\n\n  match n\n    case 0 => \"0\" case 1 => \"1\"\n    case _ => decimal_to_binary_helper(n / 2) + decimal_to_binary_helper(n % 2)\n\n}\n\nfunction binary_to_decimal(s: stringBin): nat\n  decreases |s|\n{\n  if |s| == 1 then\n    match s[0]\n    case '0' => 0 case '1' => 1\n  else\n    binary_to_decimal(s[..|s|-1])*2 + binary_to_decimal(s[|s|-1..|s|])\n}", "vc-helpers": "", "vc-spec": "method decimal_to_binary(n: nat) returns (s: string)\n\n  ensures |s| == |decimal_to_binary_helper(n)| + 4\n  ensures s[..2] == \"db\"\n  ensures s[|s| - 2..] == \"db\"\n  ensures s[2..|s| - 2] == decimal_to_binary_helper(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0082", "language": "dafny", "source": "humaneval", "source_id": "humaneval_080", "vc-description": "This task involves determining if a string is \"happy\". A string is considered happy if it has a length of at least 3 characters and in every substring of 3 consecutive characters, all characters are distinct (no duplicates). The implementation should efficiently check this condition and return the appropriate boolean result.", "vc-preamble": "\npredicate ValidLength(s: string)\n{\n    |s| >= 3\n}\n\npredicate AllWindowsDistinct(s: string)\n{\n    forall i {:trigger s[i]} :: 0 <= i <= |s| - 3 ==> s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2]\n}\n\npredicate IsHappy(s: string)\n{\n    ValidLength(s) && AllWindowsDistinct(s)\n}", "vc-helpers": "", "vc-spec": "method is_happy(s: string) returns (result: bool)\n    ensures result == IsHappy(s)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0083", "language": "dafny", "source": "humaneval", "source_id": "humaneval_081", "vc-description": "Convert a list of numerical GPA values to corresponding letter grades using a specified grading scale. The grading scale maps GPA ranges to letter grades from A+ (4.0) down to E (0.0).", "vc-preamble": "\nfunction getLetterGrade(gpa: real): string\n{\n    if gpa == 4.0 then \"A+\"\n    else if gpa > 3.7 then \"A\"\n    else if gpa > 3.3 then \"A-\"\n    else if gpa > 3.0 then \"B+\"\n    else if gpa > 2.7 then \"B\"\n    else if gpa > 2.3 then \"B-\"\n    else if gpa > 2.0 then \"C+\"\n    else if gpa > 1.7 then \"C\"\n    else if gpa > 1.3 then \"C-\"\n    else if gpa > 1.0 then \"D+\"\n    else if gpa > 0.7 then \"D\"\n    else if gpa > 0.0 then \"D-\"\n    else \"E\"\n}\n\npredicate ValidLetterGrades(grades: seq<string>)\n{\n    forall grade :: grade in grades ==> grade in {\"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"D-\", \"E\"}\n}", "vc-helpers": "", "vc-spec": "method numerical_letter_grade(grades: seq<real>) returns (letter_grades: seq<string>)\n    ensures |letter_grades| == |grades|\n    ensures forall i :: 0 <= i < |grades| ==> letter_grades[i] == getLetterGrade(grades[i])\n    ensures ValidLetterGrades(letter_grades)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0084", "language": "dafny", "source": "humaneval", "source_id": "humaneval_082", "vc-description": "This task verifies a function that determines whether a string's length is a prime number. A prime number is defined as an integer greater than or equal to 2 that has no divisors other than 1 and itself.", "vc-preamble": "\npredicate is_prime_number(n: int)\n{\n    n >= 2 && (forall k :: 2 <= k < n ==> n % k != 0)\n}", "vc-helpers": "", "vc-spec": "method prime_length(s: string) returns (result: bool)\n    ensures result <==> is_prime_number(|s|)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0085", "language": "dafny", "source": "humaneval", "source_id": "humaneval_083", "vc-description": "Count n-digit positive integers that start with 1 OR end with 1 using inclusion-exclusion principle. The task requires implementing a function that uses the inclusion-exclusion principle to count numbers that either start with 1, end with 1, or both, avoiding double-counting those that satisfy both conditions.", "vc-preamble": "\npredicate ValidInput(n: int) {\n  n >= 1\n}\n\nfunction power(base: int, exp: int): int\n  requires exp >= 0\n  ensures base >= 0 ==> power(base, exp) >= 0\n  ensures base > 0 ==> power(base, exp) > 0\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nfunction CountStartsWith1(n: int): int\n  requires n >= 1\n  ensures CountStartsWith1(n) == power(10, n - 1)\n{\n  power(10, n - 1)\n}\n\nfunction CountEndsWith1(n: int): int\n  requires n >= 1\n  ensures n == 1 ==> CountEndsWith1(n) == 1\n  ensures n >= 2 ==> CountEndsWith1(n) == 9 * power(10, n - 2)\n{\n  if n == 1 then 1\n  else 9 * power(10, n - 2)\n}\n\nfunction CountStartsAndEndsWith1(n: int): int\n  requires n >= 1\n  ensures n == 1 ==> CountStartsAndEndsWith1(n) == 1\n  ensures n == 2 ==> CountStartsAndEndsWith1(n) == 1\n  ensures n >= 3 ==> CountStartsAndEndsWith1(n) == power(10, n - 2)\n{\n  if n <= 2 then 1\n  else power(10, n - 2)\n}", "vc-helpers": "", "vc-spec": "method starts_one_ends(n: int) returns (result: int)\n  requires ValidInput(n)\n  ensures result == CountStartsWith1(n) + CountEndsWith1(n) - CountStartsAndEndsWith1(n)\n  ensures result >= 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0086", "language": "dafny", "source": "humaneval", "source_id": "humaneval_084_solve", "vc-description": "function_signature: def solve(n: int) -> str\nGiven a positive integer N, return the total sum of its digits in binary.", "vc-preamble": "function popcount(n: nat): nat {\n  if n == 0 then 0 else n % 2 + popcount(n / 2)\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat) returns (r: nat)\n\n  ensures r == popcount(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0087", "language": "dafny", "source": "humaneval", "source_id": "humaneval_085_add", "vc-description": "function_signature: def solve(n: list[int]) -> int\nGiven a non-empty list of integers lst, add the even elements that are at odd indices.", "vc-preamble": "function sumc(s: seq<int>, p: seq<bool>) : int\n    requires |s| == |p|\n    {\n        if |s| == 0 then 0 else (if p[0] then s[0] else 0) + sumc(s[1..], p[1..])\n    }\nfunction add_conditon(lst: seq<int>) : (p : seq<bool>)\n    ensures |lst| == |p|\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => i % 2 == 1 && lst[i] % 2 == 0)\n    }", "vc-helpers": "", "vc-spec": "method add(v: seq<int>) returns (r : int)\n\n    ensures r == sumc(v, add_conditon(v))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0088", "language": "dafny", "source": "humaneval", "source_id": "humaneval_087_get_row__SortSeq", "vc-description": "function_signature: method SortSeq(s: SortSeqState) returns (sorted: SortSeqState)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "type SortSeqState = seq<(int, int)>\nfunction less(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  x < u || (x == u && y > v)\n}\nfunction less_eq(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  (x == u && y == v) || less(a, b)\n}", "vc-helpers": "", "vc-spec": "method SortSeq(s: SortSeqState) returns (sorted: SortSeqState)\n\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> less_eq(sorted[i], sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0089", "language": "dafny", "source": "humaneval", "source_id": "humaneval_087_get_row__get_row", "vc-description": "function_signature: method get_row(lst: seq<seq<int>>, x: int) returns (pos: SortSeqState)\nRetrieve elements. Ensures: the condition holds for all values; the condition holds for all values; the condition holds for all values.", "vc-preamble": "type SortSeqState = seq<(int, int)>\nfunction less(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  x < u || (x == u && y > v)\n}\nfunction less_eq(a: (int, int), b: (int, int)): bool {\n  var (x, y) := a; var (u, v) := b;\n  (x == u && y == v) || less(a, b)\n}", "vc-helpers": "", "vc-spec": "method get_row(lst: seq<seq<int>>, x: int) returns (pos: SortSeqState)\n\n  ensures forall i :: 0 <= i < |pos| ==> (\n    var (a, b) := pos[i];\n    0 <= a < |lst| && 0 <= b < |lst[a]| && lst[a][b] == x\n  )\n  ensures forall i, j :: 0 <= i < |lst| && 0 <= j < |lst[i]| && lst[i][j] == x ==> (i, j) in pos\n  ensures forall i, j :: 0 <= i < j < |pos| ==> less_eq(pos[i], pos[j])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0090", "language": "dafny", "source": "humaneval", "source_id": "humaneval_088", "vc-description": "This verification task implements a conditional sorting algorithm for arrays of non-negative integers. The sorting order is determined by the sum of the first and last elements: if the sum is odd, the array is sorted in ascending order; if the sum is even, it's sorted in descending order. The implementation must return a sorted copy without modifying the original array and preserve all elements (multiset equality).", "vc-preamble": "\npredicate ValidInput(arr: seq<int>)\n{\n    forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n}\n\npredicate IsAscendingSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\npredicate IsDescendingSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]\n}\n\npredicate ShouldSortAscending(arr: seq<int>)\n{\n    |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 1\n}\n\npredicate ShouldSortDescending(arr: seq<int>)\n{\n    |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 0\n}\n\npredicate CorrectlySorted(arr: seq<int>, result: seq<int>)\n{\n    (|arr| <= 1 ==> result == arr) &&\n    (ShouldSortAscending(arr) ==> IsAscendingSorted(result)) &&\n    (ShouldSortDescending(arr) ==> IsDescendingSorted(result))\n}\nmethod SortAscending(arr: seq<int>) returns (result: seq<int>)\n    ensures multiset(result) == multiset(arr)\n    ensures IsAscendingSorted(result)\n{\n    result := arr;\n    var i := 0;\n    while i < |result|\n        invariant 0 <= i <= |result|\n        invariant |result| == |arr|\n        invariant multiset(result) == multiset(arr)\n        invariant forall p, q :: 0 <= p < q < i ==> result[p] <= result[q]\n        invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] <= result[q]\n        decreases |result| - i\n    {\n        var j := i + 1;\n        while j < |result|\n            invariant i < j <= |result|\n            invariant |result| == |arr|\n            invariant multiset(result) == multiset(arr)\n            invariant forall p, q :: 0 <= p < q < i ==> result[p] <= result[q]\n            invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] <= result[q]\n            invariant forall q :: i < q < j ==> result[i] <= result[q]\n        {\n            if result[j] < result[i] {\n                result := result[i := result[j]][j := result[i]];\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}\n\nmethod SortDescending(arr: seq<int>) returns (result: seq<int>)\n    ensures multiset(result) == multiset(arr)\n    ensures IsDescendingSorted(result)\n{\n    result := arr;\n    var i := 0;\n    while i < |result|\n        invariant 0 <= i <= |result|\n        invariant |result| == |arr|\n        invariant multiset(result) == multiset(arr)\n        invariant forall p, q :: 0 <= p < q < i ==> result[p] >= result[q]\n        invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] >= result[q]\n        decreases |result| - i\n    {\n        var j := i + 1;\n        while j < |result|\n            invariant i < j <= |result|\n            invariant |result| == |arr|\n            invariant multiset(result) == multiset(arr)\n            invariant forall p, q :: 0 <= p < q < i ==> result[p] >= result[q]\n            invariant forall p, q :: 0 <= p < i <= q < |result| ==> result[p] >= result[q]\n            invariant forall q :: i < q < j ==> result[i] >= result[q]\n        {\n            if result[j] > result[i] {\n                result := result[i := result[j]][j := result[i]];\n            }\n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}", "vc-helpers": "", "vc-spec": "method sort_array(arr: seq<int>) returns (result: seq<int>)\n    requires ValidInput(arr)\n    ensures multiset(result) == multiset(arr)\n    ensures CorrectlySorted(arr, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0091", "language": "dafny", "source": "humaneval", "source_id": "humaneval_089", "vc-description": "This verification task implements a string encryption algorithm that shifts each alphabetic character forward by 4 positions in the alphabet with wraparound. The implementation should preserve the case of letters and leave non-alphabetic characters unchanged.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method encrypt(s: string) returns (result: string)\n    requires |s| >= 0\n    ensures |result| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (\n        if 'a' <= s[i] <= 'z' then\n            result[i] == (((s[i] as int - 'a' as int + 4) % 26) + 'a' as int) as char\n        else if 'A' <= s[i] <= 'Z' then\n            result[i] == (((s[i] as int - 'A' as int + 4) % 26) + 'A' as int) as char\n        else\n            result[i] == s[i]\n    )", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0092", "language": "dafny", "source": "humaneval", "source_id": "humaneval_090_next_smallest", "vc-description": "function_signature: def next_smallest(lst: List[int]) -> Optional[int]\nYou are given a list of integers. Write a function next_smallest() that returns the 2nd smallest element of the list. Return None if there is no such element. TODO(George): Remove this when being reviewed The spec is defined as: if result is none there is no second smallest element, which exists in a finite list iff there are at least two distinct elements in the list. If result is some x, then x is the second smallest element of the list, the spec obtains the sublist of elements smaller than the result, and checks that this sublist does not contain two distinct elements (they are all the same).", "vc-preamble": "datatype Option<T> = None | Some(T)\nfunction getVal(mx : Option<int>) : int\n    requires mx != None\n{\n    match mx {\n        case Some(n) => n\n    }\n}", "vc-helpers": "", "vc-spec": "method rolling_max(s: seq<int>) returns (res: Option<int>) \n\n    ensures res == None <==> |s| < 2\n    ensures res != None ==> exists x :: 0 <= x < |s| && s[x] == getVal(res)\n    ensures forall x, y :: 0 <= x < y < |s| ==> s[x] <= getVal(res) || s[y] <= getVal(res)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0094", "language": "dafny", "source": "humaneval", "source_id": "humaneval_092", "vc-description": "This verification task involves implementing a function that checks if three real numbers satisfy two conditions: all three must be integers, and one of the numbers must equal the sum of the other two. The function should return true only if both conditions are met, false otherwise.", "vc-preamble": "\npredicate IsInteger(x: real)\n{\n    x == x.Floor as real\n}\n\npredicate AllIntegers(x: real, y: real, z: real)\n{\n    IsInteger(x) && IsInteger(y) && IsInteger(z)\n}\n\npredicate OneEqualsSumOfOtherTwo(x: real, y: real, z: real)\n{\n    x == y + z || y == x + z || z == x + y\n}\n\npredicate ValidResult(x: real, y: real, z: real, result: bool)\n{\n    result <==> (AllIntegers(x, y, z) && OneEqualsSumOfOtherTwo(x, y, z))\n}", "vc-helpers": "", "vc-spec": "method any_int(x: real, y: real, z: real) returns (result: bool)\n    ensures ValidResult(x, y, z, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0095", "language": "dafny", "source": "humaneval", "source_id": "humaneval_093", "vc-description": "Implement a message encoding algorithm that applies two transformations to each character: first replace vowels with letters appearing 2 positions later in the alphabet, then swap the case of all letters. Spaces are preserved unchanged, and the input contains only letters and spaces.", "vc-preamble": "\npredicate isVowel(c: char)\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n    c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\n\nfunction getVowelReplacement(c: char): char\n    requires isVowel(c)\n{\n    match c\n        case 'a' => 'c'\n        case 'e' => 'g' \n        case 'i' => 'k'\n        case 'o' => 'q'\n        case 'u' => 'w'\n        case 'A' => 'C'\n        case 'E' => 'G'\n        case 'I' => 'K'\n        case 'O' => 'Q'\n        case 'U' => 'W'\n}\n\nfunction swapCase(c: char): char\n{\n    if 'a' <= c <= 'z' then\n        (c as int - 'a' as int + 'A' as int) as char\n    else if 'A' <= c <= 'Z' then\n        (c as int - 'A' as int + 'a' as int) as char\n    else\n        c\n}", "vc-helpers": "", "vc-spec": "method encode(message: string) returns (result: string)\n    requires forall i :: 0 <= i < |message| ==> (('a' <= message[i] <= 'z') || ('A' <= message[i] <= 'Z') || message[i] == ' ')\n    ensures |result| == |message|\n    ensures forall i :: 0 <= i < |message| ==> \n        if message[i] == ' ' then result[i] == ' '\n        else if isVowel(message[i]) then result[i] == swapCase(getVowelReplacement(message[i]))\n        else result[i] == swapCase(message[i])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0096", "language": "dafny", "source": "humaneval", "source_id": "humaneval_094", "vc-description": "This verification task involves implementing a method that finds the largest prime number in a given list of integers and returns the sum of its digits. If no prime number exists in the list, the method should return 0. The implementation requires helper functions for prime checking and digit sum calculation.", "vc-preamble": "\nfunction is_prime_pure(n: int): bool\n{\n    n >= 2 && (forall k :: 2 <= k < n ==> n % k != 0)\n}\n\nfunction sum_of_digits_pure(n: int): int\n    requires n >= 0\n{\n    if n < 10 then n else (n % 10) + sum_of_digits_pure(n / 10)\n}\n\nfunction sum_of_digits(n: int): int\n    requires n >= 0\n    ensures sum_of_digits(n) == sum_of_digits_pure(n)\n    ensures sum_of_digits(n) >= 0\n{\n    if n < 10 then n\n    else (n % 10) + sum_of_digits(n / 10)\n}", "vc-helpers": "", "vc-spec": "method skjkasdkd(lst: seq<int>) returns (result: int)\n    ensures result >= 0\n    ensures (forall x :: x in lst ==> !is_prime_pure(x)) ==> result == 0\n    ensures (exists x :: x in lst && is_prime_pure(x)) ==> \n        (exists largest :: (largest in lst && is_prime_pure(largest) && \n         (forall y :: y in lst && is_prime_pure(y) ==> y <= largest) &&\n         result == sum_of_digits_pure(largest)))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0097", "language": "dafny", "source": "humaneval", "source_id": "humaneval_095_check_dict_case", "vc-description": "function_signature: def check_dict_case(s : dict[str, str]) -> bool\nGiven a dictionary, return True if all keys are strings in lower case or all keys are strings in upper case, else return False. The function should return False is the given dictionary is empty. Note(George): Modified the problem to use strings only for both keys and values.", "vc-preamble": "function IsLowerCase(s: string) : bool\n{\n  forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\nfunction IsUpperCase(s: string) : bool\n{\n  forall i :: 0 <= i < |s| ==> 'A' <= s[i] <= 'Z'\n}\ntype DictCase = map<string, string>", "vc-helpers": "", "vc-spec": "method CheckDictCase(dict: DictCase) returns (result: bool)\n\n  ensures dict == map[] ==> !result\n  ensures result ==> (forall k :: k in dict ==> IsLowerCase(k)) || (forall k :: k in dict ==> IsUpperCase(k))\n  ensures !result ==> dict == map[] || ((exists k :: k in dict && !IsLowerCase(k)) && (exists k :: k in dict && !IsUpperCase(k)))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0098", "language": "dafny", "source": "humaneval", "source_id": "humaneval_096", "vc-description": "This verification task involves implementing a function that returns all prime numbers strictly less than a given non-negative integer n, in ascending order. The implementation should correctly identify prime numbers using a helper method and build the result sequence while maintaining the sorted order.", "vc-preamble": "\npredicate is_prime_number(num: int)\n{\n    num >= 2 && forall k :: 2 <= k < num ==> num % k != 0\n}", "vc-helpers": "", "vc-spec": "method count_up_to(n: int) returns (result: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |result| ==> is_prime_number(result[i])\n    ensures forall i :: 0 <= i < |result| ==> result[i] < n\n    ensures forall p :: 2 <= p < n && is_prime_number(p) ==> p in result\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0099", "language": "dafny", "source": "humaneval", "source_id": "humaneval_097", "vc-description": "This task implements a function to compute the product of the unit digits of two integers. The unit digit is defined as the ones place digit of the absolute value of a number. Given two integers (which can be positive, negative, or zero), the method should return the product of their respective unit digits.", "vc-preamble": "\nfunction UnitDigit(n: int): int\n{\n    (if n >= 0 then n else -n) % 10\n}\n\nfunction ProductOfUnitDigits(a: int, b: int): int\n{\n    UnitDigit(a) * UnitDigit(b)\n}\n\npredicate ValidResult(result: int)\n{\n    result >= 0 && result <= 81\n}", "vc-helpers": "", "vc-spec": "method multiply(a: int, b: int) returns (result: int)\n    ensures result == ProductOfUnitDigits(a, b)\n    ensures ValidResult(result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0100", "language": "dafny", "source": "humaneval", "source_id": "humaneval_098_count_upper", "vc-description": "function_signature: def count_upper(s : String) -> Int\nGiven a string s, count the number of uppercase vowels in even indices.", "vc-preamble": "function is_upper_vowel(c: char) : bool {\n  c == 'A' || c == 'E' || c == 'U' || c == 'I' || c == 'O'\n}", "vc-helpers": "", "vc-spec": "method count_upper(s: string) returns (cnt: int)\n\n  ensures cnt == |set i | 0 <= i < |s| && i % 2 == 0 && is_upper_vowel(s[i])|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0101", "language": "dafny", "source": "humaneval", "source_id": "humaneval_100", "vc-description": "This verification task implements a method to create a pile of stones with n levels. The first level contains n stones, and each subsequent level contains the next number with the same parity (odd/even) as n. This creates an arithmetic sequence where each level has 2 more stones than the previous level.", "vc-preamble": "\npredicate ValidInput(n: int)\n{\n    n > 0\n}\n\npredicate ValidPile(pile: seq<int>, n: int)\n{\n    && |pile| == n\n    && (n > 0 ==> |pile| > 0 && pile[0] == n)\n    && (forall i :: 0 <= i < |pile| ==> pile[i] == n + 2 * i)\n    && (forall i :: 0 <= i < |pile| - 1 ==> pile[i+1] == pile[i] + 2)\n}", "vc-helpers": "", "vc-spec": "method make_a_pile(n: int) returns (pile: seq<int>)\n    requires ValidInput(n)\n    ensures ValidPile(pile, n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0102", "language": "dafny", "source": "humaneval", "source_id": "humaneval_102", "vc-description": "This task involves implementing a method to find the largest even integer in a given range [x, y] inclusive, where x and y are positive integers. If no even integer exists in the range, the method should return -1.", "vc-preamble": "\npredicate ValidInput(x: int, y: int) {\n    x > 0 && y > 0\n}\n\npredicate NoEvenInRange(x: int, y: int) {\n    forall i :: x <= i <= y ==> i % 2 != 0\n}\n\npredicate IsLargestEvenInRange(x: int, y: int, result: int) {\n    result % 2 == 0 && \n    x <= result <= y && \n    (forall i :: x <= i <= y && i % 2 == 0 ==> i <= result)\n}\n\npredicate CorrectResult(x: int, y: int, result: int) {\n    if x > y then \n        result == -1\n    else\n        (result == -1 && NoEvenInRange(x, y)) ||\n        IsLargestEvenInRange(x, y, result)\n}", "vc-helpers": "", "vc-spec": "method ChooseNum(x: int, y: int) returns (result: int)\n    requires ValidInput(x, y)\n    ensures CorrectResult(x, y, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0103", "language": "dafny", "source": "humaneval", "source_id": "humaneval_103", "vc-description": "Given two positive integers n and m, compute the average of all integers in the range [n, m] (inclusive).\nRound the result to the nearest integer using banker's rounding (round half to even) and return the binary representation as a string prefixed with \"0b\". If n > m, return \"-1\".", "vc-preamble": "\nfunction IntToBinary(n: nat): string\n{\n    if n == 0 then \"0\"\n    else IntToBinaryHelper(n)\n}\n\nfunction IntToBinaryHelper(n: nat): string\n    requires n > 0\n{\n    if n == 1 then \"1\" \n    else IntToBinaryHelper(n / 2) + (if n % 2 == 1 then \"1\" else \"0\")\n}", "vc-helpers": "", "vc-spec": "method rounded_avg(n: int, m: int) returns (result: string)\n    requires n > 0 && m > 0\n    ensures n > m ==> result == \"-1\"\n    ensures n <= m ==> |result| >= 3 && result[0..2] == \"0b\"\n    ensures n <= m ==> (\n        var count := m - n + 1;\n        var total_sum := count * (n + m) / 2;\n        var quotient := total_sum / count;\n        var remainder := total_sum % count;\n        var rounded := if remainder * 2 < count then quotient\n                      else if remainder * 2 > count then quotient + 1\n                      else if quotient % 2 == 0 then quotient\n                      else quotient + 1;\n        result == \"0b\" + IntToBinary(rounded)\n    )", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0104", "language": "dafny", "source": "humaneval", "source_id": "humaneval_104_unique_digits", "vc-description": "function_signature: def unique_digits(x: List[nat]) -> List[nat]\nGiven a list of positive integers x. return a sorted list of all elements that hasn't any even digit.", "vc-preamble": "function HasNoEvenDigit(n: int) : bool\n  decreases n\n{\n  n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && HasNoEvenDigit(n / 10)))\n}", "vc-helpers": "", "vc-spec": "method UniqueDigits(x: seq<int>) returns (result: seq<int>)\n\n  ensures forall i :: 0 <= i < |result| ==> HasNoEvenDigit(result[i])\n  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]\n  ensures forall e :: e in x && HasNoEvenDigit(e) ==> e in result\n  ensures forall e :: e in result ==> e in x", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0105", "language": "dafny", "source": "humaneval", "source_id": "humaneval_105_by_length__SortReverseAndName", "vc-description": "function_signature: method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\nSort elements. Ensures: the size is bounded; the condition holds for all values.", "vc-preamble": "function NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}", "vc-helpers": "", "vc-spec": "method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)\n\n  ensures |result| <= |arr|\n  ensures forall i :: 0 <= i < |result| ==>\n    result[i] in [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0106", "language": "dafny", "source": "humaneval", "source_id": "humaneval_105_by_length__SortSeq", "vc-description": "function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "function NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}", "vc-helpers": "", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0107", "language": "dafny", "source": "humaneval", "source_id": "humaneval_105_by_length__reverse", "vc-description": "function_signature: method reverse(s: seq<int>) returns (rev: seq<int>)\nReverse order. Ensures: returns the correct size/count; the condition holds for all values.", "vc-preamble": "function NumberToName(n: int): string\n  requires 1 <= n <= 9\n{\n  match n\n  case 1 => \"One\"\n  case 2 => \"Two\"\n  case 3 => \"Three\"\n  case 4 => \"Four\"\n  case 5 => \"Five\"\n  case 6 => \"Six\"\n  case 7 => \"Seven\"\n  case 8 => \"Eight\"\n  case 9 => \"Nine\"\n}", "vc-helpers": "", "vc-spec": "method reverse(s: seq<int>) returns (rev: seq<int>)\n\n  ensures |rev| == |s|\n  ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0108", "language": "dafny", "source": "humaneval", "source_id": "humaneval_106", "vc-description": "This task requires implementing a method that generates a sequence of natural numbers based on position-dependent calculations. For each position i (0-indexed), if (i+1) is even, the element should be the factorial of (i+1); if (i+1) is odd, the element should be the sum of integers from 1 to (i+1).", "vc-preamble": "\nfunction factorial(n: nat): nat\n{\n    if n <= 1 then 1 else n * factorial(n - 1)\n}\n\nfunction sum_range(n: nat): nat\n{\n    if n == 0 then 0 else n + sum_range(n - 1)\n}\n\npredicate ValidResult(n: nat, result: seq<nat>)\n{\n    |result| == n &&\n    forall i :: 0 <= i < n ==> \n        (if (i + 1) % 2 == 0 then result[i] == factorial(i + 1)\n         else result[i] == sum_range(i + 1))\n}", "vc-helpers": "", "vc-spec": "method f(n: nat) returns (result: seq<nat>)\n    ensures ValidResult(n, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0109", "language": "dafny", "source": "humaneval", "source_id": "humaneval_107", "vc-description": "This verification task implements a function to count even and odd palindromic integers in the range [1, n] inclusive. A palindromic integer reads the same forwards and backwards (e.g., 121, 7, 1331). The function should return a tuple (even_count, odd_count) representing the counts of even and odd palindromic integers respectively.", "vc-preamble": "\npredicate ValidInput(n: nat)\n{\n    n >= 1\n}\n\nfunction DigitsOf(n: nat): seq<nat>\n    requires n >= 0\n{\n    if n < 10 then [n]\n    else DigitsOf(n / 10) + [n % 10]\n}\n\nfunction ReverseSeq<T>(s: seq<T>): seq<T>\n{\n    if |s| <= 1 then s\n    else ReverseSeq(s[1..]) + [s[0]]\n}\n\nfunction IsPalindrome(n: nat): bool\n    requires n >= 0\n{\n    var digits := DigitsOf(n);\n    digits == ReverseSeq(digits)\n}\n\nfunction CountPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) then 1 + CountPalindromesInRange(start + 1, end)\n    else CountPalindromesInRange(start + 1, end)\n}\n\nfunction CountEvenPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) && start % 2 == 0 then 1 + CountEvenPalindromesInRange(start + 1, end)\n    else CountEvenPalindromesInRange(start + 1, end)\n}\n\nfunction CountOddPalindromesInRange(start: nat, end: nat): nat\n    requires start >= 1\n    decreases end - start + 1\n{\n    if start > end then 0\n    else if IsPalindrome(start) && start % 2 == 1 then 1 + CountOddPalindromesInRange(start + 1, end)\n    else CountOddPalindromesInRange(start + 1, end)\n}\nfunction CountPalindromes(n: nat, current: nat, even_count: nat, odd_count: nat): (nat, nat)\n    requires current >= 1\n    requires n >= 1\n    requires current <= n + 1\n    decreases n - current + 1\n    ensures CountPalindromes(n, current, even_count, odd_count).0 >= even_count\n    ensures CountPalindromes(n, current, even_count, odd_count).1 >= odd_count\n    ensures CountPalindromes(n, current, even_count, odd_count).0 == even_count + CountEvenPalindromesInRange(current, n)\n    ensures CountPalindromes(n, current, even_count, odd_count).1 == odd_count + CountOddPalindromesInRange(current, n)\n    ensures CountPalindromes(n, current, even_count, odd_count).0 + CountPalindromes(n, current, even_count, odd_count).1 == even_count + odd_count + CountPalindromesInRange(current, n)\n{\n    if current > n then\n        (even_count, odd_count)\n    else if IsPalindrome(current) then\n        if current % 2 == 0 then\n            CountPalindromes(n, current + 1, even_count + 1, odd_count)\n        else\n            CountPalindromes(n, current + 1, even_count, odd_count + 1)\n    else\n        CountPalindromes(n, current + 1, even_count, odd_count)\n}", "vc-helpers": "", "vc-spec": "method even_odd_palindrome(n: nat) returns (result: (nat, nat))\n    requires ValidInput(n)\n    ensures result.0 >= 0\n    ensures result.1 >= 0\n    ensures result.0 == CountEvenPalindromesInRange(1, n)\n    ensures result.1 == CountOddPalindromesInRange(1, n)\n    ensures result.0 + result.1 == CountPalindromesInRange(1, n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0110", "language": "dafny", "source": "humaneval", "source_id": "humaneval_108", "vc-description": "Given an array of integers, count how many elements have a positive sum of digits. For digit sum calculation: positive numbers sum all digits normally, negative numbers have the first digit as negative and remaining digits as positive, and zero has digit sum 0. Return the count of numbers whose digit sum is greater than 0.", "vc-preamble": "\nfunction digitSumFunc(n: int): int\n{\n    if n == 0 then 0\n    else if n > 0 then sumOfDigitsPos(n)\n    else sumOfDigitsPos(-n) - 2 * firstDigit(-n)\n}\n\nfunction sumOfDigitsPos(n: nat): nat\n    requires n >= 0\n    ensures n > 0 ==> sumOfDigitsPos(n) > 0\n{\n    if n == 0 then 0\n    else (n % 10) + sumOfDigitsPos(n / 10)\n}\n\nfunction firstDigit(n: nat): nat\n    requires n > 0\n{\n    if n < 10 then n\n    else firstDigit(n / 10)\n}\n\npredicate ValidInput(arr: seq<int>)\n{\n    true\n}\n\npredicate ValidOutput(arr: seq<int>, count: int)\n{\n    0 <= count <= |arr| && count == |set i | 0 <= i < |arr| && digitSumFunc(arr[i]) > 0|\n}\nmethod digitSum(n: int) returns (result: int)\n    ensures result == digitSumFunc(n)\n    ensures n == 0 ==> result == 0\n    ensures n > 0 ==> result > 0\n{\n    if n == 0 {\n        result := 0;\n    } else if n > 0 {\n        var abs_n := n;\n        var sum := 0;\n        while abs_n > 0 \n            invariant abs_n >= 0\n            invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(n)\n        {\n            sum := sum + (abs_n % 10);\n            abs_n := abs_n / 10;\n        }\n        result := sum;\n    } else {\n        var abs_n := -n;\n        var sum := 0;\n        var first_digit := 0;\n        var temp := abs_n;\n\n        while temp >= 10\n            invariant temp > 0\n            invariant firstDigit(temp) == firstDigit(abs_n)\n        {\n            temp := temp / 10;\n        }\n        first_digit := temp;\n\n        while abs_n > 0 \n            invariant abs_n >= 0\n            invariant sum + sumOfDigitsPos(abs_n) == sumOfDigitsPos(-n)\n        {\n            sum := sum + (abs_n % 10);\n            abs_n := abs_n / 10;\n        }\n        result := sum - 2 * first_digit;\n    }\n}", "vc-helpers": "", "vc-spec": "method count_nums(arr: seq<int>) returns (count: int)\n    requires ValidInput(arr)\n    ensures ValidOutput(arr, count)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0111", "language": "dafny", "source": "humaneval", "source_id": "humaneval_109", "vc-description": "Given an array of unique integers, determine if it's possible to sort the array in non-decreasing order using only right shift operations. A right shift moves all elements one position to the right, with the last element moving to the first. The method should return True if the array is sortable via rotations, False otherwise, with empty arrays returning True.", "vc-preamble": "\npredicate is_sorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction rotate_right(arr: seq<int>, k: int): seq<int>\n    requires 0 <= k <= |arr|\n    ensures |rotate_right(arr, k)| == |arr|\n{\n    if |arr| == 0 then arr\n    else if k == 0 then arr\n    else arr[|arr|-k..] + arr[..|arr|-k]\n}\n\nmethod quicksort(s: seq<int>) returns (sorted: seq<int>)\n    decreases |s|\n{\n    if |s| <= 1 {\n        sorted := s;\n    } else {\n        var pivot := s[0];\n        var smaller := [];\n        var greater := [];\n\n        var i := 1;\n        while i < |s|\n            invariant 1 <= i <= |s|\n            invariant |smaller| + |greater| == i - 1\n            invariant |smaller| < |s|\n            invariant |greater| < |s|\n        {\n            if s[i] < pivot {\n                smaller := smaller + [s[i]];\n            } else {\n                greater := greater + [s[i]];\n            }\n            i := i + 1;\n        }\n\n        var sorted_smaller := quicksort(smaller);\n        var sorted_greater := quicksort(greater);\n        sorted := sorted_smaller + [pivot] + sorted_greater;\n    }\n}", "vc-helpers": "", "vc-spec": "method move_one_ball(arr: seq<int>) returns (result: bool)\n    requires forall i, j :: 0 <= i < j < |arr| ==> arr[i] != arr[j]\n    ensures |arr| == 0 ==> result == true\n    ensures result == true ==> (|arr| == 0 || exists k :: 0 <= k < |arr| && is_sorted(rotate_right(arr, k)))\n    ensures result == false ==> forall k :: 0 <= k < |arr| ==> !is_sorted(rotate_right(arr, k))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0112", "language": "dafny", "source": "humaneval", "source_id": "humaneval_110", "vc-description": "This task involves determining if it's possible to exchange elements between two non-empty lists of integers such that the first list contains only even numbers. The method should return \"YES\" if such an exchange is possible, \"NO\" otherwise.\n\nThe key insight is that we need at least as many even numbers across both lists as the length of the first list to make the first list contain only even numbers.", "vc-preamble": "\nfunction countEven(lst: seq<int>): int\n    ensures countEven(lst) >= 0\n    ensures countEven(lst) <= |lst|\n{\n    if |lst| == 0 then 0\n    else if lst[0] % 2 == 0 then 1 + countEven(lst[1..])\n    else countEven(lst[1..])\n}\n\npredicate ValidInput(lst1: seq<int>, lst2: seq<int>)\n{\n    |lst1| > 0 && |lst2| > 0\n}\n\npredicate CanExchange(lst1: seq<int>, lst2: seq<int>)\n{\n    countEven(lst1) + countEven(lst2) >= |lst1|\n}", "vc-helpers": "", "vc-spec": "method exchange(lst1: seq<int>, lst2: seq<int>) returns (result: string)\n    requires ValidInput(lst1, lst2)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanExchange(lst1, lst2)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0113", "language": "dafny", "source": "humaneval", "source_id": "humaneval_111_histogram", "vc-description": "function_signature: def histogram(s : str) -> Dict[str, int]\nGiven a string representing a space separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count. If several letters have the same occurrence, return all of them.", "vc-preamble": "type BiggestMap = map<int, int>", "vc-helpers": "", "vc-spec": "method count(a: seq<int>) returns (biggest: BiggestMap)\n\n  ensures forall i :: 0 <= i < |a| && a[i] in biggest ==>\n    biggest[a[i]] == |set j | 0 <= j < |a| && a[j] == a[i]|\n  ensures forall i, j :: 0 <= i < |a| && 0 <= j < |a| && a[i] in biggest ==>\n    biggest[a[i]] >= |set k | 0 <= k < |a| && a[k] == a[j]|\n  ensures forall i, j :: 0 <= i < |a| && 0 <= j < |a| && a[i] in biggest && a[j] in biggest ==>\n    biggest[a[i]] == biggest[a[j]]", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0114", "language": "dafny", "source": "humaneval", "source_id": "humaneval_112", "vc-description": "This task implements a string filtering and palindrome checking function. Given two strings s and c, it removes all characters from string s that appear anywhere in string c, then determines if the resulting string is a palindrome (reads the same forwards and backwards). The method returns a tuple containing the filtered string and a boolean indicating whether it's a palindrome.", "vc-preamble": "\nfunction filter_chars(s: seq<char>, c: seq<char>): seq<char>\n{\n    if |s| == 0 then []\n    else if s[0] in c then filter_chars(s[1..], c)\n    else [s[0]] + filter_chars(s[1..], c)\n}\n\nfunction reverse(s: seq<char>): seq<char>\n{\n    if |s| == 0 then []\n    else reverse(s[1..]) + [s[0]]\n}\nlemma filter_chars_append_lemma(s: seq<char>, ch: char, c: seq<char>)\n    ensures filter_chars(s + [ch], c) == \n        (if ch in c then filter_chars(s, c) else filter_chars(s, c) + [ch])\n{\n    if |s| == 0 {\n        assert s + [ch] == [ch];\n        if ch in c {\n            assert filter_chars([ch], c) == filter_chars(s, c);\n        } else {\n            assert filter_chars([ch], c) == [ch];\n            assert filter_chars(s, c) + [ch] == [] + [ch] == [ch];\n        }\n    } else {\n        assert s + [ch] == [s[0]] + (s[1..] + [ch]);\n        filter_chars_append_lemma(s[1..], ch, c);\n    }\n}", "vc-helpers": "", "vc-spec": "method reverse_delete(s: seq<char>, c: seq<char>) returns (result: (seq<char>, bool))\n    ensures result.0 == filter_chars(s, c)\n    ensures result.1 == (result.0 == reverse(result.0))\n    ensures |result.0| <= |s|\n    ensures forall i :: 0 <= i < |result.0| ==> result.0[i] !in c\n    ensures forall i :: 0 <= i < |result.0| ==> result.0[i] in s", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0115", "language": "dafny", "source": "humaneval", "source_id": "humaneval_113", "vc-description": "Given a list of strings containing only digits, count the odd digits (1,3,5,7,9) in each string and return formatted messages where the count is embedded in a template message. The task involves string processing, digit counting, and message formatting with proper verification of loop invariants and postconditions.", "vc-preamble": "\npredicate is_all_digits(s: string)\n{\n  forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction count_odd_digits(s: string): int\n  requires is_all_digits(s)\n  ensures count_odd_digits(s) >= 0\n  ensures count_odd_digits(s) <= |s|\n{\n    if |s| == 0 then 0\n    else\n        var digit := s[0] as int - '0' as int;\n        var is_odd := if digit % 2 == 1 then 1 else 0;\n        is_odd + count_odd_digits(s[1..])\n}\n\nfunction int_to_string_func(n: int): string\n  requires n >= 0\n{\n  if n == 0 then \"0\"\n  else int_to_string_rec(n, \"\")\n}\n\nfunction format_message(count: int): string\n  requires count >= 0\n{\n  var count_str := int_to_string_func(count);\n  \"the number of odd elements \" + count_str + \"n the str\" + count_str + \"ng \" + count_str + \" of the \" + count_str + \"nput.\"\n}\nfunction int_to_string_rec(n: int, acc: string): string\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then acc\n  else\n    var digit := n % 10;\n    var digit_char := ('0' as int + digit) as char;\n    int_to_string_rec(n / 10, [digit_char] + acc)\n}\n\nmethod int_to_string(n: int) returns (s: string)\n  requires n >= 0\n  ensures s == int_to_string_func(n)\n{\n    if n == 0 {\n        s := \"0\";\n    } else {\n        s := \"\";\n        var temp := n;\n        while temp > 0\n          decreases temp\n          invariant temp >= 0\n          invariant int_to_string_rec(temp, s) == int_to_string_rec(n, \"\")\n        {\n            var digit := temp % 10;\n            var digit_char := ('0' as int + digit) as char;\n            s := [digit_char] + s;\n            temp := temp / 10;\n        }\n    }\n}", "vc-helpers": "", "vc-spec": "method odd_count(lst: seq<string>) returns (result: seq<string>)\n  requires forall i :: 0 <= i < |lst| ==> is_all_digits(lst[i])\n  ensures |result| == |lst|\n  ensures forall i :: 0 <= i < |lst| ==> \n    result[i] == format_message(count_odd_digits(lst[i]))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0116", "language": "dafny", "source": "humaneval", "source_id": "humaneval_114_minSubArraySum", "vc-description": "function_signature: def minSubArraySum(nums : list[int]) -> int\nGiven an array of integers nums, find the minimum sum of any non-empty sub-array of nums.", "vc-preamble": "function Sum(a: seq<int>, s: int, t: int): int\n  requires 0 <= s <= t <= |a|\n{\n  if s == t then 0 else Sum(a, s, t-1) + a[t-1]\n}", "vc-helpers": "", "vc-spec": "method minSubArraySum(a: seq<int>) returns (s: int)\n\n  ensures forall p,q :: 0 <= p <= q <= |a| ==> Sum(a, p, q) >= s\n  ensures exists k, m :: 0 <= k <= m <= |a| && s == Sum(a, k, m)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0117", "language": "dafny", "source": "humaneval", "source_id": "humaneval_115", "vc-description": "This verification task involves implementing a solution to determine the minimum number of bucket operations needed to empty all wells in a 2D binary grid. Each row represents a well, each 1 represents a unit of water, and each bucket has a fixed capacity. The implementation must correctly calculate the total number of bucket trips required across all wells.", "vc-preamble": "\npredicate ValidInput(grid: seq<seq<int>>, capacity: int)\n{\n    capacity > 0 &&\n    (forall i :: 0 <= i < |grid| ==> forall j :: 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1) &&\n    (forall i :: 0 <= i < |grid| ==> |grid[i]| == if |grid| > 0 then |grid[0]| else 0)\n}\n\nfunction sum_water(well: seq<int>): int\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n{\n    if |well| == 0 then 0\n    else well[0] + sum_water(well[1..])\n}\n\nfunction trips_for_well(well: seq<int>, capacity: int): int\n    requires capacity > 0\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n{\n    var water_units := sum_water(well);\n    if water_units == 0 then 0\n    else (water_units + capacity - 1) / capacity\n}\n\nfunction sum_of_trips(grid: seq<seq<int>>, capacity: int): int\n    requires capacity > 0\n    requires forall i :: 0 <= i < |grid| ==> forall j :: 0 <= j < |grid[i]| ==> grid[i][j] == 0 || grid[i][j] == 1\n    requires forall i :: 0 <= i < |grid| ==> |grid[i]| == if |grid| > 0 then |grid[0]| else 0\n{\n    if |grid| == 0 then 0\n    else trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..], capacity)\n}\nlemma sum_water_slice_lemma(well: seq<int>, j: int)\n    requires 0 <= j < |well|\n    requires forall k :: 0 <= k < |well| ==> well[k] == 0 || well[k] == 1\n    ensures sum_water(well[..j+1]) == sum_water(well[..j]) + well[j]\n{\n    if j == 0 {\n        assert well[..1] == [well[0]];\n        assert well[..0] == [];\n        assert sum_water(well[..0]) == 0;\n        assert sum_water(well[..1]) == well[0] + sum_water([]);\n        assert sum_water(well[..1]) == well[0] + 0;\n        assert sum_water(well[..1]) == well[0];\n    } else {\n        assert well[..j+1] == well[..j] + [well[j]];\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[..j+1])[1..]);\n        assert (well[..j+1])[1..] == well[1..j+1];\n        assert well[1..j+1] == (well[1..])[..j];\n        sum_water_slice_lemma(well[1..], j-1);\n        assert sum_water((well[1..])[..j]) == sum_water((well[1..])[..j-1]) + (well[1..])[j-1];\n        assert (well[1..])[j-1] == well[j];\n        assert sum_water(well[..j]) == well[0] + sum_water((well[..j])[1..]);\n        assert (well[..j])[1..] == well[1..j];\n        assert well[1..j] == (well[1..])[..j-1];\n        assert sum_water(well[..j]) == well[0] + sum_water((well[1..])[..j-1]);\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[1..])[..j]);\n        assert sum_water(well[..j+1]) == well[0] + sum_water((well[1..])[..j-1]) + well[j];\n        assert sum_water(well[..j+1]) == sum_water(well[..j]) + well[j];\n    }\n}\n\nlemma sum_water_full_slice_lemma(well: seq<int>)\n    requires forall j :: 0 <= j < |well| ==> well[j] == 0 || well[j] == 1\n    ensures sum_water(well[..|well|]) == sum_water(well)\n{\n    assert well[..|well|] == well;\n}\n\nlemma sum_of_trips_slice_lemma(grid: seq<seq<int>>, i: int, capacity: int)\n    requires capacity > 0\n    requires 0 <= i < |grid|\n    requires forall k :: 0 <= k < |grid| ==> forall j :: 0 <= j < |grid[k]| ==> grid[k][j] == 0 || grid[k][j] == 1\n    requires forall k :: 0 <= k < |grid| ==> |grid[k]| == if |grid| > 0 then |grid[0]| else 0\n    ensures sum_of_trips(grid[..i+1], capacity) == sum_of_trips(grid[..i], capacity) + trips_for_well(grid[i], capacity)\n{\n    if i == 0 {\n        assert grid[..1] == [grid[0]];\n        assert grid[..0] == [];\n        assert sum_of_trips(grid[..0], capacity) == 0;\n        assert sum_of_trips(grid[..1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips([], capacity);\n        assert sum_of_trips(grid[..1], capacity) == trips_for_well(grid[0], capacity) + 0;\n    } else {\n        assert grid[..i+1] == [grid[0]] + grid[1..i+1];\n        assert sum_of_trips(grid[..i+1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..i+1], capacity);\n        assert grid[1..i+1] == (grid[1..])[..i];\n        sum_of_trips_slice_lemma(grid[1..], i-1, capacity);\n        assert sum_of_trips((grid[1..])[..i], capacity) == sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well((grid[1..])[i-1], capacity);\n        assert (grid[1..])[i-1] == grid[i];\n        assert grid[..i] == [grid[0]] + grid[1..i];\n        assert sum_of_trips(grid[..i], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips(grid[1..i], capacity);\n        assert grid[1..i] == (grid[1..])[..i-1];\n        assert sum_of_trips(grid[..i], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips((grid[1..])[..i-1], capacity);\n        assert sum_of_trips(grid[1..i+1], capacity) == sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well(grid[i], capacity);\n        assert sum_of_trips(grid[..i+1], capacity) == trips_for_well(grid[0], capacity) + sum_of_trips((grid[1..])[..i-1], capacity) + trips_for_well(grid[i], capacity);\n        assert sum_of_trips(grid[..i+1], capacity) == sum_of_trips(grid[..i], capacity) + trips_for_well(grid[i], capacity);\n    }\n}", "vc-helpers": "", "vc-spec": "method max_fill(grid: seq<seq<int>>, capacity: int) returns (result: int)\n    requires ValidInput(grid, capacity)\n    ensures result >= 0\n    ensures result == sum_of_trips(grid, capacity)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0118", "language": "dafny", "source": "humaneval", "source_id": "humaneval_116_sort_array", "vc-description": "function_signature: def max_fill_count(grid : list[list[int]], capacity : int) -> int\nPlease write a function that sorts an array of non-negative integers according to number of ones in their binary representation in ascending order. For similar number of ones, sort based on decimal value.", "vc-preamble": "function popcount(n: nat): nat {\n  if n == 0 then 0\n  else popcount(n / 2) + n % 2\n}", "vc-helpers": "", "vc-spec": "method sort_array(s: seq<nat>) returns (sorted: seq<nat>)\n\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> popcount(sorted[i]) <= popcount(sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0119", "language": "dafny", "source": "humaneval", "source_id": "humaneval_118_get_closest_vowel", "vc-description": "function_signature: def get_closest_vowel(s : str) -> str\nYou are given a word. Your task is to find the closest vowel that stands between two consonants from the right side of the word (case sensitive).", "vc-preamble": "function IsVowel(c: char) : bool\n{\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n}\nfunction IsConsonant(c: char) : bool\n{\n  ('A' <= c <= 'Z' || 'a' <= c <= 'z') && !IsVowel(c)\n}", "vc-helpers": "", "vc-spec": "method get_closest_vowel(word: string) returns (result: string)\n\n  requires forall i :: 0 <= i < |word| ==> ('A' <= word[i] <= 'Z' || 'a' <= word[i] <= 'z')\n\n  ensures |result| <= 1\n  ensures |result| == 1 ==> IsVowel(result[0])\n  ensures |result| == 1 ==> exists i {:trigger word[i]} ::\n        1 <= i && i + 1 < |word|\n            && IsVowel(word[i]) && IsConsonant(word[i - 1]) && IsConsonant(word[i + 1])\n            && (forall j :: i < j < |word| - 1 ==> !IsVowel(word[j]) || !IsConsonant(word[j - 1]) || !IsConsonant(word[j + 1]))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0120", "language": "dafny", "source": "humaneval", "source_id": "humaneval_119", "vc-description": "Given a list of exactly two strings containing only '(' and ')' characters, determine if it's possible to concatenate them in some order to create a balanced parentheses string. Return 'Yes' if either concatenation order produces a balanced string, 'No' otherwise.", "vc-preamble": "\npredicate valid_paren_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '(' || s[i] == ')'\n}\n\nfunction is_balanced_helper(s: string, depth: int): int\n{\n    if |s| == 0 then depth\n    else if s[0] == '(' then is_balanced_helper(s[1..], depth + 1)\n    else if s[0] == ')' then \n        if depth > 0 then is_balanced_helper(s[1..], depth - 1)\n        else -1\n    else is_balanced_helper(s[1..], depth)\n}\n\nfunction is_balanced(s: string): bool\n{\n    is_balanced_helper(s, 0) == 0\n}\n\npredicate ValidInput(lst: seq<string>)\n{\n    |lst| == 2 && valid_paren_string(lst[0]) && valid_paren_string(lst[1])\n}\n\npredicate CorrectOutput(lst: seq<string>, result: string)\n    requires ValidInput(lst)\n{\n    (result == \"Yes\" || result == \"No\") &&\n    (result == \"Yes\" <==> (is_balanced(lst[0] + lst[1]) || is_balanced(lst[1] + lst[0])))\n}", "vc-helpers": "", "vc-spec": "method match_parens(lst: seq<string>) returns (result: string)\n    requires ValidInput(lst)\n    ensures CorrectOutput(lst, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0121", "language": "dafny", "source": "humaneval", "source_id": "humaneval_120_maximum__SortSeq", "vc-description": "function_signature: method SortSeq(s: seq<int>) returns (sorted: seq<int>)\nSort elements. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method SortSeq(s: seq<int>) returns (sorted: seq<int>)\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && s[i] == sorted[j]\n  ensures forall x :: x in s ==> x in sorted\n  ensures forall i :: 0 <= i < |s| ==> exists j :: 0 <= j < |sorted| && sorted[i] == s[j]\n  ensures forall x :: x in sorted ==> x in s", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0122", "language": "dafny", "source": "humaneval", "source_id": "humaneval_120_maximum__maximum", "vc-description": "function_signature: method maximum(s: seq<int>, k: int) returns (result: seq<int>)\nProcess input. Requires: the size is bounded; the size is bounded; the condition holds for all values. Ensures: returns the correct size/count; the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method maximum(s: seq<int>, k: int) returns (result: seq<int>)\n\n  requires 1 <= k <= |s|\n  requires 1 <= |s| <= 1000\n  requires forall x :: x in s ==> -1000 <= x <= 1000\n\n  ensures |result| == k\n  ensures forall i, j :: 0 <= i < j < k ==> result[i] <= result[j]\n  ensures forall x :: x in result ==> x in s", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0123", "language": "dafny", "source": "humaneval", "source_id": "humaneval_121", "vc-description": "This task requires implementing a method that calculates the sum of all odd numbers located at even-indexed positions in a non-empty sequence of integers. The positions are 0-indexed, so we consider positions 0, 2, 4, etc.", "vc-preamble": "\nfunction SumOddAtEvenPositions(lst: seq<int>, pos: int): int\n    requires 0 <= pos\n    decreases |lst| - pos\n{\n    if pos >= |lst| then 0\n    else if lst[pos] % 2 == 1 then lst[pos] + SumOddAtEvenPositions(lst, pos + 2)\n    else SumOddAtEvenPositions(lst, pos + 2)\n}", "vc-helpers": "", "vc-spec": "method solution(lst: seq<int>) returns (result: int)\n    requires |lst| > 0\n    ensures result == SumOddAtEvenPositions(lst, 0)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0124", "language": "dafny", "source": "humaneval", "source_id": "humaneval_122", "vc-description": "This verification task involves computing the sum of all elements that have at most two digits among the first k elements of an array. An element has at most two digits if its absolute value is between 0 and 99 (inclusive).", "vc-preamble": "\npredicate ValidInput(arr: seq<int>, k: int) {\n  1 <= |arr| <= 100 && 1 <= k <= |arr|\n}\n\nfunction sum_valid_elements(arr: seq<int>, k: int): int\n  requires 0 <= k <= |arr|\n{\n  sum_valid_elements_up_to(arr, k)\n}\n\nfunction sum_valid_elements_up_to(arr: seq<int>, n: int): int\n  requires 0 <= n <= |arr|\n{\n  if n == 0 then 0\n  else \n    var current := if -99 <= arr[n-1] <= 99 then arr[n-1] else 0;\n    sum_valid_elements_up_to(arr, n-1) + current\n}", "vc-helpers": "", "vc-spec": "method add_elements(arr: seq<int>, k: int) returns (result: int)\n  requires ValidInput(arr, k)\n  ensures result == sum_valid_elements(arr, k)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0125", "language": "dafny", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__get_odd_collatz", "vc-description": "function_signature: method get_odd_collatz(n: nat) returns (sorted: seq<int>)\nRetrieve elements. Requires: requires n > 1. Ensures: the result is sorted according to the ordering relation; the result is sorted according to the ordering relation.", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}", "vc-helpers": "", "vc-spec": "method get_odd_collatz(n: nat) returns (sorted: seq<int>)\n  decreases *\n  requires n > 1\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]\n  ensures forall i :: 0 <= i < |sorted| ==> sorted[i] % 2 == 1", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0126", "language": "dafny", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__get_odd_collatz_unsorted", "vc-description": "function_signature: method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\nSort elements. Requires: requires n > 1. Ensures: the condition holds for all values; the condition holds for all values.", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}", "vc-helpers": "", "vc-spec": "method get_odd_collatz_unsorted(n: nat) returns (odd_collatz: seq<nat>)\n  decreases *\n  requires n > 1\n  ensures forall i :: 0 <= i < |odd_collatz| ==> odd_collatz[i] % 2 == 1\n  ensures forall i :: 1 <= i < |odd_collatz| ==> odd_collatz[i] == next_odd_collatz(odd_collatz[i - 1])", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0127", "language": "dafny", "source": "humaneval", "source_id": "humaneval_123_get_odd_collatz__next_odd_collatz_iter", "vc-description": "function_signature: method next_odd_collatz_iter(n: nat) returns (next: nat)\nProcess input. Requires: requires n > 0. Ensures: returns the correct value; returns the correct value.", "vc-preamble": "function iterate_to_odd(n: nat): nat\n  requires n % 2 == 0\n  requires n > 0\n  ensures iterate_to_odd(n) % 2 == 1\n{\n  if (n / 2) % 2 == 1 then n / 2 else iterate_to_odd(n / 2)\n}\nfunction next_odd_collatz(n: nat): nat\n  requires n > 0\n{\n  if n % 2 == 0 then iterate_to_odd(n) else iterate_to_odd(3 * n + 1)\n}", "vc-helpers": "", "vc-spec": "method next_odd_collatz_iter(n: nat) returns (next: nat)\n\n  requires n > 0\n\n  ensures next % 2 == 1\n  ensures next == next_odd_collatz(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0128", "language": "dafny", "source": "humaneval", "source_id": "humaneval_124", "vc-description": "Implement a function to validate date strings according to specific formatting and validity rules. The date must be in \"mm-dd-yyyy\" format with exactly two hyphens as separators, contain only numeric components, have a valid month (1-12), and have a valid day for the given month (considering different month lengths including February with 29 days maximum).", "vc-preamble": "\npredicate ValidDateFormat(date: string)\n{\n    |date| > 0 &&\n    count_char(date, '-') == 2 &&\n    (var parts := split_by_hyphen(date);\n     |parts| == 3 &&\n     |parts[0]| > 0 && |parts[1]| > 0 && |parts[2]| > 0 &&\n     is_numeric(parts[0]) && is_numeric(parts[1]) && is_numeric(parts[2]) &&\n     (var month := string_to_int(parts[0]);\n      var day := string_to_int(parts[1]);\n      1 <= month <= 12 &&\n      (if month in {1, 3, 5, 7, 8, 10, 12} then 1 <= day <= 31\n       else if month in {4, 6, 9, 11} then 1 <= day <= 30\n       else 1 <= day <= 29)))\n}\n\nfunction count_char(s: string, c: char): nat\n{\n    if |s| == 0 then 0\n    else if s[0] == c then 1 + count_char(s[1..], c)\n    else count_char(s[1..], c)\n}\n\nfunction is_digit(c: char): bool\n{\n    '0' <= c <= '9'\n}\n\nfunction is_numeric(s: string): bool\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> is_digit(s[i]))\n}\n\nfunction char_to_int(c: char): nat\n    requires is_digit(c)\n{\n    c as nat - '0' as nat\n}\n\nfunction string_to_int(s: string): nat\n    requires is_numeric(s)\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then char_to_int(s[0])\n    else string_to_int(s[..|s|-1]) * 10 + char_to_int(s[|s|-1])\n}\n\nfunction find_first_hyphen(s: string, start: nat): nat\n    requires start <= |s|\n    ensures find_first_hyphen(s, start) >= start\n    ensures find_first_hyphen(s, start) <= |s|\n    ensures find_first_hyphen(s, start) < |s| ==> s[find_first_hyphen(s, start)] == '-'\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == '-' then start\n    else find_first_hyphen(s, start + 1)\n}\n\nfunction split_by_hyphen(s: string): seq<string>\n{\n    var first_hyphen := find_first_hyphen(s, 0);\n    if first_hyphen >= |s| then [s]\n    else \n        var tmpCall1 := find_first_hyphen(s, first_hyphen + 1);\n        var second_hyphen := tmpCall1;\n        if second_hyphen >= |s| then [s[..first_hyphen], s[first_hyphen+1..]]\n        else \n            [s[..first_hyphen], s[first_hyphen+1..second_hyphen], s[second_hyphen+1..]]\n}", "vc-helpers": "", "vc-spec": "method valid_date(date: string) returns (result: bool)\n    ensures result == ValidDateFormat(date)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0129", "language": "dafny", "source": "humaneval", "source_id": "humaneval_125", "vc-description": "This verification task implements a string processing function that applies rules in a specific order. Given a string, it first checks if the string contains whitespace and splits on whitespace if so. If there's no whitespace but the string contains commas, it splits on commas. Otherwise, it counts the lowercase letters that are at odd positions in the alphabet (b, d, f, h, etc.).\n\nThe implementation uses a datatype to represent either a sequence of strings (for splitting results) or an integer count, with helper functions for each operation and appropriate specifications ensuring correctness.", "vc-preamble": "\ndatatype SplitResult = StringSeq(words: seq<string>) | Count(value: int)\n\nfunction contains_space(txt: string): bool\n{\n    exists i :: 0 <= i < |txt| && txt[i] == ' '\n}\n\nfunction contains_comma(txt: string): bool\n{\n    exists i :: 0 <= i < |txt| && txt[i] == ','\n}\nfunction split_on_whitespace(txt: string): seq<string>\n    ensures forall w :: w in split_on_whitespace(txt) ==> |w| > 0\n    ensures forall w :: w in split_on_whitespace(txt) ==> forall c :: c in w ==> c != ' '\n    decreases |txt|\n{\n    if |txt| == 0 then\n        []\n    else\n        split_on_whitespace_helper(txt, 0, [], \"\")\n}\n\nfunction split_on_whitespace_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>\n    requires 0 <= i <= |txt|\n    requires forall w :: w in result ==> |w| > 0\n    requires forall w :: w in result ==> forall c :: c in w ==> c != ' '\n    requires forall c :: c in current_word ==> c != ' '\n    ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> |w| > 0\n    ensures forall w :: w in split_on_whitespace_helper(txt, i, result, current_word) ==> forall c :: c in w ==> c != ' '\n    decreases |txt| - i\n{\n    if i == |txt| then\n        if |current_word| > 0 then\n            result + [current_word]\n        else\n            result\n    else if txt[i] == ' ' then\n        if |current_word| > 0 then\n            split_on_whitespace_helper(txt, i + 1, result + [current_word], \"\")\n        else\n            split_on_whitespace_helper(txt, i + 1, result, \"\")\n    else\n        split_on_whitespace_helper(txt, i + 1, result, current_word + [txt[i]])\n}\n\nfunction split_on_comma(txt: string): seq<string>\n    ensures |split_on_comma(txt)| > 0\n    decreases |txt|\n{\n    if |txt| == 0 then\n        [\"\"]\n    else\n        split_on_comma_helper(txt, 0, [], \"\")\n}\n\nfunction split_on_comma_helper(txt: string, i: int, result: seq<string>, current_word: string): seq<string>\n    requires 0 <= i <= |txt|\n    ensures |split_on_comma_helper(txt, i, result, current_word)| > 0\n    decreases |txt| - i\n{\n    if i == |txt| then\n        result + [current_word]\n    else if txt[i] == ',' then\n        split_on_comma_helper(txt, i + 1, result + [current_word], \"\")\n    else\n        split_on_comma_helper(txt, i + 1, result, current_word + [txt[i]])\n}\n\nfunction count_odd_position_lowercase(txt: string): int\n    ensures count_odd_position_lowercase(txt) >= 0\n    ensures count_odd_position_lowercase(txt) <= |txt|\n{\n    count_odd_position_lowercase_helper(txt, 0)\n}\n\nfunction count_odd_position_lowercase_helper(txt: string, i: int): int\n    requires 0 <= i <= |txt|\n    ensures count_odd_position_lowercase_helper(txt, i) >= 0\n    ensures count_odd_position_lowercase_helper(txt, i) <= |txt| - i\n    decreases |txt| - i\n{\n    if i == |txt| then\n        0\n    else\n        var c := txt[i];\n        var count_rest := count_odd_position_lowercase_helper(txt, i + 1);\n        if 'a' <= c <= 'z' && (c as int - 'a' as int) % 2 == 1 then\n            1 + count_rest\n        else\n            count_rest\n}", "vc-helpers": "", "vc-spec": "method split_words(txt: string) returns (result: SplitResult)\n    ensures (contains_space(txt) ==> result.StringSeq?) &&\n            (!contains_space(txt) && contains_comma(txt) ==> result.StringSeq?) &&\n            (!contains_space(txt) && !contains_comma(txt) ==> result.Count?)\n    ensures contains_space(txt) ==> result == StringSeq(split_on_whitespace(txt))\n    ensures !contains_space(txt) && contains_comma(txt) ==> result == StringSeq(split_on_comma(txt))\n    ensures !contains_space(txt) && !contains_comma(txt) ==> result == Count(count_odd_position_lowercase(txt))\n    ensures result.StringSeq? ==> |result.words| >= 0\n    ensures result.Count? ==> result.value >= 0\n    ensures contains_space(txt) ==> (forall w :: w in result.words ==> |w| > 0)\n    ensures !contains_space(txt) && contains_comma(txt) ==> |result.words| > 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0130", "language": "dafny", "source": "humaneval", "source_id": "humaneval_126", "vc-description": "This verification task checks if a list of non-negative integers satisfies two conditions: (1) the list is sorted in non-decreasing (ascending) order, and (2) no number appears more than twice in the list. The implementation uses helper functions to check these conditions efficiently and returns true if both are met, false otherwise.", "vc-preamble": "\npredicate ValidInput(lst: seq<int>)\n{\n    forall i :: 0 <= i < |lst| ==> lst[i] >= 0\n}\n\npredicate IsSortedAscending(lst: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |lst| ==> lst[i] <= lst[j]\n}\n\npredicate NoMoreThanTwoDuplicates(lst: seq<int>)\n{\n    forall i :: 0 <= i < |lst| ==> count_occurrences(lst, lst[i]) <= 2\n}\n\npredicate ValidList(lst: seq<int>)\n{\n    ValidInput(lst) && IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)\n}\nfunction count_occurrences(lst: seq<int>, value: int): int\n    ensures count_occurrences(lst, value) >= 0\n    ensures count_occurrences(lst, value) <= |lst|\n    ensures count_occurrences(lst, value) == 0 <==> value !in lst\n{\n    if |lst| == 0 then 0\n    else if lst[0] == value then 1 + count_occurrences(lst[1..], value)\n    else count_occurrences(lst[1..], value)\n}\n\nfunction has_more_than_two_occurrences(lst: seq<int>, index: int): bool\n    requires 0 <= index <= |lst|\n    ensures has_more_than_two_occurrences(lst, index) == (exists i :: index <= i < |lst| && count_occurrences(lst, lst[i]) > 2)\n    decreases |lst| - index\n{\n    if index == |lst| then false\n    else if count_occurrences(lst, lst[index]) > 2 then true\n    else has_more_than_two_occurrences(lst, index + 1)\n}\n\nfunction is_sorted_ascending(lst: seq<int>, index: int): bool\n    requires 0 <= index <= |lst|\n    ensures is_sorted_ascending(lst, index) == (forall i, j :: index <= i < j < |lst| ==> lst[i] <= lst[j])\n    decreases |lst| - index\n{\n    if index >= |lst| - 1 then true\n    else if lst[index] > lst[index + 1] then false\n    else is_sorted_ascending(lst, index + 1)\n}\n\nfunction is_sorted(lst: seq<int>): bool\n    requires ValidInput(lst)\n    ensures |lst| <= 1 ==> is_sorted(lst) == true\n    ensures is_sorted(lst) == (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst))\n{\n    if |lst| <= 1 then true\n    else if !is_sorted_ascending(lst, 0) then false\n    else !has_more_than_two_occurrences(lst, 0)\n}", "vc-helpers": "", "vc-spec": "method CheckValidList(lst: seq<int>) returns (result: bool)\n    requires ValidInput(lst)\n    ensures result == ValidList(lst)\n    ensures result == (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0131", "language": "dafny", "source": "humaneval", "source_id": "humaneval_127_intersection", "vc-description": "function_signature: def intersection(interval1: Tuple[Int, Int], interval2: Tuple[Int, Int]) -> str\nYou are given two intervals, where each interval is a pair of integers. For example, interval = (start, end) = (1, 2). The given intervals are closed which means that the interval (start, end) includes both start and end. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number. Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3) which its length is 1, which not a prime number. If the length of the intersection is a prime number, return \"YES\", otherwise, return \"NO\". If the two intervals don't intersect, return \"NO\".", "vc-preamble": "function IsPrime(n: nat) : bool\n{\n  n > 1 &&\n  forall k :: 2 <= k < n ==> n % k != 0\n}\nfunction min(a: int, b: int): int\n{\n  if a <= b then a else b\n}\nfunction max(a: int, b: int): int\n{\n  if a >= b then a else b\n}", "vc-helpers": "", "vc-spec": "method Intersection(start1: int, end1: int, start2: int, end2: int) returns (result: string)\n\n  requires start1 <= end1 && start2 <= end2\n\n  ensures result == \"YES\" || result == \"NO\"\n  ensures result == \"YES\" <==>\n    (max(start1, start2) <= min(end1, end2) &&\n     IsPrime((min(end1, end2) - max(start1, start2) + 1) as nat))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0132", "language": "dafny", "source": "humaneval", "source_id": "humaneval_128", "vc-description": "This task implements a function that calculates the sum of absolute values of all elements in an array, multiplied by the product of signs of all elements. The sign function returns 1 for positive numbers, -1 for negative numbers, and 0 for zero. If the array is empty, the function returns None; otherwise, it returns Some with the computed result.", "vc-preamble": "\ndatatype Option<T> = None | Some(value: T)\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}\n\nfunction sign(x: int): int\n{\n    if x > 0 then 1 else if x < 0 then -1 else 0\n}\n\nfunction sum_of_magnitudes(arr: seq<int>): int\n{\n    if |arr| == 0 then 0 else abs(arr[0]) + sum_of_magnitudes(arr[1..])\n}\n\nfunction product_of_signs(arr: seq<int>): int\n{\n    if |arr| == 0 then 1 else sign(arr[0]) * product_of_signs(arr[1..])\n}\nlemma sum_of_magnitudes_append(arr: seq<int>, i: int)\n    requires 0 <= i < |arr|\n    ensures sum_of_magnitudes(arr[0..i+1]) == sum_of_magnitudes(arr[0..i]) + abs(arr[i])\n{\n    if i == 0 {\n        assert arr[0..1] == [arr[0]];\n        assert arr[0..0] == [];\n    } else {\n        sum_of_magnitudes_append(arr[1..], i-1);\n        assert arr[1..][0..i-1] == arr[1..i];\n        assert arr[1..][0..i] == arr[1..i+1];\n        assert sum_of_magnitudes(arr[1..i+1]) == sum_of_magnitudes(arr[1..i]) + abs(arr[i]);\n        assert sum_of_magnitudes(arr[0..i+1]) == abs(arr[0]) + sum_of_magnitudes(arr[1..i+1]);\n        assert sum_of_magnitudes(arr[0..i]) == abs(arr[0]) + sum_of_magnitudes(arr[1..i]);\n    }\n}\n\nlemma product_of_signs_append(arr: seq<int>, i: int)\n    requires 0 <= i < |arr|\n    ensures product_of_signs(arr[0..i+1]) == product_of_signs(arr[0..i]) * sign(arr[i])\n{\n    if i == 0 {\n        assert arr[0..1] == [arr[0]];\n        assert arr[0..0] == [];\n    } else {\n        product_of_signs_append(arr[1..], i-1);\n        assert arr[1..][0..i-1] == arr[1..i];\n        assert arr[1..][0..i] == arr[1..i+1];\n        assert product_of_signs(arr[1..i+1]) == product_of_signs(arr[1..i]) * sign(arr[i]);\n        assert product_of_signs(arr[0..i+1]) == sign(arr[0]) * product_of_signs(arr[1..i+1]);\n        assert product_of_signs(arr[0..i]) == sign(arr[0]) * product_of_signs(arr[1..i]);\n    }\n}", "vc-helpers": "", "vc-spec": "method prod_signs(arr: seq<int>) returns (result: Option<int>)\n    ensures |arr| == 0 ==> result == None\n    ensures |arr| > 0 ==> result == Some(sum_of_magnitudes(arr) * product_of_signs(arr))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0133", "language": "dafny", "source": "humaneval", "source_id": "humaneval_130_tri", "vc-description": "function_signature: def tri(n: int) -> List[int]\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in the last couple centuries. However, what people don't know is Tribonacci sequence. Tribonacci sequence is defined by the recurrence: tri(1) = 3 tri(n) = 1 + n / 2, if n is even. tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd. For example: tri(2) = 1 + (2 / 2) = 2 tri(4) = 3 tri(3) = tri(2) + tri(1) + tri(4) = 2 + 3 + 3 = 8 You are given a non-negative integer number n, you have to a return a list of the first n + 1 numbers of the Tribonacci sequence.", "vc-preamble": "function tri(n: nat): nat\n  decreases if n % 2 == 0 then 0 else n\n{\n  if n == 1 then 3\n  else if n % 2 == 0 then 1 + n / 2\n  else tri(n - 1) + tri(n - 2) + tri(n + 1)\n}", "vc-helpers": "", "vc-spec": "method Tribonacci(n: nat) returns (result: seq<nat>)\n\n  ensures |result| == n + 1\n  ensures forall i :: 0 <= i <= n ==> result[i] == tri(i)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0134", "language": "dafny", "source": "humaneval", "source_id": "humaneval_132_is_nested", "vc-description": "function_signature: def is_nested(string: str) -> Bool\nCreate a function that takes a string as input which contains only parentheses. The function should return True if and only if there is a valid subsequence of parentheses where at least one parenthesis in the subsequence is nested.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method is_nested(s: seq<int>) returns (res: bool) \n\n    ensures res == exists x, y, z, w :: 0 <= x < y < z < w < |s| && s[x] == 0 && s[y] == 0 && s[z] == 1 && s[w] == 1", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0135", "language": "dafny", "source": "humaneval", "source_id": "humaneval_133_sum_squares", "vc-description": "function_signature: def sum_squares(lst: List[float]) -> int\nYou are given a list of numbers. You need to return the sum of squared numbers in the given list, round each element in the list to the upper int(Ceiling) first.", "vc-preamble": "function sum(s: seq<int>) : int\n    {\n        if |s| == 0 then 0 else s[0] + sum(s[1..])\n    }\nfunction ceil(f: real) : (c : int)\n    {\n        (f + 1.0).Floor\n    }\nfunction square_seq(lst: seq<real>) : (sq : seq<int>)\n        ensures |sq| == |lst|\n    {\n        seq(|lst|, i requires 0 <= i < |lst| => ceil(lst[i]) * ceil(lst[i]))\n    }", "vc-helpers": "", "vc-spec": "method sum_squares(lst: seq<real>) returns (r : int)\n\n    ensures r == sum(square_seq(lst))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0136", "language": "dafny", "source": "humaneval", "source_id": "humaneval_134", "vc-description": "This verification task involves implementing a method to determine if the last character of a string is an alphabetical character that stands alone (not part of a word). A \"word\" is defined as a group of characters separated by spaces. The method should return true if the last character is a letter AND is not part of a word, false otherwise. A standalone letter is either the entire string (single character) or a letter preceded by a space.", "vc-preamble": "\npredicate IsAlpha(c: char)\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\npredicate ValidLastCharIsStandaloneLetter(txt: string)\n{\n    |txt| > 0 && IsAlpha(txt[|txt| - 1]) && (|txt| == 1 || txt[|txt| - 2] == ' ')\n}", "vc-helpers": "", "vc-spec": "method check_if_last_char_is_a_letter(txt: string) returns (result: bool)\n    ensures result == ValidLastCharIsStandaloneLetter(txt)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0137", "language": "dafny", "source": "humaneval", "source_id": "humaneval_135", "vc-description": "The task is to find the largest index in an array of distinct integers where an element is smaller than the element immediately before it. If no such index exists (i.e., the array is non-decreasing), return -1. The implementation should scan from right to left to efficiently find the largest such index.", "vc-preamble": "\npredicate ValidInput(arr: seq<int>) {\n    forall i, j :: 0 <= i < j < |arr| ==> arr[i] != arr[j]\n}\n\npredicate HasDecreaseAt(arr: seq<int>, i: int) {\n    1 <= i < |arr| && arr[i] < arr[i-1]\n}\n\npredicate IsLargestDecreaseIndex(arr: seq<int>, result: int) {\n    HasDecreaseAt(arr, result) && \n    (forall j :: result < j < |arr| ==> arr[j] >= arr[j-1])\n}\n\npredicate IsNonDecreasing(arr: seq<int>) {\n    forall i :: 1 <= i < |arr| ==> arr[i] >= arr[i-1]\n}", "vc-helpers": "", "vc-spec": "method can_arrange(arr: seq<int>) returns (result: int)\n    requires ValidInput(arr)\n    ensures result == -1 || (0 < result < |arr|)\n    ensures result == -1 ==> IsNonDecreasing(arr)\n    ensures result != -1 ==> IsLargestDecreaseIndex(arr, result)\n    ensures result != -1 ==> (exists i :: HasDecreaseAt(arr, i))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0138", "language": "dafny", "source": "humaneval", "source_id": "humaneval_136_largest_smallest_integers", "vc-description": "function_signature: def largest_smallest_integers(lst: List[int]) -> Tuple[ Optional[Int], Optional[Int] ]\nCreate a function that returns a tuple (a, b), where 'a' is the largest of negative integers, and 'b' is the smallest of positive integers in a list. If there is no negative or positive integers, return them as None.", "vc-preamble": "datatype Option<T> = None | Some(value: T)\nfunction get_value(o: Option<int>): int\n  requires o.Some?\n  ensures get_value(o) == o.value\n{\n  o.value\n}", "vc-helpers": "", "vc-spec": "method largest_smallest_integers(arr: seq<int>) returns (a: Option<int>, b: Option<int>)\n\n  ensures a.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n  ensures a.Some? ==> get_value(a) in arr && get_value(a) < 0\n  ensures a.Some? ==> forall i :: 0 <= i < |arr| && arr[i] < 0 ==> arr[i] <= get_value(a)\n  ensures b.None? ==> forall i :: 0 <= i < |arr| ==> arr[i] <= 0\n  ensures b.Some? ==> get_value(b) in arr && get_value(b) > 0\n  ensures b.Some? ==> forall i :: 0 <= i < |arr| && arr[i] > 0 ==> arr[i] >= get_value(b)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0139", "language": "dafny", "source": "humaneval", "source_id": "humaneval_137", "vc-description": "This verification task implements a function that compares two values of different types (integers, reals, or strings representing real numbers) and returns the larger one in its original format. If the values are numerically equal, the function returns None. The challenge is handling different value types while maintaining their original representation in the result.", "vc-preamble": "\ndatatype Value = Int(i: int) | Real(r: real) | Str(s: string)\n\ndatatype Option<T> = None | Some(value: T)\n\npredicate IsValidNumericString(s: string)\n{\n    true\n}\n\nfunction ValueToReal(v: Value): real\n    requires v.Str? ==> IsValidNumericString(v.s)\n{\n    match v {\n        case Int(i) => i as real\n        case Real(r) => r\n        case Str(s) => StringToReal(s)\n    }\n}\n\nfunction StringToReal(s: string): real\n    requires IsValidNumericString(s)\n{\n    0.0\n}", "vc-helpers": "", "vc-spec": "method compare_one(a: Value, b: Value) returns (result: Option<Value>)\n    requires (a.Str? ==> IsValidNumericString(a.s))\n    requires (b.Str? ==> IsValidNumericString(b.s))\n    ensures ValueToReal(a) == ValueToReal(b) <==> result == None\n    ensures ValueToReal(a) > ValueToReal(b) <==> result == Some(a)\n    ensures ValueToReal(b) > ValueToReal(a) <==> result == Some(b)\n    ensures result.Some? ==> (result.value == a || result.value == b)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0140", "language": "dafny", "source": "humaneval", "source_id": "humaneval_138", "vc-description": "This verification task determines whether a given positive integer n can be expressed as the sum of exactly 4 positive even numbers. The key insight is that the minimum sum is 8 (2+2+2+2), and only even numbers can be expressed this way since the sum of 4 even numbers is always even.", "vc-preamble": "\npredicate ValidInput(n: int)\n{\n    n > 0\n}\n\npredicate CanBeSumOfFourPositiveEvens(n: int)\n{\n    n % 2 == 0 && n >= 8\n}", "vc-helpers": "", "vc-spec": "method is_equal_to_sum_even(n: int) returns (result: bool)\n    requires ValidInput(n)\n    ensures result == CanBeSumOfFourPositiveEvens(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0141", "language": "dafny", "source": "humaneval", "source_id": "humaneval_139", "vc-description": "Compute the special factorial of a positive integer n, defined as the product of all factorials from 1! to n!: special_factorial(n) = n! × (n-1)! × (n-2)! × ... × 1!. The implementation should use an iterative approach with proper loop invariants to ensure correctness.", "vc-preamble": "\nfunction factorial_func(num: int): int\n    requires num >= 0\n{\n    if num <= 1 then 1 else num * factorial_func(num - 1)\n}\n\nfunction special_factorial_func(n: int): int\n    requires n >= 0\n{\n    if n <= 0 then 1\n    else special_factorial_func(n - 1) * factorial_func(n)\n}\nmethod factorial(num: int) returns (result: int)\n    requires num >= 0\n    ensures result == factorial_func(num)\n    ensures result > 0\n{\n    if num <= 1 {\n        return 1;\n    }\n    result := 1;\n    var i := 2;\n    while i <= num\n        invariant 2 <= i <= num + 1\n        invariant result == factorial_func(i - 1)\n        invariant result > 0\n    {\n        result := result * i;\n        i := i + 1;\n    }\n}", "vc-helpers": "", "vc-spec": "method special_factorial(n: int) returns (result: int)\n    requires n >= 0\n    ensures result == special_factorial_func(n)\n    ensures result > 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0143", "language": "dafny", "source": "humaneval", "source_id": "humaneval_142", "vc-description": "Transform each element in a list of integers based on its index position: square elements at indices that are multiples of 3, cube elements at indices that are multiples of 4 but not 3, and leave other elements unchanged. Return the sum of all transformed elements.", "vc-preamble": "\nfunction transform_element(value: int, index: int): int\n{\n    if index % 3 == 0 then value * value\n    else if index % 4 == 0 then value * value * value\n    else value\n}\n\nfunction sum_partial(lst: seq<int>, n: int): int\n    requires 0 <= n <= |lst|\n{\n    if n == 0 then 0\n    else sum_partial(lst, n-1) + transform_element(lst[n-1], n-1)\n}\n\nfunction sum_transformed(lst: seq<int>): int\n{\n    sum_partial(lst, |lst|)\n}", "vc-helpers": "", "vc-spec": "method sum_squares(lst: seq<int>) returns (result: int)\n    ensures result == sum_transformed(lst)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0144", "language": "dafny", "source": "humaneval", "source_id": "humaneval_144", "vc-description": "This verification challenge involves implementing a method that determines if the product of two fractions is a whole number. Given two fractions represented as strings in the format \"numerator/denominator\", the task is to multiply them and check if the result is an integer (i.e., the numerator of the product is divisible by the denominator).\n\nThe implementation must correctly parse the fraction strings, extract numerators and denominators, perform the multiplication, and check divisibility while maintaining all verification conditions.", "vc-preamble": "\npredicate ValidFraction(s: string)\n{\n    |s| > 0 && \n    (exists i :: 0 <= i < |s| && s[i] == '/') &&\n    (forall j :: 0 <= j < |s| ==> (s[j] == '/' || ('0' <= s[j] <= '9'))) &&\n    (exists k :: 0 <= k < |s| && s[k] == '/' && \n        |s[0..k]| > 0 && |s[k+1..]| > 0 &&\n        StringToInt(s[0..k]) > 0 && StringToInt(s[k+1..]) > 0) &&\n    (forall i :: 0 <= i < |s| && s[i] == '/' ==> \n        |s[0..i]| > 0 && |s[i+1..]| > 0 &&\n        StringToInt(s[0..i]) > 0 && StringToInt(s[i+1..]) > 0)\n}\n\nfunction GetNumerator(s: string): int\n    requires ValidFraction(s)\n{\n    var slash_pos := FindSlash(s);\n    StringToInt(s[0..slash_pos])\n}\n\nfunction GetDenominator(s: string): int\n    requires ValidFraction(s)\n    ensures GetDenominator(s) > 0\n{\n    var slash_pos := FindSlash(s);\n    StringToInt(s[slash_pos+1..])\n}\n\nfunction FindSlash(s: string): int\n    requires exists i :: 0 <= i < |s| && s[i] == '/'\n    ensures 0 <= FindSlash(s) < |s|\n    ensures s[FindSlash(s)] == '/'\n{\n    FindSlashHelper(s, 0)\n}\n\nfunction StringToInt(s: string): int\n{\n    StringToIntHelper(s, 0)\n}\n\nfunction CharToInt(c: char): int\n{\n    if c == '0' then 0\n    else if c == '1' then 1\n    else if c == '2' then 2\n    else if c == '3' then 3\n    else if c == '4' then 4\n    else if c == '5' then 5\n    else if c == '6' then 6\n    else if c == '7' then 7\n    else if c == '8' then 8\n    else if c == '9' then 9\n    else 0\n}\nfunction FindSlashHelper(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires exists i :: pos <= i < |s| && s[i] == '/'\n    ensures pos <= FindSlashHelper(s, pos) < |s|\n    ensures s[FindSlashHelper(s, pos)] == '/'\n    decreases |s| - pos\n{\n    if pos < |s| && s[pos] == '/' then pos\n    else FindSlashHelper(s, pos + 1)\n}\n\nfunction StringToIntHelper(s: string, acc: int): int\n{\n    if |s| == 0 then acc\n    else StringToIntHelper(s[1..], acc * 10 + CharToInt(s[0]))\n}", "vc-helpers": "", "vc-spec": "method simplify(x: string, n: string) returns (result: bool)\n    requires |x| > 0 && |n| > 0\n    requires exists i :: 0 <= i < |x| && x[i] == '/'\n    requires exists j :: 0 <= j < |n| && n[j] == '/'\n    requires forall i :: 0 <= i < |x| ==> (x[i] == '/' || ('0' <= x[i] <= '9'))\n    requires forall j :: 0 <= j < |n| ==> (n[j] == '/' || ('0' <= n[j] <= '9'))\n    requires ValidFraction(x)\n    requires ValidFraction(n)\n    ensures result <==> (GetNumerator(x) * GetNumerator(n)) % (GetDenominator(x) * GetDenominator(n)) == 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0145", "language": "dafny", "source": "humaneval", "source_id": "humaneval_145_order_by_points", "vc-description": "function_signature: def order_by_points(nums: List[int]) -> List[int]\nWrite a function which sorts the given list of integers in ascending order according to the sum of their digits. Note: if there are several items with similar sum of their digits, order them based on their index in original list.", "vc-preamble": "function digits_sum_pos(n: int): int\n  requires n >= 0\n{\n  if n < 10 then n else digits_sum_pos(n / 10) + n % 10\n}\nfunction digits_sum(n: int): int {\n  if n < 0 then digits_sum_pos(-n) else digits_sum_pos(n)\n}", "vc-helpers": "", "vc-spec": "method order_by_points(s: seq<int>) returns (sorted: seq<int>)\n\n  ensures forall i, j :: 0 <= i < j < |sorted| ==> digits_sum(sorted[i]) <= digits_sum(sorted[j])\n  ensures |sorted| == |s|\n  ensures multiset(s) == multiset(sorted)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0146", "language": "dafny", "source": "humaneval", "source_id": "humaneval_146", "vc-description": "Count the numbers in an array that satisfy all three conditions: 1) Greater than 10, 2) First digit is odd (1, 3, 5, 7, 9), and 3) Last digit is odd (1, 3, 5, 7, 9).", "vc-preamble": "\nfunction FirstDigit(n: int): int\n  requires n > 0\n{\n  if n < 10 then n else FirstDigit(n / 10)\n}\n\nfunction LastDigit(n: int): int\n  requires n > 0\n{\n  n % 10\n}\n\nfunction IsOdd(n: int): bool\n{\n  n == 1 || n == 3 || n == 5 || n == 7 || n == 9\n}\n\npredicate SatisfiesCondition(n: int)\n{\n  n > 10 && IsOdd(FirstDigit(n)) && IsOdd(LastDigit(n))\n}\n\npredicate ValidInput(nums: seq<int>)\n{\n  true\n}\nfunction CountHelper(nums: seq<int>, index: int): int\n  requires 0 <= index <= |nums|\n  decreases |nums| - index\n  ensures CountHelper(nums, index) >= 0\n  ensures CountHelper(nums, index) <= |nums| - index\n{\n  if index == |nums| then 0\n  else\n    var current := nums[index];\n    var contribution := if SatisfiesCondition(current) then 1 else 0;\n    contribution + CountHelper(nums, index + 1)\n}\n\nlemma CountHelperCorrectness(nums: seq<int>, index: int)\n  requires 0 <= index <= |nums|\n  ensures CountHelper(nums, index) == |set i | index <= i < |nums| && SatisfiesCondition(nums[i])|\n  decreases |nums| - index\n{\n  if index == |nums| {\n    assert (set i | index <= i < |nums| && SatisfiesCondition(nums[i])) == {};\n  } else {\n    CountHelperCorrectness(nums, index + 1);\n    var setWithIndex := set i | index <= i < |nums| && SatisfiesCondition(nums[i]);\n    var setWithoutIndex := set i | index + 1 <= i < |nums| && SatisfiesCondition(nums[i]);\n\n    if SatisfiesCondition(nums[index]) {\n      assert setWithIndex == {index} + setWithoutIndex;\n      assert index !in setWithoutIndex;\n      assert |setWithIndex| == 1 + |setWithoutIndex|;\n    } else {\n      assert setWithIndex == setWithoutIndex;\n    }\n  }\n}", "vc-helpers": "", "vc-spec": "method SpecialFilter(nums: seq<int>) returns (count: int)\n  requires ValidInput(nums)\n  ensures count >= 0\n  ensures count <= |nums|\n  ensures count == |set i | 0 <= i < |nums| && SatisfiesCondition(nums[i])|\n  ensures nums == [] ==> count == 0\n  ensures forall i :: 0 <= i < |nums| && SatisfiesCondition(nums[i]) ==> nums[i] > 10 && IsOdd(FirstDigit(nums[i])) && IsOdd(LastDigit(nums[i]))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0147", "language": "dafny", "source": "humaneval", "source_id": "humaneval_147", "vc-description": "This verification task involves counting valid triples from a special array. Given a positive integer n, create an array where each element a[i] = i² - i + 1 for positions 1 to n. The goal is to count the number of triples (a[i], a[j], a[k]) where i < j < k and their sum is divisible by 3.\n\nThe implementation uses the mathematical insight that elements can be categorized by their modulo 3 value, and valid triples must either come from all elements with the same modulo value.", "vc-preamble": "\nfunction array_element(i: int): int\n  requires i >= 1\n{\n  i * i - i + 1\n}\n\nfunction count_elements_mod_0(n: int): int\n  requires n >= 0\n  ensures count_elements_mod_0(n) >= 0\n{\n  if n == 0 then 0\n  else if n % 3 == 2 then 1 + count_elements_mod_0(n - 1)\n  else count_elements_mod_0(n - 1)\n}\n\nfunction count_elements_mod_1(n: int): int\n  requires n >= 0\n  ensures count_elements_mod_1(n) >= 0\n{\n  if n == 0 then 0\n  else if n % 3 != 2 then 1 + count_elements_mod_1(n - 1)\n  else count_elements_mod_1(n - 1)\n}\n\nfunction combination(n: int, k: int): int\n  requires n >= 0 && k >= 0\n  ensures combination(n, k) >= 0\n  ensures k > n ==> combination(n, k) == 0\n  ensures k == 0 || k == n ==> combination(n, k) == 1\n  ensures k == 1 ==> combination(n, k) == n\n  ensures k == 2 && n >= 2 ==> combination(n, k) == n * (n - 1) / 2\n  ensures k == 3 && n >= 3 ==> combination(n, k) == n * (n - 1) * (n - 2) / 6\n{\n  if k > n || k < 0 then 0\n  else if k == 0 || k == n then 1\n  else if k == 1 then n\n  else if k == 2 then n * (n - 1) / 2\n  else if k == 3 then n * (n - 1) * (n - 2) / 6\n  else 0\n}\n\nfunction count_valid_triples(n: int): int\n  requires n >= 1\n{\n  var count_0 := count_elements_mod_0(n);\n  var count_1 := count_elements_mod_1(n);\n  combination(count_0, 3) + combination(count_1, 3)\n}\n\npredicate ValidInput(n: int)\n{\n  n >= 1\n}", "vc-helpers": "", "vc-spec": "method get_max_triples(n: int) returns (result: int)\n  requires ValidInput(n)\n  ensures result >= 0\n  ensures result == count_valid_triples(n)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0148", "language": "dafny", "source": "humaneval", "source_id": "humaneval_148_bf", "vc-description": "function_signature: def bf(planet1: str, planet2: str) -> List[str]\nThere are eight planets in our solar system: the closest to the Sun is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write a function that takes two planet names as strings planet1 and planet2. The function should return a tuple containing all planets whose orbits are located between the orbit of planet1 and the orbit of planet2, sorted by the proximity to the sun. The function should return an empty tuple if planet1 or planet2 are not correct planet names.", "vc-preamble": "datatype Planet = Mercury | Venus | Earth | Mars | Jupiter | Saturn | Uranus | Neptune\ndatatype Option<T> = Some(value: T) | None\nfunction PlanetFromString(name: string): Option<Planet>\n  ensures PlanetFromString(name).Some? ==> 0 <= PlanetIndex(PlanetFromString(name).value) <= 7\n{\n  match name\n  case \"Mercury\" => Some(Mercury)\n  case \"Venus\" => Some(Venus)\n  case \"Earth\" => Some(Earth)\n  case \"Mars\" => Some(Mars)\n  case \"Jupiter\" => Some(Jupiter)\n  case \"Saturn\" => Some(Saturn)\n  case \"Uranus\" => Some(Uranus)\n  case \"Neptune\" => Some(Neptune)\n  case _ => None\n}\nfunction PlanetIndex(p: Planet): int\n{\n  match p\n  case Mercury => 0\n  case Venus => 1\n  case Earth => 2\n  case Mars => 3\n  case Jupiter => 4\n  case Saturn => 5\n  case Uranus => 6\n  case Neptune => 7\n}\nfunction GetPlanetsBetween(planet1: string, planet2: string): seq<string>\n\n  ensures |GetPlanetsBetween(planet1, planet2)| <= 6\n\n{\n\n  var p1 := PlanetFromString(planet1);\n  var p2 := PlanetFromString(planet2);\n  if p1.None? || p2.None? then\n    []\n  else\n    var i1 := PlanetIndex(p1.value);\n    var i2 := PlanetIndex(p2.value);\n    if i1 < i2 then\n      GetPlanetsBetweenIndices(i1 + 1, i2 - 1)\n    else if i1 > i2 then\n      GetPlanetsBetweenIndices(i2 + 1, i1 - 1)\n    else\n      []\n\n}\nfunction GetPlanetsBetweenIndices(start: int, end: int): seq<string>\n\n  requires 0 <= start <= 7 && 0 <= end <= 7\n\n  ensures |GetPlanetsBetweenIndices(start, end)| <= (if start <= end then end - start + 1 else 0)\n\n  decreases if start <= end then end - start + 1 else 0\n{\n\n  if start > end then\n    []\n  else\n    match start\n    case 0 => [\"Mercury\"] + GetPlanetsBetweenIndices(1, end)\n    case 1 => [\"Venus\"] + GetPlanetsBetweenIndices(2, end)\n    case 2 => [\"Earth\"] + GetPlanetsBetweenIndices(3, end)\n    case 3 => [\"Mars\"] + GetPlanetsBetweenIndices(4, end)\n    case 4 => [\"Jupiter\"] + GetPlanetsBetweenIndices(5, end)\n    case 5 => [\"Saturn\"] + GetPlanetsBetweenIndices(6, end)\n    case 6 => [\"Uranus\"] + GetPlanetsBetweenIndices(7, end)\n    case 7 => [\"Neptune\"]\n\n}", "vc-helpers": "", "vc-spec": "method bf(start: int, end: int) returns (planets: seq<string>)\n\n    requires 0 <= start <= 7 && 0 <= end <= 7\n\n    ensures |planets| <= (if start <= end then end - start + 1 else 0)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0149", "language": "dafny", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sort_lengths", "vc-description": "function_signature: method sort_lengths(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Requires: the condition holds for all values. Ensures: the result is sorted according to the ordering relation; returns the correct size/count; returns a sorted permutation of the input; the result is sorted according to the ordering relation.", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}", "vc-helpers": "", "vc-spec": "method sort_lengths(list: seq<string>) returns (sorted: seq<string>)\n    requires forall i : int :: 0 <= i < |list| ==> |list[i]| % 2 == 0\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0150", "language": "dafny", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sort_strings", "vc-description": "function_signature: method sort_strings(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Ensures: returns the correct size/count; returns a sorted permutation of the input.", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}", "vc-helpers": "", "vc-spec": "method sort_strings(list: seq<string>) returns (sorted: seq<string>)\n    ensures |sorted| == |list|\n    ensures multiset(sorted) == multiset(list)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0151", "language": "dafny", "source": "humaneval", "source_id": "humaneval_149_sorted_list_sum__sorted_list_sum", "vc-description": "function_signature: method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\nSort elements. Requires: requires size of listsize of  > 0. Ensures: the size is bounded; the result is sorted according to the ordering relation; the result is sorted according to the ordering relation; returns a sorted permutation of the input.", "vc-preamble": "function comparison(a : string, b : string, i : int): bool\n    requires 0 <= i <= |a| && 0 <= i <= |b|\n    decreases |a| - i\n    decreases |b| - i\n    ensures (a == b) ==> comparison(a, b, i)\n{\n    if (i < |a| && i < |b|) then\n        if a[i] < b[i] then\n            true\n        else if a[i] > b[i] then\n            false\n        else\n            comparison(a, b, i + 1)\n    else\n        if |a| <= |b| then\n            true\n        else\n            false\n}", "vc-helpers": "", "vc-spec": "method sorted_list_sum(list: seq<string>) returns (sorted: seq<string>)\n    requires |list| > 0\n    ensures |sorted| <= |list|\n    ensures forall i : int :: 0 <= i < |sorted| ==> |sorted[i]| % 2 == 0\n    ensures forall x : int, y : int :: 0 <= x < y < |sorted| ==> |sorted[x]| <= |sorted[y]|\n    ensures multiset(sorted) <= multiset(list)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0152", "language": "dafny", "source": "humaneval", "source_id": "humaneval_150_x_or_y", "vc-description": "function_signature: def x_or_y(int n, int x, int y) -> int\nA simple program which should return the value of x if n is a prime number and should return the value of y otherwise.", "vc-preamble": "function IsPrime(n: nat) : bool\n{\n  n > 1 &&\n  forall k :: 2 <= k < n ==> n % k != 0\n}", "vc-helpers": "", "vc-spec": "method x_or_y(n: nat, x: int, y: int) returns (result: int)\n\n  ensures IsPrime(n) ==> result == x\n  ensures !IsPrime(n) ==> result == y", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0153", "language": "dafny", "source": "humaneval", "source_id": "humaneval_151", "vc-description": "This verification task implements a function that computes the sum of squares of all positive odd integers in a list containing both integers and real numbers. The function should ignore negative numbers and non-integers, returning 0 for an empty list.\n\nThe implementation needs to handle a mixed datatype that can represent both integers and reals, properly identify positive odd integers (including reals that represent integers), and maintain correctness through loop invariants.", "vc-preamble": "\ndatatype Number = Int(i: int) | Real(r: real)\n\nfunction IsInteger(r: real): bool\n{\n    r == r.Floor as real\n}\n\npredicate IsPositiveOddInteger(n: Number)\n{\n    match n\n    case Int(i) => i > 0 && i % 2 == 1\n    case Real(r) => IsInteger(r) && r > 0.0 && (r.Floor as int) % 2 == 1\n}\n\nfunction SquareValue(n: Number): int\n    requires IsPositiveOddInteger(n)\n    ensures SquareValue(n) > 0\n{\n    match n\n    case Int(i) => i * i\n    case Real(r) => (r.Floor as int) * (r.Floor as int)\n}\n\nfunction SumOfSquares(lst: seq<Number>, i: nat): int\n    requires i <= |lst|\n    ensures SumOfSquares(lst, i) >= 0\n{\n    if i == 0 then 0\n    else if IsPositiveOddInteger(lst[i-1]) then\n        SquareValue(lst[i-1]) + SumOfSquares(lst, i-1)\n    else\n        SumOfSquares(lst, i-1)\n}", "vc-helpers": "", "vc-spec": "method double_the_difference(lst: seq<Number>) returns (result: int)\n    ensures result >= 0\n    ensures result == SumOfSquares(lst, |lst|)\n    ensures |lst| == 0 ==> result == 0", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0154", "language": "dafny", "source": "humaneval", "source_id": "humaneval_152", "vc-description": "This verification task involves implementing a function that compares two arrays of equal length representing actual game scores and guessed scores. The implementation should calculate how far off each guess was from the actual result by computing the absolute difference between corresponding elements.", "vc-preamble": "predicate ValidInput(game: seq<int>, guess: seq<int>)\n{\n  |game| == |guess|\n}\n\npredicate ValidOutput(game: seq<int>, guess: seq<int>, result: seq<int>)\n  requires |game| == |guess|\n{\n  && |result| == |game|\n  && (forall i :: 0 <= i < |game| ==> result[i] == abs(game[i] - guess[i]))\n  && (forall i :: 0 <= i < |result| ==> result[i] >= 0)\n}\nfunction abs(x: int): int\n{\n  if x >= 0 then x else -x\n}", "vc-helpers": "", "vc-spec": "method compare(game: seq<int>, guess: seq<int>) returns (result: seq<int>)\n  requires ValidInput(game, guess)\n  ensures ValidOutput(game, guess, result)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0155", "language": "dafny", "source": "humaneval", "source_id": "humaneval_153", "vc-description": "Given a class name (string) and a list of extension names (strings), find the \"strongest\" extension and return the result in the format \"ClassName.StrongestExtensionName\". The strength of an extension is calculated as: (number of uppercase letters) - (number of lowercase letters). Choose the extension with the highest strength value. If multiple extensions have the same highest strength, choose the first one that appears in the list.", "vc-preamble": "\nfunction count_upper(s: string): int\n{\n    if |s| == 0 then 0\n    else (if 'A' <= s[0] <= 'Z' then 1 else 0) + count_upper(s[1..])\n}\n\nfunction count_lower(s: string): int\n{\n    if |s| == 0 then 0\n    else (if 'a' <= s[0] <= 'z' then 1 else 0) + count_lower(s[1..])\n}\n\nfunction strength(s: string): int\n{\n    count_upper(s) - count_lower(s)\n}", "vc-helpers": "", "vc-spec": "method Strongest_Extension(class_name: string, extensions: seq<string>) returns (result: string)\n    requires |extensions| > 0\n    ensures exists i :: (0 <= i < |extensions| && result == class_name + \".\" + extensions[i] &&\n            (forall j :: 0 <= j < |extensions| ==> strength(extensions[i]) >= strength(extensions[j])) &&\n            (forall j :: 0 <= j < i ==> strength(extensions[j]) < strength(extensions[i])))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0156", "language": "dafny", "source": "humaneval", "source_id": "humaneval_154_cycpattern_check", "vc-description": "function_signature: def cycpattern_check(String a, String b) -> Bool\nYou are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word, else False", "vc-preamble": "function IsSubstring(s: string, sub: string) : bool\n{\n  |s| >= |sub| && exists i {:trigger s[i..i+|sub|]} :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub\n}\nfunction RotateString(s: string, n: nat): string\n  requires 0 <= n <= |s|\n{\n  s[n..] + s[..n]\n}", "vc-helpers": "", "vc-spec": "method CycpatternCheck(word: string, pattern: string) returns (result: bool)\n\n  ensures result ==> exists i :: 0 <= i <= |pattern| && IsSubstring(word, RotateString(pattern, i))\n  ensures !result ==> forall i :: 0 <= i <= |pattern| ==> !IsSubstring(word, RotateString(pattern, i))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0157", "language": "dafny", "source": "humaneval", "source_id": "humaneval_155", "vc-description": "This verification task implements a function to count the number of even and odd digits in the absolute value of an integer. The function should return a tuple containing the count of even digits and the count of odd digits.\n\nThe implementation uses helper functions to define digit counting operations and ensures correctness through loop invariants that maintain the relationship between processed and remaining digits.", "vc-preamble": "\nfunction abs_value(x: int): int\n{\n    if x < 0 then -x else x\n}\n\nfunction count_digits(n: nat): nat\n    requires n >= 0\n{\n    if n < 10 then 1 else 1 + count_digits(n / 10)\n}\n\nfunction is_even_digit(d: nat): bool\n    requires d < 10\n{\n    d % 2 == 0\n}\n\nfunction count_even_digits(n: nat): nat\n    requires n >= 0\n    decreases n\n{\n    if n < 10 then\n        if is_even_digit(n) then 1 else 0\n    else\n        (if is_even_digit(n % 10) then 1 else 0) + count_even_digits(n / 10)\n}\n\nfunction count_odd_digits(n: nat): nat\n    requires n >= 0\n    decreases n\n{\n    if n < 10 then\n        if !is_even_digit(n) then 1 else 0\n    else\n        (if !is_even_digit(n % 10) then 1 else 0) + count_odd_digits(n / 10)\n}", "vc-helpers": "", "vc-spec": "method even_odd_count(num: int) returns (even_count: int, odd_count: int)\n    ensures even_count >= 0 && odd_count >= 0\n    ensures even_count + odd_count >= 1\n    ensures var abs_num := abs_value(num);\n            even_count == count_even_digits(abs_num) &&\n            odd_count == count_odd_digits(abs_num)\n    ensures even_count + odd_count == count_digits(abs_value(num))\n    ensures num == 0 ==> (even_count == 1 && odd_count == 0)\n    ensures abs_value(num) == abs_value(-num) ==> \n            (even_count == count_even_digits(abs_value(-num)) && \n             odd_count == count_odd_digits(abs_value(-num)))", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0158", "language": "dafny", "source": "humaneval", "source_id": "humaneval_157", "vc-description": "This verification task involves implementing a method to determine if three positive numbers representing triangle side lengths form a right-angled triangle. The implementation must check both that the sides form a valid triangle (positive lengths satisfying triangle inequality) and that they satisfy the Pythagorean theorem.", "vc-preamble": "\npredicate ValidTriangle(a: real, b: real, c: real)\n{\n    a > 0.0 && b > 0.0 && c > 0.0 &&\n    a + b > c && a + c > b && b + c > a\n}\n\npredicate IsRightTriangle(a: real, b: real, c: real)\n{\n    a * a + b * b == c * c || \n    a * a + c * c == b * b || \n    b * b + c * c == a * a\n}\n\npredicate ValidRightTriangle(a: real, b: real, c: real)\n{\n    ValidTriangle(a, b, c) && IsRightTriangle(a, b, c)\n}", "vc-helpers": "", "vc-spec": "method right_angle_triangle(a: real, b: real, c: real) returns (result: bool)\n    ensures result <==> ValidRightTriangle(a, b, c)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0159", "language": "dafny", "source": "humaneval", "source_id": "humaneval_158_find_max", "vc-description": "function_signature: def find_max(words: List String) -> String\nWrite a function that accepts a list of strings. The list contains different words. Return the word with maximum number of unique characters. If multiple strings have maximum number of unique characters, return the one which comes first in lexicographical order.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method find_max(strings : seq<string>) returns (s : string)\n\n    requires |strings| > 0\n\n    ensures s in strings\n    ensures forall i : int :: 0 <= i < |strings| ==> |set c | c in s| >= |set c | c in strings[i]|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0160", "language": "dafny", "source": "humaneval", "source_id": "humaneval_159", "vc-description": "This verification task involves implementing a method that calculates carrot consumption for a rabbit. Given the number of carrots already eaten, the number of additional carrots needed, and the number of carrots remaining in stock, the method should return the total carrots that will be eaten and how many carrots will be left. The rabbit will eat as many carrots as possible from the remaining stock, up to the number needed.", "vc-preamble": "\npredicate ValidInput(number: int, need: int, remaining: int)\n{\n    0 <= number <= 1000 && 0 <= need <= 1000 && 0 <= remaining <= 1000\n}\n\nfunction CanEat(need: int, remaining: int): int\n{\n    if need <= remaining then need else remaining\n}\n\nfunction TotalEaten(number: int, need: int, remaining: int): int\n{\n    number + CanEat(need, remaining)\n}\n\nfunction CarrotsLeft(need: int, remaining: int): int\n{\n    remaining - CanEat(need, remaining)\n}\n\npredicate ValidResult(result: seq<int>, number: int, need: int, remaining: int)\n{\n    |result| == 2 &&\n    result[0] == TotalEaten(number, need, remaining) &&\n    result[1] == CarrotsLeft(need, remaining) &&\n    result[0] >= number &&\n    result[1] >= 0 &&\n    result[1] <= remaining\n}", "vc-helpers": "", "vc-spec": "method eat(number: int, need: int, remaining: int) returns (result: seq<int>)\n    requires ValidInput(number, need, remaining)\n    ensures ValidResult(result, number, need, remaining)", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0161", "language": "dafny", "source": "humaneval", "source_id": "humaneval_161", "vc-description": "This task involves implementing a string transformation method that applies one of two operations based on whether the string contains letters. If the string has at least one letter, swap the case of each letter (lowercase ↔ uppercase) while keeping non-letters unchanged. If the string contains no letters, reverse the entire string.", "vc-preamble": "\nfunction hasLetter(s: string): bool\n{\n    exists i :: 0 <= i < |s| && (('A' <= s[i] <= 'Z') || ('a' <= s[i] <= 'z'))\n}\n\nfunction reverseString(s: string): string\n    ensures |reverseString(s)| == |s|\n{\n    if |s| == 0 then s else s[|s|-1..] + reverseString(s[..|s|-1])\n}\n\nfunction swapCase(c: char): char\n{\n    if 'A' <= c <= 'Z' then (c as int + 32) as char\n    else if 'a' <= c <= 'z' then (c as int - 32) as char\n    else c\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    ensures if hasLetter(s) then\n        |result| == |s| && \n        (forall i :: 0 <= i < |s| ==> result[i] == swapCase(s[i]))\n    else\n        result == reverseString(s)\n    ensures |result| == |s|", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0162", "language": "dafny", "source": "humaneval", "source_id": "humaneval_162", "vc-description": "This verification task implements a string to MD5 hash conversion function. The method takes a string input and returns an Option type containing either None (for empty input) or Some with a valid 32-character lowercase hexadecimal MD5 hash string.", "vc-preamble": "\ndatatype Option<T> = None | Some(value: T)\n\npredicate isValidMD5Hash(s: string)\n{\n    |s| == 32 && forall i :: 0 <= i < |s| ==> s[i] in \"0123456789abcdef\"\n}", "vc-helpers": "", "vc-spec": "method string_to_md5(text: string) returns (result: Option<string>)\n    ensures text == \"\" ==> result == None\n    ensures text != \"\" ==> result.Some? && isValidMD5Hash(result.value)\n    ensures text != \"\" ==> |result.value| == 32", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
{"id": "DH0163", "language": "dafny", "source": "humaneval", "source_id": "humaneval_163_generate_integers__generate_integers", "vc-description": "function_signature: method generate_integers(a : int, b : int) returns (result: seq<int>)\nGenerate elements. Ensures: the condition holds for all values; the condition holds for all values.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method generate_integers(a : int, b : int) returns (result: seq<int>)\n  ensures forall i :: 0 <= i < |result| ==> result[i] in {2, 4, 6, 8}\n  ensures forall i :: 0 <= i < |result| - 1 ==> result[i] < result[i + 1]\n  ensures forall x :: x in result ==> (x >= a && x <= b) || (x >= b && x <= a)\n  ensures forall x :: x in {2, 4, 6, 8} && ((x >= a && x <= b) || (x >= b && x <= a)) ==> x in result", "vc-code": "{\n    assume {:axiom} false;\n  }", "vc-postamble": ""}
