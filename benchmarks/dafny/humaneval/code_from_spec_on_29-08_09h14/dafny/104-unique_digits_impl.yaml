vc-preamble: |-
  function HasNoEvenDigit(n: int) : bool
    decreases n
  {
    n >= 0 && ((n < 10 && n % 2 == 1) || (n % 2 == 1 && HasNoEvenDigit(n / 10)))
  }

vc-helpers: |-
  lemma HasNoEvenDigitNonnegative(n: int)
    requires HasNoEvenDigit(n)
    ensures n >= 0
  {
  }
  
  lemma HasNoEvenDigitCorrect(n: int)
    requires n >= 0
    ensures HasNoEvenDigit(n) <==> (forall d :: d in Digits(n) ==> d % 2 == 1)
  {
    if n < 10 {
      assert Digits(n) == [n];
    } else {
      HasNoEvenDigitCorrect(n / 10);
      assert Digits(n) == Digits(n / 10) + [n % 10];
    }
  }
  
  function Digits(n: int): seq<int>
    requires n >= 0
    decreases n
  {
    if n < 10 then [n] else Digits(n / 10) + [n % 10]
  }
  
  predicate Sorted(s: seq<int>)
  {
    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
  }
  
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    ensures Sorted(sorted)
    ensures multiset(s) == multiset(sorted)
    ensures |s| == |sorted|
  {
    sorted := s;
    var i := 0;
    while i < |sorted|
      invariant 0 <= i <= |sorted|
      invariant multiset(s) == multiset(sorted)
      invariant forall k, l :: 0 <= k < l < i ==> sorted[k] <= sorted[l]
    {
      var j := i;
      while j > 0 && sorted[j-1] > sorted[j]
        invariant 0 <= j <= i
        invariant multiset(s) == multiset(sorted)
        invariant forall k, l :: 0 <= k < l < |sorted| && (l < j || k >= i+1) ==> sorted[k] <= sorted[l]
      {
        sorted := sorted[j-1 := sorted[j]][j := sorted[j-1]];
        j := j - 1;
      }
      i := i + 1;
    }
  }

vc-description: |-
  function_signature: def unique_digits(x: List[nat]) -> List[nat]
  Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.

vc-spec: |-
  method UniqueDigits(x: seq<int>) returns (result: seq<int>)
    // post-conditions-start
    ensures forall i :: 0 <= i < |result| ==> HasNoEvenDigit(result[i])
    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]
    ensures forall e :: e in x && HasNoEvenDigit(e) ==> e in result
    ensures forall e :: e in result ==> e in x
    // post-conditions-end

vc-code: |-
  {
    var filtered := [];
    var i := 0;
    
    while i < |x|
      invariant 0 <= i <= |x|
      invariant forall j :: 0 <= j < |filtered| ==> HasNoEvenDigit(filtered[j])
      invariant forall j :: 0 <= j < |filtered| ==> filtered[j] in x
      invariant forall e :: e in x[..i] && HasNoEvenDigit(e) ==> e in filtered
    {
      if HasNoEvenDigit(x[i]) {
        filtered := filtered + [x[i]];
      }
      i := i + 1;
    }
    
    result := SortSeq(filtered);
  }

vc-postamble: |-


