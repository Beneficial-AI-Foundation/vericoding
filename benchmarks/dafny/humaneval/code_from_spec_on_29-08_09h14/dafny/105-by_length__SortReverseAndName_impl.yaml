vc-preamble: |-


vc-helpers: |-
  lemma NumberToNameInRange(n: int)
    requires 1 <= n <= 9
    ensures NumberToName(n) in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
  {
  }
  
  lemma FilterPreservesOrder(s: seq<int>, p: int -> bool) returns (filtered: seq<int>)
    ensures |filtered| <= |s|
    ensures forall i :: 0 <= i < |filtered| ==> p(filtered[i])
    ensures forall i, j :: 0 <= i < j < |filtered| && 0 <= GetOriginalIndex(s, filtered[i], i) < GetOriginalIndex(s, filtered[j], j) < |s| ==> GetOriginalIndex(s, filtered[i], i) < GetOriginalIndex(s, filtered[j], j)
  {
    filtered := FilterSeq(s, p);
  }
  
  function FilterSeq(s: seq<int>, p: int -> bool): seq<int>
  {
    if |s| == 0 then []
    else if p(s[0]) then [s[0]] + FilterSeq(s[1..], p)
    else FilterSeq(s[1..], p)
  }
  
  function GetOriginalIndex(s: seq<int>, val: int, filteredIndex: int): int
    requires filteredIndex >= 0
  {
    if |s| == 0 then -1
    else if s[0] == val && CountInPrefix(FilterSeq(s, x => 1 <= x <= 9), val, filteredIndex) == 0
    then 0
    else 1 + GetOriginalIndex(s[1..], val, filteredIndex)
  }
  
  function CountInPrefix(s: seq<int>, val: int, upTo: int): int
  {
    if upTo <= 0 || |s| == 0 then 0
    else if s[0] == val then 1 + CountInPrefix(s[1..], val, upTo - 1)
    else CountInPrefix(s[1..], val, upTo)
  }

vc-description: |-
  function_signature: method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)
  Sort elements. Ensures: the size is bounded; the condition holds for all values.

vc-spec: |-
  method SortReverseAndName(arr: seq<int>) returns (result: seq<string>)
    // post-conditions-start
    ensures |result| <= |arr|
    ensures forall i :: 0 <= i < |result| ==>
      result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    // post-conditions-end

vc-code: |-
  {
    var sorted := SortSeq(arr);
    var reversed := reverse(sorted);
    var filtered := FilterSeq(reversed, x => 1 <= x <= 9);
    
    var names: seq<string> := [];
    var i := 0;
    
    while i < |filtered|
      invariant 0 <= i <= |filtered|
      invariant |names| == i
      invariant forall j :: 0 <= j < i ==> names[j] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    {
      assert 1 <= filtered[i] <= 9;
      NumberToNameInRange(filtered[i]);
      names := names + [NumberToName(filtered[i])];
      i := i + 1;
    }
    
    result := names;
  }

vc-postamble: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
    // post-conditions-start
    ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
    ensures |sorted| == |s|
    ensures multiset(s) == multiset(sorted)
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  method reverse(s: seq<int>) returns (rev: seq<int>)
    // post-conditions-start
    ensures |rev| == |s|
    ensures forall k :: 0 <= k < |s| ==> rev[k] == s[|s| - 1 - k]
    // post-conditions-end
  {
    assume{:axiom} false;
  }
  function NumberToName(n: int): string
    requires 1 <= n <= 9
  {
    match n
    case 1 => "One"
    case 2 => "Two"
    case 3 => "Three"
    case 4 => "Four"
    case 5 => "Five"
    case 6 => "Six"
    case 7 => "Seven"
    case 8 => "Eight"
    case 9 => "Nine"
  }
  // pure-end

