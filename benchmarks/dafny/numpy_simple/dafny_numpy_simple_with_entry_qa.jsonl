{"id": "DS0000", "language": "dafny", "source": "numpy_simple", "source_id": "NpAbs-spec", "vc-description": "Computes the absolute value of each element in a vector.", "vc-preamble": "function AbsInt(x: int): int\n{\n    if x < 0 then -x else x\n}", "vc-helpers": "", "vc-spec": "method Abs(a: array<int>) returns (result: array<int>)\n    ensures \n        result.Length == a.Length &&\n        (forall i :: 0 <= i < a.Length ==> result[i] == AbsInt(a[i])) &&\n        (forall i :: 0 <= i < result.Length ==> result[i] >= 0)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0001", "language": "dafny", "source": "numpy_simple", "source_id": "NpAdd-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Add(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    ensures \n        result.Length == a.Length &&\n        forall i :: 0 <= i < result.Length ==> result[i] == a[i] + b[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0002", "language": "dafny", "source": "numpy_simple", "source_id": "NpArange-spec", "vc-description": "", "vc-preamble": "function ArangeLength(start: int, stop: int, step: int): nat\n{\n    if step != 0 then\n        if step < 0 then\n            if start > stop then\n                (start - stop) / (-step)\n            else\n                0\n        else\n            if start < stop then\n                (stop - start) / step\n            else\n                0\n    else\n        0\n}", "vc-helpers": "", "vc-spec": "method Arange(start: int, stop: int, step: int) returns (result: array<int>)\n    requires \n        step != 0 &&\n        (if step < 0 then start > stop else start < stop)\n    ensures\n        result.Length == ArangeLength(start, stop, step) &&\n        result.Length > 0 &&\n        result[0] == start", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0003", "language": "dafny", "source": "numpy_simple", "source_id": "NpArgmax-spec", "vc-description": "Finds the index of the maximum element in a non-empty vector of floats.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Argmax(arr: array<int>) returns (result: int)\n    requires arr.Length > 0\n    ensures \n        0 <= result < arr.Length &&\n        (forall i :: 0 <= i < result ==> arr[result] > arr[i]) &&\n        (forall i :: result < i < arr.Length ==> arr[result] >= arr[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0004", "language": "dafny", "source": "numpy_simple", "source_id": "NpArgsort-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Argsort(a: array<int>) returns (result: array<int>)\n    ensures result.Length == a.Length\n    ensures forall i, j :: 0 <= i < j < result.Length && 0 <= result[i] < a.Length && 0 <= result[j] < a.Length ==> a[result[i]] <= a[result[j]]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0005", "language": "dafny", "source": "numpy_simple", "source_id": "NpBitwiseAnd-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method BitwiseAnd(a: seq<bv32>, b: seq<bv32>) returns (result: seq<bv32>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == (a[i] & b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0006", "language": "dafny", "source": "numpy_simple", "source_id": "NpBitwiseOr-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method BitwiseOr(a: array<bv32>, b: array<bv32>) returns (result: array<bv32>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == (a[i] | b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0007", "language": "dafny", "source": "numpy_simple", "source_id": "NpBitwiseXor-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method BitwiseXor(a: array<bv32>, b: array<bv32>) returns (result: array<bv32>)\n    requires \n        a.Length == b.Length &&\n        a.Length > 0\n    ensures\n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == a[i] ^ b[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0008", "language": "dafny", "source": "numpy_simple", "source_id": "NpBroadcast-spec", "vc-description": "Broadcast operation that reshapes a vector into a matrix according to broadcasting rules.", "vc-preamble": "/* Matrix type definition - represents an m√ón matrix */\ndatatype Matrix<T> = Matrix(\n    data: seq<seq<T>>,\n    rows: int,\n    cols: int\n)\n\npredicate MatrixWf<T>(m: Matrix<T>)\n{\n    && |m.data| == m.rows\n    && (forall i :: 0 <= i < |m.data| ==> |m.data[i]| == m.cols)\n}\n\nfunction MatrixIndex<T>(m: Matrix<T>, i: int, j: int): T\n    requires 0 <= i < m.rows && 0 <= j < m.cols && MatrixWf(m)\n{\n    m.data[i][j]\n}\n\nfunction MatrixSize<T>(m: Matrix<T>): int\n{\n    m.rows * m.cols\n}", "vc-helpers": "", "vc-spec": "method Broadcast(a: seq<int>, shape: seq<int>) returns (ret: Matrix<int>)\n    requires \n        |a| > 0 &&\n        |shape| == 2 &&\n        shape[0] > 0 &&\n        shape[1] > 0 &&\n        (shape[0] == |a| || shape[1] == |a|)\n    ensures\n        MatrixWf(ret) &&\n        ret.rows == shape[0] &&\n        ret.cols == shape[1] &&\n        MatrixSize(ret) == shape[0] * shape[1] &&\n        (forall i, j :: 0 <= i < shape[0] && 0 <= j < shape[1] ==> (\n            if shape[0] == |a| then\n                MatrixIndex(ret, i, j) == a[i]\n            else\n                MatrixIndex(ret, i, j) == a[j]\n        ))", "vc-code": "{\n    assume {:axiom} false;\n    ret := Matrix([], 0, 0);\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0009", "language": "dafny", "source": "numpy_simple", "source_id": "NpCenter-spec", "vc-description": "Centers strings within a given width by adding appropriate padding.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Center(input: array<string>, width: int) returns (result: array<string>)\n    requires \n        input.Length > 0\n    requires\n        forall i :: 0 <= i < input.Length ==> |input[i]| >= 1\n    ensures\n        result.Length == input.Length\n    ensures\n        forall i :: 0 <= i < input.Length ==> \n            if |input[i]| > width then\n                |result[i]| == |input[i]|\n            else\n                |result[i]| == width\n    ensures\n        forall i :: 0 <= i < input.Length ==> \n            if |input[i]| < width then\n                var start_pos := (width - |input[i]| + 1) / 2;\n                result[i][start_pos..start_pos + |input[i]|] == input[i]\n            else\n                true", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0010", "language": "dafny", "source": "numpy_simple", "source_id": "NpClip-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Clip(a: array<int>, min: int, max: int) returns (result: array<int>)\n    requires min < max\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> \n        if a[i] < min then result[i] == min\n        else if a[i] > max then result[i] == max\n        else result[i] == a[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0011", "language": "dafny", "source": "numpy_simple", "source_id": "NpColumnStack-spec", "vc-description": "Creates a matrix by stacking column vectors horizontally.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method ColumnStack(input: seq<seq<int>>, m: int, n: int) returns (result: seq<seq<int>>)\n    requires \n        n > 0 &&\n        |input| == n &&\n        (forall i :: 0 <= i < n ==> |input[i]| == m)\n    ensures\n        |result| == m &&\n        (forall j :: 0 <= j < m ==> |result[j]| == n) &&\n        |result| * n == m * n &&\n        (forall i, j :: 0 <= i < n && 0 <= j < m ==> \n            result[j][i] == input[i][j])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0013", "language": "dafny", "source": "numpy_simple", "source_id": "NpCopy-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method copy(arr: seq<int>) returns (result: seq<int>)\n    ensures\n        |result| == |arr| &&\n        forall i :: 0 <= i < |arr| ==> result[i] == arr[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0014", "language": "dafny", "source": "numpy_simple", "source_id": "NpCountnonzero-spec", "vc-description": "Counts the number of non-zero elements in a float vector.", "vc-preamble": "function nonzero_helper(arr: seq<real>): nat \n    decreases |arr|\n{\n    if |arr| == 0 then\n        0\n    else\n        var rest_count := nonzero_helper(arr[1..]);\n        if arr[0] == 0.0 then\n            rest_count\n        else\n            rest_count + 1\n}", "vc-helpers": "", "vc-spec": "method nonzero(arr: array<real>) returns (result: int)\n    ensures \n        result <= arr.Length &&\n        result == nonzero_helper(arr[..]) &&\n        (arr.Length > 0 && arr[0] == 0.0 ==> \n            nonzero_helper(arr[1..]) == if result > 0 then result - 1 else 0)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0015", "language": "dafny", "source": "numpy_simple", "source_id": "NpCumProd-spec", "vc-description": "Computes the cumulative product of a vector where each element is the product of all elements up to that index.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method CumProd(a: array<int>) returns (result: array<int>)\n    requires a.Length > 0\n    ensures \n        result.Length == a.Length &&\n        result[0] == a[0] &&\n        forall i :: 0 < i < a.Length ==> result[i] == result[i-1] * a[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0016", "language": "dafny", "source": "numpy_simple", "source_id": "NpCumSum-spec", "vc-description": "Computes the cumulative sum of elements in a vector, where each position contains the sum of all elements from the start up to that position.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method CumSum(a: array<int>) returns (result: array<int>)\n    requires a.Length > 0\n    ensures \n        result.Length == a.Length &&\n        result[0] == a[0] &&\n        forall i :: 1 <= i < a.Length ==> result[i] == result[i - 1] + a[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0017", "language": "dafny", "source": "numpy_simple", "source_id": "NpDiagonal-spec", "vc-description": "", "vc-preamble": "/* Matrix type represented as a sequence of sequences */\ntype Matrix<T> = seq<seq<T>>", "vc-helpers": "", "vc-spec": "method diagonal(arr: Matrix<int>, k: int) returns (result: seq<int>)\n    requires \n        |arr| > 0 &&\n        |arr| == |arr[0]| && /* square matrix */\n        (forall i :: 0 <= i < |arr| ==> |arr[i]| == |arr|) &&\n        -|arr| < k < |arr|\n    ensures\n        if k > 0 then\n            |result| == |arr| - k &&\n            forall i :: 0 <= i < |result| ==> \n                0 <= i < |arr| && 0 <= i + k < |arr| && result[i] == arr[i][i + k]\n        else\n            |result| == |arr| + (-k) &&\n            forall i :: 0 <= i < |result| ==> \n                0 <= i + (-k) < |arr| && 0 <= i < |arr| && result[i] == arr[i + (-k)][i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0018", "language": "dafny", "source": "numpy_simple", "source_id": "NpEqual-spec", "vc-description": "Element-wise comparison of two vectors, returning a boolean vector indicating equality at each position.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Equal(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures \n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == (a[i] == b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0019", "language": "dafny", "source": "numpy_simple", "source_id": "NpFlatten-spec", "vc-description": "Flattens a 2D matrix into a 1D vector in row-major order.", "vc-preamble": "/* Matrix type definition - 2D array represented as sequence of sequences */\ndatatype Matrix = Matrix(data: seq<seq<int>>, rows: nat, cols: nat)\n\npredicate MatrixValid(mat: Matrix)\n{\n    |mat.data| == mat.rows &&\n    (forall i :: 0 <= i < mat.rows ==> |mat.data[i]| == mat.cols)\n}\n\nfunction MatrixSize(mat: Matrix): nat\n{\n    mat.rows * mat.cols\n}\n\nfunction MatrixGet(mat: Matrix, i: nat, j: nat): int\n    requires MatrixValid(mat)\n    requires i < mat.rows && j < mat.cols\n{\n    mat.data[i][j]\n}", "vc-helpers": "", "vc-spec": "method Flatten2(mat: Matrix) returns (ret: seq<int>)\n    requires mat.rows > 0\n    requires mat.cols > 0\n    requires MatrixValid(mat)\n    ensures |ret| == mat.rows * mat.cols\n    ensures forall i, j :: \n        0 <= i < mat.rows && 0 <= j < mat.cols ==> \n        0 <= i * mat.cols + j < |ret| && ret[i * mat.cols + j] == MatrixGet(mat, i, j)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0020", "language": "dafny", "source": "numpy_simple", "source_id": "NpFloorDivide-spec", "vc-description": "Element-wise floor division of two vectors where the divisor vector has no zero elements.", "vc-preamble": "predicate IsNonZeroVector(v: seq<int>)\n{\n    forall i :: 0 <= i < |v| ==> v[i] != 0\n}", "vc-helpers": "", "vc-spec": "method FloorDivide(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    requires IsNonZeroVector(b[..])\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] / b[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0021", "language": "dafny", "source": "numpy_simple", "source_id": "NpGcd-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method GcdInt(a: int, b: int) returns (result: int)\n    ensures\n        result > 0 &&\n        a % result == 0 &&\n        b % result == 0 &&\n        (forall d :: d > 0 && a % d == 0 && b % d == 0 ==> d <= result)", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    result := 1;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0022", "language": "dafny", "source": "numpy_simple", "source_id": "NpGreater-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Greater(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures \n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == (a[i] > b[i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0023", "language": "dafny", "source": "numpy_simple", "source_id": "NpGreaterEqual-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method GreaterEqual(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures \n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == (a[i] >= b[i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0024", "language": "dafny", "source": "numpy_simple", "source_id": "NpHistogram-spec", "vc-description": "Computes a histogram of floating-point data given bin boundaries.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method histogram(data: array<real>, bins: array<real>) returns (result: array<int>)\n    requires \n        bins.Length >= 2\n    ensures\n        result.Length == bins.Length - 1\n{\n    assume {:axiom} false;\n}\n\nmethod histogram_helper(data: array<real>, bins: array<real>, hist: array<int>, index: int) returns (result: array<int>)\n    requires \n        bins.Length >= 2 &&\n        hist.Length == bins.Length - 1\n    ensures\n        result.Length == bins.Length - 1", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0025", "language": "dafny", "source": "numpy_simple", "source_id": "NpIntersect-spec", "vc-description": "Computes the intersection of two vectors containing common elements.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Intersect(a: array<real>, b: array<real>) returns (result: array<real>)\n    ensures\n        result.Length < a.Length && result.Length < b.Length &&\n        forall i, j :: 0 <= i < a.Length && 0 <= j < b.Length ==> (\n            (a[i] == b[j] ==> exists k :: 0 <= k < result.Length && result[k] == a[i]) &&\n            (a[i] != b[j] ==> !exists k :: 0 <= k < result.Length && result[k] == a[i])\n        )", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0026", "language": "dafny", "source": "numpy_simple", "source_id": "NpInvert-spec", "vc-description": "", "vc-preamble": "function pow2(n: nat): nat \n    decreases n\n{\n    if n == 0 then\n        1\n    else\n        2 * pow2(n - 1)\n}", "vc-helpers": "", "vc-spec": "method invert(bit_width: nat, a: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == (pow2(bit_width) - 1) - a[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0027", "language": "dafny", "source": "numpy_simple", "source_id": "NpIsalpha-spec", "vc-description": "Checks if all strings in a vector contain only alphabetic characters (A-Z, a-z).", "vc-preamble": "predicate IsAlphaChar(c: char)\n{\n    ('A' <= c <= 'Z') || ('a' <= c <= 'z')\n}\n\npredicate StringIsAlpha(s: seq<char>)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> IsAlphaChar(s[i])\n}", "vc-helpers": "", "vc-spec": "method IsAlpha(input: array<string>) returns (ret: array<bool>)\n    ensures\n        ret.Length == input.Length &&\n        forall i :: 0 <= i < input.Length ==> \n            ret[i] == StringIsAlpha(input[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0028", "language": "dafny", "source": "numpy_simple", "source_id": "NpIsclose-spec", "vc-description": "Computes element-wise absolute difference comparison within tolerance for two integer vectors.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method NpIsclose(a: array<int>, b: array<int>, tol: int) returns (result: array<bool>)\n    requires \n        a.Length > 0 &&\n        a.Length == b.Length &&\n        tol > 0\n    ensures\n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> \n            result[i] == (-tol < a[i] - b[i] && a[i] - b[i] < tol)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0029", "language": "dafny", "source": "numpy_simple", "source_id": "NpLcm-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LcmInt(a: int, b: int) returns (result: int)\n    requires a != 0 && b != 0\n    ensures result >= 0\n    ensures result % a == 0\n    ensures result % b == 0", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0030", "language": "dafny", "source": "numpy_simple", "source_id": "NpLeftShift-spec", "vc-description": "", "vc-preamble": "function ShiftLeftInt(x: int, shift: nat): int", "vc-helpers": "", "vc-spec": "method LeftShift(a: array<int>, b: array<nat>) returns (result: array<int>)\n    requires \n        a.Length == b.Length &&\n        forall i :: 0 <= i < b.Length ==> b[i] < 64\n    ensures\n        result.Length == a.Length &&\n        forall i :: 0 <= i < result.Length ==> result[i] == ShiftLeftInt(a[i], b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0031", "language": "dafny", "source": "numpy_simple", "source_id": "NpLess-spec", "vc-description": "Element-wise comparison of two vectors, returning a boolean vector indicating where the first vector is less than the second.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Less(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == (a[i] < b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0032", "language": "dafny", "source": "numpy_simple", "source_id": "NpLessEqual-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method LessEqual(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == (a[i] <= b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0033", "language": "dafny", "source": "numpy_simple", "source_id": "NpMax-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Max(a: array<int>) returns (result: int)\n    requires a.Length > 0\n    ensures exists i :: 0 <= i < a.Length && result == a[i]\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= result", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0034", "language": "dafny", "source": "numpy_simple", "source_id": "NpMin-spec", "vc-description": "Finds the minimum element in a non-empty vector.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method min(a: array<int>) returns (result: int)\n    requires a.Length > 0\n    ensures exists i :: 0 <= i < a.Length && result == a[i]\n    ensures forall i :: 0 <= i < a.Length ==> result <= a[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0035", "language": "dafny", "source": "numpy_simple", "source_id": "NpMod-spec", "vc-description": "", "vc-preamble": "predicate AllNonzero(v: seq<int>)\n{\n    forall i :: 0 <= i < |v| ==> v[i] != 0\n}", "vc-helpers": "", "vc-spec": "method ModVec(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    requires AllNonzero(b[..])\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] % b[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0036", "language": "dafny", "source": "numpy_simple", "source_id": "NpMultiply-spec", "vc-description": "Element-wise multiplication of two vectors of the same length.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method multiply(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == a[i] * b[i]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0037", "language": "dafny", "source": "numpy_simple", "source_id": "NpNotEqual-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method NotEqual(a: array<int>, b: array<int>) returns (result: array<bool>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == (a[i] != b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0038", "language": "dafny", "source": "numpy_simple", "source_id": "NpPiecewise-spec", "vc-description": "Implements a piecewise function that applies different functions to elements based on conditions.", "vc-preamble": "type CondFunc = real -> bool\ntype ApplyFunc = real -> real", "vc-helpers": "", "vc-spec": "method Piecewise(x: array<real>, condlist: array<CondFunc>, funclist: array<ApplyFunc>) returns (ret: array<real>)\n    requires condlist.Length == funclist.Length\n    ensures ret.Length == x.Length\n    ensures forall i, j :: (0 <= i < x.Length && 0 <= j < condlist.Length && \n        condlist[j](x[i])) ==> ret[i] == funclist[j](x[i])", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0039", "language": "dafny", "source": "numpy_simple", "source_id": "NpPoly-spec", "vc-description": "", "vc-preamble": "function PolyHelperSpec(roots: seq<real>, val: nat): seq<real>", "vc-helpers": "", "vc-spec": "method PolyHelper(roots: array<real>, val: nat) returns (result: array<real>)\n    requires \n        roots.Length > 0 &&\n        val > 0\n    ensures \n        result.Length == roots.Length &&\n        (result.Length > 0 ==> result[0] == 1.0)\n{\n    assume {:axiom} false;\n}\n\nmethod Poly(roots: array<real>) returns (result: array<real>)\n    requires roots.Length > 0\n    ensures \n        result.Length == roots.Length &&\n        (var helperSeq := PolyHelperSpec(roots[..], (roots.Length - 1) as nat);\n         |helperSeq| == result.Length &&\n         forall i :: 0 <= i < result.Length ==> result[i] == helperSeq[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0040", "language": "dafny", "source": "numpy_simple", "source_id": "NpPolyder-spec", "vc-description": "Computes the polynomial derivative of order m for a given polynomial represented as a vector of coefficients.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method polyder(poly: array<real>, m: int) returns (result: array<real>)\n    requires \n        m > 0 &&\n        m <= poly.Length\n    ensures \n        result.Length == poly.Length - m", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0041", "language": "dafny", "source": "numpy_simple", "source_id": "NpPower-spec", "vc-description": "", "vc-preamble": "function IntPow(base: int, exp: nat): int\n    decreases exp\n{\n    if exp == 0 then\n        1\n    else\n        base * IntPow(base, exp - 1)\n}", "vc-helpers": "", "vc-spec": "method Power(a: array<int>, b: array<nat>) returns (result: array<int>)\n    requires a.Length == b.Length\n    ensures \n        result.Length == a.Length &&\n        forall i :: 0 <= i < a.Length ==> result[i] == IntPow(a[i], b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0042", "language": "dafny", "source": "numpy_simple", "source_id": "NpProd-spec", "vc-description": "", "vc-preamble": "function ProdSpecHelper(a: seq<int>, start: int, finish: int): int\n    requires 0 <= start <= finish <= |a|\n    decreases finish - start\n{\n    if start >= finish then\n        1\n    else\n        a[start] * ProdSpecHelper(a, start + 1, finish)\n}\n\nfunction ProdSpec(a: seq<int>): int {\n    ProdSpecHelper(a, 0, |a|)\n}\n\nfunction ProdArraySpec(a: seq<int>, start: int, finish: int): int\n    requires 0 <= start <= finish <= |a|\n{\n    ProdSpecHelper(a, start, finish)\n}", "vc-helpers": "", "vc-spec": "method Prod(a: array<int>) returns (result: int)\n    ensures result == ProdSpec(a[..])\n{\n    assume {:axiom} false;\n}\n\nmethod ProdArray(a: array<int>, start: int, finish: int) returns (result: int)\n    requires 0 <= start <= finish <= a.Length\n    ensures result == ProdArraySpec(a[..], start, finish)\n{\n    assume {:axiom} false;\n}\n\nlemma {:axiom} ProdTheorem(a: array<int>)\n    requires a.Length > 0\n    ensures ProdSpec(a[..]) == ProdArraySpec(a[..], 0, a.Length) &&\n            (forall i :: 0 <= i < a.Length && a[i] == 0 ==> ProdSpec(a[..]) == 0)", "vc-code": "", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0043", "language": "dafny", "source": "numpy_simple", "source_id": "NpRavel-spec", "vc-description": "Flattens a 2D matrix into a 1D vector in row-major order.", "vc-preamble": "/* Matrix type definition: function from row,col indices to values */\ntype Matrix<T> = int -> int -> T\n\n/* Get matrix element at position (i,j) */\nfunction MatrixGet<T>(mat: Matrix<T>, i: int, j: int): T\n{\n    mat(i)(j)\n}\n\n/* Matrix size helper */\nfunction MatrixSize(m: int, n: int): int\n{\n    m * n\n}", "vc-helpers": "", "vc-spec": "method Ravel(arr: Matrix<int>, m: int, n: int) returns (ret: seq<int>)\n    requires m > 0 && n > 0\n    ensures |ret| == m * n\n    ensures forall i, j :: 0 <= i < m && 0 <= j < n && 0 <= i * n + j < |ret| ==> \n            ret[i * n + j] == MatrixGet(arr, i, j)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0044", "language": "dafny", "source": "numpy_simple", "source_id": "NpRemainder-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method remainder(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires \n        a.Length == b.Length\n    requires\n        forall i :: 0 <= i < b.Length ==> b[i] != 0\n    ensures\n        result.Length == a.Length\n    ensures\n        forall i :: 0 <= i < result.Length ==> result[i] == a[i] % b[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0045", "language": "dafny", "source": "numpy_simple", "source_id": "NpReshape-spec", "vc-description": "", "vc-preamble": "type Matrix<T> = seq<seq<T>>\n\nfunction MatrixSize<T>(mat: Matrix<T>): nat\n{\n    if |mat| == 0 then 0 else |mat| * |mat[0]|\n}", "vc-helpers": "", "vc-spec": "method Reshape(arr: seq<int>, shape: seq<nat>) returns (result: Matrix<int>)\n    requires \n        |arr| > 0 &&\n        |shape| == 2", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0046", "language": "dafny", "source": "numpy_simple", "source_id": "NpRightShift-spec", "vc-description": "", "vc-preamble": "function pow2(n: nat): nat\n    ensures pow2(n) > 0\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nfunction shift_right_int(x: int, n: nat): int\n    requires pow2(n) > 0\n{\n  if x >= 0 then\n    x / pow2(n)\n  else\n    -((((-x) - 1) / pow2(n)) + 1)\n}", "vc-helpers": "", "vc-spec": "method right_shift(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    requires forall i :: 0 <= i < b.Length ==> 0 <= b[i] < 64\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> \n        result[i] == shift_right_int(a[i], b[i])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 1}, "individual_score": 0.85}}
{"id": "DS0047", "language": "dafny", "source": "numpy_simple", "source_id": "NpSelect-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method select(condlist: array<array<bool>>, choicelist: array<array<real>>) returns (result: array<real>)\n    requires \n        condlist.Length > 0 &&\n        condlist.Length == choicelist.Length &&\n        (forall i :: 0 <= i < condlist.Length ==> condlist[i].Length > 0) &&\n        (forall i :: 0 <= i < condlist.Length ==> condlist[i].Length == choicelist[i].Length) &&\n        (forall i, j :: 0 <= i < condlist.Length && 0 <= j < condlist.Length ==> \n            condlist[i].Length == condlist[j].Length)\n    ensures\n        result.Length == condlist[0].Length &&\n        (forall i, j :: \n            0 <= i < condlist.Length && 0 <= j < result.Length && condlist[i][j] ==> \n            result[j] == choicelist[i][j])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0048", "language": "dafny", "source": "numpy_simple", "source_id": "NpShape-spec", "vc-description": "Matrix and array shape computation functions", "vc-preamble": "datatype Matrix<T> = Matrix(m: nat, n: nat, data: seq<seq<T>>)\n\nfunction MatrixSize<T>(matrix: Matrix<T>): nat\n{\n    matrix.m * matrix.n\n}\n\ndatatype Arrays = ArrayOne(arr1: seq<real>) | ArrayTwo(arr2: seq<seq<real>>) | ArrayThree(arr3: seq<seq<seq<real>>>)\n\nfunction ArraysNdim(a: Arrays): nat\n{\n    match a\n    case ArrayOne(_) => 1\n    case ArrayTwo(_) => 2\n    case ArrayThree(_) => 3\n}", "vc-helpers": "", "vc-spec": "method {:axiom} ShapeArrays(a: Arrays) returns (result: seq<nat>)\n    ensures\n        |result| == ArraysNdim(a) &&\n        match a {\n            case ArrayOne(arr) => |result| == 1 && result[0] == |arr|\n            case ArrayTwo(arr) => |result| == 2 && result[0] == |arr| && \n                result[1] == (if |arr| > 0 then |arr[0]| else 0)\n            case ArrayThree(arr) => |result| == 3 && result[0] == |arr| && \n                result[1] == (if |arr| > 0 then |arr[0]| else 0) &&\n                result[2] == (if |arr| > 0 && |arr[0]| > 0 then |arr[0][0]| else 0)\n        }\n\nmethod {:axiom} ShapeMatrix(a: Matrix<real>) returns (result: seq<nat>)\n    ensures\n        |result| == 2 &&\n        result[0] == a.m &&\n        result[1] == a.n", "vc-code": "", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0049", "language": "dafny", "source": "numpy_simple", "source_id": "NpSign-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Sign(a: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == a.Length\n    ensures\n        forall i :: 0 <= i < a.Length ==> (\n            (a[i] > 0 ==> result[i] == 1) &&\n            (a[i] == 0 ==> result[i] == 0) &&\n            (a[i] < 0 ==> result[i] == -1)\n        )", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0050", "language": "dafny", "source": "numpy_simple", "source_id": "NpSort-spec", "vc-description": "Sorts a vector of floating-point numbers in ascending order.", "vc-preamble": "function MultisetCount<T(==)>(s: seq<T>, x: T): nat\n{\n    |set i | 0 <= i < |s| && s[i] == x|\n}", "vc-helpers": "", "vc-spec": "method Sort(a: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == a.Length &&\n        (forall i, j :: 0 <= i < j < result.Length ==> result[i] <= result[j]) &&\n        (forall x :: MultisetCount(result[..], x) == MultisetCount(a[..], x))", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0051", "language": "dafny", "source": "numpy_simple", "source_id": "NpSquare-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method Square(arr: array<int>) returns (result: array<int>)\n    ensures\n        result.Length == arr.Length &&\n        forall i :: 0 <= i < arr.Length ==> result[i] == arr[i] * arr[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0052", "language": "dafny", "source": "numpy_simple", "source_id": "NpSubtract-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method subtract(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a.Length == b.Length\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> result[i] == a[i] - b[i]", "vc-code": "{\n    // impl-start\n    assume {:axiom} false;\n    // impl-end\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0053", "language": "dafny", "source": "numpy_simple", "source_id": "NpSum-spec", "vc-description": "", "vc-preamble": "function SumRange(a: seq<int>, start: int, len: int): int\n    decreases len\n{\n    if len <= 0 || start < 0 || start + len > |a| then\n        0\n    else if len == 0 then\n        0\n    else\n        a[start] + SumRange(a, start + 1, len - 1)\n}\n\nfunction SeqSum(a: seq<int>): int\n{\n    SumRange(a, 0, |a|)\n}", "vc-helpers": "", "vc-spec": "method Sum(a: array<int>) returns (result: int)\n    ensures result == SeqSum(a[..])\n{\n    assume {:axiom} false;\n}\n\nmethod SumArray(a: array<int>, start: int, finish: int) returns (result: int)\n    requires start <= finish && finish <= a.Length\n    ensures result == SumRange(a[..], start, finish - start)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0054", "language": "dafny", "source": "numpy_simple", "source_id": "NpTranspose-spec", "vc-description": "Matrix transpose operation that swaps rows and columns.", "vc-preamble": "type Matrix = seq<seq<int>>\n\nfunction MatrixGet(mat: Matrix, i: int, j: int): int\n    requires 0 <= i < |mat|\n    requires i < |mat| ==> 0 <= j < |mat[i]|\n{\n    mat[i][j]\n}\n\nfunction MatrixRows(mat: Matrix): int {\n    |mat|\n}\n\nfunction MatrixCols(mat: Matrix): int\n{\n    if |mat| > 0 then |mat[0]| else 0\n}\n\nfunction MatrixSize(mat: Matrix): int\n{\n    MatrixRows(mat) * MatrixCols(mat)\n}", "vc-helpers": "", "vc-spec": "method Transpose(arr: Matrix) returns (ret: Matrix)\n    requires |arr| > 0\n    requires forall i :: 0 <= i < |arr| ==> |arr[i]| == |arr[0]|\n    ensures |ret| == |arr[0]|\n    ensures forall i :: 0 <= i < |ret| ==> |ret[i]| == |arr|\n    ensures MatrixSize(ret) == MatrixCols(arr) * MatrixRows(arr)\n    ensures forall i, j :: \n        (0 <= i < MatrixRows(arr) && 0 <= j < MatrixCols(arr)) ==>\n        MatrixGet(ret, j, i) == MatrixGet(arr, i, j)", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0055", "language": "dafny", "source": "numpy_simple", "source_id": "NpTril-spec", "vc-description": "", "vc-preamble": "type Matrix<T> = seq<seq<T>>\n\nfunction MatrixSize<T>(m: Matrix<T>): nat\n{\n    (|m| * (if |m| > 0 then |m[0]| else 0)) as nat\n}", "vc-helpers": "", "vc-spec": "method Tril(arr: Matrix<int>, k: int) returns (ret: Matrix<int>)\n    requires \n        |arr| > 0 &&\n        |arr[0]| > 0 &&\n        (forall i :: 0 <= i < |arr| ==> |arr[i]| == |arr[0]|) &&\n        -((|arr| as int) - 1) < k && k < (|arr[0]| as int) - 1\n    ensures\n        MatrixSize(ret) == MatrixSize(arr) &&\n        |ret| == |arr| &&\n        (forall i :: 0 <= i < |ret| ==> |ret[i]| == |arr[0]|) &&\n        forall i: int, j: int :: \n            0 <= i < |arr| && 0 <= j < |arr[0]| ==> \n                if j - i > k then ret[i][j] == 0 else ret[i][j] == arr[i][j]", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0056", "language": "dafny", "source": "numpy_simple", "source_id": "NpUniqueall-spec", "vc-description": "Removes duplicate elements from a vector, preserving the order of first occurrences.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method UniqueAll(arr: array<int>) returns (ret: array<int>)\n    ensures\n        ret.Length <= arr.Length &&\n        (forall i :: 0 <= i < arr.Length ==> exists j :: 0 <= j < ret.Length && ret[j] == arr[i]) &&\n        (forall i, j :: 0 <= i < ret.Length && 0 <= j < i ==> ret[i] != ret[j])", "vc-code": "{\n    assume {:axiom} false;\n}", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0057", "language": "dafny", "source": "numpy_simple", "source_id": "NpWhere-spec", "vc-description": "Vector where functions for conditional element selection and transformation.", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method WhereFn(condition: array<bool>, x: array<int>, y: array<int>) returns (result: array<int>)\n    requires \n        condition.Length == x.Length &&\n        x.Length == y.Length\n    ensures \n        result.Length == condition.Length &&\n        forall i :: 0 <= i < result.Length ==> \n            result[i] == if condition[i] then x[i] else y[i]\n{\n    assume {:axiom} false;\n}\n\nmethod WhereWithTransform(arr: array<int>) returns (result: array<int>)\n    requires arr.Length >= 0\n    ensures \n        result.Length == arr.Length\n{\n    assume {:axiom} false;\n}", "vc-code": "", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
{"id": "DS0058", "language": "dafny", "source": "numpy_simple", "source_id": "NpZeros-spec", "vc-description": "", "vc-preamble": "", "vc-helpers": "", "vc-spec": "method zeros(n: nat) returns (result: array<int>)\n    ensures \n        result.Length == n &&\n        (forall i :: 0 <= i < n ==> result[i] == 0)\n{\n    assume {:axiom} false;\n}\n\nmethod zeros2d(rows: nat, cols: nat) returns (result: array<array<int>>)\n    ensures \n        result.Length == rows &&\n        (forall i :: 0 <= i < rows ==> result[i].Length == cols) &&\n        (forall i, j :: 0 <= i < rows && 0 <= j < cols ==> result[i][j] == 0)\n{\n    assume {:axiom} false;\n}", "vc-code": "", "vc-postamble": "", "qa_entry_metadata": {"issues": {"functions_with_default_values": 0, "methods_with_bodies": 0, "near_duplicates": 0}, "individual_score": 1.0}}
