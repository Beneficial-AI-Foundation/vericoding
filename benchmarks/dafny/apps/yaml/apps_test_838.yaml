vc-description: |-
  Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)
  and every pair of cells in the set shares either a row or a column.

vc-preamble: |-
  predicate ValidInput(stdin_input: string)
  {
      |stdin_input| > 0
  }
  
  predicate ValidGrid(grid: array2<int>)
      reads grid
  {
      grid.Length0 > 0 && grid.Length1 > 0 &&
      forall i, j :: 0 <= i < grid.Length0 && 0 <= j < grid.Length1 ==> 
          grid[i, j] == 0 || grid[i, j] == 1
  }
  
  function count_valid_sets(grid: array2<int>): int
      requires ValidGrid(grid)
      reads grid
      ensures count_valid_sets(grid) >= grid.Length0 * grid.Length1
  {
      grid.Length0 * grid.Length1 + 
      sum_row_contributions(grid) + 
      sum_col_contributions(grid)
  }
  
  function sum_row_contributions(grid: array2<int>): int
      reads grid
      ensures sum_row_contributions(grid) >= 0
  {
      sum_row_contributions_helper(grid, 0)
  }
  
  function sum_row_contributions_helper(grid: array2<int>, row: int): int
      requires 0 <= row <= grid.Length0
      reads grid
      ensures sum_row_contributions_helper(grid, row) >= 0
      decreases grid.Length0 - row
  {
      if row == grid.Length0 then 0
      else row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1)
  }
  
  function row_contribution(grid: array2<int>, row: int): int
      requires 0 <= row < grid.Length0
      reads grid
      ensures row_contribution(grid, row) >= 0
  {
      var cnt0 := count_in_row(grid, row, 0);
      var cnt1 := count_in_row(grid, row, 1);
      (if cnt0 > 1 then power(2, cnt0) - cnt0 - 1 else 0) +
      (if cnt1 > 1 then power(2, cnt1) - cnt1 - 1 else 0)
  }
  
  function sum_col_contributions(grid: array2<int>): int
      reads grid
      ensures sum_col_contributions(grid) >= 0
  {
      sum_col_contributions_helper(grid, 0)
  }
  
  function sum_col_contributions_helper(grid: array2<int>, col: int): int
      requires 0 <= col <= grid.Length1
      reads grid
      ensures sum_col_contributions_helper(grid, col) >= 0
      decreases grid.Length1 - col
  {
      if col == grid.Length1 then 0
      else col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1)
  }
  
  function col_contribution(grid: array2<int>, col: int): int
      requires 0 <= col < grid.Length1
      reads grid
      ensures col_contribution(grid, col) >= 0
  {
      var cnt0 := count_in_col(grid, col, 0);
      var cnt1 := count_in_col(grid, col, 1);
      (if cnt0 > 1 then power(2, cnt0) - cnt0 - 1 else 0) +
      (if cnt1 > 1 then power(2, cnt1) - cnt1 - 1 else 0)
  }
  
  function count_in_row(grid: array2<int>, row: int, value: int): int
      requires 0 <= row < grid.Length0
      reads grid
      ensures count_in_row(grid, row, value) >= 0
      ensures count_in_row(grid, row, value) <= grid.Length1
  {
      count_in_row_helper(grid, row, value, 0)
  }
  
  function count_in_row_helper(grid: array2<int>, row: int, value: int, col: int): int
      requires 0 <= row < grid.Length0
      requires 0 <= col <= grid.Length1
      reads grid
      ensures count_in_row_helper(grid, row, value, col) >= 0
      ensures count_in_row_helper(grid, row, value, col) <= grid.Length1 - col
      decreases grid.Length1 - col
  {
      if col == grid.Length1 then 0
      else (if grid[row, col] == value then 1 else 0) + count_in_row_helper(grid, row, value, col + 1)
  }
  
  function count_in_col(grid: array2<int>, col: int, value: int): int
      requires 0 <= col < grid.Length1
      reads grid
      ensures count_in_col(grid, col, value) >= 0
      ensures count_in_col(grid, col, value) <= grid.Length0
  {
      if grid.Length0 == 0 then 0
      else count_col_helper(grid, col, value, 0)
  }
  
  function count_col_helper(grid: array2<int>, col: int, value: int, row: int): int
      requires 0 <= col < grid.Length1
      requires 0 <= row <= grid.Length0
      reads grid
      ensures count_col_helper(grid, col, value, row) >= 0
      ensures count_col_helper(grid, col, value, row) <= grid.Length0 - row
      decreases grid.Length0 - row
  {
      if row == grid.Length0 then 0
      else (if grid[row, col] == value then 1 else 0) + count_col_helper(grid, col, value, row + 1)
  }

vc-helpers: |-
  function power(base: int, exp: int): int
      requires base >= 0 && exp >= 0
      ensures power(base, exp) >= 0
      ensures exp == 0 ==> power(base, exp) == 1
      ensures exp > 0 && base > 0 ==> power(base, exp) >= base
      ensures base == 2 && exp >= 0 ==> power(base, exp) >= exp
  {
      if exp == 0 then 1
      else base * power(base, exp - 1)
  }
  
  function split_lines(s: string): seq<string>
      ensures |split_lines(s)| >= 0
      ensures forall line :: line in split_lines(s) ==> '\n' !in line
  {
      []
  }
  
  function split_numbers(s: string): seq<int>
      ensures |split_numbers(s)| >= 0
      ensures forall n :: n in split_numbers(s) ==> n >= 0
  {
      []
  }
  
  function int_to_string(n: int): string
      requires n >= 0
      ensures |int_to_string(n)| > 0
      ensures n == 0 ==> int_to_string(n) == "0"
      ensures '\n' !in int_to_string(n)
  {
      if n == 0 then "0"
      else int_to_string_helper(n)
  }
  
  function int_to_string_helper(n: int): string
      requires n > 0
      ensures |int_to_string_helper(n)| > 0
      ensures '\n' !in int_to_string_helper(n)
  {
      if n < 10 then [('0' as int + n) as char]
      else int_to_string_helper(n / 10) + [('0' as int + (n % 10)) as char]
  }

vc-spec: |-
  method solve(stdin_input: string) returns (result: string)
      requires ValidInput(stdin_input)
      ensures |result| > 0
      ensures result[|result|-1] == '\n'
      ensures exists output_value: int :: output_value >= 0 && result == int_to_string(output_value) + "\n"

vc-code: |-
  {
      var lines := split_lines(stdin_input);
      if |lines| < 1 {
          result := "0\n";
          assert int_to_string(0) == "0";
          assert result == int_to_string(0) + "\n";
          return;
      }
  
      var first_line := split_numbers(lines[0]);
      if |first_line| < 2 {
          result := "0\n";
          assert int_to_string(0) == "0";
          assert result == int_to_string(0) + "\n";
          return;
      }
  
      var n := first_line[0];
      var m := first_line[1];
  
      if n <= 0 || m <= 0 || |lines| < n + 1 {
          result := "0\n";
          assert int_to_string(0) == "0";
          assert result == int_to_string(0) + "\n";
          return;
      }
  
      var grid := new int[n, m];
      var i := 0;
      while i < n
          invariant 0 <= i <= n
      {
          if i + 1 < |lines| {
              var row_values := split_numbers(lines[i + 1]);
              var j := 0;
              while j < m && j < |row_values|
                  invariant 0 <= j <= m
              {
                  grid[i, j] := if j < |row_values| then row_values[j] % 2 else 0;
                  j := j + 1;
              }
          }
          i := i + 1;
      }
  
      assert ValidGrid(grid);
  
      var ans := count_valid_sets(grid);
      result := int_to_string(ans) + "\n";
  }

vc-postamble: |-

