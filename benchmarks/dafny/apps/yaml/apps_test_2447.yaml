vc-description: |-
  Given multiple binary strings, determine the minimum number of character flips needed 
  to make each string "good". A string is "good" if it contains neither "010" nor "101" 
  as a subsequence. Input format: first line contains number of test cases t, followed 
  by t binary strings. Output the minimum operations needed for each string.

vc-preamble: |-
  function split_lines(s: string): seq<string>
  {
      [""]  // placeholder implementation
  }
  
  function is_valid_number(s: string): bool
  {
      true  // placeholder implementation
  }
  
  function parse_int(s: string): int
      requires is_valid_number(s)
  {
      0  // placeholder implementation
  }
  
  function is_binary_string(s: string): bool
  {
      true  // placeholder implementation
  }
  
  function ends_with_newline(s: string): bool
  {
      |s| > 0 && s[|s|-1] == '\n'
  }
  
  predicate ValidInput(input: string)
  {
      |input| > 0 &&
      input[|input|-1] == '\n' &&
      exists lines :: 
          lines == split_lines(input) &&
          |lines| >= 2 &&
          is_valid_number(lines[0]) &&
          var t := parse_int(lines[0]);
          t >= 1 && t <= 100 &&
          |lines| == t + 1 &&
          forall i :: 1 <= i < |lines| ==> 
              is_binary_string(lines[i]) && |lines[i]| >= 1 && |lines[i]| <= 1000
  }
  
  predicate ValidOutput(result: string)
  {
      result != "" &&
      (ends_with_newline(result) || result == "") &&
      exists output_lines :: 
          output_lines == split_lines(result) &&
          |output_lines| >= 1 &&
          (forall i :: 0 <= i < |output_lines|-1 ==> is_valid_number(output_lines[i])) &&
          (forall i :: 0 <= i < |output_lines|-1 ==> parse_int(output_lines[i]) >= 0)
  }
  
  predicate CorrectResult(input: string, result: string)
      requires ValidInput(input)
  {
      exists input_lines, t :: 
          input_lines == split_lines(input) &&
          t == parse_int(input_lines[0]) &&
          var output_lines := split_lines(result);
          |output_lines| == t + 1 &&
          forall test_case :: 0 <= test_case < t ==>
              var s := input_lines[test_case + 1];
              var min_ops := parse_int(output_lines[test_case]);
              min_ops == min_operations_to_make_good(s)
  }
  
  function min_operations_to_make_good(s: string): int
      requires is_binary_string(s)
      ensures min_operations_to_make_good(s) >= 0
      ensures min_operations_to_make_good(s) <= |s|
  {
      if |s| == 0 then 0
      else min_ops_helper(s, 0, |s|)
  }

vc-helpers: |-
  function count_char(s: string, c: char): int
      ensures count_char(s, c) >= 0
      ensures count_char(s, c) <= |s|
  {
      if |s| == 0 then 0
      else if s[0] == c then 1 + count_char(s[1..], c)
      else count_char(s[1..], c)
  }
  
  function min_ops_helper(s: string, split_pos: int, best_so_far: int): int
      requires is_binary_string(s)
      requires 0 <= split_pos <= |s|
      requires best_so_far >= 0
      requires best_so_far <= |s|
      ensures min_ops_helper(s, split_pos, best_so_far) >= 0
      ensures min_ops_helper(s, split_pos, best_so_far) <= |s|
      decreases |s| - split_pos
  {
      if split_pos >= |s| then best_so_far
      else
          var prefix := s[..split_pos];
          var suffix := s[split_pos..];
          var cost1 := count_char(prefix, '0') + count_char(suffix, '1');
          var cost2 := count_char(prefix, '1') + count_char(suffix, '0');
          var min_cost := if cost1 <= cost2 then cost1 else cost2;
          var new_best := if min_cost < best_so_far then min_cost else best_so_far;
          min_ops_helper(s, split_pos + 1, new_best)
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires ValidInput(input)
      ensures ValidOutput(result)
      ensures CorrectResult(input, result)

vc-code: |-
  {
      result := "";
  }

vc-postamble: |-

