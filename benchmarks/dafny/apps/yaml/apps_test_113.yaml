vc-description: |-
  Find the minimum positive integer x such that x is divisible by n and x ends with k or more zeros in base 10.
  A number ends with k zeros if and only if it's divisible by 10^k = 2^k Ã— 5^k.
  Algorithm: Factor out powers of 2 and 5 from n, then multiply n by additional factors needed to achieve k trailing zeros.

vc-preamble: |-
  function power(base: int, exp: int): int
      requires exp >= 0
      ensures exp == 0 ==> power(base, exp) == 1
      ensures base > 0 ==> power(base, exp) > 0
      ensures base != 0 ==> power(base, exp) != 0
      decreases exp
  {
      if exp == 0 then 1
      else base * power(base, exp - 1)
  }

vc-helpers: |-
  

vc-spec: |-
  method solve(n: int, k: int) returns (result: int)
      requires n > 0 && k >= 0
      ensures result > 0
      ensures result % n == 0
      ensures result % power(10, k) == 0
      ensures forall m :: m > 0 && m % n == 0 && m % power(10, k) == 0 ==> result <= m

vc-code: |-
  {
      var num_2 := 0;
      var num_5 := 0;
      var x := n;
  
      // Count factors of 2
      while x % 2 == 0
          invariant x > 0
          invariant x <= n
          invariant n == x * power(2, num_2)
          decreases x
      {
          num_2 := num_2 + 1;
          x := x / 2;
      }
  
      // Reset x and count factors of 5
      x := n;
      while x % 5 == 0
          invariant x > 0
          invariant x <= n
          invariant n == x * power(5, num_5)
          decreases x
      {
          num_5 := num_5 + 1;
          x := x / 5;
      }
  
      // Calculate additional factors needed
      var add_2 := if k > num_2 then k - num_2 else 0;
      var add_5 := if k > num_5 then k - num_5 else 0;
  
      // Calculate result
      result := n * power(2, add_2) * power(5, add_5);
  
      // Help verifier prove postconditions
      assert power(2, add_2) > 0;
      assert power(5, add_5) > 0;
      assert power(10, k) > 0;
      assert add_2 + num_2 >= k && add_5 + num_5 >= k;
  }

vc-postamble: |-
