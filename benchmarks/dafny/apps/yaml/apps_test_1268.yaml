vc-description: |-
  Given n cola cans where each can i has remaining volume a_i and capacity b_i,
  determine if all remaining cola can be poured into exactly 2 cans.

vc-preamble: |-
  predicate ValidInput(a: seq<int>, b: seq<int>)
  {
    |a| == |b| && |a| >= 2 && forall i :: 0 <= i < |a| ==> 0 <= a[i] <= b[i]
  }
  
  function sumSeq(s: seq<int>): int
  {
    if |s| == 0 then 0
    else s[0] + sumSeq(s[1..])
  }
  
  function findTwoLargestSum(s: seq<int>): int
    requires |s| >= 2
    ensures exists i, j :: 0 <= i < |s| && 0 <= j < |s| && i != j && 
            findTwoLargestSum(s) == s[i] + s[j] &&
            (forall k :: 0 <= k < |s| && k != i ==> s[k] <= s[i] || s[k] <= s[j]) &&
            (forall k :: 0 <= k < |s| && k != j ==> s[k] <= s[i] || s[k] <= s[j])
  {
    var max1 := findMax(s);
    var max2 := findMaxExcluding(s, max1);
    s[max1] + s[max2]
  }
  
  function findMax(s: seq<int>): int
    requires |s| >= 1
    ensures 0 <= findMax(s) < |s|
    ensures forall i :: 0 <= i < |s| ==> s[i] <= s[findMax(s)]
  {
    if |s| == 1 then 0
    else
      var restMax := findMax(s[1..]);
      if s[0] >= s[restMax + 1] then 0 else restMax + 1
  }
  
  function findMaxExcluding(s: seq<int>, exclude: int): int
    requires |s| >= 2
    requires 0 <= exclude < |s|
    ensures 0 <= findMaxExcluding(s, exclude) < |s|
    ensures findMaxExcluding(s, exclude) != exclude
    ensures forall i :: 0 <= i < |s| && i != exclude ==> s[i] <= s[findMaxExcluding(s, exclude)]
  {
    if exclude == 0 then
      1 + findMax(s[1..])
    else if exclude == |s| - 1 then
      findMax(s[..|s|-1])
    else
      var leftMax := if |s[..exclude]| > 0 then findMax(s[..exclude]) else -1;
      var rightMax := if |s[exclude+1..]| > 0 then exclude + 1 + findMax(s[exclude+1..]) else -1;
      if leftMax == -1 then rightMax
      else if rightMax == -1 then leftMax
      else if s[leftMax] >= s[rightMax] then leftMax else rightMax
  }

vc-helpers: |-
  method findTwoLargest(s: seq<int>) returns (sum: int)
    requires |s| >= 2
    ensures sum == findTwoLargestSum(s)
  {
    var first := s[0];
    var second := s[1];
    var firstIdx := 0;
    var secondIdx := 1;
  
    if second > first {
      first := s[1];
      second := s[0];
      firstIdx := 1;
      secondIdx := 0;
    }
  
    var i := 2;
    while i < |s|
      invariant 2 <= i <= |s|
      invariant 0 <= firstIdx < |s| && 0 <= secondIdx < |s| && firstIdx != secondIdx
      invariant first == s[firstIdx] && second == s[secondIdx]
      invariant forall k :: 0 <= k < i ==> s[k] <= first
      invariant forall k :: 0 <= k < i && k != firstIdx ==> s[k] <= second
      invariant firstIdx < i && secondIdx < i
    {
      if s[i] > first {
        second := first;
        secondIdx := firstIdx;
        first := s[i];
        firstIdx := i;
      } else if s[i] > second {
        second := s[i];
        secondIdx := i;
      }
      i := i + 1;
    }
  
    sum := first + second;
  }

vc-spec: |-
  method solve(a: seq<int>, b: seq<int>) returns (result: string)
    requires ValidInput(a, b)
    ensures result == "YES" || result == "NO"
    ensures result == "YES" <==> findTwoLargestSum(b) >= sumSeq(a)

vc-code: |-
  {
    var totalVolume := sumSeq(a);
    var maxCapacities := findTwoLargest(b);
  
    if maxCapacities >= totalVolume {
      result := "YES";
    } else {
      result := "NO";
    }
  }

vc-postamble: |-

