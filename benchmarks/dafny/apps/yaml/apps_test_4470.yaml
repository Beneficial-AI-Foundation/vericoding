vc-description: |-
  Given an integer n, find the minimum number of operations to transform it to 1, or return -1 if impossible.
  Allowed operations: 1) n → n/2 if n divisible by 2, 2) n → 2n/3 if n divisible by 3, 3) n → 4n/5 if n divisible by 5.

vc-preamble: |-
  predicate ValidInput(n: nat)
  {
      n > 0
  }
  
  predicate CanReachOne(n: nat)
      requires n > 0
  {
      OnlyFactors235(n)
  }
  
  predicate OnlyFactors235(n: nat)
      requires n > 0
  {
      ReduceByFactors235(n) == 1
  }
  
  function ReduceByFactors235(n: nat): nat
      requires n > 0
      decreases n
  {
      if n == 1 then 1
      else if n % 2 == 0 then ReduceByFactors235(n / 2)
      else if n % 3 == 0 then ReduceByFactors235(n / 3)
      else if n % 5 == 0 then ReduceByFactors235(n / 5)
      else n
  }
  
  function MinMovesToOne(n: nat): nat
      requires n > 0
      requires CanReachOne(n)
      decreases n
  {
      if n == 1 then 0
      else if n % 2 == 0 then 1 + MinMovesToOne(n / 2)
      else if n % 3 == 0 then 2 + MinMovesToOne(n / 3)
      else if n % 5 == 0 then 3 + MinMovesToOne(n / 5)
      else 0
  }

vc-helpers: |-

vc-spec: |-
  method Solve(n: nat) returns (result: int)
      requires ValidInput(n)
      ensures result >= -1
      ensures result == -1 <==> !CanReachOne(n)
      ensures result >= 0 ==> CanReachOne(n) && result == MinMovesToOne(n)

vc-code: |-
  {
    assume {:axiom} false;
  }

vc-postamble: |-

