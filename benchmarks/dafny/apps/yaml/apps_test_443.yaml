vc-description: |-
  Given n packets of balloons, divide all packets between two people such that:
  1. Each person gets at least one packet
  2. All packets are distributed 
  3. The total number of balloons each person receives is different
  Find any valid distribution or return empty sequence if impossible.

vc-preamble: |-
  predicate ValidInput(n: int, packets: seq<int>)
  {
      n >= 1 && |packets| == n && forall i :: 0 <= i < |packets| ==> packets[i] >= 1
  }
  
  predicate IsPossible(n: int, packets: seq<int>)
      requires ValidInput(n, packets)
  {
      n >= 2 && (n > 2 || packets[0] != packets[1])
  }
  
  function SumPackets(packets: seq<int>): int
  {
      if |packets| == 0 then 0 else packets[0] + SumPackets(packets[1..])
  }
  
  predicate ValidSolution(n: int, packets: seq<int>, result: seq<int>)
      requires ValidInput(n, packets)
  {
      if !IsPossible(n, packets) then
          |result| == 0
      else
          |result| == 2 && result[0] == 1 && 1 <= result[1] <= n &&
          exists minIndex :: 0 <= minIndex < |packets| && 
          result[1] == minIndex + 1 &&
          (forall j :: 0 <= j < |packets| ==> packets[minIndex] <= packets[j]) &&
          (forall k :: 0 <= k < minIndex ==> packets[k] > packets[minIndex])
  }

vc-helpers: |-

vc-spec: |-
  method solve(n: int, packets: seq<int>) returns (result: seq<int>)
      requires ValidInput(n, packets)
      ensures ValidSolution(n, packets, result)

vc-code: |-
  {
      if n < 2 {
          result := [];
          return;
      }
  
      if n == 2 && packets[0] == packets[1] {
          result := [];
          return;
      }
  
      // Find the minimum value and its index
      var minVal := packets[0];
      var minIndex := 0;
      var i := 1;
  
      while i < |packets|
          invariant 1 <= i <= |packets|
          invariant 0 <= minIndex < i
          invariant minVal == packets[minIndex]
          invariant forall j :: 0 <= j < i ==> packets[minIndex] <= packets[j]
          invariant forall k :: 0 <= k < minIndex ==> packets[k] > packets[minIndex]
      {
          if packets[i] < minVal {
              minVal := packets[i];
              minIndex := i;
          }
          i := i + 1;
      }
  
      // Return [1, minIndex + 1] (1-indexed)
      result := [1, minIndex + 1];
  }

vc-postamble: |-

