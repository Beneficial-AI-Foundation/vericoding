vc-description: |-
  Given a string of lowercase English letters containing at least one 'a',
  find the maximum length of a string obtainable by erasing some characters
  such that the resulting string has strictly more than half of its characters as 'a's.

vc-preamble: |-
  function count_a(s: string): int
      ensures count_a(s) >= 0
      ensures count_a(s) <= |s|
  {
      if |s| == 0 then 0
      else (if s[0] == 'a' then 1 else 0) + count_a(s[1..])
  }
  
  function min(a: int, b: int): int
  {
      if a <= b then a else b
  }
  
  predicate ValidInput(s: string)
  {
      |s| >= 1 && exists i :: 0 <= i < |s| && s[i] == 'a'
  }
  
  predicate IsGoodString(s: string)
  {
      |s| > 0 && count_a(s) > |s| / 2
  }

vc-helpers: |-
  lemma CountASliceProperty(s: string, i: int)
      requires 0 <= i < |s|
      ensures count_a(s[0..i+1]) == count_a(s[0..i]) + (if s[i] == 'a' then 1 else 0)
  {
      if i == 0 {
          assert s[0..1] == [s[0]];
          assert count_a(s[0..1]) == count_a([s[0]]);
          assert count_a([s[0]]) == (if s[0] == 'a' then 1 else 0);
          assert count_a(s[0..0]) == 0;
      } else {
          assert s[0..i+1] == s[0..i] + [s[i]];
          CountAAppendProperty(s[0..i], s[i]);
      }
  }
  
  lemma CountAAppendProperty(s1: string, c: char)
      ensures count_a(s1 + [c]) == count_a(s1) + (if c == 'a' then 1 else 0)
  {
      if |s1| == 0 {
          assert s1 + [c] == [c];
          assert count_a([c]) == (if c == 'a' then 1 else 0);
      } else {
          assert s1 + [c] == [s1[0]] + (s1[1..] + [c]);
          CountAAppendProperty(s1[1..], c);
      }
  }

vc-spec: |-
  method solve(s: string) returns (result: int)
      requires ValidInput(s)
      ensures result >= 1
      ensures result <= |s|
      ensures result == min(2 * count_a(s) - 1, |s|)

vc-code: |-
  {
      var count := 0;
      var i := 0;
  
      // Count number of 'a' characters
      while i < |s|
          invariant 0 <= i <= |s|
          invariant count == count_a(s[0..i])
          invariant (exists j :: 0 <= j < i && s[j] == 'a') ==> count >= 1
      {
          if s[i] == 'a' {
              count := count + 1;
          }
  
          // Use the lemma to help prove the invariant before incrementing i
          CountASliceProperty(s, i);
  
          i := i + 1;
      }
  
      assert s[0..|s|] == s;
      assert count == count_a(s);
      assert exists j :: 0 <= j < |s| && s[j] == 'a';
      assert count >= 1;
  
      // Calculate 2*count - 1
      var maxGoodLength := 2 * count - 1;
  
      // Return minimum of maxGoodLength and original string length
      if maxGoodLength <= |s| {
          result := maxGoodLength;
      } else {
          result := |s|;
      }
  }

vc-postamble: |-
