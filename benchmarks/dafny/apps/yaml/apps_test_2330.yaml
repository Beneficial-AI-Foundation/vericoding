vc-description: |-
  Given n fridges with weights a₁, a₂, ..., aₙ, create exactly m steel chains between fridges 
  such that all fridges are "private". A chain connecting fridges u and v costs aᵤ + aᵥ. 
  A fridge is "private" if only its owner can unlock it. Find the minimum total cost to create 
  exactly m chains making all fridges private, or determine if impossible.

vc-preamble: |-
  datatype Result = Impossible | Possible(cost: int, edges: seq<(int, int)>)
  
  function seq_sum(s: seq<int>): int {
      if |s| == 0 then 0 else s[0] + seq_sum(s[1..])
  }
  
  function seq_sum_first(s: seq<int>, n: int): int
      requires 0 <= n <= |s|
  {
      if n == 0 then 0 else s[n-1] + seq_sum_first(s, n-1)
  }
  
  function min_index(weights: seq<int>): int
      requires |weights| > 0
      ensures 0 <= min_index(weights) < |weights|
      ensures forall j :: 0 <= j < |weights| ==> weights[min_index(weights)] <= weights[j]
  {
      min_index_helper(weights, 0, 1)
  }
  
  function min_index_helper(weights: seq<int>, current_min: int, next: int): int
      requires |weights| > 0
      requires 0 <= current_min < |weights|
      requires 0 <= next <= |weights|
      requires forall j :: 0 <= j < next ==> weights[current_min] <= weights[j]
      ensures 0 <= min_index_helper(weights, current_min, next) < |weights|
      ensures forall j :: 0 <= j < |weights| ==> weights[min_index_helper(weights, current_min, next)] <= weights[j]
      decreases |weights| - next
  {
      if next >= |weights| then current_min
      else if weights[next] < weights[current_min] then min_index_helper(weights, next, next + 1)
      else min_index_helper(weights, current_min, next + 1)
  }
  
  function min_index_excluding(weights: seq<int>, exclude: int): int
      requires |weights| > 1
      requires 0 <= exclude < |weights|
      ensures 0 <= min_index_excluding(weights, exclude) < |weights|
      ensures min_index_excluding(weights, exclude) != exclude
      ensures forall j :: 0 <= j < |weights| && j != exclude ==> 
          weights[min_index_excluding(weights, exclude)] <= weights[j]
  {
      var first_valid := if exclude == 0 then 1 else 0;
      min_index_excluding_helper(weights, exclude, first_valid, 0)
  }
  
  function min_index_excluding_helper(weights: seq<int>, exclude: int, current_min: int, next: int): int
      requires |weights| > 1
      requires 0 <= exclude < |weights|
      requires 0 <= current_min < |weights|
      requires current_min != exclude
      requires 0 <= next <= |weights|
      requires forall j :: 0 <= j < next && j != exclude ==> weights[current_min] <= weights[j]
      ensures 0 <= min_index_excluding_helper(weights, exclude, current_min, next) < |weights|
      ensures min_index_excluding_helper(weights, exclude, current_min, next) != exclude
      ensures forall j :: 0 <= j < |weights| && j != exclude ==> 
          weights[min_index_excluding_helper(weights, exclude, current_min, next)] <= weights[j]
      decreases |weights| - next
  {
      if next >= |weights| then current_min
      else if next == exclude then min_index_excluding_helper(weights, exclude, current_min, next + 1)
      else if weights[next] < weights[current_min] then min_index_excluding_helper(weights, exclude, next, next + 1)
      else min_index_excluding_helper(weights, exclude, current_min, next + 1)
  }

vc-helpers: |-
  lemma seq_sum_first_lemma(s: seq<int>, n: int)
      requires 0 <= n < |s|
      ensures seq_sum_first(s, n+1) == seq_sum_first(s, n) + s[n]
  {
  }
  
  lemma seq_sum_equivalence(s: seq<int>)
      ensures seq_sum(s) == seq_sum_first(s, |s|)
  {
      if |s| == 0 {
          assert seq_sum(s) == 0;
          assert seq_sum_first(s, 0) == 0;
      } else if |s| == 1 {
          assert seq_sum(s) == s[0];
          assert seq_sum_first(s, 1) == s[0];
      } else {
          seq_sum_equivalence(s[1..]);
          assert seq_sum(s[1..]) == seq_sum_first(s[1..], |s[1..]|);
          assert seq_sum_first(s[1..], |s[1..]|) == seq_sum_first(s[1..], |s| - 1);
          seq_sum_first_shift_lemma(s, |s| - 1);
      }
  }
  
  lemma seq_sum_first_shift_lemma(s: seq<int>, n: int)
      requires 0 < n <= |s|
      ensures seq_sum_first(s[1..], n-1) == seq_sum_first(s, n) - s[0]
  {
      if n == 1 {
          assert seq_sum_first(s[1..], 0) == 0;
          assert seq_sum_first(s, 1) == s[0];
      } else {
          seq_sum_first_shift_lemma(s, n-1);
      }
  }

vc-spec: |-
  method solve(t: int, cases: seq<(int, int, seq<int>)>) returns (results: seq<Result>)
      requires t >= 0
      requires |cases| == t
      requires forall i :: 0 <= i < t ==> 
          cases[i].0 >= 0 && cases[i].1 >= 0 && |cases[i].2| == cases[i].0
      ensures |results| == t
      ensures forall i :: 0 <= i < t ==> 
          var n := cases[i].0;
          var m := cases[i].1;
          (n <= 2 || m < n) ==> results[i] == Impossible
      ensures forall i :: 0 <= i < t ==> 
          var n := cases[i].0;
          var m := cases[i].1;
          var weights := cases[i].2;
          (n > 2 && m >= n && results[i].Possible?) ==> 
              |results[i].edges| == m &&
              (forall j :: 0 <= j < |results[i].edges| ==> 
                  1 <= results[i].edges[j].0 <= n && 1 <= results[i].edges[j].1 <= n &&
                  results[i].edges[j].0 != results[i].edges[j].1)
      ensures forall i :: 0 <= i < t ==> 
          var n := cases[i].0;
          var m := cases[i].1;
          var weights := cases[i].2;
          (n > 2 && m >= n && results[i].Possible?) ==> 
              var min1_idx := min_index(weights);
              var min2_idx := min_index_excluding(weights, min1_idx);
              results[i].cost == 2 * seq_sum(weights) + (m - n) * (weights[min1_idx] + weights[min2_idx])
      ensures forall i :: 0 <= i < t ==> 
          var n := cases[i].0;
          var m := cases[i].1;
          (n > 2 && m >= n && results[i].Possible?) ==> 
              (forall j :: 0 <= j < n ==> 
                  results[i].edges[j] == (j + 1, if j == n - 1 then 1 else j + 2)) &&
              (forall j :: n <= j < m ==> 
                  var min1_idx := min_index(cases[i].2);
                  var min2_idx := min_index_excluding(cases[i].2, min1_idx);
                  results[i].edges[j] == (min1_idx + 1, min2_idx + 1))

vc-code: |-
  {
      results := [];
  
      for i := 0 to t
          invariant 0 <= i <= t
          invariant |results| == i
          invariant forall k :: 0 <= k < i ==> 
              var n := cases[k].0;
              var m := cases[k].1;
              (n <= 2 || m < n) ==> results[k] == Impossible
          invariant forall k :: 0 <= k < i ==> 
              var n := cases[k].0;
              var m := cases[k].1;
              var weights := cases[k].2;
              (n > 2 && m >= n && results[k].Possible?) ==> 
                  |results[k].edges| == m &&
                  (forall j :: 0 <= j < |results[k].edges| ==> 
                      1 <= results[k].edges[j].0 <= n && 1 <= results[k].edges[j].1 <= n &&
                      results[k].edges[j].0 != results[k].edges[j].1)
          invariant forall k :: 0 <= k < i ==> 
              var n := cases[k].0;
              var m := cases[k].1;
              var weights := cases[k].2;
              (n > 2 && m >= n && results[k].Possible?) ==> 
                  var min1_idx := min_index(weights);
                  var min2_idx := min_index_excluding(weights, min1_idx);
                  results[k].cost == 2 * seq_sum(weights) + (m - n) * (weights[min1_idx] + weights[min2_idx])
          invariant forall k :: 0 <= k < i ==> 
              var n := cases[k].0;
              var m := cases[k].1;
              (n > 2 && m >= n && results[k].Possible?) ==> 
                  (forall j :: 0 <= j < n ==> 
                      results[k].edges[j] == (j + 1, if j == n - 1 then 1 else j + 2)) &&
                  (forall j :: n <= j < m ==> 
                      var min1_idx := min_index(cases[k].2);
                      var min2_idx := min_index_excluding(cases[k].2, min1_idx);
                      results[k].edges[j] == (min1_idx + 1, min2_idx + 1))
      {
          var n := cases[i].0;
          var m := cases[i].1;
          var weights := cases[i].2;
  
          if n <= 2 || m < n {
              results := results + [Impossible];
          } else {
              var cost := 0;
              var edges: seq<(int, int)> := [];
  
              for j := 0 to n
                  invariant 0 <= j <= n
                  invariant |edges| == j
                  invariant cost == 2 * seq_sum_first(weights, j)
                  invariant forall k :: 0 <= k < j ==> 
                      edges[k] == (k + 1, if k == n - 1 then 1 else k + 2)
              {
                  var u := j + 1;
                  var v := if j == n - 1 then 1 else j + 2;
                  edges := edges + [(u, v)];
                  cost := cost + 2 * weights[j];
                  seq_sum_first_lemma(weights, j);
              }
  
              seq_sum_equivalence(weights);
              assert cost == 2 * seq_sum(weights);
  
              var min1 := min_index(weights);
              var min2 := min_index_excluding(weights, min1);
  
              if m > n {
                  for extra := 0 to m - n
                      invariant 0 <= extra <= m - n
                      invariant |edges| == n + extra
                      invariant cost == 2 * seq_sum(weights) + extra * (weights[min1] + weights[min2])
                      invariant forall k :: 0 <= k < n ==> 
                          edges[k] == (k + 1, if k == n - 1 then 1 else k + 2)
                      invariant forall k :: n <= k < n + extra ==> 
                          edges[k] == (min1 + 1, min2 + 1)
                  {
                      edges := edges + [(min1 + 1, min2 + 1)];
                      cost := cost + weights[min1] + weights[min2];
                  }
              }
  
              var tmpCall1 := Possible(cost, edges);
              results := results + [tmpCall1];
          }
      }
  }

vc-postamble: |-

