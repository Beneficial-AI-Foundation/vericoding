vc-description: |-
  Given a string s consisting of uppercase Latin letters, determine if it contains 
  two non-overlapping substrings "AB" and "BA". Return "YES" if both substrings 
  exist without overlapping, "NO" otherwise.

vc-preamble: |-
  function CountSubstring(s: string, pattern: string): nat
  {
      if |pattern| == 0 || |s| < |pattern| then 0
      else if s[..|pattern|] == pattern then 1 + CountSubstring(s[1..], pattern)
      else CountSubstring(s[1..], pattern)
  }
  
  function FindIndex(s: string, pattern: string): int
  {
      if |pattern| == 0 || |s| < |pattern| then -1
      else if s[..|pattern|] == pattern then 0
      else 
          var rest := FindIndex(s[1..], pattern);
          if rest == -1 then -1 else 1 + rest
  }
  
  predicate HasNonOverlappingABAndBA(s: string)
  {
      var abIndex := FindIndex(s, "AB");
      var baIndex := FindIndex(s, "BA");
  
      (abIndex >= 0 && baIndex >= 0) &&
      (
          (abIndex >= 0 && abIndex + 2 < |s| && CountSubstring(s[abIndex + 2..], "BA") > 0) ||
          (baIndex >= 0 && baIndex + 2 < |s| && CountSubstring(s[baIndex + 2..], "AB") > 0)
      )
  }
  
  predicate ValidInput(input: string)
  {
      |input| >= 0
  }

vc-helpers: |-
  lemma CountZeroImpliesIndexNegOne(s: string, pattern: string)
      requires |pattern| > 0
      ensures CountSubstring(s, pattern) == 0 ==> FindIndex(s, pattern) == -1
  {
      if |s| < |pattern| {
          // Base case: string too short
      } else if s[..|pattern|] == pattern {
          // If we found the pattern, count would be at least 1
          assert CountSubstring(s, pattern) >= 1;
      } else {
          // Recursive case
          CountZeroImpliesIndexNegOne(s[1..], pattern);
      }
  }
  
  lemma CountPositiveImpliesIndexNonNegative(s: string, pattern: string)
      requires |pattern| > 0
      ensures CountSubstring(s, pattern) > 0 ==> FindIndex(s, pattern) >= 0
  {
      if |s| < |pattern| {
          // Base case: string too short, count is 0
          assert CountSubstring(s, pattern) == 0;
      } else if s[..|pattern|] == pattern {
          // If we found the pattern at the beginning, index is 0
          assert FindIndex(s, pattern) == 0;
      } else {
          // Recursive case
          CountPositiveImpliesIndexNonNegative(s[1..], pattern);
          if CountSubstring(s, pattern) > 0 {
              // Count is positive, so the recursive part must have found something
              assert CountSubstring(s[1..], pattern) > 0;
              var restIndex := FindIndex(s[1..], pattern);
              assert restIndex >= 0;
              assert FindIndex(s, pattern) == 1 + restIndex >= 0;
          }
      }
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires ValidInput(input)
      ensures result == "YES" <==> HasNonOverlappingABAndBA(if |input| > 0 && input[|input|-1] == '\n' then input[..|input|-1] else input)
      ensures result == "YES" || result == "NO"
      ensures (var s := if |input| > 0 && input[|input|-1] == '\n' then input[..|input|-1] else input;
               CountSubstring(s, "AB") == 0 || CountSubstring(s, "BA") == 0) ==> result == "NO"
      ensures (var s := if |input| > 0 && input[|input|-1] == '\n' then input[..|input|-1] else input;
               var abIndex := FindIndex(s, "AB");
               var baIndex := FindIndex(s, "BA");
               CountSubstring(s, "AB") > 0 && CountSubstring(s, "BA") > 0 &&
               !((abIndex >= 0 && abIndex + 2 < |s| && CountSubstring(s[abIndex + 2..], "BA") > 0) ||
                 (baIndex >= 0 && baIndex + 2 < |s| && CountSubstring(s[baIndex + 2..], "AB") > 0))) ==> result == "NO"

vc-code: |-
  {
      var s := input;
      if |s| > 0 && s[|s|-1] == '\n' {
          s := s[..|s|-1];
      }
  
      var abCount := CountSubstring(s, "AB");
      var baCount := CountSubstring(s, "BA");
  
      if abCount == 0 || baCount == 0 {
          CountZeroImpliesIndexNegOne(s, "AB");
          CountZeroImpliesIndexNegOne(s, "BA");
  
          // Help Dafny see that HasNonOverlappingABAndBA(s) is false
          var abIndex := FindIndex(s, "AB");
          var baIndex := FindIndex(s, "BA");
          assert abCount == 0 ==> abIndex == -1;
          assert baCount == 0 ==> baIndex == -1;
          assert (abCount == 0 || baCount == 0) ==> !(abIndex >= 0 && baIndex >= 0);
          assert !HasNonOverlappingABAndBA(s);
  
          result := "NO";
          return;
      }
  
      var abIndex := FindIndex(s, "AB");
      var baIndex := FindIndex(s, "BA");
  
      CountPositiveImpliesIndexNonNegative(s, "AB");
      CountPositiveImpliesIndexNonNegative(s, "BA");
  
      if abIndex >= 0 && abIndex + 2 < |s| {
          var restAfterAB := s[abIndex + 2..];
          if CountSubstring(restAfterAB, "BA") > 0 {
              // Both AB and BA exist, and BA exists after AB
              assert abIndex >= 0;
              assert baIndex >= 0; // Since baCount > 0
              assert HasNonOverlappingABAndBA(s);
              result := "YES";
              return;
          }
      }
  
      if baIndex >= 0 && baIndex + 2 < |s| {
          var restAfterBA := s[baIndex + 2..];
          if CountSubstring(restAfterBA, "AB") > 0 {
              // Both BA and AB exist, and AB exists after BA
              assert baIndex >= 0;
              assert abIndex >= 0; // Since abCount > 0
              assert HasNonOverlappingABAndBA(s);
              result := "YES";
              return;
          }
      }
  
      // Neither condition for YES is met
      assert !HasNonOverlappingABAndBA(s);
      result := "NO";
  }

vc-postamble: |-
