vc-description: |-
  Given n monsters with health points, player and opponent take turns attacking until each monster dies.
  Player attacks first with damage a, opponent with damage b. Player gets 1 point for killing a monster.
  Player can skip opponent's turn at most k times total. Find maximum points achievable.

vc-preamble: |-
  predicate ValidInput(n: int, a: int, b: int, k: int, H: seq<int>)
  {
      n > 0 && a > 0 && b > 0 && k >= 0 && |H| == n && 
      forall i :: 0 <= i < |H| ==> H[i] > 0
  }
  
  function ProcessHealthValues(H: seq<int>, a: int, b: int): seq<int>
      requires a > 0 && b > 0
      requires forall i :: 0 <= i < |H| ==> H[i] > 0
      ensures |ProcessHealthValues(H, a, b)| == |H|
      ensures forall i :: 0 <= i < |H| ==> 
          var h_mod := H[i] % (a + b);
          ProcessHealthValues(H, a, b)[i] == (if h_mod == 0 then a + b else h_mod)
      ensures forall i :: 0 <= i < |ProcessHealthValues(H, a, b)| ==> 
          1 <= ProcessHealthValues(H, a, b)[i] <= a + b
  {
      if |H| == 0 then []
      else 
          var h_mod := H[0] % (a + b);
          var h_final := if h_mod == 0 then a + b else h_mod;
          [h_final] + ProcessHealthValues(H[1..], a, b)
  }
  
  function CountKillableMonsters(sorted_health: seq<int>, a: int, k: int): int
      requires a > 0 && k >= 0
      requires forall i, j :: 0 <= i < j < |sorted_health| ==> sorted_health[i] <= sorted_health[j]
      requires forall i :: 0 <= i < |sorted_health| ==> sorted_health[i] > 0
      ensures 0 <= CountKillableMonsters(sorted_health, a, k) <= |sorted_health|
  {
      CountKillableHelper(sorted_health, a, k, 0, 0)
  }
  
  function CountKillableHelper(sorted_health: seq<int>, a: int, remaining_k: int, index: int, acc: int): int
      requires a > 0 && remaining_k >= 0 && 0 <= index <= |sorted_health| && acc >= 0
      requires forall i, j :: 0 <= i < j < |sorted_health| ==> sorted_health[i] <= sorted_health[j]
      requires forall i :: 0 <= i < |sorted_health| ==> sorted_health[i] > 0
      ensures CountKillableHelper(sorted_health, a, remaining_k, index, acc) >= acc
      ensures CountKillableHelper(sorted_health, a, remaining_k, index, acc) <= acc + (|sorted_health| - index)
      decreases |sorted_health| - index
  {
      if index >= |sorted_health| then acc
      else
          var x := sorted_health[index];
          if x <= a then
              CountKillableHelper(sorted_health, a, remaining_k, index + 1, acc + 1)
          else
              var needed_skips := (x + a - 1) / a - 1;
              if remaining_k >= needed_skips then
                  CountKillableHelper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)
              else
                  CountKillableHelper(sorted_health, a, remaining_k, index + 1, acc)
  }

vc-helpers: |-
  method SortSequence(arr: seq<int>) returns (sorted_arr: seq<int>)
      requires |arr| >= 0
      ensures |sorted_arr| == |arr|
      ensures multiset(sorted_arr) == multiset(arr)
      ensures forall i, j :: 0 <= i < j < |sorted_arr| ==> sorted_arr[i] <= sorted_arr[j]
  {
      if |arr| == 0 {
          sorted_arr := [];
          return;
      }
  
      sorted_arr := arr;
      var n := |arr|;
      var i := 0;
      while i < n
          invariant 0 <= i <= n
          invariant |sorted_arr| == n
          invariant multiset(sorted_arr) == multiset(arr)
          invariant forall x, y :: 0 <= x < y < i ==> sorted_arr[x] <= sorted_arr[y]
          invariant forall x, y :: 0 <= x < i && i <= y < n ==> sorted_arr[x] <= sorted_arr[y]
      {
          var j := i + 1;
          while j < n
              invariant i + 1 <= j <= n
              invariant |sorted_arr| == n
              invariant multiset(sorted_arr) == multiset(arr)
              invariant forall x, y :: 0 <= x < y < i ==> sorted_arr[x] <= sorted_arr[y]
              invariant forall x, y :: 0 <= x < i && i <= y < n ==> sorted_arr[x] <= sorted_arr[y]
              invariant forall y :: i + 1 <= y < j ==> sorted_arr[i] <= sorted_arr[y]
          {
              if sorted_arr[i] > sorted_arr[j] {
                  var temp := sorted_arr[i];
                  sorted_arr := sorted_arr[i := sorted_arr[j]][j := temp];
              }
              j := j + 1;
          }
          i := i + 1;
      }
  }

vc-spec: |-
  method SolveCore(n: int, a: int, b: int, k: int, H: seq<int>) returns (result: int)
      requires ValidInput(n, a, b, k, H)
      ensures 0 <= result <= n

vc-code: |-
  {
      var processed := [];
      var i := 0;
      while i < n
          invariant 0 <= i <= n
          invariant |processed| == i
          invariant forall j :: 0 <= j < i ==> 
              var h_mod := H[j] % (a + b);
              processed[j] == (if h_mod == 0 then a + b else h_mod)
          invariant forall j :: 0 <= j < |processed| ==> 1 <= processed[j] <= a + b
      {
          var h_mod := H[i] % (a + b);
          var h_final := if h_mod == 0 then a + b else h_mod;
          processed := processed + [h_final];
          i := i + 1;
      }
  
      var sorted_health := SortSequence(processed);
      var ans := 0;
      var remaining_k := k;
      i := 0;
  
      while i < |sorted_health|
          invariant 0 <= i <= |sorted_health|
          invariant 0 <= ans <= i
          invariant remaining_k >= 0
      {
          var x := sorted_health[i];
          if x <= a {
              ans := ans + 1;
          } else {
              var needed_skips := (x + a - 1) / a - 1;
              if remaining_k >= needed_skips {
                  remaining_k := remaining_k - needed_skips;
                  ans := ans + 1;
              }
          }
          i := i + 1;
      }
  
      result := ans;
  }

vc-postamble: |-

