vc-description: |-
  Given a modulus m and a list of n forbidden values, construct the longest possible sequence where:
  - Each sequence element is an integer in [0, m-1]  
  - All prefix products modulo m are distinct
  - No prefix product modulo m equals any forbidden value
  - Sequence length is maximized

vc-preamble: |-
  function prefixProduct(s: seq<nat>, i: nat, mod: nat): nat
    requires mod > 0
    requires i <= |s|
  {
      if i == 0 then 1
      else (s[i-1] * prefixProduct(s, i-1, mod)) % mod
  }
  
  function prefixProducts(s: seq<nat>, mod: nat): seq<nat>
    requires mod > 0
  {
      seq(|s|, i requires 0 <= i < |s| => prefixProduct(s, i+1, mod))
  }
  
  predicate allDistinct<T(==)>(s: seq<T>)
  {
      forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]
  }
  
  predicate noForbiddenProducts(s: seq<nat>, forbidden: seq<nat>, mod: nat)
    requires mod > 0
  {
      var products := prefixProducts(s, mod);
      forall i :: 0 <= i < |products| ==> products[i] !in forbidden
  }
  
  predicate ValidInput(n: nat, m: nat, forbidden: seq<nat>)
  {
      m >= 1 &&
      n >= 0 &&
      |forbidden| == n &&
      (forall i :: 0 <= i < |forbidden| ==> 0 <= forbidden[i] < m) &&
      (forall i, j :: 0 <= i < j < |forbidden| ==> forbidden[i] != forbidden[j])
  }
  
  predicate ValidSequence(sequence: seq<nat>, m: nat, forbidden: seq<nat>)
    requires m > 0
  {
      (forall i :: 0 <= i < |sequence| ==> 0 <= sequence[i] < m) &&
      allDistinct([1] + prefixProducts(sequence, m)) &&
      noForbiddenProducts(sequence, forbidden, m)
  }

vc-helpers: |-
  function gcd(a: nat, b: nat): nat
    decreases b
  {
      if b == 0 then a else gcd(b, a % b)
  }
  
  function power(base: nat, exp: nat, mod: nat): nat
    requires mod > 0
  {
      if exp == 0 then 1
      else if exp % 2 == 0 then 
          var half := power(base, exp / 2, mod);
          (half * half) % mod
      else (base * power(base, exp - 1, mod)) % mod
  }
  
  method extendedGcd(a: int, b: int) returns (g: int, x: int, y: int)
    requires a >= 0 && b >= 0
    ensures g >= 0
  {
      if a == 0 {
          return b, 0, 1;
      }
      var g1, x1, y1 := extendedGcd(b % a, a);
      x := y1 - (b / a) * x1;
      y := x1;
      g := g1;
  }
  
  method modInverse(x: int, m: int) returns (inv: int)
    requires m > 0 && x >= 0
  {
      var g, inv_candidate, _ := extendedGcd(x, m);
      inv := ((inv_candidate % m) + m) % m;
  }
  
  lemma prefixProductPrefix(s: seq<nat>, i: nat, mod: nat)
    requires mod > 0
    requires i <= |s|
    ensures forall t :: s <= t ==> prefixProduct(s, i, mod) == prefixProduct(t, i, mod)
  {
      if i == 0 {
          // Base case: prefixProduct is 1 for both
      } else {
          // Inductive case
          prefixProductPrefix(s, i-1, mod);
      }
  }

vc-spec: |-
  method solve(n: nat, m: nat, forbidden: seq<nat>) returns (length: nat, sequence: seq<nat>)
    requires ValidInput(n, m, forbidden)
    ensures length == |sequence|
    ensures length >= 0
    ensures m == 1 ==> length == 0 && sequence == []
    ensures m > 1 ==> ValidSequence(sequence, m, forbidden)
    ensures n == 0 && m > 1 ==> length > 0

vc-code: |-
  {
      if m == 1 {
          return 0, [];
      }
  
      // If 1 is forbidden, we cannot build any sequence since the initial prefix product is 1
      if 1 in forbidden {
          return 0, [];
      }
  
      // Simple greedy approach: try each multiplier from 1 to m-1
      var result: seq<nat> := [];
      var currentProduct: nat := 1;
  
      var multiplier := 1;
      while multiplier < m
        invariant 1 <= multiplier <= m
        invariant forall i :: 0 <= i < |result| ==> 0 <= result[i] < m
        invariant currentProduct == prefixProduct(result, |result|, m)
        invariant allDistinct([1] + prefixProducts(result, m))
        invariant noForbiddenProducts(result, forbidden, m)
        invariant currentProduct !in forbidden
      {
          var newProduct := (currentProduct * multiplier) % m;
          var allProducts := [1] + prefixProducts(result, m);
  
          if newProduct !in allProducts && newProduct !in forbidden {
              result := result + [multiplier];
              currentProduct := newProduct;
              
              // Establish that the new prefix product is what we expect
              prefixProductPrefix(result[..|result|-1], |result|-1, m);
              assert result[..|result|-1] == result[..|result|][..|result|-1];
          }
  
          multiplier := multiplier + 1;
      }
  
      return |result|, result;
  }

vc-postamble: |-
