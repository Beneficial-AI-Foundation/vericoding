vc-description: |-
  Given a string of length n containing only 'a' and 'b' characters, count the number of "good" substrings of even length and odd length.
  A substring is "good" if after merging all consecutive equal characters, the resulting string is a palindrome.
  For example: "aabba" becomes "aba" after merging, which is a palindrome, so "aabba" is good.

vc-preamble: |-
  predicate ValidInput(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == 'a' || s[i] == 'b'
  }
  
  function MergeConsecutive(s: string): string
      requires |s| > 0
  {
      if |s| == 1 then s
      else if s[0] == s[1] then MergeConsecutive(s[1..])
      else [s[0]] + MergeConsecutive(s[1..])
  }
  
  function IsPalindrome(s: string): bool
  {
      if |s| <= 1 then true
      else s[0] == s[|s|-1] && IsPalindrome(s[1..|s|-1])
  }
  
  predicate IsGoodSubstring(s: string, i: int, j: int)
      requires ValidInput(s) && 0 <= i <= j < |s|
  {
      var sub := s[i..j+1];
      IsPalindrome(MergeConsecutive(sub))
  }
  
  predicate ValidOutput(s: string, evenCount: int, oddCount: int)
      requires ValidInput(s)
  {
      evenCount >= 0 && oddCount >= 0 &&
      evenCount + oddCount >= |s| &&
      oddCount >= |s| &&
      (|s| == 1 ==> evenCount == 0 && oddCount == 1)
  }

vc-helpers: |-

vc-spec: |-
  method solve(s: string) returns (evenCount: int, oddCount: int)
      requires ValidInput(s)
      ensures ValidOutput(s, evenCount, oddCount)

vc-code: |-
  {
      var length := |s|;
      var goodbad := new int[length, 4];
  
      // Initialize first position
      goodbad[0, 0] := 1; // good odd
      goodbad[0, 1] := 0; // bad odd
      goodbad[0, 2] := 0; // good even
      goodbad[0, 3] := 0; // bad even
  
      // Fill the DP table
      var i := 0;
      while i < length - 1
          invariant 0 <= i < length
          invariant forall j :: 0 <= j <= i ==> goodbad[j, 0] >= 0 && goodbad[j, 1] >= 0 && goodbad[j, 2] >= 0 && goodbad[j, 3] >= 0
          invariant goodbad[0, 0] == 1 && goodbad[0, 1] == 0 && goodbad[0, 2] == 0 && goodbad[0, 3] == 0
          invariant forall j :: 0 <= j <= i ==> goodbad[j, 0] >= 1
      {
          if s[i] == s[i + 1] {
              // Same characters - parity flips, good/bad stays
              goodbad[i + 1, 0] := goodbad[i, 2] + 1; // good odd = prev good even + new single char
              goodbad[i + 1, 2] := goodbad[i, 0]; // good even = prev good odd
              goodbad[i + 1, 1] := goodbad[i, 3]; // bad odd = prev bad even
              goodbad[i + 1, 3] := goodbad[i, 1]; // bad even = prev bad odd
          } else {
              // Different characters - good/bad flips, parity stays
              goodbad[i + 1, 0] := goodbad[i, 3] + 1; // bad even becomes good odd + new single char
              goodbad[i + 1, 3] := goodbad[i, 0]; // good odd becomes bad even
              goodbad[i + 1, 1] := goodbad[i, 2]; // bad odd = prev good even
              goodbad[i + 1, 2] := goodbad[i, 1]; // good even = prev bad odd
          }
          i := i + 1;
      }
  
      // Sum up all good counts
      oddCount := 0;
      evenCount := 0;
      i := 0;
      while i < length
          invariant 0 <= i <= length
          invariant oddCount >= 0 && evenCount >= 0
          invariant forall j :: 0 <= j < length ==> goodbad[j, 0] >= 1
          invariant oddCount >= i  // At least i good odd substrings counted so far
          invariant oddCount + evenCount >= i
          invariant (length == 1 && i == 0) ==> (oddCount == 0 && evenCount == 0)
          invariant (length == 1 && i == 1) ==> (oddCount == 1 && evenCount == 0)
      {
          oddCount := oddCount + goodbad[i, 0];
          evenCount := evenCount + goodbad[i, 2];
          i := i + 1;
      }
  
      // Help Dafny prove the postcondition for length 1
      if length == 1 {
          assert oddCount == 1 && evenCount == 0;
      }
  }

vc-postamble: |-

