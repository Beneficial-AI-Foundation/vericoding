vc-description: |-
  Given an array of n integers and m queries, determine for each query whether a specified subsegment forms a "ladder".
  A ladder is a sequence that first non-decreases, then non-increases. Formally, there exists a position x such that 
  elements are non-decreasing up to position x, then non-increasing from position x onward.

vc-preamble: |-
  predicate isLadder(arr: seq<int>, l: int, r: int)
    requires 0 <= l <= r < |arr|
  {
    if l == r then true
    else
      exists k :: l <= k <= r && 
        isNonDecreasing(arr, l, k) && 
        isNonIncreasing(arr, k, r)
  }
  
  predicate isNonDecreasing(arr: seq<int>, start: int, end: int)
    requires 0 <= start <= end < |arr|
  {
    forall i :: start <= i < end ==> arr[i] <= arr[i+1]
  }
  
  predicate isNonIncreasing(arr: seq<int>, start: int, end: int)
    requires 0 <= start <= end < |arr|
  {
    forall i :: start <= i < end ==> arr[i] >= arr[i+1]
  }

vc-helpers: |-
  method checkLadder(arr: seq<int>, L: seq<int>, l: int, r: int) returns (isLadderResult: bool)
    requires 0 <= l <= r < |L| == |arr|
    requires forall j :: 1 <= j < |L| ==> 
      (L[j] == 1 <==> arr[j] > arr[j-1]) &&
      (L[j] == 0 <==> arr[j] == arr[j-1]) &&
      (L[j] == -1 <==> arr[j] < arr[j-1])
    ensures isLadderResult == isLadder(arr, l, r)
  {
    if l == r {
      isLadderResult := true;
      return;
    }
  
    var peak := l;
    var i := l + 1;
  
    while i <= r && L[i] >= 0
      invariant l < i <= r + 1
      invariant forall j :: l < j < i ==> L[j] >= 0
      invariant forall j :: l < j < i ==> arr[j] >= arr[j-1]
      invariant isNonDecreasing(arr, l, i-1)
    {
      i := i + 1;
    }
  
    peak := i - 1;
  
    var isValidLadder := true;
    while i <= r
      invariant peak < i <= r + 1
      invariant isValidLadder ==> forall j :: peak < j < i ==> L[j] <= 0
      invariant isValidLadder ==> forall j :: peak < j < i ==> arr[j] <= arr[j-1]
      invariant isValidLadder ==> isNonIncreasing(arr, peak, i-1)
    {
      if L[i] > 0 {
        isValidLadder := false;
        assert arr[i] > arr[i-1];
        assert !isNonIncreasing(arr, peak, r);
        assert forall k :: i <= k <= r ==> !isNonDecreasing(arr, l, k);
        assert !isLadder(arr, l, r);
        isLadderResult := false;
        return;
      }
      i := i + 1;
    }
  
    assert isNonDecreasing(arr, l, peak);
    assert isNonIncreasing(arr, peak, r);
    assert l <= peak <= r;
    isLadderResult := true;
  }

vc-spec: |-
  method solve(n: int, m: int, arr: seq<int>, queries: seq<(int, int)>) returns (results: seq<string>)
    requires n >= 1 && m >= 1
    requires |arr| == n
    requires |queries| == m
    requires forall i :: 0 <= i < m ==> 1 <= queries[i].0 <= queries[i].1 <= n
    ensures |results| == m
    ensures forall i :: 0 <= i < m ==> results[i] == "Yes" || results[i] == "No"
    ensures forall i :: 0 <= i < m ==> 
      (results[i] == "Yes" <==> isLadder(arr, queries[i].0 - 1, queries[i].1 - 1))

vc-code: |-
  {
    if n == 1 {
      results := [];
      var idx := 0;
      while idx < m
        invariant 0 <= idx <= m
        invariant |results| == idx
        invariant forall j :: 0 <= j < idx ==> results[j] == "Yes"
        invariant forall j :: 0 <= j < idx ==> isLadder(arr, queries[j].0 - 1, queries[j].1 - 1)
      {
        var l := queries[idx].0 - 1;
        var r := queries[idx].1 - 1;
        assert l == r;
        assert isLadder(arr, l, r);
        results := results + ["Yes"];
        idx := idx + 1;
      }
      return;
    }
  
    var L := seq(n, _ => 0);
    var hasInc := false;
    var hasDec := false;
  
    var i := 1;
    while i < n
      invariant 1 <= i <= n
      invariant |L| == n
      invariant hasInc ==> exists j :: 1 <= j < i && arr[j] > arr[j-1]
      invariant hasDec ==> exists j :: 1 <= j < i && arr[j] < arr[j-1]
      invariant !hasInc ==> forall j :: 1 <= j < i ==> arr[j] <= arr[j-1]
      invariant !hasDec ==> forall j :: 1 <= j < i ==> arr[j] >= arr[j-1]
      invariant forall j :: 1 <= j < i ==> 
        (L[j] == 1 <==> arr[j] > arr[j-1]) &&
        (L[j] == 0 <==> arr[j] == arr[j-1]) &&
        (L[j] == -1 <==> arr[j] < arr[j-1])
    {
      if arr[i] > arr[i-1] {
        L := L[i := 1];
        hasInc := true;
      } else if arr[i] == arr[i-1] {
        L := L[i := 0];
      } else {
        L := L[i := -1];
        hasDec := true;
      }
      i := i + 1;
    }
  
    if !hasInc || !hasDec {
      results := [];
      var idx := 0;
      while idx < m
        invariant 0 <= idx <= m
        invariant |results| == idx
        invariant forall j :: 0 <= j < idx ==> results[j] == "Yes"
        invariant forall j :: 0 <= j < idx ==> isLadder(arr, queries[j].0 - 1, queries[j].1 - 1)
        invariant !hasInc ==> forall j :: 1 <= j < n ==> arr[j] <= arr[j-1]
        invariant !hasDec ==> forall j :: 1 <= j < n ==> arr[j] >= arr[j-1]
      {
        var l := queries[idx].0 - 1;
        var r := queries[idx].1 - 1;
  
        if !hasInc {
          assert isNonIncreasing(arr, l, r);
          assert isNonDecreasing(arr, l, l);
          assert isLadder(arr, l, r);
        } else {
          assert isNonDecreasing(arr, l, r);
          assert isNonIncreasing(arr, r, r);
          assert isLadder(arr, l, r);
        }
  
        results := results + ["Yes"];
        idx := idx + 1;
      }
      return;
    }
  
    results := [];
    var queryIdx := 0;
    while queryIdx < m
      invariant 0 <= queryIdx <= m
      invariant |results| == queryIdx
      invariant forall j :: 0 <= j < queryIdx ==> results[j] == "Yes" || results[j] == "No"
      invariant forall j :: 0 <= j < queryIdx ==> 
        (results[j] == "Yes" <==> isLadder(arr, queries[j].0 - 1, queries[j].1 - 1))
    {
      var l := queries[queryIdx].0 - 1;
      var r := queries[queryIdx].1 - 1;
  
      if r == l {
        assert isLadder(arr, l, r);
        results := results + ["Yes"];
      } else {
        var isLadderResult := checkLadder(arr, L, l, r);
        if isLadderResult {
          results := results + ["Yes"];
        } else {
          results := results + ["No"];
        }
      }
      queryIdx := queryIdx + 1;
    }
  }

vc-postamble: |-

