vc-description: |-
  Given n particles on a line at distinct even-integer positions, where each particle moves 
  left (L) or right (R) at speed 1 unit per microsecond, find the time of the first collision 
  between any two particles, or return -1 if no collision occurs.

vc-preamble: |-
  predicate ValidInput(n: int, directions: string, positions: seq<int>)
  {
      n >= 1 &&
      |directions| == n &&
      |positions| == n &&
      (forall i :: 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&
      (forall i :: 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&
      (forall i, j :: 0 <= i < j < n ==> positions[i] < positions[j])
  }
  
  predicate HasCollision(directions: string, positions: seq<int>)
      requires |directions| == |positions|
  {
      exists i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L'
  }
  
  function CollisionTime(i: int, positions: seq<int>): int
      requires 0 <= i < |positions|-1
  {
      (positions[i+1] - positions[i]) / 2
  }
  
  predicate IsMinimalCollisionTime(result: int, directions: string, positions: seq<int>)
      requires |directions| == |positions|
  {
      (forall i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L' ==> 
          CollisionTime(i, positions) >= result) &&
      (exists i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L' && 
          CollisionTime(i, positions) == result)
  }

vc-helpers: |-

vc-spec: |-
  method solve(n: int, directions: string, positions: seq<int>) returns (result: int)
      requires ValidInput(n, directions, positions)
      ensures result == -1 || result >= 0
      ensures result != -1 ==> HasCollision(directions, positions)
      ensures result == -1 ==> !HasCollision(directions, positions)
      ensures result != -1 ==> IsMinimalCollisionTime(result, directions, positions)

vc-code: |-
  {
      var best := 0;
      var found_collision := false;
      var i := 0;
      while i < |directions| - 1
          invariant 0 <= i <= |directions| - 1
          invariant found_collision ==> exists j :: 0 <= j < i && directions[j] == 'R' && directions[j+1] == 'L'
          invariant !found_collision ==> forall j :: 0 <= j < i ==> !(directions[j] == 'R' && directions[j+1] == 'L')
          invariant found_collision ==> forall j :: 0 <= j < i && directions[j] == 'R' && directions[j+1] == 'L' ==> CollisionTime(j, positions) >= best
          invariant found_collision ==> exists j :: 0 <= j < i && directions[j] == 'R' && directions[j+1] == 'L' && CollisionTime(j, positions) == best
          invariant best >= 0
      {
          if directions[i] == 'R' && directions[i+1] == 'L'
          {
              var collision_time := CollisionTime(i, positions);
              if !found_collision
              {
                  found_collision := true;
                  best := collision_time;
              }
              else if collision_time < best
              {
                  best := collision_time;
              }
          }
          i := i + 1;
      }
  
      if found_collision
      {
          result := best;
      }
      else
      {
          result := -1;
      }
  }

vc-postamble: |-

