vc-description: |-
  Given n strings of lowercase Latin letters, determine if there exists a permutation 
  of the 26 lowercase Latin letters such that the strings are in lexicographical order
  according to this custom alphabet. Output the valid alphabet permutation or "Impossible".

vc-preamble: |-
  ghost predicate validInput(stdin_input: string, n: int)
  {
      exists lines :: (parseInput(stdin_input) == lines &&
      |lines| >= 1 &&
      |lines| == n + 1 &&
      parseInt(lines[0]) == n &&
      n >= 1 && n <= 100 &&
      (forall i :: 1 <= i < |lines| ==> 
          1 <= |lines[i]| <= 100 && 
          forall j :: 0 <= j < |lines[i]| ==> 'a' <= lines[i][j] <= 'z'))
  }
  
  ghost predicate validAlphabetOrdering(stdin_input: string, alphabet: string)
      requires |alphabet| == 26
      requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'
      requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]
  {
      exists lines, n :: (parseInput(stdin_input) == lines &&
      |lines| >= 1 &&
      |lines| == n + 1 &&
      parseInt(lines[0]) == n &&
      (forall i :: 1 <= i < n ==> lexicographicallyLessOrEqual(lines[i], lines[i+1], alphabet)))
  }
  
  ghost predicate lexicographicallyLessOrEqual(s1: string, s2: string, alphabet: string)
      requires |alphabet| == 26
      requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'
      requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]
  {
      if s1 == s2 then
          true
      else if |s1| <= |s2| && s1 == s2[..|s1|] then
          true
      else if |s2| < |s1| && s2 == s1[..|s2|] then
          false
      else
          exists i :: (0 <= i < |s1| && i < |s2| && s1[i] != s2[i] &&
          (forall j :: 0 <= j < i ==> s1[j] == s2[j]) &&
          'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&
          alphabetOrder(s1[i], s2[i], alphabet))
  }
  
  ghost predicate alphabetOrder(c1: char, c2: char, alphabet: string)
      requires |alphabet| == 26
      requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'
      requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]
      requires 'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'
  {
      exists i, j :: 0 <= i < j < |alphabet| && alphabet[i] == c1 && alphabet[j] == c2
  }
  
  ghost function parseInput(input: string): seq<string>
  
  ghost function parseInt(s: string): int

vc-helpers: |-
  ghost predicate hasConstraintViolation(stdin_input: string)
  {
      exists lines, n :: (parseInput(stdin_input) == lines &&
      |lines| >= 1 &&
      |lines| == n + 1 &&
      parseInt(lines[0]) == n &&
      (exists i :: 1 <= i < n && hasImpossiblePrefixRelation(lines[i], lines[i+1]))) ||
      hasOrderingCycle(stdin_input)
  }
  
  ghost predicate hasImpossiblePrefixRelation(s1: string, s2: string)
  {
      |s2| < |s1| && s2 == s1[..|s2|]
  }
  
  ghost predicate hasOrderingCycle(stdin_input: string)
  {
      exists lines, n :: (parseInput(stdin_input) == lines &&
      |lines| >= 1 &&
      |lines| == n + 1 &&
      parseInt(lines[0]) == n &&
      existsCharacterOrderingCycle(lines))
  }
  
  ghost predicate existsCharacterOrderingCycle(lines: seq<string>)
  {
      exists c1, c2 :: ('a' <= c1 <= 'z' && 'a' <= c2 <= 'z' &&
      requiresOrdering(lines, c1, c2) && requiresOrdering(lines, c2, c1))
  }
  
  ghost predicate requiresOrdering(lines: seq<string>, c1: char, c2: char)
  {
      exists i :: 1 <= i < |lines| && requiresOrderingBetween(lines[i-1], lines[i], c1, c2)
  }
  
  ghost predicate requiresOrderingBetween(s1: string, s2: string, c1: char, c2: char)
  {
      s1 != s2 &&
      !isProperPrefix(s1, s2) &&
      !isProperPrefix(s2, s1) &&
      exists pos :: (0 <= pos < |s1| && pos < |s2| &&
      (forall j :: 0 <= j < pos ==> s1[j] == s2[j]) &&
      s1[pos] == c1 && s2[pos] == c2)
  }
  
  ghost predicate isProperPrefix(s1: string, s2: string)
  {
      |s1| < |s2| && s1 == s2[..|s1|]
  }

vc-spec: |-
  method solve(stdin_input: string) returns (result: string)
      requires |stdin_input| > 0
      requires exists n :: n >= 1 && validInput(stdin_input, n)
      ensures result == "Impossible" || (|result| == 26 && forall i :: 0 <= i < |result| ==> 'a' <= result[i] <= 'z')
      ensures result != "Impossible" ==> (forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j])
      ensures result != "Impossible" ==> validAlphabetOrdering(stdin_input, result)

vc-code: |-
  {
      result := "Impossible";
  }

vc-postamble: |-
