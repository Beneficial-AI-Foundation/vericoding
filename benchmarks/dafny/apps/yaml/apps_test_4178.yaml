vc-description: |-
  Given N squares with heights, determine if it's possible to make heights non-decreasing
  from left to right. For each square, you can decrease its height by 1 or leave unchanged.

vc-preamble: |-
  function maxHeightUpTo(heights: seq<int>, index: int): int
    requires |heights| > 0
    requires -1 <= index < |heights|
  {
    if index < 0 then 0
    else if index == 0 then heights[0]
    else if heights[index] > maxHeightUpTo(heights, index - 1) 
      then heights[index]
      else maxHeightUpTo(heights, index - 1)
  }
  
  predicate ValidInput(n: int, heights: seq<int>)
  {
    n >= 1 && |heights| == n && (forall i :: 0 <= i < |heights| ==> heights[i] >= 1)
  }
  
  predicate CanMakeNonDecreasing(heights: seq<int>)
    requires |heights| > 0
  {
    forall i :: 0 <= i < |heights| ==> heights[i] >= maxHeightUpTo(heights, i) - 1
  }

vc-helpers: |-
  

vc-spec: |-
  method solve(n: int, heights: seq<int>) returns (result: string)
    requires ValidInput(n, heights)
    ensures result == "Yes" <==> CanMakeNonDecreasing(heights)

vc-code: |-
  {
    var hmax := heights[0];
    var flg := true;
  
    var i := 0;
    while i < |heights| && flg
      invariant 0 <= i <= |heights|
      invariant hmax >= heights[0]
      invariant forall j :: 0 <= j < i ==> hmax >= heights[j]
      invariant i == 0 ==> hmax == heights[0]
      invariant i > 0 ==> hmax == maxHeightUpTo(heights, i-1)
      invariant flg <==> (forall j :: 0 <= j < i ==> heights[j] >= maxHeightUpTo(heights, j) - 1)
    {
      hmax := if hmax > heights[i] then hmax else heights[i];
      if heights[i] < hmax - 1 {
        flg := false;
      }
      i := i + 1;
    }
  
    if flg {
      result := "Yes";
    } else {
      result := "No";
    }
  }

vc-postamble: |-
