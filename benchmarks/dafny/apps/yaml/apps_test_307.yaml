vc-description: |-
  Given k_2 digits '2', k_3 digits '3', k_5 digits '5', and k_6 digits '6',
  form integers 32 and 256 to maximize their sum. Each digit can only be used once.
  To form 256: need one '2', one '5', one '6'
  To form 32: need one '3', one '2'

vc-preamble: |-
  predicate ValidInput(k2: int, k3: int, k5: int, k6: int)
  {
      k2 >= 0 && k3 >= 0 && k5 >= 0 && k6 >= 0 &&
      k2 <= 5000000 && k3 <= 5000000 && k5 <= 5000000 && k6 <= 5000000
  }
  
  function OptimalSum(k2: int, k3: int, k5: int, k6: int): int
      requires ValidInput(k2, k3, k5, k6)
  {
      var count256 := min(min(k2, k5), k6);
      var remaining_k2 := k2 - count256;
      var count32 := min(k3, remaining_k2);
      256 * count256 + 32 * count32
  }

vc-helpers: |-
  function min(a: int, b: int): int
  {
      if a <= b then a else b
  }

vc-spec: |-
  method solve(k2: int, k3: int, k5: int, k6: int) returns (result: int)
      requires ValidInput(k2, k3, k5, k6)
      ensures result >= 0
      ensures result == OptimalSum(k2, k3, k5, k6)

vc-code: |-
  {
      var c := min(min(k2, k5), k6);
      var remaining_k2 := k2 - c;
      var ans := 256 * c;
      var tmpCall1 := min(k3, remaining_k2);
      ans := ans + 32 * tmpCall1;
      result := ans;
  }

vc-postamble: |-
