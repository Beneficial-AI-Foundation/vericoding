vc-description: |-
  Given n piles of stones, two players alternate turns removing stones from the leftmost non-empty pile.
  The player who cannot make a move loses. Determine the winner when both players play optimally.

vc-preamble: |-
  predicate ValidInput(testCases: seq<seq<int>>) {
      forall i :: 0 <= i < |testCases| ==> 
          |testCases[i]| >= 1 && 
          forall j :: 0 <= j < |testCases[i]| ==> testCases[i][j] >= 1
  }
  
  predicate ValidResults(results: seq<string>) {
      forall i :: 0 <= i < |results| ==> 
          results[i] == "First" || results[i] == "Second"
  }
  
  function CountLeadingOnes(piles: seq<int>): nat
      requires forall j :: 0 <= j < |piles| ==> piles[j] >= 1
  {
      if |piles| == 0 then 0
      else if piles[0] != 1 then 0
      else 1 + CountLeadingOnes(piles[1..])
  }
  
  predicate CorrectGameResult(piles: seq<int>, result: string)
      requires |piles| >= 1
      requires forall j :: 0 <= j < |piles| ==> piles[j] >= 1
      requires result == "First" || result == "Second"
  {
      var onesCount := |set j | 0 <= j < |piles| && piles[j] == 1|;
      var allOnes := (onesCount == |piles|);
      var leadingOnes := CountLeadingOnes(piles);
      if allOnes then
          (if onesCount % 2 == 1 then result == "First" else result == "Second")
      else
          (if leadingOnes % 2 == 1 then result == "Second" else result == "First")
  }

vc-helpers: |-
  

vc-spec: |-
  method solve(testCases: seq<seq<int>>) returns (results: seq<string>)
      requires ValidInput(testCases)
      ensures |results| == |testCases|
      ensures ValidResults(results)
      ensures forall i :: 0 <= i < |testCases| ==> CorrectGameResult(testCases[i], results[i])

vc-code: |-
  {
      var output: seq<string> := [];
      var i := 0;
  
      while i < |testCases|
          invariant 0 <= i <= |testCases|
          invariant |output| == i
          invariant ValidResults(output)
          invariant forall k :: 0 <= k < i ==> CorrectGameResult(testCases[k], output[k])
      {
          var piles := testCases[i];
          var n := |piles|;
  
          // Count how many piles have exactly 1 stone
          var onesCount := 0;
          var j := 0;
          while j < n
              invariant 0 <= j <= n
              invariant onesCount == |set idx | 0 <= idx < j && piles[idx] == 1|
          {
              var oldOnesCount := onesCount;
              if piles[j] == 1 {
                  onesCount := onesCount + 1;
              }
              assert onesCount == oldOnesCount + (if piles[j] == 1 then 1 else 0);
  
              // Help Dafny understand the set relationship
              var oldSet := set idx | 0 <= idx < j && piles[idx] == 1;
              var newSet := set idx | 0 <= idx < j + 1 && piles[idx] == 1;
              assert newSet == oldSet + (if piles[j] == 1 then {j} else {});
              assert |newSet| == |oldSet| + (if piles[j] == 1 then 1 else 0);
  
              j := j + 1;
          }
  
          assert onesCount == |set idx | 0 <= idx < |piles| && piles[idx] == 1|;
  
          if onesCount == n {
              // All piles have exactly 1 stone
              if onesCount % 2 == 1 {
                  output := output + ["First"];
              } else {
                  output := output + ["Second"];
              }
          } else {
              // Count consecutive 1's from the beginning
              var leadingOnes := CountLeadingOnes(piles);
  
              if leadingOnes % 2 == 1 {
                  output := output + ["Second"];
              } else {
                  output := output + ["First"];
              }
          }
  
          i := i + 1;
      }
  
      return output;
  }

vc-postamble: |-
