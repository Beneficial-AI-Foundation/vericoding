vc-description: |-
  Given q queries with battery charge k, n turns, and two actions with costs a and b (where b < a),
  find the maximum number of Action A turns possible while completing exactly n turns and keeping
  charge > 0 at the end, or return -1 if impossible.

vc-preamble: |-
  predicate ValidQuery(k: int, n: int, a: int, b: int)
  {
      k > 0 && n > 0 && a > 0 && b > 0 && b < a
  }
  
  function MaxActionATurns(k: int, n: int, a: int, b: int): int
      requires ValidQuery(k, n, a, b)
  {
      if n * b > k then 
          -1
      else 
          var maxPossible := (k - n * b - 1) / (a - b);
          if n <= maxPossible then n else maxPossible
  }
  
  predicate ValidResult(result: int, k: int, n: int, a: int, b: int)
      requires ValidQuery(k, n, a, b)
  {
      result == -1 || (0 <= result <= n)
  }

vc-helpers: |-

vc-spec: |-
  method solve(queries: seq<(int, int, int, int)>) returns (results: seq<int>)
      requires |queries| > 0
      requires forall i :: 0 <= i < |queries| ==> 
          var (k, n, a, b) := queries[i];
          ValidQuery(k, n, a, b)
      ensures |results| == |queries|
      ensures forall i :: 0 <= i < |queries| ==> 
          var (k, n, a, b) := queries[i];
          results[i] == MaxActionATurns(k, n, a, b)
      ensures forall i :: 0 <= i < |results| ==> 
          var (k, n, a, b) := queries[i];
          ValidResult(results[i], k, n, a, b)

vc-code: |-
  {
    assume {:axiom} false;
  }

vc-postamble: |-

