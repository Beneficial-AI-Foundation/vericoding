vc-description: |-
  Given a positive integer N, find how many values of K (where 2 ≤ K ≤ N) will cause N to become 1
  through repeated operations: if K divides N, replace N with N/K; otherwise replace N with N-K;
  continue until N < K. Count the number of valid K values.

vc-preamble: |-
  predicate ValidInput(n: nat)
  {
    n > 0
  }
  
  function reduce_by_divisor(n: nat, d: nat): nat
    requires n > 0 && d > 1
    decreases n
  {
    if n % d == 0 && n >= d then 
      reduce_by_divisor(n / d, d)
    else n
  }
  
  function count_divisors(n: nat): nat
    requires n > 0
  {
    |set d | 1 <= d <= n && n % d == 0|
  }
  
  function count_special_divisors(n: nat): nat
    requires n > 0
  {
    |set d | 2 <= d <= n && n % d == 0 && (reduce_by_divisor(n, d) - 1) % d == 0|
  }
  
  function count_valid_k_values(n: nat): int
    requires n > 0
  {
    if n == 1 then -1
    else 
      count_divisors(n - 1) + count_special_divisors(n) - 1
  }

vc-helpers: |-
  method make_divisors(n: nat) returns (divisors: seq<nat>)
    requires n > 0
    ensures forall d :: d in divisors ==> d > 0 && n % d == 0
    ensures forall d :: d > 0 && n % d == 0 ==> d in divisors
    ensures |divisors| > 0
    ensures 1 in divisors
    ensures n in divisors
  {
    divisors := [];
    var i := 1;
    while i <= n
      invariant 1 <= i <= n + 1
      invariant forall d :: d in divisors ==> d > 0 && n % d == 0
      invariant forall d :: 1 <= d < i && n % d == 0 ==> d in divisors
    {
      if n % i == 0 {
        divisors := divisors + [i];
      }
      i := i + 1;
    }
  }

vc-spec: |-
  method solve(n: nat) returns (result: int)
    requires ValidInput(n)
    ensures result == count_valid_k_values(n)
    ensures n == 1 ==> result == -1
    ensures n > 1 ==> result == count_divisors(n - 1) + count_special_divisors(n) - 1
    ensures result >= -1

vc-code: |-
  {
    if n == 1 {
      result := -1;
      return;
    }
  
    result := count_divisors(n - 1) + count_special_divisors(n) - 1;
  }

vc-postamble: |-
