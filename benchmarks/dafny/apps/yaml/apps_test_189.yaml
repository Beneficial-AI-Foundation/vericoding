vc-description: |-
  Given n sticks with positive integer lengths, find a positive integer t and modify sticks to minimize 
  total cost such that all final lengths are almost good for t (within distance 1 of t).
  Cost to change a stick's length is the absolute difference.

vc-preamble: |-
  predicate ValidInput(n: int, sticks: seq<int>)
  {
      1 <= n <= 1000 &&
      |sticks| == n &&
      (forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100)
  }
  
  function CostForT(sticks: seq<int>, t: int): int
      requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100
      requires 1 <= t <= 99
      ensures CostForT(sticks, t) >= 0
  {
      SumCosts(sticks, t, 0)
  }
  
  function SumCosts(sticks: seq<int>, t: int, index: int): int
      requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100
      requires 1 <= t <= 99
      requires 0 <= index <= |sticks|
      ensures SumCosts(sticks, t, index) >= 0
      decreases |sticks| - index
  {
      if index == |sticks| then 0
      else Max(0, Abs(t - sticks[index]) - 1) + SumCosts(sticks, t, index + 1)
  }
  
  function Abs(x: int): int
      ensures Abs(x) >= 0
  {
      if x >= 0 then x else -x
  }
  
  function Max(a: int, b: int): int
      ensures Max(a, b) >= a && Max(a, b) >= b
  {
      if a >= b then a else b
  }
  
  predicate IsOptimalT(sticks: seq<int>, t: int)
      requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100
      requires 1 <= t <= 99
  {
      forall other_t :: 1 <= other_t <= 99 ==> 
          CostForT(sticks, t) <= CostForT(sticks, other_t)
  }

vc-helpers: |-
  function IntToString(x: int): string
  {
      if x == 0 then "0"
      else if x > 0 then IntToStringPos(x)
      else "-" + IntToStringPos(-x)
  }
  
  function IntToStringPos(x: int): string
      requires x > 0
      decreases x
  {
      if x < 10 then [CharOfDigit(x)]
      else IntToStringPos(x / 10) + [CharOfDigit(x % 10)]
  }
  
  function CharOfDigit(d: int): char
      requires 0 <= d <= 9
  {
      match d
      case 0 => '0' case 1 => '1' case 2 => '2' case 3 => '3' case 4 => '4'
      case 5 => '5' case 6 => '6' case 7 => '7' case 8 => '8' case 9 => '9'
  }

vc-spec: |-
  method FindOptimalT(n: int, sticks: seq<int>) returns (t: int, min_cost: int)
      requires ValidInput(n, sticks)
      ensures 1 <= t <= 99
      ensures min_cost >= 0
      ensures min_cost == CostForT(sticks, t)
      ensures IsOptimalT(sticks, t)

vc-code: |-
  {
      t := 1;
      min_cost := CostForT(sticks, 1);
  
      var current_t := 2;
      while current_t <= 99
          invariant 1 <= t <= 99
          invariant 2 <= current_t <= 100
          invariant min_cost >= 0
          invariant min_cost == CostForT(sticks, t)
          invariant forall other_t :: 1 <= other_t < current_t ==> 
              CostForT(sticks, t) <= CostForT(sticks, other_t)
      {
          var current_cost := CostForT(sticks, current_t);
          if current_cost < min_cost {
              t := current_t;
              min_cost := current_cost;
          }
          current_t := current_t + 1;
      }
  }

vc-postamble: |-
