vc-description: |-
  Given a string of '>' and '<' characters, determine the minimum number of characters 
  to remove so that the remaining string can be reduced to exactly one character using 
  these operations: Choose '>': delete the character immediately to its right (if exists),
  Choose '<': delete the character immediately to its left (if exists).
  Process multiple test cases where each test case consists of a string length and the string.

vc-preamble: |-
  predicate IsValidString(s: string)
  {
      |s| > 0
  }
  
  predicate IsValidProblemString(s: string)
  {
      forall i :: 0 <= i < |s| ==> s[i] == '>' || s[i] == '<'
  }
  
  predicate IsValidIntegerString(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  }
  
  function StringToInt(s: string): int
      requires IsValidIntegerString(s)
  {
      StringToIntHelper(s, |s|)
  }
  
  function StringToIntHelper(s: string, pos: int): int
      requires 0 <= pos <= |s|
      requires forall i :: 0 <= i < pos ==> '0' <= s[i] <= '9'
  {
      if pos == 0 then 0
      else StringToIntHelper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int)
  }
  
  function MinDeletionsNeeded(s: string): int
      requires IsValidProblemString(s)
  {
      var firstGreater := FirstGreaterFromLeft(s);
      var firstLessFromRight := FirstLessFromRight(s);
      if firstGreater < firstLessFromRight then firstGreater else firstLessFromRight
  }
  
  function FirstGreaterFromLeft(s: string): int
      requires IsValidProblemString(s)
      ensures 0 <= FirstGreaterFromLeft(s) <= |s|
  {
      FirstGreaterFromLeftHelper(s, 0)
  }
  
  function FirstGreaterFromLeftHelper(s: string, pos: int): int
      requires IsValidProblemString(s)
      requires 0 <= pos <= |s|
      ensures 0 <= FirstGreaterFromLeftHelper(s, pos) <= |s|
      decreases |s| - pos
  {
      if pos >= |s| then |s|
      else if s[pos] == '>' then pos
      else FirstGreaterFromLeftHelper(s, pos + 1)
  }
  
  function FirstLessFromRight(s: string): int
      requires IsValidProblemString(s)
      ensures 0 <= FirstLessFromRight(s) <= |s|
  {
      FirstLessFromRightHelper(s, |s| - 1)
  }
  
  function FirstLessFromRightHelper(s: string, pos: int): int
      requires IsValidProblemString(s)
      requires -1 <= pos < |s|
      ensures 0 <= FirstLessFromRightHelper(s, pos) <= |s|
      decreases pos + 1
  {
      if pos < 0 then |s|
      else if s[pos] == '<' then |s| - 1 - pos
      else FirstLessFromRightHelper(s, pos - 1)
  }
  
  function min(a: int, b: int): int
  {
      if a < b then a else b
  }

vc-helpers: |-
  method ParseInt(s: string) returns (result: int)
      requires IsValidIntegerString(s)
      ensures result >= 0
      ensures result == StringToInt(s)
  {
      result := 0;
      var i := 0;
      while i < |s|
          invariant 0 <= i <= |s|
          invariant result >= 0
          invariant result == StringToIntHelper(s, i)
      {
          result := result * 10 + (s[i] as int - '0' as int);
          i := i + 1;
      }
  }
  
  method SolveCase(s: string) returns (result: int)
      requires IsValidProblemString(s)
      ensures 0 <= result <= |s|
      ensures result == MinDeletionsNeeded(s)
  {
      if |s| == 0 {
          return 0;
      }
  
      var firstGreater := FirstGreaterFromLeft(s);
      var firstLessFromRight := FirstLessFromRight(s);
  
      result := min(firstGreater, firstLessFromRight);
  }

vc-spec: |-
  method solve(lines: seq<string>) returns (results: seq<int>)
      requires |lines| > 0
      requires forall i :: 0 <= i < |lines| ==> IsValidString(lines[i])
      requires IsValidIntegerString(lines[0])
      requires var t := StringToInt(lines[0]); |lines| >= 1 + 2 * t
      requires forall i :: 0 <= i < StringToInt(lines[0]) ==> 
          IsValidIntegerString(lines[1 + 2*i]) && IsValidProblemString(lines[2 + 2*i])
      ensures |results| == StringToInt(lines[0])
      ensures forall r :: r in results ==> r >= 0
      ensures forall i :: 0 <= i < |results| ==> 
          results[i] == MinDeletionsNeeded(lines[2 + 2*i])

vc-code: |-
  {
      var t := ParseInt(lines[0]);
      results := [];
      var i := 0;
  
      while i < t
          invariant 0 <= i <= t
          invariant |results| == i
          invariant forall r :: r in results ==> r >= 0
          invariant forall idx :: 0 <= idx < |results| ==> 
              results[idx] == MinDeletionsNeeded(lines[2 + 2*idx])
      {
          var n := ParseInt(lines[1 + 2*i]);
          var s := lines[2 + 2*i];
  
          var minDeletions := SolveCase(s);
          results := results + [minDeletions];
          i := i + 1;
      }
  }

vc-postamble: |-

