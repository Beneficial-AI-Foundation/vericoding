vc-description: |-
  Given m ships, each with a destination coordinate expressed as (a+b)/c where a, b, c are positive integers,
  determine how many ships (including itself) will have the same destination coordinate for each ship.

vc-preamble: |-
  predicate ValidInput(input: string)
  {
      |input| > 0
  }
  
  predicate ValidOutput(result: seq<int>, input: string)
  {
      |result| >= 0 &&
      (forall i :: 0 <= i < |result| ==> result[i] >= 1) &&
      (forall i :: 0 <= i < |result| ==> result[i] <= |result|)
  }

vc-helpers: |-
  method SplitLines(input: string) returns (lines: seq<string>)
      requires |input| >= 0
      ensures |lines| >= 0
      ensures forall i :: 0 <= i < |lines| ==> |lines[i]| >= 0
  {
      lines := [];
      var start := 0;
      var i := 0;
      while i < |input|
          invariant 0 <= start <= i <= |input|
      {
          if input[i] == '\n' {
              if start < i {
                  lines := lines + [input[start..i]];
              }
              start := i + 1;
          }
          i := i + 1;
      }
      if start < |input| {
          lines := lines + [input[start..]];
      }
  }
  
  method ParseInt(s: string) returns (n: int)
      requires |s| >= 0
      ensures n >= 0
  {
      n := 0;
      var i := 0;
      while i < |s|
          invariant 0 <= i <= |s|
          invariant n >= 0
      {
          if '0' <= s[i] <= '9' {
              n := n * 10 + (s[i] as int - '0' as int);
          }
          i := i + 1;
      }
  }
  
  method FindChar(s: string, ch: char) returns (pos: int)
      requires |s| >= 0
      ensures -1 <= pos < |s|
      ensures pos == -1 ==> forall i :: 0 <= i < |s| ==> s[i] != ch
      ensures pos >= 0 ==> s[pos] == ch
  {
      pos := -1;
      var i := 0;
      while i < |s|
          invariant 0 <= i <= |s|
          invariant pos == -1 ==> forall j :: 0 <= j < i ==> s[j] != ch
          invariant pos >= 0 ==> 0 <= pos < i && s[pos] == ch
      {
          if s[i] == ch {
              pos := i;
              return;
          }
          i := i + 1;
      }
  }
  
  method ParseCoordinate(s: string) returns (coord: real)
      requires |s| >= 0
      ensures coord >= 0.0
  {
      var slashPos := FindChar(s, '/');
      if slashPos == -1 {
          coord := 0.0;
          return;
      }
  
      var leftPart := s[0..slashPos];
      var rightPart := s[slashPos+1..];
  
      if |leftPart| >= 2 && leftPart[0] == '(' && leftPart[|leftPart|-1] == ')' {
          leftPart := leftPart[1..|leftPart|-1];
      }
  
      var tmpCall1 := FindChar(leftPart, '+');
      var plusPos := tmpCall1;
      if plusPos == -1 {
          coord := 0.0;
          return;
      }
  
      var aPart := leftPart[0..plusPos];
      var bPart := leftPart[plusPos+1..];
  
      var a := ParseInt(aPart);
      var b := ParseInt(bPart);
      var c := ParseInt(rightPart);
  
      if c != 0 {
          coord := (a + b) as real / c as real;
      } else {
          coord := 0.0;
      }
  }

vc-spec: |-
  method solve(input: string) returns (result: seq<int>)
      requires ValidInput(input)
      ensures ValidOutput(result, input)

vc-code: |-
  {
      var lines := SplitLines(input);
      if |lines| == 0 { return []; }
  
      var n := ParseInt(lines[0]);
      if n == 0 { return []; }
  
      var coordinates: seq<real> := [];
      var i := 1;
      while i <= n && i < |lines|
          invariant 1 <= i <= n + 1
          invariant i <= |lines| + 1
          invariant |coordinates| == i - 1
      {
          if i < |lines| {
              var coord := ParseCoordinate(lines[i]);
              coordinates := coordinates + [coord];
          }
          i := i + 1;
      }
  
      var counts: seq<int> := [];
      var j := 0;
      while j < |coordinates|
          invariant 0 <= j <= |coordinates|
          invariant |counts| == j
          invariant forall idx :: 0 <= idx < j ==> counts[idx] >= 1
          invariant forall idx :: 0 <= idx < j ==> counts[idx] <= |coordinates|
      {
          var count := 0;
          var k := 0;
          while k < |coordinates|
              invariant 0 <= k <= |coordinates|
              invariant count >= 0
              invariant j < k ==> count >= 1
              invariant count <= k
          {
              if coordinates[j] == coordinates[k] {
                  count := count + 1;
              }
              k := k + 1;
          }
          assert count >= 1;
          assert count <= |coordinates|;
          counts := counts + [count];
          j := j + 1;
      }
  
      return counts;
  }

vc-postamble: |-
