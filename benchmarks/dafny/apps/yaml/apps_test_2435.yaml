vc-description: |-
  Given an array of n integers where initially a[x] = 1 and all other elements are 0,
  determine how many positions can contain the value 1 after performing m swap operations optimally.
  Each operation i allows swapping any two elements at positions c and d where l_i ≤ c, d ≤ r_i.

vc-preamble: |-
  predicate ValidInput(testCases: seq<(int, int, seq<(int, int)>)>)
  {
      |testCases| >= 0 &&
      forall i :: 0 <= i < |testCases| ==> 
          var (n, x, operations) := testCases[i];
          n >= 1 && 1 <= x <= n && |operations| >= 0 &&
          (forall j :: 0 <= j < |operations| ==> 
              var (l, r) := operations[j];
              1 <= l <= r <= n)
  }
  
  function computeFinalBounds(x: int, operations: seq<(int, int)>): (int, int)
      requires forall j :: 0 <= j < |operations| ==> 
          var (l, r) := operations[j];
          l <= r
  {
      computeFinalBoundsHelper(x, x, operations, 0)
  }
  
  predicate ValidResults(testCases: seq<(int, int, seq<(int, int)>)>, results: seq<int>)
      requires ValidInput(testCases)
  {
      |results| == |testCases| &&
      forall i :: 0 <= i < |testCases| ==> 
          var (n, x, operations) := testCases[i];
          var finalBounds := computeFinalBounds(x, operations);
          results[i] == finalBounds.1 - finalBounds.0 + 1 &&
          finalBounds.0 <= x <= finalBounds.1 &&
          results[i] >= 1 &&
          1 <= finalBounds.0 <= finalBounds.1 <= n
  }

vc-helpers: |-

vc-spec: |-
  method solve(testCases: seq<(int, int, seq<(int, int)>)>) returns (results: seq<int>)
      requires ValidInput(testCases)
      ensures ValidResults(testCases, results)

vc-code: |-
  {
    assume {:axiom} false;
  }

vc-postamble: |-

