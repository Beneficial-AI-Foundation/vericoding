vc-description: |-
  Given n strings containing only 's' and 'h' characters, arrange them in optimal order
  and concatenate to form a single string. Find the maximum possible "noise" which is
  the number of "sh" subsequences in the resulting concatenated string.

vc-preamble: |-
  predicate ValidInput(input: seq<string>)
  {
      |input| >= 1 &&
      (forall i :: 0 <= i < |input[0]| ==> '0' <= input[0][i] <= '9') &&
      var n := StringToInt(input[0]);
      n >= 1 && |input| >= n + 1 &&
      forall i :: 1 <= i <= n ==> (|input[i]| > 0 &&
          forall j :: 0 <= j < |input[i]| ==> input[i][j] == 's' || input[i][j] == 'h')
  }
  
  function StringToInt(s: string): int
      requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
      ensures StringToInt(s) >= 0
  {
      if |s| == 0 then 0
      else StringToInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)
  }
  
  function CountChar(s: string, c: char): int
      ensures CountChar(s, c) >= 0
      ensures CountChar(s, c) <= |s|
  {
      if |s| == 0 then 0
      else (if s[0] == c then 1 else 0) + CountChar(s[1..], c)
  }
  
  function CountShSubsequences(s: string): int
      ensures CountShSubsequences(s) >= 0
  {
      CountShSubsequencesHelper(s, 0, 0)
  }
  
  function CountShSubsequencesHelper(s: string, index: int, s_count: int): int
      requires 0 <= index <= |s|
      requires s_count >= 0
      ensures CountShSubsequencesHelper(s, index, s_count) >= 0
      decreases |s| - index
  {
      if index == |s| then 0
      else if s[index] == 's' then
          CountShSubsequencesHelper(s, index + 1, s_count + 1)
      else if s[index] == 'h' then
          s_count + CountShSubsequencesHelper(s, index + 1, s_count)
      else
          CountShSubsequencesHelper(s, index + 1, s_count)
  }
  
  function StringRatio(s: string): real
      requires |s| > 0
  {
      (CountChar(s, 's') as real) / (|s| as real)
  }
  
  function ConcatenateStrings(strings: seq<string>): string
  {
      if |strings| == 0 then ""
      else strings[0] + ConcatenateStrings(strings[1..])
  }
  
  predicate IsSortedByRatio(strings: seq<string>)
      requires forall i :: 0 <= i < |strings| ==> |strings[i]| > 0
  {
      forall i, j :: 0 <= i < j < |strings| ==> StringRatio(strings[i]) <= StringRatio(strings[j])
  }
  
  predicate IsValidArrangement(original: seq<string>, arranged: seq<string>)
  {
      |arranged| == |original| && multiset(arranged) == multiset(original)
  }

vc-helpers: |-
  method SortByRatio(strings: seq<string>) returns (sorted: seq<string>)
      requires forall i :: 0 <= i < |strings| ==> |strings[i]| > 0
      requires forall i :: 0 <= i < |strings| ==> forall j :: 0 <= j < |strings[i]| ==> strings[i][j] == 's' || strings[i][j] == 'h'
      ensures |sorted| == |strings|
      ensures forall i :: 0 <= i < |sorted| ==> |sorted[i]| > 0
      ensures multiset(sorted) == multiset(strings)
      ensures forall i :: 0 <= i < |sorted| ==> forall j :: 0 <= j < |sorted[i]| ==> sorted[i][j] == 's' || sorted[i][j] == 'h'
      ensures IsSortedByRatio(sorted)
      ensures IsValidArrangement(strings, sorted)
  {
      sorted := strings;
      var i := 0;
      while i < |sorted|
          invariant 0 <= i <= |sorted|
          invariant |sorted| == |strings|
          invariant multiset(sorted) == multiset(strings)
          invariant forall k :: 0 <= k < |sorted| ==> |sorted[k]| > 0
          invariant forall k :: 0 <= k < |sorted| ==> forall j :: 0 <= j < |sorted[k]| ==> sorted[k][j] == 's' || sorted[k][j] == 'h'
          invariant forall k, l :: 0 <= k < l < i ==> StringRatio(sorted[k]) <= StringRatio(sorted[l])
          invariant forall k, l :: 0 <= k < i && i <= l < |sorted| ==> StringRatio(sorted[k]) <= StringRatio(sorted[l])
      {
          var j := i + 1;
          var min_index := i;
          while j < |sorted|
              invariant i < j <= |sorted|
              invariant i <= min_index < |sorted|
              invariant |sorted| == |strings|
              invariant multiset(sorted) == multiset(strings)
              invariant forall k :: 0 <= k < |sorted| ==> |sorted[k]| > 0
              invariant forall k :: 0 <= k < |sorted| ==> forall l :: 0 <= l < |sorted[k]| ==> sorted[k][l] == 's' || sorted[k][l] == 'h'
              invariant forall k :: i <= k < j ==> StringRatio(sorted[min_index]) <= StringRatio(sorted[k])
          {
              if StringRatio(sorted[j]) < StringRatio(sorted[min_index]) {
                  min_index := j;
              }
              j := j + 1;
          }
  
          if min_index != i {
              var temp := sorted[i];
              sorted := sorted[i := sorted[min_index]][min_index := temp];
          }
          i := i + 1;
      }
  }

vc-spec: |-
  method solve(input: seq<string>) returns (result: int)
      requires ValidInput(input)
      ensures result >= 0

vc-code: |-
  {
      var n := StringToInt(input[0]);
      var strings := input[1..n+1];
  
      var sorted_strings := SortByRatio(strings);
  
      var concatenated := "";
      var i := 0;
      while i < |sorted_strings|
          invariant 0 <= i <= |sorted_strings|
      {
          concatenated := concatenated + sorted_strings[i];
          i := i + 1;
      }
  
      var s_count := 0;
      var total := 0;
      var j := 0;
      while j < |concatenated|
          invariant 0 <= j <= |concatenated|
          invariant s_count >= 0
          invariant total >= 0
      {
          if concatenated[j] == 's' {
              s_count := s_count + 1;
          } else if concatenated[j] == 'h' {
              total := total + s_count;
          }
          j := j + 1;
      }
  
      result := total;
  }

vc-postamble: |-

