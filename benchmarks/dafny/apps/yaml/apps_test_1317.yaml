vc-description: |-
  Given an n×n grid where each cell (i,j) contains (i² + j²) candies, count how many cells have a number of candies divisible by m.

vc-preamble: |-
  function CountCellsDivisibleByM(n: int, m: int): int
    requires 1 <= n
    requires 1 <= m
  {
    |set i, j | 1 <= i <= n && 1 <= j <= n && (i * i + j * j) % m == 0 :: (i, j)|
  }
  
  predicate ValidInput(n: int, m: int) {
    1 <= n && 1 <= m <= 1000
  }

vc-helpers: |-
  

vc-spec: |-
  method solve(n: int, m: int) returns (result: int)
    requires ValidInput(n, m)
    ensures result >= 0
    ensures result == CountCellsDivisibleByM(n, m)

vc-code: |-
  {
    var qr: map<int, int> := map[];
  
    // Initialize all remainders to 0
    var r := 0;
    while r < m
      invariant 0 <= r <= m
      invariant forall k :: 0 <= k < r ==> k in qr && qr[k] == 0
      invariant forall k :: k in qr ==> 0 <= k < r && qr[k] == 0
    {
      qr := qr[r := 0];
      r := r + 1;
    }
  
    // Count how many i in [1, n] have i^2 ≡ r (mod m) for each remainder r
    var i := 1;
    while i <= n
      invariant 1 <= i <= n + 1
      invariant forall k :: k in qr ==> qr[k] >= 0
      invariant forall k :: 0 <= k < m ==> k in qr
      invariant qr.Keys == set k {:trigger} | 0 <= k < m
      invariant forall k :: 0 <= k < m ==> qr[k] == |set j | 1 <= j <= i - 1 && (j * j) % m == k|
    {
      var remainder := (i * i) % m;
      qr := qr[remainder := qr[remainder] + 1];
      i := i + 1;
    }
  
    result := 0;
    i := 0;
    while i < m
      invariant 0 <= i <= m
      invariant result >= 0
      invariant forall k :: k in qr ==> qr[k] >= 0
      invariant forall k :: 0 <= k < m ==> qr[k] == |set j | 1 <= j <= n && (j * j) % m == k|
      invariant result == |set x, y | 1 <= x <= n && 1 <= y <= n && (x * x + y * y) % m == 0 && (x * x) % m < i :: (x, y)|
    {
      var r1 := i;
      var r2 := if i == 0 then 0 else m - i;
  
      var count1 := if r1 in qr then qr[r1] else 0;
      var count2 := if r2 in qr then qr[r2] else 0;
  
      assert count1 >= 0 && count2 >= 0;
      assert count1 == |set j | 1 <= j <= n && (j * j) % m == r1|;
      assert count2 == |set j | 1 <= j <= n && (j * j) % m == r2|;
  
      if r1 == r2 {
        result := result + count1 * count1;
      } else {
        result := result + 2 * count1 * count2;
      }
      i := i + 1;
    }
  
    assert i == m;
    assert result == |set x, y | 1 <= x <= n && 1 <= y <= n && (x * x + y * y) % m == 0 && (x * x) % m < m :: (x, y)|;
    assert forall x :: 1 <= x <= n ==> (x * x) % m < m;
    assert result == |set x, y | 1 <= x <= n && 1 <= y <= n && (x * x + y * y) % m == 0 :: (x, y)|;
  }

vc-postamble: |-
