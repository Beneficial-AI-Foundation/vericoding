vc-description: |-
  Given n columns of soldiers where column i has l_i soldiers starting with left leg 
  and r_i soldiers starting with right leg, find which column to swap (change all 
  left-leg soldiers to right-leg and vice versa) to maximize the beauty of the parade.
  Beauty is defined as |L - R| where L is total left-leg soldiers and R is total 
  right-leg soldiers across all columns. You can swap at most one column. 
  Output the 1-indexed column number to swap, or 0 if no swap improves the current beauty.

vc-preamble: |-
  predicate ValidInput(columns: seq<(int, int)>)
  {
      forall i :: 0 <= i < |columns| ==> columns[i].0 > 0 && columns[i].1 > 0
  }
  
  function abs(x: int): int
  {
      if x >= 0 then x else -x
  }
  
  function sum_left(columns: seq<(int, int)>): int
  {
      if |columns| == 0 then 0
      else columns[0].0 + sum_left(columns[1..])
  }
  
  function sum_right(columns: seq<(int, int)>): int
  {
      if |columns| == 0 then 0
      else columns[0].1 + sum_right(columns[1..])
  }

vc-helpers: |-
  lemma sum_left_lemma(columns: seq<(int, int)>, i: int)
      requires 0 <= i < |columns|
      ensures sum_left(columns[..i+1]) == sum_left(columns[..i]) + columns[i].0
  {
      if i == 0 {
          assert columns[..1] == [columns[0]];
          assert sum_left(columns[..1]) == columns[0].0;
          assert sum_left(columns[..0]) == 0;
      } else {
          assert columns[..i+1] == columns[..i] + [columns[i]];
          sum_left_append_lemma(columns[..i], [columns[i]]);
      }
  }
  
  lemma sum_right_lemma(columns: seq<(int, int)>, i: int)
      requires 0 <= i < |columns|
      ensures sum_right(columns[..i+1]) == sum_right(columns[..i]) + columns[i].1
  {
      if i == 0 {
          assert columns[..1] == [columns[0]];
          assert sum_right(columns[..1]) == columns[0].1;
          assert sum_right(columns[..0]) == 0;
      } else {
          assert columns[..i+1] == columns[..i] + [columns[i]];
          sum_right_append_lemma(columns[..i], [columns[i]]);
      }
  }
  
  lemma sum_left_append_lemma(a: seq<(int, int)>, b: seq<(int, int)>)
      ensures sum_left(a + b) == sum_left(a) + sum_left(b)
  {
      if |a| == 0 {
          assert a + b == b;
      } else {
          assert a + b == [a[0]] + (a[1..] + b);
          sum_left_append_lemma(a[1..], b);
      }
  }
  
  lemma sum_right_append_lemma(a: seq<(int, int)>, b: seq<(int, int)>)
      ensures sum_right(a + b) == sum_right(a) + sum_right(b)
  {
      if |a| == 0 {
          assert a + b == b;
      } else {
          assert a + b == [a[0]] + (a[1..] + b);
          sum_right_append_lemma(a[1..], b);
      }
  }

vc-spec: |-
  method solve(columns: seq<(int, int)>) returns (result: int)
      requires ValidInput(columns)
      ensures 0 <= result <= |columns|
      ensures var L := sum_left(columns);
              var R := sum_right(columns);
              var original_beauty := abs(L - R);
              if result == 0 then
                  forall i :: 0 <= i < |columns| ==> 
                      var new_L := L - columns[i].0 + columns[i].1;
                      var new_R := R - columns[i].1 + columns[i].0;
                      abs(new_L - new_R) <= original_beauty
              else
                  1 <= result <= |columns| &&
                  var best_idx := result - 1;
                  var best_L := L - columns[best_idx].0 + columns[best_idx].1;
                  var best_R := R - columns[best_idx].1 + columns[best_idx].0;
                  var best_beauty := abs(best_L - best_R);
                  best_beauty > original_beauty &&
                  forall i :: 0 <= i < |columns| ==> 
                      var new_L := L - columns[i].0 + columns[i].1;
                      var new_R := R - columns[i].1 + columns[i].0;
                      abs(new_L - new_R) <= best_beauty

vc-code: |-
  {
      var n := |columns|;
      if n == 0 {
          result := 0;
          return;
      }
  
      var L := 0;
      var R := 0;
      var i := 0;
      while i < n
          invariant 0 <= i <= n
          invariant L >= 0 && R >= 0
          invariant L == sum_left(columns[..i])
          invariant R == sum_right(columns[..i])
      {
          sum_left_lemma(columns, i);
          sum_right_lemma(columns, i);
          L := L + columns[i].0;
          R := R + columns[i].1;
          i := i + 1;
      }
  
      assert columns[..n] == columns;
      assert L == sum_left(columns);
      assert R == sum_right(columns);
  
      var original_beauty := abs(L - R);
      var mx := original_beauty;
      var k := 0;
  
      i := 0;
      while i < n
          invariant 0 <= i <= n
          invariant k >= 0
          invariant mx >= original_beauty
          invariant k == 0 ==> mx == original_beauty
          invariant k > 0 ==> 1 <= k <= n && k - 1 < i
          invariant k > 0 ==> 
              var best_idx := k - 1;
              var best_L := L - columns[best_idx].0 + columns[best_idx].1;
              var best_R := R - columns[best_idx].1 + columns[best_idx].0;
              mx == abs(best_L - best_R) && mx > original_beauty
          invariant forall j :: 0 <= j < i ==> 
              var new_L := L - columns[j].0 + columns[j].1;
              var new_R := R - columns[j].1 + columns[j].0;
              abs(new_L - new_R) <= mx
      {
          var Lp := L - columns[i].0 + columns[i].1;
          var Rp := R - columns[i].1 + columns[i].0;
          if abs(Lp - Rp) > mx {
              mx := abs(Lp - Rp);
              k := i + 1;
          }
          i := i + 1;
      }
  
      result := k;
  }

vc-postamble: |-

