vc-description: |-
  Distribute n candies among m friends such that each friend receives at least one candy
  and the difference between the maximum and minimum number of candies is minimized.
  The optimal solution gives each friend either floor(n/m) or floor(n/m)+1 candies.

vc-preamble: |-
  predicate ValidInput(n: int, m: int)
  {
    n >= m > 0
  }
  
  function sum(s: seq<int>): int
  {
    if |s| == 0 then 0 else s[0] + sum(s[1..])
  }
  
  function count(s: seq<int>, val: int): int
  {
    if |s| == 0 then 0 
    else (if s[0] == val then 1 else 0) + count(s[1..], val)
  }
  
  predicate OptimalDistribution(result: seq<int>, n: int, m: int)
    requires m > 0
  {
    |result| == m &&
    (forall i :: 0 <= i < |result| ==> result[i] > 0) &&
    sum(result) == n &&
    (forall i :: 0 <= i < |result| ==> result[i] == n / m || result[i] == n / m + 1) &&
    count(result, n / m) == m - (n % m) &&
    count(result, n / m + 1) == n % m
  }

vc-helpers: |-
  lemma sum_append_lemma(s: seq<int>, x: int)
    ensures sum(s + [x]) == sum(s) + x
  {
    if |s| == 0 {
      assert s + [x] == [x];
      assert sum([x]) == x + sum([]);
      assert sum([]) == 0;
    } else {
      assert s + [x] == [s[0]] + (s[1..] + [x]);
      sum_append_lemma(s[1..], x);
      assert sum(s + [x]) == s[0] + sum(s[1..] + [x]);
      assert sum(s[1..] + [x]) == sum(s[1..]) + x;
      assert sum(s) == s[0] + sum(s[1..]);
    }
  }
  
  lemma count_append_same_lemma(s: seq<int>, x: int)
    ensures count(s + [x], x) == count(s, x) + 1
  {
    if |s| == 0 {
      assert s + [x] == [x];
      assert count([x], x) == 1 + count([], x);
      assert count([], x) == 0;
    } else {
      assert s + [x] == [s[0]] + (s[1..] + [x]);
      count_append_same_lemma(s[1..], x);
      assert count(s + [x], x) == (if s[0] == x then 1 else 0) + count(s[1..] + [x], x);
      assert count(s[1..] + [x], x) == count(s[1..], x) + 1;
      assert count(s, x) == (if s[0] == x then 1 else 0) + count(s[1..], x);
    }
  }
  
  lemma count_append_diff_lemma(s: seq<int>, y: int, x: int)
    requires x != y
    ensures count(s + [x], y) == count(s, y)
  {
    if |s| == 0 {
      assert s + [x] == [x];
      assert count([x], y) == (if x == y then 1 else 0) + count([], y);
      assert count([], y) == 0;
      assert x != y;
      assert count([x], y) == 0;
    } else {
      assert s + [x] == [s[0]] + (s[1..] + [x]);
      count_append_diff_lemma(s[1..], y, x);
      assert count(s + [x], y) == (if s[0] == y then 1 else 0) + count(s[1..] + [x], y);
      assert count(s[1..] + [x], y) == count(s[1..], y);
      assert count(s, y) == (if s[0] == y then 1 else 0) + count(s[1..], y);
    }
  }
  
  lemma arithmetic_lemma(n: int, m: int, base: int, remainder: int, lower_count: int)
    requires m > 0
    requires base == n / m
    requires remainder == n % m
    requires lower_count == m - remainder
    ensures lower_count * base + remainder * (base + 1) == n
  {
    assert lower_count * base + remainder * (base + 1) == (m - remainder) * base + remainder * (base + 1);
    assert (m - remainder) * base + remainder * (base + 1) == m * base - remainder * base + remainder * base + remainder;
    assert m * base - remainder * base + remainder * base + remainder == m * base + remainder;
    assert m * base + remainder == m * (n / m) + (n % m);
    assert m * (n / m) + (n % m) == n;
  }

vc-spec: |-
  method solve(n: int, m: int) returns (result: seq<int>)
    requires ValidInput(n, m)
    ensures OptimalDistribution(result, n, m)

vc-code: |-
  {
    var base := n / m;
    var remainder := n % m;
    var lower_count := m - remainder;
  
    result := [];
  
    var i := 0;
    while i < lower_count
      invariant 0 <= i <= lower_count
      invariant |result| == i
      invariant forall j :: 0 <= j < |result| ==> result[j] == base
      invariant forall j :: 0 <= j < |result| ==> result[j] > 0
      invariant sum(result) == i * base
      invariant count(result, base) == i
      invariant count(result, base + 1) == 0
    {
      sum_append_lemma(result, base);
      count_append_same_lemma(result, base);
      count_append_diff_lemma(result, base + 1, base);
      result := result + [base];
      i := i + 1;
    }
  
    i := 0;
    while i < remainder
      invariant 0 <= i <= remainder
      invariant |result| == lower_count + i
      invariant forall j :: 0 <= j < lower_count ==> result[j] == base
      invariant forall j :: lower_count <= j < |result| ==> result[j] == base + 1
      invariant forall j :: 0 <= j < |result| ==> result[j] > 0
      invariant forall j :: 0 <= j < |result| ==> result[j] == base || result[j] == base + 1
      invariant sum(result) == lower_count * base + i * (base + 1)
      invariant count(result, base) == lower_count
      invariant count(result, base + 1) == i
    {
      sum_append_lemma(result, base + 1);
      count_append_same_lemma(result, base + 1);
      count_append_diff_lemma(result, base, base + 1);
      result := result + [base + 1];
      i := i + 1;
    }
  
    arithmetic_lemma(n, m, base, remainder, lower_count);
  }

vc-postamble: |-

