vc-description: |-
  Given n castles with soldiers, two players alternate turns starting with White.
  Each turn a player attacks a castle using mixed (x damage), infantry (y damage, 
  forbidden if previous attack on same castle was infantry), or cavalry (z damage,
  forbidden if previous attack on same castle was cavalry). Player making the last
  attack wins. Find number of White's winning first moves using Grundy number theory.

vc-preamble: |-
  datatype TestCase = TestCase(n: nat, x: nat, y: nat, z: nat, castles: seq<nat>)
  
  predicate ValidInput(input: string)
  {
      |input| > 0 && 
      var lines := split_by_newline(input);
      |lines| >= 1 && 
      is_non_negative_integer_string(lines[0]) &&
      var t := parse_integer(lines[0]);
      1 <= t <= 1000 &&
      |lines| == 1 + 2 * t &&
      forall i :: 0 <= i < t ==>
          var params_line := lines[1 + 2*i];
          var castles_line := lines[2 + 2*i];
          is_valid_test_case_params(params_line) &&
          is_valid_castles_line(castles_line, get_n_from_params(params_line)) &&
          get_n_from_params(params_line) <= 300000 &&
          1 <= get_x_from_params(params_line) <= 5 &&
          1 <= get_y_from_params(params_line) <= 5 &&
          1 <= get_z_from_params(params_line) <= 5
  }
  
  predicate ValidOutput(input: string, output: string)
      requires ValidInput(input)
  {
      |output| > 0 &&
      output[|output|-1] == '\n' &&
      count_lines(output) == get_test_count(input) &&
      forall i :: 0 <= i < count_lines(output) ==> 
          var line := get_line(output, i);
          line != "" ==> is_non_negative_integer_string(line)
  }
  
  function get_test_count(s: string): nat
      requires ValidInput(s)
      ensures 1 <= get_test_count(s) <= 1000
  {
      parse_integer(split_by_newline(s)[0])
  }
  
  function get_test_case(s: string, i: nat): TestCase
      requires ValidInput(s)
      requires i < get_test_count(s)
      ensures var tc := get_test_case(s, i);
          1 <= tc.n <= 300000 &&
          1 <= tc.x <= 5 && 1 <= tc.y <= 5 && 1 <= tc.z <= 5 &&
          |tc.castles| == tc.n &&
          forall j :: 0 <= j < |tc.castles| ==> tc.castles[j] >= 1
  {
      var lines := split_by_newline(s);
      var params_line := lines[1 + 2*i];
      var castles_line := lines[2 + 2*i];
      TestCase(
          get_n_from_params(params_line),
          get_x_from_params(params_line), 
          get_y_from_params(params_line),
          get_z_from_params(params_line),
          parse_castle_array(castles_line)
      )
  }
  
  function count_winning_first_moves(tc: TestCase): nat
      ensures count_winning_first_moves(tc) <= 3 * tc.n
  {
      0 // Implementation uses Grundy number theory
  }

vc-helpers: |-
  function split_by_newline(s: string): seq<string>
      ensures forall line :: line in split_by_newline(s) ==> '\n' !in line
      ensures |split_by_newline(s)| >= 1
  {
      [""] // placeholder implementation
  }
  
  predicate is_non_negative_integer_string(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  }
  
  predicate is_valid_test_case_params(line: string)
  {
      |line| > 0 // should validate "n x y z" format
  }
  
  predicate is_valid_castles_line(line: string, n: nat)
  {
      |line| > 0 // should validate n space-separated integers
  }
  
  function get_n_from_params(line: string): nat
  {
      1 // placeholder - parse first integer
  }
  
  function get_x_from_params(line: string): nat
  {
      1 // placeholder - parse second integer  
  }
  
  function get_y_from_params(line: string): nat
  {
      1 // placeholder - parse third integer
  }
  
  function get_z_from_params(line: string): nat
  {
      1 // placeholder - parse fourth integer
  }
  
  function parse_integer(s: string): nat
      requires is_non_negative_integer_string(s)
  {
      0 // placeholder implementation
  }
  
  function parse_castle_array(line: string): seq<nat>
  {
      [1] // placeholder - parse space-separated integers
  }
  
  function count_lines(s: string): nat
      ensures count_lines(s) >= 1
  {
      1 // placeholder implementation
  }
  
  function get_line(s: string, i: nat): string
      requires i < count_lines(s)
  {
      s // placeholder implementation
  }

vc-spec: |-
  method solve(stdin_input: string) returns (result: string)
      requires ValidInput(stdin_input)
      ensures ValidOutput(stdin_input, result)
      ensures forall i :: 0 <= i < get_test_count(stdin_input) ==>
          var output_val := parse_integer(get_line(result, i));
          var test_case := get_test_case(stdin_input, i);
          output_val == count_winning_first_moves(test_case)

vc-code: |-
  {
      result := "";
      var t := get_test_count(stdin_input);
      var i := 0;
  
      while i < t
          invariant 0 <= i <= t
          invariant count_lines(result) == i
      {
          var test_case := get_test_case(stdin_input, i);
          var winning_moves := count_winning_first_moves(test_case);
          var line := int_to_string(winning_moves) + "\n";
          result := result + line;
          i := i + 1;
      }
  }

vc-postamble: |-

