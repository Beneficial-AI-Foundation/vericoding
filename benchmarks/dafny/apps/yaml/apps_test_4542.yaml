vc-description: |-
  Given a string of stones ('B' for black, 'W' for white), find the minimum number 
  of stones to place at either end to make all stones the same color. When placing 
  a stone, all stones of opposite color between the new stone and the nearest 
  existing stone of the same color are flipped.

vc-preamble: |-
  predicate ValidInput(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == 'B' || s[i] == 'W'
  }
  
  function CountSegments(s: string): int
      requires |s| > 0
      ensures CountSegments(s) >= 1
      ensures CountSegments(s) <= |s|
  {
      if |s| == 1 then 1
      else 
          CountSegments(s[..|s|-1]) + (if s[|s|-1] != s[|s|-2] then 1 else 0)
  }

vc-helpers: |-
  lemma CountSegmentsLemma(s: string, i: int)
      requires |s| > 0
      requires 1 <= i < |s|
      requires forall j :: 0 <= j < |s| ==> s[j] == 'B' || s[j] == 'W'
      ensures CountSegments(s[..i+1]) == CountSegments(s[..i]) + (if s[i] != s[i-1] then 1 else 0)
  {
      var prefix := s[..i];
      var extended := s[..i+1];
  
      assert extended == prefix + [s[i]];
      assert |extended| == i + 1;
      assert |prefix| == i;
  
      if i == 1 {
          assert |extended| == 2;
          assert CountSegments(extended) == CountSegments(extended[..1]) + (if extended[1] != extended[0] then 1 else 0);
          assert extended[..1] == [s[0]];
          assert CountSegments([s[0]]) == 1;
      } else {
          assert CountSegments(extended) == CountSegments(extended[..i]) + (if extended[i] != extended[i-1] then 1 else 0);
          assert extended[..i] == prefix;
      }
  }

vc-spec: |-
  method solve(s: string) returns (result: int)
      requires ValidInput(s)
      ensures result >= 0
      ensures result == CountSegments(s) - 1
      ensures result <= |s| - 1

vc-code: |-
  {
      var segments := 1;
      var i := 1;
  
      while i < |s|
          invariant 1 <= i <= |s|
          invariant segments >= 1
          invariant segments == CountSegments(s[..i])
          invariant forall j :: 0 <= j < i ==> s[j] == 'B' || s[j] == 'W'
      {
          assert s[..i+1] == s[..i] + [s[i]];
          if s[i] != s[i-1] {
              segments := segments + 1;
          }
          CountSegmentsLemma(s, i);
          i := i + 1;
      }
  
      assert i == |s|;
      assert s[..i] == s;
      assert segments == CountSegments(s);
      return segments - 1;
  }

vc-postamble: |-
