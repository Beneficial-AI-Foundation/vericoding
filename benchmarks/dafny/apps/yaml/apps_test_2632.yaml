vc-description: |-
  Given an m√ón grid of non-negative integers, find the minimum sum path from the top-left corner 
  to the bottom-right corner. You can only move right or down.

vc-preamble: |-
  predicate ValidPath(path: seq<(int, int)>, m: int, n: int)
  {
      |path| >= 1 &&
      path[0] == (0, 0) &&
      path[|path|-1] == (m-1, n-1) &&
      (forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&
      forall i :: 0 <= i < |path|-1 ==> 
          (path[i+1].0 == path[i].0 && path[i+1].1 == path[i].1 + 1) || // right
          (path[i+1].0 == path[i].0 + 1 && path[i+1].1 == path[i].1)    // down
  }
  
  function PathSum(path: seq<(int, int)>, grid: array2<int>): int
      requires forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < grid.Length0 && 0 <= path[i].1 < grid.Length1
      reads grid
  {
      if |path| == 0 then 0
      else grid[path[0].0, path[0].1] + PathSum(path[1..], grid)
  }
  
  predicate ValidInput(grid: array2<int>)
      reads grid
  {
      grid.Length0 > 0 && grid.Length1 > 0 &&
      forall i, j :: 0 <= i < grid.Length0 && 0 <= j < grid.Length1 ==> grid[i, j] >= 0
  }

vc-helpers: |-

vc-spec: |-
  method minPathSum(grid: array2<int>) returns (result: int)
      requires ValidInput(grid)
      ensures result >= 0
      ensures grid.Length0 == 1 && grid.Length1 == 1 ==> result == grid[0, 0]

vc-code: |-
  {
      var m := grid.Length0;
      var n := grid.Length1;
  
      // Initialize dp array
      var dp := new int[n];
  
      // Handle first row
      dp[0] := grid[0, 0];
      var j := 1;
      while j < n
          invariant 1 <= j <= n
          invariant dp[0] == grid[0, 0]
          invariant forall k :: 1 <= k < j ==> dp[k] >= 0
      {
          dp[j] := dp[j-1] + grid[0, j];
          j := j + 1;
      }
  
      // Process remaining rows
      var i := 1;
      while i < m
          invariant 1 <= i <= m
          invariant forall k :: 0 <= k < n ==> dp[k] >= 0
          invariant m == 1 ==> dp[0] == grid[0, 0]
      {
          dp[0] := dp[0] + grid[i, 0];
          j := 1;
          while j < n
              invariant 1 <= j <= n
              invariant forall k :: 0 <= k < n ==> dp[k] >= 0
          {
              var fromAbove := dp[j];
              var fromLeft := dp[j-1];
              var minPrev := if fromAbove < fromLeft then fromAbove else fromLeft;
              dp[j] := minPrev + grid[i, j];
              j := j + 1;
          }
          i := i + 1;
      }
  
      assert m == 1 && n == 1 ==> dp[0] == grid[0, 0];
      result := dp[n-1];
  }

vc-postamble: |-

