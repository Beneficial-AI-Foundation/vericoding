vc-description: |-
  Given n problems with difficulties d_i (in increasing order) and costs c_i, find the maximum profit 
  from selecting a consecutive subsegment of problems. For a subsegment [l, r]:
  - Revenue: (r - l + 1) × a burles (where a is profit per problem)
  - Costs: sum of c_i for i in [l, r] + gap(l, r)
  - gap(l, r) = max{(d_{i+1} - d_i)² | l ≤ i < r}, or 0 if l = r
  - Profit = Revenue - Costs
  Find the maximum possible profit (can be 0 if all segments are unprofitable).

vc-preamble: |-
  predicate ValidInput(input: string)
  {
      var lines := SplitLinesSpec(input);
      |lines| >= 1 && 
      |SplitWhitespaceSpec(lines[0])| >= 2 &&
      var n := ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]);
      var k := ParseIntSpec(SplitWhitespaceSpec(lines[0])[1]);
      n > 0 && k > 0 && |lines| >= n + 1 &&
      (forall i :: 1 <= i <= n ==> 
          i < |lines| && |SplitWhitespaceSpec(lines[i])| >= 2)
  }
  
  function OptimalSegmentProfit(input: string, n: nat, k: int): int
      requires n > 0
      requires k > 0
      requires var lines := SplitLinesSpec(input);
          |lines| >= n + 1 &&
          (forall i :: 1 <= i <= n ==> 
              i < |lines| && |SplitWhitespaceSpec(lines[i])| >= 2)
  {
      var lines := SplitLinesSpec(input);
      var difficulties := seq(n, i requires 0 <= i < n => 
          ParseIntSpec(SplitWhitespaceSpec(lines[i + 1])[0]));
      var costs := seq(n, i requires 0 <= i < n => 
          ParseIntSpec(SplitWhitespaceSpec(lines[i + 1])[1]));
  
      MaxSubsegmentProfit(difficulties, costs, k)
  }
  
  function MaxSubsegmentProfit(difficulties: seq<int>, costs: seq<int>, k: int): int
      requires |difficulties| == |costs| >= 0
      requires k > 0
      requires forall i :: 0 <= i < |difficulties|-1 ==> difficulties[i] < difficulties[i+1]
  {
      if |difficulties| == 0 then 0
      else
          var allSegmentProfits := seq(|difficulties|, l requires 0 <= l < |difficulties| => 
              seq(|difficulties| - l, len requires 0 <= len < |difficulties| - l =>
                  SubsegmentProfit(difficulties, costs, k, l, l + len)));
          Max(0, MaxInNestedSeq(allSegmentProfits))
  }
  
  function SubsegmentProfit(difficulties: seq<int>, costs: seq<int>, k: int, l: nat, r: nat): int
      requires |difficulties| == |costs|
      requires k > 0
      requires 0 <= l <= r < |difficulties|
      requires forall i :: 0 <= i < |difficulties|-1 ==> difficulties[i] < difficulties[i+1]
  {
      var length := r - l + 1;
      var revenue := length * k;
      var costSum := SumRange(costs, l, r);
      var gap := if l == r then 0 else MaxGapSquared(difficulties, l, r);
      revenue - costSum - gap
  }
  
  function SplitLinesSpec(s: string): seq<string>
  {
      []
  }
  
  function SplitWhitespaceSpec(s: string): seq<string>
  {
      []
  }
  
  function ParseIntSpec(s: string): int
  {
      0
  }
  
  function IntToStringResult(n: int): string
  {
      "0"
  }

vc-helpers: |-
  function MaxGapSquared(d: seq<int>, l: nat, r: nat): int
      requires 0 <= l < r < |d|
      requires forall i :: l <= i < r ==> d[i] < d[i+1]
      decreases r - l
  {
      if l + 1 == r then (d[r] - d[l]) * (d[r] - d[l])
      else
          var leftGap := (d[l + 1] - d[l]) * (d[l + 1] - d[l]);
          var restGap := MaxGapSquared(d, l + 1, r);
          if leftGap >= restGap then leftGap else restGap
  }
  
  function SumRange(c: seq<int>, l: nat, r: nat): int
      requires 0 <= l <= r < |c|
      decreases r - l
  {
      if l == r then c[l]
      else c[l] + SumRange(c, l + 1, r)
  }
  
  function MaxInNestedSeq(seqs: seq<seq<int>>): int
      decreases |seqs|
  {
      if |seqs| == 0 then 0
      else
          var maxInFirst := MaxInSeq(seqs[0]);
          var maxInRest := MaxInNestedSeq(seqs[1..]);
          Max(maxInFirst, maxInRest)
  }
  
  function MaxInSeq(s: seq<int>): int
      decreases |s|
  {
      if |s| == 0 then 0
      else if |s| == 1 then s[0]
      else Max(s[0], MaxInSeq(s[1..]))
  }
  
  function Max(a: int, b: int): int
  {
      if a >= b then a else b
  }
  
  method IntToString(n: int) returns (s: string)
      ensures |s| >= 1
      ensures n >= 0 ==> (|s| >= 1 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')
      ensures s == IntToStringResult(n)
  {
      s := "0";
  }
  
  method SplitLines(s: string) returns (lines: seq<string>)
      requires |s| >= 0
      ensures |lines| >= 0
      ensures lines == SplitLinesSpec(s)
  {
      lines := [];
  }
  
  method SplitWhitespace(s: string) returns (parts: seq<string>)
      requires |s| >= 0
      ensures |parts| >= 0
      ensures parts == SplitWhitespaceSpec(s)
  {
      parts := [];
  }
  
  method ParseInt(s: string) returns (result: int)
      ensures result == ParseIntSpec(s)
  {
      result := 0;
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires |input| > 0
      ensures |result| > 0
      ensures result[|result|-1] == '\n'
      ensures var lines := SplitLinesSpec(input);
          (|lines| == 0 || |lines| == 1 || 
           |SplitWhitespaceSpec(lines[0])| < 2 ||
           ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]) <= 0) ==> 
          result == "0\n"
      ensures ValidInput(input) ==>
          (var lines := SplitLinesSpec(input);
           var n := ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]);
           var k := ParseIntSpec(SplitWhitespaceSpec(lines[0])[1]);
           exists profit: int :: 
              profit >= 0 && 
              result == IntToStringResult(profit) + "\n" &&
              profit == OptimalSegmentProfit(input, n, k))

vc-code: |-
  {
      var lines := SplitLines(input);
      if |lines| == 0 { return "0\n"; }
  
      var firstParts := SplitWhitespace(lines[0]);
      if |firstParts| < 2 { return "0\n"; }
  
      var n := ParseInt(firstParts[0]);
      var k := ParseInt(firstParts[1]);
  
      if n <= 0 || |lines| < n + 1 { return "0\n"; }
  
      var d := new int[n];
      var c := new int[n];
  
      var i := 0;
      while i < n && i + 1 < |lines|
      {
          var tmpCall1 := SplitWhitespace(lines[i + 1]);
          var parts := tmpCall1;
          if |parts| >= 2 {
              var difficulty := ParseInt(parts[0]);
              var cost := ParseInt(parts[1]);
              d[i] := difficulty;
              c[i] := cost;
          }
          i := i + 1;
      }
  
      var maxProfit := 0;
  
      // Try all possible subsegments [l, r]
      var l := 0;
      while l < n
      {
          var r := l;
          while r < n
          {
              var length := r - l + 1;
              var revenue := length * k;
  
              var costSum := 0;
              var k_inner := l;
              while k_inner <= r
              {
                  costSum := costSum + c[k_inner];
                  k_inner := k_inner + 1;
              }
  
              var gap := 0;
              if l < r {
                  var j := l;
                  while j < r
                  {
                      var diff := d[j + 1] - d[j];
                      gap := Max(gap, diff * diff);
                      j := j + 1;
                  }
              }
  
              var profit := revenue - costSum - gap;
              maxProfit := Max(maxProfit, profit);
  
              r := r + 1;
          }
          l := l + 1;
      }
  
      var profitStr := IntToString(maxProfit);
      return profitStr + "\n";
  }

vc-postamble: |-

