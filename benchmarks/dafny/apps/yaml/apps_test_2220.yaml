vc-description: |-
  Given n emotes with happiness values, use emotes m times total to maximize happiness.
  Cannot use the same emote more than k consecutive times.

vc-preamble: |-
  predicate ValidInput(n: int, m: int, k: int, emotes: seq<int>)
  {
      n >= 2 && k >= 1 && m >= 1 && |emotes| == n &&
      forall i :: 0 <= i < |emotes| ==> emotes[i] >= 1
  }
  
  function MaxHappiness(n: int, m: int, k: int, emotes: seq<int>): int
      requires ValidInput(n, m, k, emotes)
  {
      var k_plus_1 := k + 1;
      var total := m / k_plus_1;
      var remainder := m % k_plus_1;
      // Assumes optimal strategy using highest and second highest values
      var max_val := MaxValue(emotes);
      var second_max_val := SecondMaxValue(emotes);
      remainder * max_val + max_val * (total * k) + second_max_val * total
  }
  
  function MaxValue(s: seq<int>): int
      requires |s| >= 1
      requires forall i :: 0 <= i < |s| ==> s[i] >= 1
      ensures MaxValue(s) >= 1
      ensures exists i :: 0 <= i < |s| && s[i] == MaxValue(s)
  {
      if |s| == 1 then s[0]
      else if s[0] >= MaxValue(s[1..]) then s[0]
      else MaxValue(s[1..])
  }
  
  function SecondMaxValue(s: seq<int>): int
      requires |s| >= 2
      requires forall i :: 0 <= i < |s| ==> s[i] >= 1
  {
      var max_val := MaxValue(s);
      var filtered := FilterOut(s, max_val, 1);
      if |filtered| > 0 then MaxValue(filtered) else 1
  }
  
  function FilterOut(s: seq<int>, val: int, count: int): seq<int>
      requires count >= 0
      requires forall i :: 0 <= i < |s| ==> s[i] >= 1
      ensures forall i :: 0 <= i < |FilterOut(s, val, count)| ==> FilterOut(s, val, count)[i] >= 1
  {
      if |s| == 0 || count == 0 then s
      else if s[0] == val then FilterOut(s[1..], val, count - 1)
      else [s[0]] + FilterOut(s[1..], val, count)
  }

vc-helpers: |-
  method SortSeq(s: seq<int>) returns (sorted: seq<int>)
      requires |s| >= 1
      requires forall i :: 0 <= i < |s| ==> s[i] >= 1
      ensures |sorted| == |s|
      ensures multiset(sorted) == multiset(s)
      ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
      ensures forall i :: 0 <= i < |sorted| ==> sorted[i] >= 1
  {
      sorted := s;
      var i := 0;
      while i < |sorted|
          invariant 0 <= i <= |sorted|
          invariant |sorted| == |s|
          invariant multiset(sorted) == multiset(s)
          invariant forall x, y :: 0 <= x < i && x <= y < |sorted| ==> sorted[x] <= sorted[y]
          invariant forall j :: 0 <= j < |sorted| ==> sorted[j] >= 1
      {
          var j := i + 1;
          while j < |sorted|
              invariant i < j <= |sorted|
              invariant |sorted| == |s|
              invariant multiset(sorted) == multiset(s)
              invariant forall x, y :: 0 <= x < i && x <= y < |sorted| ==> sorted[x] <= sorted[y]
              invariant forall y :: i <= y < j ==> sorted[i] <= sorted[y]
              invariant forall k :: 0 <= k < |sorted| ==> sorted[k] >= 1
          {
              if sorted[i] > sorted[j] {
                  var temp := sorted[i];
                  sorted := sorted[i := sorted[j]];
                  sorted := sorted[j := temp];
              }
              j := j + 1;
          }
          i := i + 1;
      }
  }

vc-spec: |-
  method solve(n: int, m: int, k: int, emotes: seq<int>) returns (result: int)
      requires ValidInput(n, m, k, emotes)
      ensures result >= 0

vc-code: |-
  {
      var sorted_emotes := SortSeq(emotes);
      var b1 := sorted_emotes[n-1]; // highest happiness value
      var b2 := sorted_emotes[n-2]; // second highest happiness value
  
      var k_plus_1 := k + 1;
      var total := m / k_plus_1;
      var remainder := m % k_plus_1;
  
      var score := 0;
      score := score + remainder * b1;
      score := score + b1 * (total * k);
      score := score + b2 * total;
  
      result := score;
  }

vc-postamble: |-

