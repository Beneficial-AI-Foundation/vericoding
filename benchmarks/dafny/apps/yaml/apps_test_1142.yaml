vc-description: |-
  Given a gun with magazine size k and n waves of monsters, find the minimum total bullets
  needed to clear all waves. Each wave i has monsters that spawn at time l_i and must be
  killed by time r_i. Shooting kills one monster instantly, reloading takes 1 time unit
  and discards remaining bullets. Waves are non-overlapping and chronological.
  Return -1 if impossible.

vc-preamble: |-
  datatype Wave = Wave(start_time: nat, end_time: nat, monsters: nat)
  
  predicate ValidWaves(waves: seq<Wave>)
  {
      forall i :: 0 <= i < |waves| ==> 
          waves[i].start_time <= waves[i].end_time &&
          waves[i].monsters > 0 &&
          (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)
  }
  
  predicate CanSolveAllWaves(waves: seq<Wave>, k: nat)
  {
      k > 0 && 
      forall i :: 0 <= i < |waves| ==> 
          CanSolveWave(waves, i, k)
  }
  
  predicate CanSolveWave(waves: seq<Wave>, waveIndex: nat, k: nat)
      requires waveIndex < |waves|
      requires k > 0
  {
      var wave := waves[waveIndex];
      var timeAvailable := wave.end_time - wave.start_time + 1;
      var maxPossibleShots := timeAvailable * k;
      wave.monsters <= maxPossibleShots &&
      (waveIndex == 0 || CanReachWaveInTime(waves, waveIndex, k))
  }
  
  predicate CanReachWaveInTime(waves: seq<Wave>, waveIndex: nat, k: nat)
      requires waveIndex > 0 && waveIndex < |waves|
      requires k > 0
  {
      var prevWave := waves[waveIndex - 1];
      var currWave := waves[waveIndex];
      var timeGap := currWave.start_time - prevWave.end_time;
      var reloadsNeeded := CalculateReloadsNeeded(prevWave.monsters, k);
      reloadsNeeded <= timeGap
  }
  
  function CalculateReloadsNeeded(monsters: nat, k: nat): nat
      requires k > 0
  {
      if monsters <= k then 0
      else (monsters - 1) / k
  }
  
  function CalculateMinimumBullets(waves: seq<Wave>, k: nat): nat
      requires k > 0
      requires ValidWaves(waves)
      requires CanSolveAllWaves(waves, k)
      ensures |waves| > 0 ==> CalculateMinimumBullets(waves, k) > 0
  {
      CalculateMinimumBulletsHelper(waves, k, 0, k)
  }

vc-helpers: |-
  function CalculateMinimumBulletsHelper(waves: seq<Wave>, k: nat, waveIndex: nat, currentAmmo: nat): nat
      requires k > 0
      requires currentAmmo <= k
      requires ValidWaves(waves)
      decreases |waves| - waveIndex
      ensures |waves| > waveIndex ==> CalculateMinimumBulletsHelper(waves, k, waveIndex, currentAmmo) > 0
  {
      if waveIndex >= |waves| then 0
      else
          var wave := waves[waveIndex];
          var monstersToKill := wave.monsters;
          var bulletsUsed := CalculateBulletsForWave(monstersToKill, k, currentAmmo);
          var remainingAmmo := CalculateRemainingAmmo(monstersToKill, k, currentAmmo);
          bulletsUsed + CalculateMinimumBulletsHelper(waves, k, waveIndex + 1, remainingAmmo)
  }
  
  function CalculateBulletsForWave(monsters: nat, k: nat, currentAmmo: nat): nat
      requires k > 0
      requires currentAmmo <= k
      ensures monsters > 0 ==> CalculateBulletsForWave(monsters, k, currentAmmo) > 0
  {
      if monsters <= currentAmmo then monsters
      else 
          var additionalMonstersAfterCurrentAmmo := monsters - currentAmmo;
          var reloadsNeeded := (additionalMonstersAfterCurrentAmmo + k - 1) / k;
          currentAmmo + reloadsNeeded * k
  }
  
  function CalculateRemainingAmmo(monsters: nat, k: nat, currentAmmo: nat): nat
      requires k > 0
      requires currentAmmo <= k
      ensures CalculateRemainingAmmo(monsters, k, currentAmmo) <= k
  {
      if monsters <= currentAmmo then currentAmmo - monsters
      else 
          var additionalMonstersAfterCurrentAmmo := monsters - currentAmmo;
          var bulletsUsedInLastMagazine := additionalMonstersAfterCurrentAmmo % k;
          if bulletsUsedInLastMagazine == 0 then 0
          else k - bulletsUsedInLastMagazine
  }

vc-spec: |-
  method SolveMonsterWaves(waves: seq<Wave>, k: nat) returns (result: int)
      requires ValidWaves(waves)
      requires k > 0
      ensures result == -1 <==> !CanSolveAllWaves(waves, k)
      ensures result >= 0 <==> CanSolveAllWaves(waves, k)
      ensures CanSolveAllWaves(waves, k) ==> result == CalculateMinimumBullets(waves, k)

vc-code: |-
  {
      if !CanSolveAllWaves(waves, k) {
          result := -1;
      } else {
          result := CalculateMinimumBullets(waves, k);
      }
  }

vc-postamble: |-

