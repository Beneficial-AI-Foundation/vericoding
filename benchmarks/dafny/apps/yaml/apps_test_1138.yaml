vc-description: |-
  Given a string of movement directions ('L', 'R', 'U', 'D'), determine the minimum number 
  of character changes needed so that following the directions returns to the starting position.
  Return -1 if impossible (when string length is odd).

vc-preamble: |-
  predicate ValidInput(s: string) {
      forall i :: 0 <= i < |s| ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'
  }
  
  function abs(x: int): int
      ensures abs(x) >= 0
      ensures abs(x) == x || abs(x) == -x
  {
      if x >= 0 then x else -x
  }
  
  function countChar(s: string, c: char): int
      requires 0 <= |s|
      ensures 0 <= countChar(s, c) <= |s|
      ensures countChar(s, c) == countCharHelper(s, c, 0, 0)
  {
      countCharHelper(s, c, 0, 0)
  }
  
  function countCharHelper(s: string, c: char, index: int, count: int): int
      requires 0 <= index <= |s|
      requires count >= 0
      requires count + (|s| - index) >= 0
      decreases |s| - index
      ensures countCharHelper(s, c, index, count) >= count
      ensures countCharHelper(s, c, index, count) <= count + (|s| - index)
  {
      if index == |s| then count
      else if s[index] == c then countCharHelper(s, c, index + 1, count + 1)
      else countCharHelper(s, c, index + 1, count)
  }
  
  function countCharFromIndex(s: string, c: char, index: int): int
      requires 0 <= index <= |s|
      ensures 0 <= countCharFromIndex(s, c, index) <= |s| - index
      decreases |s| - index
  {
      if index == |s| then 0
      else if s[index] == c then 1 + countCharFromIndex(s, c, index + 1)
      else countCharFromIndex(s, c, index + 1)
  }
  
  predicate CorrectResult(s: string, result: int) {
      (|s| % 2 != 0 ==> result == -1) &&
      (|s| % 2 == 0 ==> result >= 0) &&
      (|s| % 2 == 0 ==> result <= |s| / 2) &&
      (|s| % 2 == 0 ==> result == (abs(countChar(s, 'L') - countChar(s, 'R')) + abs(countChar(s, 'U') - countChar(s, 'D'))) / 2)
  }

vc-helpers: |-
  lemma countCharEquivalence(s: string, c: char)
      ensures countChar(s, c) == countCharFromIndex(s, c, 0)
  {
      countCharEquivalenceHelper(s, c, 0, 0);
  }
  
  lemma countCharEquivalenceHelper(s: string, c: char, index: int, count: int)
      requires 0 <= index <= |s|
      requires count >= 0
      requires count == countCharFromIndex(s, c, 0) - countCharFromIndex(s, c, index)
      ensures countCharHelper(s, c, index, count) == countCharFromIndex(s, c, 0)
      decreases |s| - index
  {
      if index == |s| {
          // base case
      } else if s[index] == c {
          countCharEquivalenceHelper(s, c, index + 1, count + 1);
      } else {
          countCharEquivalenceHelper(s, c, index + 1, count);
      }
  }
  
  lemma sumOfCountsLemma(s: string, c1: char, c2: char, c3: char, c4: char)
      requires c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4
      requires forall i :: 0 <= i < |s| ==> s[i] == c1 || s[i] == c2 || s[i] == c3 || s[i] == c4
      ensures countChar(s, c1) + countChar(s, c2) + countChar(s, c3) + countChar(s, c4) == |s|
  {
      countCharEquivalence(s, c1);
      countCharEquivalence(s, c2);
      countCharEquivalence(s, c3);
      countCharEquivalence(s, c4);
      sumOfCountsHelper(s, c1, c2, c3, c4, 0);
  }
  
  lemma sumOfCountsHelper(s: string, c1: char, c2: char, c3: char, c4: char, index: int)
      requires c1 != c2 && c1 != c3 && c1 != c4 && c2 != c3 && c2 != c4 && c3 != c4
      requires forall i :: 0 <= i < |s| ==> s[i] == c1 || s[i] == c2 || s[i] == c3 || s[i] == c4
      requires 0 <= index <= |s|
      ensures countCharFromIndex(s, c1, index) + countCharFromIndex(s, c2, index) + countCharFromIndex(s, c3, index) + countCharFromIndex(s, c4, index) == |s| - index
      decreases |s| - index
  {
      if index == |s| {
          // base case
      } else {
          sumOfCountsHelper(s, c1, c2, c3, c4, index + 1);
      }
  }

vc-spec: |-
  method solve(s: string) returns (result: int)
      requires ValidInput(s)
      ensures CorrectResult(s, result)

vc-code: |-
  {
      if |s| % 2 != 0 {
          result := -1;
          return;
      }
  
      var li := countChar(s, 'L');
      var ri := countChar(s, 'R');
      var ui := countChar(s, 'U');
      var di := countChar(s, 'D');
  
      var horizontal_diff := if li >= ri then li - ri else ri - li;
      var vertical_diff := if ui >= di then ui - di else di - ui;
  
      // Help Dafny prove that the sum of all character counts equals |s|
      sumOfCountsLemma(s, 'L', 'R', 'U', 'D');
      assert li + ri + ui + di == |s|;
  
      // Help Dafny prove the bound
      assert horizontal_diff == abs(li - ri);
      assert vertical_diff == abs(ui - di);
      assert horizontal_diff <= li + ri;
      assert vertical_diff <= ui + di;
      assert horizontal_diff + vertical_diff <= li + ri + ui + di;
      assert horizontal_diff + vertical_diff <= |s|;
  
      result := (horizontal_diff + vertical_diff) / 2;
  }

vc-postamble: |-
