vc-description: |-
  Given n non-intersecting integer segments, find the minimum number of moves
  to make the total count of integers covered by all segments divisible by k.
  Each move extends any segment by 1 unit either left or right.

vc-preamble: |-
  ghost predicate ValidInputFormat(s: string) {
      var lines := SplitLines(s);
      |lines| >= 1 &&
      exists n: nat, k: nat :: 
          ParsesAsIntegers(lines[0], n as int, k as int) && n > 0 && k > 0 && |lines| >= n + 1 &&
          (forall i :: 1 <= i <= n && i < |lines| ==> 
              exists a: int, b: int :: ParsesAsIntegers(lines[i], a, b))
  }
  
  ghost predicate ParsedCorrectly(input: string, n: nat, k: nat, segments: seq<(int, int)>) {
      var lines := SplitLines(input);
      |lines| >= n + 1 && |segments| == n &&
      ParsesAsIntegers(lines[0], n as int, k as int) &&
      (forall i :: 0 <= i < n && i + 1 < |lines| ==> 
          ParsesAsIntegers(lines[i + 1], segments[i].0, segments[i].1))
  }
  
  predicate IsValidOutput(s: string) {
      |s| > 0 && s[|s| - 1] == '\n' && 
      (forall i :: 0 <= i < |s| - 1 ==> s[i] != '\n') &&
      IsNumericOutput(s[..|s| - 1])
  }
  
  function MinMovesToDivisible(segments: seq<(int, int)>, k: nat): nat
      requires k > 0
      ensures MinMovesToDivisible(segments, k) < k
  {
      var totalCoverage := TotalCoverage(segments);
      var remainder := totalCoverage % k;
      if remainder == 0 then 0 else k - remainder
  }
  
  function TotalCoverage(segments: seq<(int, int)>): nat {
      if |segments| == 0 then 0
      else SegmentLength(segments[0]) + TotalCoverage(segments[1..])
  }
  
  function SegmentLength(segment: (int, int)): nat
      ensures SegmentLength(segment) >= 1
  {
      var maxVal := MaxInt(segment.0, segment.1);
      var minVal := MinInt(segment.0, segment.1);
      if maxVal >= minVal then (maxVal - minVal + 1) as nat else 1
  }

vc-helpers: |-
  ghost predicate ParsesAsIntegers(line: string, a: int, b: int) {
      var parts := SplitWhitespace(line);
      |parts| >= 2 && StringToInt(parts[0]) == a && StringToInt(parts[1]) == b
  }
  
  predicate ContainsNewline(s: string) {
      exists i :: 0 <= i < |s| && s[i] == '\n'
  }
  
  predicate IsNumericOutput(s: string) {
      |s| > 0 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')
  }
  
  function MaxInt(a: int, b: int): int {
      if a >= b then a else b
  }
  
  function MinInt(a: int, b: int): int {
      if a <= b then a else b
  }
  
  function SplitLines(s: string): seq<string> {
      SplitByChar(s, '\n')
  }
  
  function SplitWhitespace(s: string): seq<string> {
      SplitByChar(s, ' ')
  }
  
  function SplitByChar(s: string, delimiter: char): seq<string> {
      if |s| == 0 then [""]
      else if s[0] == delimiter then
          [""] + SplitByChar(s[1..], delimiter)
      else
          var rest := SplitByChar(s[1..], delimiter);
          if |rest| == 0 then [s[0..1]]
          else [s[0..1] + rest[0]] + rest[1..]
  }
  
  function StringToInt(s: string): int {
      if |s| == 0 then 0
      else if s[0] == '-' && |s| > 1 then -(StringToNat(s[1..]) as int)
      else StringToNat(s) as int
  }
  
  function StringToNat(s: string): nat {
      if |s| == 0 then 0
      else if |s| == 1 && '0' <= s[0] <= '9' then (s[0] as int) - ('0' as int)
      else if |s| > 1 && '0' <= s[0] <= '9' then
          ((s[0] as int) - ('0' as int)) * Pow10(|s| - 1) + StringToNat(s[1..])
      else 0
  }
  
  function Pow10(n: nat): nat {
      if n == 0 then 1 else 10 * Pow10(n - 1)
  }
  
  function IntToString(n: int): string
      requires n >= 0
      ensures |IntToString(n)| > 0
      ensures IsNumericOutput(IntToString(n))
  {
      NatToString(n as nat)
  }
  
  function NatToString(n: nat): string
      ensures |NatToString(n)| > 0
      ensures IsNumericOutput(NatToString(n))
  {
      if n == 0 then "0"
      else if n < 10 then [('0' as int + n) as char]
      else NatToString(n / 10) + NatToString(n % 10)
  }

vc-spec: |-
  method solve(stdin_input: string) returns (result: string)
      requires |stdin_input| > 0
      requires stdin_input[|stdin_input| - 1] == '\n' || !ContainsNewline(stdin_input)
      ensures |result| == 0 || result[|result| - 1] == '\n'
      ensures ValidInputFormat(stdin_input) ==> 
          exists n: nat, k: nat, segments: seq<(int, int)> ::
              n > 0 && k > 0 && |segments| == n &&
              ParsedCorrectly(stdin_input, n, k, segments) &&
              result == IntToString(MinMovesToDivisible(segments, k)) + "\n"
      ensures ValidInputFormat(stdin_input) ==> IsValidOutput(result)
      ensures !ValidInputFormat(stdin_input) ==> 
          (result == "" || (|result| > 0 && result[|result| - 1] == '\n'))

vc-code: |-
  {
      var lines := SplitLines(stdin_input);
      if |lines| == 0 {
          result := "";
          return;
      }
  
      var firstLine := SplitWhitespace(lines[0]);
      if |firstLine| < 2 {
          result := "";
          return;
      }
  
      var N := StringToInt(firstLine[0]);
      var k := StringToInt(firstLine[1]);
  
      if N <= 0 || k <= 0 || |lines| < N + 1 {
          result := "";
          return;
      }
  
      var segments: seq<(int, int)> := [];
      var i := 1;
  
      while i <= N && i < |lines|
          decreases N - i
          invariant 1 <= i <= N + 1
          invariant |segments| == i - 1
          invariant i <= |lines|
          invariant forall j :: 0 <= j < |segments| ==> 
              j + 1 < |lines| && ParsesAsIntegers(lines[j + 1], segments[j].0, segments[j].1)
      {
          var segmentLine := SplitWhitespace(lines[i]);
          if |segmentLine| >= 2 {
              var A := StringToInt(segmentLine[0]);
              var B := StringToInt(segmentLine[1]);
              segments := segments + [(A, B)];
          } else {
              result := "";
              return;
          }
          i := i + 1;
      }
  
      var answer := MinMovesToDivisible(segments, k as nat);
      result := IntToString(answer) + "\n";
  
      if ValidInputFormat(stdin_input) {
          assert N > 0 && k > 0;
          assert |segments| == N;
          assert ParsedCorrectly(stdin_input, N as nat, k as nat, segments);
      }
  }

vc-postamble: |-

