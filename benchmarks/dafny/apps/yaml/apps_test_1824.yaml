vc-description: |-
  Given three lists of compilation errors (initial with n errors, second with n-1 errors, third with n-2 errors),
  find the two error values that were corrected. The compiler shows errors in different order each time,
  but the actual error values remain the same.

vc-preamble: |-
  predicate ValidInput(input: string)
  {
      var lines := SplitByNewline(input);
      |lines| >= 4 && 
      IsValidInteger(lines[0]) &&
      StringToInt(lines[0]) >= 3 &&
      |SplitBySpace(lines[1])| == StringToInt(lines[0]) &&
      |SplitBySpace(lines[2])| == StringToInt(lines[0]) - 1 &&
      |SplitBySpace(lines[3])| == StringToInt(lines[0]) - 2 &&
      (forall i :: 0 <= i < |SplitBySpace(lines[1])| ==> IsValidInteger(SplitBySpace(lines[1])[i])) &&
      (forall i :: 0 <= i < |SplitBySpace(lines[2])| ==> IsValidInteger(SplitBySpace(lines[2])[i])) &&
      (forall i :: 0 <= i < |SplitBySpace(lines[3])| ==> IsValidInteger(SplitBySpace(lines[3])[i]))
  }
  
  predicate IsValidInteger(s: string)
  {
      |s| > 0 && (s[0] == '-' ==> |s| > 1) && 
      (forall i :: (if s[0] == '-' then 1 else 0) <= i < |s| ==> '0' <= s[i] <= '9')
  }
  
  function GetFirstSum(input: string): int
      requires ValidInput(input)
  {
      var lines := SplitByNewline(input);
      var firstLine := SplitBySpace(lines[1]);
      SumSequence(firstLine)
  }
  
  function GetSecondSum(input: string): int
      requires ValidInput(input)
  {
      var lines := SplitByNewline(input);
      var secondLine := SplitBySpace(lines[2]);
      SumSequence(secondLine)
  }
  
  function GetThirdSum(input: string): int
      requires ValidInput(input)
  {
      var lines := SplitByNewline(input);
      var thirdLine := SplitBySpace(lines[3]);
      SumSequence(thirdLine)
  }
  
  function SumSequence(numbers: seq<string>): int
      requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])
  {
      if |numbers| == 0 then 0
      else StringToInt(numbers[0]) + SumSequence(numbers[1..])
  }
  
  function SplitByNewline(s: string): seq<string>
  {
      if |s| == 0 then []
      else if s[0] == '\n' then SplitByNewline(s[1..])
      else 
          var rest := SplitByNewline(s[1..]);
          if |rest| == 0 then [s]
          else [s[0..1] + rest[0]] + rest[1..]
  }
  
  function SplitBySpace(s: string): seq<string>
  {
      SplitByChar(s, ' ')
  }
  
  function SplitByChar(s: string, delimiter: char): seq<string>
  {
      if |s| == 0 then []
      else
          var pos := FindChar(s, delimiter, 0);
          if pos == -1 then [s]
          else if pos == 0 then SplitByChar(s[1..], delimiter)
          else [s[0..pos]] + SplitByChar(s[pos+1..], delimiter)
  }
  
  function FindChar(s: string, c: char, start: int): int
      requires 0 <= start <= |s|
      ensures -1 <= FindChar(s, c, start) < |s|
      decreases |s| - start
  {
      if start >= |s| then -1
      else if s[start] == c then start
      else FindChar(s, c, start + 1)
  }
  
  function StringToInt(s: string): int
  {
      if |s| == 0 then 0
      else if s[0] == '-' then -StringToIntHelper(s[1..], 0)
      else StringToIntHelper(s, 0)
  }
  
  function StringToIntHelper(s: string, acc: int): int
  {
      if |s| == 0 then acc
      else if '0' <= s[0] <= '9' then
          StringToIntHelper(s[1..], acc * 10 + (s[0] as int - '0' as int))
      else acc
  }
  
  function IntToString(n: int): string
  {
      if n == 0 then "0"
      else if n < 0 then "-" + IntToStringHelper(-n)
      else IntToStringHelper(n)
  }
  
  function IntToStringHelper(n: int): string
      requires n >= 0
  {
      if n == 0 then ""
      else IntToStringHelper(n / 10) + [((n % 10) + '0' as int) as char]
  }

vc-helpers: |-
  lemma SumSequenceAddLemma(prefix: seq<string>, elem: string)
      requires forall j :: 0 <= j < |prefix| ==> IsValidInteger(prefix[j])
      requires IsValidInteger(elem)
      ensures SumSequence(prefix + [elem]) == SumSequence(prefix) + StringToInt(elem)
  {
      if |prefix| == 0 {
          assert prefix + [elem] == [elem];
          assert SumSequence([elem]) == StringToInt(elem) + SumSequence([]);
          assert SumSequence([]) == 0;
      } else {
          assert prefix == [prefix[0]] + prefix[1..];
          assert prefix + [elem] == [prefix[0]] + (prefix[1..] + [elem]);
          SumSequenceAddLemma(prefix[1..], elem);
          assert SumSequence(prefix[1..] + [elem]) == SumSequence(prefix[1..]) + StringToInt(elem);
      }
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires |input| > 0
      requires ValidInput(input)
      ensures result == IntToString(GetFirstSum(input) - GetSecondSum(input)) + "\n" + IntToString(GetSecondSum(input) - GetThirdSum(input)) + "\n"

vc-code: |-
  {
      var lines := SplitByNewline(input);
      var n := StringToInt(lines[0]);
  
      var firstLine := SplitBySpace(lines[1]);
      var secondLine := SplitBySpace(lines[2]);
      var thirdLine := SplitBySpace(lines[3]);
  
      var sum1 := 0;
      var sum2 := 0;
      var sum3 := 0;
  
      var i := 0;
      while i < |firstLine|
          invariant 0 <= i <= |firstLine|
          invariant forall j :: 0 <= j < |firstLine| ==> IsValidInteger(firstLine[j])
          invariant sum1 == SumSequence(firstLine[0..i])
      {
          SumSequenceAddLemma(firstLine[0..i], firstLine[i]);
          assert firstLine[0..i] + [firstLine[i]] == firstLine[0..i+1];
          var tmpCall1 := StringToInt(firstLine[i]);
          sum1 := sum1 + tmpCall1;
          assert sum1 == SumSequence(firstLine[0..i]) + StringToInt(firstLine[i]);
          assert sum1 == SumSequence(firstLine[0..i] + [firstLine[i]]);
          assert sum1 == SumSequence(firstLine[0..i+1]);
          i := i + 1;
      }
      assert firstLine[0..i] == firstLine;
      assert sum1 == SumSequence(firstLine);
  
      i := 0;
      while i < |secondLine|
          invariant 0 <= i <= |secondLine|
          invariant forall j :: 0 <= j < |secondLine| ==> IsValidInteger(secondLine[j])
          invariant sum2 == SumSequence(secondLine[0..i])
      {
          SumSequenceAddLemma(secondLine[0..i], secondLine[i]);
          assert secondLine[0..i] + [secondLine[i]] == secondLine[0..i+1];
          var tmpCall2 := StringToInt(secondLine[i]);
          sum2 := sum2 + tmpCall2;
          assert sum2 == SumSequence(secondLine[0..i]) + StringToInt(secondLine[i]);
          assert sum2 == SumSequence(secondLine[0..i] + [secondLine[i]]);
          assert sum2 == SumSequence(secondLine[0..i+1]);
          i := i + 1;
      }
      assert secondLine[0..i] == secondLine;
      assert sum2 == SumSequence(secondLine);
  
      i := 0;
      while i < |thirdLine|
          invariant 0 <= i <= |thirdLine|
          invariant forall j :: 0 <= j < |thirdLine| ==> IsValidInteger(thirdLine[j])
          invariant sum3 == SumSequence(thirdLine[0..i])
      {
          SumSequenceAddLemma(thirdLine[0..i], thirdLine[i]);
          assert thirdLine[0..i] + [thirdLine[i]] == thirdLine[0..i+1];
          var tmpCall3 := StringToInt(thirdLine[i]);
          sum3 := sum3 + tmpCall3;
          assert sum3 == SumSequence(thirdLine[0..i]) + StringToInt(thirdLine[i]);
          assert sum3 == SumSequence(thirdLine[0..i] + [thirdLine[i]]);
          assert sum3 == SumSequence(thirdLine[0..i+1]);
          i := i + 1;
      }
      assert thirdLine[0..i] == thirdLine;
      assert sum3 == SumSequence(thirdLine);
  
      var firstCorrected := sum1 - sum2;
      var secondCorrected := sum2 - sum3;
  
      result := IntToString(firstCorrected) + "\n" + IntToString(secondCorrected) + "\n";
  }

vc-postamble: |-

