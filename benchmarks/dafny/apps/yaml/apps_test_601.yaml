vc-description: |-
  Given two people with carrying capacities p and f, and a shop containing cnt_s swords
  (each weighing s units) and cnt_w war axes (each weighing w units), find the maximum
  total number of items both people can carry. The input contains multiple test cases.

vc-preamble: |-
  predicate validInput(input: string)
  {
      |input| > 0 && 
      var lines := splitFunc(input, '\n');
      |lines| >= 1 &&
      parseIntFunc(lines[0]) >= 0 &&
      |lines| >= 1 + 3 * parseIntFunc(lines[0])
  }
  
  function processTestCases(input: string): seq<int>
      requires validInput(input)
  {
      var lines := splitFunc(input, '\n');
      var t := parseIntFunc(lines[0]);
      processTestCasesHelper(input, lines, 1, 0, t, [])
  }
  
  function formatOutput(results: seq<int>): string
  {
      formatOutputHelper(results, 0, "")
  }

vc-helpers: |-
  function splitFunc(s: string, delimiter: char): seq<string>
  {
      if |s| == 0 then [""]
      else splitHelper(s, delimiter, 0, "", [])
  }
  
  function splitHelper(s: string, delimiter: char, i: int, current: string, acc: seq<string>): seq<string>
      requires 0 <= i <= |s|
      decreases |s| - i
  {
      if i == |s| then
          if |current| > 0 then acc + [current] else acc
      else if s[i] == delimiter then
          splitHelper(s, delimiter, i + 1, "", acc + [current])
      else
          splitHelper(s, delimiter, i + 1, current + [s[i]], acc)
  }
  
  function parseIntFunc(s: string): int
  {
      if |s| == 0 then 0
      else if s[0] == '-' then -parseIntHelper(s, 1, 0)
      else parseIntHelper(s, 0, 0)
  }
  
  function parseIntHelper(s: string, i: int, acc: int): int
      requires 0 <= i <= |s|
      decreases |s| - i
  {
      if i == |s| then acc
      else if '0' <= s[i] <= '9' then
          parseIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))
      else
          parseIntHelper(s, i + 1, acc)
  }
  
  function parseIntsFunc(s: string): seq<int>
  {
      var parts := splitFunc(s, ' ');
      parseIntsHelper(parts, 0, [])
  }
  
  function parseIntsHelper(parts: seq<string>, i: int, acc: seq<int>): seq<int>
      requires 0 <= i <= |parts|
      decreases |parts| - i
  {
      if i == |parts| then acc
      else if |parts[i]| > 0 then
          parseIntsHelper(parts, i + 1, acc + [parseIntFunc(parts[i])])
      else
          parseIntsHelper(parts, i + 1, acc)
  }
  
  function formatOutputHelper(results: seq<int>, i: int, acc: string): string
      requires 0 <= i <= |results|
      decreases |results| - i
  {
      if i == |results| then acc
      else 
          var numStr := intToString(results[i]);
          var newAcc := if i == 0 then numStr else acc + "\n" + numStr;
          formatOutputHelper(results, i + 1, newAcc)
  }
  
  function intToString(n: int): string
  {
      if n == 0 then "0"
      else if n < 0 then "-" + intToStringHelper(-n, "")
      else intToStringHelper(n, "")
  }
  
  function intToStringHelper(n: int, acc: string): string
      requires n >= 0
      decreases n
  {
      if n == 0 then acc
      else intToStringHelper(n / 10, [('0' as int + (n % 10)) as char] + acc)
  }
  
  function processTestCasesHelper(input: string, lines: seq<string>, lineIndex: int, testCase: int, totalCases: int, acc: seq<int>): seq<int>
      requires validInput(input)
      requires lines == splitFunc(input, '\n')
      requires totalCases >= 0
      requires 0 <= testCase <= totalCases
      requires 0 <= lineIndex <= |lines|
      requires |acc| == testCase
      decreases totalCases - testCase
  {
      if testCase >= totalCases || lineIndex + 2 >= |lines| then acc
      else
          var pf := parseIntsFunc(lines[lineIndex]);
          if |pf| < 2 then acc else
          var p := pf[0]; var f := pf[1];
  
          var cscw := parseIntsFunc(lines[lineIndex + 1]);
          if |cscw| < 2 then acc else
          var cs := cscw[0]; var cw := cscw[1];
  
          var sw := parseIntsFunc(lines[lineIndex + 2]);
          if |sw| < 2 then acc else
          var s := sw[0]; var w := sw[1];
  
          var (finalS, finalW, finalCs, finalCw) := 
              if s > w then (w, s, cw, cs) else (s, w, cs, cw);
  
          if finalS > 0 && finalW > 0 && finalCs >= 0 && finalCw >= 0 && p >= 0 && f >= 0 then
              var best := computeOptimal(p, f, finalCs, finalCw, finalS, finalW);
              processTestCasesHelper(input, lines, lineIndex + 3, testCase + 1, totalCases, acc + [best])
          else
              processTestCasesHelper(input, lines, lineIndex + 3, testCase + 1, totalCases, acc + [0])
  }
  
  function computeOptimal(p: int, f: int, cs: int, cw: int, s: int, w: int): int
      requires s > 0 && w > 0 && cs >= 0 && cw >= 0 && p >= 0 && f >= 0
  {
      computeOptimalHelper(p, f, cs, cw, s, w, 0, 0)
  }
  
  function computeOptimalHelper(p: int, f: int, cs: int, cw: int, s: int, w: int, i: int, best: int): int
      requires s > 0 && w > 0 && cs >= 0 && cw >= 0 && p >= 0 && f >= 0
      requires 0 <= i && best >= 0
      decreases cs + 1 - i
  {
      if i > cs then best
      else
          var newBest := 
              if s * i <= p then
                  var war_me := min((p - s*i)/w, cw);
                  var tb := i + war_me;
                  var sword_him := min(cs - i, f/s);
                  var tb2 := tb + sword_him;
                  var war_him := min((f - s*sword_him)/w, cw - war_me);
                  var tb3 := tb2 + war_him;
                  max(best, tb3)
              else best;
          computeOptimalHelper(p, f, cs, cw, s, w, i + 1, newBest)
  }
  
  function min(a: int, b: int): int
  {
      if a <= b then a else b
  }
  
  function max(a: int, b: int): int  
  {
      if a >= b then a else b
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires |input| > 0
      requires validInput(input)
      ensures |result| >= 0
      ensures result == formatOutput(processTestCases(input))

vc-code: |-
  {
      return formatOutput(processTestCases(input));
  }

vc-postamble: |-
