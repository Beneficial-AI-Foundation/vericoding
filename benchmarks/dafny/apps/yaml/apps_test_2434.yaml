vc-description: |-
  Given two integers n and m where m < n, determine if it's possible to select m vertices 
  from a regular n-gon such that these m vertices form a regular m-gon with the same center.
  The solution is "YES" if n is divisible by m, "NO" otherwise.

vc-preamble: |-
  predicate ValidInputFormat(input: string)
  {
      var lines := SplitByNewline(input);
      |lines| >= 1 && 
      IsValidInt(lines[0]) &&
      var t := ParseInt(lines[0]);
      t >= 0 && t + 1 <= |lines| &&
      forall i :: 1 <= i <= t ==> IsValidTwoIntLine(lines[i])
  }
  
  predicate IsValidInt(s: string)
  {
      |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
  }
  
  predicate IsValidTwoIntLine(s: string)
  {
      var parts := SplitBySpace(s);
      |parts| >= 2 && IsValidInt(parts[0]) && IsValidInt(parts[1])
  }
  
  predicate ValidOutputFormat(output: string, input: string)
  {
      var inputLines := SplitByNewline(input);
      if |inputLines| == 0 then output == ""
      else
          var t := ParseInt(inputLines[0]);
          var outputLines := SplitByNewline(output);
          |outputLines| == t &&
          forall i :: 0 <= i < t ==> (outputLines[i] == "YES" || outputLines[i] == "NO")
  }
  
  predicate CorrectDivisibilityResults(input: string, output: string)
  {
      var inputLines := SplitByNewline(input);
      if |inputLines| == 0 then output == ""
      else
          var t := ParseInt(inputLines[0]);
          var outputLines := SplitByNewline(output);
          |outputLines| == t &&
          forall i :: 0 <= i < t && i + 1 < |inputLines| ==> 
              var parts := SplitBySpace(inputLines[i + 1]);
              |parts| >= 2 ==>
                  var x := ParseInt(parts[0]);
                  var y := ParseInt(parts[1]);
                  y != 0 ==>
                      (outputLines[i] == "YES" <==> x % y == 0)
  }
  
  function SplitByNewline(s: string): seq<string>
  {
      if |s| == 0 then []
      else if s[0] == '\n' then [""] + SplitByNewline(s[1..])
      else 
          var rest := SplitByNewline(s[1..]);
          if |rest| == 0 then [s]
          else [s[0..1] + rest[0]] + rest[1..]
  }
  
  function SplitBySpace(s: string): seq<string>
  {
      if |s| == 0 then []
      else if s[0] == ' ' then [""] + SplitBySpace(s[1..])
      else 
          var rest := SplitBySpace(s[1..]);
          if |rest| == 0 then [s]
          else [s[0..1] + rest[0]] + rest[1..]
  }
  
  function ParseInt(s: string): int
  {
      if |s| == 0 then 0
      else if |s| == 1 then
          if '0' <= s[0] <= '9' then s[0] as int - '0' as int else 0
      else
          if '0' <= s[0] <= '9' then
              (s[0] as int - '0' as int) * Pow10(|s| - 1) + ParseInt(s[1..])
          else 0
  }
  
  function Pow10(n: int): int
      requires n >= 0
  {
      if n == 0 then 1 else 10 * Pow10(n - 1)
  }

vc-helpers: |-

vc-spec: |-
  method solve(input: string) returns (output: string)
      requires |input| > 0
      requires ValidInputFormat(input)
      ensures forall i :: 0 <= i < |output| ==> output[i] in "YESNO\n"
      ensures ValidOutputFormat(output, input)
      ensures CorrectDivisibilityResults(input, output)

vc-code: |-
  {
      var lines := SplitByNewline(input);
      if |lines| == 0 {
          return "";
      }
  
      var t := ParseInt(lines[0]);
      var result := "";
  
      var i := 0;
      while i < t && i + 1 < |lines|
          invariant 0 <= i <= t
          invariant i + 1 <= |lines|
          invariant forall j :: 0 <= j < |result| ==> result[j] in "YESNO\n"
          invariant if i == 0 then result == ""
                    else exists prefix :: result == prefix + "\n" && 
                         forall j :: 0 <= j < |prefix| ==> prefix[j] in "YESNO"
          invariant var resultWithNewline := if i == 0 then "" else result + "\n";
                    var resultLines := SplitByNewline(resultWithNewline);
                    if i == 0 then |resultLines| == 0
                    else |resultLines| == i + 1 && |resultLines[i]| == 0 &&
                         forall k :: 0 <= k < i ==> (resultLines[k] == "YES" || resultLines[k] == "NO")
          invariant forall k :: 0 <= k < i && k + 1 < |lines| ==> 
                      var parts := SplitBySpace(lines[k + 1]);
                      |parts| >= 2 ==>
                          var x := ParseInt(parts[0]);
                          var y := ParseInt(parts[1]);
                          y != 0 ==>
                              var resultWithNewline := if i == 0 then "" else result + "\n";
                              var resultLines := SplitByNewline(resultWithNewline);
                              i > 0 ==> (resultLines[k] == "YES" <==> x % y == 0)
      {
          var tmpCall1 := SplitBySpace(lines[i + 1]);
          var parts := tmpCall1;
          if |parts| >= 2 {
              var n := ParseInt(parts[0]);
              var m := ParseInt(parts[1]);
  
              if i > 0 {
                  result := result + "\n";
              }
  
              if m != 0 && n % m == 0 {
                  result := result + "YES";
              } else {
                  result := result + "NO";
              }
          }
          i := i + 1;
      }
  
      return result;
  }

vc-postamble: |-

