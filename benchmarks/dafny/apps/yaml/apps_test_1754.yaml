vc-description: |-
  Given n students across m schools, where each student has a unique power level,
  the Technogoblet selects the strongest student from each school. We want k specific 
  students (Chosen Ones) to be selected. We can create new schools and reassign students.
  Find the minimum number of new schools needed so all k Chosen Ones get selected.

vc-preamble: |-
  predicate IsStrongestInSchool(student_idx: int, powers: seq<int>, schools: seq<int>)
    requires 0 <= student_idx < |powers| && |powers| == |schools|
  {
    forall j :: 0 <= j < |powers| && schools[j] == schools[student_idx] ==> powers[j] <= powers[student_idx]
  }

vc-helpers: |-

vc-spec: |-
  method solve(n: int, m: int, k: int, powers: seq<int>, schools: seq<int>, chosen: seq<int>) returns (result: int)
    requires n >= 1 && m >= 1 && k >= 1 && k <= n && m <= n
    requires |powers| == n && |schools| == n && |chosen| == k
    requires forall i :: 0 <= i < n ==> 1 <= schools[i] <= m
    requires forall i :: 0 <= i < k ==> 1 <= chosen[i] <= n
    requires forall i, j :: 0 <= i < k && 0 <= j < k && i != j ==> chosen[i] != chosen[j]
    requires forall i, j :: 0 <= i < n && 0 <= j < n && i != j ==> powers[i] != powers[j]
    requires forall s :: 1 <= s <= m ==> exists i :: 0 <= i < n && schools[i] == s
    requires forall i :: 0 <= i < n ==> 1 <= powers[i] <= n
    ensures result >= 0 && result <= k
    ensures result == |set i | 0 <= i < k && !IsStrongestInSchool(chosen[i]-1, powers, schools)|

vc-code: |-
  {
    var sch := seq(m, i => 0);
  
    var i := 0;
    while i < n
      invariant 0 <= i <= n
      invariant |sch| == m
      invariant forall j :: 0 <= j < i ==> 
        var school_idx := schools[j] - 1;
        0 <= school_idx < m && powers[j] <= sch[school_idx]
      invariant forall s :: 0 <= s < m ==> 
        sch[s] == 0 || (exists j :: 0 <= j < i && schools[j] - 1 == s && powers[j] == sch[s])
      invariant forall s :: 1 <= s <= m ==> 
        (exists j :: 0 <= j < i && schools[j] == s) ==> sch[s-1] > 0
      invariant forall s :: 1 <= s <= m && i == n ==> sch[s-1] > 0
    {
      var school_idx := schools[i] - 1;
      if powers[i] > sch[school_idx] {
        sch := sch[school_idx := powers[i]];
      }
      i := i + 1;
    }
  
    assert forall j :: 0 <= j < n ==> 
      var school_idx := schools[j] - 1;
      0 <= school_idx < m && powers[j] <= sch[school_idx];
  
    assert forall s :: 1 <= s <= m ==> sch[s-1] > 0;
  
    result := 0;
    i := 0;
    while i < k
      invariant 0 <= i <= k
      invariant 0 <= result <= i
      invariant result == |set j | 0 <= j < i && !IsStrongestInSchool(chosen[j]-1, powers, schools)|
      invariant |sch| == m
      invariant forall j :: 0 <= j < n ==> 
        var school_idx := schools[j] - 1;
        0 <= school_idx < m && powers[j] <= sch[school_idx]
      invariant forall s :: 1 <= s <= m ==> sch[s-1] > 0
      invariant forall j :: 0 <= j < n ==> 
        (IsStrongestInSchool(j, powers, schools) <==> (powers[j] == sch[schools[j] - 1]))
    {
      var chosen_student := chosen[i] - 1;
      var chosen_school := schools[chosen_student] - 1;
  
      assert IsStrongestInSchool(chosen_student, powers, schools) <==> (powers[chosen_student] == sch[chosen_school]);
  
      if powers[chosen_student] != sch[chosen_school] {
        result := result + 1;
      }
      i := i + 1;
    }
  }

vc-postamble: |-

