vc-description: |-
  Given a target sum n and a range of coin denominations [l, r], determine if it's possible 
  to make exactly the sum n using coins with denominations between l and r (inclusive).
  You have unlimited coins of each valid denomination.

vc-preamble: |-
  predicate ValidInput(input: string)
  {
      |input| > 0
  }
  
  function CanMakeSum(n: int, l: int, r: int): bool
  {
      l > 0 && l <= r && n > 0 && n % l <= (r - l) * (n / l)
  }
  
  predicate ValidOutput(result: string)
  {
      |result| >= 0 && forall i :: 0 <= i < |result| ==> result[i] in "Yes\nNo\n "
  }
  
  predicate CorrectSolution(input: string, result: string)
  {
      var lines := SplitLines(input);
      |lines| > 0 ==> 
      (var t := ParseInt(lines[0]);
       var outputLines := SplitLines(result);
       |outputLines| >= 1 && (|outputLines| == 1 ==> outputLines[0] == "") &&
       (|outputLines| > 1 ==> outputLines[|outputLines|-1] == "") &&
       forall i :: 1 <= i <= t && i < |lines| ==>
          (var parts := SplitSpaces(lines[i]);
           |parts| >= 3 ==>
           (var n := ParseInt(parts[0]);
            var l := ParseInt(parts[1]);
            var r := ParseInt(parts[2]);
            var expectedOutput := if CanMakeSum(n, l, r) then "Yes" else "No";
            i-1 < |outputLines| && outputLines[i-1] == expectedOutput)))
  }

vc-helpers: |-
  function SplitLines(s: string): seq<string>
      decreases |s|
  {
      if |s| == 0 then []
      else 
          var idx := FindChar(s, '\n');
          if idx == -1 then [s]
          else if idx < |s| then [s[..idx]] + SplitLines(s[idx+1..])
          else [s]
  }
  
  function SplitSpaces(s: string): seq<string>
      decreases |s|
  {
      if |s| == 0 then []
      else
          var idx := FindChar(s, ' ');
          if idx == -1 then [s]
          else if idx < |s| then [s[..idx]] + SplitSpaces(s[idx+1..])
          else [s]
  }
  
  function FindChar(s: string, c: char): int
      ensures -1 <= FindChar(s, c) < |s|
  {
      FindCharHelper(s, c, 0)
  }
  
  function FindCharHelper(s: string, c: char, start: int): int
      requires 0 <= start <= |s|
      ensures -1 <= FindCharHelper(s, c, start) < |s|
      decreases |s| - start
  {
      if start >= |s| then -1
      else if start < |s| && s[start] == c then start
      else FindCharHelper(s, c, start + 1)
  }
  
  function ParseInt(s: string): int
  {
      if |s| == 0 then 0
      else ParseIntHelper(s, 0, 0)
  }
  
  function ParseIntHelper(s: string, pos: int, acc: int): int
      requires 0 <= pos <= |s|
      requires acc >= 0
      decreases |s| - pos
  {
      if pos >= |s| then acc
      else if pos < |s| && '0' <= s[pos] <= '9' then
          ParseIntHelper(s, pos + 1, acc * 10 + (s[pos] as int - '0' as int))
      else acc
  }

vc-spec: |-
  method solve(input: string) returns (result: string)
      requires ValidInput(input)
      ensures ValidOutput(result)
      ensures CorrectSolution(input, result)

vc-code: |-
  {
      var lines := SplitLines(input);
      if |lines| == 0 { return "\n"; }
  
      var t := ParseInt(lines[0]);
      if t <= 0 { return "\n"; }
  
      var output := "";
  
      var i := 1;
      while i <= t && i < |lines|
          decreases t - i + 1
          invariant 1 <= i <= t + 1
          invariant ValidOutput(output)
          invariant |output| == 0 || output[|output|-1] == '\n'
          invariant var outputLines := SplitLines(output);
                    forall k :: 1 <= k < i && k < |lines| ==>
                      (var parts := SplitSpaces(lines[k]);
                       |parts| >= 3 ==>
                       (var n := ParseInt(parts[0]);
                        var l := ParseInt(parts[1]);
                        var r := ParseInt(parts[2]);
                        var expectedOutput := if CanMakeSum(n, l, r) then "Yes" else "No";
                        k-1 < |outputLines| && outputLines[k-1] == expectedOutput))
      {
          var parts := SplitSpaces(lines[i]);
          if |parts| >= 3 {
              var n := ParseInt(parts[0]);
              var l := ParseInt(parts[1]);
              var r := ParseInt(parts[2]);
  
              if CanMakeSum(n, l, r) {
                  output := output + "Yes\n";
              } else {
                  output := output + "No\n";
              }
          }
  
          i := i + 1;
      }
  
      if output == "" {
          return "\n";
      } else {
          return output;
      }
  }

vc-postamble: |-

