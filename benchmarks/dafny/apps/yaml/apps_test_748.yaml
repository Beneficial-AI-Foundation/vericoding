vc-description: |-
  Given a sequence of n positive integers (n divisible by 3), each â‰¤ 7,
  partition into groups of 3 elements (a,b,c) where a < b < c and a|b, b|c.
  Return the partition or empty sequence if impossible.

vc-preamble: |-
  predicate ValidInput(n: int, numbers: seq<int>)
  {
      n >= 3 && n % 3 == 0 &&
      |numbers| == n &&
      forall i :: 0 <= i < |numbers| ==> 1 <= numbers[i] <= 7
  }
  
  predicate ValidTriplet(triplet: seq<int>)
  {
      |triplet| == 3 &&
      triplet[0] < triplet[1] < triplet[2] &&
      triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&
      triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0
  }
  
  function FlattenPartition(result: seq<seq<int>>): seq<int>
  {
      if |result| == 0 then [] else
      result[0] + FlattenPartition(result[1..])
  }
  
  predicate ValidPartition(result: seq<seq<int>>, numbers: seq<int>)
  {
      |result| == |numbers| / 3 &&
      (forall i :: 0 <= i < |result| ==> ValidTriplet(result[i])) &&
      multiset(numbers) == multiset(FlattenPartition(result))
  }
  
  predicate NoPartitionExists(result: seq<seq<int>>)
  {
      |result| == 0
  }

vc-helpers: |-
  lemma FlattenPartitionSize(result: seq<seq<int>>)
      requires forall i :: 0 <= i < |result| ==> |result[i]| == 3
      ensures |FlattenPartition(result)| == |result| * 3
  {
      if |result| == 0 {
      } else {
          FlattenPartitionSize(result[1..]);
      }
  }
  
  lemma MultisetSliceLemma(numbers: seq<int>, i: int)
      requires 0 <= i < |numbers|
      ensures multiset(numbers[..i+1]) == multiset(numbers[..i]) + multiset{numbers[i]}
  {
      assert numbers[..i+1] == numbers[..i] + [numbers[i]];
  }

vc-spec: |-
  method solve(n: int, numbers: seq<int>) returns (result: seq<seq<int>>)
      requires ValidInput(n, numbers)
      ensures NoPartitionExists(result) || ValidPartition(result, numbers)

vc-code: |-
  {
      var L := new int[8];
      L[0] := 0; L[1] := 0; L[2] := 0; L[3] := 0; 
      L[4] := 0; L[5] := 0; L[6] := 0; L[7] := 0;
  
      var i := 0;
      while i < |numbers|
          invariant 0 <= i <= |numbers|
          invariant forall j :: 0 <= j <= 7 ==> L[j] >= 0
          invariant forall j :: 1 <= j <= 7 ==> L[j] == multiset(numbers[..i])[j]
          invariant L[0] == 0
          invariant forall k :: 0 <= k < i ==> 1 <= numbers[k] <= 7
      {
          assert 1 <= numbers[i] <= 7;
          MultisetSliceLemma(numbers, i);
          L[numbers[i]] := L[numbers[i]] + 1;
          i := i + 1;
      }
  
      var it := n / 3;
      var found := true;
      var ans: seq<seq<int>> := [];
      var ic := 0;
  
      while ic < it && found
          invariant 0 <= ic <= it
          invariant found ==> |ans| == ic
          invariant !found ==> |ans| <= ic
          invariant forall j :: 0 <= j < |ans| ==> ValidTriplet(ans[j])
          invariant forall j :: 0 <= j <= 7 ==> L[j] >= 0
          decreases it - ic
      {
          var triplet: seq<int> := [];
          var el := 1;
  
          while el < 8 && |triplet| < 3
              invariant 1 <= el <= 8
              invariant |triplet| <= 3
              invariant forall j :: 0 <= j < |triplet| ==> 1 <= triplet[j] <= 7
              invariant forall j :: 0 <= j < |triplet| - 1 ==> triplet[j] < triplet[j+1] && triplet[j+1] % triplet[j] == 0
              invariant forall j :: 0 <= j <= 7 ==> L[j] >= 0
              invariant |triplet| > 0 ==> triplet[|triplet| - 1] < el
          {
              if L[el] > 0
              {
                  if |triplet| == 0
                  {
                      triplet := triplet + [el];
                      L[el] := L[el] - 1;
                  }
                  else if el % triplet[|triplet| - 1] == 0 && el > triplet[|triplet| - 1]
                  {
                      triplet := triplet + [el];
                      L[el] := L[el] - 1;
                  }
              }
              el := el + 1;
          }
  
          if |triplet| == 3
          {
              ans := ans + [triplet];
          }
          else
          {
              found := false;
          }
          ic := ic + 1;
      }
  
      if found && |ans| == n / 3
      {
          FlattenPartitionSize(ans);
          result := ans;
      }
      else
      {
          result := [];
      }
  }

vc-postamble: |-
