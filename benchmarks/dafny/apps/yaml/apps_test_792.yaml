vc-description: |-
  Given a credit card account starting with 0 money and n consecutive days of transactions,
  determine the minimum number of days deposits are needed to satisfy all constraints.
  Each day deposits can be made in the morning, then transactions occur in the evening.
  If any evening transaction causes the balance to exceed limit d, return -1.
  On days when evening transaction is 0 (balance check days), the balance after the
  transaction must be non-negative. Morning deposits can be any positive integer amount.

vc-preamble: |-
  predicate ValidInput(n: int, d: int, transactions: seq<int>)
  {
    n >= 1 && d >= 1 &&
    |transactions| == n &&
    forall i :: 0 <= i < n ==> -10000 <= transactions[i] <= 10000
  }
  
  function prefix_sum(transactions: seq<int>, index: int): int
    requires 0 <= index < |transactions|
  {
    if index == 0 then transactions[0]
    else prefix_sum(transactions, index - 1) + transactions[index]
  }
  
  function count_zero_transactions(transactions: seq<int>): int
  {
    if |transactions| == 0 then 0
    else (if transactions[0] == 0 then 1 else 0) + count_zero_transactions(transactions[1..])
  }
  
  function balance_after_day(transactions: seq<int>, deposits: seq<int>, day: int): int
    requires 0 <= day < |transactions|
    requires |deposits| == |transactions|
  {
    if day == 0 then deposits[0] + transactions[0]
    else balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day]
  }
  
  function count_positive_deposits(deposits: seq<int>): int
  {
    if |deposits| == 0 then 0
    else (if deposits[0] > 0 then 1 else 0) + count_positive_deposits(deposits[1..])
  }
  
  predicate valid_deposits_schedule(transactions: seq<int>, d: int, deposits_schedule: seq<int>, num_deposits: int)
    requires |deposits_schedule| == |transactions|
    requires forall i :: 0 <= i < |deposits_schedule| ==> deposits_schedule[i] >= 0
  {
    num_deposits == count_positive_deposits(deposits_schedule) &&
    forall i :: 0 <= i < |transactions| ==> 
      (deposits_schedule[i] > 0 ==> transactions[i] == 0)
  }
  
  function filter_positive(deposits: seq<int>): seq<int>
  {
    if |deposits| == 0 then []
    else if deposits[0] > 0 then [deposits[0]] + filter_positive(deposits[1..])
    else filter_positive(deposits[1..])
  }

vc-helpers: |-

vc-spec: |-
  method solve(n: int, d: int, transactions: seq<int>) returns (result: int)
    requires ValidInput(n, d, transactions)
    ensures result == -1 || result >= 0

vc-code: |-
  {
    // Compute prefix sums
    var pref := new int[n];
    var maxx := 0;
    for i := 0 to n {
      if i == 0 {
        pref[i] := transactions[i];
      } else {
        pref[i] := pref[i-1] + transactions[i];
      }
      if pref[i] > maxx {
        maxx := pref[i];
      }
    }
  
    // Compute max suffix sums
    var maxr := new int[n];
    for i := n-1 downto 0 {
      if i == n-1 {
        maxr[i] := pref[i];
      } else {
        if maxr[i+1] > pref[i] {
          maxr[i] := maxr[i+1];
        } else {
          maxr[i] := pref[i];
        }
      }
    }
  
    var sm := 0;
    var bon := 0;
    var ans := 0;
    var b := true;
  
    if maxx > d {
      b := false;
    }
  
    for i := 0 to n {
      var elem := transactions[i];
      sm := sm + elem;
  
      if elem == 0 {
        if sm + bon < 0 {
          ans := ans + 1;
          var deposit_limit := d - (maxr[i] + bon);
          if deposit_limit > 0 {
            bon := bon + deposit_limit;
          }
        }
        if sm + bon < 0 {
          b := false;
          break;
        }
      }
  
      if sm + bon > d {
        b := false;
        break;
      }
    }
  
    if b == false {
      result := -1;
    } else {
      result := ans;
    }
  }

vc-postamble: |-

