{"id": "apps_test_1", "vc-description": "Given a positive integer x, find the positive integer not exceeding x that has the maximum sum of digits. \nIf multiple such integers exist, return the largest one.", "vc-preamble": "function intToDigits(x: int): seq<int>\n  requires x >= 0\n{\n  if x == 0 then [0]\n  else intToDigitsHelper(x)\n}\n\nfunction intToDigitsHelper(x: int): seq<int>\n  requires x > 0\n  decreases x\n{\n  if x < 10 then [x]\n  else intToDigitsHelper(x / 10) + [x % 10]\n}\n\nfunction digitSum(digits: seq<int>): int\n{\n  if |digits| == 0 then 0\n  else digits[0] + digitSum(digits[1..])\n}\n\npredicate ValidInput(x: int)\n{\n  x >= 1\n}\n\npredicate ValidResult(x: int, result: int)\n  requires ValidInput(x)\n{\n  result > 0 &&\n  result <= x &&\n  (forall y :: 1 <= y <= x ==> digitSum(intToDigits(y)) <= digitSum(intToDigits(result))) &&\n  (forall y :: 1 <= y <= x && digitSum(intToDigits(y)) == digitSum(intToDigits(result)) ==> y <= result)\n}", "vc-helpers": "", "vc-spec": "method solve(x: int) returns (result: int)\n  requires ValidInput(x)\n  ensures ValidResult(x, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_10", "vc-description": "Given a Martian year with n days and Earth-like weeks (5 work days + 2 days off),\ndetermine the minimum and maximum possible number of days off in that year.", "vc-preamble": "predicate ValidInput(n: int)\n{\n  n >= 1\n}\n\nfunction MinDaysOff(n: int): int\n  requires ValidInput(n)\n{\n  var completeWeeks := n / 7;\n  var remainingDays := n % 7;\n  var minAdditional := if remainingDays > 5 then remainingDays - 5 else 0;\n  2 * completeWeeks + minAdditional\n}\n\nfunction MaxDaysOff(n: int): int\n  requires ValidInput(n)\n{\n  var completeWeeks := n / 7;\n  var remainingDays := n % 7;\n  var maxAdditional := if remainingDays < 2 then remainingDays else 2;\n  2 * completeWeeks + maxAdditional\n}\n\npredicate ValidOutput(result: seq<int>, n: int)\n  requires ValidInput(n)\n{\n  |result| == 2 &&\n  result[0] >= 0 && result[1] >= 0 &&\n  result[0] <= result[1] &&\n  result[0] <= n && result[1] <= n &&\n  result[0] == MinDaysOff(n) &&\n  result[1] == MaxDaysOff(n)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<int>)\n  requires ValidInput(n)\n  ensures ValidOutput(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1000", "vc-description": "Find minimum cost to travel from city 1 to city n on a straight line where adjacent cities are 1 km apart,\nroads are directional (can only go from lower to higher numbered cities), car has fuel tank capacity v liters\nconsuming 1 liter per km, and each city i sells fuel at i dollars per liter.", "vc-preamble": "predicate ValidInput(n: int, v: int) {\n    2 <= n <= 100 && 1 <= v <= 100\n}\n\nfunction MinCost(n: int, v: int): int\n    requires ValidInput(n, v)\n{\n    var req := n - 1;\n    if req <= v then\n        req\n    else\n        var remaining := req - v;\n        v + remaining * (remaining + 3) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, v: int) returns (result: int)\n    requires ValidInput(n, v)\n    ensures result == MinCost(n, v)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1002", "vc-description": "Schedule an optimal event with singer Devu and comedian Churu within a time limit.\nDevu must sing all n songs in order with 10-minute rest periods between songs.\nChuru tells 5-minute jokes during rest periods and any remaining time.\nFind the maximum number of jokes possible, or return -1 if impossible.", "vc-preamble": "function SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\npredicate ValidInput(n: int, d: int, t: seq<int>)\n{\n  1 <= n <= 100 && 1 <= d <= 10000 &&\n  |t| == n &&\n  forall i :: 0 <= i < |t| ==> 1 <= t[i] <= 100\n}\n\nfunction MinTimeNeeded(n: int, t: seq<int>): int\n  requires |t| == n\n{\n  SumSeq(t) + 10 * (n - 1)\n}\n\npredicate ValidResult(n: int, d: int, t: seq<int>, result: int)\n  requires ValidInput(n, d, t)\n{\n  var songSum := SumSeq(t);\n  var minTime := MinTimeNeeded(n, t);\n  if minTime > d then\n    result == -1\n  else\n    result == (d - songSum) / 5 && result >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, d: int, t: seq<int>) returns (result: int)\n  requires ValidInput(n, d, t)\n  ensures ValidResult(n, d, t, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1003", "vc-description": "Vasya starts with n pairs of socks. Each day he uses one pair and discards it.\nEvery m-th day (days m, 2m, 3m, ...), his mother buys him one new pair in the evening.\nFind the number of days Vasya can wear socks before running out.", "vc-preamble": "predicate ValidInput(n: int, m: int) {\n    n >= 1 && m >= 2\n}\n\nfunction SocksAfterDay(n: int, m: int, day: int): int\n  requires m > 0\n{\n    n + day / m - day\n}\n\npredicate CanWearSocksOnDay(n: int, m: int, day: int) \n  requires m > 0\n{\n    day >= 1 ==> SocksAfterDay(n, m, day - 1) > 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures result >= n\n  ensures result > 0\n  ensures SocksAfterDay(n, m, result) <= 0\n  ensures forall k :: 1 <= k < result ==> SocksAfterDay(n, m, k) > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1007", "vc-description": "Find the sum of the k smallest zcy numbers modulo p.\nA zcy number is a palindrome with even length in decimal representation.", "vc-preamble": "function IntToString(n: int): string\n    requires n >= 0\n    ensures forall i :: 0 <= i < |IntToString(n)| ==> '0' <= IntToString(n)[i] <= '9'\n{\n    if n == 0 then \"0\"\n    else if n < 10 then [('0' as int + n) as char]\n    else IntToString(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\nfunction ReverseString(s: string): string\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures forall i :: 0 <= i < |ReverseString(s)| ==> '0' <= ReverseString(s)[i] <= '9'\n{\n    if |s| == 0 then \"\"\n    else ReverseString(s[1..]) + [s[0]]\n}\n\nfunction StringToInt(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 1 then (s[0] as int) - ('0' as int)\n    else StringToInt(s[0..|s|-1]) * 10 + ((s[|s|-1] as int) - ('0' as int))\n}\n\nfunction SumOfPalindromes(k: int): int\n    requires k >= 0\n{\n    if k == 0 then 0\n    else if k == 1 then\n        var s := IntToString(1);\n        var reversed := ReverseString(s);\n        var palindrome := s + reversed;\n        StringToInt(palindrome)\n    else\n        var s := IntToString(k);\n        var reversed := ReverseString(s);\n        var palindrome := s + reversed;\n        StringToInt(palindrome) + SumOfPalindromes(k - 1)\n}\n\npredicate ValidInput(k: int, p: int)\n{\n    k >= 1 && p >= 1\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, p: int) returns (result: int)\n    requires ValidInput(k, p)\n    ensures 0 <= result < p\n    ensures result == (SumOfPalindromes(k) % p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1008", "vc-description": "Given a string s and an integer k, determine if s can be split into exactly k\npalindromes of equal length. Return \"YES\" if possible, \"NO\" otherwise.", "vc-preamble": "function isPalindrome(s: string): bool\n{\n    forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - 1 - i]\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, k: int) returns (result: string)\n    requires k > 0\n    ensures result == \"YES\" || result == \"NO\"\n    ensures |s| % k != 0 ==> result == \"NO\"\n    ensures |s| % k == 0 && (forall i :: 0 <= i < k ==> \n        isPalindrome(s[i * (|s| / k)..(i + 1) * (|s| / k)])) ==> result == \"YES\"\n    ensures |s| % k == 0 && (exists i :: 0 <= i < k && \n        !isPalindrome(s[i * (|s| / k)..(i + 1) * (|s| / k)])) ==> result == \"NO\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1009", "vc-description": "Given n cowbells with integer sizes s\u2081 \u2264 s\u2082 \u2264 ... \u2264 s\u2099 and k boxes, find the minimum box size s \nsuch that all cowbells can be packed into the k boxes, where each box can hold at most 2 cowbells,\nthe sum of cowbell sizes in each box cannot exceed the box size s, and all boxes have the same size s.", "vc-preamble": "predicate ValidInput(n: int, k: int, L: seq<int>)\n{\n    n >= 1 && k >= 1 && n <= 2*k &&\n    |L| == n &&\n    (forall i :: 0 <= i < |L|-1 ==> L[i] <= L[i+1]) &&\n    (forall i :: 0 <= i < |L| ==> L[i] >= 0)\n}\n\npredicate ValidBoxConfiguration(boxes: seq<int>, boxSize: int)\n{\n    |boxes| >= 1 &&\n    (forall i :: 0 <= i < |boxes| ==> boxes[i] <= boxSize) &&\n    (forall i :: 0 <= i < |boxes| ==> boxes[i] >= 0)\n}\n\nfunction sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\nfunction max(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= max(s[1..]) then s[0]\n    else max(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, L: seq<int>) returns (result: int)\n    requires ValidInput(n, k, L)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1013", "vc-description": "Given an n\u00d7m grid where some cells are \"good\" (value 1) and others are not (value 0).\nCorner cells are never good. In one operation, choose a good cell and a corner cell,\nthen color all cells in the rectangle formed by these two cells.\nFind the minimum number of operations to color all cells in the grid.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLinesFunc(input);\n    |lines| >= 2 &&\n    var firstLine := lines[0];\n    var nmParts := SplitWhitespaceFunc(firstLine);\n    |nmParts| >= 2 &&\n    var n := StringToIntFunc(nmParts[0]);\n    var m := StringToIntFunc(nmParts[1]);\n    n >= 3 && m >= 3 &&\n    |lines| >= n + 1 &&\n    (forall i :: 1 <= i <= n ==> \n        var rowParts := SplitWhitespaceFunc(lines[i]);\n        |rowParts| >= m &&\n        (forall j :: 0 <= j < m ==> rowParts[j] == \"0\" || rowParts[j] == \"1\")) &&\n    (exists i, j :: 0 <= i < n && 0 <= j < m && GetGridCellHelper(lines, i, j) == \"1\") &&\n    GetGridCellHelper(lines, 0, 0) == \"0\" &&\n    GetGridCellHelper(lines, 0, m-1) == \"0\" &&\n    GetGridCellHelper(lines, n-1, 0) == \"0\" &&\n    GetGridCellHelper(lines, n-1, m-1) == \"0\"\n}\n\nfunction GetGridCellHelper(lines: seq<string>, i: int, j: int): string\n    requires |lines| >= 2\n    requires i >= 0 && j >= 0\n    requires i + 1 < |lines|\n{\n    var line := lines[i + 1];\n    var parts := SplitWhitespaceFunc(line);\n    if j < |parts| then parts[j] else \"0\"\n}\n\nfunction GetN(input: string): int\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures GetN(input) >= 3\n{\n    var lines := SplitLinesFunc(input);\n    var firstLine := lines[0];\n    var parts := SplitWhitespaceFunc(firstLine);\n    StringToIntFunc(parts[0])\n}\n\nfunction GetM(input: string): int\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures GetM(input) >= 3\n{\n    var lines := SplitLinesFunc(input);\n    var firstLine := lines[0];\n    var parts := SplitWhitespaceFunc(firstLine);\n    StringToIntFunc(parts[1])\n}\n\nfunction GetGridCell(input: string, i: int, j: int): string\n    requires |input| > 0\n    requires ValidInput(input)\n    requires 0 <= i < GetN(input)\n    requires 0 <= j < GetM(input)\n    ensures GetGridCell(input, i, j) == \"0\" || GetGridCell(input, i, j) == \"1\"\n{\n    var lines := SplitLinesFunc(input);\n    var line := lines[i + 1];\n    var parts := SplitWhitespaceFunc(line);\n    parts[j]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures result == \"2\\n\" || result == \"4\\n\"\n    ensures result == \"2\\n\" <==> (exists i, j :: 0 <= i < GetN(input) && 0 <= j < GetM(input) && \n                                 GetGridCell(input, i, j) == \"1\" && \n                                 (i == 0 || j == 0 || i == GetN(input) - 1 || j == GetM(input) - 1))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1014", "vc-description": "Given an n\u00d7n chessboard where white queen starts at (1,1), black queen at (1,n),\nand all other squares contain green pawns. Players alternate turns capturing pieces\nwith standard queen movement. Determine the winner under optimal play.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 2\n}\n\npredicate IsWinForWhite(n: int) {\n    n % 2 == 0\n}\n\npredicate IsWinForBlack(n: int) {\n    n % 2 == 1\n}\n\nfunction OptimalWhiteMove(n: int): (int, int)\n    requires ValidInput(n)\n    requires IsWinForWhite(n)\n{\n    (1, 2)\n}\n\npredicate ValidResult(n: int, result: string) \n    requires ValidInput(n)\n{\n    if IsWinForBlack(n) then\n        result == \"black\\n\"\n    else\n        result == \"white\\n1 2\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n    requires ValidInput(n)\n    ensures ValidResult(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1017", "vc-description": "Given n stones, find the maximum number of distributions such that no two\nconsecutive distributions contain the same number of stones. Each distribution\nmust contain at least 1 stone.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction MaxDistributions(n: int): int\n    requires ValidInput(n)\n{\n    if n % 3 == 0 then 2 * (n / 3) else 2 * (n / 3) + 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result >= 1\n    ensures result == MaxDistributions(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_102", "vc-description": "Convert an integer score (0 \u2264 s \u2264 99) to its English word representation \nusing only lowercase letters and hyphens. Numbers 0-19 have unique forms,\nnumbers 20-99 combine tens words with units using hyphens, multiples of 10\nfrom 20-90 stand alone.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    IsValidIntegerString(s) && \n    var n := ParseInteger(s); 0 <= n <= 99\n}\n\nfunction CorrectEnglishWord(n: int): string\n    requires 0 <= n <= 99\n{\n    if n == 0 then \"zero\"\n    else if n == 1 then \"one\"\n    else if n == 2 then \"two\"\n    else if n == 3 then \"three\"\n    else if n == 4 then \"four\"\n    else if n == 5 then \"five\"\n    else if n == 6 then \"six\"\n    else if n == 7 then \"seven\"\n    else if n == 8 then \"eight\"\n    else if n == 9 then \"nine\"\n    else if n == 10 then \"ten\"\n    else if n == 11 then \"eleven\"\n    else if n == 12 then \"twelve\"\n    else if n == 13 then \"thirteen\"\n    else if n == 14 then \"fourteen\"\n    else if n == 15 then \"fifteen\"\n    else if n == 16 then \"sixteen\"\n    else if n == 17 then \"seventeen\"\n    else if n == 18 then \"eighteen\"\n    else if n == 19 then \"nineteen\"\n    else if n == 20 then \"twenty\"\n    else if n == 30 then \"thirty\"\n    else if n == 40 then \"forty\"\n    else if n == 50 then \"fifty\"\n    else if n == 60 then \"sixty\"\n    else if n == 70 then \"seventy\"\n    else if n == 80 then \"eighty\"\n    else if n == 90 then \"ninety\"\n    else if 21 <= n <= 29 then \"twenty-\" + UnitWord(n % 10)\n    else if 31 <= n <= 39 then \"thirty-\" + UnitWord(n % 10)\n    else if 41 <= n <= 49 then \"forty-\" + UnitWord(n % 10)\n    else if 51 <= n <= 59 then \"fifty-\" + UnitWord(n % 10)\n    else if 61 <= n <= 69 then \"sixty-\" + UnitWord(n % 10)\n    else if 71 <= n <= 79 then \"seventy-\" + UnitWord(n % 10)\n    else if 81 <= n <= 89 then \"eighty-\" + UnitWord(n % 10)\n    else \"ninety-\" + UnitWord(n % 10)\n}\n\npredicate IsValidIntegerString(s: string)\n{\n    (|s| >= 1 && |s| <= 3 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9') ||\n    (|s| >= 2 && |s| <= 4 && s[|s|-1] == '\\n' && forall i :: 0 <= i < |s|-1 ==> '0' <= s[i] <= '9')\n}\n\nfunction ParseInteger(s: string): int\n    requires IsValidIntegerString(s)\n{\n    if s[|s|-1] == '\\n' then\n        ParseIntegerHelper(s[0..|s|-1])\n    else\n        ParseIntegerHelper(s)\n}\n\nfunction ParseIntegerHelper(s: string): int\n    requires |s| >= 1 && |s| <= 3\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 1 then\n        (s[0] as int) - ('0' as int)\n    else if |s| == 2 then\n        10 * ((s[0] as int) - ('0' as int)) + ((s[1] as int) - ('0' as int))\n    else\n        100 * ((s[0] as int) - ('0' as int)) + 10 * ((s[1] as int) - ('0' as int)) + ((s[2] as int) - ('0' as int))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInput(stdin_input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures var n := ParseInteger(stdin_input);\n        result == CorrectEnglishWord(n) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1020", "vc-description": "Given a rectangular plate with dimensions w \u00d7 h cells, calculate the total number of cells\nto be gilded when adding k concentric rings. Ring 1 is the border of the full w \u00d7 h rectangle,\nRing 2 is the border of the inner (w-4) \u00d7 (h-4) rectangle, and so on. Each ring consists of\nall cells on the perimeter of its respective rectangle.", "vc-preamble": "predicate ValidInput(w: int, h: int, k: int)\n{\n    w >= 3 && h >= 3 && w <= 100 && h <= 100 && \n    k >= 1 && k <= ((if w <= h then w else h) + 1) / 4 &&\n    w - 4 * k >= 3 && h - 4 * k >= 3\n}\n\nfunction perimeter(w: int, h: int): int\n    requires w >= 1 && h >= 1\n{\n    w * 2 + (h - 2) * 2\n}\n\nfunction computeSum(w: int, h: int, k: int): int\n    requires w >= 3 && h >= 3 && k >= 0\n    requires w - 4 * k >= 3 && h - 4 * k >= 3\n    decreases k\n{\n    if k == 0 then 0\n    else \n        perimeter(w, h) + computeSum(w - 4, h - 4, k - 1)\n}", "vc-helpers": "", "vc-spec": "method GildCells(w: int, h: int, k: int) returns (result: int)\n    requires ValidInput(w, h, k)\n    ensures result == computeSum(w, h, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1027", "vc-description": "Given a Mancala board with 14 holes containing stones, determine the maximum score achievable in one move.\nMove rules: Choose a hole with positive stones, take all stones, redistribute counter-clockwise,\ncollect stones from holes with even counts as the score.", "vc-preamble": "ghost predicate canParseToBoard(input: string)\n    reads {}\n{\n    |input| > 0\n}\n\nghost predicate boardMatchesInput(board: array<int>, input: string)\n    requires board.Length == 14\n    reads board\n{\n    true\n}\n\nghost predicate stringRepresentsInt(s: string, n: int)\n    reads {}\n{\n    |s| > 0 && n >= 0\n}\n\nghost function maxAchievableScoreFromInput(input: string): int\n    requires |input| > 0\n    requires canParseToBoard(input)\n    reads {}\n    ensures maxAchievableScoreFromInput(input) >= 0\n{\n    0\n}\n\nghost function maxScoreFromRange(board: array<int>, upTo: int): int\n    requires board.Length == 14\n    requires 0 <= upTo <= 14\n    requires forall i :: 0 <= i < 14 ==> board[i] >= 0\n    reads board\n    ensures maxScoreFromRange(board, upTo) >= 0\n{\n    if upTo == 0 then 0\n    else var prevMax := maxScoreFromRange(board, upTo - 1);\n         var currentScore := if board[upTo - 1] == 0 then -1 else 0;\n         if currentScore > prevMax then currentScore else prevMax\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires canParseToBoard(stdin_input)\n    ensures |result| > 0\n    ensures result == intToString(maxAchievableScoreFromInput(stdin_input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1028", "vc-description": "Given n participants split into m teams where each team has at least one participant,\nfind the minimum and maximum possible number of friendship pairs that can form.\nFriendship pairs are formed between all participants within the same team.", "vc-preamble": "function comb2(n: int): int\n  requires n >= 0\n{\n  n * (n - 1) / 2\n}\n\npredicate ValidInput(n: int, m: int)\n{\n  1 <= m <= n\n}\n\nfunction MinFriendshipPairs(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  var k := n / m;\n  var p := n % m;\n  p * comb2(k + 1) + (m - p) * comb2(k)\n}\n\nfunction MaxFriendshipPairs(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  comb2(n - m + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (min_pairs: int, max_pairs: int)\n  requires ValidInput(n, m)\n  ensures min_pairs >= 0\n  ensures max_pairs >= 0\n  ensures min_pairs <= max_pairs\n  ensures min_pairs == MinFriendshipPairs(n, m)\n  ensures max_pairs == MaxFriendshipPairs(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1035", "vc-description": "Given two positive integers A and B, find the maximum number of positive common divisors \nthat can be chosen such that any two chosen divisors are coprime (share no common factors other than 1).", "vc-preamble": "predicate ValidInput(A: int, B: int)\n{\n  A > 0 && B > 0\n}\n\nfunction gcd(a: int, b: int): int\n  requires a > 0 && b >= 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 then a else gcd(b, a % b)\n}\n\nfunction countDistinctPrimeFactors(n: int): int\n  requires n > 0\n  ensures countDistinctPrimeFactors(n) >= 0\n{\n  if n == 1 then 0\n  else countDistinctPrimeFactorsHelper(n, 2)\n}\n\nfunction countDistinctPrimeFactorsHelper(n: int, i: int): int\n  requires n > 0 && i >= 2\n  ensures countDistinctPrimeFactorsHelper(n, i) >= 0\n  decreases 2*n - i\n{\n  if i * i > n then\n    if n > 1 then 1 else 0\n  else if n % i == 0 then\n    1 + countDistinctPrimeFactorsHelper(divideOutFactor(n, i), i + 1)\n  else\n    countDistinctPrimeFactorsHelper(n, i + 1)\n}\n\nfunction divideOutFactor(n: int, factor: int): int\n  requires n > 0 && factor > 1 && n % factor == 0\n  ensures divideOutFactor(n, factor) > 0\n  ensures divideOutFactor(n, factor) < n\n  ensures divideOutFactor(n, factor) % factor != 0\n  decreases n\n{\n  var next := n / factor;\n  if next % factor == 0 then divideOutFactor(next, factor) else next\n}\n\npredicate CorrectResult(A: int, B: int, result: int)\n  requires A > 0 && B > 0\n{\n  result == countDistinctPrimeFactors(gcd(A, B)) + 1\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int) returns (result: int)\n  requires ValidInput(A, B)\n  ensures result > 0\n  ensures CorrectResult(A, B, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1036", "vc-description": "Given integers n and k, simulate a Rock-Paper-Scissors tournament among 2^k players.\nEach player i has favorite hand from string s at position ((i mod n) + 1).\nTournament uses recursive bracket structure where Rock beats Scissors, \nPaper beats Rock, Scissors beats Paper, and ties go to the first player.\nReturn the favorite hand of the tournament winner.", "vc-preamble": "function winner(a: char, b: char): char\n{\n    if (a, b) == ('R', 'P') || (a, b) == ('P', 'S') || (a, b) == ('S', 'R') then b else a\n}\n\npredicate validRPSChar(c: char)\n{\n    c == 'R' || c == 'P' || c == 'S'\n}\n\npredicate validRPSString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> validRPSChar(s[i])\n}\n\npredicate ValidInput(n: int, k: int, s: string)\n{\n    n > 0 && k >= 0 && |s| == n && validRPSString(s)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, s: string) returns (result: char)\n    requires ValidInput(n, k, s)\n    ensures validRPSChar(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1038", "vc-description": "Given two integers A and B, compute f(A, B) which is the exclusive OR (XOR) of all integers \nin the range [A, B] inclusive. The XOR operation combines all bits where the result bit is 1 \nif an odd number of input integers have 1 in that bit position, and 0 if an even number do.", "vc-preamble": "predicate ValidInput(a: int, b: int) {\n    0 <= a <= b\n}\n\nfunction XorInt(x: int, y: int): int\n    requires x >= 0 && y >= 0\n    decreases x + y\n    ensures XorInt(x, y) >= 0\n{\n    if x == 0 && y == 0 then 0\n    else if x == 0 then y\n    else if y == 0 then x\n    else\n        var bit_x := x % 2;\n        var bit_y := y % 2;\n        var xor_bit := if bit_x != bit_y then 1 else 0;\n        xor_bit + 2 * XorInt(x / 2, y / 2)\n}\n\nfunction XorRange(a: int, b: int): int\n    requires 0 <= a <= b\n    decreases b - a\n    ensures XorRange(a, b) >= 0\n{\n    if a == b then a\n    else XorInt(a, XorRange(a + 1, b))\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result == XorRange(a, b)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1044", "vc-description": "Two players play a cycle-splitting game alternately. Player 1 goes first.\nPlayers split cycles with \u22652 vertices into two smaller cycles.\nProcess n operations sequentially, each adding a cycle.\nAfter each operation, determine who wins if the game starts with current cycle set.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    var lines := SplitByNewlineSpec(s);\n    |lines| >= 2 &&\n    IsValidInteger(lines[0]) &&\n    var n := ParseIntSpec(lines[0]);\n    var numbers := SplitBySpaceSpec(lines[1]);\n    |numbers| == n &&\n    forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction SplitByNewlineSpec(s: string): seq<string>\n{\n    [\"\", \"\"]\n}\n\nfunction SplitBySpaceSpec(s: string): seq<string>\n{\n    [\"\"]\n}\n\nfunction ParseIntSpec(s: string): int\n    requires IsValidInteger(s)\n{\n    0\n}\n\npredicate SimulatesGameLogic(numbers: seq<string>, result: string)\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    var outputLines := SplitByNewlineSpec(result);\n    ComputesCorrectPlayers(numbers, outputLines)\n}\n\npredicate ComputesCorrectPlayers(numbers: seq<string>, outputs: seq<string>)\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    |numbers| == |outputs| &&\n    var players := ComputePlayersSequence(numbers);\n    |players| == |outputs| &&\n    forall i :: 0 <= i < |outputs| ==> \n        (players[i] == 1 ==> outputs[i] == \"1\") &&\n        (players[i] == 2 ==> outputs[i] == \"2\")\n}\n\nfunction ComputePlayersSequence(numbers: seq<string>): seq<int>\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    if |numbers| == 0 then []\n    else ComputePlayersHelper(numbers, 0, 2)\n}\n\nfunction ComputePlayersHelper(numbers: seq<string>, index: int, currentPlayer: int): seq<int>\n    requires 0 <= index <= |numbers|\n    requires currentPlayer == 1 || currentPlayer == 2\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n    decreases |numbers| - index\n{\n    if index >= |numbers| then []\n    else\n        var num := ParseIntSpec(numbers[index]);\n        var nextPlayer := if num % 2 == 0 then 3 - currentPlayer else currentPlayer;\n        [nextPlayer] + ComputePlayersHelper(numbers, index + 1, nextPlayer)\n}\n\nfunction CountLines(s: string): int\n{\n    CountNewlines(s, 0, 0)\n}\n\nfunction CountNewlines(s: string, index: int, count: int): int\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index >= |s| then count\n    else if s[index] == '\\n' then CountNewlines(s, index + 1, count + 1)\n    else CountNewlines(s, index + 1, count)\n}\n\npredicate StartsWithPlayer2AndTogglesOnEven(numbers: seq<string>, result: string)\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    var outputLines := SplitByNewlineSpec(result);\n    var computedPlayers := ComputePlayersSequence(numbers);\n    |outputLines| == |computedPlayers| &&\n    forall i :: 0 <= i < |outputLines| ==>\n        (computedPlayers[i] == 1 ==> outputLines[i] == \"1\") &&\n        (computedPlayers[i] == 2 ==> outputLines[i] == \"2\")\n}\n\npredicate AlternatesCorrectly(input: string, output: string)\n{\n    var lines := SplitByNewlineSpec(input);\n    |lines| >= 2 ==>\n    var numbers := SplitBySpaceSpec(lines[1]);\n    var outputLines := SplitByNewlineSpec(output);\n    |outputLines| == |numbers| &&\n    ComputesCorrectPlayers(numbers, outputLines)\n}\n\npredicate PartialSimulation(numbers: seq<string>, output: string, processed: int, currentPlayer: int)\n    requires 0 <= processed <= |numbers|\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    var outputLines := SplitByNewlineSpec(output);\n    |outputLines| == processed &&\n    var partialComputed := ComputePlayersSequence(numbers[..processed]);\n    |outputLines| == |partialComputed| &&\n    forall i :: 0 <= i < |outputLines| ==>\n        (partialComputed[i] == 1 ==> outputLines[i] == \"1\") &&\n        (partialComputed[i] == 2 ==> outputLines[i] == \"2\")\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    requires exists i :: 0 <= i < |s| && s[i] == '\\n'\n    requires ValidInput(s)\n    ensures |result| > 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] == '1' || result[i] == '2' || result[i] == '\\n'\n    ensures result[|result|-1] == '\\n'\n    ensures var lines := SplitByNewlineSpec(s);\n        |lines| >= 2 ==> \n        var numbers := SplitBySpaceSpec(lines[1]);\n        CountLines(result) == |numbers|\n    ensures var lines := SplitByNewlineSpec(s);\n        |lines| >= 2 ==> \n        var numbers := SplitBySpaceSpec(lines[1]);\n        SimulatesGameLogic(numbers, result)\n    ensures var lines := SplitByNewlineSpec(s);\n        |lines| >= 2 ==> \n        var numbers := SplitBySpaceSpec(lines[1]);\n        StartsWithPlayer2AndTogglesOnEven(numbers, result)\n    ensures AlternatesCorrectly(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1045", "vc-description": "Find the maximum height of a pyramid that can be built with n cubes, where\nlevel i requires exactly i*(i+1)/2 cubes. The pyramid is built from top to\nbottom with levels 1, 2, 3, ..., h.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction CubesForLevel(level: int): int\n    requires level >= 1\n{\n    level * (level + 1) / 2\n}\n\nfunction TotalCubesForHeight(h: int): int\n    requires h >= 1\n{\n    h * (h + 1) * (h + 2) / 6\n}\n\npredicate ValidPyramidHeight(n: int, h: int) {\n    ValidInput(n) && h >= 1 && \n    TotalCubesForHeight(h) <= n &&\n    TotalCubesForHeight(h + 1) > n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result >= 1\n    ensures ValidPyramidHeight(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1046", "vc-description": "Given n secretaries, each assigned either a positive session ID if on a call or 0 if not talking.\nWhen two people call each other, they share the same unique session ID. Each call connects exactly \ntwo people (no conferences). Determine how many pairs of secretaries are talking to each other, \nor return -1 if the situation is impossible (any session ID appears more than twice).", "vc-preamble": "function CountOccurrences(s: seq<int>, x: int): int\n  ensures CountOccurrences(s, x) >= 0\n{\n  if |s| == 0 then 0\n  else (if s[0] == x then 1 else 0) + CountOccurrences(s[1..], x)\n}\n\nfunction CountPairs(s: seq<int>): int\n  ensures CountPairs(s) >= 0\n{\n  var positive_sessions := FilterPositive(s);\n  CountPairsHelper(positive_sessions)\n}\n\nfunction FilterPositive(s: seq<int>): seq<int>\n  ensures forall i :: 0 <= i < |FilterPositive(s)| ==> FilterPositive(s)[i] > 0\n{\n  if |s| == 0 then []\n  else if s[0] > 0 then [s[0]] + FilterPositive(s[1..])\n  else FilterPositive(s[1..])\n}\n\nfunction CountPairsHelper(s: seq<int>): int\n  decreases |s|\n  ensures CountPairsHelper(s) >= 0\n{\n  if |s| <= 1 then 0\n  else \n    var count := CountOccurrences(s, s[0]);\n    var remaining := RemoveAllOccurrences(s, s[0]);\n    (if count == 2 then 1 else 0) + CountPairsHelper(remaining)\n}\n\nfunction RemoveAllOccurrences(s: seq<int>, x: int): seq<int>\n  ensures |RemoveAllOccurrences(s, x)| <= |s|\n{\n  if |s| == 0 then []\n  else if s[0] == x then RemoveAllOccurrences(s[1..], x)\n  else [s[0]] + RemoveAllOccurrences(s[1..], x)\n}\n\npredicate ExistsIndex(s: seq<int>, x: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == x\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, sessions: seq<int>) returns (result: int)\n  requires n >= 1\n  requires |sessions| == n\n  requires forall i :: 0 <= i < |sessions| ==> sessions[i] >= 0\n  ensures result == -1 || result >= 0\n  ensures result == -1 ==> exists id :: id > 0 && CountOccurrences(sessions, id) > 2\n  ensures result >= 0 ==> forall id :: id > 0 ==> CountOccurrences(sessions, id) <= 2\n  ensures result >= 0 ==> result == CountPairs(sessions)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1048", "vc-description": "Given a sequence of movement commands for a robot on an infinite grid, find the maximum number of commands \nthat could be executed such that the robot returns to its starting position (0, 0). The robot can move \nU (up), D (down), L (left), or R (right). To return to origin, we need equal numbers of L/R movements \nand equal numbers of U/D movements.", "vc-preamble": "function count_char(s: string, c: char): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + count_char(s[1..], c)\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}\n\npredicate ValidCommands(commands: string)\n{\n    forall i :: 0 <= i < |commands| ==> commands[i] in {'L', 'R', 'U', 'D'}\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, commands: string) returns (result: int)\n    requires n >= 0\n    requires |commands| == n\n    requires ValidCommands(commands)\n    ensures result >= 0\n    ensures result <= n\n    ensures result % 2 == 0\n    ensures result == 2 * min(count_char(commands, 'L'), count_char(commands, 'R')) + \n                     2 * min(count_char(commands, 'U'), count_char(commands, 'D'))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1049", "vc-description": "Given n opponents and d days, determine the maximum number of consecutive days where Arya wins fights.\nArya wins on a day if at least one opponent is absent. Arya loses on a day if all opponents are present.\nEach day's attendance is given as a binary string of length n, where '1' means present and '0' means absent.", "vc-preamble": "predicate InputWellFormed(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 1 &&\n    var firstLineParts := SplitString(lines[0], ' ');\n    |firstLineParts| == 2 &&\n    IsValidInt(firstLineParts[0]) &&\n    IsValidInt(firstLineParts[1]) &&\n    var n := StringToInt(firstLineParts[0]);\n    var d := StringToInt(firstLineParts[1]);\n    n >= 0 && d >= 0 &&\n    |lines| >= d + 1 &&\n    forall i :: 1 <= i <= d ==> i < |lines| && IsValidBinaryString(lines[i], n)\n}\n\nfunction ComputeMaxConsecutiveWins(input: string): int\n    requires InputWellFormed(input)\n{\n    var lines := SplitLines(input);\n    var firstLineParts := SplitString(lines[0], ' ');\n    var n := StringToInt(firstLineParts[0]);\n    var d := StringToInt(firstLineParts[1]);\n    MaxConsecutiveWinsUpTo(lines, n, d)\n}\n\npredicate IsValidInt(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate IsValidBinaryString(s: string, expectedLength: int)\n{\n    |s| == expectedLength && forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires InputWellFormed(input)\n    ensures result == IntToString(ComputeMaxConsecutiveWins(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1052", "vc-description": "Count the number of permutations of [1, 2, ..., n] where at least n-k positions\nhave the correct value (i.e., p[i] = i for at least n-k indices i).", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n  4 <= n <= 1000 && 1 <= k <= 4 && k < n\n}\n\nfunction factorial(n: int): int\n  requires n >= 0\n  ensures factorial(n) > 0\n{\n  if n <= 1 then 1 else n * factorial(n - 1)\n}\n\nfunction derangement(n: int): int\n  requires n >= 0\n  ensures derangement(n) >= 0\n{\n  if n <= 1 then 0\n  else if n == 2 then 1\n  else (n - 1) * (derangement(n - 1) + derangement(n - 2))\n}\n\nfunction binomial(n: int, k: int): int\n  requires n >= 0 && k >= 0\n  ensures binomial(n, k) >= 0\n{\n  if k > n then 0\n  else if k == 0 || k == n then 1\n  else factorial(n) / (factorial(k) * factorial(n - k))\n}\n\nfunction sum_binomial_derangement(n: int, k: int, i: int): int\n  requires n >= 0 && k >= 0 && i >= 0\n  ensures sum_binomial_derangement(n, k, i) >= 0\n  decreases n - k - i\n{\n  if i >= n - k then 0\n  else binomial(n, i) * derangement(n - i) + sum_binomial_derangement(n, k, i + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n  requires ValidInput(n, k)\n  ensures result == factorial(n) - sum_binomial_derangement(n, k, 0)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1055", "vc-description": "Given an array of integers, apply the Thanos sort algorithm to find the maximum length \nof a sorted subarray. The algorithm works by: if the array is sorted, stop; otherwise \nchoose either the first half or second half and repeat the process.", "vc-preamble": "predicate ValidInput(a: seq<int>)\n{\n    |a| > 0\n}\n\npredicate isSorted(x: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |x| ==> x[i] <= x[j]\n}\n\nfunction thanosSort(x: seq<int>): int\n    requires |x| > 0\n    ensures thanosSort(x) >= 1\n    ensures thanosSort(x) <= |x|\n    ensures isSorted(x) ==> thanosSort(x) == |x|\n{\n    var len := |x|;\n    if isSorted(x) then\n        len\n    else\n        var firstHalf := x[..len/2];\n        var secondHalf := x[len/2..];\n        var leftResult := thanosSort(firstHalf);\n        var rightResult := thanosSort(secondHalf);\n        if leftResult > rightResult then leftResult else rightResult\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: int)\n    requires ValidInput(a)\n    ensures result == thanosSort(a)\n    ensures 1 <= result <= |a|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_106", "vc-description": "Given a circular building with n entrances, m floors per entrance, and k apartments per floor,\nfind the minimum time to travel from apartment a to apartment b. Apartments are numbered 1 to n\u00b7m\u00b7k\nsequentially. Travel costs: stairs 5s/floor, adjacent entrances 15s, elevator 10s wait + 1s/floor,\nsame floor 0s. Can walk around building in either direction.", "vc-preamble": "predicate ValidInput(n: int, m: int, k: int, a: int, b: int) {\n  n > 0 && m > 0 && k > 0 && 1 <= a <= n * m * k && 1 <= b <= n * m * k && a != b\n}\n\nfunction GetEntrance(apt: int, m: int, k: int): int\n  requires apt >= 1\n  requires m > 0 && k > 0\n{\n  (apt - 1) / (m * k)\n}\n\nfunction GetFloor(apt: int, m: int, k: int): int\n  requires apt >= 1\n  requires m > 0 && k > 0\n{\n  ((apt - 1) - GetEntrance(apt, m, k) * m * k) / k\n}\n\nfunction MinTravelTime(floors: int): int\n  requires floors >= 0\n{\n  var stair_time := 5 * floors;\n  var elevator_time := 10 + floors;\n  if stair_time < elevator_time then stair_time else elevator_time\n}\n\nfunction MinEntranceDistance(entrance_a: int, entrance_b: int, n: int): int\n  requires n > 0\n{\n  var clockwise := (entrance_b - entrance_a + n) % n;\n  var counterclockwise := (entrance_a - entrance_b + n) % n;\n  if clockwise <= counterclockwise then clockwise else counterclockwise\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int, a: int, b: int) returns (result: int)\n  requires ValidInput(n, m, k, a, b)\n  ensures result >= 0\n  ensures GetEntrance(a, m, k) == GetEntrance(b, m, k) ==> \n    result == MinTravelTime(if GetFloor(a, m, k) >= GetFloor(b, m, k) \n                           then GetFloor(a, m, k) - GetFloor(b, m, k) \n                           else GetFloor(b, m, k) - GetFloor(a, m, k))\n  ensures GetEntrance(a, m, k) != GetEntrance(b, m, k) ==>\n    result == MinTravelTime(GetFloor(a, m, k)) + \n              15 * MinEntranceDistance(GetEntrance(a, m, k), GetEntrance(b, m, k), n) + \n              MinTravelTime(GetFloor(b, m, k))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1063", "vc-description": "Given a sequence of n strings where each string contains digits and question marks (?),\nrestore the original strictly increasing sequence of positive integers by replacing each\nquestion mark with a single digit (0-9). The resulting sequence must be strictly increasing,\nall numbers must be positive integers (no leading zeros allowed), and each ? represents\nexactly one missing digit.", "vc-preamble": "predicate isWellFormedInput(stdin_input: string)\n{\n    var lines := splitLines(stdin_input);\n    if |lines| < 1 then false\n    else\n        var n := parseInt(lines[0]);\n        n >= 0 && |lines| >= n + 1 &&\n        (forall i :: 1 <= i <= n && i < |lines| ==> \n            |lines[i]| >= 1 && |lines[i]| <= 8 &&\n            (forall j :: 0 <= j < |lines[i]| ==> \n                (lines[i][j] >= '0' && lines[i][j] <= '9') || lines[i][j] == '?'))\n}\n\nghost predicate hasValidSolution(stdin_input: string)\n    requires isWellFormedInput(stdin_input)\n{\n    var lines := splitLines(stdin_input);\n    var n := parseInt(lines[0]);\n    if n <= 0 then true\n    else\n        var inputStrings := lines[1..n+1];\n        exists solution :: isValidSequenceSolution(inputStrings, solution)\n}\n\npredicate isValidSequenceSolution(input: seq<string>, solution: seq<string>)\n{\n    |input| == |solution| &&\n    (forall i :: 0 <= i < |input| ==> \n        |input[i]| == |solution[i]| &&\n        forall j :: 0 <= j < |input[i]| ==> \n            (input[i][j] != '?' ==> input[i][j] == solution[i][j]) &&\n            (input[i][j] == '?' ==> solution[i][j] >= '0' && solution[i][j] <= '9')) &&\n    (forall i :: 0 <= i < |solution| ==> isValidPositiveInteger(solution[i])) &&\n    isStrictlyIncreasingSequence(solution)\n}\n\npredicate isValidPositiveInteger(s: string)\n{\n    |s| >= 1 && \n    (forall i :: 0 <= i < |s| ==> (s[i] >= '0' && s[i] <= '9')) &&\n    (|s| == 1 || s[0] != '0')\n}\n\npredicate isStrictlyIncreasingSequence(nums: seq<string>)\n    requires forall i :: 0 <= i < |nums| ==> isValidPositiveInteger(nums[i])\n{\n    forall i :: 0 <= i < |nums| - 1 ==> isLexicographicallySmaller(nums[i], nums[i+1])\n}\n\npredicate isLexicographicallySmaller(a: string, b: string)\n    requires isValidPositiveInteger(a) && isValidPositiveInteger(b)\n{\n    |a| < |b| || (|a| == |b| && a < b)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires isWellFormedInput(stdin_input)\n    ensures |result| > 0\n    ensures result == \"NO\\n\" || (|result| > 4 && result[..4] == \"YES\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1065", "vc-description": "Given n candies and k people (numbered 1 to k), find the maximum number of candies person 1 can receive.\nPerson 1 chooses an integer x and distributes candies cyclically: first x candies to person 1, next x to person 2, \n..., next x to person k, then repeat the cycle. Remaining candies are discarded.\nConstraints: 1 \u2264 x \u2264 M, no person can receive candies more than D times.", "vc-preamble": "predicate ValidInput(n: int, k: int, M: int, D: int) {\n    2 <= n && 2 <= k <= n && 1 <= M <= n && 1 <= D <= n && M * D * k >= n\n}\n\nfunction CandiesUsed(x: int, d: int, k: int): int {\n    x * ((d - 1) * k + 1)\n}\n\npredicate ValidDistribution(x: int, d: int, n: int, k: int, M: int, D: int) {\n    1 <= x <= M && 1 <= d <= D && CandiesUsed(x, d, k) <= n\n}\n\nfunction Person1Candies(x: int, d: int): int {\n    x * d\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, M: int, D: int) returns (result: int)\n    requires ValidInput(n, k, M, D)\n    ensures result >= 0\n    ensures result <= M * D\n    ensures forall x: int, d: int :: ValidDistribution(x, d, n, k, M, D) ==> Person1Candies(x, d) <= result\n    ensures exists x: int, d: int :: ValidDistribution(x, d, n, k, M, D) && Person1Candies(x, d) == result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1069", "vc-description": "Calculate the value of (1^n + 2^n + 3^n + 4^n) mod 5 for a given integer n.\nThe input n is given as a string representation of a non-negative integer.\nThe result is either 4 (when n \u2261 0 mod 4) or 0 (otherwise).", "vc-preamble": "function StringToNat(s: string): nat\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n  if |s| == 1 then (s[0] as int - '0' as int) as nat\n  else StringToNat(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int) as nat\n}\n\npredicate ValidInput(n: string)\n{\n  |n| > 0 && \n  (forall i :: 0 <= i < |n| ==> '0' <= n[i] <= '9') &&\n  (n[0] != '0' || |n| == 1)\n}\n\npredicate ValidOutput(result: string)\n{\n  result == \"4\\n\" || result == \"0\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: string) returns (result: string)\n  requires ValidInput(n)\n  ensures ValidOutput(result)\n  ensures (StringToNat(n) % 4 == 0) <==> (result == \"4\\n\")\n  ensures (StringToNat(n) % 4 != 0) <==> (result == \"0\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1071", "vc-description": "Given a cupboard with n shelves, determine if all cups and medals can be placed\nfollowing constraints: cups and medals cannot be on the same shelf, each shelf\ncan hold at most 5 cups, and each shelf can hold at most 10 medals.", "vc-preamble": "predicate ValidInput(a: seq<int>, b: seq<int>, n: int)\n{\n    |a| >= 0 && |b| >= 0 &&\n    (forall i :: 0 <= i < |a| ==> a[i] >= 0) &&\n    (forall j :: 0 <= j < |b| ==> b[j] >= 0) &&\n    n >= 1\n}\n\nfunction sum_seq(s: seq<int>): int\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 0\n{\n    if |s| == 0 then 0 else s[0] + sum_seq(s[1..])\n}\n\nfunction ShelvesNeeded(total: int, capacity: int): int\n    requires capacity > 0\n{\n    if total == 0 then 0 else (total - 1) / capacity + 1\n}\n\npredicate CanPlaceAll(a: seq<int>, b: seq<int>, n: int)\n    requires ValidInput(a, b, n)\n{\n    var total_cups := sum_seq(a);\n    var total_medals := sum_seq(b);\n    var shelves_for_cups := ShelvesNeeded(total_cups, 5);\n    var shelves_for_medals := ShelvesNeeded(total_medals, 10);\n    shelves_for_cups + shelves_for_medals <= n\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>, b: seq<int>, n: int) returns (result: string)\n    requires ValidInput(a, b, n)\n    ensures result == (if CanPlaceAll(a, b, n) then \"YES\" else \"NO\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1074", "vc-description": "Given an integer a, count the number of times the digit '1' appears in its octal (base-8) representation.\nInput: A single integer a where 0 \u2264 a \u2264 1,000,000\nOutput: A single integer representing the count of digit '1' in the octal representation of a", "vc-preamble": "function CountOnesInOctal(a: int): int\n    requires a >= 0\n{\n    if a == 0 then 0\n    else (if a % 8 == 1 then 1 else 0) + CountOnesInOctal(a / 8)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int) returns (count: int)\n    requires a >= 0\n    ensures count >= 0\n    ensures count == CountOnesInOctal(a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1081", "vc-description": "Given an integer a (1 \u2264 a \u2264 99), determine whether it satisfies a specific condition\nand output \"YES\" or \"NO\". The condition is derived from the pattern in given examples.", "vc-preamble": "predicate ValidInput(n: int) {\n    1 <= n <= 99\n}\n\nfunction ExpectedResult(n: int): string\n    requires ValidInput(n)\n{\n    if n < 12 then\n        if n == 1 || n == 7 || n == 9 || n == 10 || n == 11 then \"NO\" else \"YES\"\n    else if 12 < n < 30 then\n        \"NO\"\n    else if 69 < n < 80 then\n        \"NO\"\n    else if 89 < n then\n        \"NO\"\n    else\n        var lastDigit := n % 10;\n        if lastDigit != 1 && lastDigit != 7 && lastDigit != 9 then \"YES\" else \"NO\"\n}\n\npredicate ValidOutput(result: string) {\n    result == \"YES\" || result == \"NO\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n    requires ValidInput(n)\n    ensures ValidOutput(result)\n    ensures result == ExpectedResult(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1084", "vc-description": "Given an n\u00d7m grid that is initially all white, determine if it can be transformed into a target \nconfiguration using a sequence of operations. Each operation selects a non-empty subset of rows \nand a non-empty subset of columns, then colors all intersections black. Each row and each column \ncan be used in at most one operation across all operations. The key constraint is that if two \nblack cells share the same column, their rows must have identical patterns of black cells.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && '\\n' in input\n}\n\npredicate CanBeConstructedByOperations(input: string)\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    if |lines| < 2 then false\n    else\n        var firstLine := lines[0];\n        var gridLines := lines[1..];\n        var dimensions := ParseDimensions(firstLine);\n        var n := dimensions.0;\n        var m := dimensions.1;\n        if n <= 0 || m <= 0 || |gridLines| != n then false\n        else if !ValidGrid(gridLines, m) then false\n        else\n            (forall col {:trigger} :: 0 <= col < m ==>\n                var rowsWithThisCol := set i | 0 <= i < n && col < |gridLines[i]| && gridLines[i][col] == '#';\n                |rowsWithThisCol| <= 1 ||\n                (forall i, j :: i in rowsWithThisCol && j in rowsWithThisCol ==>\n                    GetRowPattern(gridLines[i], m) == GetRowPattern(gridLines[j], m)))\n}\n\npredicate ValidGrid(gridLines: seq<string>, m: int)\n{\n    (forall i :: 0 <= i < |gridLines| ==> |gridLines[i]| == m) &&\n    (forall i :: 0 <= i < |gridLines| ==> \n        forall j :: 0 <= j < |gridLines[i]| ==> gridLines[i][j] in {'.', '#'})\n}\n\nfunction GetRowPattern(row: string, m: int): set<int>\n    requires |row| == m\n{\n    set j | 0 <= j < m && row[j] == '#'\n}\n\nfunction SplitLines(input: string): seq<string>\n    requires |input| > 0\n{\n    SplitLinesHelper(input, 0, [])\n}\n\nfunction ParseDimensions(line: string): (int, int)\n{\n    var parts := SplitOnSpace(line);\n    if |parts| >= 2 then\n        (StringToInt(parts[0]), StringToInt(parts[1]))\n    else\n        (0, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures result == \"Yes\\n\" || result == \"No\\n\"\n    ensures |result| > 0\n    ensures result == \"Yes\\n\" <==> CanBeConstructedByOperations(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1085", "vc-description": "Given a positive integer N, find how many values of K (where 2 \u2264 K \u2264 N) will cause N to become 1\nthrough repeated operations: if K divides N, replace N with N/K; otherwise replace N with N-K;\ncontinue until N < K. Count the number of valid K values.", "vc-preamble": "predicate ValidInput(n: nat)\n{\n  n > 0\n}\n\nfunction reduce_by_divisor(n: nat, d: nat): nat\n  requires n > 0 && d > 1\n  decreases n\n{\n  if n % d == 0 && n >= d then \n    reduce_by_divisor(n / d, d)\n  else n\n}\n\nfunction count_divisors(n: nat): nat\n  requires n > 0\n{\n  |set d | 1 <= d <= n && n % d == 0|\n}\n\nfunction count_special_divisors(n: nat): nat\n  requires n > 0\n{\n  |set d | 2 <= d <= n && n % d == 0 && (reduce_by_divisor(n, d) - 1) % d == 0|\n}\n\nfunction count_valid_k_values(n: nat): int\n  requires n > 0\n{\n  if n == 1 then -1\n  else \n    count_divisors(n - 1) + count_special_divisors(n) - 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat) returns (result: int)\n  requires ValidInput(n)\n  ensures result == count_valid_k_values(n)\n  ensures n == 1 ==> result == -1\n  ensures n > 1 ==> result == count_divisors(n - 1) + count_special_divisors(n) - 1\n  ensures result >= -1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1096", "vc-description": "Given a king's position on a standard 8\u00d78 chess board, determine the number of valid moves \nthe king can make. The position is given as a two-character string \"cd\" where 'c' is the \ncolumn ('a' to 'h') and 'd' is the row ('1' to '8'). A king can move exactly one square \nin any direction but cannot move outside the board boundaries.", "vc-preamble": "predicate ValidInput(position: string)\n{\n  |position| == 2 && 'a' <= position[0] <= 'h' && '1' <= position[1] <= '8'\n}\n\npredicate IsCorner(position: string)\n  requires ValidInput(position)\n{\n  (position[0] == 'a' || position[0] == 'h') && (position[1] == '1' || position[1] == '8')\n}\n\npredicate IsEdge(position: string)\n  requires ValidInput(position)\n{\n  (position[0] == 'a' || position[0] == 'h' || position[1] == '1' || position[1] == '8') && !IsCorner(position)\n}\n\npredicate IsInterior(position: string)\n  requires ValidInput(position)\n{\n  !IsCorner(position) && !IsEdge(position)\n}\n\nfunction ValidMoves(position: string): int\n  requires ValidInput(position)\n{\n  if IsCorner(position) then 3\n  else if IsEdge(position) then 5\n  else 8\n}", "vc-helpers": "", "vc-spec": "method solve(position: string) returns (moves: int)\n  requires ValidInput(position)\n  ensures moves == ValidMoves(position)\n  ensures IsCorner(position) ==> moves == 3\n  ensures IsEdge(position) ==> moves == 5\n  ensures IsInterior(position) ==> moves == 8\n  ensures moves == 3 || moves == 5 || moves == 8", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_11", "vc-description": "Given n tiles numbered 1 to n, paint tiles according to rules:\n- Tile can be painted Red if divisible by a (gives p chocolates)\n- Tile can be painted Blue if divisible by b (gives q chocolates)  \n- If divisible by both a and b, choose the color giving more chocolates\nFind the maximum total chocolates possible.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, p: int, q: int) {\n  n > 0 && a > 0 && b > 0 && p > 0 && q > 0\n}\n\nfunction gcd(a: int, b: int): int\n  requires a > 0 && b >= 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 then a else gcd(b, a % b)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, p: int, q: int) returns (result: int)\n  requires ValidInput(n, a, b, p, q)\n  ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1100", "vc-description": "Given a regular convex polygon with n vertices, draw rays from each vertex to all others.\nRays stop when hitting vertices or intersecting previously drawn rays, creating regions.\nA squirrel starts outside and jumps between adjacent regions to collect all walnuts.\nFind the minimum number of jumps needed.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 3\n}\n\nfunction MinJumps(n: int): int\n    requires ValidInput(n)\n{\n    (n - 2) * (n - 2)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == MinJumps(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1101", "vc-description": "Given n rooms in a row (some occupied, some free) and k cows, find k+1 free rooms to book \nsuch that when one room is assigned to Farmer John and k rooms to his cows, the maximum \ndistance from Farmer John's room to any cow's room is minimized.", "vc-preamble": "predicate isValidPlacement(rooms: string, k: int, placement: seq<int>)\n{\n    |placement| == k + 1 &&\n    (forall i :: 0 <= i < |placement| ==> 0 <= placement[i] < |rooms|) &&\n    (forall i :: 0 <= i < |placement| ==> rooms[placement[i]] == '0') &&\n    (forall i, j :: 0 <= i < j < |placement| ==> placement[i] != placement[j]) &&\n    (forall i :: 0 <= i < |placement| - 1 ==> placement[i] < placement[i+1])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, rooms: string) returns (result: int)\n    requires n > 0\n    requires k > 0 \n    requires k < n\n    requires |rooms| == n\n    requires forall i :: 0 <= i < n ==> rooms[i] == '0' || rooms[i] == '1'\n    requires |set i | 0 <= i < n && rooms[i] == '0'| >= k + 1\n    ensures result >= 0\n    ensures exists placement :: isValidPlacement(rooms, k, placement) && optimalMaxDistance(placement) == result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1102", "vc-description": "Given n cities in a row, Limak lives in city a and uses a Bear Criminal Detector (BCD) \nthat reports total criminals at each distance. He can only catch criminals where he can \ndefinitively determine their presence: at distance d with 1 city and 1 criminal reported, \nor at distance d with 2 cities and 2 criminals reported. Return total criminals caught.", "vc-preamble": "predicate ValidInput(n: int, a: int, x: seq<int>)\n{\n    n > 0 && 1 <= a <= n && |x| == n && \n    forall i :: 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n}\n\nfunction SumCriminalsCaught(n: int, a_idx: int, x: seq<int>, distance: int): int\n    requires n > 0\n    requires 0 <= a_idx < n\n    requires |x| == n\n    requires forall i :: 0 <= i < n ==> (x[i] == 0 || x[i] == 1)\n    requires distance >= 1\n    decreases n + 1 - distance\n    ensures SumCriminalsCaught(n, a_idx, x, distance) >= 0\n{\n    if distance > n then 0\n    else\n        var le := a_idx - distance;\n        var rg := a_idx + distance;\n        var le_valid := le >= 0 && le < n;\n        var rg_valid := rg >= 0 && rg < n;\n        var current_caught :=\n            if !le_valid && !rg_valid then 0\n            else if le_valid && !rg_valid then x[le]\n            else if !le_valid && rg_valid then x[rg]\n            else if le_valid && rg_valid && x[le] == 1 && x[rg] == 1 then 2\n            else 0;\n        if !le_valid && !rg_valid then current_caught\n        else current_caught + SumCriminalsCaught(n, a_idx, x, distance + 1)\n}\n\nfunction TotalCriminalsCaught(n: int, a: int, x: seq<int>): int\n    requires ValidInput(n, a, x)\n{\n    x[a-1] + SumCriminalsCaught(n, a-1, x, 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, x: seq<int>) returns (result: int)\n    requires ValidInput(n, a, x)\n    ensures result >= 0\n    ensures result == TotalCriminalsCaught(n, a, x)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1106", "vc-description": "Given a complete binary tree of depth n, find the minimum number of additional\nstreet lights needed so that all paths from entrance (node 1) to exits have\nthe same total number of lights.", "vc-preamble": "predicate ValidInput(n: int, lights: seq<int>)\n{\n    1 <= n <= 10 &&\n    |lights| == power2(n+1) - 2 &&\n    forall i :: 0 <= i < |lights| ==> 1 <= lights[i] <= 100\n}\n\nfunction power2(n: int): int\n    requires n >= 0\n    ensures power2(n) > 0\n    ensures power2(n) == if n == 0 then 1 else 2 * power2(n-1)\n{\n    if n <= 0 then 1\n    else 2 * power2(n - 1)\n}\n\nghost function dfs_result(i: int, n: int, a: seq<int>): (int, int)\n    requires 1 <= n <= 10\n    requires 1 <= i < power2(n+1)\n    requires |a| == power2(n+1)\n    requires forall j :: 2 <= j < |a| ==> 1 <= a[j] <= 100\n    requires a[0] == 0 && a[1] == 0\n    decreases power2(n+1) - i\n{\n    if i >= power2(n) then (0, 0)\n    else\n        var left := dfs_result(i * 2, n, a);\n        var right := dfs_result(i * 2 + 1, n, a);\n        var x1 := left.0; var m1 := left.1;\n        var x2 := right.0; var m2 := right.1;\n        if m1 + a[i * 2] < m2 + a[i * 2 + 1] then\n            (x1 + x2 + m2 + a[i * 2 + 1] - m1 - a[i * 2], m2 + a[i * 2 + 1])\n        else\n            (x1 + x2 + m1 + a[i * 2] - m2 - a[i * 2 + 1], m1 + a[i * 2])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, lights: seq<int>) returns (result: int)\n    requires ValidInput(n, lights)\n    ensures result >= 0\n    ensures result == dfs_result(1, n, [0, 0] + lights).0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1109", "vc-description": "Given an array of length n containing only 1s and 2s, find the minimum number of elements\nto change to make the array k-periodic. An array is k-periodic if it can be represented \nas a pattern of length k repeated exactly n/k times consecutively. The constraint is that \nn is divisible by k.", "vc-preamble": "predicate ValidInput(n: int, k: int, A: seq<int>)\n{\n  1 <= k <= n <= 100 &&\n  n % k == 0 &&\n  |A| == n &&\n  forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n}\n\nfunction CountOnesInColumn(A: seq<int>, n: int, k: int, col: int): int\n  requires 0 <= col < k <= n\n  requires n % k == 0\n  requires |A| == n\n  requires forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n{\n  |set j | 0 <= j < n && j % k == col && A[j] == 1|\n}\n\nfunction CountTwosInColumn(A: seq<int>, n: int, k: int, col: int): int\n  requires 0 <= col < k <= n\n  requires n % k == 0\n  requires |A| == n\n  requires forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n{\n  |set j | 0 <= j < n && j % k == col && A[j] == 2|\n}\n\nfunction MinChangesForColumn(A: seq<int>, n: int, k: int, col: int): int\n  requires 0 <= col < k <= n\n  requires n % k == 0\n  requires |A| == n\n  requires forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n{\n  var count1 := CountOnesInColumn(A, n, k, col);\n  var count2 := CountTwosInColumn(A, n, k, col);\n  if count1 < count2 then count1 else count2\n}\n\nfunction SumMinChangesHelper(A: seq<int>, n: int, k: int, col: int): int\n  requires 1 <= k <= n\n  requires n % k == 0\n  requires |A| == n\n  requires forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n  requires 0 <= col <= k\n  decreases k - col\n{\n  if col == k then 0\n  else MinChangesForColumn(A, n, k, col) + SumMinChangesHelper(A, n, k, col + 1)\n}\n\nfunction SumMinChangesForAllColumns(A: seq<int>, n: int, k: int): int\n  requires 1 <= k <= n\n  requires n % k == 0\n  requires |A| == n\n  requires forall i :: 0 <= i < |A| ==> A[i] == 1 || A[i] == 2\n{\n  SumMinChangesHelper(A, n, k, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, A: seq<int>) returns (result: int)\n  requires ValidInput(n, k, A)\n  ensures 0 <= result <= n\n  ensures result == SumMinChangesForAllColumns(A, n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1110", "vc-description": "Find the worst-case number of button presses needed to open a lock with n buttons.\nThe lock has a specific unknown sequence. When a button is pressed:\n- If it's the next correct button, it stays pressed\n- If it's incorrect, all pressed buttons reset\n- The lock opens when all n buttons are pressed simultaneously (sequence complete)", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction WorstCasePresses(n: int): int\n    requires ValidInput(n)\n{\n    n * (n * n + 5) / 6\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == WorstCasePresses(n)\n    ensures result >= 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1116", "vc-description": "Given three integers r, b, and k, determine if it's possible to paint planks on a fence\naccording to specific rules without creating k consecutive planks of the same color.\nPaint plank i red if i is divisible by r, blue if divisible by b, either color if \ndivisible by both, and don't paint otherwise. Return \"OBEY\" if possible to avoid\nk consecutive same-color planks, \"REBEL\" if unavoidable.", "vc-preamble": "function gcd(a: int, b: int): int\n  requires a > 0 && b >= 0\n  decreases b\n{\n  if b == 0 then a else gcd(b, a % b)\n}\n\npredicate ValidInput(r: int, b: int, k: int)\n{\n  r > 0 && b > 0 && k > 0\n}\n\nfunction MaxConsecutiveSameColor(r: int, b: int): int\n  requires r > 0 && b > 0\n{\n  var a := if r <= b then r else b;\n  var b_val := if r <= b then b else r;\n  var n := gcd(a, b_val);\n  -((n - b_val) / a)\n}\n\npredicate CanAvoidConsecutive(r: int, b: int, k: int)\n  requires ValidInput(r, b, k)\n{\n  MaxConsecutiveSameColor(r, b) < k\n}", "vc-helpers": "", "vc-spec": "method solve(r: int, b: int, k: int) returns (result: string)\n  requires ValidInput(r, b, k)\n  ensures result == (if CanAvoidConsecutive(r, b, k) then \"OBEY\" else \"REBEL\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1117", "vc-description": "Given n rectangles in a fixed order, each rectangle can be rotated 90 degrees (swapping its width and height). \nDetermine if it's possible to rotate some rectangles such that the final heights form a non-ascending sequence \n(each height \u2264 previous height).", "vc-preamble": "function canFormNonAscendingSequence(rectangles: seq<(int, int)>): bool\n{\n    if |rectangles| <= 1 then true\n    else canFormNonAscendingSequenceHelper(rectangles, 1, max(rectangles[0].0, rectangles[0].1))\n}\n\nfunction canFormNonAscendingSequenceHelper(rectangles: seq<(int, int)>, index: int, prevHeight: int): bool\n    requires 0 <= index <= |rectangles|\n    decreases |rectangles| - index\n{\n    if index >= |rectangles| then true\n    else\n        var a := rectangles[index].0;\n        var b := rectangles[index].1;\n        var minDim := min(a, b);\n        var maxDim := max(a, b);\n\n        if minDim > prevHeight then false\n        else if minDim <= prevHeight < maxDim then \n            canFormNonAscendingSequenceHelper(rectangles, index + 1, minDim)\n        else \n            canFormNonAscendingSequenceHelper(rectangles, index + 1, maxDim)\n}\n\nfunction parseRectangles(input: string): seq<(int, int)>\n{\n    var lines := split(input, '\\n');\n    if |lines| == 0 then []\n    else\n        var n := parseInt(lines[0]);\n        if n <= 0 then []\n        else parseRectanglesFromLines(lines[1..], n)\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}\n\nfunction max(a: int, b: int): int\n{\n    if a >= b then a else b\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> canFormNonAscendingSequence(parseRectangles(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1124", "vc-description": "Given N positive integers, repeatedly perform the operation: find maximum X and minimum x,\nif X != x then replace all X with (X - x), until all integers are equal.\nReturn the final common value.", "vc-preamble": "predicate ValidInput(values: seq<int>)\n{\n  |values| >= 1 && forall i :: 0 <= i < |values| ==> values[i] > 0\n}\n\nfunction gcd(a: int, b: int): int\n  requires a > 0 && b > 0\n  decreases if a >= b then a else b\n  ensures gcd(a, b) > 0\n  ensures a % gcd(a, b) == 0\n  ensures b % gcd(a, b) == 0\n  ensures forall d :: d > 0 && a % d == 0 && b % d == 0 ==> d <= gcd(a, b)\n{\n  if a == b then a\n  else if a > b then gcd(a - b, b)\n  else gcd(a, b - a)\n}\n\nfunction gcdSeq(values: seq<int>, index: int, current: int): int\n  requires 0 <= index <= |values|\n  requires current > 0\n  requires forall i :: 0 <= i < |values| ==> values[i] > 0\n  decreases |values| - index\n  ensures gcdSeq(values, index, current) > 0\n  ensures current % gcdSeq(values, index, current) == 0\n  ensures forall i :: index <= i < |values| ==> values[i] % gcdSeq(values, index, current) == 0\n  ensures forall d {:trigger current % d} :: d > 0 && current % d == 0 && (forall i :: index <= i < |values| ==> values[i] % d == 0) ==> d <= gcdSeq(values, index, current)\n{\n  if index == |values| then current\n  else gcdSeq(values, index + 1, gcd(current, values[index]))\n}\n\nfunction gcdOfAll(values: seq<int>): int\n  requires |values| >= 1\n  requires forall i :: 0 <= i < |values| ==> values[i] > 0\n  ensures gcdOfAll(values) > 0\n  ensures forall i :: 0 <= i < |values| ==> values[i] % gcdOfAll(values) == 0\n  ensures forall d {:trigger values[0] % d} :: d > 0 && (forall i :: 0 <= i < |values| ==> values[i] % d == 0) ==> d <= gcdOfAll(values)\n{\n  gcdSeq(values, 1, values[0])\n}", "vc-helpers": "", "vc-spec": "method solve(values: seq<int>) returns (result: int)\n  requires ValidInput(values)\n  ensures result > 0\n  ensures result == gcdOfAll(values)\n  ensures forall i :: 0 <= i < |values| ==> values[i] % result == 0\n  ensures forall d", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1125", "vc-description": "Given N piles of stones, two players alternate removing stones from any single pile.\nThe player unable to make a move loses. Before the game begins, the second player\ncan move between 0 and (A_1 - 1) stones from pile 1 to pile 2. Find the minimum\nnumber of stones to move to guarantee the second player wins, or output -1 if impossible.", "vc-preamble": "predicate validInput(s: string)\n{\n    var lines := splitLinesFunc(s);\n    |lines| >= 2 && \n    parseIntFunc(lines[0]) >= 2 &&\n    |parseIntArrayFunc(lines[1])| == parseIntFunc(lines[0]) &&\n    forall i :: 0 <= i < |parseIntArrayFunc(lines[1])| ==> parseIntArrayFunc(lines[1])[i] >= 1\n}\n\npredicate isValidOutput(s: string)\n{\n    s == \"-1\" || (parseIntFunc(s) >= 0)\n}\n\npredicate correctSolution(input: string, output: string)\n{\n    var lines := splitLinesFunc(input);\n    |lines| >= 2 ==>\n    var n := parseIntFunc(lines[0]);\n    var a := parseIntArrayFunc(lines[1]);\n\n    if n == 2 then\n        (output == \"-1\" <==> (a[0] < a[1] || (a[0] - a[1]) % 2 != 0)) &&\n        (output != \"-1\" ==> parseIntFunc(output) == (a[0] - a[1]) / 2)\n    else\n        var xor_rest := xorRange(a, 2, n);\n        var and_val := a[0] + a[1] - xor_rest;\n        var target_and := and_val / 2;\n\n        if and_val % 2 != 0 || a[0] < target_and || andOp(target_and, xor_rest) != 0 then\n            output == \"-1\"\n        else\n            var a0 := constructA0(target_and, xor_rest, a[0]);\n            if a0 == 0 then\n                output == \"-1\"\n            else\n                output != \"-1\" && parseIntFunc(output) == a[0] - a0\n}\n\npredicate secondPlayerWins(original_piles: seq<int>, stones_moved: int)\n  requires |original_piles| >= 2\n  requires 0 <= stones_moved < original_piles[0]\n  requires forall i :: 0 <= i < |original_piles| ==> original_piles[i] >= 0\n{\n    var new_piles := original_piles[0 := original_piles[0] - stones_moved][1 := original_piles[1] + stones_moved];\n    nimSum(new_piles) == 0\n}\n\nfunction nimSum(piles: seq<int>): int\n  requires forall i :: 0 <= i < |piles| ==> piles[i] >= 0\n  ensures nimSum(piles) >= 0\n{\n    if |piles| == 0 then 0\n    else xorOp(piles[0], nimSum(piles[1..]))\n}\n\nfunction xorOp(x: int, y: int): int\n  requires x >= 0 && y >= 0\n  ensures xorOp(x, y) >= 0\n  decreases x + y\n{\n    if x == 0 then y\n    else if y == 0 then x\n    else if x % 2 != y % 2 then 1 + 2 * xorOp(x / 2, y / 2)\n    else 2 * xorOp(x / 2, y / 2)\n}\n\nfunction andOp(x: int, y: int): int\n  requires x >= 0 && y >= 0\n  ensures andOp(x, y) >= 0\n  decreases x + y\n{\n    if x == 0 || y == 0 then 0\n    else if x % 2 == 1 && y % 2 == 1 then 1 + 2 * andOp(x / 2, y / 2)\n    else 2 * andOp(x / 2, y / 2)\n}\n\nfunction xorRange(a: seq<int>, start: int, end: int): int\n  requires 0 <= start <= end <= |a|\n  requires forall i :: 0 <= i < |a| ==> a[i] >= 0\n  ensures xorRange(a, start, end) >= 0\n  decreases end - start\n{\n    if start >= end then 0\n    else xorOp(a[start], xorRange(a, start + 1, end))\n}\n\nfunction constructA0(initial_and: int, num: int, max_pile: int): int\n  requires initial_and >= 0\n  requires num >= 0\n{\n    var max_power := findMaxPower(num);\n    constructA0Helper(initial_and, num, max_pile, max_power)\n}\n\nfunction findMaxPower(num: int): int\n  requires num >= 0\n  ensures findMaxPower(num) >= 1\n{\n    if num == 0 then 1\n    else\n        var power := 1;\n        findMaxPowerHelper(power, num)\n}\n\nfunction findMaxPowerHelper(current_power: int, num: int): int\n  requires current_power >= 1\n  requires num >= 0\n  ensures findMaxPowerHelper(current_power, num) >= 1\n  decreases if current_power > num then 0 else num + 1 - current_power\n{\n    if current_power > num then \n        if current_power / 2 >= 1 then current_power / 2 else 1\n    else findMaxPowerHelper(current_power * 2, num)\n}\n\nfunction constructA0Helper(a0: int, num: int, max_pile: int, power: int): int\n  requires a0 >= 0\n  requires num >= 0\n  requires power >= 1\n  decreases power\n{\n    if power == 1 then \n        if andOp(num, power) != 0 && a0 + power <= max_pile then a0 + power else a0\n    else\n        var new_a0 := if andOp(num, power) != 0 && a0 + power <= max_pile then a0 + power else a0;\n        if power / 2 >= 1 then constructA0Helper(new_a0, num, max_pile, power / 2) else new_a0\n}\n\nfunction splitLinesFunc(s: string): seq<string>\n{\n    [s]\n}\n\nfunction parseIntFunc(s: string): int\n{\n    0\n}\n\nfunction parseIntArrayFunc(s: string): seq<int>\n{\n    []\n}\n\nfunction intToStringFunc(n: int): string\n{\n    \"0\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires validInput(stdin_input)\n  ensures |result| > 0\n  ensures isValidOutput(result)\n  ensures result == \"-1\" || (parseIntFunc(result) >= 0)\n  ensures correctSolution(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_113", "vc-description": "Find the minimum positive integer x such that x is divisible by n and x ends with k or more zeros in base 10.\nA number ends with k zeros if and only if it's divisible by 10^k = 2^k \u00d7 5^k.\nAlgorithm: Factor out powers of 2 and 5 from n, then multiply n by additional factors needed to achieve k trailing zeros.", "vc-preamble": "function power(base: int, exp: int): int\n    requires exp >= 0\n    ensures exp == 0 ==> power(base, exp) == 1\n    ensures base > 0 ==> power(base, exp) > 0\n    ensures base != 0 ==> power(base, exp) != 0\n    decreases exp\n{\n    if exp == 0 then 1\n    else base * power(base, exp - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires n > 0 && k >= 0\n    ensures result > 0\n    ensures result % n == 0\n    ensures result % power(10, k) == 0\n    ensures forall m :: m > 0 && m % n == 0 && m % power(10, k) == 0 ==> result <= m", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1134", "vc-description": "Given n consecutive days of river observations where on day i there are m_i marks \nstrictly above the current water level, find the minimum possible sum of d_i over \nall n days, where d_i is the number of marks strictly below the water level on day i.\nEach day a mark is made at the current water level, marks never wash away, and the\ntotal number of marks can only stay the same or increase each day.", "vc-preamble": "predicate ValidInput(n: int, m: seq<int>) {\n    n > 0 && |m| == n && \n    forall i :: 0 <= i < n ==> 0 <= m[i] < i + 1\n}\n\npredicate ValidSolution(n: int, m: seq<int>, dm: seq<int>) {\n    |dm| == n && |m| == n &&\n    (forall i :: 0 <= i < n ==> dm[i] >= m[i] + 1) &&\n    (forall i :: 0 <= i < n - 1 ==> dm[i] <= dm[i + 1])\n}\n\nfunction SumBelow(m: seq<int>, dm: seq<int>): int\n    requires |m| == |dm|\n{\n    if |m| == 0 then 0\n    else (dm[0] - 1 - m[0]) + SumBelow(m[1..], dm[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: seq<int>) returns (result: int)\n    requires ValidInput(n, m)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1135", "vc-description": "Decode a string that was encoded by repeatedly extracting median characters.\nThe decoding process inserts each character from the encoded string back into\nits proper median position in the reconstructed word.", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n    n >= 1 && n <= 2000 && |s| == n && \n    forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\npredicate ValidOutput(result: string, n: int)\n{\n    |result| == n && \n    forall i :: 0 <= i < |result| ==> 'a' <= result[i] <= 'z'\n}\n\npredicate PreservesCharacters(s: string, result: string)\n{\n    multiset(s) == multiset(result)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: string)\n    requires ValidInput(n, s)\n    ensures ValidOutput(result, n)\n    ensures PreservesCharacters(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1138", "vc-description": "Given a string of movement directions ('L', 'R', 'U', 'D'), determine the minimum number \nof character changes needed so that following the directions returns to the starting position.\nReturn -1 if impossible (when string length is odd).", "vc-preamble": "predicate ValidInput(s: string) {\n    forall i :: 0 <= i < |s| ==> s[i] == 'L' || s[i] == 'R' || s[i] == 'U' || s[i] == 'D'\n}\n\nfunction abs(x: int): int\n    ensures abs(x) >= 0\n    ensures abs(x) == x || abs(x) == -x\n{\n    if x >= 0 then x else -x\n}\n\nfunction countChar(s: string, c: char): int\n    requires 0 <= |s|\n    ensures 0 <= countChar(s, c) <= |s|\n    ensures countChar(s, c) == countCharHelper(s, c, 0, 0)\n{\n    countCharHelper(s, c, 0, 0)\n}\n\nfunction countCharHelper(s: string, c: char, index: int, count: int): int\n    requires 0 <= index <= |s|\n    requires count >= 0\n    requires count + (|s| - index) >= 0\n    decreases |s| - index\n    ensures countCharHelper(s, c, index, count) >= count\n    ensures countCharHelper(s, c, index, count) <= count + (|s| - index)\n{\n    if index == |s| then count\n    else if s[index] == c then countCharHelper(s, c, index + 1, count + 1)\n    else countCharHelper(s, c, index + 1, count)\n}\n\nfunction countCharFromIndex(s: string, c: char, index: int): int\n    requires 0 <= index <= |s|\n    ensures 0 <= countCharFromIndex(s, c, index) <= |s| - index\n    decreases |s| - index\n{\n    if index == |s| then 0\n    else if s[index] == c then 1 + countCharFromIndex(s, c, index + 1)\n    else countCharFromIndex(s, c, index + 1)\n}\n\npredicate CorrectResult(s: string, result: int) {\n    (|s| % 2 != 0 ==> result == -1) &&\n    (|s| % 2 == 0 ==> result >= 0) &&\n    (|s| % 2 == 0 ==> result <= |s| / 2) &&\n    (|s| % 2 == 0 ==> result == (abs(countChar(s, 'L') - countChar(s, 'R')) + abs(countChar(s, 'U') - countChar(s, 'D'))) / 2)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures CorrectResult(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_114", "vc-description": "Given an n\u00d7m matrix A containing only 0s and 1s, and matrix B initially all zeros.\nYou can perform operations on B: choose integers x, y where 1 \u2264 x < n and 1 \u2264 y < m,\nthen set B[x,y], B[x,y+1], B[x+1,y], and B[x+1,y+1] to 1.\nDetermine if B can be made equal to A, and if so, provide a sequence of operations.", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n  |input| > 0 && input[|input|-1] == '\\n' &&\n  exists lines: seq<string> ::\n    lines == SplitLines(input) &&\n    |lines| >= 3 &&\n    ValidDimensionLine(lines[0]) &&\n    (var parsed := ParseDimensions(lines[0]);\n     var n, m := parsed.0, parsed.1;\n     |lines| == n + 1 && 2 <= n <= 50 && 2 <= m <= 50 &&\n     (forall i :: 1 <= i <= n ==> ValidMatrixRow(lines[i], m)) &&\n     (forall i :: 1 <= i <= n ==> \n       forall j :: 1 <= j <= m ==> \n         ParseMatrixElement(lines[i], j) in {0, 1}))\n}\n\npredicate ValidOperationSequence(output: string, original_input: string)\n{\n  |output| > 0 && output[|output|-1] == '\\n' &&\n  exists lines: seq<string> ::\n    lines == SplitLines(output) &&\n    |lines| >= 1 &&\n    ValidNumber(lines[0]) &&\n    (var k := ParseNumber(lines[0]);\n     0 <= k <= 2500 &&\n     |lines| == k + 1 &&\n     (var parsed := ParseInput(original_input);\n      var n, m := parsed.0, parsed.1;\n      forall i :: 1 <= i <= k ==> ValidCoordinatePair(lines[i], n-1, m-1)))\n}\n\npredicate ValidDimensionLine(line: string) { |line| > 0 }\npredicate ValidMatrixRow(line: string, m: int) { |line| > 0 && m > 0 }\npredicate ValidNumber(s: string) { |s| > 0 }\npredicate ValidCoordinatePair(s: string, maxX: int, maxY: int) { |s| > 0 && maxX > 0 && maxY > 0 }\n\nfunction SplitLines(s: string): seq<string> { [s] }\nfunction ParseDimensions(line: string): (int, int) { (2, 2) }\nfunction ParseNumber(s: string): int { 0 }\nfunction ParseInput(input: string): (int, int, seq<seq<int>>) { (2, 2, [[0, 0], [0, 0]]) }\nfunction ParseOperations(output: string): seq<(int,int)> { [] }\nfunction ParseMatrixElement(line: string, pos: int): int { 0 }\nfunction ToString(n: int): string { \"0\" }\n\nfunction ApplyGreedyAlgorithm(n: int, m: int, A: seq<seq<int>>): (seq<seq<int>>, seq<(int,int)>)\n  requires 2 <= n <= 50 && 2 <= m <= 50\n  requires |A| == n && forall i :: 0 <= i < n ==> |A[i]| == m\n  requires forall i, j :: 0 <= i < n && 0 <= j < m ==> A[i][j] in {0, 1}\n{\n  var B := seq(n, i => seq(m, j => 0));\n  var ops := [];\n  GreedyStep(A, B, ops, 0, 0, n, m)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires ValidInputFormat(stdin_input)\n  ensures |result| > 0\n  ensures result == \"-1\\n\" || ValidOperationSequence(result, stdin_input)\n  ensures result != \"-1\\n\" ==> \n    (var parsed := ParseInput(stdin_input);\n     var n, m, A := parsed.0, parsed.1, parsed.2;\n     var ops := ParseOperations(result);\n     var algorithm_result := ApplyGreedyAlgorithm(n, m, A);\n     var B := algorithm_result.0;\n     var expected_ops := algorithm_result.1;\n     B == A && ops == expected_ops)\n  ensures result == \"-1\\n\" ==> \n    (var parsed := ParseInput(stdin_input);\n     var n, m, A := parsed.0, parsed.1, parsed.2;\n     var algorithm_result := ApplyGreedyAlgorithm(n, m, A);\n     var B := algorithm_result.0;\n     B != A)\n  ensures result == \"-1\\n\" || \n    (exists k: nat, lines: seq<string> :: \n      lines == SplitLines(result) && \n      |lines| == k + 1 && \n      lines[0] == ToString(k) && k <= 2500 &&\n      (var parsed := ParseInput(stdin_input);\n       var n, m := parsed.0, parsed.1;\n       forall i :: 1 <= i <= k ==> \n         (exists x, y: int :: (1 <= x <= n-1 && 1 <= y <= m-1 && \n          lines[i] == ToString(x) + \" \" + ToString(y)))))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1142", "vc-description": "Given a gun with magazine size k and n waves of monsters, find the minimum total bullets\nneeded to clear all waves. Each wave i has monsters that spawn at time l_i and must be\nkilled by time r_i. Shooting kills one monster instantly, reloading takes 1 time unit\nand discards remaining bullets. Waves are non-overlapping and chronological.\nReturn -1 if impossible.", "vc-preamble": "datatype Wave = Wave(start_time: nat, end_time: nat, monsters: nat)\n\npredicate ValidWaves(waves: seq<Wave>)\n{\n    forall i :: 0 <= i < |waves| ==> \n        waves[i].start_time <= waves[i].end_time &&\n        waves[i].monsters > 0 &&\n        (i > 0 ==> waves[i-1].end_time <= waves[i].start_time)\n}\n\npredicate CanSolveAllWaves(waves: seq<Wave>, k: nat)\n{\n    k > 0 && \n    forall i :: 0 <= i < |waves| ==> \n        CanSolveWave(waves, i, k)\n}\n\npredicate CanSolveWave(waves: seq<Wave>, waveIndex: nat, k: nat)\n    requires waveIndex < |waves|\n    requires k > 0\n{\n    var wave := waves[waveIndex];\n    var timeAvailable := wave.end_time - wave.start_time + 1;\n    var maxPossibleShots := timeAvailable * k;\n    wave.monsters <= maxPossibleShots &&\n    (waveIndex == 0 || CanReachWaveInTime(waves, waveIndex, k))\n}\n\npredicate CanReachWaveInTime(waves: seq<Wave>, waveIndex: nat, k: nat)\n    requires waveIndex > 0 && waveIndex < |waves|\n    requires k > 0\n{\n    var prevWave := waves[waveIndex - 1];\n    var currWave := waves[waveIndex];\n    var timeGap := currWave.start_time - prevWave.end_time;\n    var reloadsNeeded := CalculateReloadsNeeded(prevWave.monsters, k);\n    reloadsNeeded <= timeGap\n}\n\nfunction CalculateReloadsNeeded(monsters: nat, k: nat): nat\n    requires k > 0\n{\n    if monsters <= k then 0\n    else (monsters - 1) / k\n}\n\nfunction CalculateMinimumBullets(waves: seq<Wave>, k: nat): nat\n    requires k > 0\n    requires ValidWaves(waves)\n    requires CanSolveAllWaves(waves, k)\n    ensures |waves| > 0 ==> CalculateMinimumBullets(waves, k) > 0\n{\n    CalculateMinimumBulletsHelper(waves, k, 0, k)\n}", "vc-helpers": "", "vc-spec": "method SolveMonsterWaves(waves: seq<Wave>, k: nat) returns (result: int)\n    requires ValidWaves(waves)\n    requires k > 0\n    ensures result == -1 <==> !CanSolveAllWaves(waves, k)\n    ensures result >= 0 <==> CanSolveAllWaves(waves, k)\n    ensures CanSolveAllWaves(waves, k) ==> result == CalculateMinimumBullets(waves, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1146", "vc-description": "Given n buttons and m bulbs, where each button can turn on a specific subset of bulbs,\ndetermine if it's possible to turn on all m bulbs by pressing some combination of buttons.\nReturn \"YES\" if all bulbs can be turned on, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(n: nat, m: nat, buttons: seq<seq<nat>>)\n{\n    |buttons| == n &&\n    n >= 1 && m >= 1 &&\n    forall i :: 0 <= i < n ==> forall j :: 0 <= j < |buttons[i]| ==> 1 <= buttons[i][j] <= m\n}\n\nfunction unionOfAllBulbs(buttons: seq<seq<nat>>): set<nat>\n{\n    set i, j | 0 <= i < |buttons| && 0 <= j < |buttons[i]| :: buttons[i][j]\n}\n\npredicate CanTurnOnAllBulbs(m: nat, buttons: seq<seq<nat>>)\n{\n    |unionOfAllBulbs(buttons)| == m\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, m: nat, buttons: seq<seq<nat>>) returns (result: string)\n    requires ValidInput(n, m, buttons)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanTurnOnAllBulbs(m, buttons)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1149", "vc-description": "Given n levels in a game, determine if two players can together pass all levels.\nPlayer X can pass a specific set of levels, and Player Y can pass a specific set of levels.\nCheck if the union of their passable levels covers all levels from 1 to n.\nOutput \"I become the guy.\" if they can pass all levels together, otherwise \"Oh, my keyboard!\".", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    var lines := split_lines(stdin_input);\n    |lines| >= 3 && \n    var n := parse_int(lines[0]);\n    var x_line := parse_int_list(lines[1]);\n    var y_line := parse_int_list(lines[2]);\n    n >= 1 && |x_line| > 0 && |y_line| > 0 &&\n    x_line[0] >= 0 && y_line[0] >= 0 &&\n    |x_line| >= 1 + x_line[0] && |y_line| >= 1 + y_line[0]\n}\n\nfunction GetExpectedOutput(stdin_input: string): string\n    requires ValidInput(stdin_input)\n{\n    var lines := split_lines(stdin_input);\n    var n := parse_int(lines[0]);\n    var x_line := parse_int_list(lines[1]);\n    var y_line := parse_int_list(lines[2]);\n    var x_levels := set_from_seq(x_line[1..1+x_line[0]]);\n    var y_levels := set_from_seq(y_line[1..1+y_line[0]]);\n    var all_levels := x_levels + y_levels;\n    var required_levels := set i {:trigger} | 1 <= i <= n :: i;\n    if all_levels >= required_levels then \"I become the guy.\" else \"Oh, my keyboard!\"\n}\n\nfunction set_from_seq(s: seq<int>): set<int>\n{\n    set x | x in s\n}\n\nfunction split_lines(s: string): seq<string>\n    decreases |s|\n{\n    if |s| == 0 then []\n    else\n        var newline_pos := find_char(s, '\\n');\n        if newline_pos == -1 then [trim(s)]\n        else if 0 <= newline_pos < |s| then \n            [trim(s[0..newline_pos])] + split_lines(s[newline_pos+1..])\n        else [trim(s)]\n}\n\nfunction trim(s: string): string\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == '\\r' then s[0..|s|-1]\n    else s\n}\n\nfunction find_char(s: string, c: char): int\n    ensures find_char(s, c) == -1 || (0 <= find_char(s, c) < |s|)\n    decreases |s|\n{\n    if |s| == 0 then -1\n    else if s[0] == c then 0\n    else\n        var rest := find_char(s[1..], c);\n        if rest == -1 then -1 else rest + 1\n}\n\nfunction parse_int(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then \n        if is_valid_digits(s[1..]) then -parse_int_helper(s[1..]) else 0\n    else if is_valid_digits(s) then parse_int_helper(s) else 0\n}\n\npredicate is_valid_digits(s: string) {\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction parse_int_helper(s: string): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    decreases |s|\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then char_to_digit(s[0])\n    else parse_int_helper(s[0..|s|-1]) * 10 + char_to_digit(s[|s|-1])\n}\n\nfunction char_to_digit(c: char): int\n    requires '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}\n\nfunction parse_int_list(s: string): seq<int>\n{\n    var parts := split_by_char(s, ' ');\n    seq(|parts|, i requires 0 <= i < |parts| => parse_int(parts[i]))\n}\n\nfunction split_by_char(s: string, delimiter: char): seq<string>\n    decreases |s|\n{\n    if |s| == 0 then []\n    else\n        var delim_pos := find_char(s, delimiter);\n        if delim_pos == -1 then [s]\n        else if delim_pos == 0 then split_by_char(s[1..], delimiter)\n        else if 0 < delim_pos < |s| then \n            [s[0..delim_pos]] + split_by_char(s[delim_pos+1..], delimiter)\n        else [s]\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures result == GetExpectedOutput(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1150", "vc-description": "Given n regiments, each with 4 moles. Each mole has current position (x,y) and home position (a,b).\nA move rotates a mole's current position 90\u00b0 counter-clockwise around its home position.\nA regiment is compact if its 4 moles form a square with non-zero area.\nFind minimum moves needed to make each regiment compact, or -1 if impossible.\n\n// Simplified square check - just check if points form any valid square\n\n// Check if we have 4 equal sides and 2 equal diagonals\n\n// Simplified - just check if total moves is reasonable", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n'\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| > 0 && output[|output|-1] == '\\n'\n}\n\npredicate ValidMole(mole: (int, int, int, int))\n{\n    var (x, y, a, b) := mole;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000 &&\n    -10000 <= a <= 10000 && -10000 <= b <= 10000\n}\n\npredicate ValidRegiment(moles: seq<(int, int, int, int)>)\n{\n    |moles| == 4 && forall i :: 0 <= i < 4 ==> ValidMole(moles[i])\n}\n\nfunction RotatePoint(x: int, y: int, centerX: int, centerY: int, times: nat): (int, int)\n{\n    var dx := x - centerX;\n    var dy := y - centerY;\n    var rotations := times % 4;\n    if rotations == 0 then (x, y)\n    else if rotations == 1 then (centerX - dy, centerY + dx)\n    else if rotations == 2 then (centerX - dx, centerY - dy)\n    else (centerX + dy, centerY - dx)\n}\n\nfunction DistanceSquared(p1: (int, int), p2: (int, int)): nat\n{\n    var (x1, y1) := p1;\n    var (x2, y2) := p2;\n    var dx := x1 - x2;\n    var dy := y1 - y2;\n    var dxAbs: nat := if dx >= 0 then dx as nat else (-dx) as nat;\n    var dyAbs: nat := if dy >= 0 then dy as nat else (-dy) as nat;\n    dxAbs * dxAbs + dyAbs * dyAbs\n}\n\npredicate IsSquare(points: seq<(int, int)>)\n    requires |points| == 4\n{\n\n    var p0 := points[0];\n    var p1 := points[1];\n    var p2 := points[2];\n    var p3 := points[3];\n    var d01 := DistanceSquared(p0, p1);\n    var d02 := DistanceSquared(p0, p2);\n    var d03 := DistanceSquared(p0, p3);\n    var d12 := DistanceSquared(p1, p2);\n    var d13 := DistanceSquared(p1, p3);\n    var d23 := DistanceSquared(p2, p3);\n\n    d01 > 0 && (\n        (d01 == d02 && d13 == d23 && d03 == d12 && d03 == 2 * d01) ||\n        (d01 == d03 && d12 == d23 && d02 == d13 && d02 == 2 * d01) ||\n        (d01 == d12 && d03 == d23 && d02 == d13 && d02 == 2 * d01) ||\n        (d01 == d13 && d02 == d23 && d03 == d12 && d03 == 2 * d01) ||\n        (d01 == d23 && d02 == d13 && d03 == d12 && d03 == 2 * d01)\n    )\n}\n\npredicate CanFormSquareWithMoves(moles: seq<(int, int, int, int)>, totalMoves: nat)\n    requires ValidRegiment(moles)\n{\n    totalMoves <= 12\n\n}\n\nfunction GetPositionsAfterMoves(moles: seq<(int, int, int, int)>, moves0: nat, moves1: nat, moves2: nat, moves3: nat): seq<(int, int)>\n    requires |moles| == 4\n{\n    var (x0, y0, a0, b0) := moles[0];\n    var (x1, y1, a1, b1) := moles[1];\n    var (x2, y2, a2, b2) := moles[2];\n    var (x3, y3, a3, b3) := moles[3];\n    [\n        RotatePoint(x0, y0, a0, b0, moves0),\n        RotatePoint(x1, y1, a1, b1, moves1),\n        RotatePoint(x2, y2, a2, b2, moves2),\n        RotatePoint(x3, y3, a3, b3, moves3)\n    ]\n}\n\nfunction IsAllDigits(s: string): bool\n{\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction StringToNat(s: string): nat\n    requires IsAllDigits(s)\n    requires |s| > 0\n{\n    if |s| == 1 then (s[0] as int) - ('0' as int)\n    else StringToNat(s[..|s|-1]) * 10 + ((s[|s|-1] as int) - ('0' as int))\n}\n\nfunction NatToString(n: nat): string\n    requires n <= 12\n    ensures IsAllDigits(NatToString(n))\n    ensures |NatToString(n)| > 0\n    ensures StringToNat(NatToString(n)) == n\n{\n    if n == 0 then \"0\"\n    else if n == 1 then \"1\"\n    else if n == 2 then \"2\"\n    else if n == 3 then \"3\"\n    else if n == 4 then \"4\"\n    else if n == 5 then \"5\"\n    else if n == 6 then \"6\"\n    else if n == 7 then \"7\"\n    else if n == 8 then \"8\"\n    else if n == 9 then \"9\"\n    else if n == 10 then \"10\"\n    else if n == 11 then \"11\"\n    else \"12\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_116", "vc-description": "Given two time intervals [l1, r1] and [l2, r2], and a specific minute k,\nfind the number of minutes in the intersection of these intervals,\nexcluding minute k if it falls within the intersection.", "vc-preamble": "predicate ValidInput(l1: int, r1: int, l2: int, r2: int, k: int) {\n    l1 <= r1 && l2 <= r2\n}\n\nfunction IntersectionLeft(l1: int, l2: int): int {\n    if l1 > l2 then l1 else l2\n}\n\nfunction IntersectionRight(r1: int, r2: int): int {\n    if r1 < r2 then r1 else r2\n}\n\nfunction IntersectionSize(l1: int, r1: int, l2: int, r2: int): int {\n    var left := IntersectionLeft(l1, l2);\n    var right := IntersectionRight(r1, r2);\n    if right - left + 1 > 0 then right - left + 1 else 0\n}\n\npredicate KInIntersection(l1: int, r1: int, l2: int, r2: int, k: int) {\n    var left := IntersectionLeft(l1, l2);\n    var right := IntersectionRight(r1, r2);\n    left <= k <= right\n}\n\nfunction ExpectedResult(l1: int, r1: int, l2: int, r2: int, k: int): int {\n    var intersection_size := IntersectionSize(l1, r1, l2, r2);\n    if KInIntersection(l1, r1, l2, r2, k) then\n        if intersection_size - 1 > 0 then intersection_size - 1 else 0\n    else\n        intersection_size\n}", "vc-helpers": "", "vc-spec": "method solve(l1: int, r1: int, l2: int, r2: int, k: int) returns (result: int)\n    requires ValidInput(l1, r1, l2, r2, k)\n    ensures result == ExpectedResult(l1, r1, l2, r2, k)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1165", "vc-description": "Given an array of n integers and m queries, for each query find any position \nwithin a specified range where the array value differs from a given target value.\nOutput the position (1-indexed) or -1 if no such position exists.", "vc-preamble": "predicate ValidInput(n: int, m: int, A: seq<int>, queries: seq<(int, int, int)>)\n{\n    n > 0 && m >= 0 && |A| == n && |queries| == m &&\n    forall q :: q in queries ==> 1 <= q.0 <= q.1 <= n\n}\n\npredicate ValidResult(A: seq<int>, queries: seq<(int, int, int)>, result: seq<int>)\n{\n    |result| == |queries| &&\n    forall i :: 0 <= i < |queries| ==> (\n        var l, r, x := queries[i].0, queries[i].1, queries[i].2;\n        (result[i] == -1 ==> (forall j :: l <= j <= r ==> 0 <= j-1 < |A| && A[j-1] == x)) &&\n        (result[i] != -1 ==> l <= result[i] <= r && 0 <= result[i]-1 < |A| && A[result[i]-1] != x)\n    )\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, A: seq<int>, queries: seq<(int, int, int)>) returns (result: seq<int>)\n    requires ValidInput(n, m, A, queries)\n    ensures ValidResult(A, queries, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1176", "vc-description": "Given N integers in a row, find the maximum possible sum after performing operations\nwhere each operation chooses an index i and multiplies both A[i] and A[i+1] by -1.", "vc-preamble": "function sum_seq(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum_seq(s[1..])\n}\n\nfunction min_seq(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0] else \n        var rest_min := min_seq(s[1..]);\n        if s[0] <= rest_min then s[0] else rest_min\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: int)\n    requires |a| >= 2\n    ensures var count_neg := |set i | 0 <= i < |a| && a[i] < 0|;\n            var sum_abs := sum_seq(seq(|a|, i requires 0 <= i < |a| => if a[i] < 0 then -a[i] else a[i]));\n            var min_abs := min_seq(seq(|a|, i requires 0 <= i < |a| => if a[i] < 0 then -a[i] else a[i]));\n            result == if count_neg % 2 == 0 then sum_abs else sum_abs - 2 * min_abs", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1177", "vc-description": "Given a sequence of N integers and a positive integer S, calculate the sum of f(L,R) \nover all pairs (L,R) where 1 \u2264 L \u2264 R \u2264 N. For each pair (L,R), f(L,R) is the number \nof increasing subsequences with sum equal to S within the range [L,R].", "vc-preamble": "predicate ValidInput(N: int, S: int, A: seq<int>)\n{\n    N >= 1 && S >= 1 && |A| == N && N <= 3000 && S <= 3000 &&\n    forall i :: 0 <= i < N ==> A[i] >= 1 && A[i] <= 3000\n}\n\npredicate ValidResult(result: int)\n{\n    result >= 0 && result < 998244353\n}\n\npredicate AllElementsGreaterThanS(A: seq<int>, S: int)\n{\n    forall i :: 0 <= i < |A| ==> A[i] > S\n}\n\nfunction SingleElementCase(N: int, S: int, A: seq<int>): int\n    requires N == 1 && |A| == 1\n{\n    if S == A[0] then 1 else 0\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, S: int, A: seq<int>) returns (result: int)\n    requires ValidInput(N, S, A)\n    ensures ValidResult(result)\n    ensures result % 998244353 == result\n    ensures (N == 1 && S == A[0]) ==> result == SingleElementCase(N, S, A)\n    ensures (N == 1 && S != A[0]) ==> result == SingleElementCase(N, S, A)\n    ensures AllElementsGreaterThanS(A, S) ==> result == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1179", "vc-description": "Given n robots with unique identifiers, they play a game where robot i says identifiers\nof robots 1 through i. Find the k-th identifier pronounced in the entire sequence.", "vc-preamble": "predicate ValidInput(n: int, k: int, L: seq<int>)\n{\n  n >= 1 && k >= 1 && |L| == n && k <= n * (n + 1) / 2\n}\n\nfunction TotalIdentifiersAfterRobot(i: int): int\n  requires i >= 0\n{\n  i * (i + 1) / 2\n}\n\npredicate CorrectResult(n: int, k: int, L: seq<int>, result: int)\n  requires ValidInput(n, k, L)\n{\n  exists i :: 1 <= i <= n && \n    TotalIdentifiersAfterRobot(i - 1) < k <= TotalIdentifiersAfterRobot(i) &&\n    result == L[k - TotalIdentifiersAfterRobot(i - 1) - 1]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, L: seq<int>) returns (result: int)\n  requires ValidInput(n, k, L)\n  ensures CorrectResult(n, k, L, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1195", "vc-description": "Given a list of n integers, compute 2 + (third_element XOR smallest_element), where:\n- third_element is the element at index 2 (third position) in the original list\n- smallest_element is the minimum value in the list\n- XOR is the bitwise exclusive OR operation", "vc-preamble": "predicate ValidInput(lst: seq<int>) {\n  5 <= |lst| <= 10 &&\n  forall i :: 0 <= i < |lst| ==> 1 <= lst[i] <= 32\n}\n\nfunction int_xor(a: int, b: int): int\n  requires 1 <= a <= 32 && 1 <= b <= 32\n{\n  var a_bv := a as bv32;\n  var b_bv := b as bv32;\n  (a_bv ^ b_bv) as int\n}\n\nfunction min_of_sequence(s: seq<int>): int\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> 1 <= s[i] <= 32\n  ensures 1 <= min_of_sequence(s) <= 32\n  ensures min_of_sequence(s) in s\n  ensures forall i :: 0 <= i < |s| ==> min_of_sequence(s) <= s[i]\n{\n  if |s| == 1 then s[0]\n  else if s[0] <= min_of_sequence(s[1..]) then s[0]\n  else min_of_sequence(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(lst: seq<int>) returns (result: int)\n  requires ValidInput(lst)\n  ensures result == 2 + int_xor(lst[2], min_of_sequence(lst))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1209", "vc-description": "Given n real numbers with sum equal to 0, construct a sequence where each element \nis either the floor or ceiling of the corresponding input number, such that the \nsum of the constructed sequence is also 0.", "vc-preamble": "predicate valid_input_format(input: string) \n{\n    |input| > 0 && contains_newline(input) && \n    has_valid_structure(input) && \n    first_line_is_valid_integer(input) &&\n    remaining_lines_are_valid_reals(input)\n}\n\npredicate input_sum_is_zero(input: string)\n{\n    has_valid_structure(input) ==> sum_of_input_reals(input) == 0.0\n}\n\npredicate valid_output_format(output: string)\n{\n    |output| >= 0 && \n    (output == \"\" || (ends_with_newline(output) && all_lines_are_integers(output)))\n}\n\npredicate output_has_correct_length(input: string, output: string)\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    count_lines(output) == get_n_from_input(input)\n}\n\npredicate each_output_is_floor_or_ceiling(input: string, output: string)\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall i :: 0 <= i < get_n_from_input(input) ==>\n        var input_val := get_ith_real(input, i);\n        var output_val := get_ith_integer(output, i);\n        output_val == floor_of(input_val) || output_val == ceiling_of(input_val)\n}\n\npredicate output_sum_is_zero(input: string, output: string)\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    sum_of_output_integers(output) == 0\n}\n\npredicate output_preserves_integers(input: string, output: string)\n{\n    has_valid_structure(input) && has_valid_structure(output) ==>\n    forall i :: 0 <= i < get_n_from_input(input) ==>\n        var input_val := get_ith_real(input, i);\n        is_integer(input_val) ==> get_ith_integer(output, i) == int_value_of(input_val)\n}\n\npredicate contains_newline(s: string)\n{\n    exists i :: 0 <= i < |s| && s[i] == '\\n'\n}\n\npredicate ends_with_newline(s: string)\n{\n    |s| > 0 && s[|s|-1] == '\\n'\n}\n\npredicate has_valid_structure(s: string) { true }\npredicate first_line_is_valid_integer(s: string) { true }\npredicate remaining_lines_are_valid_reals(s: string) { true }\npredicate all_lines_are_integers(s: string) { true }\npredicate is_integer(r: real) { true }\n\nfunction sum_of_input_reals(input: string): real { 0.0 }\nfunction sum_of_output_integers(output: string): int { 0 }\nfunction get_n_from_input(input: string): nat { 1 }\nfunction count_lines(s: string): nat { if s == \"0\\n\" then 1 else 0 }\nfunction get_ith_real(input: string, i: nat): real { 0.0 }\nfunction get_ith_integer(output: string, i: nat): int { 0 }\nfunction floor_of(r: real): int { 0 }\nfunction ceiling_of(r: real): int { 0 }\nfunction int_value_of(r: real): int { 0 }", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires |stdin_input| > 0\n    requires valid_input_format(stdin_input)\n    requires input_sum_is_zero(stdin_input)\n    ensures valid_output_format(output)\n    ensures output_has_correct_length(stdin_input, output)\n    ensures each_output_is_floor_or_ceiling(stdin_input, output)\n    ensures output_sum_is_zero(stdin_input, output)\n    ensures output_preserves_integers(stdin_input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1211", "vc-description": "Given N hamsters and K types of boxes with capacities, find which single box type\nto buy (and how many boxes) to transport the maximum number of hamsters.\nEach box must be completely filled.", "vc-preamble": "predicate ValidInput(n: int, k: int, A: seq<int>)\n{\n    k > 0 && |A| == k && (forall i :: 0 <= i < k ==> A[i] > 0) && n >= 0\n}\n\nfunction HamstersTransported(n: int, capacity: int): int\n    requires capacity > 0\n{\n    capacity * (n / capacity)\n}\n\npredicate OptimalSolution(n: int, A: seq<int>, box_type: int, num_boxes: int)\n    requires ValidInput(n, |A|, A)\n    requires 1 <= box_type <= |A|\n{\n    num_boxes == n / A[box_type - 1] &&\n    forall i :: 0 <= i < |A| ==> HamstersTransported(n, A[box_type - 1]) >= HamstersTransported(n, A[i])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, A: seq<int>) returns (box_type: int, num_boxes: int)\n    requires ValidInput(n, k, A)\n    ensures 1 <= box_type <= k\n    ensures num_boxes >= 0\n    ensures OptimalSolution(n, A, box_type, num_boxes)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1212", "vc-description": "Given a fence with n planks of heights, find k consecutive planks with the minimum sum of heights.\nReturn the 1-indexed starting position of such a sequence. If multiple solutions exist, return any valid one.", "vc-preamble": "function sum_window(heights: seq<int>, start: int, k: int): int\n  requires 0 <= start\n  requires start + k <= |heights|\n  requires k > 0\n  decreases k\n{\n  if k == 1 then heights[start]\n  else heights[start] + sum_window(heights, start + 1, k - 1)\n}\n\npredicate ValidInput(n: int, k: int, heights: seq<int>)\n{\n  1 <= k <= n && |heights| == n && forall i :: 0 <= i < n ==> 1 <= heights[i] <= 100\n}\n\npredicate ValidResult(result: int, n: int, k: int, heights: seq<int>)\n  requires ValidInput(n, k, heights)\n{\n  1 <= result <= n-k+1 &&\n  forall start :: 0 <= start <= n-k ==> \n    sum_window(heights, result-1, k) <= sum_window(heights, start, k) &&\n  forall start :: 0 <= start < result-1 ==>\n    sum_window(heights, start, k) > sum_window(heights, result-1, k)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, heights: seq<int>) returns (result: int)\n  requires ValidInput(n, k, heights)\n  ensures ValidResult(result, n, k, heights)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1218", "vc-description": "Find the minimum number of splitters needed to transform 1 pipe into n pipes.\nAvailable splitters have 2, 3, 4, ..., k outputs respectively.\nEach splitter takes 1 input pipe and produces multiple output pipes.\nReturn -1 if impossible.", "vc-preamble": "predicate ValidInput(n: int, k: int) {\n    n >= 1 && k >= 2\n}\n\nfunction ImpossibilityCondition(n: int, k: int): bool\n    requires ValidInput(n, k)\n{\n    2 * (n - 1) - k * (k - 1) > 0\n}\n\npredicate ValidSolution(n: int, k: int, result: int)\n    requires ValidInput(n, k)\n{\n    if ImpossibilityCondition(n, k) then\n        result == -1\n    else\n        result >= 0 && result <= k &&\n        exists x: int :: \n            x >= 0 && \n            x * x - x + (2 * (n - 1) - k * (k - 1)) <= 0 && \n            (x == 0 || (x + 1) * (x + 1) - (x + 1) + (2 * (n - 1) - k * (k - 1)) > 0) &&\n            result == k - x\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures result >= -1\n    ensures (result == -1) <==> ImpossibilityCondition(n, k)\n    ensures ValidSolution(n, k, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1225", "vc-description": "Given a monster with initial health H, find the minimum number of attacks needed to defeat it.\nAttack rules: If health is 1, monster dies. If health > 1, monster splits into two monsters\nwith health floor(X/2). Goal is to make all monsters have health <= 0.", "vc-preamble": "predicate ValidInput(h: int) {\n    h >= 1\n}\n\nfunction ComputeAttacks(h: int): int\n    requires h >= 0\n    ensures h == 0 ==> ComputeAttacks(h) == 0\n    ensures h > 0 ==> ComputeAttacks(h) > 0\n{\n    ComputeAttacksIterative(h, 0)\n}\n\nfunction ComputeAttacksIterative(h: int, n: int): int\n    requires h >= 0 && n >= 0\n    ensures h == 0 ==> ComputeAttacksIterative(h, n) == 0\n    ensures h > 0 ==> ComputeAttacksIterative(h, n) > 0\n{\n    if h == 0 then 0\n    else pow2(n) + ComputeAttacksIterative(h / 2, n + 1)\n}\n\nfunction pow2(n: int) : int\n    requires n >= 0\n    ensures pow2(n) >= 1\n    ensures pow2(n) == if n == 0 then 1 else 2 * pow2(n-1)\n{\n    if n <= 0 then 1\n    else 2 * pow2(n-1)\n}\n\nfunction ParseIntFunc(s: string): int\n    requires |s| > 0\n    ensures ParseIntFunc(s) >= 0\n{\n    ParseIntHelper(s, 0, 0)\n}\n\nfunction ParseIntHelper(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    requires acc >= 0\n    ensures ParseIntHelper(s, i, acc) >= 0\n    decreases |s| - i\n{\n    if i >= |s| || s[i] == '\\n' || s[i] == ' ' then acc\n    else if '0' <= s[i] <= '9' then\n        ParseIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    else\n        ParseIntHelper(s, i + 1, acc)\n}\n\nfunction IntToStringFunc(n: int): string\n    requires n >= 0\n    ensures |IntToStringFunc(n)| > 0\n    ensures n == 0 ==> IntToStringFunc(n) == \"0\"\n    ensures n > 0 ==> |IntToStringFunc(n)| > 0\n{\n    if n == 0 then \"0\"\n    else IntToStringHelper(n, \"\")\n}\n\nfunction IntToStringHelper(n: int, acc: string): string\n    requires n >= 0\n    ensures |IntToStringHelper(n, acc)| >= |acc|\n    decreases n\n{\n    if n == 0 then acc\n    else\n        var digit := n % 10;\n        var digitChar := ('0' as int + digit) as char;\n        IntToStringHelper(n / 10, [digitChar] + acc)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires |stdin_input| > 0\n    ensures |output| > 0\n    ensures output[|output|-1] == '\\n'\n    ensures var h := ParseIntFunc(stdin_input);\n            ValidInput(h) ==> output == IntToStringFunc(ComputeAttacks(h)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1227", "vc-description": "Count the integers from 1 to N (inclusive) that have exactly K non-zero digits \nin their decimal representation. N can be very large (up to 10^100) and K is \nbetween 1 and 3.", "vc-preamble": "function CountNonZeroDigits(n: int): int\n    requires n >= 0\n    ensures CountNonZeroDigits(n) >= 0\n{\n    if n == 0 then 0\n    else if n % 10 == 0 then CountNonZeroDigits(n / 10)\n    else 1 + CountNonZeroDigits(n / 10)\n}\n\nfunction CountNumbersWithKNonZeroDigits(n: int, k: int): int\n    requires n >= 1\n    requires k >= 1\n    ensures CountNumbersWithKNonZeroDigits(n, k) >= 0\n    ensures CountNumbersWithKNonZeroDigits(n, k) <= n\n{\n    CountRange(n, k, 1, n)\n}\n\nfunction CountRange(n: int, k: int, start: int, end: int): int\n    requires n >= 1\n    requires k >= 1\n    requires start >= 1\n    requires end >= start - 1\n    ensures CountRange(n, k, start, end) >= 0\n    ensures CountRange(n, k, start, end) <= if start > end then 0 else end - start + 1\n    decreases if end < start then 0 else end - start + 1\n{\n    if start > end then 0\n    else if CountNonZeroDigits(start) == k then \n        1 + CountRange(n, k, start + 1, end)\n    else \n        CountRange(n, k, start + 1, end)\n}\n\npredicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 1 && k <= 3\n}", "vc-helpers": "", "vc-spec": "method CountNumbersWithExactlyKNonZeroDigits(N: int, K: int) returns (count: int)\n    requires ValidInput(N, K)\n    ensures count == CountNumbersWithKNonZeroDigits(N, K)\n    ensures count >= 0\n    ensures count <= N", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1228", "vc-description": "Given a current HP value, determine how much to increase it (by 0, 1, or 2) to achieve the highest possible category.\nHP categories are defined by remainder when divided by 4:\nCategory A: remainder 1 (highest priority), Category B: remainder 3, Category C: remainder 2, Category D: remainder 0 (lowest priority)\nPriority order: A > B > C > D", "vc-preamble": "function GetCategory(hp: int): char\n{\n    var remainder := hp % 4;\n    if remainder == 1 then 'A'\n    else if remainder == 3 then 'B'\n    else if remainder == 2 then 'C'\n    else 'D'\n}\n\npredicate ValidInput(n: int)\n{\n    30 <= n <= 100\n}\n\npredicate ValidOutput(a: int, b: char)\n{\n    0 <= a <= 2 && (b == 'A' || b == 'B' || b == 'C' || b == 'D')\n}\n\npredicate OptimalChoice(n: int, a: int, b: char)\n{\n    b == GetCategory(n + a) &&\n    ((n % 4 == 1) ==> (a == 0 && b == 'A')) &&\n    ((n % 4 == 2) ==> (a == 1 && b == 'B')) &&\n    ((n % 4 == 3) ==> (a == 2 && b == 'A')) &&\n    ((n % 4 == 0) ==> (a == 1 && b == 'A'))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (a: int, b: char)\n    requires ValidInput(n)\n    ensures ValidOutput(a, b)\n    ensures OptimalChoice(n, a, b)\n    ensures b == 'A' || b == 'B'", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1231", "vc-description": "Given two integers a and b representing counts of even and odd steps,\ndetermine if there exists a contiguous interval [l,r] of positive integers\ncontaining exactly a even-numbered steps and b odd-numbered steps.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    0 <= a <= 100 && 0 <= b <= 100\n}\n\npredicate ValidOutput(result: string)\n{\n    result == \"YES\" || result == \"NO\"\n}\n\npredicate IntervalExists(a: int, b: int)\n{\n    abs(a - b) <= 1 && a + b > 0\n}\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: string)\n    requires ValidInput(a, b)\n    ensures ValidOutput(result)\n    ensures result == \"YES\" <==> IntervalExists(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1232", "vc-description": "Given two sorted arrays A and B (non-decreasing order), determine if it's possible \nto select k elements from A and m elements from B such that every selected element \nfrom A is strictly less than every selected element from B.", "vc-preamble": "predicate ValidInput(n_A: int, n_B: int, k: int, m: int, A: seq<int>, B: seq<int>)\n{\n    n_A >= 1 && n_B >= 1 &&\n    k >= 1 && k <= n_A &&\n    m >= 1 && m <= n_B &&\n    |A| == n_A &&\n    |B| == n_B\n}\n\npredicate IsSorted(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| - 1 ==> s[i] <= s[i + 1]\n}\n\npredicate ValidSelection(A: seq<int>, B: seq<int>, k: int, m: int)\n    requires k >= 1 && k <= |A|\n    requires m >= 1 && m <= |B|\n{\n    A[k - 1] < B[|B| - m]\n}", "vc-helpers": "", "vc-spec": "method solve(n_A: int, n_B: int, k: int, m: int, A: seq<int>, B: seq<int>) returns (result: string)\n    requires ValidInput(n_A, n_B, k, m, A, B)\n    requires IsSorted(A)\n    requires IsSorted(B)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> ValidSelection(A, B, k, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1240", "vc-description": "Given n columns of soldiers where column i has l_i soldiers starting with left leg \nand r_i soldiers starting with right leg, find which column to swap (change all \nleft-leg soldiers to right-leg and vice versa) to maximize the beauty of the parade.\nBeauty is defined as |L - R| where L is total left-leg soldiers and R is total \nright-leg soldiers across all columns. You can swap at most one column. \nOutput the 1-indexed column number to swap, or 0 if no swap improves the current beauty.", "vc-preamble": "predicate ValidInput(columns: seq<(int, int)>)\n{\n    forall i :: 0 <= i < |columns| ==> columns[i].0 > 0 && columns[i].1 > 0\n}\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}\n\nfunction sum_left(columns: seq<(int, int)>): int\n{\n    if |columns| == 0 then 0\n    else columns[0].0 + sum_left(columns[1..])\n}\n\nfunction sum_right(columns: seq<(int, int)>): int\n{\n    if |columns| == 0 then 0\n    else columns[0].1 + sum_right(columns[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(columns: seq<(int, int)>) returns (result: int)\n    requires ValidInput(columns)\n    ensures 0 <= result <= |columns|\n    ensures var L := sum_left(columns);\n            var R := sum_right(columns);\n            var original_beauty := abs(L - R);\n            if result == 0 then\n                forall i :: 0 <= i < |columns| ==> \n                    var new_L := L - columns[i].0 + columns[i].1;\n                    var new_R := R - columns[i].1 + columns[i].0;\n                    abs(new_L - new_R) <= original_beauty\n            else\n                1 <= result <= |columns| &&\n                var best_idx := result - 1;\n                var best_L := L - columns[best_idx].0 + columns[best_idx].1;\n                var best_R := R - columns[best_idx].1 + columns[best_idx].0;\n                var best_beauty := abs(best_L - best_R);\n                best_beauty > original_beauty &&\n                forall i :: 0 <= i < |columns| ==> \n                    var new_L := L - columns[i].0 + columns[i].1;\n                    var new_R := R - columns[i].1 + columns[i].0;\n                    abs(new_L - new_R) <= best_beauty", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_125", "vc-description": "Given a 4-way intersection with 4 road parts arranged counter-clockwise, determine if a traffic accident\nbetween cars and pedestrians is possible. Each road part has 4 traffic lights: left turn (l), straight (s),\nright turn (r), and pedestrian crossing (p). Each light can be red (0) or green (1). An accident is possible\nif a pedestrian crossing light is green and a car light is green that allows cars to reach that crossing.", "vc-preamble": "predicate ValidInputString(s: string)\n{\n    |s| >= 7 &&\n    ContainsFourLines(s) &&\n    AllLinesHaveFourValidIntegers(s)\n}\n\npredicate ContainsFourLines(s: string)\n{\n    CountNewlines(s, 0) >= 3\n}\n\npredicate AllLinesHaveFourValidIntegers(s: string)\n{\n    forall i :: 0 <= i < |s| ==> (s[i] == '0' || s[i] == '1' || s[i] == ' ' || s[i] == '\\n')\n}\n\npredicate ParseInput(s: string, input_lines: seq<seq<int>>)\n{\n    |input_lines| == 4 &&\n    (forall i :: 0 <= i < 4 ==> |input_lines[i]| == 4) &&\n    (forall i :: 0 <= i < 4 ==> forall j :: 0 <= j < 4 ==> \n        (input_lines[i][j] >= 0 && input_lines[i][j] <= 1)) &&\n    StringContainsFourLinesOfFourIntegers(s, input_lines)\n}\n\npredicate StringContainsFourLinesOfFourIntegers(s: string, input_lines: seq<seq<int>>)\n{\n    |input_lines| == 4 &&\n    (forall i :: 0 <= i < 4 ==> |input_lines[i]| == 4) &&\n    ValidInputString(s)\n}\n\npredicate AccidentPossible(lanes: seq<seq<int>>)\n    requires |lanes| == 4\n    requires forall i :: 0 <= i < 4 ==> |lanes[i]| == 4\n    requires forall i :: 0 <= i < 4 ==> forall j :: 0 <= j < 4 ==> \n        (lanes[i][j] == 0 || lanes[i][j] == 1)\n{\n    exists i :: 0 <= i < 4 && AccidentAtLane(i, lanes)\n}\n\npredicate AccidentAtLane(i: int, lanes: seq<seq<int>>)\n    requires 0 <= i < 4\n    requires |lanes| == 4\n    requires forall j :: 0 <= j < 4 ==> |lanes[j]| == 4\n{\n    (lanes[i][3] == 1 && (lanes[i][0] == 1 || lanes[i][1] == 1 || lanes[i][2] == 1)) ||\n    (lanes[i][0] == 1 && lanes[(i + 3) % 4][3] == 1) ||\n    (lanes[i][1] == 1 && lanes[(i + 2) % 4][3] == 1) ||\n    (lanes[i][2] == 1 && lanes[(i + 1) % 4][3] == 1)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> s[i] as int >= 0 && s[i] as int <= 127\n    requires ValidInputString(s)\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures exists input_lines :: \n        ParseInput(s, input_lines) && \n        (result == \"YES\\n\" <==> AccidentPossible(input_lines))\n    ensures |result| >= 3", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1255", "vc-description": "Given n customers visiting a cafe at specific times (hours and minutes), determine the minimum number of cash registers needed.\nEach customer takes less than a minute to serve and will leave if no register is available upon arrival.\nThe minimum number of registers equals the maximum number of customers arriving at the same time.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\nfunction GetMaxSimultaneousArrivals(input: string): int\n    requires ValidInput(input)\n    ensures GetMaxSimultaneousArrivals(input) >= 0\n{\n    var lines := SplitLinesFunction(input);\n    if |lines| == 0 then 0\n    else MaxFrequencyInAllLines(lines)\n}\n\nfunction SplitLinesFunction(s: string): seq<string>\n{\n    SplitLinesHelper(s, 0, 0, [])\n}\n\nfunction SplitLinesHelper(s: string, start: int, i: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if start < |s| then acc + [s[start..]] else acc\n    else if s[i] == '\\n' then\n        var newAcc := if start < i then acc + [s[start..i]] else acc;\n        SplitLinesHelper(s, i + 1, i + 1, newAcc)\n    else\n        SplitLinesHelper(s, start, i + 1, acc)\n}\n\nfunction MaxFrequencyInAllLines(lines: seq<string>): int\n    requires |lines| > 0\n    ensures MaxFrequencyInAllLines(lines) >= 1\n{\n    MaxFrequencyHelper(lines, 0, 0)\n}\n\nfunction MaxFrequencyHelper(lines: seq<string>, index: int, currentMax: int): int\n    requires 0 <= index <= |lines|\n    requires currentMax >= 0\n    ensures MaxFrequencyHelper(lines, index, currentMax) >= currentMax\n    decreases |lines| - index\n{\n    if index >= |lines| then currentMax\n    else\n        var count := CountOccurrences(lines, lines[index]);\n        var newMax := if count > currentMax then count else currentMax;\n        var nextIndex := SkipIdentical(lines, index);\n        MaxFrequencyHelper(lines, nextIndex, newMax)\n}\n\nfunction CountOccurrences(lines: seq<string>, target: string): int\n    ensures CountOccurrences(lines, target) >= 0\n{\n    CountOccurrencesHelper(lines, target, 0, 0)\n}\n\nfunction CountOccurrencesHelper(lines: seq<string>, target: string, index: int, count: int): int\n    requires 0 <= index <= |lines|\n    requires count >= 0\n    ensures CountOccurrencesHelper(lines, target, index, count) >= count\n    decreases |lines| - index\n{\n    if index >= |lines| then count\n    else\n        var newCount := if lines[index] == target then count + 1 else count;\n        CountOccurrencesHelper(lines, target, index + 1, newCount)\n}\n\nfunction SkipIdentical(lines: seq<string>, index: int): int\n    requires 0 <= index < |lines|\n    ensures index < SkipIdentical(lines, index) <= |lines|\n    decreases |lines| - index\n{\n    if index + 1 >= |lines| then |lines|\n    else if lines[index + 1] == lines[index] then SkipIdentical(lines, index + 1)\n    else index + 1\n}\n\nfunction IntToStringFunction(n: int): string\n    requires n >= 0\n    ensures |IntToStringFunction(n)| > 0\n{\n    if n == 0 then \"0\"\n    else IntToStringHelper(n, \"\")\n}\n\nfunction IntToStringHelper(n: int, acc: string): string\n    requires n > 0\n    ensures |IntToStringHelper(n, acc)| > |acc|\n    decreases n\n{\n    var digit := n % 10;\n    var digitChar := ('0' as int + digit) as char;\n    if n / 10 == 0 then [digitChar] + acc\n    else IntToStringHelper(n / 10, [digitChar] + acc)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result == IntToStringFunction(GetMaxSimultaneousArrivals(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_126", "vc-description": "Given a phone keypad layout and a phone number, determine if the finger movement \nsequence between consecutive key presses is unique (no other number produces the same sequence).\nThe keypad layout is: 1-2-3 in top row, 4-5-6 in middle row, 7-8-9 in bottom row, \nand 0 below 8.", "vc-preamble": "function string_to_digits(s: string): set<int>\n{\n    set i | 0 <= i < |s| && '0' <= s[i] <= '9' :: (s[i] as int) - ('0' as int)\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 && '\\n' in input\n}\n\npredicate HasUniqueMovementSequence(digits: set<int>)\n{\n    (1 in digits || 4 in digits || 7 in digits || 0 in digits) &&\n    (1 in digits || 2 in digits || 3 in digits) &&\n    (3 in digits || 6 in digits || 9 in digits || 0 in digits) &&\n    (7 in digits || 0 in digits || 9 in digits)\n}\n\nfunction split_lines(s: string): seq<string>\n{\n    if '\\n' !in s then [s]\n    else \n        var idx := find_char(s, '\\n');\n        if idx == -1 then [s]\n        else if idx < |s| then [s[..idx]] + split_lines(s[idx+1..])\n        else [s]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n  requires ValidInput(input)\n  ensures result == \"YES\\n\" || result == \"NO\\n\"\n  ensures |result| > 0\n  ensures var lines := split_lines(input);\n          |lines| >= 2 ==>\n          var digits_str := lines[1];\n          var digits := string_to_digits(digits_str);\n          result == \"YES\\n\" <==> HasUniqueMovementSequence(digits)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1267", "vc-description": "Given n participants with integer scores, determine the number of ways to award diplomas such that:\n1. At least one participant receives a diploma\n2. No participant with score 0 receives a diploma  \n3. If a participant with score X receives a diploma, then all participants with score \u2265 X must also receive diplomas", "vc-preamble": "predicate ValidInput(n: int, scores: seq<int>)\n{\n    n == |scores| && n >= 1 && exists i :: 0 <= i < |scores| && scores[i] != 0\n}\n\nfunction UniqueNonZeroScores(scores: seq<int>): set<int>\n{\n    set i | 0 <= i < |scores| && scores[i] != 0 :: scores[i]\n}\n\npredicate ValidResult(scores: seq<int>, result: int)\n{\n    result >= 1 && \n    result == |UniqueNonZeroScores(scores)| && \n    result <= |scores|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, scores: seq<int>) returns (result: int)\n    requires ValidInput(n, scores)\n    ensures ValidResult(scores, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1268", "vc-description": "Given n cola cans where each can i has remaining volume a_i and capacity b_i,\ndetermine if all remaining cola can be poured into exactly 2 cans.", "vc-preamble": "predicate ValidInput(a: seq<int>, b: seq<int>)\n{\n  |a| == |b| && |a| >= 2 && forall i :: 0 <= i < |a| ==> 0 <= a[i] <= b[i]\n}\n\nfunction sumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0\n  else s[0] + sumSeq(s[1..])\n}\n\nfunction findTwoLargestSum(s: seq<int>): int\n  requires |s| >= 2\n  ensures exists i, j :: 0 <= i < |s| && 0 <= j < |s| && i != j && \n          findTwoLargestSum(s) == s[i] + s[j] &&\n          (forall k :: 0 <= k < |s| && k != i ==> s[k] <= s[i] || s[k] <= s[j]) &&\n          (forall k :: 0 <= k < |s| && k != j ==> s[k] <= s[i] || s[k] <= s[j])\n{\n  var max1 := findMax(s);\n  var max2 := findMaxExcluding(s, max1);\n  s[max1] + s[max2]\n}\n\nfunction findMax(s: seq<int>): int\n  requires |s| >= 1\n  ensures 0 <= findMax(s) < |s|\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= s[findMax(s)]\n{\n  if |s| == 1 then 0\n  else\n    var restMax := findMax(s[1..]);\n    if s[0] >= s[restMax + 1] then 0 else restMax + 1\n}\n\nfunction findMaxExcluding(s: seq<int>, exclude: int): int\n  requires |s| >= 2\n  requires 0 <= exclude < |s|\n  ensures 0 <= findMaxExcluding(s, exclude) < |s|\n  ensures findMaxExcluding(s, exclude) != exclude\n  ensures forall i :: 0 <= i < |s| && i != exclude ==> s[i] <= s[findMaxExcluding(s, exclude)]\n{\n  if exclude == 0 then\n    1 + findMax(s[1..])\n  else if exclude == |s| - 1 then\n    findMax(s[..|s|-1])\n  else\n    var leftMax := if |s[..exclude]| > 0 then findMax(s[..exclude]) else -1;\n    var rightMax := if |s[exclude+1..]| > 0 then exclude + 1 + findMax(s[exclude+1..]) else -1;\n    if leftMax == -1 then rightMax\n    else if rightMax == -1 then leftMax\n    else if s[leftMax] >= s[rightMax] then leftMax else rightMax\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>, b: seq<int>) returns (result: string)\n  requires ValidInput(a, b)\n  ensures result == \"YES\" || result == \"NO\"\n  ensures result == \"YES\" <==> findTwoLargestSum(b) >= sumSeq(a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_128", "vc-description": "Given n cows initially arranged in positions 1, 2, ..., n, find the maximum number of inversions\nachievable using at most k swaps. An inversion is a pair (i,j) where i < j but the cow in \nposition i has a larger label than the cow in position j.", "vc-preamble": "function min(a: int, b: int): int\n    ensures min(a, b) == a || min(a, b) == b\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a ==> a <= b\n    ensures min(a, b) == b ==> b <= a\n{\n    if a <= b then a else b\n}\n\nfunction computeInversions(n: int, k: int, iterations: int): int\n    requires n >= 1 && k >= 0 && iterations >= 0\n    requires iterations <= min(k, n / 2)\n    decreases iterations\n{\n    if iterations == 0 then 0\n    else computeInversions(n, k, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2)\n}\n\nfunction sumInversionsFormula(n: int, iterations: int): int\n    requires n >= 1 && iterations >= 0\n    requires iterations <= n / 2\n    decreases iterations\n{\n    if iterations == 0 then 0\n    else sumInversionsFormula(n, iterations - 1) + (n - 2*(iterations-1) - 1) + (n - 2*(iterations-1) - 2)\n}\n\nfunction sumOfConsecutivePairs(n: int, k: int): int\n    requires n >= 1 && k >= 0 && k < n / 2\n{\n    var iterations := k;\n    if iterations == 0 then 0\n    else sumInversionsFormula(n, iterations)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires n >= 1 && k >= 0\n    ensures result >= 0\n    ensures result == computeInversions(n, k, min(k, n / 2))\n    ensures result == sumInversionsFormula(n, min(k, n / 2))\n    ensures k >= n / 2 ==> result == n * (n - 1) / 2\n    ensures k < n / 2 ==> result == sumOfConsecutivePairs(n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1282", "vc-description": "Given a string of 'M' (boys) and 'F' (girls), determine how many seconds\nit takes for all girls to move to the front of the line. Each second,\nall boys immediately in front of girls simultaneously swap positions.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 1 && forall i :: 0 <= i < |input| ==> input[i] == 'M' || input[i] == 'F'\n}\n\nfunction ComputeSwapTime(input: string): nat\n    requires ValidInput(input)\n{\n    var rev_input := reverse(input);\n    var first_f := find_char(rev_input, 'F', 0);\n\n    if first_f == -1 then 0\n    else\n        var first_m_after_f := find_char(rev_input, 'M', first_f + 1);\n        if first_m_after_f == -1 then 0\n        else\n            var last_m := rfind_char(rev_input, 'M');\n            if last_m < first_m_after_f then 0\n            else\n                var substring := rev_input[first_m_after_f..last_m+1];\n                var balance := calculate_balance(substring);\n                var f_count := count_char(substring, 'F');\n                balance + f_count + first_m_after_f - first_f - 1\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| >= 1\n    ensures result[|result|-1] == '\\n'\n    ensures exists val :: val >= 0 && result == nat_to_string(val) + \"\\n\"\n    ensures result == nat_to_string(ComputeSwapTime(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1289", "vc-description": "Given n bus stops at positions a_i (sorted in increasing order), a bus travels back and forth \nbetween stops 1 and n in order: 1\u21922\u2192...\u2192n\u2192(n-1)\u2192...\u21921\u21922\u2192... repeatedly.\nGiven a segment of the bus journey as a sorted list of stop numbers with their visit frequencies,\ncalculate the total distance traveled during this segment, or return -1 if the distance cannot \nbe uniquely determined.\n\n// Since |visits| >= 1, there must be at least one visit\n\n// This means at least one count > 0, so if allZero then maxRounds >= 1", "vc-preamble": "predicate isSorted(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\npredicate allDistancesEqual(positions: seq<int>)\n    requires |positions| >= 2\n    requires forall i :: 0 <= i < |positions| - 1 ==> positions[i] < positions[i + 1]\n{\n    if |positions| <= 2 then true\n    else\n        var firstDist := positions[1] - positions[0];\n        forall i :: 1 <= i < |positions| - 1 ==> positions[i + 1] - positions[i] == firstDist\n}\n\nfunction computeCounts(n: int, visits: seq<int>): seq<int>\n    requires n >= 2\n    requires forall i :: 0 <= i < |visits| ==> 1 <= visits[i] <= n\n{\n    var baseCounts := seq(n, i requires 0 <= i < n => countVisits(visits, i + 1));\n    seq(n, i requires 0 <= i < n => \n        if i == 0 || i == n - 1 then baseCounts[i] * 2 \n        else baseCounts[i]\n    )\n}\n\nfunction computeMaxRounds(counts: seq<int>): int\n    requires |counts| > 0\n{\n    maxVal(seq(|counts|, i requires 0 <= i < |counts| => counts[i] / 2))\n}\n\npredicate hasAmbiguousPath(n: int, positions: seq<int>, visits: seq<int>)\n    requires n >= 2\n    requires |positions| == n\n    requires forall i :: 0 <= i < |visits| ==> 1 <= visits[i] <= n\n    requires forall i :: 0 <= i < n - 1 ==> positions[i] < positions[i + 1]\n{\n    var counts := computeCounts(n, visits);\n    var maxRounds := computeMaxRounds(counts);\n    var remainingCounts := seq(n, i requires 0 <= i < n => counts[i] - maxRounds * 2);\n    var allZero := forall i :: 0 <= i < n ==> remainingCounts[i] == 0;\n\n    allZero && n > 2 && !allDistancesEqual(positions)\n}\n\nfunction calculateTotalDistance(n: int, positions: seq<int>, visits: seq<int>): int\n    requires n >= 2\n    requires |positions| == n\n    requires forall i :: 0 <= i < |visits| ==> 1 <= visits[i] <= n\n    requires forall i :: 0 <= i < n - 1 ==> positions[i] < positions[i + 1]\n    requires !hasAmbiguousPath(n, positions, visits)\n    requires |visits| >= 1\n    ensures calculateTotalDistance(n, positions, visits) >= 0\n{\n    var counts := computeCounts(n, visits);\n    var maxRounds := computeMaxRounds(counts);\n    var remainingCounts := seq(n, i requires 0 <= i < n => counts[i] - maxRounds * 2);\n    var allZero := forall i :: 0 <= i < n ==> remainingCounts[i] == 0;\n\n    if allZero then\n        if n == 2 then\n            maxRounds * (positions[1] - positions[0]) * 2 - (positions[1] - positions[0])\n        else\n            var firstDist := positions[1] - positions[0];\n\n            assert exists i :: 0 <= i < n && counts[i] > 0;\n            assert maxRounds >= 1;\n            maxRounds * firstDist * 2 * (n - 1) - firstDist\n    else\n        var edgeDistance := sum(seq(n-1, i requires 0 <= i < n-1 => min(remainingCounts[i], remainingCounts[i+1]) * (positions[i+1] - positions[i])));\n        var totalEdgeLength := sum(seq(n-1, i requires 0 <= i < n-1 => positions[i+1] - positions[i]));\n        edgeDistance + maxRounds * 2 * totalEdgeLength\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, positions: seq<int>, m: int, visits: seq<int>) returns (result: int)\n    requires n >= 2\n    requires |positions| == n\n    requires m >= 1\n    requires |visits| == m\n    requires forall i :: 0 <= i < |visits| ==> 1 <= visits[i] <= n\n    requires forall i :: 0 <= i < n - 1 ==> positions[i] < positions[i + 1]\n    requires forall i :: 0 <= i < |positions| ==> positions[i] >= 1\n    requires isSorted(visits)\n    ensures result >= -1\n    ensures result == -1 <==> hasAmbiguousPath(n, positions, visits)\n    ensures result >= 0 ==> result == calculateTotalDistance(n, positions, visits)\n    ensures result >= 0 ==> (forall i :: 0 <= i < n-1 ==> positions[i+1] - positions[i] > 0)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1290", "vc-description": "Given n columns and m squares appearing in specified columns, calculate points earned.\nEach square stacks in its column. When all columns have at least one square,\nthe bottom row is removed (earning 1 point) and squares drop down.\nReturn total points earned.", "vc-preamble": "predicate ValidInput(n: int, m: int, squares: seq<int>) {\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    |squares| == m &&\n    forall i :: 0 <= i < |squares| ==> 1 <= squares[i] <= n\n}\n\nfunction count_occurrences(s: seq<int>, value: int): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == value then 1 else 0) + count_occurrences(s[1..], value)\n}\n\npredicate CorrectResult(n: int, squares: seq<int>, result: int) {\n    0 <= result <= |squares| &&\n    (forall col :: 1 <= col <= n ==> result <= count_occurrences(squares, col)) &&\n    (exists col :: 1 <= col <= n && result == count_occurrences(squares, col))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, squares: seq<int>) returns (result: int)\n    requires ValidInput(n, m, squares)\n    ensures CorrectResult(n, squares, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1291", "vc-description": "Given two sets of points in a 2D plane, determine if there exists a circle such that \nall points from one set are strictly inside the circle and all points from the other \nset are strictly outside the circle. Input consists of n and m (sizes of the sets), \nfollowed by n coordinate pairs for the first set, then m coordinate pairs for the \nsecond set. Output \"YES\" if such a separating circle exists, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    (exists i :: 0 <= i < |input| && input[i] == '\\n') &&\n    ValidInputStructure(input)\n}\n\npredicate ValidInputStructure(input: string)\n{\n    |input| >= 3\n}\n\npredicate ValidOutput(output: string)\n{\n    output == \"YES\\n\" || output == \"NO\\n\"\n}\n\nfunction ParseInput(input: string): (int, int, string, seq<string>, seq<string>)\n    reads *\n    requires ValidInput(input)\n    ensures var result := ParseInput(input);\n            result.0 >= 1 && result.1 >= 1 &&\n            |result.3| == result.0 &&\n            |result.4| == result.1\n{\n    var lines := SplitLines(input);\n    if |lines| >= 1 then\n        var first_line := lines[0];\n        var nm_parts := SplitWhitespace(first_line);\n        if |nm_parts| >= 2 then\n            var n := StringToInt(nm_parts[0]);\n            var m := StringToInt(nm_parts[1]);\n            var a_lines := if |lines| > n then lines[1..n+1] else [];\n            var b_lines := if |lines| > n + m then lines[n+1..n+m+1] else [];\n            (n, m, first_line, a_lines, b_lines)\n        else\n            var a_seq := seq(1, i => \"\");\n            var b_seq := seq(1, i => \"\");\n            (1, 1, first_line, a_seq, b_seq)\n    else\n        var a_seq := seq(1, i => \"\");\n        var b_seq := seq(1, i => \"\");\n        (1, 1, \"\", a_seq, b_seq)\n}\n\nfunction SolveCircleSeparation(input: string): string\n    reads *\n    requires ValidInput(input)\n    ensures ValidOutput(SolveCircleSeparation(input))\n{\n    var parsed := ParseInput(input);\n    var n := parsed.0;\n    var m := parsed.1;\n    var nm_string := parsed.2;\n    var a := parsed.3;\n    var b := parsed.4;\n\n    if (\n        (n == 2 && m == 2 && |a| > 0 && a[0] == \"-1 0\") ||\n        (n == 2 && m == 3 && |a| > 0 && a[0] == \"-1 0\") ||\n        (n == 3 && m == 3 && |a| > 0 && a[0] == \"-3 -4\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"15 70\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"28 9\") ||\n        (n == 10000 && m == 10000 && |a| > 0 && a[0] == \"917 -4476\") ||\n        (n == 3 && m == 2 && |a| > 0 && a[0] == \"9599 -9999\") ||\n        (n == 145 && m == 143 && |a| > 0 && a[0] == \"-5915 6910\") ||\n        (n == 2 && m == 10 && |a| >= 2 && ((a[0] == \"-1 0\" && a[1] == \"0 -1\") || (a[0] == \"1 0\" && a[1] == \"0 1\"))) ||\n        (n == 2 && m == 3 && |a| > 0 && a[0] == \"0 -1\") ||\n        (n == 100 && m == 100 && |a| > 0 && a[0] == \"-10000 6429\")\n    ) then \"NO\\n\"\n    else if (\n        (n == 4 && m == 4 && |a| > 0 && a[0] == \"1 0\") ||\n        (n == 3 && m == 4 && |a| > 0 && a[0] == \"-9998 -10000\") ||\n        (n == 1) ||\n        (m == 1) ||\n        (n == 2 && m == 2 && |a| > 0 && a[0] == \"3782 2631\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"-4729 -6837\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"6558 -2280\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"-5051 5846\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"-4547 4547\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"7010 10000\") ||\n        (n == 1948 && m == 1091 && |a| > 0 && a[0] == \"-1873 -10000\") ||\n        (n == 1477 && m == 1211 && |a| > 0 && a[0] == \"2770 -10000\") ||\n        (n == 1000 && m == 1000 && |a| > 0 && a[0] == \"5245 6141\") ||\n        (n == 10000 && m == 10000 && |a| > 0 && a[0] == \"-4957 8783\") ||\n        (n == 10000 && m == 10000 && |a| > 0 && a[0] == \"-1729 2513\") ||\n        (n == 10000 && m == 10000 && |a| > 0 && a[0] == \"8781 -5556\") ||\n        (n == 10000 && m == 10000 && |a| > 0 && a[0] == \"5715 5323\") ||\n        (nm_string == \"10000 10000\" && |a| > 0 && a[0] == \"-1323 290\") ||\n        (nm_string == \"10000 10000\" && |a| > 0 && a[0] == \"6828 3257\") ||\n        (nm_string == \"10000 10000\" && |a| > 0 && a[0] == \"1592 -154\") ||\n        (nm_string == \"10000 10000\" && |a| > 0 && a[0] == \"-1535 5405\") ||\n        (nm_string == \"10000 10000\" && |a| > 0 && (a[0] == \"-3041 8307\" || a[0] == \"-2797 3837\" || a[0] == \"8393 -5715\"))\n    ) then \"YES\\n\"\n    else if (n >= 1000) then \"NO\\n\"\n    else \"YES\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(result)\n    ensures result == SolveCircleSeparation(stdin_input)\n    ensures |result| > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1298", "vc-description": "Given a binary string, repeatedly remove adjacent pairs of '0' and '1' characters.\nFind the minimum possible length after performing this operation any number of times.\nEach operation removes exactly one '0' and one '1', so the result is the absolute\ndifference between the count of '0's and '1's in the original string.", "vc-preamble": "predicate is_binary_string(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}\n\npredicate is_valid_integer(s: string)\n{\n    |s| > 0 && (s[0] != '0' || |s| == 1) && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction count_char(s: string, c: char): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + count_char(s[1..], c)\n}\n\nfunction abs_diff_count(s: string): int\n    requires is_binary_string(s)\n{\n    var count0 := count_char(s, '0');\n    var count1 := count_char(s, '1');\n    if count1 >= count0 then count1 - count0 else count0 - count1\n}\n\nfunction int_to_string(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"0\"\n    else if n < 10 then [char_of_digit(n)]\n    else int_to_string(n / 10) + [char_of_digit(n % 10)]\n}\n\nfunction char_of_digit(d: int): char\n    requires 0 <= d <= 9\n{\n    match d\n        case 0 => '0'\n        case 1 => '1' \n        case 2 => '2'\n        case 3 => '3'\n        case 4 => '4'\n        case 5 => '5'\n        case 6 => '6'\n        case 7 => '7'\n        case 8 => '8'\n        case 9 => '9'\n}\n\nfunction string_to_int(s: string): int\n    requires is_valid_integer(s)\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then (s[0] as int) - ('0' as int)\n    else string_to_int(s[0..|s|-1]) * 10 + ((s[|s|-1] as int) - ('0' as int))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n'\n    requires exists newline_pos :: 0 <= newline_pos < |stdin_input| && stdin_input[newline_pos] == '\\n' &&\n             newline_pos + 1 < |stdin_input| &&\n             exists binary_end :: newline_pos + 1 <= binary_end <= |stdin_input| &&\n             (binary_end == |stdin_input| || stdin_input[binary_end] == '\\n') &&\n             is_valid_integer(stdin_input[0..newline_pos]) &&\n             is_binary_string(stdin_input[newline_pos + 1..binary_end])\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures exists newline_pos :: 0 <= newline_pos < |stdin_input| && stdin_input[newline_pos] == '\\n' &&\n            newline_pos + 1 < |stdin_input| &&\n            exists binary_end :: newline_pos + 1 <= binary_end <= |stdin_input| &&\n            (binary_end == |stdin_input| || stdin_input[binary_end] == '\\n') &&\n            is_binary_string(stdin_input[newline_pos + 1..binary_end]) &&\n            result == int_to_string(abs_diff_count(stdin_input[newline_pos + 1..binary_end])) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1301", "vc-description": "Given a pattern string containing lowercase letters and dots (representing unknown letters),\nfind which of the eight Pok\u00e9mon names (vaporeon, jolteon, flareon, espeon, umbreon, leafeon, glaceon, sylveon)\nmatches the pattern exactly. Input consists of pattern length n and the pattern string.", "vc-preamble": "predicate ValidPokemonName(name: string)\n{\n    name == \"vaporeon\" || name == \"jolteon\" || name == \"flareon\" || name == \"espeon\" ||\n    name == \"umbreon\" || name == \"leafeon\" || name == \"glaceon\" || name == \"sylveon\"\n}\n\npredicate MatchesPattern(pokemonName: string, pattern: string)\n    requires |pokemonName| == |pattern|\n{\n    forall i :: 0 <= i < |pattern| ==> (pattern[i] == '.' || pattern[i] == pokemonName[i])\n}\n\nfunction GetPokemonList(): seq<string>\n{\n    [\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 && \n    var lines := SplitLines(input);\n    |lines| >= 2 &&\n    (|lines[0]| > 0 && forall i :: 0 <= i < |lines[0]| ==> '0' <= lines[0][i] <= '9') &&\n    6 <= |lines[1]| <= 8 &&\n    forall i :: 0 <= i < |lines[1]| ==> ('a' <= lines[1][i] <= 'z' || lines[1][i] == '.') &&\n    exists j :: 0 <= j < |GetPokemonList()| && |GetPokemonList()[j]| == |lines[1]| && MatchesPattern(GetPokemonList()[j], lines[1])\n}\n\npredicate IsFirstMatch(result: string, pattern: string, pokemonList: seq<string>)\n{\n    exists i :: 0 <= i < |pokemonList| && \n        pokemonList[i] == result &&\n        |result| == |pattern| &&\n        MatchesPattern(result, pattern) &&\n        forall j :: 0 <= j < i ==> (|pokemonList[j]| != |pattern| || !MatchesPattern(pokemonList[j], pattern))\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidPokemonName(result)\n    ensures var lines := SplitLines(input);\n        IsFirstMatch(result, lines[1], GetPokemonList())\n    ensures var lines := SplitLines(input);\n        exists i :: 0 <= i < |GetPokemonList()| && \n            GetPokemonList()[i] == result &&\n            |result| == |lines[1]| &&\n            MatchesPattern(result, lines[1])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_131", "vc-description": "Given two configurations of n stone piles, determine if the first configuration\ncan be transformed into the second using operations: remove one stone from any pile,\nor move one stone from one pile to another pile.", "vc-preamble": "predicate IsValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 3 && \n    ParseInt(lines[0]) > 0 &&\n    |ParseIntArray(lines[1])| == ParseInt(lines[0]) &&\n    |ParseIntArray(lines[2])| == ParseInt(lines[0])\n}\n\nfunction GetInitialSum(input: string): int\n    requires IsValidInput(input)\n{\n    var lines := SplitLines(input);\n    Sum(ParseIntArray(lines[1]))\n}\n\nfunction GetTargetSum(input: string): int\n    requires IsValidInput(input)\n{\n    var lines := SplitLines(input);\n    Sum(ParseIntArray(lines[2]))\n}\n\nfunction Sum(nums: seq<int>): int\n    decreases |nums|\n{\n    if |nums| == 0 then 0\n    else nums[0] + Sum(nums[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures IsValidInput(input) ==> \n        (result == \"Yes\" <==> GetInitialSum(input) >= GetTargetSum(input))\n    ensures !IsValidInput(input) ==> result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1310", "vc-description": "Given an array of n non-negative integers, find the maximum XOR value among all possible \ncontiguous subarrays (segments of consecutive elements).", "vc-preamble": "predicate ValidInput(arr: seq<bv32>)\n{\n    |arr| > 0\n}\n\npredicate IsMaxXorSubarray(arr: seq<bv32>, result: bv32)\n    requires ValidInput(arr)\n{\n    exists i, j :: 0 <= i <= j < |arr| && result == XorRange(arr, i, j) &&\n    forall i1, j1 :: 0 <= i1 <= j1 < |arr| ==> \n        (XorRange(arr, i1, j1) as int) <= (result as int)\n}", "vc-helpers": "", "vc-spec": "method solve(arr: seq<bv32>) returns (result: bv32)\n    requires ValidInput(arr)\n    ensures IsMaxXorSubarray(arr, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1312", "vc-description": "Distribute n candies among m friends such that each friend receives at least one candy\nand the difference between the maximum and minimum number of candies is minimized.\nThe optimal solution gives each friend either floor(n/m) or floor(n/m)+1 candies.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n  n >= m > 0\n}\n\nfunction sum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\nfunction count(s: seq<int>, val: int): int\n{\n  if |s| == 0 then 0 \n  else (if s[0] == val then 1 else 0) + count(s[1..], val)\n}\n\npredicate OptimalDistribution(result: seq<int>, n: int, m: int)\n  requires m > 0\n{\n  |result| == m &&\n  (forall i :: 0 <= i < |result| ==> result[i] > 0) &&\n  sum(result) == n &&\n  (forall i :: 0 <= i < |result| ==> result[i] == n / m || result[i] == n / m + 1) &&\n  count(result, n / m) == m - (n % m) &&\n  count(result, n / m + 1) == n % m\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: seq<int>)\n  requires ValidInput(n, m)\n  ensures OptimalDistribution(result, n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1317", "vc-description": "Given an n\u00d7n grid where each cell (i,j) contains (i\u00b2 + j\u00b2) candies, count how many cells have a number of candies divisible by m.", "vc-preamble": "function CountCellsDivisibleByM(n: int, m: int): int\n  requires 1 <= n\n  requires 1 <= m\n{\n  |set i, j | 1 <= i <= n && 1 <= j <= n && (i * i + j * j) % m == 0 :: (i, j)|\n}\n\npredicate ValidInput(n: int, m: int) {\n  1 <= n && 1 <= m <= 1000\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures result >= 0\n  ensures result == CountCellsDivisibleByM(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1329", "vc-description": "Given an integer N (1 \u2264 N \u2264 100), count how many divisors of N! have exactly 75 divisors.\nA number has exactly 75 divisors if and only if its prime factorization has one of these forms:\n- p^74 (where p is prime)\n- p^24 \u00d7 q^2 (where p, q are distinct primes)  \n- p^14 \u00d7 q^4 (where p, q are distinct primes)\n- p^4 \u00d7 q^4 \u00d7 r^2 (where p, q, r are distinct primes)\n\n// Abstract specification - represents the count of divisors of N! that have exactly 75 divisors", "vc-preamble": "predicate ValidInput(N: int)\n{\n  1 <= N <= 100\n}\n\nfunction countDivisorsWith75Factors(N: int): int\n  requires ValidInput(N)\n{\n  0\n}\n\npredicate ValidOutput(result: int)\n{\n  result >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: int)\n  requires ValidInput(N)\n  ensures ValidOutput(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1332", "vc-description": "Five players each start with the same positive number of coins b. Coins are passed between players.\nGiven the final coin distribution, determine the initial bet b, or -1 if no such positive b exists.", "vc-preamble": "predicate ValidInput(coins: seq<int>)\n{\n  |coins| == 5 && forall i :: 0 <= i < |coins| ==> 0 <= coins[i] <= 100\n}\n\nfunction TotalCoins(coins: seq<int>): int\n  requires |coins| == 5\n{\n  coins[0] + coins[1] + coins[2] + coins[3] + coins[4]\n}\n\npredicate HasValidSolution(coins: seq<int>)\n  requires ValidInput(coins)\n{\n  var total := TotalCoins(coins);\n  total > 0 && total % 5 == 0\n}\n\nfunction ComputeResult(coins: seq<int>): int\n  requires ValidInput(coins)\n{\n  var total := TotalCoins(coins);\n  if total > 0 && total % 5 == 0 then total / 5 else -1\n}", "vc-helpers": "", "vc-spec": "method solve(coins: seq<int>) returns (result: int)\n  requires ValidInput(coins)\n  ensures result == ComputeResult(coins)\n  ensures HasValidSolution(coins) ==> result == TotalCoins(coins) / 5\n  ensures !HasValidSolution(coins) ==> result == -1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1339", "vc-description": "Given n segments on a coordinate line, where each segment i is defined by [l_i, r_i], \nfind a segment that covers all other segments. A segment [a, b] covers segment [c, d] \nif a \u2264 c \u2264 d \u2264 b. Return the 1-indexed number of such a segment, or -1 if none exists.", "vc-preamble": "predicate ValidInput(n: int, segments: seq<(int, int)>)\n{\n    n >= 1 && |segments| == n && \n    forall i :: 0 <= i < n ==> segments[i].0 <= segments[i].1\n}\n\npredicate CoversAll(segments: seq<(int, int)>, idx: int)\n{\n    0 <= idx < |segments| &&\n    forall j :: 0 <= j < |segments| ==> \n        segments[idx].0 <= segments[j].0 && segments[j].1 <= segments[idx].1\n}\n\npredicate HasMinLeftAndMaxRight(segments: seq<(int, int)>, idx: int)\n{\n    0 <= idx < |segments| &&\n    (forall j :: 0 <= j < |segments| ==> segments[idx].0 <= segments[j].0) &&\n    (forall j :: 0 <= j < |segments| ==> segments[idx].1 >= segments[j].1)\n}\n\nfunction MinLeft(segments: seq<(int, int)>): int\n    requires |segments| > 0\n{\n    if |segments| == 1 then segments[0].0\n    else if segments[0].0 <= MinLeft(segments[1..]) then segments[0].0\n    else MinLeft(segments[1..])\n}\n\nfunction MaxRight(segments: seq<(int, int)>): int\n    requires |segments| > 0\n{\n    if |segments| == 1 then segments[0].1\n    else if segments[0].1 >= MaxRight(segments[1..]) then segments[0].1\n    else MaxRight(segments[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, segments: seq<(int, int)>) returns (result: int)\n    requires ValidInput(n, segments)\n    ensures result == -1 || (1 <= result <= n)\n    ensures result != -1 ==> \n        (var idx := result - 1;\n         HasMinLeftAndMaxRight(segments, idx) &&\n         CoversAll(segments, idx))\n    ensures result == -1 ==> \n        !(exists i :: 0 <= i < n && HasMinLeftAndMaxRight(segments, i))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1346", "vc-description": "Given two polynomials f(x) and g(x) with positive integer coefficients,\nfind any coefficient in their product h(x) = f(x) \u00b7 g(x) that is not\ndivisible by a given prime p. The gcd constraint ensures at least one\ncoefficient in each polynomial is not divisible by p.", "vc-preamble": "predicate ValidInput(n: int, m: int, p: int, f: seq<int>, g: seq<int>) {\n    n >= 1 && m >= 1 &&\n    p >= 2 &&\n    |f| == n && |g| == m &&\n    (forall k :: 0 <= k < |f| ==> f[k] > 0) &&\n    (forall k :: 0 <= k < |g| ==> g[k] > 0) &&\n    (exists k :: 0 <= k < |f| && f[k] % p != 0) &&\n    (exists k :: 0 <= k < |g| && g[k] % p != 0)\n}\n\npredicate ValidResult(result: int, n: int, m: int, p: int, f: seq<int>, g: seq<int>) \n    requires p != 0\n{\n    exists i, j :: 0 <= i < |f| && 0 <= j < |g| &&\n            (forall k :: 0 <= k < i ==> f[k] % p == 0) &&\n            f[i] % p != 0 &&\n            (forall k :: 0 <= k < j ==> g[k] % p == 0) &&\n            g[j] % p != 0 &&\n            result == i + j &&\n            0 <= result < |f| + |g|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, p: int, f: seq<int>, g: seq<int>) returns (result: int)\n    requires ValidInput(n, m, p, f, g)\n    requires p != 0\n    ensures ValidResult(result, n, m, p, f, g)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_135", "vc-description": "Given two integers n and k, determine whether all remainders n mod i for i = 1, 2, ..., k are distinct.\nSpecifically, check if n mod 1 = 0, n mod 2 = 1, n mod 3 = 2, ..., n mod k = k-1.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 1\n}\n\npredicate AllRemaindersDistinct(n: int, k: int)\n    requires ValidInput(n, k)\n{\n    forall i :: 1 <= i <= k ==> n % i == (i - 1)\n}\n\npredicate HasNonDistinctRemainder(n: int, k: int)\n    requires ValidInput(n, k)\n{\n    exists i :: 1 <= i <= k && n % i != (i - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: string)\n    requires ValidInput(n, k)\n    ensures result == \"Yes\\n\" <==> AllRemaindersDistinct(n, k)\n    ensures result == \"No\\n\" <==> HasNonDistinctRemainder(n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1353", "vc-description": "Find the minimum cost for Ann to make exactly n subway rides, given two ticket options:\nsingle-ride tickets (cost a rubles each) and multi-ride tickets (cost b rubles, covers m rides).\nAnn can buy any combination of these tickets.\n\n// All single tickets\n\n// All multi-ride tickets (with potential waste)\n\n// Mixed: multi-ride + single for remainder", "vc-preamble": "predicate ValidInput(n: int, m: int, a: int, b: int)\n{\n    n >= 1 && n <= 1000 &&\n    m >= 1 && m <= 1000 &&\n    a >= 1 && a <= 1000 &&\n    b >= 1 && b <= 1000\n}\n\nfunction OptimalCost(n: int, m: int, a: int, b: int): int\n    requires ValidInput(n, m, a, b)\n{\n    min(\n        n * a,\n        min(\n            ((n + m - 1) / m) * b,\n            (n / m) * b + (n % m) * a\n        )\n    )\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, a: int, b: int) returns (result: int)\n    requires ValidInput(n, m, a, b)\n    ensures result >= 0\n    ensures result == OptimalCost(n, m, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1354", "vc-description": "Given a 1\u00d7n grid where Alice claims to have placed k ships of size a (consecutive cells)\nsuch that no two ships intersect or touch, and Bob makes m shots that all \"miss\",\ndetermine the first shot after which we can be certain Alice is cheating\n(i.e., it becomes impossible to place k non-intersecting, non-touching ships without hitting a shot).", "vc-preamble": "predicate ValidInput(n: int, k: int, a: int, m: int, shots: seq<int>)\n{\n    n > 0 && k > 0 && a > 0 && m > 0 && |shots| == m &&\n    (forall i :: 0 <= i < |shots| ==> 1 <= shots[i] <= n)\n}\n\nfunction canPlaceShipsFunc(n: int, k: int, a: int, shots: seq<int>, numShots: int): bool\n    requires n > 0 && k > 0 && a > 0 && numShots >= 0\n    requires numShots <= |shots|\n    requires forall i :: 0 <= i < |shots| ==> 1 <= shots[i] <= n\n{\n    var hitCells := set i | 0 <= i < numShots && i < |shots| :: shots[i];\n    greedyShipPlacement(n, k, a, hitCells) >= k\n}\n\nfunction greedyShipPlacement(n: int, k: int, a: int, hitCells: set<int>): int\n    requires n > 0 && k > 0 && a > 0\n    requires forall cell :: cell in hitCells ==> 1 <= cell <= n\n{\n    greedyPlaceShipsFromPosition(1, n, k, a, hitCells)\n}\n\nfunction greedyPlaceShipsFromPosition(pos: int, n: int, k: int, a: int, hitCells: set<int>): int\n    requires pos >= 1 && n > 0 && k >= 0 && a > 0\n    requires forall cell :: cell in hitCells ==> 1 <= cell <= n\n    decreases n - pos + 1, k\n{\n    if pos > n || k == 0 then 0\n    else if pos + a - 1 <= n && forall cell :: pos <= cell <= pos + a - 1 ==> cell !in hitCells then\n        1 + greedyPlaceShipsFromPosition(pos + a + 1, n, k - 1, a, hitCells)\n    else\n        greedyPlaceShipsFromPosition(pos + 1, n, k, a, hitCells)\n}\n\npredicate isNaturalNumberString(str: string)\n{\n    |str| > 0 && str[0] != '0' && forall i :: 0 <= i < |str| ==> '0' <= str[i] <= '9'\n}\n\nfunction parseInputSpec(input: string): seq<string>\n    requires |input| > 0\n    ensures |parseInputSpec(input)| >= 0\n{\n    []\n}\n\nfunction parseThreeIntsSpec(line: string): (int, int, int)\n    ensures parseThreeIntsSpec(line).0 > 0 && parseThreeIntsSpec(line).1 > 0 && parseThreeIntsSpec(line).2 > 0\n{\n    (1, 1, 1)\n}\n\nfunction parseIntSpec(line: string): int\n    ensures parseIntSpec(line) >= 0\n{\n    0\n}\n\nfunction parseIntArraySpec(line: string): seq<int>\n    ensures forall i :: 0 <= i < |parseIntArraySpec(line)| ==> parseIntArraySpec(line)[i] > 0\n{\n    []\n}\n\nfunction intToStringSpec(value: int): string\n    requires value >= 1\n    ensures |intToStringSpec(value)| > 0\n    ensures isNaturalNumberString(intToStringSpec(value))\n{\n    \"1\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires stdin_input[|stdin_input|-1] == '\\n'\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures result == \"-1\\n\" || (exists shot_num_str :: |shot_num_str| > 0 && result == shot_num_str + \"\\n\" && isNaturalNumberString(shot_num_str))\n    ensures var lines := parseInputSpec(stdin_input);\n            if |lines| >= 3 then\n                var firstLine := parseThreeIntsSpec(lines[0]);\n                var n, k, a := firstLine.0, firstLine.1, firstLine.2;\n                var m := parseIntSpec(lines[1]);\n                var shots := parseIntArraySpec(lines[2]);\n                if ValidInput(n, k, a, m, shots) then\n                    if canPlaceShipsFunc(n, k, a, shots, m) then\n                        result == \"-1\\n\"\n                    else\n                        exists shot_idx :: 1 <= shot_idx <= m && \n                                         result == intToStringSpec(shot_idx) + \"\\n\" &&\n                                         !canPlaceShipsFunc(n, k, a, shots, shot_idx) &&\n                                         (shot_idx == 1 || canPlaceShipsFunc(n, k, a, shots, shot_idx-1))\n                else\n                    true\n            else\n                true", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1356", "vc-description": "Given a string of lowercase English letters containing at least one 'a',\nfind the maximum length of a string obtainable by erasing some characters\nsuch that the resulting string has strictly more than half of its characters as 'a's.", "vc-preamble": "function count_a(s: string): int\n    ensures count_a(s) >= 0\n    ensures count_a(s) <= |s|\n{\n    if |s| == 0 then 0\n    else (if s[0] == 'a' then 1 else 0) + count_a(s[1..])\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}\n\npredicate ValidInput(s: string)\n{\n    |s| >= 1 && exists i :: 0 <= i < |s| && s[i] == 'a'\n}\n\npredicate IsGoodString(s: string)\n{\n    |s| > 0 && count_a(s) > |s| / 2\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result >= 1\n    ensures result <= |s|\n    ensures result == min(2 * count_a(s) - 1, |s|)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1357", "vc-description": "Given n houses numbered 1 to n arranged in a clockwise ring with one-way clockwise traffic,\nfind the minimum time to complete m tasks in sequence. Each task must be completed at a \nspecific house. Starting at house 1, moving from one house to the next adjacent house takes \n1 time unit. Tasks must be completed in the given order.", "vc-preamble": "predicate ValidInput(n: int, m: int, tasks: seq<int>)\n{\n    n >= 2 && m >= 1 && |tasks| == m && \n    forall i :: 0 <= i < |tasks| ==> 1 <= tasks[i] <= n\n}\n\nfunction MinTimeToComplete(n: int, tasks: seq<int>, currentPos: int, taskIndex: int): int\n    requires n >= 2\n    requires forall i :: 0 <= i < |tasks| ==> 1 <= tasks[i] <= n\n    requires 1 <= currentPos <= n\n    requires 0 <= taskIndex < |tasks|\n{\n    var target := tasks[taskIndex];\n    if target >= currentPos then target - currentPos\n    else (n - currentPos) + target\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, tasks: seq<int>) returns (result: int)\n    requires ValidInput(n, m, tasks)\n    ensures result >= 0\n    ensures m > 0 ==> result >= tasks[m-1] - 1\n    ensures result <= (m - 1) * n + tasks[m-1] - 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1361", "vc-description": "Given n holds at increasing heights, remove exactly one hold (not the first or last) \nto minimize the track difficulty. The difficulty is the maximum difference between \nconsecutive hold heights.", "vc-preamble": "predicate ValidInput(holds: seq<int>) {\n    |holds| >= 3 && forall i :: 0 <= i < |holds| - 1 ==> holds[i] < holds[i + 1]\n}\n\nfunction maxDiff(s: seq<int>): int\n    requires |s| >= 2\n    ensures maxDiff(s) >= 0\n{\n    if |s| <= 1 then 0\n    else\n        var maxSoFar := if s[1] - s[0] >= 0 then s[1] - s[0] else 0;\n        maxDiffHelper(s, 2, maxSoFar)\n}\n\nfunction maxDiffHelper(s: seq<int>, index: int, currentMax: int): int\n    requires 1 <= index <= |s|\n    requires currentMax >= 0\n    ensures maxDiffHelper(s, index, currentMax) >= currentMax\n    decreases |s| - index\n{\n    if index >= |s| then currentMax\n    else\n        var diff := s[index] - s[index - 1];\n        var newMax := if diff > currentMax then diff else currentMax;\n        maxDiffHelper(s, index + 1, newMax)\n}", "vc-helpers": "", "vc-spec": "method solve(holds: seq<int>) returns (result: int)\n    requires ValidInput(holds)\n    ensures result >= 0\n    ensures exists k :: 1 <= k < |holds| - 1 && result == maxDiff(holds[..k] + holds[k+1..])\n    ensures forall k :: 1 <= k < |holds| - 1 ==> result <= maxDiff(holds[..k] + holds[k+1..])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1381", "vc-description": "Given k people who each want to make n paper airplanes, where s airplanes can be made from one sheet of paper,\nand paper is sold in packs of p sheets each, find the minimum number of packs needed to buy so that each person\nhas enough sheets to make their n airplanes.", "vc-preamble": "predicate ValidInput(k: int, n: int, s: int, p: int)\n{\n  k >= 1 && n >= 1 && s >= 1 && p >= 1 &&\n  k <= 10000 && n <= 10000 && s <= 10000 && p <= 10000\n}\n\nfunction SheetsPerPerson(n: int, s: int): int\n  requires s >= 1\n{\n  (n + s - 1) / s\n}\n\nfunction TotalSheetsNeeded(k: int, n: int, s: int): int\n  requires s >= 1\n{\n  k * SheetsPerPerson(n, s)\n}\n\nfunction MinPacksNeeded(k: int, n: int, s: int, p: int): int\n  requires s >= 1 && p >= 1\n{\n  (TotalSheetsNeeded(k, n, s) + p - 1) / p\n}\n\npredicate CorrectResult(result: int, k: int, n: int, s: int, p: int)\n  requires s >= 1 && p >= 1\n{\n  result == MinPacksNeeded(k, n, s, p) &&\n  result * p >= TotalSheetsNeeded(k, n, s) &&\n  (result - 1) * p < TotalSheetsNeeded(k, n, s)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, n: int, s: int, p: int) returns (result: int)\n  requires ValidInput(k, n, s, p)\n  ensures result >= 1\n  ensures CorrectResult(result, k, n, s, p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1386", "vc-description": "Given a w\u00d7h grid, place square tiles that are diagonally split into white and black halves.\nEach tile can be rotated in 4 orientations. Adjacent tiles must have different colors on their\nshared edge. Count the number of valid tilings modulo 998244353.", "vc-preamble": "predicate ValidInput(input: string)\n{\n  |input| > 0 &&\n  exists i :: 0 < i < |input| - 1 && input[i] == ' ' &&\n  (forall j :: 0 <= j < i ==> '0' <= input[j] <= '9') &&\n  (forall j :: i < j < |input| ==> '0' <= input[j] <= '9')\n}\n\npredicate ValidDimensions(w: int, h: int)\n{\n  w >= 1 && h >= 1 && w <= 1000 && h <= 1000\n}\n\nfunction ParseTwoInts(input: string): (int, int)\n  requires ValidInput(input)\n{\n  var spaceIndex := FindSpace(input, 0);\n  var w := StringToInt(input[0..spaceIndex]);\n  var h := StringToInt(input[spaceIndex+1..]);\n  (w, h)\n}\n\nfunction FindSpace(s: string, start: int): int\n  requires 0 <= start < |s|\n  requires exists i :: start <= i < |s| && s[i] == ' '\n  ensures start <= FindSpace(s, start) < |s|\n  ensures s[FindSpace(s, start)] == ' '\n  decreases |s| - start\n{\n  if s[start] == ' ' then start\n  else FindSpace(s, start + 1)\n}\n\nfunction StringToInt(s: string): int\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n  if |s| == 1 then s[0] as int - '0' as int\n  else StringToInt(s[0..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction IntToString(n: int): string\n  requires n >= 0\n  ensures |IntToString(n)| > 0\n{\n  if n == 0 then \"0\"\n  else if n < 10 then [('0' as int + n) as char]\n  else IntToString(n / 10) + IntToString(n % 10)\n}\n\nfunction ModPow(base: int, exp: int, mod: int): int\n  requires mod > 1\n  requires exp >= 0\n  ensures 0 <= ModPow(base, exp, mod) < mod\n{\n  if exp == 0 then 1 % mod\n  else if exp % 2 == 0 then\n    var half := ModPow(base, exp / 2, mod);\n    (half * half) % mod\n  else\n    (base * ModPow(base, exp - 1, mod)) % mod\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1394", "vc-description": "Given a string t, find a string s such that when you create s' by removing all 'a' \ncharacters from s (keeping other characters in order) and concatenate s and s' to \nform t = s + s', output the unique string s if it exists, otherwise output \":(\".", "vc-preamble": "function CountAs(s: string): int\n    ensures 0 <= CountAs(s) <= |s|\n    ensures CountAs(s) == |s| ==> (forall i :: 0 <= i < |s| ==> s[i] == 'a')\n{\n    if |s| == 0 then 0\n    else if s[0] == 'a' then 1 + CountAs(s[1..])\n    else CountAs(s[1..])\n}\n\nfunction RemoveAs(s: string): string\n    ensures |RemoveAs(s)| <= |s|\n    ensures |RemoveAs(s)| == |s| - CountAs(s)\n    ensures forall i :: 0 <= i < |RemoveAs(s)| ==> RemoveAs(s)[i] != 'a'\n{\n    if |s| == 0 then \"\"\n    else if s[0] == 'a' then RemoveAs(s[1..])\n    else [s[0]] + RemoveAs(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(t: string) returns (result: string)\n    requires |t| >= 1\n    ensures result == \":(\" || (|result| <= |t| && t == result + RemoveAs(result))\n    ensures result != \":(\" ==> (\n        var z := CountAs(t);\n        var nonACount := |t| - z;\n        nonACount % 2 == 0 &&\n        var q := nonACount / 2;\n        var sLength := q + z;\n        sLength <= |t| &&\n        result == t[..sLength] &&\n        RemoveAs(result) == t[sLength..]\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1395", "vc-description": "Given a positive integer represented as a string and a divisor m, find the minimum remainder \nwhen dividing any valid cyclic shift of the integer by m. A cyclic shift is valid if it \ndoesn't have leading zeros when interpreted as an integer.", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n  |stdin_input| > 0 && exists pos :: 0 <= pos < |stdin_input| && stdin_input[pos] == '\\n'\n}\n\npredicate ValidDigitString(s: string)\n{\n  |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate ValidNumberString(s: string)\n{\n  ValidDigitString(s) && s[0] != '0'\n}\n\npredicate ValidOutput(result: string)\n{\n  |result| > 0 && forall i :: 0 <= i < |result| ==> '0' <= result[i] <= '9'\n}\n\nfunction isGoodShift(s: string, shift: int): bool\n  requires 0 <= shift < |s|\n  requires |s| > 0\n{\n  s[shift] != '0'\n}\n\nfunction cyclicShiftRemainder(s: string, shift: int, m: int): int\n  requires 0 <= shift < |s|\n  requires |s| > 0\n  requires m >= 2\n  requires ValidDigitString(s)\n  ensures 0 <= cyclicShiftRemainder(s, shift, m) < m\n{\n  cyclicShiftRemainderHelper(s, shift, m, 0, 0)\n}\n\nfunction cyclicShiftRemainderHelper(s: string, shift: int, m: int, pos: int, acc: int): int\n  requires 0 <= shift < |s|\n  requires |s| > 0\n  requires m >= 2\n  requires 0 <= pos <= |s|\n  requires 0 <= acc < m\n  requires ValidDigitString(s)\n  ensures 0 <= cyclicShiftRemainderHelper(s, shift, m, pos, acc) < m\n  decreases |s| - pos\n{\n  if pos == |s| then acc\n  else\n    var idx := (shift + pos) % |s|;\n    var digit := (s[idx] as int) - ('0' as int);\n    var newAcc := (acc * 10 + digit) % m;\n    cyclicShiftRemainderHelper(s, shift, m, pos + 1, newAcc)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires ValidInput(stdin_input)\n  ensures ValidOutput(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1409", "vc-description": "Given n students where each student has participated in ACM ICPC championship y_i times (0 \u2264 y_i \u2264 5),\nform the maximum number of teams such that: each team has exactly 3 students, no student can be on \nmultiple teams, and each team can participate together at least k more times (since each student can \nparticipate at most 5 times total). Find the maximum number of teams that can be formed.", "vc-preamble": "function count_eligible(participations: seq<int>, k: int): int\n    requires 0 <= k <= 5\n    requires forall i :: 0 <= i < |participations| ==> 0 <= participations[i] <= 5\n{\n    if |participations| == 0 then 0\n    else (if 5 - participations[0] >= k then 1 else 0) + count_eligible(participations[1..], k)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, participations: seq<int>) returns (result: int)\n    requires 0 <= k <= 5\n    requires n == |participations|\n    requires forall i :: 0 <= i < |participations| ==> 0 <= participations[i] <= 5\n    ensures result == (count_eligible(participations, k) / 3)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1419", "vc-description": "Given a text containing words separated by spaces, where some words contain hyphens\nthat serve as valid line break points, format the text to fit within at most k lines\nwhile minimizing the maximum line width. Line breaks can occur at spaces (space stays\non current line) or at hyphens (hyphen stays on current line, remainder goes to next line).\n\n// Potential break point\n\n// Must break line\n\n// Can continue on current line or break\n\n// Regular character - must continue on current line", "vc-preamble": "predicate canFormatText(s: string, k: int, maxWidth: int)\n    requires k >= 1\n    requires |s| >= 1\n    requires maxWidth >= 1\n{\n    checkFormatting(s, k, maxWidth, 0, 1, 0)\n}\n\npredicate checkFormatting(s: string, k: int, maxWidth: int, pos: int, lines: int, currentLine: int)\n    requires k >= 1\n    requires |s| >= 1\n    requires maxWidth >= 1\n    requires 0 <= pos <= |s|\n    requires lines >= 1\n    requires currentLine >= 0\n    decreases |s| - pos\n{\n    if pos == |s| then\n        lines <= k && currentLine <= maxWidth\n    else\n        if s[pos] == ' ' || s[pos] == '-' then\n\n            if currentLine + 1 > maxWidth then\n\n                if lines + 1 > k then\n                    false\n                else\n                    checkFormatting(s, k, maxWidth, pos + 1, lines + 1, 1)\n            else\n\n                (checkFormatting(s, k, maxWidth, pos + 1, lines, currentLine + 1) ||\n                 (lines < k && checkFormatting(s, k, maxWidth, pos + 1, lines + 1, 1)))\n        else\n\n            if currentLine + 1 > maxWidth then\n                false\n            else\n                checkFormatting(s, k, maxWidth, pos + 1, lines, currentLine + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, s: string) returns (result: int)\n    requires k >= 1\n    requires |s| >= 1\n    ensures result >= 1\n    ensures result <= |s|\n    ensures canFormatText(s, k, result)\n    ensures result > 1 ==> !canFormatText(s, k, result - 1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1430", "vc-description": "Given a binary string S of length N and an integer K, find the maximum length of \nconsecutive '1's achievable using at most K flip operations. Each flip operation \nchooses a contiguous range and flips all bits in that range (0\u21921, 1\u21920).", "vc-preamble": "predicate ValidInput(N: int, K: int, S: string)\n{\n    N > 0 && K >= 0 && |S| == N && \n    forall i :: 0 <= i < |S| ==> S[i] == '0' || S[i] == '1'\n}\n\nfunction StringToBits(S: string): seq<int>\n    requires forall i :: 0 <= i < |S| ==> S[i] == '0' || S[i] == '1'\n{\n    seq(|S|, i requires 0 <= i < |S| => if S[i] == '0' then 0 else 1)\n}\n\npredicate ValidResult(result: int, N: int)\n{\n    0 <= result <= N\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, K: int, S: string) returns (result: int)\n    requires ValidInput(N, K, S)\n    ensures ValidResult(result, N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_144", "vc-description": "Given a sequence of n digits, determine if it can be divided into two or more \nnon-overlapping contiguous segments such that all segments have equal digit sums.\nEach digit must belong to exactly one segment.", "vc-preamble": "predicate CanPartitionIntoEqualSumSegments(input: string)\n    requires |input| > 0\n{\n    var lines := SplitLines(input);\n    if |lines| < 2 then false\n    else\n        var nStr := Trim(lines[0]);\n        var digitsStr := Trim(lines[1]);\n        var n := ParseInt(nStr);\n        if n < 2 || n > 100 || |digitsStr| != n then false\n        else\n            var digits := ParseDigits(digitsStr);\n            if |digits| != n then false\n            else\n                exists i {:trigger Sum(digits[..i + 1])} :: 0 <= i < n - 1 && \n                    var firstSum := Sum(digits[..i + 1]);\n                    firstSum >= 0 &&\n                    CanPartitionRemainder(digits, i + 1, firstSum)\n}\n\npredicate CanPartitionRemainder(digits: seq<int>, start: int, targetSum: int)\n    requires 0 <= start <= |digits|\n    requires targetSum >= 0\n    decreases |digits| - start\n{\n    if start >= |digits| then true\n    else\n        exists segmentEnd :: start < segmentEnd <= |digits| && \n            Sum(digits[start..segmentEnd]) == targetSum &&\n            CanPartitionRemainder(digits, segmentEnd, targetSum)\n}\n\nfunction Sum(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + Sum(s[1..])\n}\n\nfunction ParseInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then CharToDigit(s[0])\n    else CharToDigit(s[0]) * Power10(|s| - 1) + ParseInt(s[1..])\n}\n\nfunction CharToDigit(c: char): int\n    ensures CharToDigit(c) >= 0\n{\n    if '0' <= c <= '9' then (c as int) - ('0' as int) else 0\n}\n\nfunction Power10(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 1 else 10 * Power10(n - 1)\n}\n\nfunction ParseDigits(s: string): seq<int>\n    ensures forall j :: 0 <= j < |ParseDigits(s)| ==> ParseDigits(s)[j] >= 0\n{\n    if |s| == 0 then []\n    else [CharToDigit(s[0])] + ParseDigits(s[1..])\n}\n\nfunction SplitLines(s: string): seq<string>\n{\n    SplitByChar(s, '\\n')\n}\n\nfunction SplitByChar(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else if s[0] == delimiter then [\"\"] + SplitByChar(s[1..], delimiter)\n    else \n        var rest := SplitByChar(s[1..], delimiter);\n        if |rest| == 0 then [s[..1]]\n        else [s[..1] + rest[0]] + rest[1..]\n}\n\nfunction Trim(s: string): string\n{\n    TrimLeft(TrimRight(s))\n}\n\nfunction TrimLeft(s: string): string\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' then TrimLeft(s[1..])\n    else s\n}\n\nfunction TrimRight(s: string): string\n{\n    if |s| == 0 then s\n    else if s[|s| - 1] == ' ' || s[|s| - 1] == '\\t' || s[|s| - 1] == '\\n' || s[|s| - 1] == '\\r' then TrimRight(s[..|s| - 1])\n    else s\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures result == \"YES\\n\" <==> CanPartitionIntoEqualSumSegments(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1448", "vc-description": "Given integers n and d, determine for each grasshopper whether their position \nis inside or on the boundary of a cornfield quadrilateral with vertices at \n(0,d), (d,0), (n,n-d), (n-d,n). Output \"YES\" if inside/on boundary, \"NO\" otherwise.", "vc-preamble": "function ValidInput(input: string): bool\n{\n    var lines := SplitLines(input);\n    |lines| >= 3 && \n    ValidFirstLine(lines[0]) &&\n    ValidSecondLine(lines[1]) &&\n    ValidGrasshopperLinesSimple(lines) &&\n    var firstLine := SplitSpaces(lines[0]);\n    var n := StringToInt(firstLine[0]);\n    var d := StringToInt(firstLine[1]);\n    var m := StringToInt(lines[1]);\n    d >= 1 && d < n && n <= 100 &&\n    m >= 1 && m <= 100 &&\n    |lines| >= 2 + m &&\n    forall i {:trigger ValidGrasshopperLine(lines[2 + i], n)} :: 0 <= i < m ==> ValidGrasshopperLine(lines[2 + i], n)\n}\n\nfunction ValidFirstLine(line: string): bool\n{\n    var parts := SplitSpaces(line);\n    |parts| == 2 && IsValidInteger(parts[0]) && IsValidInteger(parts[1])\n}\n\nfunction ValidSecondLine(line: string): bool\n{\n    IsValidInteger(line)\n}\n\nfunction ValidGrasshopperLinesSimple(lines: seq<string>): bool\n{\n    |lines| >= 3 &&\n    var m := StringToInt(lines[1]);\n    |lines| >= 2 + m\n}\n\nfunction ValidGrasshopperLine(line: string, n: int): bool\n{\n    var parts := SplitSpaces(line);\n    |parts| == 2 && IsValidInteger(parts[0]) && IsValidInteger(parts[1]) &&\n    StringToInt(parts[0]) >= 0 && StringToInt(parts[0]) <= n &&\n    StringToInt(parts[1]) >= 0 && StringToInt(parts[1]) <= n\n}\n\nfunction IsValidInteger(s: string): bool\n{\n    |s| > 0 && (s[0] != '-' ==> forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9') &&\n    (s[0] == '-' ==> |s| > 1 && forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction GetN(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var firstLine := SplitSpaces(lines[0]);\n    StringToInt(firstLine[0])\n}\n\nfunction GetD(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var firstLine := SplitSpaces(lines[0]);\n    StringToInt(firstLine[1])\n}\n\nfunction GetNumberOfGrasshoppers(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    StringToInt(lines[1])\n}\n\nfunction GetGrasshopper(input: string, i: int): (int, int)\n    requires ValidInput(input)\n    requires 0 <= i < GetNumberOfGrasshoppers(input)\n{\n    var lines := SplitLines(input);\n    var coords := SplitSpaces(lines[2 + i]);\n    assert ValidGrasshopperLine(lines[2 + i], GetN(input));\n    assert |coords| == 2;\n    (StringToInt(coords[0]), StringToInt(coords[1]))\n}\n\nfunction IsInsideCornfield(grasshopper: (int, int), n: int, d: int): bool\n{\n    var (x, y) := grasshopper;\n    x + y >= d && x + y <= 2 * n - d && x - y >= -d && x - y <= d\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: seq<string>)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |result| == GetNumberOfGrasshoppers(input)\n    ensures forall i :: 0 <= i < |result| ==> result[i] == \"YES\" || result[i] == \"NO\"\n    ensures forall i :: 0 <= i < |result| ==> \n        result[i] == (if IsInsideCornfield(GetGrasshopper(input, i), GetN(input), GetD(input)) then \"YES\" else \"NO\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_145", "vc-description": "Given a username string containing only lowercase English letters, determine the user's gender\nbased on the number of distinct characters: odd count means male, even count means female.\nOutput \"IGNORE HIM!\" for male, \"CHAT WITH HER!\" for female.", "vc-preamble": "function CountDistinct(s: string): int\n{\n    |set c | 0 <= c < |s| :: s[c]|\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    input[|input|-1] == '\\n' &&\n    |input| >= 2 &&\n    forall i :: 0 <= i < |input|-1 ==> 'a' <= input[i] <= 'z'\n}\n\npredicate CorrectOutput(username: string, output: string)\n{\n    var distinctCount := CountDistinct(username);\n    (distinctCount % 2 == 1 ==> output == \"IGNORE HIM!\\n\") &&\n    (distinctCount % 2 == 0 ==> output == \"CHAT WITH HER!\\n\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures var username := input[..|input|-1];\n            CorrectOutput(username, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1451", "vc-description": "Given n positive integers and a threshold k, count how many integers contain at most k lucky digits.\nLucky digits are 4 and 7.", "vc-preamble": "predicate ValidInput(n: int, k: int, numbers: seq<int>)\n{\n    n >= 1 && k >= 0 && |numbers| == n && forall i :: 0 <= i < |numbers| ==> numbers[i] > 0\n}\n\nfunction countLuckyDigits(num: int): int\n    requires num >= 0\n    ensures countLuckyDigits(num) >= 0\n    ensures num == 0 ==> countLuckyDigits(num) == 0\n    ensures num > 0 ==> countLuckyDigits(num) == (if (num % 10 == 4 || num % 10 == 7) then 1 else 0) + countLuckyDigits(num / 10)\n{\n    if num == 0 then 0\n    else\n        var digit := num % 10;\n        var rest := num / 10;\n        var digitCount := if digit == 4 || digit == 7 then 1 else 0;\n        digitCount + countLuckyDigits(rest)\n}\n\nfunction countValidNumbers(numbers: seq<int>, k: int, upTo: int): int\n    requires 0 <= upTo <= |numbers|\n    requires k >= 0\n    requires forall i :: 0 <= i < |numbers| ==> numbers[i] >= 0\n    ensures 0 <= countValidNumbers(numbers, k, upTo) <= upTo\n{\n    if upTo == 0 then 0\n    else \n        var prevCount := countValidNumbers(numbers, k, upTo - 1);\n        if countLuckyDigits(numbers[upTo - 1]) <= k then prevCount + 1 else prevCount\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, numbers: seq<int>) returns (result: int)\n    requires ValidInput(n, k, numbers)\n    ensures 0 <= result <= n\n    ensures result == |set i | 0 <= i < |numbers| && countLuckyDigits(numbers[i]) <= k|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1461", "vc-description": "Given a functional directed graph where each vertex i has exactly one outgoing edge\nto vertex f[i] with weight w[i], find for each starting vertex the sum and minimum\nweight of all edges on a path of exactly k edges.", "vc-preamble": "predicate ValidGraph(n: int, f: seq<int>, w: seq<int>)\n{\n  n > 0 && |f| == n && |w| == n &&\n  (forall i :: 0 <= i < n ==> 0 <= f[i] < n) &&\n  (forall i :: 0 <= i < n ==> w[i] >= 0)\n}\n\npredicate ValidResult(n: int, sums: seq<int>, mins: seq<int>)\n{\n  |sums| == n && |mins| == n &&\n  forall i :: 0 <= i < n ==> sums[i] >= 0 && mins[i] >= 0\n}\n\nfunction PathSum(start: int, k: int, f: seq<int>, w: seq<int>): int\n  requires |f| == |w| && |f| > 0\n  requires 0 <= start < |f|\n  requires k >= 0\n  requires forall i :: 0 <= i < |f| ==> 0 <= f[i] < |f|\n  requires forall i :: 0 <= i < |w| ==> w[i] >= 0\n  decreases k\n{\n  if k == 0 then 0\n  else w[start] + PathSum(f[start], k - 1, f, w)\n}\n\nfunction PathMin(start: int, k: int, f: seq<int>, w: seq<int>): int\n  requires |f| == |w| && |f| > 0\n  requires 0 <= start < |f|\n  requires k > 0\n  requires forall i :: 0 <= i < |f| ==> 0 <= f[i] < |f|\n  requires forall i :: 0 <= i < |w| ==> w[i] >= 0\n  decreases k\n{\n  if k == 1 then w[start]\n  else\n    var nextMin := PathMin(f[start], k - 1, f, w);\n    if w[start] <= nextMin then w[start] else nextMin\n}", "vc-helpers": "", "vc-spec": "method SolveGraph(n: int, k: int, f: seq<int>, w: seq<int>) returns (sums: seq<int>, mins: seq<int>)\n  requires ValidGraph(n, f, w)\n  requires k > 0\n  ensures ValidResult(n, sums, mins)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_148", "vc-description": "Given a circular subway with n stations, determine if two trains moving in opposite directions\nwill ever meet at the same station. Train 1 moves clockwise (1\u21922\u2192...\u2192n\u21921), Train 2 moves \ncounterclockwise (n\u2192(n-1)\u2192...\u21921\u2192n). Daniel boards Train 1 at station a, exits at x.\nVlad boards Train 2 at station b, exits at y. All a,x,b,y are distinct.", "vc-preamble": "predicate validInput(input: string)\nreads *\nrequires |input| > 0\nrequires exists i :: 0 <= i < |input| && input[i] == '\\n'\n{\n    var parts := parseInput(input);\n    |parts| == 5 &&\n    parts[0] >= 4 && parts[0] <= 100 &&\n    parts[1] >= 1 && parts[1] <= parts[0] &&\n    parts[2] >= 1 && parts[2] <= parts[0] &&\n    parts[3] >= 1 && parts[3] <= parts[0] &&\n    parts[4] >= 1 && parts[4] <= parts[0] &&\n    parts[1] != parts[2] && parts[1] != parts[3] && parts[1] != parts[4] &&\n    parts[2] != parts[3] && parts[2] != parts[4] &&\n    parts[3] != parts[4]\n}\n\npredicate trainsWillMeet(input: string)\nreads *\nrequires |input| > 0\nrequires exists i :: 0 <= i < |input| && input[i] == '\\n'\nrequires validInput(input)\n{\n    var parts := parseInput(input);\n    var n := parts[0];\n    var a := parts[1];\n    var x := parts[2];\n    var b := parts[3]; \n    var y := parts[4];\n\n    if a == b then true\n    else simulateTrains(n, a, x, b, y)\n}\n\nfunction simulateTrains(n: int, a: int, x: int, b: int, y: int): bool\nrequires n >= 4 && 1 <= a <= n && 1 <= x <= n && 1 <= b <= n && 1 <= y <= n\nrequires a != x && a != b && a != y && x != b && x != y && b != y\ndecreases 2 * n\n{\n    simulateTrainsHelper(n, a, x, b, y, 2 * n)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\nrequires |stdin_input| > 0\nrequires exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n'\nrequires validInput(stdin_input)\nensures result == \"YES\\n\" || result == \"NO\\n\"\nensures result == \"YES\\n\" <==> trainsWillMeet(stdin_input)\nensures result == \"NO\\n\" <==> !trainsWillMeet(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1486", "vc-description": "Given n cities located on a coordinate axis with positions in ascending order,\ncalculate for each city the minimum and maximum cost to send a letter to any other city.\nThe cost equals the distance between cities.", "vc-preamble": "predicate ValidInput(cities: seq<int>)\n{\n  |cities| >= 2 &&\n  forall i, j :: 0 <= i < j < |cities| ==> cities[i] < cities[j]\n}\n\nfunction MinDistance(cities: seq<int>, i: int): int\n  requires ValidInput(cities)\n  requires 0 <= i < |cities|\n{\n  if i == 0 then\n    cities[1] - cities[0]\n  else if i == |cities| - 1 then\n    cities[i] - cities[i-1]\n  else\n    var left_dist := cities[i] - cities[i-1];\n    var right_dist := cities[i+1] - cities[i];\n    if left_dist <= right_dist then left_dist else right_dist\n}\n\nfunction MaxDistance(cities: seq<int>, i: int): int\n  requires ValidInput(cities)\n  requires 0 <= i < |cities|\n{\n  if i == 0 then\n    cities[|cities|-1] - cities[0]\n  else if i == |cities| - 1 then\n    cities[i] - cities[0]\n  else\n    var dist_to_first := cities[i] - cities[0];\n    var dist_to_last := cities[|cities|-1] - cities[i];\n    if dist_to_first >= dist_to_last then dist_to_first else dist_to_last\n}\n\npredicate ValidOutput(cities: seq<int>, min_distances: seq<int>, max_distances: seq<int>)\n{\n  ValidInput(cities) &&\n  |min_distances| == |cities| &&\n  |max_distances| == |cities| &&\n  forall i :: 0 <= i < |cities| ==> \n    min_distances[i] == MinDistance(cities, i) &&\n    max_distances[i] == MaxDistance(cities, i) &&\n    min_distances[i] > 0 &&\n    max_distances[i] > 0\n}", "vc-helpers": "", "vc-spec": "method CalculateDistances(cities: seq<int>) returns (min_distances: seq<int>, max_distances: seq<int>)\n  requires ValidInput(cities)\n  ensures ValidOutput(cities, min_distances, max_distances)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1512", "vc-description": "Given a permutation of integers from 1 to n, determine which single element to remove\nto maximize the number of records in the remaining sequence. A record is an element\nthat is greater than all elements that appear before it in the sequence. If multiple\nelements can be removed to achieve the same maximum number of records, return the\nsmallest such element.", "vc-preamble": "predicate ValidPermutation(p: seq<int>, n: int)\n{\n  |p| == n && n >= 1 &&\n  (forall i :: 0 <= i < n ==> 1 <= p[i] <= n) &&\n  (forall i, j :: 0 <= i < j < n ==> p[i] != p[j])\n}\n\nfunction countRecords(s: seq<int>): int\n  ensures countRecords(s) >= 0\n{\n  if |s| == 0 then 0\n  else 1 + countRecordsFromIndex(s, 1, s[0])\n}\n\nfunction countRecordsAfterRemoval(p: seq<int>, toRemove: int): int\n  requires forall i :: 0 <= i < |p| ==> 1 <= p[i] <= |p|\n  requires forall i, j :: 0 <= i < j < |p| ==> p[i] != p[j]\n  requires toRemove in p\n{\n  var filtered := seq(|p| - 1, i requires 0 <= i < |p| - 1 => \n    if indexOf(p, toRemove) <= i then p[i + 1] else p[i]);\n  countRecords(filtered)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: seq<int>) returns (result: int)\n  requires ValidPermutation(p, n)\n  ensures 1 <= result <= n\n  ensures result in p\n  ensures forall x :: x in p ==> countRecordsAfterRemoval(p, result) >= countRecordsAfterRemoval(p, x)\n  ensures forall x :: x in p && countRecordsAfterRemoval(p, x) == countRecordsAfterRemoval(p, result) ==> result <= x", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1526", "vc-description": "Given three integers A, B, and C, find the minimum number of operations to make all three equal.\nOperations: (1) Choose any two numbers and increase both by 1, (2) Choose any one number and increase it by 2.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int) {\n    0 <= A <= 50 && 0 <= B <= 50 && 0 <= C <= 50\n}\n\nfunction MaxOf3(A: int, B: int, C: int): int {\n    if A >= B && A >= C then A\n    else if B >= C then B\n    else C\n}\n\nfunction SortDescending(A: int, B: int, C: int): (int, int, int) {\n    if A >= B && A >= C then\n        if B >= C then (A, B, C) else (A, C, B)\n    else if B >= A && B >= C then\n        if A >= C then (B, A, C) else (B, C, A)\n    else\n        if A >= B then (C, A, B) else (C, B, A)\n}\n\nfunction MinOperations(A: int, B: int, C: int): int\n    requires ValidInput(A, B, C)\n{\n    var (a0, a1, a2) := SortDescending(A, B, C);\n    var gap1 := a0 - a1;\n    var updated_smallest := a2 + gap1;\n    var remaining_gap := a0 - updated_smallest;\n    gap1 + remaining_gap / 2 + (remaining_gap % 2) * 2\n}\n\npredicate AllEqual(A: int, B: int, C: int) {\n    A == B && B == C\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int) returns (result: int)\n    requires ValidInput(A, B, C)\n    ensures result >= 0\n    ensures AllEqual(A, B, C) ==> result == 0\n    ensures result == MinOperations(A, B, C)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1529", "vc-description": "Given n sentences from a chat record, determine the speaker of each sentence based on these patterns:\n- Freda always ends her sentences with \"lala.\"\n- Rainbow always begins his sentences with \"miao.\"\nFor each sentence, classify it as spoken by Freda, Rainbow, or unknown if it's ambiguous or matches neither pattern.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 0\n}\n\nfunction SplitLines_func(input: string): seq<string>\n    requires |input| >= 0\n{\n    if |input| == 0 then []\n    else SplitLines_helper(input, 0, \"\", [])\n}\n\nfunction SplitLines_helper(input: string, i: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= i <= |input|\n    requires forall j :: 0 <= j < |current| ==> current[j] != '\\n'\n    decreases |input| - i\n{\n    if i == |input| then\n        if |current| > 0 then acc + [current] else acc\n    else if input[i] == '\\n' then\n        SplitLines_helper(input, i + 1, \"\", acc + [current])\n    else\n        SplitLines_helper(input, i + 1, current + [input[i]], acc)\n}\n\nfunction ParseInt_func(s: string): int\n    requires |s| >= 0\n    ensures ParseInt_func(s) >= 0\n{\n    if |s| == 0 then 0\n    else ParseInt_helper(s, 0, 0)\n}\n\nfunction ParseInt_helper(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    requires acc >= 0\n    ensures ParseInt_helper(s, i, acc) >= 0\n    decreases |s| - i\n{\n    if i == |s| || !('0' <= s[i] <= '9') then acc\n    else ParseInt_helper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n}\n\nfunction BuildOutput_func(lines: seq<string>, n: int): string\n    requires |lines| > 0\n    requires n >= 0\n    requires n <= |lines| - 1\n{\n    if n == 0 then \"\"\n    else if n == 1 then ClassifySentence_func(lines[1])\n    else BuildOutput_func(lines, n-1) + \"\\n\" + ClassifySentence_func(lines[n])\n}\n\nfunction ClassifySentence_func(sentence: string): string\n{\n    if EndsWith_func(sentence, \"lala.\") && !StartsWith_func(sentence, \"miao.\") then \"Freda's\"\n    else if StartsWith_func(sentence, \"miao.\") && !EndsWith_func(sentence, \"lala.\") then \"Rainbow's\" \n    else \"OMG>.< I don't know!\"\n}\n\nfunction StartsWith_func(s: string, prefix: string): bool\n    requires |prefix| >= 0\n{\n    |prefix| <= |s| && (forall i :: 0 <= i < |prefix| ==> s[i] == prefix[i])\n}\n\nfunction EndsWith_func(s: string, suffix: string): bool\n    requires |suffix| >= 0\n{\n    |suffix| <= |s| && (forall i :: 0 <= i < |suffix| ==> s[|s| - |suffix| + i] == suffix[i])\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| >= 0\n    ensures var lines := SplitLines_func(input); \n            if |lines| == 0 then result == \"\"\n            else (var n := ParseInt_func(lines[0]);\n                  result == BuildOutput_func(lines, min(n, |lines| - 1)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1533", "vc-description": "Given a sequence of names, for each position i, determine if that same name\nappeared at any earlier position j < i in the sequence.", "vc-preamble": "predicate ValidOutput(names: seq<string>, output: seq<string>)\n{\n    |output| == |names| &&\n    forall i :: 0 <= i < |names| ==> \n        output[i] == (if exists j :: 0 <= j < i && names[j] == names[i] then \"YES\" else \"NO\")\n}", "vc-helpers": "", "vc-spec": "method solve(names: seq<string>) returns (output: seq<string>)\n    ensures ValidOutput(names, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1541", "vc-description": "Given a string representing a lever with weights and a pivot, determine if the lever\ntilts left, right, or remains balanced based on torque calculations.\nThe pivot is marked by '^', weights are digits 1-9, and empty positions are '='.\nTorque = weight \u00d7 distance from pivot. Left weights contribute positive torque,\nright weights contribute negative torque.", "vc-preamble": "predicate ValidLeverInput(s: string)\n{\n    |s| >= 3 &&\n    (exists i :: 0 <= i < |s| && s[i] == '^') &&\n    (forall i :: 0 <= i < |s| ==> (s[i] == '^' || s[i] == '=' || ('1' <= s[i] <= '9'))) &&\n    (forall i, j :: 0 <= i < j < |s| && s[i] == '^' ==> s[j] != '^') &&\n    (forall i :: 0 <= i < |s| && s[i] == '^' ==> (i != 0 && i != |s| - 1))\n}\n\nfunction FindPivot(s: string): int\n    requires exists i :: 0 <= i < |s| && s[i] == '^'\n    requires forall i, j :: 0 <= i < j < |s| && s[i] == '^' ==> s[j] != '^'\n    ensures 0 <= FindPivot(s) < |s|\n    ensures s[FindPivot(s)] == '^'\n    ensures forall j :: 0 <= j < FindPivot(s) ==> s[j] != '^'\n{\n    FindPivotHelper(s, 0)\n}\n\nfunction FindPivotHelper(s: string, index: int): int\n    requires 0 <= index <= |s|\n    requires exists i :: index <= i < |s| && s[i] == '^'\n    ensures index <= FindPivotHelper(s, index) < |s|\n    ensures s[FindPivotHelper(s, index)] == '^'\n    ensures forall j :: index <= j < FindPivotHelper(s, index) ==> s[j] != '^'\n    decreases |s| - index\n{\n    if index >= |s| then 0\n    else if s[index] == '^' then index\n    else FindPivotHelper(s, index + 1)\n}\n\nfunction CalculateTorque(s: string, pivotPos: int): int\n    requires 0 <= pivotPos < |s|\n{\n    CalculateTorqueHelper(s, pivotPos, 0)\n}\n\nfunction CalculateTorqueHelper(s: string, pivotPos: int, index: int): int\n    requires 0 <= pivotPos < |s|\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index >= |s| then 0\n    else if '1' <= s[index] <= '9' then\n        var weight := (s[index] as int) - ('0' as int);\n        (pivotPos - index) * weight + CalculateTorqueHelper(s, pivotPos, index + 1)\n    else\n        CalculateTorqueHelper(s, pivotPos, index + 1)\n}\n\nfunction CalculateTorquePartial(s: string, pivotPos: int, upTo: int): int\n    requires 0 <= pivotPos < |s|\n    requires 0 <= upTo <= |s|\n{\n    CalculateTorqueHelper(s, pivotPos, 0) - CalculateTorqueHelper(s, pivotPos, upTo)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidLeverInput(s)\n    ensures result == \"left\" || result == \"right\" || result == \"balance\"\n    ensures var pivotPos := FindPivot(s);\n            var torque := CalculateTorque(s, pivotPos);\n            (torque > 0 ==> result == \"left\") &&\n            (torque < 0 ==> result == \"right\") &&\n            (torque == 0 ==> result == \"balance\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1547", "vc-description": "Given an n\u00d7m grid initially filled with color 0, perform k painting operations and output the final grid.\nOperations can paint entire rows or columns with specified colors.\nWhen a cell is painted multiple times, it takes the color of the most recent operation affecting it.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| > 0 && |SplitString(lines[0], ' ')| == 3 &&\n    var n := StringToInt(SplitString(lines[0], ' ')[0]);\n    var m := StringToInt(SplitString(lines[0], ' ')[1]);\n    var k := StringToInt(SplitString(lines[0], ' ')[2]);\n    n > 0 && m > 0 && k >= 0 && |lines| >= k + 1\n}\n\nfunction GetDimensions(input: string): (int, int, int)\nrequires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var firstLine := SplitString(lines[0], ' ');\n    (StringToInt(firstLine[0]), StringToInt(firstLine[1]), StringToInt(firstLine[2]))\n}\n\nfunction ComputeGrid(lines: seq<string>, n: int, m: int, k: int): seq<seq<int>>\nrequires n > 0 && m > 0 && k >= 0\nrequires |lines| >= k + 1\n{\n    var row := seq(n, i => (0, -1));\n    var col := seq(m, i => (0, -1));\n    var processedArrays := ProcessOperations(lines, n, m, k, 0, row, col);\n    BuildGrid(n, m, processedArrays.0, processedArrays.1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires |input| > 0\nensures !ValidInput(input) ==> result == \"\"\nensures ValidInput(input) ==> \n        var (n, m, k) := GetDimensions(input);\n        var lines := SplitLines(input);\n        result == FormatGrid(ComputeGrid(lines, n, m, k))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_155", "vc-description": "Given an n\u00d7m matrix where n is even, determine Lara's position after exactly k moves\nfollowing a specific path: start at (1,1), move down column 1 to (n,1), then move in\na snake pattern through remaining columns alternating between moving right-up-left-up\nuntil reaching (1,2). Find coordinates after exactly k moves.", "vc-preamble": "predicate ValidInput(n: int, m: int, k: int) {\n    n >= 2 && m >= 2 && n % 2 == 0 && k >= 0 && k < n * m\n}\n\npredicate ValidOutput(result: seq<int>, n: int, m: int) {\n    |result| == 2 && result[0] >= 1 && result[0] <= n && result[1] >= 1 && result[1] <= m\n}\n\npredicate CorrectPosition(result: seq<int>, n: int, m: int, k: int) \n    requires ValidInput(n, m, k)\n    requires |result| == 2\n{\n    if k < n then\n        result[0] == k + 1 && result[1] == 1\n    else\n        var k_remaining := k - n;\n        var r := n - k_remaining / (m - 1);\n        result[0] == r &&\n        (r % 2 == 1 ==> result[1] == m - k_remaining % (m - 1)) &&\n        (r % 2 == 0 ==> result[1] == 2 + k_remaining % (m - 1))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int) returns (result: seq<int>)\n    requires ValidInput(n, m, k)\n    ensures ValidOutput(result, n, m)\n    ensures CorrectPosition(result, n, m, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1550", "vc-description": "Given a combination lock display with n digits, find the smallest possible number \nachievable using two operations: (1) Add 1 to all digits (9 wraps to 0), and \n(2) Shift all digits one position right (rightmost digit becomes leftmost).\nLeading zeros are ignored when comparing numbers for size.", "vc-preamble": "predicate ValidInput(n: int, digits: string)\n{\n    n > 0 && |digits| == n && forall i :: 0 <= i < |digits| ==> '0' <= digits[i] <= '9'\n}\n\nfunction modifyString(s: string, index: int): string\n    requires 0 <= index < |s|\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures |modifyString(s, index)| == |s|\n    ensures forall i :: 0 <= i < |modifyString(s, index)| ==> '0' <= modifyString(s, index)[i] <= '9'\n{\n    var key := if s[index] == '0' then 0 else 10 - (s[index] as int - '0' as int);\n    var transformed := transformDigits(s, key);\n    rotateString(transformed, index)\n}\n\nfunction transformDigits(s: string, key: int): string\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires 0 <= key <= 9\n    ensures |transformDigits(s, key)| == |s|\n    ensures forall i :: 0 <= i < |transformDigits(s, key)| ==> '0' <= transformDigits(s, key)[i] <= '9'\n    decreases |s|\n{\n    if |s| == 0 then \"\"\n    else \n        var digit := (s[0] as int - '0' as int + key) % 10;\n        [('0' as int + digit) as char] + transformDigits(s[1..], key)\n}\n\nfunction rotateString(s: string, index: int): string\n    requires 0 <= index < |s|\n    ensures |rotateString(s, index)| == |s|\n{\n    if |s| == 0 then \"\"\n    else s[index..] + s[..index]\n}\n\npredicate isAllDigits(s: string)\n{\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction parseInput(input: string): seq<string>\n    ensures |parseInput(input)| >= 0\n    decreases |input|\n{\n    parseInputHelper(input, 0, \"\", [])\n}\n\nfunction parseInputHelper(input: string, i: int, currentLine: string, lines: seq<string>): seq<string>\n    requires 0 <= i <= |input|\n    ensures |parseInputHelper(input, i, currentLine, lines)| >= |lines|\n    decreases |input| - i\n{\n    if i >= |input| then\n        if |currentLine| > 0 then lines + [currentLine] else lines\n    else if input[i] == '\\n' then\n        parseInputHelper(input, i + 1, \"\", lines + [currentLine])\n    else\n        parseInputHelper(input, i + 1, currentLine + [input[i]], lines)\n}\n\nfunction parseInt(s: string): int\n    ensures parseInt(s) >= 0\n{\n    if |s| == 0 then 0\n    else if !('0' <= s[0] <= '9') then 0\n    else (s[0] as int - '0' as int) + 10 * parseInt(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n'\n    ensures |result| > 0\n    ensures result[|result| - 1] == '\\n'\n    ensures var lines := parseInput(stdin_input);\n            if |lines| >= 2 then\n                var n := parseInt(lines[0]);\n                var digits := lines[1];\n                if ValidInput(n, digits) then\n                    var minResult := result[..|result|-1];\n                    |minResult| == n &&\n                    (forall i :: 0 <= i < |minResult| ==> '0' <= minResult[i] <= '9') &&\n                    (exists index :: 0 <= index < n && minResult == modifyString(digits, index)) &&\n                    (forall index :: 0 <= index < n ==> minResult <= modifyString(digits, index))\n                else\n                    result == \"\\n\"\n            else\n                result == \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1568", "vc-description": "Given n messages arriving at specified times, determine the maximum money achievable by time T.\nEach message has initial value A that decreases by B per minute after arrival.\nEarn C per unread message per minute. All messages must be read by time T.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, c: int, t: int, arrivals: seq<int>) \n{\n    1 <= n <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    1 <= c <= 1000 &&\n    1 <= t <= 1000 &&\n    |arrivals| == n &&\n    forall i :: 0 <= i < |arrivals| ==> 1 <= arrivals[i] <= t\n}\n\nfunction sum_seq(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + sum_seq(s[1..])\n}\n\nfunction MaxMoney(n: int, a: int, b: int, c: int, t: int, arrivals: seq<int>): int\n    requires ValidInput(n, a, b, c, t, arrivals)\n{\n    if b > c then n * a\n    else n * a + (c - b) * (n * t - sum_seq(arrivals))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, c: int, t: int, arrivals: seq<int>) returns (result: int)\n    requires ValidInput(n, a, b, c, t, arrivals)\n    ensures result == MaxMoney(n, a, b, c, t, arrivals)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_157", "vc-description": "Given the number of lemons (a), apples (b), and pears (c), find the maximum total number of fruits\nthat can be used to make a compote following the recipe ratio of 1:2:4 (lemons:apples:pears).\nFruits must be used whole and cannot be cut or broken. If no complete recipe units can be made, output 0.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= c <= 1000\n}\n\nfunction MaxRecipeUnits(a: int, b: int, c: int): int\n{\n    min(a, min(b / 2, c / 4))\n}\n\nfunction TotalFruitsUsed(units: int): int\n{\n    units * 7\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int) returns (result: int)\n    requires ValidInput(a, b, c)\n    ensures result == TotalFruitsUsed(MaxRecipeUnits(a, b, c))\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1576", "vc-description": "Decrypt a string that was encrypted using the Right-Left cipher.\nThe Right-Left cipher encrypts by starting with the first character,\nthen alternating between appending to the right (even positions) and\nprepending to the left (odd positions) for subsequent characters.", "vc-preamble": "predicate ValidInput(t: string)\n{\n    |t| >= 1\n}", "vc-helpers": "", "vc-spec": "method solve(t: string) returns (result: string)\n    requires ValidInput(t)\n    ensures |result| == |t|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1577", "vc-description": "Given a string input containing two lines: an integer n and a string s of length n with only 'A' and 'D' characters,\ndetermine which character appears more frequently. Return \"Anton\" if 'A' appears more, \"Danik\" if 'D' appears more,\nor \"Friendship\" if they appear equally.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && exists newlinePos :: 0 <= newlinePos < |input| && input[newlinePos] == '\\n'\n}\n\npredicate ValidParsedInput(lines: seq<string>)\n{\n    |lines| >= 2 && IsValidInteger(lines[0]) && IsValidGameString(lines[1]) &&\n    var n := StringToInt(lines[0]);\n    var s := lines[1];\n    |s| == n && n >= 1\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] >= '0' && s[i] <= '9'\n}\n\npredicate IsValidGameString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == 'A' || s[i] == 'D'\n}\n\nfunction CountChar(s: string, c: char): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + CountChar(s[1..], c)\n}\n\nfunction DetermineWinner(countA: int, countD: int): string\n{\n    if countA > countD then \"Anton\"\n    else if countD > countA then \"Danik\"  \n    else \"Friendship\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    requires ValidParsedInput(SplitLines(input))\n    ensures result == \"Anton\" || result == \"Danik\" || result == \"Friendship\"\n    ensures var lines := SplitLines(input);\n            var s := lines[1];\n            var countA := CountChar(s, 'A');\n            var countD := CountChar(s, 'D');\n            result == DetermineWinner(countA, countD)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1578", "vc-description": "Given an integer N, find a permutation P\u2081, P\u2082, ..., P\u2099 of numbers 1 to N\nthat maximizes the sum M\u2081 + M\u2082 + ... + M\u2099, where M\u1d62 is the remainder when i is divided by P\u1d62.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction MaxSum(n: int): int\n    requires n >= 1\n{\n    n * (n - 1) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == MaxSum(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1586", "vc-description": "Given a non-negative integer N, compute the double factorial f(N) where f(n) = 1 if n < 2,\nand f(n) = n \u00d7 f(n-2) if n \u2265 2. Find the number of trailing zeros in the decimal representation of f(N).\nTrailing zeros are produced by factors of 10, which come from pairs of prime factors 2 and 5.", "vc-preamble": "function ValidInput(N: int): bool\n{\n  N >= 0\n}\n\nfunction FactorsInFactorial(n: int, p: int): int\n  requires p > 1\n  requires n >= 0\n  ensures FactorsInFactorial(n, p) >= 0\n  ensures n == 0 ==> FactorsInFactorial(n, p) == 0\n  ensures n > 0 ==> FactorsInFactorial(n, p) == n / p + FactorsInFactorial(n / p, p)\n  decreases n\n{\n  if n == 0 then 0\n  else n / p + FactorsInFactorial(n / p, p)\n}\n\nfunction FactorsInDoubleFactorial(n: int, p: int): int\n  requires p > 1\n  requires n >= 0\n  ensures FactorsInDoubleFactorial(n, p) >= 0\n  ensures n <= 0 ==> FactorsInDoubleFactorial(n, p) == 0\n  ensures n > 0 && n % 2 == 1 ==> FactorsInDoubleFactorial(n, p) == FactorsInFactorial(n, p) - FactorsInDoubleFactorial(n - 1, p)\n  ensures n > 0 && n % 2 == 0 ==> FactorsInDoubleFactorial(n, p) == FactorsInFactorial(n / 2, p) + (if p == 2 then n / 2 else 0)\n  decreases n\n{\n  if n <= 0 then 0\n  else if n % 2 == 1 then\n    FactorsInFactorial(n, p) - FactorsInDoubleFactorial(n - 1, p)\n  else\n    FactorsInFactorial(n / 2, p) + (if p == 2 then n / 2 else 0)\n}\n\npredicate ValidResult(N: int, result: int)\n  requires N >= 0\n{\n  result >= 0 &&\n  result == (if FactorsInDoubleFactorial(N, 2) < FactorsInDoubleFactorial(N, 5) then FactorsInDoubleFactorial(N, 2) else FactorsInDoubleFactorial(N, 5))\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: int)\n  requires ValidInput(N)\n  ensures ValidResult(N, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1594", "vc-description": "Given a playlist of n songs where song i has duration t_i minutes and is played c_i consecutive times.\nThe playlist plays songs in order: song 1 (c_1 times), then song 2 (c_2 times), etc.\nFor m given time moments, determine which song number is playing at each moment.", "vc-preamble": "function sum_playlist_duration(songs: seq<(int, int)>, n: int): int\n  requires n >= 0\n  requires |songs| >= n\n  requires forall i :: 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n{\n  if n == 0 then 0\n  else songs[n-1].0 * songs[n-1].1 + sum_playlist_duration(songs, n-1)\n}\n\nfunction cumulative_duration_at_song(songs: seq<(int, int)>, song_idx: int): int\n  requires song_idx >= -1\n  requires |songs| > song_idx\n  requires forall i :: 0 <= i <= song_idx ==> songs[i].0 > 0 && songs[i].1 > 0\n{\n  if song_idx == -1 then 0\n  else songs[song_idx].0 * songs[song_idx].1 + cumulative_duration_at_song(songs, song_idx - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, songs: seq<(int, int)>, queries: seq<int>) returns (result: seq<int>)\n  requires n >= 0\n  requires m >= 0\n  requires |songs| == n\n  requires |queries| == m\n  requires forall i :: 0 <= i < n ==> songs[i].0 > 0 && songs[i].1 > 0\n  requires forall i :: 0 <= i < m - 1 ==> queries[i] < queries[i + 1]\n  requires forall i :: 0 <= i < m ==> queries[i] >= 1\n  requires m == 0 || queries[m-1] <= sum_playlist_duration(songs, n)\n  ensures |result| == m\n  ensures forall i :: 0 <= i < m ==> 1 <= result[i] <= n\n  ensures forall i :: 0 <= i < m ==> queries[i] <= cumulative_duration_at_song(songs, result[i] - 1)\n  ensures forall i :: 0 <= i < m ==> result[i] == 1 || queries[i] > cumulative_duration_at_song(songs, result[i] - 2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1598", "vc-description": "Given a binary string s, find a binary string t of the same length such that\nfor every substring s[l..r] and t[l..r], they have the same length of longest\nnon-decreasing subsequence, and the number of zeros in t is maximized.", "vc-preamble": "predicate ValidBinaryString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}\n\nfunction LongestNonDecreasingSubseq(str: string): nat\n    requires ValidBinaryString(str)\n{\n    if |str| == 0 then 0\n    else if |str| == 1 then 1\n    else\n        LongestNonDecreasingSubseqHelper(str, 1, 1, 1)\n}\n\nfunction LongestNonDecreasingSubseqHelper(str: string, i: int, currentLen: nat, maxLen: nat): nat\n    requires ValidBinaryString(str)\n    requires 1 <= i <= |str|\n    requires currentLen >= 1\n    requires maxLen >= 1\n    decreases |str| - i\n{\n    if i >= |str| then maxLen\n    else\n        var newCurrentLen := if str[i] >= str[i-1] then currentLen + 1 else 1;\n        var newMaxLen := if newCurrentLen > maxLen then newCurrentLen else maxLen;\n        LongestNonDecreasingSubseqHelper(str, i + 1, newCurrentLen, newMaxLen)\n}\n\nfunction CountZeros(str: string): nat\n    requires ValidBinaryString(str)\n    decreases |str|\n{\n    if |str| == 0 then 0\n    else if str[0] == '0' then 1 + CountZeros(str[1..])\n    else CountZeros(str[1..])\n}\n\npredicate SameSubsequenceLengths(s: string, t: string)\n    requires ValidBinaryString(s) && ValidBinaryString(t)\n    requires |s| == |t|\n{\n    forall l, r :: 0 <= l <= r <= |s| ==> \n        LongestNonDecreasingSubseq(s[l..r]) == LongestNonDecreasingSubseq(t[l..r])\n}\n\npredicate ValidSolution(s: string, t: string)\n    requires ValidBinaryString(s) && ValidBinaryString(t)\n{\n    |s| == |t| && SameSubsequenceLengths(s, t)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    requires ValidBinaryString(s)\n    ensures ValidBinaryString(result)\n    ensures ValidSolution(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1605", "vc-description": "Given a string of length n containing only 'a' and 'b' characters, count the number of \"good\" substrings of even length and odd length.\nA substring is \"good\" if after merging all consecutive equal characters, the resulting string is a palindrome.\nFor example: \"aabba\" becomes \"aba\" after merging, which is a palindrome, so \"aabba\" is good.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == 'a' || s[i] == 'b'\n}\n\nfunction MergeConsecutive(s: string): string\n    requires |s| > 0\n{\n    if |s| == 1 then s\n    else if s[0] == s[1] then MergeConsecutive(s[1..])\n    else [s[0]] + MergeConsecutive(s[1..])\n}\n\nfunction IsPalindrome(s: string): bool\n{\n    if |s| <= 1 then true\n    else s[0] == s[|s|-1] && IsPalindrome(s[1..|s|-1])\n}\n\npredicate IsGoodSubstring(s: string, i: int, j: int)\n    requires ValidInput(s) && 0 <= i <= j < |s|\n{\n    var sub := s[i..j+1];\n    IsPalindrome(MergeConsecutive(sub))\n}\n\npredicate ValidOutput(s: string, evenCount: int, oddCount: int)\n    requires ValidInput(s)\n{\n    evenCount >= 0 && oddCount >= 0 &&\n    evenCount + oddCount >= |s| &&\n    oddCount >= |s| &&\n    (|s| == 1 ==> evenCount == 0 && oddCount == 1)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (evenCount: int, oddCount: int)\n    requires ValidInput(s)\n    ensures ValidOutput(s, evenCount, oddCount)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1615", "vc-description": "Given n non-intersecting integer segments, find the minimum number of moves\nto make the total count of integers covered by all segments divisible by k.\nEach move extends any segment by 1 unit either left or right.", "vc-preamble": "ghost predicate ValidInputFormat(s: string) {\n    var lines := SplitLines(s);\n    |lines| >= 1 &&\n    exists n: nat, k: nat :: \n        ParsesAsIntegers(lines[0], n as int, k as int) && n > 0 && k > 0 && |lines| >= n + 1 &&\n        (forall i :: 1 <= i <= n && i < |lines| ==> \n            exists a: int, b: int :: ParsesAsIntegers(lines[i], a, b))\n}\n\nghost predicate ParsedCorrectly(input: string, n: nat, k: nat, segments: seq<(int, int)>) {\n    var lines := SplitLines(input);\n    |lines| >= n + 1 && |segments| == n &&\n    ParsesAsIntegers(lines[0], n as int, k as int) &&\n    (forall i :: 0 <= i < n && i + 1 < |lines| ==> \n        ParsesAsIntegers(lines[i + 1], segments[i].0, segments[i].1))\n}\n\npredicate IsValidOutput(s: string) {\n    |s| > 0 && s[|s| - 1] == '\\n' && \n    (forall i :: 0 <= i < |s| - 1 ==> s[i] != '\\n') &&\n    IsNumericOutput(s[..|s| - 1])\n}\n\nfunction MinMovesToDivisible(segments: seq<(int, int)>, k: nat): nat\n    requires k > 0\n    ensures MinMovesToDivisible(segments, k) < k\n{\n    var totalCoverage := TotalCoverage(segments);\n    var remainder := totalCoverage % k;\n    if remainder == 0 then 0 else k - remainder\n}\n\nfunction TotalCoverage(segments: seq<(int, int)>): nat {\n    if |segments| == 0 then 0\n    else SegmentLength(segments[0]) + TotalCoverage(segments[1..])\n}\n\nfunction SegmentLength(segment: (int, int)): nat\n    ensures SegmentLength(segment) >= 1\n{\n    var maxVal := MaxInt(segment.0, segment.1);\n    var minVal := MinInt(segment.0, segment.1);\n    if maxVal >= minVal then (maxVal - minVal + 1) as nat else 1\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires stdin_input[|stdin_input| - 1] == '\\n' || !ContainsNewline(stdin_input)\n    ensures |result| == 0 || result[|result| - 1] == '\\n'\n    ensures ValidInputFormat(stdin_input) ==> \n        exists n: nat, k: nat, segments: seq<(int, int)> ::\n            n > 0 && k > 0 && |segments| == n &&\n            ParsedCorrectly(stdin_input, n, k, segments) &&\n            result == IntToString(MinMovesToDivisible(segments, k)) + \"\\n\"\n    ensures ValidInputFormat(stdin_input) ==> IsValidOutput(result)\n    ensures !ValidInputFormat(stdin_input) ==> \n        (result == \"\" || (|result| > 0 && result[|result| - 1] == '\\n'))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1617", "vc-description": "Given n people sitting in a circle numbered 1 to n, person 1 starts with a ball and chooses a positive integer k \u2264 n.\nThe ball is passed to the k-th neighbor in clockwise direction repeatedly until it returns to person 1.\nThe fun value is the sum of all unique person IDs who touched the ball during this process.\nFind all possible fun values for all valid choices of k.", "vc-preamble": "function f(n: int, x: int): int\n  requires x > 0 && n >= x && n % x == 0\n{\n  var y := n / x;\n  y + x * y * (y - 1) / 2\n}\n\npredicate IsDivisor(d: int, n: int)\n{\n  d > 0 && n % d == 0\n}\n\npredicate IsSorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\npredicate NoDuplicates(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<int>)\n  requires n >= 2\n  ensures NoDuplicates(result)\n  ensures IsSorted(result)\n  ensures forall v :: v in result <==> exists d :: IsDivisor(d, n) && v == f(n, d)\n  ensures |result| > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1618", "vc-description": "Given a staircase with n stairs at non-decreasing heights, process m boxes thrown sequentially.\nEach box has width w and height h, covering stairs 1 through w. A box falls until its bottom \ntouches either a stair top or a previously placed box top within its coverage area.\nDetermine the landing height of each box's bottom.", "vc-preamble": "function max(a: int, b: int): int\n{\n    if a >= b then a else b\n}\n\npredicate ValidStairs(stair_heights: seq<int>)\n{\n    |stair_heights| >= 1 &&\n    (forall i :: 0 <= i < |stair_heights| - 1 ==> stair_heights[i] <= stair_heights[i + 1]) &&\n    (forall i :: 0 <= i < |stair_heights| ==> stair_heights[i] >= 0)\n}\n\npredicate ValidBoxes(boxes: seq<(int, int)>, stairs_amount: int)\n{\n    forall i :: 0 <= i < |boxes| ==> boxes[i].0 >= 1 && boxes[i].0 <= stairs_amount && boxes[i].1 >= 1\n}\n\npredicate ValidResult(result: seq<int>, boxes: seq<(int, int)>, stair_heights: seq<int>)\n    requires |stair_heights| >= 1\n    requires forall i :: 0 <= i < |boxes| ==> boxes[i].0 >= 1 && boxes[i].0 <= |stair_heights|\n{\n    |result| == |boxes| &&\n    (forall i :: 0 <= i < |boxes| ==> result[i] >= 0) &&\n    (forall i :: 0 <= i < |boxes| ==> \n        result[i] >= stair_heights[0] && result[i] >= stair_heights[boxes[i].0 - 1]) &&\n    (forall i :: 0 <= i < |boxes| ==> \n        result[i] == max(if i == 0 then stair_heights[0] else result[i-1] + boxes[i-1].1, \n                        stair_heights[boxes[i].0 - 1]))\n}", "vc-helpers": "", "vc-spec": "method solve(stairs_amount: int, stair_heights: seq<int>, boxes_amount: int, boxes: seq<(int, int)>) returns (result: seq<int>)\n    requires stairs_amount >= 1\n    requires |stair_heights| == stairs_amount\n    requires boxes_amount >= 0\n    requires |boxes| == boxes_amount\n    requires ValidStairs(stair_heights)\n    requires ValidBoxes(boxes, stairs_amount)\n    ensures ValidResult(result, boxes, stair_heights)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_162", "vc-description": "Find the minimum number of hours to water a garden of length k using exactly one type of bucket.\nEach bucket type i can water a continuous segment of length a_i per hour.\nMust choose a bucket size that evenly divides the garden length to avoid gaps or overlaps.", "vc-preamble": "predicate ValidInput(n: int, k: int, a: seq<int>)\n{\n    n >= 1 && k >= 1 && |a| == n &&\n    (forall i :: 0 <= i < |a| ==> a[i] >= 1) &&\n    (exists i :: 0 <= i < |a| && k % a[i] == 0)\n}\n\npredicate ValidBucket(k: int, bucketSize: int)\n{\n    bucketSize >= 1 && k % bucketSize == 0\n}\n\nfunction HoursNeeded(k: int, bucketSize: int): int\n    requires ValidBucket(k, bucketSize)\n{\n    k / bucketSize\n}\n\npredicate IsOptimalChoice(k: int, a: seq<int>, chosenBucket: int)\n{\n    0 <= chosenBucket < |a| &&\n    ValidBucket(k, a[chosenBucket]) &&\n    (forall i :: 0 <= i < |a| && ValidBucket(k, a[i]) ==> a[i] <= a[chosenBucket])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, k, a)\n    ensures result >= 1\n    ensures exists i :: IsOptimalChoice(k, a, i) && result == HoursNeeded(k, a[i])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1620", "vc-description": "Given a positive integer n, construct a string of length n using only characters 'a', 'b', and 'c' such that:\n1. The string contains no palindromic substrings of length 3\n2. The number of 'c' characters is minimized", "vc-preamble": "predicate ValidInput(n: int)\n{\n  n >= 1\n}\n\npredicate ValidOutput(s: string, n: int)\n{\n  |s| == n &&\n  (forall i :: 0 <= i < |s| ==> s[i] == 'a' || s[i] == 'b' || s[i] == 'c') &&\n  (forall i :: 0 <= i <= |s| - 3 ==> !(s[i] == s[i+2]))\n}\n\npredicate MinimalCUsage(s: string)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == 'a' || s[i] == 'b'\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n  requires ValidInput(n)\n  ensures ValidOutput(result, n)\n  ensures MinimalCUsage(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1621", "vc-description": "Given a string of lowercase letters and a value for each letter, calculate the maximum \npossible value of a string after inserting exactly k lowercase letters. The value of a \nstring s = s\u2081s\u2082...s\u2099 is defined as f(s) = \u03a3\u1d62\u208c\u2081\u207f (w\u209b\u1d62 \u00d7 i), where w\u209b\u1d62 is the value of \ncharacter s\u1d62 and i is its 1-indexed position.", "vc-preamble": "function stringValue(s: string, w: seq<int>): int\n  requires |w| == 26\n  requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n{\n  if |s| == 0 then 0\n  else\n    var charIndex := (s[|s|-1] as int) - ('a' as int);\n    stringValue(s[..|s|-1], w) + |s| * w[charIndex]\n}\n\nfunction appendValue(startPos: int, count: int, maxVal: int): int\n  requires startPos >= 0\n  requires count >= 0\n{\n  if count == 0 then 0\n  else (startPos + count) * maxVal + appendValue(startPos, count - 1, maxVal)\n}\n\nfunction maxValue(w: seq<int>): int\n  requires |w| > 0\n  ensures exists i :: 0 <= i < |w| && maxValue(w) == w[i]\n  ensures forall i :: 0 <= i < |w| ==> w[i] <= maxValue(w)\n{\n  if |w| == 1 then w[0]\n  else if w[0] >= maxValue(w[1..]) then w[0]\n  else maxValue(w[1..])\n}\n\npredicate ValidInput(s: string, k: int, w: seq<int>)\n{\n  |w| == 26 && \n  k >= 0 && \n  |s| <= 1000 && \n  k <= 1000 && \n  (forall i :: 0 <= i < |w| ==> 0 <= w[i] <= 1000) &&\n  (forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z')\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, k: int, w: seq<int>) returns (result: int)\n  requires ValidInput(s, k, w)\n  ensures result == stringValue(s, w) + appendValue(|s|, k, maxValue(w))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1623", "vc-description": "Given an array of n positive integers where the number of distinct elements \nis between l and r (inclusive) and each element is either 1 or even with its \nhalf also present in the array, find the minimum and maximum possible sums.", "vc-preamble": "predicate ValidInput(n: int, l: int, r: int)\n{\n    n >= 1 && l >= 1 && r >= l && r <= n && r <= 20\n}\n\nfunction MinSumCalculation(n: int, l: int): int\n    requires n >= 1 && l >= 1\n{\n    var start_power := Power(2, l - 1);\n    SumWithDecreasingPowers(n, start_power)\n}\n\nfunction MaxSumCalculation(n: int, r: int): int\n    requires n >= 1 && r >= 1\n{\n    var max_power := Power(2, r - 1);\n    SumWithIncreasingPowers(n, max_power)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, l: int, r: int) returns (min_sum: int, max_sum: int)\n    requires ValidInput(n, l, r)\n    ensures min_sum > 0\n    ensures max_sum > 0\n    ensures min_sum <= max_sum\n    ensures min_sum == MinSumCalculation(n, l)\n    ensures max_sum == MaxSumCalculation(n, r)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1627", "vc-description": "Given an array of n integers representing animal heights, sort the array in non-decreasing order\nusing a specific operation that selects a segment of even length and swaps adjacent pairs within it.\nOutput the sequence of operations (at most 20,000) needed to sort the array.", "vc-preamble": "predicate ValidInput(n: int, arr: seq<int>)\n{\n    n >= 1 && |arr| == n && forall i :: 0 <= i < |arr| ==> arr[i] >= 1\n}\n\npredicate ValidOperations(operations: seq<(int, int)>, n: int)\n{\n    forall op :: op in operations ==> 1 <= op.0 <= n && 1 <= op.1 <= n && op.1 == op.0 + 1\n}\n\nfunction isSorted(arr: seq<int>): bool\n{\n    forall i :: 0 <= i < |arr| - 1 ==> arr[i] <= arr[i+1]\n}\n\nfunction applyOperations(arr: seq<int>, operations: seq<(int, int)>): seq<int>\n  ensures multiset(applyOperations(arr, operations)) == multiset(arr)\n  decreases |operations|\n{\n    if |operations| == 0 then arr\n    else \n        var op := operations[0];\n        if 1 <= op.0 <= |arr| && 1 <= op.1 <= |arr| && op.1 == op.0 + 1 then\n            var newArr := swapAdjacent(arr, op.0 - 1, op.1 - 1);\n            applyOperations(newArr, operations[1..])\n        else\n            applyOperations(arr, operations[1..])\n}\n\nfunction countInversions(arr: seq<int>): nat\n{\n    |set i, j | 0 <= i < j < |arr| && arr[i] > arr[j] :: (i, j)|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, arr: seq<int>) returns (operations: seq<(int, int)>)\n  requires ValidInput(n, arr)\n  ensures ValidOperations(operations, n)\n  ensures var finalArr := applyOperations(arr, operations); isSorted(finalArr) || |operations| == 20000\n  ensures multiset(arr) == multiset(applyOperations(arr, operations))\n  ensures |operations| <= 20000\n  ensures isSorted(arr) ==> |operations| == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1628", "vc-description": "Given a string containing only 'x' and 'y' characters, apply operations:\n1. Swap leftmost \"yx\" to \"xy\" \n2. Remove leftmost \"xy\"\nApply operation 1 if possible, otherwise operation 2, repeat until no operations possible.\nReturn the final non-empty string.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == 'x' || s[i] == 'y'\n}\n\nfunction countChar(s: string, c: char): nat\n{\n    |set i | 0 <= i < |s| && s[i] == c|\n}\n\npredicate ValidOutput(s: string, result: string)\n    requires ValidInput(s)\n{\n    var countX := countChar(s, 'x');\n    var countY := countChar(s, 'y');\n    if countY > countX then\n        |result| == countY - countX && forall i :: 0 <= i < |result| ==> result[i] == 'y'\n    else\n        |result| == countX - countY && forall i :: 0 <= i < |result| ==> result[i] == 'x'\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures ValidOutput(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_163", "vc-description": "Given a line of n cells and a grasshopper that can jump exactly k cells at a time,\ndetermine if the grasshopper can reach a target cell. The line contains exactly one\ngrasshopper ('G'), one target ('T'), empty cells ('.'), and obstacles ('#').\nThe grasshopper can only land on empty cells or the target.", "vc-preamble": "predicate ValidInput(n: int, k: int, s: string)\n{\n    n >= 2 &&\n    1 <= k < n &&\n    |s| == n &&\n    (exists i :: 0 <= i < |s| && s[i] == 'G') &&\n    (exists i :: 0 <= i < |s| && s[i] == 'T') &&\n    (forall i :: 0 <= i < |s| ==> s[i] in {'G', 'T', '.', '#'}) &&\n    (forall i, j :: 0 <= i < j < |s| && s[i] == 'G' ==> s[j] != 'G') &&\n    (forall i, j :: 0 <= i < j < |s| && s[i] == 'T' ==> s[j] != 'T')\n}\n\nfunction FindFirstGOrT(s: string): int\n    requires exists i :: 0 <= i < |s| && s[i] in {'G', 'T'}\n{\n    if s[0] in {'G', 'T'} then 0\n    else FindFirstGOrT(s[1..]) + 1\n}\n\npredicate CanReachTarget(s: string, k: int)\n    requires k > 0\n{\n    exists start :: \n        0 <= start < |s| && \n        s[start] in {'G', 'T'} &&\n        (forall j :: 0 <= j < start ==> s[j] !in {'G', 'T'}) &&\n        (exists final :: \n            start < final < |s| &&\n            s[final] in {'G', 'T'} &&\n            (final - start) % k == 0 &&\n            (forall pos :: start < pos < final && (pos - start) % k == 0 ==> s[pos] !in {'G', 'T', '#'})\n        )\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, s: string) returns (result: string)\n    requires ValidInput(n, k, s)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanReachTarget(s, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1631", "vc-description": "Given n strings of lowercase Latin letters, determine if there exists a permutation \nof the 26 lowercase Latin letters such that the strings are in lexicographical order\naccording to this custom alphabet. Output the valid alphabet permutation or \"Impossible\".", "vc-preamble": "ghost predicate validInput(stdin_input: string, n: int)\n{\n    exists lines :: (parseInput(stdin_input) == lines &&\n    |lines| >= 1 &&\n    |lines| == n + 1 &&\n    parseInt(lines[0]) == n &&\n    n >= 1 && n <= 100 &&\n    (forall i :: 1 <= i < |lines| ==> \n        1 <= |lines[i]| <= 100 && \n        forall j :: 0 <= j < |lines[i]| ==> 'a' <= lines[i][j] <= 'z'))\n}\n\nghost predicate validAlphabetOrdering(stdin_input: string, alphabet: string)\n    requires |alphabet| == 26\n    requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'\n    requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]\n{\n    exists lines, n :: (parseInput(stdin_input) == lines &&\n    |lines| >= 1 &&\n    |lines| == n + 1 &&\n    parseInt(lines[0]) == n &&\n    (forall i :: 1 <= i < n ==> lexicographicallyLessOrEqual(lines[i], lines[i+1], alphabet)))\n}\n\nghost predicate lexicographicallyLessOrEqual(s1: string, s2: string, alphabet: string)\n    requires |alphabet| == 26\n    requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'\n    requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]\n{\n    if s1 == s2 then\n        true\n    else if |s1| <= |s2| && s1 == s2[..|s1|] then\n        true\n    else if |s2| < |s1| && s2 == s1[..|s2|] then\n        false\n    else\n        exists i :: (0 <= i < |s1| && i < |s2| && s1[i] != s2[i] &&\n        (forall j :: 0 <= j < i ==> s1[j] == s2[j]) &&\n        'a' <= s1[i] <= 'z' && 'a' <= s2[i] <= 'z' &&\n        alphabetOrder(s1[i], s2[i], alphabet))\n}\n\nghost predicate alphabetOrder(c1: char, c2: char, alphabet: string)\n    requires |alphabet| == 26\n    requires forall i :: 0 <= i < |alphabet| ==> 'a' <= alphabet[i] <= 'z'\n    requires forall i, j :: 0 <= i < j < |alphabet| ==> alphabet[i] != alphabet[j]\n    requires 'a' <= c1 <= 'z' && 'a' <= c2 <= 'z'\n{\n    exists i, j :: 0 <= i < j < |alphabet| && alphabet[i] == c1 && alphabet[j] == c2\n}\n\nghost function parseInput(input: string): seq<string>\n\nghost function parseInt(s: string): int", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires exists n :: n >= 1 && validInput(stdin_input, n)\n    ensures result == \"Impossible\" || (|result| == 26 && forall i :: 0 <= i < |result| ==> 'a' <= result[i] <= 'z')\n    ensures result != \"Impossible\" ==> (forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j])\n    ensures result != \"Impossible\" ==> validAlphabetOrdering(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1634", "vc-description": "Given ticket costs and transportation usage, find the minimum cost to buy tickets.\nThere are 4 ticket types: individual ride cost, unlimited rides on one vehicle,\nunlimited rides on all buses OR all trolleys, and unlimited rides on everything.\nInput includes 4 costs and arrays of ride counts for buses and trolleys.", "vc-preamble": "predicate ValidCosts(c: array<int>)\n  reads c\n{\n  c.Length == 4 &&\n  c[0] >= 1 && c[1] >= 1 && c[2] >= 1 && c[3] >= 1 &&\n  c[0] <= 1000 && c[1] <= 1000 && c[2] <= 1000 && c[3] <= 1000\n}\n\npredicate ValidRides(rides: array<int>)\n  reads rides\n{\n  rides.Length >= 1 && rides.Length <= 1000 &&\n  forall i :: 0 <= i < rides.Length ==> 0 <= rides[i] <= 1000\n}\n\nfunction sum_array(arr: seq<int>): int\n  requires forall i :: 0 <= i < |arr| ==> arr[i] >= 0\n  ensures sum_array(arr) >= 0\n{\n  if |arr| == 0 then 0\n  else arr[0] + sum_array(arr[1..])\n}\n\nfunction optimized_cost(rides: seq<int>, individual_cost: int, unlimited_cost: int): int\n  requires individual_cost >= 1 && unlimited_cost >= 1\n  requires forall i :: 0 <= i < |rides| ==> rides[i] >= 0\n  ensures optimized_cost(rides, individual_cost, unlimited_cost) >= 0\n  ensures optimized_cost(rides, individual_cost, unlimited_cost) <= sum_array(rides) * individual_cost\n{\n  var initial_cost := sum_array(rides) * individual_cost;\n  min_with_unlimited(rides, initial_cost, individual_cost, unlimited_cost, 0)\n}\n\nfunction min_with_unlimited(rides: seq<int>, current_cost: int, individual_cost: int, unlimited_cost: int, index: int): int\n  requires index >= 0\n  requires individual_cost >= 1 && unlimited_cost >= 1\n  requires forall i :: 0 <= i < |rides| ==> rides[i] >= 0\n  requires current_cost >= 0\n  requires current_cost <= sum_array(rides) * individual_cost\n  ensures min_with_unlimited(rides, current_cost, individual_cost, unlimited_cost, index) >= 0\n  ensures min_with_unlimited(rides, current_cost, individual_cost, unlimited_cost, index) <= current_cost\n  decreases |rides| - index\n{\n  if index >= |rides| then current_cost\n  else \n    var new_cost := current_cost - rides[index] * individual_cost + unlimited_cost;\n    var updated_cost := if new_cost < current_cost && new_cost >= 0 then new_cost else current_cost;\n    min_with_unlimited(rides, updated_cost, individual_cost, unlimited_cost, index + 1)\n}\n\nfunction CorrectResult(c: array<int>, a: array<int>, b: array<int>, result: int): bool\n  reads c, a, b\n  requires ValidCosts(c) && ValidRides(a) && ValidRides(b)\n{\n  result == min5(optimized_cost(a[..], c[0], c[1]) + optimized_cost(b[..], c[0], c[1]),\n                 optimized_cost(a[..], c[0], c[1]) + c[2],\n                 optimized_cost(b[..], c[0], c[1]) + c[2],\n                 c[2] + c[2],\n                 c[3])\n}", "vc-helpers": "", "vc-spec": "method solve(c: array<int>, a: array<int>, b: array<int>) returns (result: int)\n  requires ValidCosts(c)\n  requires ValidRides(a)\n  requires ValidRides(b)\n  ensures result >= 0\n  ensures CorrectResult(c, a, b, result)\n  ensures result <= min5(sum_array(a[..]) * c[0] + sum_array(b[..]) * c[0], \n                        sum_array(a[..]) * c[0] + c[2],\n                        sum_array(b[..]) * c[0] + c[2],\n                        c[2] + c[2],\n                        c[3])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1635", "vc-description": "Given a sequence of cafe visits, find the cafe that was visited earliest among all last visits to each cafe.\nFor each unique cafe, record the position of its last occurrence, then return the cafe whose last occurrence \nhas the smallest position.", "vc-preamble": "function LastOccurrencePosition(cafes: seq<int>, cafe: int): int\n    requires cafe in cafes\n    ensures 0 <= LastOccurrencePosition(cafes, cafe) < |cafes|\n    ensures cafes[LastOccurrencePosition(cafes, cafe)] == cafe\n    ensures forall j :: LastOccurrencePosition(cafes, cafe) < j < |cafes| ==> cafes[j] != cafe\n{\n    LastOccurrenceHelper(cafes, cafe, |cafes| - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(cafes: seq<int>) returns (mini: int)\n    requires |cafes| > 0\n    ensures mini in cafes\n    ensures forall cafe :: cafe in cafes ==> LastOccurrencePosition(cafes, mini) <= LastOccurrencePosition(cafes, cafe)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_164", "vc-description": "Given a rectangular football field where Robo-Wallace is at position (x_b, y_b) with a ball of radius r,\nfind a point x_w on the right wall (at y = y_w) such that kicking the ball there will cause it to bounce\nonce and go through the goal. The goal is located at x = 0, between y-coordinates y_1 and y_2.\nThe ball moves in straight lines and bounces elastically off walls. A goal is scored when the ball's\ncenter crosses the y-axis between y_1 and y_2. Output x_w if possible, otherwise -1.", "vc-preamble": "predicate ValidInput(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int)\n{\n    y1 < y2 < y_w &&\n    y_b + r < y_w &&\n    2 * r < y2 - y1 &&\n    x_b > 0 && y_b > 0 && r > 0 &&\n    2 * (y_w - r) - y1 - y_b - r != 0\n}\n\nfunction ComputeW(y_w: int, r: int): int\n{\n    y_w - r\n}\n\nfunction ComputeNewY1(y_w: int, r: int, y1: int, y_b: int): int\n{\n    2 * (y_w - r) - y1 - y_b - r\n}\n\nfunction ComputeNewY2(y_w: int, r: int, y2: int, y_b: int): int\n{\n    2 * (y_w - r) - y2 - y_b\n}\n\nfunction ComputeLeftSide(x_b: int, new_y1: int, new_y2: int): int\n{\n    x_b * x_b * (new_y2 - new_y1) * (new_y2 - new_y1)\n}\n\nfunction ComputeRightSide(x_b: int, new_y1: int, r: int): int\n{\n    (new_y1 * new_y1 + x_b * x_b) * r * r\n}\n\npredicate IsImpossible(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int)\n    requires ValidInput(y1, y2, y_w, x_b, y_b, r)\n{\n    var w := ComputeW(y_w, r);\n    var new_y1 := ComputeNewY1(y_w, r, y1, y_b);\n    var new_y2 := ComputeNewY2(y_w, r, y2, y_b);\n    var left_side := ComputeLeftSide(x_b, new_y1, new_y2);\n    var right_side := ComputeRightSide(x_b, new_y1, r);\n    left_side <= right_side\n}\n\nfunction ComputeSolution(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int): real\n    requires ValidInput(y1, y2, y_w, x_b, y_b, r)\n    requires !IsImpossible(y1, y2, y_w, x_b, y_b, r)\n{\n    var w := ComputeW(y_w, r);\n    var new_y1 := ComputeNewY1(y_w, r, y1, y_b);\n    (x_b as real) * ((new_y1 + y_b - w) as real) / (new_y1 as real)\n}", "vc-helpers": "", "vc-spec": "method solve(y1: int, y2: int, y_w: int, x_b: int, y_b: int, r: int) returns (result: real)\n    requires ValidInput(y1, y2, y_w, x_b, y_b, r)\n    ensures IsImpossible(y1, y2, y_w, x_b, y_b, r) ==> result == -1.0\n    ensures !IsImpossible(y1, y2, y_w, x_b, y_b, r) ==> result == ComputeSolution(y1, y2, y_w, x_b, y_b, r)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1643", "vc-description": "Given a binary string s, find a binary string t of the same length such that:\n1. For every substring s[l..r], the longest non-decreasing subsequence length in s[l..r] \n   equals the longest non-decreasing subsequence length in t[l..r]\n2. The number of zeros in t is maximized", "vc-preamble": "predicate ValidBinaryString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}\n\nfunction countZeros(s: string): int\n    ensures countZeros(s) >= 0\n    ensures countZeros(s) <= |s|\n{\n    if |s| == 0 then 0\n    else if s[0] == '0' then 1 + countZeros(s[1..])\n    else countZeros(s[1..])\n}\n\nfunction countOnes(s: string): int\n    ensures countOnes(s) >= 0\n    ensures countOnes(s) <= |s|\n{\n    if |s| == 0 then 0\n    else if s[0] == '1' then 1 + countOnes(s[1..])\n    else countOnes(s[1..])\n}\n\nfunction longestNonDecreasingSubseqLengthComplete(s: string): int\n    ensures longestNonDecreasingSubseqLengthComplete(s) >= (if |s| == 0 then 0 else 1)\n    ensures longestNonDecreasingSubseqLengthComplete(s) <= |s|\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then 1\n    else \n        var countOnes := countOnes(s);\n        var countZeros := |s| - countOnes;\n        if countZeros == 0 then countOnes\n        else if countOnes == 0 then 1\n        else countZeros + countOnes\n}\n\nfunction longestNonDecreasingSubseqLength(s: string, l: int, r: int): int\n    requires 0 <= l <= r < |s|\n    ensures longestNonDecreasingSubseqLength(s, l, r) >= 1\n    ensures longestNonDecreasingSubseqLength(s, l, r) <= r - l + 1\n{\n    var sub := s[l..r+1];\n    longestNonDecreasingSubseqLengthComplete(sub)\n}\n\npredicate BasicValidSolution(s: string, t: string)\n{\n    && |s| == |t|\n    && ValidBinaryString(s)\n    && ValidBinaryString(t)\n    && (forall i :: 0 <= i < |s| ==> s[i] == '0' ==> t[i] == '0')\n    && (forall i :: 0 <= i < |s| ==> t[i] == '1' ==> s[i] == '1')\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidBinaryString(s)\n    ensures BasicValidSolution(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1646", "vc-description": "Given a binary string with no redundant leading zeros, find the minimum possible binary string \nachievable using these operations: 1) Swap any two adjacent characters, 2) Replace \"11\" with \"1\".\nThe goal is to minimize the decimal value represented by the resulting binary string.", "vc-preamble": "predicate ValidBinaryString(s: string)\n{\n    |s| > 0 && \n    (forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1') &&\n    (s == \"0\" || s[0] == '1')\n}\n\nfunction count_zeros(s: string): int\n    ensures count_zeros(s) >= 0\n    ensures count_zeros(s) <= |s|\n{\n    if |s| == 0 then 0\n    else (if s[0] == '0' then 1 else 0) + count_zeros(s[1..])\n}\n\npredicate IsMinimalForm(s: string, result: string)\n{\n    s == \"0\" ==> result == \"0\"\n    &&\n    s != \"0\" ==> result == \"1\" + seq(count_zeros(s), _ => '0')\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: string)\n    requires n >= 1 && n <= 100\n    requires |s| == n\n    requires ValidBinaryString(s)\n    ensures ValidBinaryString(result)\n    ensures IsMinimalForm(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_165", "vc-description": "Calculate the minimum number of meals Vasiliy could have missed during his sanatorium stay.\nGiven counts of breakfasts (b), dinners (d), and suppers (s) he had, determine how many meals\nhe definitively missed based on arrival/departure timing constraints.", "vc-preamble": "function Max3(a: int, b: int, c: int): int\n{\n    if a >= b && a >= c then a\n    else if b >= c then b\n    else c\n}\n\nfunction CalculateMissedMeals(input: string): int\n{\n    var parts := SplitSpaces(TrimNewline(input));\n    if |parts| >= 3 then\n        var a := StringToInt(parts[0]);\n        var b := StringToInt(parts[1]);  \n        var c := StringToInt(parts[2]);\n        var maxVal := Max3(a, b, c);\n        var threshold := maxVal - 1;\n        (if a < threshold then threshold - a else 0) +\n        (if b < threshold then threshold - b else 0) +\n        (if c < threshold then threshold - c else 0)\n    else 0\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires ValidInput(input)\nensures result == IntToString(CalculateMissedMeals(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1655", "vc-description": "Given n people in positions 1 to n, where person i has weapon reach L_i.\nAll people simultaneously attack: person i kills person j if and only if \nj < i and j >= i - L_i. Determine the number of survivors.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 1 && |a| == n && forall i :: 0 <= i < n ==> a[i] >= 0\n}\n\nfunction CountSurvivors(n: int, a: seq<int>): int\n    requires ValidInput(n, a)\n{\n    CountSurvivorsFrom(n, a, 0, n)\n}\n\nfunction CountSurvivorsFrom(n: int, a: seq<int>, start: int, left: int): int\n    requires ValidInput(n, a)\n    requires 0 <= start <= n\n    requires left <= n\n    decreases n - start\n{\n    if start >= n then 0\n    else\n        var i := n - 1 - start;\n        var survives := if i < left then 1 else 0;\n        var newLeft := if i - a[i] < left then i - a[i] else left;\n        survives + CountSurvivorsFrom(n, a, start + 1, newLeft)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures result >= 0\n    ensures result <= n\n    ensures result == CountSurvivors(n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1656", "vc-description": "Given a non-empty string containing only characters 'v' and 'o' with length at most 10^6,\ncalculate its \"wow factor\" - the number of subsequences that form the pattern \"wow\".\nEach 'w' must be represented by exactly two consecutive 'v' characters.\nA valid \"wow\" subsequence consists of: two consecutive 'v' characters (first 'w'),\nan 'o' character appearing later, and two consecutive 'v' characters after the 'o' (second 'w').", "vc-preamble": "function wowFactor(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'v' || s[i] == 'o'\n    ensures wowFactor(s) >= 0\n{\n    if |s| < 4 then 0\n    else\n        var n := |s|;\n        wowFactorSum(s, 0)\n}\n\nfunction countVVPairsBefore(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'v' || s[i] == 'o'\n    ensures countVVPairsBefore(s, pos) >= 0\n{\n    if pos <= 1 then 0\n    else\n        var prev := countVVPairsBefore(s, pos - 1);\n        if s[pos-1] == 'v' && s[pos-2] == 'v' then prev + 1 else prev\n}\n\nfunction countVVPairsAfter(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'v' || s[i] == 'o'\n    ensures countVVPairsAfter(s, pos) >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| - 1 then 0\n    else\n        var rest := countVVPairsAfter(s, pos + 1);\n        if pos + 1 < |s| && s[pos] == 'v' && s[pos+1] == 'v' then rest + 1 else rest\n}\n\nfunction wowFactorSum(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'v' || s[i] == 'o'\n    ensures wowFactorSum(s, pos) >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| then 0\n    else\n        var current := if s[pos] == 'o' then \n            countVVPairsBefore(s, pos) * countVVPairsAfter(s, pos + 1)\n        else 0;\n        current + wowFactorSum(s, pos + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'v' || s[i] == 'o'\n    ensures result >= 0\n    ensures result == wowFactor(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1661", "vc-description": "Given n games with costs and m bills with values, determine how many games can be bought\nby processing games in order. For each game, use the first available bill if it has\nsufficient value to buy the game, otherwise skip the game. Return total games bought.", "vc-preamble": "function countBuyableGames(games: seq<int>, bills: seq<int>): int\n    requires forall i :: 0 <= i < |games| ==> games[i] >= 1\n    requires forall i :: 0 <= i < |bills| ==> bills[i] >= 1\n{\n    if |games| == 0 then 0\n    else if |bills| == 0 then 0\n    else if bills[0] >= games[0] then 1 + countBuyableGames(games[1..], bills[1..])\n    else countBuyableGames(games[1..], bills)\n}\n\npredicate ValidInput(n: int, m: int, games: seq<int>, bills: seq<int>)\n{\n    n >= 1 && m >= 1 &&\n    |games| == n && |bills| == m &&\n    (forall i :: 0 <= i < |games| ==> 1 <= games[i] <= 1000) &&\n    (forall i :: 0 <= i < |bills| ==> 1 <= bills[i] <= 1000)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, games: seq<int>, bills: seq<int>) returns (result: int)\n    requires ValidInput(n, m, games, bills)\n    ensures 0 <= result <= n\n    ensures result <= m\n    ensures result == countBuyableGames(games, bills)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1672", "vc-description": "Given a sequence of magnets with orientations \"01\" or \"10\", count the number of groups formed.\nAdjacent magnets with same orientation attract (same group), different orientations repel (separate groups).", "vc-preamble": "predicate ValidInput(magnets: seq<string>)\n{\n    forall i :: 0 <= i < |magnets| ==> magnets[i] in {\"01\", \"10\"}\n}\n\nfunction CountGroups(magnets: seq<string>) : int\n    requires ValidInput(magnets)\n{\n    if |magnets| == 0 then 0\n    else 1 + |set i | 1 <= i < |magnets| && magnets[i] != magnets[i-1]|\n}", "vc-helpers": "", "vc-spec": "method solve(magnets: seq<string>) returns (result: int)\n    requires ValidInput(magnets)\n    ensures result >= 0\n    ensures |magnets| == 0 ==> result == 0\n    ensures |magnets| > 0 ==> result >= 1\n    ensures result <= |magnets|\n    ensures result == CountGroups(magnets)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1675", "vc-description": "Given n football teams where each team has home and away kit colors (different colors),\ncalculate how many games each team plays in home kit vs away kit in a round-robin tournament.\nKit rules: home team wears home kit, away team wears away kit unless it conflicts with \nhome team's home kit color, then away team wears home kit.", "vc-preamble": "predicate ValidInput(n: int, teams: seq<(int, int)>)\n{\n  n >= 2 && |teams| == n &&\n  (forall i :: 0 <= i < n ==> teams[i].0 != teams[i].1) &&\n  (forall i :: 0 <= i < n ==> |set j | 0 <= j < n && teams[j].0 == teams[i].1| <= n - 1)\n}\n\npredicate ValidOutput(n: int, teams: seq<(int, int)>, result: seq<(int, int)>)\n  requires |teams| == n\n{\n  |result| == n &&\n  (forall i :: 0 <= i < n ==> result[i].0 + result[i].1 == 2 * (n - 1)) &&\n  (forall i :: 0 <= i < n ==> result[i].0 >= n - 1) &&\n  (forall i :: 0 <= i < n ==> result[i].1 >= 0) &&\n  (forall i :: 0 <= i < n ==> \n    var homeCount := |set j | 0 <= j < n && teams[j].0 == teams[i].1|;\n    result[i].0 == (n - 1) + homeCount &&\n    result[i].1 == (n - 1) - homeCount)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, teams: seq<(int, int)>) returns (result: seq<(int, int)>)\n  requires ValidInput(n, teams)\n  ensures ValidOutput(n, teams, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1684", "vc-description": "Given n points numbered 1 to n arranged clockwise on a circle's circumference \nand m line segments connecting pairs of these points, determine if the resulting \nimage has rotational symmetry. The image has rotational symmetry if there exists \nan integer k (1 \u2264 k < n) such that rotating all segments clockwise by k units \naround the center produces the same image.", "vc-preamble": "datatype InputData = InputData(n: int, m: int, segments: set<(int, int)>)\n\npredicate valid_input_format(stdin_input: string)\n{\n    |stdin_input| > 0\n}\n\nfunction parse_input(stdin_input: string): InputData\nrequires valid_input_format(stdin_input)\n{\n    InputData(2, 0, {})\n}\n\nfunction rotate_segment(seg: (int, int), k: int, n: int): (int, int)\nrequires 1 <= seg.0 <= n && 1 <= seg.1 <= n\nrequires k >= 0 && n > 0\n{\n    var a := var temp_a := (seg.0 + k) % n; if temp_a == 0 then n else temp_a;\n    var b := var temp_b := (seg.1 + k) % n; if temp_b == 0 then n else temp_b;\n    (a, b)\n}\n\npredicate exists_rotational_symmetry(data: InputData)\n{\n    exists k :: 1 <= k < data.n && \n        data.n % k == 0 &&\n        (forall seg :: seg in data.segments ==> \n            seg.0 >= 1 && seg.0 <= data.n && seg.1 >= 1 && seg.1 <= data.n &&\n            rotate_segment(seg, k, data.n) in data.segments)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\nrequires |stdin_input| > 0\nrequires valid_input_format(stdin_input)\nensures result == \"Yes\" || result == \"No\"\nensures result == \"Yes\" <==> exists_rotational_symmetry(parse_input(stdin_input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1687", "vc-description": "Given an array of positive integers, find an element from the array such that all elements\nin the array are divisible by it. If no such element exists, return -1. If multiple valid\nelements exist, return any one of them.", "vc-preamble": "function min(a: seq<int>): int\n    requires |a| > 0\n    ensures min(a) in a\n    ensures forall i :: 0 <= i < |a| ==> min(a) <= a[i]\n{\n    if |a| == 1 then a[0]\n    else if a[0] <= min(a[1..]) then a[0]\n    else min(a[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: int)\n    requires |a| > 0\n    requires forall i :: 0 <= i < |a| ==> a[i] > 0\n    ensures result == -1 || result in a\n    ensures result != -1 ==> forall i :: 0 <= i < |a| ==> a[i] % result == 0\n    ensures result == -1 ==> forall x :: x in a ==> exists i :: 0 <= i < |a| && a[i] % x != 0\n    ensures (forall i :: 0 <= i < |a| ==> a[i] % (min(a)) == 0) ==> result == min(a)\n    ensures (exists i :: 0 <= i < |a| && a[i] % (min(a)) != 0) ==> result == -1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1689", "vc-description": "Given a bus with n rows of seats, where each row contains 4 seats arranged as two pairs \nseparated by a walkway (format: XX|XX), find two adjacent empty seats in the same pair \nfor two passengers. Each seat is either 'O' (empty) or 'X' (occupied). If such a pair \nexists, mark it with \"++\" and output \"YES\" with the modified configuration. Otherwise, \noutput \"NO\".", "vc-preamble": "predicate ValidInput(n: int, rows: seq<string>)\n{\n    n >= 0 && |rows| == n && forall i :: 0 <= i < |rows| ==> |rows[i]| == 5\n}\n\npredicate HasAdjacentEmptySeats(rows: seq<string>)\n{\n    exists i :: 0 <= i < |rows| && \n        ((|rows[i]| >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n         (|rows[i]| >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\npredicate NoAdjacentEmptySeats(rows: seq<string>)\n{\n    forall i :: 0 <= i < |rows| ==> \n        !((|rows[i]| >= 2 && rows[i][0] == 'O' && rows[i][1] == 'O') ||\n          (|rows[i]| >= 5 && rows[i][3] == 'O' && rows[i][4] == 'O'))\n}\n\npredicate ValidSolution(result: string, rows: seq<string>)\n{\n    result != \"NO\" ==> |result| >= 4\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, rows: seq<string>) returns (result: string)\n    requires ValidInput(n, rows)\n    ensures result == \"NO\" || |result| >= 4\n    ensures result == \"NO\" ==> NoAdjacentEmptySeats(rows)\n    ensures result != \"NO\" ==> HasAdjacentEmptySeats(rows)\n    ensures ValidSolution(result, rows)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_171", "vc-description": "Given a password string, determine if it meets complexity requirements.\nA password is complex if it has at least 5 characters, contains at least\none uppercase letter, one lowercase letter, and one digit.", "vc-preamble": "predicate ContainsLowercase(s: string)\n{\n    exists i :: 0 <= i < |s| && 'a' <= s[i] <= 'z'\n}\n\npredicate ContainsUppercase(s: string)\n{\n    exists i :: 0 <= i < |s| && 'A' <= s[i] <= 'Z'\n}\n\npredicate ContainsDigit(s: string)\n{\n    exists i :: 0 <= i < |s| && '0' <= s[i] <= '9'\n}\n\npredicate IsValidPassword(s: string)\n{\n    |s| >= 5 && ContainsLowercase(s) && ContainsUppercase(s) && ContainsDigit(s)\n}\n\nfunction TrimNewline(s: string): string\n{\n    if |s| > 0 && s[|s|-1] == '\\n' then s[..|s|-1] else s\n}\n\nfunction StripWhitespace(s: string): string\n    decreases |s|\n{\n    if |s| == 0 then s\n    else if s[0] == ' ' || s[0] == '\\t' || s[0] == '\\n' || s[0] == '\\r' then\n        StripWhitespace(s[1..])\n    else if s[|s|-1] == ' ' || s[|s|-1] == '\\t' || s[|s|-1] == '\\n' || s[|s|-1] == '\\r' then\n        StripWhitespace(s[..|s|-1])\n    else s\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures var processedInput := TrimNewline(input);\n            var stripped := StripWhitespace(processedInput);\n            if IsValidPassword(stripped) then\n                output == \"Correct\\n\"\n            else\n                output == \"Too weak\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1711", "vc-description": "Count the number of arrays of length n where each element is from 1 to m,\nexactly one pair of elements are equal (all others distinct), and the array\nis unimodal (strictly ascending then strictly descending around a peak).", "vc-preamble": "predicate ValidInput(n: int, m: int) {\n  n >= 2 && m >= 1 && n <= m && m <= 200000\n}\n\nfunction ExpectedResult(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  if n == 2 then 0\n  else (((Combination(m, n - 1, 998244353) * (n - 2)) % 998244353) * Power(2, n - 3, 998244353)) % 998244353\n}\n\npredicate ValidOutput(result: int) {\n  0 <= result < 998244353\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures ValidOutput(result)\n  ensures result == ExpectedResult(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1712", "vc-description": "Two players (Vanya and Vova) attack monsters simultaneously with different frequencies.\nVanya attacks at frequency a hits/second, Vova at frequency b hits/second.\nFor each monster requiring mobs[i] hits, determine who makes the final hit.\nThe attack pattern repeats every (a+b) hits, so we can use modular arithmetic.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, mobs: seq<int>)\n{\n    n >= 0 && a > 0 && b > 0 && |mobs| == n &&\n    forall i :: 0 <= i < n ==> mobs[i] >= 0\n}\n\npredicate ValidOutput(result: seq<string>, n: int)\n{\n    |result| == n &&\n    forall i :: 0 <= i < n ==> result[i] in [\"Vanya\", \"Vova\", \"Both\"]\n}\n\npredicate CorrectResult(result: seq<string>, n: int, a: int, b: int, mobs: seq<int>)\n    requires a > 0 && b > 0 && |mobs| == n\n{\n    ValidOutput(result, n) &&\n    forall i :: 0 <= i < n ==> \n        var total := a + b;\n        var k := if mobs[i] == 0 then 0 else mobs[i] % total;\n        (result[i] == \"Vanya\" <==> determineWinner(k, a, b) == 0) &&\n        (result[i] == \"Vova\" <==> determineWinner(k, a, b) == 1) &&\n        (result[i] == \"Both\" <==> determineWinner(k, a, b) == 2)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, mobs: seq<int>) returns (result: seq<string>)\n    requires ValidInput(n, a, b, mobs)\n    ensures CorrectResult(result, n, a, b, mobs)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1723", "vc-description": "Given an integer n (2 \u2264 n \u2264 10^5), construct two trees with n nodes each:\n1. First tree: Where Mahmoud's algorithm produces incorrect minimum vertex cover size\n2. Second tree: Where Mahmoud's algorithm produces correct minimum vertex cover size\nMahmoud's algorithm roots the tree at node 1, counts nodes at even/odd depths,\nand returns min(evenCnt, oddCnt) as the vertex cover size.", "vc-preamble": "predicate ValidOutput(n: int, result: seq<string>)\n    requires n >= 2\n{\n    if n < 6 then\n        |result| == 1 + (n - 1) &&\n        result[0] == \"-1\" &&\n        (forall i :: 1 <= i < |result| ==> result[i] == \"1 \" + IntToString(i + 1))\n    else\n        |result| == (5 + (n - 6)) + (n - 1) &&\n        result[0] == \"1 2\" && result[1] == \"1 3\" && result[2] == \"1 4\" && \n        result[3] == \"2 5\" && result[4] == \"2 6\" &&\n        (forall i :: 5 <= i < 5 + (n - 6) ==> result[i] == \"1 \" + IntToString(i + 2)) &&\n        (forall i :: 5 + (n - 6) <= i < |result| ==> result[i] == \"1 \" + IntToString(i - (5 + (n - 6)) + 2))\n}\n\nfunction IntToString(n: int): string\n    decreases n < 0, if n >= 0 then n else -n\n{\n    if n < 0 then \"-\" + IntToString(-n)\n    else if n < 10 then [n as char + '0']\n    else IntToString(n / 10) + IntToString(n % 10)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<string>)\n    requires n >= 2\n    ensures ValidOutput(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1724", "vc-description": "Given an array a of n non-negative integers and a binary string representing number m,\nfind the maximum value of function f(x) = sum(a[i] * bit_i(x)) for all integers x in range [0, m],\nwhere bit_i(x) is 1 if the i-th bit of x is set, 0 otherwise.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>, k: string)\n{\n  n >= 1 && |a| == n && |k| == n && \n  (forall i :: 0 <= i < n ==> a[i] >= 0) &&\n  isBinaryString(k)\n}\n\npredicate isBinaryString(s: string)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}\n\nfunction binaryStringToInt(s: string): int\n  requires isBinaryString(s)\n  ensures binaryStringToInt(s) >= 0\n{\n  if |s| == 0 then 0\n  else (if s[0] == '1' then 1 else 0) * pow(2, |s|-1) + binaryStringToInt(s[1..])\n}\n\nfunction f(a: seq<int>, x: int, n: int): int\n  requires n >= 0\n  requires |a| == n\n  ensures (forall i :: 0 <= i < n ==> a[i] >= 0) ==> f(a, x, n) >= 0\n{\n  if n == 0 then 0\n  else (if (x / pow(2, n-1)) % 2 == 1 then a[n-1] else 0) + f(a[..n-1], x % pow(2, n-1), n-1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>, k: string) returns (result: int)\n  requires ValidInput(n, a, k)\n  ensures result >= 0\n  ensures exists x :: 0 <= x <= binaryStringToInt(k) && result == f(a, x, n)\n  ensures forall x :: 0 <= x <= binaryStringToInt(k) ==> f(a, x, n) <= result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1725", "vc-description": "Given an n \u00d7 m matrix of integers and parameter d, find minimum operations to make all elements equal.\nEach operation adds or subtracts d from any element. Return -1 if impossible.", "vc-preamble": "predicate ValidInput(n: int, m: int, d: int, matrix: seq<seq<int>>)\n{\n    n > 0 && m > 0 && d > 0 &&\n    |matrix| == n &&\n    (forall i :: 0 <= i < n ==> |matrix[i]| == m) &&\n    (forall i, j :: 0 <= i < n && 0 <= j < m ==> matrix[i][j] > 0)\n}\n\npredicate AllSameRemainder(matrix: seq<seq<int>>, d: int)\n    requires ValidInput(|matrix|, if |matrix| > 0 then |matrix[0]| else 0, d, matrix)\n{\n    forall i, j, k, l :: 0 <= i < |matrix| && 0 <= j < |matrix[0]| && \n                        0 <= k < |matrix| && 0 <= l < |matrix[0]| ==>\n        matrix[i][j] % d == matrix[k][l] % d\n}\n\nfunction flatten(matrix: seq<seq<int>>): seq<int>\n{\n    if |matrix| == 0 then []\n    else matrix[0] + flatten(matrix[1..])\n}\n\nfunction divideSequenceByD(s: seq<int>, d: int): seq<int>\n    requires d > 0\n{\n    if |s| == 0 then []\n    else [s[0] / d] + divideSequenceByD(s[1..], d)\n}\n\nfunction sumAbsDifferencesFromTarget(s: seq<int>, target: int): int\n{\n    if |s| == 0 then 0\n    else (if s[0] >= target then s[0] - target else target - s[0]) + sumAbsDifferencesFromTarget(s[1..], target)\n}\n\nfunction minimumOperationsToMakeEqual(simplified: seq<int>): int\n    requires |simplified| > 0\n{\n    var minVal := seqMin(simplified);\n    var maxVal := seqMax(simplified);\n    minOpsInRange(simplified, minVal, maxVal)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, d: int, matrix: seq<seq<int>>) returns (result: int)\n    requires ValidInput(n, m, d, matrix)\n    ensures result == -1 <==> !AllSameRemainder(matrix, d)\n    ensures result >= 0 ==> AllSameRemainder(matrix, d)\n    ensures result >= 0 ==> (var flat := flatten(matrix); var simplified := divideSequenceByD(flat, d); result == minimumOperationsToMakeEqual(simplified))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_173", "vc-description": "Given an (n-1) \u00d7 (m-1) grid of junctions formed by n horizontal streets and m vertical streets,\nwhere each street is one-way, determine if it's possible to reach any junction from any other junction.\nInput: n, m (dimensions), string of horizontal directions ('<' or '>'), string of vertical directions ('^' or 'v').\nOutput: \"YES\" if fully connected, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(n: int, m: int, horizontal: seq<char>, vertical: seq<char>)\n{\n    n >= 2 && n <= 20 && m >= 2 && m <= 20 &&\n    |horizontal| == n && |vertical| == m &&\n    (forall c :: c in horizontal ==> c == '<' || c == '>') &&\n    (forall c :: c in vertical ==> c == '^' || c == 'v')\n}\n\npredicate IsDisconnected(hor: seq<char>, ver: seq<char>)\n{\n    (|hor| > 0 && |ver| > 0 && hor[0] == '>' && ver[0] == 'v') ||\n    (|hor| > 0 && |ver| > 0 && hor[0] == '<' && ver[|ver|-1] == 'v') ||\n    (|hor| > 0 && |ver| > 0 && hor[|hor|-1] == '>' && ver[0] == '^') ||\n    (|hor| > 0 && |ver| > 0 && hor[|hor|-1] == '<' && ver[|ver|-1] == '^')\n}\n\nfunction {:extern} split(s: seq<char>, delimiter: char): seq<seq<char>>\n\nfunction {:extern} is_integer(s: seq<char>): bool\n\nfunction {:extern} parse_int(s: seq<char>): int\n    requires is_integer(s)", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, horizontal: seq<char>, vertical: seq<char>) returns (result: seq<char>)\n    requires ValidInput(n, m, horizontal, vertical)\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures (result == \"NO\\n\" <==> IsDisconnected(horizontal, vertical))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1735", "vc-description": "Two players alternate turns removing consecutive identical letters from a string.\nThe player who cannot make a move loses. Determine if the first player wins.", "vc-preamble": "function countMaxMoves(s: string): nat\n{\n    if |s| == 0 then 0\n    else \n        var stack := [];\n        var moves := 0;\n        countMaxMovesHelper(s, 0, stack, moves)\n}\n\nfunction countMaxMovesHelper(s: string, i: nat, stack: seq<char>, moves: nat): nat\n    requires i <= |s|\n    decreases |s| - i\n{\n    if i == |s| then moves\n    else if |stack| > 0 && s[i] == stack[|stack| - 1] then\n        countMaxMovesHelper(s, i + 1, stack[..|stack| - 1], moves + 1)\n    else\n        countMaxMovesHelper(s, i + 1, stack + [s[i]], moves)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| >= 1\n    ensures result == \"Yes\" || result == \"No\"\n    ensures result == \"Yes\" <==> countMaxMoves(s) % 2 == 1\n    ensures result == \"No\" <==> countMaxMoves(s) % 2 == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1745", "vc-description": "Given an n \u00d7 m grid where '.' represents empty cells and '#' represents occupied cells,\ncount the number of distinct ways to create a pipe with constraints:\n1. The pipe is a width-1 polyline through empty cells only\n2. The pipe starts and ends on the grid boundary (but not corner cells)\n3. The pipe has at most 2 turns (90-degree turns)\n4. The pipe touches exactly 2 boundary cells (start and end)\n5. If the pipe is a straight line, start and end must be on different edges\n6. Each non-boundary pipe cell has exactly 2 adjacent pipe cells\n7. Each boundary pipe cell has exactly 1 adjacent pipe cell\n\n// Simplified implementation", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n'\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| > 0 && output[|output|-1] == '\\n'\n}\n\nfunction ParseGrid(input: string): (seq<seq<char>>, int, int)\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    if |lines| == 0 then ([], 0, 0)\n    else\n        var grid := seq(|lines|, i requires 0 <= i < |lines| => lines[i]);\n        var rows := |grid|;\n        var cols := if rows > 0 then |grid[0]| else 0;\n        (grid, rows, cols)\n}\n\nfunction SplitLines(s: string): seq<string>\n    decreases |s|\n{\n    if |s| == 0 then []\n    else\n        var newlinePos := FindNewline(s, 0);\n        if newlinePos == -1 then [s]\n        else if newlinePos == 0 then [\"\"] + SplitLines(s[1..])\n        else \n            assert 0 < newlinePos < |s|;\n            assert 0 <= newlinePos <= |s|;\n            assert 0 <= newlinePos + 1 <= |s|;\n            [s[..newlinePos]] + SplitLines(s[newlinePos+1..])\n}\n\nfunction FindNewline(s: string, start: int): int\n    requires 0 <= start <= |s|\n    ensures var pos := FindNewline(s, start); pos == -1 || (start <= pos < |s|)\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == '\\n' then start\n    else FindNewline(s, start + 1)\n}\n\npredicate IsValidGrid(grid: seq<seq<char>>, rows: int, cols: int)\n{\n    |grid| == rows &&\n    rows >= 0 && cols >= 0 &&\n    (forall i :: 0 <= i < rows ==> |grid[i]| == cols) &&\n    (forall i, j :: 0 <= i < rows && 0 <= j < cols ==> grid[i][j] == '.' || grid[i][j] == '#')\n}\n\npredicate IsBoundaryCell(i: int, j: int, rows: int, cols: int)\n    requires rows > 0 && cols > 0\n{\n    (i == 0 || i == rows - 1 || j == 0 || j == cols - 1)\n}\n\npredicate IsCornerCell(i: int, j: int, rows: int, cols: int)\n    requires rows > 0 && cols > 0\n{\n    (i == 0 && j == 0) || (i == 0 && j == cols - 1) ||\n    (i == rows - 1 && j == 0) || (i == rows - 1 && j == cols - 1)\n}\n\nfunction CountValidPipes(grid: seq<seq<char>>, rows: int, cols: int): int\n    requires IsValidGrid(grid, rows, cols)\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method ExecutePythonLogic(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1746", "vc-description": "Determine if a rooted tree is a \"spruce\". A rooted tree is a spruce if every \nnon-leaf vertex has at least 3 leaf children. A leaf is a vertex with no children,\nand a non-leaf vertex has at least one child.", "vc-preamble": "function hasChildren(node: int, parents: seq<int>, n: int): bool\n    requires 0 <= node < n\n    requires n >= 3\n    requires |parents| == n - 1\n{\n    exists i :: 0 <= i < n - 1 && parents[i] - 1 == node\n}\n\nfunction countLeafChildren(node: int, parents: seq<int>, n: int): int\n    requires 0 <= node < n\n    requires n >= 3\n    requires |parents| == n - 1\n{\n    |set i | 0 <= i < n - 1 && parents[i] - 1 == node && !hasChildren(i + 1, parents, n)|\n}\n\npredicate ValidInput(n: int, parents: seq<int>)\n{\n    n >= 3 && |parents| == n - 1 && \n    (forall i :: 0 <= i < n - 1 ==> 1 <= parents[i] <= i + 1)\n}\n\npredicate IsSpruce(n: int, parents: seq<int>)\n    requires ValidInput(n, parents)\n{\n    forall node :: 0 <= node < n && hasChildren(node, parents, n) ==> \n        countLeafChildren(node, parents, n) >= 3\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, parents: seq<int>) returns (result: string)\n    requires ValidInput(n, parents)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures result == \"Yes\" <==> IsSpruce(n, parents)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1754", "vc-description": "Given n students across m schools, where each student has a unique power level,\nthe Technogoblet selects the strongest student from each school. We want k specific \nstudents (Chosen Ones) to be selected. We can create new schools and reassign students.\nFind the minimum number of new schools needed so all k Chosen Ones get selected.", "vc-preamble": "predicate IsStrongestInSchool(student_idx: int, powers: seq<int>, schools: seq<int>)\n  requires 0 <= student_idx < |powers| && |powers| == |schools|\n{\n  forall j :: 0 <= j < |powers| && schools[j] == schools[student_idx] ==> powers[j] <= powers[student_idx]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int, powers: seq<int>, schools: seq<int>, chosen: seq<int>) returns (result: int)\n  requires n >= 1 && m >= 1 && k >= 1 && k <= n && m <= n\n  requires |powers| == n && |schools| == n && |chosen| == k\n  requires forall i :: 0 <= i < n ==> 1 <= schools[i] <= m\n  requires forall i :: 0 <= i < k ==> 1 <= chosen[i] <= n\n  requires forall i, j :: 0 <= i < k && 0 <= j < k && i != j ==> chosen[i] != chosen[j]\n  requires forall i, j :: 0 <= i < n && 0 <= j < n && i != j ==> powers[i] != powers[j]\n  requires forall s :: 1 <= s <= m ==> exists i :: 0 <= i < n && schools[i] == s\n  requires forall i :: 0 <= i < n ==> 1 <= powers[i] <= n\n  ensures result >= 0 && result <= k\n  ensures result == |set i | 0 <= i < k && !IsStrongestInSchool(chosen[i]-1, powers, schools)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1757", "vc-description": "Generate a string of exactly n characters where each character is either 'O' or 'o'.\nThe i-th character (1-indexed) should be 'O' if i is a Fibonacci number, 'o' otherwise.\nFibonacci sequence: f\u2081 = 1, f\u2082 = 1, f\u2099 = f\u2099\u208b\u2081 + f\u2099\u208b\u2082 for n > 2.", "vc-preamble": "function isFibonacci(num: int): bool\n  requires num >= 1\n{\n  isFibHelper(num, 1, 1)\n}\n\nfunction isFibHelper(num: int, prev: int, curr: int): bool\n  requires num >= 1 && prev >= 1 && curr >= 1\n  decreases if curr >= num then 0 else num - curr\n{\n  if curr == num then true\n  else if curr > num then false\n  else isFibHelper(num, curr, prev + curr)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n  requires n >= 1 && n <= 1000\n  ensures |result| == n\n  ensures forall i :: 0 <= i < |result| ==> result[i] == 'O' || result[i] == 'o'\n  ensures forall i :: 1 <= i <= n ==> (isFibonacci(i) <==> result[i-1] == 'O')\n  ensures forall i :: 1 <= i <= n ==> (!isFibonacci(i) <==> result[i-1] == 'o')", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_176", "vc-description": "Count the number of integers in the range [a, b] that are divisible by k.\nGiven three integers k, a, b where k > 0 and a <= b, return the count of\nintegers x such that a <= x <= b and x % k == 0.", "vc-preamble": "predicate ValidInput(k: int, a: int, b: int)\n{\n  k > 0 && a <= b\n}\n\nfunction FloorDiv(a: int, b: int): int\n  requires b > 0\n{\n  if a >= 0 then a / b\n  else (a - b + 1) / b\n}\n\nfunction CountDivisiblesInRange(k: int, a: int, b: int): int\n  requires k > 0\n  requires a <= b\n{\n  FloorDiv(b, k) - FloorDiv(a - 1, k)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, a: int, b: int) returns (result: int)\n  requires ValidInput(k, a, b)\n  ensures result >= 0\n  ensures result == CountDivisiblesInRange(k, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1761", "vc-description": "Given n words forming a message, determine if a received text could have been encoded by:\n1. Creating coded string with \"<3\" before each word and after last word\n2. Inserting additional characters anywhere in the coded string\nCheck if received message contains expected coded string as subsequence.", "vc-preamble": "predicate ValidInput(input: seq<string>)\n{\n    |input| >= 2 &&\n    var n := parseIntHelper(input[0], 0, 0);\n    n >= 1 && n + 1 < |input|\n}\n\nfunction buildExpectedPattern(words: seq<string>): seq<char>\n{\n    if |words| == 0 then ['<', '3']\n    else ['<', '3'] + seq(|words[0]|, i requires 0 <= i < |words[0]| => words[0][i]) + buildExpectedPattern(words[1..])\n}\n\nfunction isSubsequence(pattern: seq<char>, text: string): bool\n{\n    isSubsequenceHelper(pattern, text, 0, 0)\n}\n\nfunction isSubsequenceHelper(pattern: seq<char>, text: string, patternIndex: nat, textIndex: nat): bool\n    requires patternIndex <= |pattern|\n    requires textIndex <= |text|\n    decreases |text| - textIndex\n{\n    if patternIndex == |pattern| then true\n    else if textIndex == |text| then false\n    else if pattern[patternIndex] == text[textIndex] then\n        isSubsequenceHelper(pattern, text, patternIndex + 1, textIndex + 1)\n    else\n        isSubsequenceHelper(pattern, text, patternIndex, textIndex + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<string>) returns (result: string)\n    requires |input| >= 2\n    requires ValidInput(input)\n    ensures result == \"yes\" || result == \"no\"\n    ensures result == \"yes\" <==> (\n        ValidInput(input) &&\n        var n := parseIntHelper(input[0], 0, 0);\n        var expected := buildExpectedPattern(input[1..n+1]);\n        var message := input[n + 1];\n        isSubsequence(expected, message)\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1766", "vc-description": "Two players take turns picking cards from either end of a row of n cards. Each card has a distinct\ninteger value. The first player (Sereja) goes first. Both players use a greedy strategy: they always\nchoose the card with the larger value between the leftmost and rightmost available cards. Determine\nthe final scores of both players.", "vc-preamble": "predicate ValidInput(cards: seq<int>)\n{\n  |cards| >= 1 &&\n  (forall i :: 0 <= i < |cards| ==> cards[i] > 0) &&\n  (forall i, j :: 0 <= i < j < |cards| ==> cards[i] != cards[j])\n}\n\nfunction sum(cards: seq<int>): int\n{\n  if |cards| == 0 then 0\n  else cards[0] + sum(cards[1..])\n}\n\nfunction sereja_optimal_score(cards: seq<int>, left: int, right: int, sereja_turn: bool): int\n  requires 0 <= left <= right < |cards|\n  decreases right - left + 1\n{\n  if left == right then\n    if sereja_turn then cards[left] else 0\n  else if cards[left] > cards[right] then\n    (if sereja_turn then cards[left] else 0) + sereja_optimal_score(cards, left+1, right, !sereja_turn)\n  else\n    (if sereja_turn then cards[right] else 0) + sereja_optimal_score(cards, left, right-1, !sereja_turn)\n}\n\npredicate ValidOutput(scores: seq<int>, cards: seq<int>)\n  requires ValidInput(cards)\n{\n  |scores| == 2 &&\n  scores[0] >= 0 && scores[1] >= 0 &&\n  scores[0] + scores[1] == sum(cards) &&\n  scores[0] == sereja_optimal_score(cards, 0, |cards|-1, true) &&\n  scores[1] == sum(cards) - sereja_optimal_score(cards, 0, |cards|-1, true)\n}", "vc-helpers": "", "vc-spec": "method solve(cards: seq<int>) returns (scores: seq<int>)\n  requires ValidInput(cards)\n  ensures ValidOutput(scores, cards)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_178", "vc-description": "Given a string of n digits where n is odd and n >= 13, two players (Vasya first, then Petya) \ntake turns removing one character at a time until exactly 11 characters remain. \nVasya wins if the final 11-character string starts with digit 8, otherwise Petya wins.\nDetermine if Vasya has a winning strategy.", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n    n >= 13 && n % 2 == 1 && |s| == n\n}\n\nfunction count_eights_in_prefix(s: string, len: int): int\n    requires 0 <= len <= |s|\n    ensures count_eights_in_prefix(s, len) >= 0\n    ensures count_eights_in_prefix(s, len) <= len\n{\n    if len == 0 then 0\n    else (if s[len-1] == '8' then 1 else 0) + count_eights_in_prefix(s, len-1)\n}\n\npredicate VasyaWins(n: int, s: string)\n    requires ValidInput(n, s)\n{\n    var petya_moves := (n - 11) / 2;\n    var prefix_len := n - 10;\n    var eights_in_prefix := count_eights_in_prefix(s, prefix_len);\n    petya_moves < eights_in_prefix\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: string)\n    requires ValidInput(n, s)\n    ensures result == \"NO\" || result == \"YES\"\n    ensures result == (if VasyaWins(n, s) then \"YES\" else \"NO\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1780", "vc-description": "Given an array of n integers (each either -1 or 1), determine for each query \nwhether the array can be rearranged so that the sum of elements in a given \nrange equals 0. A range can sum to 0 only if it has even length and we have \nenough positive and negative values to fill half the positions each.", "vc-preamble": "ghost predicate ValidInput(input: string)\n{\n    var lines := splitLines(input);\n    |lines| >= 2 &&\n    containsValidFirstLine(lines[0]) &&\n    containsValidSecondLine(lines[1]) &&\n    |lines| == 2 + extractMFromLine(lines[0]) &&\n    (forall i :: 2 <= i < |lines| ==> containsValidQuery(lines[i])) &&\n    extractN(lines[0]) == |lines[1]|\n}\n\nghost predicate containsValidFirstLine(line: string)\n{\n    exists n, m :: n >= 0 && m >= 0 && line == toString(n) + \" \" + toString(m)\n}\n\nghost predicate containsValidSecondLine(line: string)\n{\n    |line| >= 0 &&\n    forall c :: c in line ==> c == '1' || c == '-'\n}\n\nghost predicate containsValidQuery(line: string)\n{\n    exists l, r :: l >= 0 && r >= l && line == toString(l) + \" \" + toString(r)\n}\n\nfunction computeCorrectResult(input: string): string\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |computeCorrectResult(input)| >= 0\n    ensures forall line :: line in splitLines(computeCorrectResult(input)) ==> line == \"0\" || line == \"1\"\n    ensures |splitLines(computeCorrectResult(input))| == extractM(input)\n{\n    var lines := splitLines(input);\n    var firstLine := lines[0];\n    var n := extractN(firstLine);\n    var m := extractM(input);\n    var arrayLine := lines[1];\n    var positives := countOnes(arrayLine);\n    var negatives := countDashes(arrayLine);\n    var maxBalanceable := 2 * min(positives, negatives);\n\n    var outputs := seq(m, i requires 0 <= i < m => \n        var query := extractQuery(lines[i + 2]);\n        var l := query.0;\n        var r := query.1;\n        var rangeLength := r - l + 1;\n        if rangeLength % 2 == 0 && rangeLength <= maxBalanceable then \"1\" else \"0\"\n    );\n\n    joinWithNewlines(outputs)\n}\n\npredicate endsWithNewlineIfNonEmpty(s: string)\n{\n    |s| == 0 || (|s| > 0 && s[|s|-1] == '\\n')\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInput(stdin_input)\n    ensures |result| >= 0\n    ensures result == computeCorrectResult(stdin_input)\n    ensures forall line :: line in splitLines(result) ==> line == \"0\" || line == \"1\"\n    ensures |splitLines(result)| == extractM(stdin_input)\n    ensures endsWithNewlineIfNonEmpty(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1788", "vc-description": "Given two integers A and B where A = X + Y and B = X - Y, find the original integers X and Y.\nThe inputs are constrained to be between -100 and 100, and unique integer solutions are guaranteed to exist.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    -100 <= a <= 100 && -100 <= b <= 100 && (a + b) % 2 == 0 && (a - b) % 2 == 0\n}\n\npredicate CorrectSolution(a: int, b: int, x: int, y: int)\n{\n    a == x + y && b == x - y\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (x: int, y: int)\n    requires ValidInput(a, b)\n    ensures CorrectSolution(a, b, x, y)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1795", "vc-description": "Given n planes numbered 1 to n, where each plane i likes exactly one other plane f_i (f_i \u2260 i),\ndetermine if there exists a love triangle. A love triangle occurs when plane A likes plane B,\nplane B likes plane C, and plane C likes plane A.", "vc-preamble": "predicate ValidInput(n: int, f: seq<int>)\n{\n    n >= 2 && n <= 5000 &&\n    |f| == n &&\n    forall i :: 0 <= i < |f| ==> 1 <= f[i] <= n && f[i] != i + 1\n}\n\nfunction ZeroIndexedArray(n: int, f: seq<int>): seq<int>\n    requires ValidInput(n, f)\n{\n    seq(n, j requires 0 <= j < n => f[j] - 1)\n}\n\npredicate HasLoveTriangleWith(n: int, a: seq<int>)\n    requires |a| == n\n    requires forall k :: 0 <= k < n ==> 0 <= a[k] < n\n{\n    exists i {:trigger a[i], a[a[i]], a[a[a[i]]]} :: 0 <= i < n && \n        0 <= a[i] < n && 0 <= a[a[i]] < n && a[a[a[i]]] == i\n}\n\npredicate HasLoveTriangle(n: int, f: seq<int>)\n    requires ValidInput(n, f)\n{\n    var a := ZeroIndexedArray(n, f);\n    HasLoveTriangleWith(n, a)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, f: seq<int>) returns (result: string)\n    requires ValidInput(n, f)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> HasLoveTriangle(n, f)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1797", "vc-description": "Given n subway stations where each station i has exactly one outgoing train to station p_i,\nand the array p represents a permutation, find the maximum \"convenience\" after changing at \nmost 2 values in p. Convenience is defined as the number of ordered pairs (x,y) where you \ncan travel from station x to station y using the subway trains.", "vc-preamble": "predicate ValidInput(n: int, p: seq<int>)\n{\n  n > 0 && |p| == n &&\n  (forall i :: 0 <= i < n ==> 1 <= p[i] <= n) &&\n  (forall i, j :: 0 <= i < j < n ==> p[i] != p[j])\n}\n\nfunction count_true(visited: seq<bool>): int\n  ensures count_true(visited) >= 0\n  ensures count_true(visited) <= |visited|\n{\n  if |visited| == 0 then 0\n  else (if visited[0] then 1 else 0) + count_true(visited[1..])\n}\n\nfunction sum_of_squares(s: seq<int>): int \n{\n  if |s| == 0 then 0 else s[0] * s[0] + sum_of_squares(s[1..])\n}\n\nfunction get_cycle_lengths(n: int, p: seq<int>): seq<int>\n  requires ValidInput(n, p)\n{\n  get_cycles_helper(n, p, seq(n, i => false), [])\n}\n\nfunction get_cycles_helper(n: int, p: seq<int>, visited: seq<bool>, cycles: seq<int>): seq<int>\n  requires n > 0\n  requires |p| == n\n  requires |visited| == n\n  requires forall i :: 0 <= i < n ==> 1 <= p[i] <= n\n  requires forall i, j :: 0 <= i < j < n ==> p[i] != p[j]\n  decreases n - count_true(visited)\n{\n  if count_true(visited) >= n then cycles\n  else\n    var unvisited := find_unvisited(visited);\n    if unvisited == -1 then cycles\n    else if 0 <= unvisited < n then\n      var cycle_length := get_cycle_length(p, visited, unvisited);\n      var new_visited := mark_cycle_visited(p, visited, unvisited);\n      if count_true(new_visited) > count_true(visited) && count_true(new_visited) <= n then\n        get_cycles_helper(n, p, new_visited, cycles + [cycle_length])\n      else\n        cycles + [cycle_length]\n    else\n      cycles\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: seq<int>) returns (result: int)\n  requires ValidInput(n, p)\n  ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1805", "vc-description": "Given n matches, find the minimum number of additional matches needed to form a valid equation a + b = c \nwhere a, b, c are positive integers. Each integer k uses k matches, '+' uses 1 match, '=' uses 1 match.\nTotal matches needed: a + b + c + 2 = 2(a + b) + 2 since c = a + b.", "vc-preamble": "predicate ValidInput(queries: seq<int>) {\n    forall i :: 0 <= i < |queries| ==> queries[i] >= 2\n}\n\nfunction MinAdditionalMatches(n: int): int\n    requires n >= 2\n{\n    if n >= 4 then n % 2 else 4 - n\n}\n\npredicate ValidResult(queries: seq<int>, results: seq<int>)\n    requires ValidInput(queries)\n{\n    |results| == |queries| &&\n    forall i :: 0 <= i < |queries| ==> results[i] == MinAdditionalMatches(queries[i])\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<int>) returns (results: seq<int>)\n    requires ValidInput(queries)\n    ensures ValidResult(queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1809", "vc-description": "Given n books with weights w_i, find the optimal initial stacking order to minimize total weight lifted \nwhen reading books according to a given sequence. To read book x: lift all books above x, remove x from \nstack, put lifted books back (maintaining order), then place x on top. The book being read is not counted \nas lifted weight.", "vc-preamble": "function isValidInput(s: string): bool\n    requires |s| > 0\n{\n    |s| >= 5 && s[|s|-1] == '\\n'\n}\n\nfunction calculateResultFromInput(s: string): string\n    requires |s| > 0\n    requires isValidInput(s)\n{\n    var parsed := parseInputFunc(s);\n    var n := parsed.0;\n    var m := parsed.1;\n    var W := parsed.2;\n    var B := parsed.3;\n    intToString(calculateAnswer(n, m, W, B))\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    requires '\\n' in s\n    requires isValidInput(s)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures result == calculateResultFromInput(s) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_181", "vc-description": "Given a camera rotation angle in degrees, determine the minimum number of 90-degree \nclockwise rotations needed to minimize the image's deviation from vertical orientation.\nWhen a camera rotates by x degrees, the image appears rotated by -x degrees.", "vc-preamble": "function NormalizeAngle(angle: int): int\n{\n    var n := angle % 360;\n    if n < 0 then n + 360 else n\n}\n\nfunction DeviationFromVertical(angle: int): int\n    requires 0 <= angle < 360\n{\n    if angle <= 180 then angle else 360 - angle\n}\n\nfunction ImageAngleAfterRotations(cameraAngle: int, rotations: int): int\n    requires 0 <= rotations <= 3\n{\n    NormalizeAngle(-cameraAngle + 90 * rotations)\n}\n\nfunction ImageDeviationAfterRotations(cameraAngle: int, rotations: int): int\n    requires 0 <= rotations <= 3\n{\n    DeviationFromVertical(ImageAngleAfterRotations(cameraAngle, rotations))\n}\n\npredicate IsOptimalRotations(cameraAngle: int, result: int)\n    requires 0 <= result <= 3\n{\n    forall k :: 0 <= k <= 3 ==> \n        var result_deviation := ImageDeviationAfterRotations(cameraAngle, result);\n        var k_deviation := ImageDeviationAfterRotations(cameraAngle, k);\n        result_deviation < k_deviation || (result_deviation == k_deviation && result <= k)\n}", "vc-helpers": "", "vc-spec": "method solve(x: int) returns (result: int)\n    ensures 0 <= result <= 3\n    ensures IsOptimalRotations(x, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1824", "vc-description": "Given three lists of compilation errors (initial with n errors, second with n-1 errors, third with n-2 errors),\nfind the two error values that were corrected. The compiler shows errors in different order each time,\nbut the actual error values remain the same.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitByNewline(input);\n    |lines| >= 4 && \n    IsValidInteger(lines[0]) &&\n    StringToInt(lines[0]) >= 3 &&\n    |SplitBySpace(lines[1])| == StringToInt(lines[0]) &&\n    |SplitBySpace(lines[2])| == StringToInt(lines[0]) - 1 &&\n    |SplitBySpace(lines[3])| == StringToInt(lines[0]) - 2 &&\n    (forall i :: 0 <= i < |SplitBySpace(lines[1])| ==> IsValidInteger(SplitBySpace(lines[1])[i])) &&\n    (forall i :: 0 <= i < |SplitBySpace(lines[2])| ==> IsValidInteger(SplitBySpace(lines[2])[i])) &&\n    (forall i :: 0 <= i < |SplitBySpace(lines[3])| ==> IsValidInteger(SplitBySpace(lines[3])[i]))\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && (s[0] == '-' ==> |s| > 1) && \n    (forall i :: (if s[0] == '-' then 1 else 0) <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction GetFirstSum(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitByNewline(input);\n    var firstLine := SplitBySpace(lines[1]);\n    SumSequence(firstLine)\n}\n\nfunction GetSecondSum(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitByNewline(input);\n    var secondLine := SplitBySpace(lines[2]);\n    SumSequence(secondLine)\n}\n\nfunction GetThirdSum(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitByNewline(input);\n    var thirdLine := SplitBySpace(lines[3]);\n    SumSequence(thirdLine)\n}\n\nfunction SumSequence(numbers: seq<string>): int\n    requires forall i :: 0 <= i < |numbers| ==> IsValidInteger(numbers[i])\n{\n    if |numbers| == 0 then 0\n    else StringToInt(numbers[0]) + SumSequence(numbers[1..])\n}\n\nfunction SplitByNewline(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else if s[0] == '\\n' then SplitByNewline(s[1..])\n    else \n        var rest := SplitByNewline(s[1..]);\n        if |rest| == 0 then [s]\n        else [s[0..1] + rest[0]] + rest[1..]\n}\n\nfunction SplitBySpace(s: string): seq<string>\n{\n    SplitByChar(s, ' ')\n}\n\nfunction SplitByChar(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var pos := FindChar(s, delimiter, 0);\n        if pos == -1 then [s]\n        else if pos == 0 then SplitByChar(s[1..], delimiter)\n        else [s[0..pos]] + SplitByChar(s[pos+1..], delimiter)\n}\n\nfunction FindChar(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    ensures -1 <= FindChar(s, c, start) < |s|\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == c then start\n    else FindChar(s, c, start + 1)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntHelper(s[1..], 0)\n    else StringToIntHelper(s, 0)\n}\n\nfunction StringToIntHelper(s: string, acc: int): int\n{\n    if |s| == 0 then acc\n    else if '0' <= s[0] <= '9' then\n        StringToIntHelper(s[1..], acc * 10 + (s[0] as int - '0' as int))\n    else acc\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [((n % 10) + '0' as int) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures result == IntToString(GetFirstSum(input) - GetSecondSum(input)) + \"\\n\" + IntToString(GetSecondSum(input) - GetThirdSum(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1826", "vc-description": "Given a sequence of moves 'U' (up) and 'R' (right), replace consecutive pairs \"RU\" or \"UR\" \nwith diagonal moves \"D\" to minimize sequence length. Input format is a number n followed by \nnewline, then a string of n characters containing only 'U' and 'R'.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && exists pos :: 0 <= pos < |input| && input[pos] == '\\n'\n}\n\npredicate ValidMoveSequence(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == 'U' || s[i] == 'R'\n}\n\nfunction CountReplacements(s: string, start: int, length: int): int\n    requires 0 <= start <= |s|\n    requires length >= 0\n    requires start + length <= |s|\n    ensures CountReplacements(s, start, length) >= 0\n    ensures CountReplacements(s, start, length) <= length / 2\n{\n    if length <= 1 then 0\n    else CountReplacementsHelper(s, start, length, 1, 0)\n}\n\nfunction CountReplacementsHelper(s: string, start: int, length: int, i: int, count: int): int\n    requires 0 <= start <= |s|\n    requires length >= 0\n    requires start + length <= |s|\n    requires 1 <= i <= length\n    requires count >= 0\n    requires count <= (i - 1) / 2\n    ensures CountReplacementsHelper(s, start, length, i, count) >= count\n    ensures CountReplacementsHelper(s, start, length, i, count) <= length / 2\n    decreases length - i\n{\n    if i >= length then count\n    else if start + i < |s| && s[start + i - 1] != s[start + i] then\n        if i + 2 <= length then CountReplacementsHelper(s, start, length, i + 2, count + 1)\n        else count + 1\n    else\n        CountReplacementsHelper(s, start, length, i + 1, count)\n}\n\nfunction MinimizedLength(originalLength: int, replacements: int): int\n    requires originalLength >= 0\n    requires replacements >= 0\n    requires replacements <= originalLength / 2\n{\n    originalLength - replacements\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result[|result| - 1] == '\\n'", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1835", "vc-description": "Given n binary strings, you can swap any two characters from any positions \n(within same string or across different strings) any number of times. \nFind the maximum number of strings that can be made palindromic simultaneously.\nA palindrome reads the same forwards and backwards.\n\n// Simplified implementation\n\n// Simplified implementation\n\n// Simplified implementation\n\n// Simplified implementation\n\n// Simplified implementation\n\n// Simplified implementation\n\n// Simplified implementation", "vc-preamble": "function valid_input_format(input: string): bool\n{\n    true\n}\n\nfunction is_binary_string(s: string): bool\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n}\n\nfunction count_test_cases(input: string): nat\n    requires valid_input_format(input)\n{\n    1\n}\n\nfunction count_lines(s: string): nat\n{\n    1\n}\n\nfunction get_line(s: string, i: nat): string\n    requires i < count_lines(s)\n{\n    \"1\"\n}\n\nfunction get_string_count(input: string, test_case: nat): nat\n    requires test_case < count_test_cases(input)\n    requires valid_input_format(input)\n{\n    1\n}\n\nfunction get_test_case_strings(input: string, test_case: nat): seq<string>\n    requires test_case < count_test_cases(input)\n    requires valid_input_format(input)\n    ensures forall s :: s in get_test_case_strings(input, test_case) ==> is_binary_string(s)\n{\n    [\"0\"]\n}\n\nfunction string_to_int(s: string): int\n{\n    1\n}\n\nfunction compute_max_palindromes(strings: seq<string>): nat\n    requires forall s :: s in strings ==> is_binary_string(s)\n    ensures compute_max_palindromes(strings) <= |strings|\n    ensures compute_max_palindromes(strings) == greedy_palindrome_count(strings)\n{\n    greedy_palindrome_count(strings)\n}\n\nfunction palindromic_strings_achievable(strings: seq<string>, k: nat): bool\n    requires forall s :: s in strings ==> is_binary_string(s)\n    requires k <= |strings|\n{\n    k <= greedy_palindrome_count(strings)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires input[|input|-1] == '\\n'\n    requires valid_input_format(input)\n    ensures |result| >= 0\n    ensures result == \"\" || result[|result|-1] == '\\n'\n    ensures count_lines(result) == count_test_cases(input)\n    ensures forall i :: 0 <= i < count_test_cases(input) ==> \n        string_to_int(get_line(result, i)) >= 0\n    ensures forall i :: 0 <= i < count_test_cases(input) ==> \n        string_to_int(get_line(result, i)) <= get_string_count(input, i)\n    ensures forall i :: 0 <= i < count_test_cases(input) ==> \n        string_to_int(get_line(result, i)) == compute_max_palindromes(get_test_case_strings(input, i))\n    ensures forall i :: 0 <= i < count_test_cases(input) ==> \n        palindromic_strings_achievable(get_test_case_strings(input, i), string_to_int(get_line(result, i)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1836", "vc-description": "Given n points and m segments, find a \"hedgehog\" with maximum beauty.\nA hedgehog has a tail (path with strictly increasing point numbers) and \nspines (all segments connected to tail's endpoint). \nBeauty = (tail length) \u00d7 (number of spines).", "vc-preamble": "predicate ValidInput(n: int, edges: seq<(int, int)>)\n{\n    n >= 2 &&\n    forall i :: 0 <= i < |edges| ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n && edges[i].0 != edges[i].1\n}\n\npredicate ValidOutput(result: int, n: int, edges: seq<(int, int)>)\n{\n    result >= 0 && result <= 2 * |edges| * (|edges| + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, edges: seq<(int, int)>) returns (result: int)\n    requires ValidInput(n, edges)\n    ensures ValidOutput(result, n, edges)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1837", "vc-description": "Given a permutation of integers 0 to n-1, find the maximum number of fixed points\n(positions where a[i] = i) after performing at most one swap operation.", "vc-preamble": "predicate ValidInput(n: int, A: seq<int>)\n{\n    n >= 1 &&\n    |A| == n &&\n    (forall i :: 0 <= i < n ==> 0 <= A[i] < n) &&\n    (forall i, j :: 0 <= i < j < n ==> A[i] != A[j]) &&\n    (forall k {:trigger A[k]} :: 0 <= k < n ==> exists i :: 0 <= i < n && A[i] == k)\n}\n\nfunction CurrentFixedPoints(A: seq<int>): int\n    requires |A| >= 0\n{\n    |set i | 0 <= i < |A| && A[i] == i|\n}\n\nfunction MaxPossibleFixedPoints(A: seq<int>): int\n    requires ValidInput(|A|, A)\n{\n    var current := CurrentFixedPoints(A);\n    if current == |A| then \n        |A|\n    else if exists i :: 0 <= i < |A| && A[i] != i && A[A[i]] == i then\n        current + 2\n    else\n        current + 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, A: seq<int>) returns (result: int)\n    requires ValidInput(n, A)\n    ensures result == MaxPossibleFixedPoints(A)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1840", "vc-description": "Given s spaceships with attacking powers and b bases with defensive powers and gold amounts,\ndetermine the maximum gold each spaceship can steal. A spaceship can attack any base where \nthe spaceship's attacking power is greater than or equal to the base's defensive power.\nWhen attacking a base, the spaceship steals all gold from that base.", "vc-preamble": "predicate ValidInput(s: nat, b: nat, attacking_powers: seq<nat>, bases: seq<(nat, nat)>)\n{\n    |attacking_powers| == s && |bases| == b\n}\n\nfunction SumGoldForSpaceship(attacking_power: nat, bases: seq<(nat, nat)>): nat\n{\n    if |bases| == 0 then 0\n    else if attacking_power >= bases[0].0 then bases[0].1 + SumGoldForSpaceship(attacking_power, bases[1..])\n    else SumGoldForSpaceship(attacking_power, bases[1..])\n}\n\npredicate ValidOutput(s: nat, attacking_powers: seq<nat>, bases: seq<(nat, nat)>, result: seq<nat>)\n{\n    |result| == s &&\n    (forall i :: 0 <= i < s ==> result[i] >= 0) &&\n    (forall i :: 0 <= i < s && i < |attacking_powers| ==> result[i] == SumGoldForSpaceship(attacking_powers[i], bases))\n}", "vc-helpers": "", "vc-spec": "method solve(s: nat, b: nat, attacking_powers: seq<nat>, bases: seq<(nat, nat)>) returns (result: seq<nat>)\n    requires ValidInput(s, b, attacking_powers, bases)\n    ensures ValidOutput(s, attacking_powers, bases, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1841", "vc-description": "Given an array of n integers and m queries, for each query l_i, find the number of distinct elements\nin the suffix of the array starting from position l_i (1-indexed). The suffix includes all elements\nfrom position l_i to the end of the array.", "vc-preamble": "predicate ValidInput(n: int, m: int, A: seq<int>, queries: seq<int>)\n{\n    |A| == n && |queries| == m && n >= 1 && m >= 1 &&\n    forall i :: 0 <= i < m ==> 1 <= queries[i] <= n\n}\n\nfunction DistinctCount(A: seq<int>, start: int): int\n    requires 0 <= start < |A|\n{\n    |set j | start <= j < |A| :: A[j]|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, A: seq<int>, queries: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, m, A, queries)\n    ensures |result| == m\n    ensures forall i :: 0 <= i < m ==> \n        result[i] == DistinctCount(A, queries[i] - 1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1849", "vc-description": "Given an integer n, consider all integers from 0 to 10^n - 1, each padded with leading zeros to exactly n digits.\nA \"block\" is a maximal consecutive sequence of identical digits.\nFor each length i from 1 to n, count the total number of blocks of length i across all these padded numbers.\nOutput n integers modulo 998244353, where the i-th integer is the number of blocks of length i.", "vc-preamble": "const MOD := 998244353\n\npredicate ValidInput(n: int)\n{\n  n >= 1\n}\n\nfunction BlockCountFormula(n: int, i: int): int\n  requires n >= 1 && 1 <= i <= n\n{\n  if i == n then 10\n  else \n    ((2 * 9 * pow(10, n - i - 1, MOD) * 10) + \n     (if i < n - 1 then ((n - 1 - i) * 9 * 9 * pow(10, n - i - 2, MOD) * 10) else 0)) % MOD\n}\n\npredicate ValidResult(result: seq<int>, n: int)\n  requires n >= 1\n{\n  |result| == n &&\n  (forall k :: 0 <= k < n ==> 0 <= result[k] < MOD) &&\n  (n >= 1 ==> result[n-1] == 10) &&\n  (forall i :: 0 <= i < n-1 ==> result[i] == BlockCountFormula(n, i+1))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<int>)\n  requires ValidInput(n)\n  ensures ValidResult(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_185", "vc-description": "Given n manholes in a line (positions 1 to n), each initially covered by one stone with one coin underneath.\nNastya starts at position k and can: throw stones, move to adjacent positions, or collect coins from uncovered manholes.\nFind the minimum number of moves needed to collect all n coins.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n  2 <= n <= 5000 && 1 <= k <= n\n}\n\nfunction OptimalMoves(n: int, k: int): int\n  requires ValidInput(n, k)\n{\n  if k == 1 || k == n then\n    3 * n\n  else\n    3 * n + min(k - 1, n - k)\n}", "vc-helpers": "", "vc-spec": "method MinimumMoves(n: int, k: int) returns (result: int)\n  requires ValidInput(n, k)\n  ensures result == OptimalMoves(n, k)\n  ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1850", "vc-description": "Given N astronauts with current point rankings and N point awards for the next race,\nfind the best possible ranking for astronaut at position D after the race.\nThe target astronaut gets the maximum award, and we try to minimize awards to astronauts\nahead of them to maximize how many can be overtaken.", "vc-preamble": "predicate ValidInput(n: int, d: int, currentPoints: seq<int>, awards: seq<int>)\n{\n    n >= 1 && n <= 200000 &&\n    d >= 1 && d <= n &&\n    |currentPoints| == n &&\n    |awards| == n &&\n    d-1 < |currentPoints| &&\n    (forall i :: 0 <= i < |currentPoints|-1 ==> currentPoints[i] >= currentPoints[i+1]) &&\n    (forall i :: 0 <= i < |awards|-1 ==> awards[i] >= awards[i+1])\n}\n\nfunction CountOvertaken(currentPoints: seq<int>, awards: seq<int>, d: int): int\n    requires |currentPoints| == |awards|\n    requires d >= 1 && d <= |currentPoints|\n    requires d-1 < |currentPoints|\n    requires forall i :: 0 <= i < |awards|-1 ==> awards[i] >= awards[i+1]\n{\n    CountOvertakenHelper(currentPoints, awards, d, 0, 0)\n}\n\nfunction CountOvertakenHelper(currentPoints: seq<int>, awards: seq<int>, d: int, pos: int, usedAwards: int): int\n    requires |currentPoints| == |awards|\n    requires d >= 1 && d <= |currentPoints|\n    requires d-1 < |currentPoints|\n    requires forall i :: 0 <= i < |awards|-1 ==> awards[i] >= awards[i+1]\n    requires 0 <= pos <= d-1\n    requires 0 <= usedAwards <= |awards|\n    decreases d-1-pos\n{\n    if pos >= d-1 then 0\n    else\n        var targetScore := currentPoints[d-1] + awards[0];\n        var remainingAwards := |awards| - usedAwards;\n        if remainingAwards > 0 && usedAwards < |awards| && currentPoints[pos] + awards[|awards|-1-usedAwards] <= targetScore then\n            1 + CountOvertakenHelper(currentPoints, awards, d, pos+1, usedAwards+1)\n        else\n            CountOvertakenHelper(currentPoints, awards, d, pos+1, usedAwards)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, d: int, currentPoints: seq<int>, awards: seq<int>) returns (result: int)\n    requires ValidInput(n, d, currentPoints, awards)\n    ensures 1 <= result <= d\n    ensures result == d - CountOvertaken(currentPoints, awards, d)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1877", "vc-description": "Given a sequence of moves on a 2D grid starting from position (0,0), count the number of times \nthe path crosses between two kingdoms separated by the line x = y. Kingdom 1 contains points \nwhere x > y, Kingdom 2 contains points where x < y, and points where x = y are on the wall/gates.\nMoves are 'U' (up: y+1) and 'R' (right: x+1). Count transitions between kingdoms, ignoring \npositions on the wall, with no cost for the initial move from starting position.", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n    n >= 0 && |s| == n && forall i :: 0 <= i < |s| ==> s[i] == 'U' || s[i] == 'R'\n}\n\nfunction CountKingdomTransitions(s: string): int\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'U' || s[i] == 'R'\n    ensures CountKingdomTransitions(s) >= 0\n    ensures CountKingdomTransitions(s) <= |s|\n{\n    if |s| == 0 then 0\n    else CountTransitionsHelper(s, 0, 0, 0, -1)\n}\n\nfunction CountTransitionsHelper(s: string, pos: int, x: int, y: int, pred: int): int\n    requires 0 <= pos <= |s|\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'U' || s[i] == 'R'\n    requires pred == -1 || pred == 0 || pred == 1\n    ensures CountTransitionsHelper(s, pos, x, y, pred) >= 0\n    ensures CountTransitionsHelper(s, pos, x, y, pred) <= |s| - pos\n    decreases |s| - pos\n{\n    if pos == |s| then 0\n    else\n        var newX := if s[pos] == 'U' then x else x + 1;\n        var newY := if s[pos] == 'U' then y + 1 else y;\n\n        if newX == newY then\n            CountTransitionsHelper(s, pos + 1, newX, newY, pred)\n        else\n            var cur := if newX > newY then 0 else 1;\n            var transition := if cur != pred && pred != -1 then 1 else 0;\n            transition + CountTransitionsHelper(s, pos + 1, newX, newY, cur)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: int)\n    requires ValidInput(n, s)\n    ensures result >= 0\n    ensures result <= n\n    ensures n == 0 ==> result == 0\n    ensures result == CountKingdomTransitions(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1878", "vc-description": "Given n rectangles on a 100\u00d7100 grid, where each rectangle is defined by its bottom-left corner (x\u2081, y\u2081) and top-right corner (x\u2082, y\u2082), \ncalculate the sum of all cell values in the grid. Each cell's value equals the number of rectangles that contain it.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 0\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n    requires |s| >= 0\n    ensures |SplitLinesFunc(s)| >= 0\n    ensures forall i :: 0 <= i < |SplitLinesFunc(s)| ==> '\\n' !in SplitLinesFunc(s)[i]\n{\n    if |s| == 0 then []\n    else SplitLinesHelper(s, 0, 0, [])\n}\n\nfunction SplitLinesHelper(s: string, start: int, pos: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= pos <= |s|\n    requires forall i :: 0 <= i < |acc| ==> '\\n' !in acc[i]\n    requires forall k :: start <= k < pos ==> s[k] != '\\n'\n    ensures |SplitLinesHelper(s, start, pos, acc)| >= |acc|\n    ensures forall i :: 0 <= i < |SplitLinesHelper(s, start, pos, acc)| ==> '\\n' !in SplitLinesHelper(s, start, pos, acc)[i]\n    decreases |s| - pos\n{\n    if pos >= |s| then\n        if start < pos then \n            assert forall k :: start <= k < pos ==> s[k] != '\\n';\n            acc + [s[start..pos]] \n        else acc\n    else if s[pos] == '\\n' then\n        var new_acc := if start < pos then \n            (assert forall k :: start <= k < pos ==> s[k] != '\\n'; acc + [s[start..pos]]) \n            else acc;\n        SplitLinesHelper(s, pos + 1, pos + 1, new_acc)\n    else\n        SplitLinesHelper(s, start, pos + 1, acc)\n}\n\nfunction ParseIntFunc(s: string): int\n    requires |s| >= 0\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -ParseIntPosFunc(s[1..])\n    else ParseIntPosFunc(s)\n}\n\nfunction ParseIntPosFunc(s: string): int\n    requires |s| >= 0\n    ensures ParseIntPosFunc(s) >= 0\n{\n    if |s| == 0 then 0\n    else if '0' <= s[0] <= '9' then\n        (s[0] as int - '0' as int) + 10 * ParseIntPosFunc(s[1..])\n    else 0\n}\n\nfunction ParseIntsFunc(s: string): seq<int>\n    requires |s| >= 0\n    ensures |ParseIntsFunc(s)| >= 0\n{\n    if |s| == 0 then []\n    else ParseIntsHelper(s, 0, 0, [])\n}\n\nfunction ParseIntsHelper(s: string, start: int, pos: int, acc: seq<int>): seq<int>\n    requires 0 <= start <= pos <= |s|\n    ensures |ParseIntsHelper(s, start, pos, acc)| >= |acc|\n    decreases |s| - pos\n{\n    if pos >= |s| then\n        if start < pos then acc + [ParseIntFunc(s[start..pos])] else acc\n    else if s[pos] == ' ' then\n        var new_acc := if start < pos then acc + [ParseIntFunc(s[start..pos])] else acc;\n        ParseIntsHelper(s, pos + 1, pos + 1, new_acc)\n    else\n        ParseIntsHelper(s, start, pos + 1, acc)\n}\n\nfunction IntToStringFunc(n: int): string\n    ensures |IntToStringFunc(n)| >= 1\n{\n    if n == 0 then \"0\"\n    else if n > 0 then IntToStringPos(n)\n    else \"-\" + IntToStringPos(-n)\n}\n\nfunction IntToStringPos(n: int): string\n    requires n > 0\n    ensures |IntToStringPos(n)| >= 1\n    decreases n\n{\n    if n < 10 then [('0' as int + n) as char]\n    else IntToStringPos(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\nfunction ComputeTotalArea(rectangle_lines: seq<string>): int\n    ensures ComputeTotalArea(rectangle_lines) >= 0\n{\n    if |rectangle_lines| == 0 then 0\n    else\n        var coords := ParseIntsFunc(rectangle_lines[0]);\n        var area := if |coords| >= 4 then \n            var computed := (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 then computed else 0\n        else 0;\n        area + ComputeTotalArea(rectangle_lines[1..])\n}\n\nfunction ComputeTotalAreaPartial(rectangle_lines: seq<string>, n: int): int\n    ensures ComputeTotalAreaPartial(rectangle_lines, n) >= 0\n{\n    if n <= 0 || |rectangle_lines| == 0 then 0\n    else\n        var coords := ParseIntsFunc(rectangle_lines[0]);\n        var area := if |coords| >= 4 then \n            var computed := (coords[2] - coords[0] + 1) * (coords[3] - coords[1] + 1);\n            if computed >= 0 then computed else 0\n        else 0;\n        area + ComputeTotalAreaPartial(rectangle_lines[1..], n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| >= 1\n    ensures result[|result|-1] == '\\n'\n    ensures exists total_area: int ::\n        total_area >= 0 &&\n        result == IntToStringFunc(total_area) + \"\\n\" &&\n        (var processed_input := if |input| > 0 && input[|input|-1] == '\\n' then input else input + \"\\n\";\n         var lines := SplitLinesFunc(processed_input);\n         if |lines| == 0 then total_area == 0\n         else\n         (var n := ParseIntFunc(lines[0]);\n          if n >= 0 && n + 1 <= |lines| then\n            total_area == ComputeTotalArea(lines[1..n+1])\n          else\n            total_area == ComputeTotalAreaPartial(lines[1..], n)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1886", "vc-description": "Given a non-empty word consisting of lowercase and uppercase English letters,\ncapitalize the first letter while keeping all other letters unchanged.", "vc-preamble": "predicate ValidInput(word: string)\n{\n  |word| > 0 && forall i :: 0 <= i < |word| ==> ('a' <= word[i] <= 'z') || ('A' <= word[i] <= 'Z')\n}\n\npredicate CorrectCapitalization(input: string, output: string)\n  requires ValidInput(input)\n{\n  |output| == |input| &&\n  ('A' <= output[0] <= 'Z') &&\n  (('a' <= input[0] <= 'z') ==> ('A' <= output[0] <= 'Z')) &&\n  (('A' <= input[0] <= 'Z') ==> (output[0] == input[0])) &&\n  forall i :: 1 <= i < |input| ==> output[i] == input[i]\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1887", "vc-description": "Given two rows of n students each, select a team with maximum total height\nsuch that selected students have strictly increasing indices, no two\nconsecutive selected students are from the same row, and any number of\nstudents can be selected (including zero).", "vc-preamble": "predicate ValidInput(n: int, h1: seq<int>, h2: seq<int>)\n{\n    n >= 1 && |h1| >= n && |h2| >= n &&\n    (forall i :: 0 <= i < n ==> h1[i] >= 0) &&\n    (forall i :: 0 <= i < n ==> h2[i] >= 0)\n}\n\nfunction maxTeamHeight(n: int, h1: seq<int>, h2: seq<int>): int\n    requires ValidInput(n, h1, h2)\n{\n    var dp1 := maxHeightEndingInRow1(n, h1, h2);\n    var dp2 := maxHeightEndingInRow2(n, h1, h2);\n    if dp1 > dp2 then dp1 else dp2\n}\n\nfunction maxHeightEndingInRow1(n: int, h1: seq<int>, h2: seq<int>): int\n    requires ValidInput(n, h1, h2)\n    decreases n\n{\n    if n == 1 then h1[0]\n    else\n        var prevRow2 := maxHeightEndingInRow2(n-1, h1, h2);\n        var prevRow1 := maxHeightEndingInRow1(n-1, h1, h2);\n        var takeFromRow2 := prevRow2 + h1[n-1];\n        if takeFromRow2 > prevRow1 then takeFromRow2 else prevRow1\n}\n\nfunction maxHeightEndingInRow2(n: int, h1: seq<int>, h2: seq<int>): int\n    requires ValidInput(n, h1, h2)\n    decreases n\n{\n    if n == 1 then h2[0]\n    else\n        var prevRow1 := maxHeightEndingInRow1(n-1, h1, h2);\n        var prevRow2 := maxHeightEndingInRow2(n-1, h1, h2);\n        var takeFromRow1 := prevRow1 + h2[n-1];\n        if takeFromRow1 > prevRow2 then takeFromRow1 else prevRow2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, h1: seq<int>, h2: seq<int>) returns (result: int)\n    requires ValidInput(n, h1, h2)\n    ensures result >= 0\n    ensures result == maxTeamHeight(n, h1, h2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1889", "vc-description": "Given an n\u00d7m grid where each cell contains either 0 or 1, process q queries.\nEach query flips the value at position (i,j) from 0 to 1 or 1 to 0.\nAfter each query, calculate the score: the maximum length of consecutive 1s across all rows in the grid.", "vc-preamble": "predicate ValidGrid(grid: seq<seq<int>>, n: int, m: int)\n{\n    |grid| == n && n > 0 && m > 0 &&\n    (forall i :: 0 <= i < n ==> |grid[i]| == m) &&\n    (forall i, j :: 0 <= i < n && 0 <= j < m ==> grid[i][j] == 0 || grid[i][j] == 1)\n}\n\npredicate ValidQueries(queries: seq<(int, int)>, q: int, n: int, m: int)\n{\n    |queries| == q && q >= 0 &&\n    (forall k :: 0 <= k < q ==> 1 <= queries[k].0 <= n && 1 <= queries[k].1 <= m)\n}\n\nfunction ConsHelper(l: seq<int>, index: int, current: int, maxSoFar: int): int\n    requires 0 <= index\n    decreases |l| - index\n{\n    if index >= |l| then maxSoFar\n    else if l[index] == 1 then\n        var newCurrent := current + 1;\n        var newMax := if newCurrent > maxSoFar then newCurrent else maxSoFar;\n        ConsHelper(l, index + 1, newCurrent, newMax)\n    else\n        ConsHelper(l, index + 1, 0, maxSoFar)\n}\n\nfunction cons(l: seq<int>): int\n{\n    ConsHelper(l, 0, 0, 0)\n}\n\nfunction MaxInSeq(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else \n        var rest := MaxInSeq(s[1..]);\n        if s[0] > rest then s[0] else rest\n}\n\nfunction ComputeScore(grid: seq<seq<int>>): int\n    requires |grid| > 0\n    requires forall i :: 0 <= i < |grid| ==> |grid[i]| > 0\n{\n    var rowScores := seq(|grid|, i requires 0 <= i < |grid| => cons(grid[i]));\n    MaxInSeq(rowScores)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, q: int, grid: seq<seq<int>>, queries: seq<(int, int)>) returns (results: seq<int>)\n    requires ValidGrid(grid, n, m)\n    requires ValidQueries(queries, q, n, m)\n    ensures |results| == q", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_189", "vc-description": "Given n sticks with positive integer lengths, find a positive integer t and modify sticks to minimize \ntotal cost such that all final lengths are almost good for t (within distance 1 of t).\nCost to change a stick's length is the absolute difference.", "vc-preamble": "predicate ValidInput(n: int, sticks: seq<int>)\n{\n    1 <= n <= 1000 &&\n    |sticks| == n &&\n    (forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100)\n}\n\nfunction CostForT(sticks: seq<int>, t: int): int\n    requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100\n    requires 1 <= t <= 99\n    ensures CostForT(sticks, t) >= 0\n{\n    SumCosts(sticks, t, 0)\n}\n\nfunction SumCosts(sticks: seq<int>, t: int, index: int): int\n    requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100\n    requires 1 <= t <= 99\n    requires 0 <= index <= |sticks|\n    ensures SumCosts(sticks, t, index) >= 0\n    decreases |sticks| - index\n{\n    if index == |sticks| then 0\n    else Max(0, Abs(t - sticks[index]) - 1) + SumCosts(sticks, t, index + 1)\n}\n\nfunction Abs(x: int): int\n    ensures Abs(x) >= 0\n{\n    if x >= 0 then x else -x\n}\n\nfunction Max(a: int, b: int): int\n    ensures Max(a, b) >= a && Max(a, b) >= b\n{\n    if a >= b then a else b\n}\n\npredicate IsOptimalT(sticks: seq<int>, t: int)\n    requires forall i :: 0 <= i < |sticks| ==> 1 <= sticks[i] <= 100\n    requires 1 <= t <= 99\n{\n    forall other_t :: 1 <= other_t <= 99 ==> \n        CostForT(sticks, t) <= CostForT(sticks, other_t)\n}", "vc-helpers": "", "vc-spec": "method FindOptimalT(n: int, sticks: seq<int>) returns (t: int, min_cost: int)\n    requires ValidInput(n, sticks)\n    ensures 1 <= t <= 99\n    ensures min_cost >= 0\n    ensures min_cost == CostForT(sticks, t)\n    ensures IsOptimalT(sticks, t)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1909", "vc-description": "Given n tasks numbered 1 to n and parameter k, find the starting task that minimizes\ntotal \"telling off power\" when Dima performs tasks in circular order and Inna\ninterrupts every k tasks (1st, (k+1)th, (2k+1)th, etc.).", "vc-preamble": "predicate ValidInput(n: int, k: int, powers: seq<int>)\n{\n    n > 0 && k > 0 && k <= n && n % k == 0 && |powers| == n\n}\n\npredicate IsOptimalStartingTask(result: int, n: int, k: int, powers: seq<int>)\n    requires ValidInput(n, k, powers)\n{\n    1 <= result <= k\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, powers: seq<int>) returns (result: int)\n    requires ValidInput(n, k, powers)\n    ensures IsOptimalStartingTask(result, n, k, powers)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1912", "vc-description": "Given T test cases with four integers r, g, b, w representing ball counts,\ndetermine if balls can be arranged into a palindrome after performing operations.\nOperation: select one red, green, and blue ball and change all three to white.\nFor palindromes, at most one color can have an odd count.", "vc-preamble": "predicate ValidInput(input: string)\n{\n  |input| > 0 &&\n  input[|input|-1] == '\\n' &&\n  ValidInputStructure(input)\n}\n\npredicate ValidInputStructure(input: string)\n{\n  |input| > 0\n}\n\npredicate ValidOutputFormat(output: string)\n{\n  output == \"\" || output[|output|-1] == '\\n'\n}\n\npredicate InputOutputCorrespondence(input: string, output: string)\n  requires ValidInput(input)\n  requires ValidOutputFormat(output)\n{\n  true\n}\n\nfunction ProcessInput(input: string): string\n  requires ValidInput(input)\n  ensures ValidOutputFormat(ProcessInput(input))\n  ensures InputOutputCorrespondence(input, ProcessInput(input))\n{\n  \"\"\n}\n\npredicate CanFormPalindrome(r: int, g: int, b: int, w: int)\n  requires r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n  var oddCount := (if r % 2 == 1 then 1 else 0) + \n                  (if g % 2 == 1 then 1 else 0) + \n                  (if b % 2 == 1 then 1 else 0) + \n                  (if w % 2 == 1 then 1 else 0);\n  oddCount <= 1 || \n  (r > 0 && g > 0 && b > 0 && CanFormPalindromeAfterOperation(r-1, g-1, b-1, w+3))\n}\n\npredicate CanFormPalindromeAfterOperation(r: int, g: int, b: int, w: int)\n  requires r >= 0 && g >= 0 && b >= 0 && w >= 0\n{\n  var oddCount := (if r % 2 == 1 then 1 else 0) + \n                  (if g % 2 == 1 then 1 else 0) + \n                  (if b % 2 == 1 then 1 else 0) + \n                  (if w % 2 == 1 then 1 else 0);\n  oddCount <= 1\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires stdin_input[|stdin_input|-1] == '\\n' || !('\\n' in stdin_input[..|stdin_input|-1])\n  requires ValidInput(stdin_input)\n  ensures |result| >= 0\n  ensures forall i :: 0 <= i < |result| ==> result[i] in \"YesNo\\n \"\n  ensures result == \"\" || result[|result|-1] == '\\n'\n  ensures ValidOutputFormat(result)\n  ensures InputOutputCorrespondence(stdin_input, result)\n  ensures result == ProcessInput(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1922", "vc-description": "Given an N\u00d7M grid of cards (all initially face up), perform one operation for each card position (i,j): \nflip the card at position (i,j) and all cards in the 8 adjacent positions (sharing a side or corner), \nif those positions exist in the grid. Determine how many cards face down after all N\u00d7M operations are completed.", "vc-preamble": "predicate ValidInput(N: int, M: int)\n{\n    N >= 1 && M >= 1\n}\n\nfunction CountFaceDownCards(N: int, M: int): int\n    requires ValidInput(N, M)\n{\n    if N == 1 && M == 1 then 1\n    else if N == 1 then M - 2\n    else if M == 1 then N - 2\n    else (N - 2) * (M - 2)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, M: int) returns (result: int)\n    requires ValidInput(N, M)\n    ensures result == CountFaceDownCards(N, M)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1925", "vc-description": "Given integers A, B, and N, find the maximum value of floor(A*x/B) - A*floor(x/B) \nover all non-negative integers x where 0 \u2264 x \u2264 N.\n\n// B must be positive\n\n// default values with B=1 to avoid division by zero", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    var parts := ParseThreeIntsFunc(input);\n    parts.1 > 0\n}\n\nfunction ParseThreeIntsFunc(s: string): (int, int, int)\n    requires |s| > 0\n{\n    var nums := ParseNumbers(s, 0, [], 0, false);\n    if |nums| >= 3 then (nums[0], if nums[1] > 0 then nums[1] else 1, nums[2])\n    else (0, 1, 0)\n}\n\nfunction ParseNumbers(s: string, i: int, nums: seq<int>, current: int, inNumber: bool): seq<int>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if inNumber && |nums| < 3 then nums + [current] else nums\n    else if |nums| >= 3 then\n        nums\n    else\n        var c := s[i];\n        if c >= '0' && c <= '9' then\n            var digit := c as int - '0' as int;\n            if !inNumber then\n                ParseNumbers(s, i + 1, nums, digit, true)\n            else\n                ParseNumbers(s, i + 1, nums, current * 10 + digit, true)\n        else if inNumber then\n            ParseNumbers(s, i + 1, nums + [current], 0, false)\n        else\n            ParseNumbers(s, i + 1, nums, current, false)\n}\n\nfunction IntToStringFunc(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelperFunc(-n)\n    else IntToStringHelperFunc(n)\n}\n\nfunction IntToStringHelperFunc(n: int): string\n    requires n > 0\n{\n    if n < 10 then\n        [('0' as int + n) as char]\n    else\n        IntToStringHelperFunc(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\nfunction ComputeMaxValue(a: int, b: int, n: int): int\n    requires b > 0\n{\n    var minVal := if b - 1 < n then b - 1 else n;\n    (a * minVal) / b\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures \n        var parts := ParseThreeIntsFunc(input);\n        var a := parts.0;\n        var b := parts.1;  \n        var n := parts.2;\n        b > 0 &&\n        result == IntToStringFunc(ComputeMaxValue(a, b, n)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1926", "vc-description": "Given an array of n integers, for each k from 1 to n-1, construct a k-ary heap structure \nand count the number of min-heap property violations. In a k-ary heap with 1-indexed elements,\nelement at index i has parent at index \u230a(i+k-2)/k\u230b (for i > 1). A violation occurs when \na[child] < a[parent].", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n  n >= 2 && |a| == n\n}\n\nfunction CountViolationsForK(a: seq<int>, n: int, k: int): int\n  requires n >= 2 && |a| == n && 1 <= k <= n - 1\n{\n  |set i | 2 <= i <= n && \n    var parent_idx := (i + k - 2) / k;\n    parent_idx >= 1 && a[i-1] < a[parent_idx-1]|\n}\n\npredicate ValidOutput(result: seq<int>, n: int, a: seq<int>)\n  requires n >= 2 && |a| == n\n{\n  |result| == n - 1 &&\n  (forall k :: 1 <= k <= n - 1 ==> result[k-1] >= 0) &&\n  (forall k :: 1 <= k <= n - 1 ==> result[k-1] == CountViolationsForK(a, n, k))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: seq<int>)\n  requires ValidInput(n, a)\n  ensures ValidOutput(result, n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1932", "vc-description": "Given a collection of regular polyhedrons, calculate the total number of faces.\nEach polyhedron type has a fixed number of faces:\n- Tetrahedron: 4 faces, Cube: 6 faces, Octahedron: 8 faces\n- Dodecahedron: 12 faces, Icosahedron: 20 faces\nInput: First line contains n (number of polyhedrons), next n lines contain polyhedron names\nOutput: Total number of faces across all polyhedrons", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    var lines := SplitLinesFunc(input);\n    |lines| >= 2 && \n    StringToIntFunc(lines[0]) >= 1 &&\n    StringToIntFunc(lines[0]) <= |lines| - 1\n}\n\nfunction GetFaces(polyhedron: string): int\n    ensures GetFaces(polyhedron) >= 0\n    ensures polyhedron == \"Tetrahedron\" ==> GetFaces(polyhedron) == 4\n    ensures polyhedron == \"Cube\" ==> GetFaces(polyhedron) == 6\n    ensures polyhedron == \"Octahedron\" ==> GetFaces(polyhedron) == 8\n    ensures polyhedron == \"Dodecahedron\" ==> GetFaces(polyhedron) == 12\n    ensures polyhedron == \"Icosahedron\" ==> GetFaces(polyhedron) == 20\n    ensures polyhedron != \"Tetrahedron\" && polyhedron != \"Cube\" && polyhedron != \"Octahedron\" && polyhedron != \"Dodecahedron\" && polyhedron != \"Icosahedron\" ==> GetFaces(polyhedron) == 0\n{\n    if polyhedron == \"Tetrahedron\" then 4\n    else if polyhedron == \"Cube\" then 6\n    else if polyhedron == \"Octahedron\" then 8\n    else if polyhedron == \"Dodecahedron\" then 12\n    else if polyhedron == \"Icosahedron\" then 20\n    else 0\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n    requires |s| > 0\n    ensures |SplitLinesFunc(s)| >= 0\n{\n    SplitLinesHelper(s, 0, 0, [])\n}\n\nfunction SplitLinesHelper(s: string, start: int, i: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= i <= |s|\n    requires start <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if start < |s| then acc + [s[start..|s|]]\n        else acc\n    else if s[i] == '\\n' then\n        var newAcc := if start <= i then acc + [s[start..i]] else acc;\n        SplitLinesHelper(s, i + 1, i + 1, newAcc)\n    else\n        SplitLinesHelper(s, start, i + 1, acc)\n}\n\nfunction StringToIntFunc(s: string): int\n    ensures StringToIntFunc(s) >= 0\n{\n    var trimmed := TrimFunc(s);\n    if |trimmed| == 0 then 0\n    else StringToIntHelper(trimmed, 0, 0)\n}\n\nfunction StringToIntHelper(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    requires acc >= 0\n    ensures StringToIntHelper(s, i, acc) >= acc\n    ensures StringToIntHelper(s, i, acc) >= 0\n    decreases |s| - i\n{\n    if i >= |s| then acc\n    else if '0' <= s[i] <= '9' then\n        StringToIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    else\n        StringToIntHelper(s, i + 1, acc)\n}\n\nfunction IntToStringFunc(n: int): string\n    requires n >= 0\n    ensures |IntToStringFunc(n)| > 0\n{\n    if n == 0 then \"0\"\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n > 0\n    ensures |IntToStringHelper(n)| > 0\n    decreases n\n{\n    if n < 10 then \n        [((n + ('0' as int)) as char)]\n    else \n        IntToStringHelper(n / 10) + [((n % 10 + ('0' as int)) as char)]\n}\n\nfunction TrimFunc(s: string): string\n    ensures |TrimFunc(s)| <= |s|\n{\n    var start := TrimStart(s, 0);\n    var end := TrimEnd(s, |s|, start);\n    if start < end then s[start..end] else \"\"\n}\n\nfunction TrimStart(s: string, i: int): int\n    requires 0 <= i <= |s|\n    ensures TrimStart(s, i) >= i\n    ensures TrimStart(s, i) <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then i\n    else if s[i] == ' ' || s[i] == '\\t' || s[i] == '\\r' || s[i] == '\\n' then\n        TrimStart(s, i + 1)\n    else i\n}\n\nfunction TrimEnd(s: string, j: int, start: int): int\n    requires 0 <= start <= j <= |s|\n    ensures start <= TrimEnd(s, j, start) <= j\n    decreases j - start\n{\n    if j <= start then start\n    else if s[j-1] == ' ' || s[j-1] == '\\t' || s[j-1] == '\\r' || s[j-1] == '\\n' then\n        TrimEnd(s, j - 1, start)\n    else j\n}\n\nfunction ComputeTotalUpTo(lines: seq<string>, count: int): int\n    requires |lines| >= 1\n    requires count >= 0\n    ensures ComputeTotalUpTo(lines, count) >= 0\n{\n    if count == 0 then 0\n    else if count >= |lines| then 0\n    else GetFaces(TrimFunc(lines[count])) + ComputeTotalUpTo(lines, count - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures exists totalFaces: int :: totalFaces >= 0 && result == IntToStringFunc(totalFaces) + \"\\n\"\n    ensures ValidInput(input) ==> \n        (var lines := SplitLinesFunc(input);\n         var n := StringToIntFunc(lines[0]);\n         var expectedTotal := ComputeTotalUpTo(lines, n);\n         result == IntToStringFunc(expectedTotal) + \"\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_194", "vc-description": "Given n groups arriving at a restaurant chronologically, where each group has 1 or 2 people,\nand the restaurant has a one-person tables and b two-person tables, determine how many people\nare denied service following specific seating rules.\n\n// group == 1", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, groups: seq<int>)\n{\n    n >= 1 && a >= 1 && b >= 1 && |groups| == n &&\n    forall i :: 0 <= i < |groups| ==> groups[i] == 1 || groups[i] == 2\n}\n\nfunction countDeniedPeople(groups: seq<int>, a: int, b: int): int\n    requires a >= 0 && b >= 0\n    requires forall i :: 0 <= i < |groups| ==> groups[i] == 1 || groups[i] == 2\n    decreases |groups|\n{\n    countDeniedPeopleWithHalf(groups, a, b, 0)\n}\n\nfunction countDeniedPeopleWithHalf(groups: seq<int>, a: int, b: int, halfOccupied: int): int\n    requires a >= 0 && b >= 0 && halfOccupied >= 0\n    requires forall i :: 0 <= i < |groups| ==> groups[i] == 1 || groups[i] == 2\n    decreases |groups|\n{\n    if |groups| == 0 then 0\n    else\n        var group := groups[0];\n        var rest := groups[1..];\n        if group == 2 then\n            if b > 0 then countDeniedPeopleWithHalf(rest, a, b - 1, halfOccupied)\n            else 2 + countDeniedPeopleWithHalf(rest, a, b, halfOccupied)\n        else\n            if a > 0 then countDeniedPeopleWithHalf(rest, a - 1, b, halfOccupied)\n            else if b > 0 then countDeniedPeopleWithHalf(rest, a, b - 1, halfOccupied + 1)\n            else if halfOccupied > 0 then countDeniedPeopleWithHalf(rest, a, b, halfOccupied - 1)\n            else 1 + countDeniedPeopleWithHalf(rest, a, b, halfOccupied)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, groups: seq<int>) returns (denied: int)\n    requires ValidInput(n, a, b, groups)\n    ensures denied >= 0\n    ensures denied == countDeniedPeople(groups, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1940", "vc-description": "Given n types of pebbles with w_i pebbles of type i, and a person with 2 pockets \nthat can each hold at most k pebbles, find the minimum number of days needed to \ncollect all pebbles. Different pebble types cannot be mixed in the same pocket, \nboth pockets can be used simultaneously on the same day, and each pebble type \nmust be collected completely.", "vc-preamble": "predicate ValidInput(n: int, k: int, w: seq<int>)\n{\n    k > 0 && n >= 0 && |w| == n && forall i :: 0 <= i < |w| ==> w[i] >= 0\n}\n\nfunction sum_trips(w: seq<int>, k: int): int\n    requires k > 0\n    requires forall i :: 0 <= i < |w| ==> w[i] >= 0\n    ensures sum_trips(w, k) >= 0\n{\n    if |w| == 0 then 0\n    else (w[0] + k - 1) / k + sum_trips(w[1..], k)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, w: seq<int>) returns (result: int)\n    requires ValidInput(n, k, w)\n    ensures result >= 0\n    ensures result == (sum_trips(w, k) + 1) / 2", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1948", "vc-description": "Given an undirected tree with n vertices rooted at vertex 1, Alice starts at vertex 1 and Bob starts at vertex x.\nPlayers alternate turns with Bob going first. Each turn a player can stay at current vertex or move to adjacent vertex.\nGame ends when Alice reaches Bob's vertex. Alice minimizes total moves, Bob maximizes total moves.\nFind the total number of moves in optimal play.", "vc-preamble": "predicate ValidInput(n: int, x: int, edges: seq<(int, int)>)\n{\n  n > 0 && 1 <= x <= n && |edges| == n - 1 &&\n  forall e :: e in edges ==> 0 <= e.0 < n && 0 <= e.1 < n\n}\n\npredicate ValidDistances(wayA: seq<int>, wayB: seq<int>, n: int, x: int)\n{\n  |wayA| == n && |wayB| == n && n > 0 && 1 <= x <= n &&\n  wayA[0] == 0 && wayB[x-1] == 0 &&\n  forall i :: 0 <= i < n ==> wayA[i] >= 0 && wayB[i] >= 0\n}\n\npredicate ValidLeaves(leaves: seq<int>, edges: seq<(int, int)>, n: int)\n  requires ValidInput(n, 1, edges)\n{\n  (forall i :: 0 <= i < |leaves| ==> 0 <= leaves[i] < n) &&\n  (forall i :: 0 <= i < |leaves| ==> IsLeafNode(leaves[i], edges, n)) &&\n  (forall i :: 0 <= i < n ==> IsLeafNode(i, edges, n) ==> i in leaves) &&\n  NoDuplicates(leaves)\n}\n\nfunction OptimalMoves(wayA: seq<int>, wayB: seq<int>, leaves: seq<int>, x: int): int\n  requires ValidDistances(wayA, wayB, |wayA|, x)\n  requires forall i :: 0 <= i < |leaves| ==> 0 <= leaves[i] < |wayA| && 0 <= leaves[i] < |wayB|\n{\n  2 * ComputeOptimalMoves(wayA, wayB, leaves, x-1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, x: int, edges: seq<(int, int)>, leaves: seq<int>, wayA: seq<int>, wayB: seq<int>) returns (result: int)\n  requires ValidInput(n, x, edges)\n  requires ValidDistances(wayA, wayB, n, x)\n  requires ValidLeaves(leaves, edges, n)\n  requires forall i :: 0 <= i < |leaves| ==> 0 <= leaves[i] < |wayA| && 0 <= leaves[i] < |wayB|\n  ensures result >= 0\n  ensures result == OptimalMoves(wayA, wayB, leaves, x)\n  ensures result % 2 == 0\n  ensures result >= 2 * wayA[x-1]", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1958", "vc-description": "Given n buyers and cost p per apple, determine total money seller should receive.\nEach buyer purchased exactly half the apples available at their turn.\nIf apples were odd, buyer received additional half apple as gift.\nSeller started with some positive number of apples and ended with zero apples.", "vc-preamble": "predicate ValidInput(n: int, p: int, buyers: seq<string>)\n{\n    1 <= n <= 40 &&\n    2 <= p <= 1000 &&\n    p % 2 == 0 &&\n    |buyers| == n &&\n    forall i :: 0 <= i < |buyers| ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n}\n\nfunction computeTotalPayment(buyers: seq<string>, p: int): int\n    requires p >= 0\n    requires p % 2 == 0\n    requires forall i :: 0 <= i < |buyers| ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    ensures computeTotalPayment(buyers, p) >= 0\n{\n    computePaymentBackward(buyers, p, |buyers| - 1, 0)\n}\n\nfunction computePaymentBackward(buyers: seq<string>, p: int, currentIndex: int, currentApples: int): int\n    requires p >= 0\n    requires p % 2 == 0\n    requires -1 <= currentIndex < |buyers|\n    requires currentApples >= 0\n    requires forall i :: 0 <= i < |buyers| ==> buyers[i] == \"half\" || buyers[i] == \"halfplus\"\n    ensures computePaymentBackward(buyers, p, currentIndex, currentApples) >= 0\n{\n    if currentIndex < 0 then 0\n    else\n        var newApples := if buyers[currentIndex] == \"halfplus\" then \n                            currentApples * 2 + 1\n                         else \n                            currentApples * 2;\n        var payment := if buyers[currentIndex] == \"halfplus\" then \n                          (newApples / 2) * p\n                       else \n                          currentApples * p;\n        payment + computePaymentBackward(buyers, p, currentIndex - 1, newApples)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: int, buyers: seq<string>) returns (result: int)\n    requires ValidInput(n, p, buyers)\n    ensures result >= 0\n    ensures result == computeTotalPayment(buyers, p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1965", "vc-description": "Given n accounts with integer ratings and one infected account (Killjoy's) with rating x,\nfind the minimum number of contests needed to infect all n accounts.\nInfection spreads instantly to accounts with the same rating.\nIn contests, participants can change ratings (sum of changes = 0), Killjoy cannot participate.", "vc-preamble": "function CountOccurrences(s: seq<int>, x: int): int\n    ensures CountOccurrences(s, x) >= 0\n    ensures CountOccurrences(s, x) <= |s|\n{\n    if |s| == 0 then 0\n    else if s[0] == x then 1 + CountOccurrences(s[1..], x)\n    else CountOccurrences(s[1..], x)\n}\n\nfunction Sum(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + Sum(s[1..])\n}\n\npredicate ValidInput(n: int, ratings: seq<int>)\n{\n    n >= 2 && |ratings| == n\n}\n\npredicate AllInfected(k: int, ratings: seq<int>)\n{\n    k in ratings && CountOccurrences(ratings, k) == |ratings|\n}\n\npredicate CanInfectInOneContest(k: int, ratings: seq<int>)\n{\n    (k in ratings && CountOccurrences(ratings, k) != |ratings|) ||\n    (k !in ratings && k * |ratings| == Sum(ratings))\n}\n\npredicate RequiresTwoContests(k: int, ratings: seq<int>)\n{\n    k !in ratings && k * |ratings| != Sum(ratings)\n}", "vc-helpers": "", "vc-spec": "method SolveCase(n: int, k: int, ratings: seq<int>) returns (answer: int)\n    requires ValidInput(n, ratings)\n    ensures answer >= 0 && answer <= 2\n    ensures AllInfected(k, ratings) ==> answer == 0\n    ensures CanInfectInOneContest(k, ratings) && !AllInfected(k, ratings) ==> answer == 1\n    ensures RequiresTwoContests(k, ratings) ==> answer == 2", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1966", "vc-description": "Given 4 square pieces of size n\u00d7n (where n is odd), each containing squares colored 0 (white) or 1 (black),\narrange them into a 2n\u00d72n board and recolor the minimum number of squares to form a valid chessboard.\nA valid chessboard has alternating colors where each square has a different color from all its adjacent squares.\nPieces can be rearranged but cannot be rotated or flipped.", "vc-preamble": "predicate contains_valid_input_format(input: string)\n{\n    exists n: int :: 1 <= n <= 100 && n % 2 == 1 && \n        input_has_correct_structure_for_n(input, n) &&\n        input_contains_exactly_four_pieces_of_size_n(input, n) &&\n        all_pieces_contain_only_binary_chars(input, n)\n}\n\npredicate input_has_correct_structure_for_n(input: string, n: int)\n    requires 1 <= n <= 100 && n % 2 == 1\n{\n    var lines := split_by_newline(input);\n    |lines| >= 4*n + 4 &&\n    is_valid_integer_string(lines[0]) &&\n    string_to_int(lines[0]) == n &&\n    (|lines| > n+1 ==> lines[n+1] == \"\") && \n    (|lines| > 2*n+2 ==> lines[2*n+2] == \"\") && \n    (|lines| > 3*n+3 ==> lines[3*n+3] == \"\")\n}\n\npredicate input_contains_exactly_four_pieces_of_size_n(input: string, n: int)\n    requires 1 <= n <= 100 && n % 2 == 1\n{\n    var lines := split_by_newline(input);\n    |lines| >= 4*n + 4 &&\n    (forall i | 1 <= i <= n && i < |lines| :: |lines[i]| == n) &&\n    (forall i | n+2 <= i <= 2*n+1 && i < |lines| :: |lines[i]| == n) &&\n    (forall i | 2*n+3 <= i <= 3*n+2 && i < |lines| :: |lines[i]| == n) &&\n    (forall i | 3*n+4 <= i <= 4*n+3 && i < |lines| :: |lines[i]| == n)\n}\n\npredicate all_pieces_contain_only_binary_chars(input: string, n: int)\n    requires 1 <= n <= 100 && n % 2 == 1\n{\n    var lines := split_by_newline(input);\n    |lines| >= 4*n + 4 &&\n    (forall i | 1 <= i <= n && i < |lines| :: \n        forall j | 0 <= j < |lines[i]| :: lines[i][j] == '0' || lines[i][j] == '1') &&\n    (forall i | n+2 <= i <= 2*n+1 && i < |lines| :: \n        forall j | 0 <= j < |lines[i]| :: lines[i][j] == '0' || lines[i][j] == '1') &&\n    (forall i | 2*n+3 <= i <= 3*n+2 && i < |lines| :: \n        forall j | 0 <= j < |lines[i]| :: lines[i][j] == '0' || lines[i][j] == '1') &&\n    (forall i | 3*n+4 <= i <= 4*n+3 && i < |lines| :: \n        forall j | 0 <= j < |lines[i]| :: lines[i][j] == '0' || lines[i][j] == '1')\n}\n\npredicate is_valid_integer_string(s: string)\n{\n    |s| > 0 && \n    (s[0] != '0' || |s| == 1) &&\n    forall i | 0 <= i < |s| :: '0' <= s[i] <= '9'\n}\n\npredicate represents_minimum_recoloring_count(input: string, output: string)\n{\n    is_valid_integer_string(output) &&\n    contains_valid_input_format(input) &&\n    var n := extract_n_from_input(input);\n    var pieces := extract_pieces_from_input(input);\n    |pieces| == 4 &&\n    (forall piece | piece in pieces :: \n        |piece| == n && \n        (forall row | row in piece :: \n            |row| == n &&\n            (forall i | 0 <= i < |row| :: row[i] == '0' || row[i] == '1'))) &&\n    string_to_int(output) == minimum_recoloring_for_pieces(pieces, n)\n}\n\nfunction extract_n_from_input(input: string): int\n    requires contains_valid_input_format(input)\n    ensures 1 <= extract_n_from_input(input) <= 100\n    ensures extract_n_from_input(input) % 2 == 1\n{\n    var lines := split_by_newline(input);\n    if |lines| > 0 && is_valid_integer_string(lines[0]) then\n        string_to_int(lines[0])\n    else\n        1\n}\n\nfunction extract_pieces_from_input(input: string): seq<seq<string>>\n    requires contains_valid_input_format(input)\n    ensures |extract_pieces_from_input(input)| == 4\n{\n    var lines := split_by_newline(input);\n    var n := extract_n_from_input(input);\n    [\n        lines[1..n+1],\n        lines[n+2..2*n+2], \n        lines[2*n+3..3*n+3],\n        lines[3*n+4..4*n+4]\n    ]\n}\n\nfunction minimum_recoloring_for_pieces(pieces: seq<seq<string>>, n: int): int\n    requires |pieces| == 4\n    requires n >= 1 && n % 2 == 1\n    requires forall piece | piece in pieces :: \n             |piece| == n && \n             (forall row | row in piece :: \n                 |row| == n &&\n                 (forall i | 0 <= i < |row| :: row[i] == '0' || row[i] == '1'))\n    ensures 0 <= minimum_recoloring_for_pieces(pieces, n) <= 2*n*n\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires contains_valid_input_format(stdin_input)\n    ensures is_valid_integer_string(result)\n    ensures result != \"\"\n    ensures represents_minimum_recoloring_count(stdin_input, result)\n    ensures var n := extract_n_from_input(stdin_input);\n            string_to_int(result) >= 0 && string_to_int(result) <= 2*n*n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1968", "vc-description": "Given n sellers and Valera's budget v, determine which sellers Valera can make a deal with.\nEach seller i has ki items with prices. Valera can buy from seller i if his budget v is\nstrictly greater than the minimum price among seller i's items.", "vc-preamble": "predicate ValidInput(n: int, v: int, sellers: seq<seq<int>>) {\n    n >= 0 && v >= 0 && |sellers| == n && \n    forall i :: 0 <= i < |sellers| ==> |sellers[i]| > 0\n}\n\npredicate ValidOutput(count: int, indices: seq<int>, n: int) {\n    count == |indices| && count >= 0 && count <= n &&\n    (forall i :: 0 <= i < |indices| ==> 1 <= indices[i] <= n) &&\n    (forall i :: 0 <= i < |indices| - 1 ==> indices[i] < indices[i+1])\n}\n\npredicate CorrectSolution(v: int, sellers: seq<seq<int>>, indices: seq<int>) \n    requires forall i :: 0 <= i < |sellers| ==> |sellers[i]| > 0\n    requires forall i :: 0 <= i < |indices| ==> 1 <= indices[i] <= |sellers|\n{\n    (forall i :: 0 <= i < |indices| ==> v > Min(sellers[indices[i] - 1])) &&\n    (forall i :: 0 <= i < |sellers| ==> (v > Min(sellers[i]) <==> (i + 1) in indices))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, v: int, sellers: seq<seq<int>>) returns (count: int, indices: seq<int>)\n    requires ValidInput(n, v, sellers)\n    ensures ValidOutput(count, indices, n)\n    ensures CorrectSolution(v, sellers, indices)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1972", "vc-description": "Process queries on an array of 500,000 integers initially set to zero.\nType 1 queries add a value to a specific position.\nType 2 queries calculate sum of elements at positions with specific modular property.", "vc-preamble": "predicate validInput(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n'\n}\n\npredicate validOutput(output: string, input: string)\n{\n    |output| > 0 && output[|output|-1] == '\\n'\n}\n\npredicate correctIncrementalQueryProcessing(input: string, output: string)\n{\n    true\n}\n\nfunction splitLinesFunc(input: string): seq<string>\n{\n    if |input| == 0 then [] else [\"1\", \"query1\"]\n}\n\npredicate isValidInteger(s: string)\n{\n    |s| > 0\n}\n\nfunction countType2Queries(queries: seq<string>): nat\n{\n    0\n}\n\nfunction intToString(x: int): string\n{\n    \"1\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires validInput(input)\n    ensures validOutput(output, input)\n    ensures |output| > 0 && output[|output|-1] == '\\n'\n    ensures correctIncrementalQueryProcessing(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_198", "vc-description": "Given a positive integer n, cut a stick of length n into exactly 4 parts with positive integer lengths.\nCount the number of ways to do this such that the parts can form a rectangle (two pairs of equal lengths)\nbut cannot form a square (all four lengths equal). Two cutting methods are distinct if the number of\nparts of any given length differs between them.", "vc-preamble": "predicate ValidRectangleParts(a: int, b: int, n: int)\n{\n    a > 0 && b > 0 && a != b && 2 * a + 2 * b == n\n}\n\nfunction CountValidRectangles(n: int): int\n    requires n > 0\n{\n    if n % 2 == 1 then 0\n    else if n % 4 == 2 then n / 4\n    else n / 4 - 1\n}\n\npredicate ValidInput(n: int)\n{\n    n > 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == CountValidRectangles(n)\n    ensures n % 2 == 1 ==> result == 0\n    ensures n % 2 == 0 && n % 4 == 2 ==> result == n / 4\n    ensures n % 2 == 0 && n % 4 == 0 ==> result == n / 4 - 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1980", "vc-description": "Given n problems with difficulties d_i (in increasing order) and costs c_i, find the maximum profit \nfrom selecting a consecutive subsegment of problems. For a subsegment [l, r]:\n- Revenue: (r - l + 1) \u00d7 a burles (where a is profit per problem)\n- Costs: sum of c_i for i in [l, r] + gap(l, r)\n- gap(l, r) = max{(d_{i+1} - d_i)\u00b2 | l \u2264 i < r}, or 0 if l = r\n- Profit = Revenue - Costs\nFind the maximum possible profit (can be 0 if all segments are unprofitable).", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLinesSpec(input);\n    |lines| >= 1 && \n    |SplitWhitespaceSpec(lines[0])| >= 2 &&\n    var n := ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]);\n    var k := ParseIntSpec(SplitWhitespaceSpec(lines[0])[1]);\n    n > 0 && k > 0 && |lines| >= n + 1 &&\n    (forall i :: 1 <= i <= n ==> \n        i < |lines| && |SplitWhitespaceSpec(lines[i])| >= 2)\n}\n\nfunction OptimalSegmentProfit(input: string, n: nat, k: int): int\n    requires n > 0\n    requires k > 0\n    requires var lines := SplitLinesSpec(input);\n        |lines| >= n + 1 &&\n        (forall i :: 1 <= i <= n ==> \n            i < |lines| && |SplitWhitespaceSpec(lines[i])| >= 2)\n{\n    var lines := SplitLinesSpec(input);\n    var difficulties := seq(n, i requires 0 <= i < n => \n        ParseIntSpec(SplitWhitespaceSpec(lines[i + 1])[0]));\n    var costs := seq(n, i requires 0 <= i < n => \n        ParseIntSpec(SplitWhitespaceSpec(lines[i + 1])[1]));\n\n    MaxSubsegmentProfit(difficulties, costs, k)\n}\n\nfunction MaxSubsegmentProfit(difficulties: seq<int>, costs: seq<int>, k: int): int\n    requires |difficulties| == |costs| >= 0\n    requires k > 0\n    requires forall i :: 0 <= i < |difficulties|-1 ==> difficulties[i] < difficulties[i+1]\n{\n    if |difficulties| == 0 then 0\n    else\n        var allSegmentProfits := seq(|difficulties|, l requires 0 <= l < |difficulties| => \n            seq(|difficulties| - l, len requires 0 <= len < |difficulties| - l =>\n                SubsegmentProfit(difficulties, costs, k, l, l + len)));\n        Max(0, MaxInNestedSeq(allSegmentProfits))\n}\n\nfunction SubsegmentProfit(difficulties: seq<int>, costs: seq<int>, k: int, l: nat, r: nat): int\n    requires |difficulties| == |costs|\n    requires k > 0\n    requires 0 <= l <= r < |difficulties|\n    requires forall i :: 0 <= i < |difficulties|-1 ==> difficulties[i] < difficulties[i+1]\n{\n    var length := r - l + 1;\n    var revenue := length * k;\n    var costSum := SumRange(costs, l, r);\n    var gap := if l == r then 0 else MaxGapSquared(difficulties, l, r);\n    revenue - costSum - gap\n}\n\nfunction SplitLinesSpec(s: string): seq<string>\n{\n    []\n}\n\nfunction SplitWhitespaceSpec(s: string): seq<string>\n{\n    []\n}\n\nfunction ParseIntSpec(s: string): int\n{\n    0\n}\n\nfunction IntToStringResult(n: int): string\n{\n    \"0\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures var lines := SplitLinesSpec(input);\n        (|lines| == 0 || |lines| == 1 || \n         |SplitWhitespaceSpec(lines[0])| < 2 ||\n         ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]) <= 0) ==> \n        result == \"0\\n\"\n    ensures ValidInput(input) ==>\n        (var lines := SplitLinesSpec(input);\n         var n := ParseIntSpec(SplitWhitespaceSpec(lines[0])[0]);\n         var k := ParseIntSpec(SplitWhitespaceSpec(lines[0])[1]);\n         exists profit: int :: \n            profit >= 0 && \n            result == IntToStringResult(profit) + \"\\n\" &&\n            profit == OptimalSegmentProfit(input, n, k))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1984", "vc-description": "Given k game levels represented as n\u00d7m grids containing candies (letters) or empty cells ('.'),\nfind the minimum cost to transmit all levels. Each level can be transmitted in full (cost: n\u00d7m)\nor as differences from a previously transmitted level (cost: d\u00d7w where d is number of differing cells).", "vc-preamble": "function split_lines(s: string): seq<string>\n{\n    []\n}\n\nfunction parse_first_line(s: string): (nat, nat, nat, nat)\n{\n    (1, 1, 1, 1)\n}\n\nfunction parse_levels(lines: seq<string>, n: nat, m: nat, k: nat): seq<seq<string>>\n{\n    []\n}\n\nfunction int_to_string(n: nat): string\n{\n    \"\"\n}\n\nfunction parse_dependency_line(s: string): (nat, nat)\n{\n    (1, 0)\n}\n\npredicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    stdin_input[|stdin_input|-1] == '\\n' &&\n    var lines := split_lines(stdin_input);\n    |lines| >= 1 &&\n    exists n, m, k, w: nat :: (\n        parse_first_line(lines[0]) == (n, m, k, w) &&\n        1 <= n <= 10 && 1 <= m <= 10 && 1 <= k <= 1000 && 1 <= w <= 1000 &&\n        |lines| >= 1 + k * n &&\n        (forall i :: 1 <= i < 1 + k * n ==> |lines[i]| == m) &&\n        (forall i :: 1 <= i < 1 + k * n ==> \n            forall j :: 0 <= j < |lines[i]| ==> \n                (lines[i][j] == '.' || ('a' <= lines[i][j] <= 'z') || ('A' <= lines[i][j] <= 'Z')))\n    )\n}\n\npredicate ValidOutput(result: string, stdin_input: string)\n{\n    |result| > 0 &&\n    result[|result|-1] == '\\n' &&\n    var result_lines := split_lines(result);\n    var lines := split_lines(stdin_input);\n    |lines| >= 1 &&\n    exists n, m, k, w: nat, input_levels: seq<seq<string>> :: (\n        parse_first_line(lines[0]) == (n, m, k, w) &&\n        1 <= n <= 10 && 1 <= m <= 10 && 1 <= k <= 1000 && 1 <= w <= 1000 &&\n        |lines| >= 1 + k * n &&\n        input_levels == parse_levels(lines, n, m, k) &&\n        |input_levels| == k &&\n        (forall i :: 0 <= i < k ==> |input_levels[i]| == n) &&\n        (forall i :: 0 <= i < k ==> forall j :: 0 <= j < n ==> |input_levels[i][j]| == m) &&\n\n        |result_lines| == k + 1 &&\n\n        exists total_cost: nat :: (\n            result_lines[0] == int_to_string(total_cost) &&\n            total_cost == calculate_mst_cost(n, m, k, w, input_levels) &&\n\n            (forall i :: 1 <= i <= k ==> \n                exists level, parent: nat :: (\n                    parse_dependency_line(result_lines[i]) == (level, parent) &&\n                    1 <= level <= k &&\n                    0 <= parent <= k &&\n                    level != parent\n                )) &&\n\n            (forall level :: 1 <= level <= k ==> \n                exists i {:trigger parse_dependency_line(result_lines[i]).0} :: \n                    1 <= i <= k && \n                    parse_dependency_line(result_lines[i]).0 == level &&\n                    (forall j :: 1 <= j <= k && j != i ==> \n                        parse_dependency_line(result_lines[j]).0 != level)) &&\n\n            is_valid_spanning_tree(result_lines, k)\n        )\n    )\n}\n\nfunction calculate_mst_cost(n: nat, m: nat, k: nat, w: nat, levels: seq<seq<string>>): nat\n{\n    0\n}\n\nfunction is_valid_spanning_tree(result_lines: seq<string>, k: nat): bool\n{\n    true\n}\n\nfunction count_differences(level1: seq<string>, level2: seq<string>, n: nat, m: nat): nat\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(result, stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1985", "vc-description": "Given k jury members who sequentially add points to an initial score, determine how many\npossible initial scores could produce a given set of observed intermediate scores.", "vc-preamble": "function sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\nfunction computeInitialScore(pos: int, a: seq<int>, b: seq<int>): int\n    requires 0 <= pos < |a|\n    requires |b| > 0\n{\n    b[0] - sum(a[0..pos+1])\n}\n\nfunction computeBackwardScores(pos: int, scoreAtPos: int, a: seq<int>): set<int>\n    requires 0 <= pos < |a|\n    decreases pos\n{\n    if pos == 0 then {scoreAtPos}\n    else {scoreAtPos} + computeBackwardScores(pos - 1, scoreAtPos - a[pos], a)\n}\n\nfunction computeForwardScores(pos: int, scoreAtPos: int, a: seq<int>): set<int>\n    requires 0 <= pos < |a|\n    decreases |a| - pos\n{\n    if pos == |a| - 1 then {}\n    else computeForwardScores(pos + 1, scoreAtPos + a[pos + 1], a) + {scoreAtPos + a[pos + 1]}\n}\n\nfunction computeScores(pos: int, scoreAtPos: int, a: seq<int>): set<int>\n    requires 0 <= pos < |a|\n{\n    var backwards := computeBackwardScores(pos, scoreAtPos, a);\n    var forwards := computeForwardScores(pos, scoreAtPos, a);\n    backwards + forwards\n}\n\npredicate isValidInitialScore(pos: int, k: int, a: seq<int>, b: seq<int>)\n    requires 0 <= pos < k\n    requires k > 0\n    requires |a| == k\n    requires |b| > 0\n{\n    var scores := computeScores(pos, b[0], a);\n    forall j :: 0 <= j < |b| ==> b[j] in scores\n}\n\nfunction validInitialScores(k: int, a: seq<int>, b: seq<int>): set<int>\n    requires k > 0\n    requires |a| == k\n    requires |b| > 0\n    requires forall i :: 0 <= i < k ==> -2000 <= a[i] <= 2000\n    requires forall i :: 0 <= i < |b| ==> -4000000 <= b[i] <= 4000000\n{\n    set i | 0 <= i < k && isValidInitialScore(i, k, a, b) :: computeInitialScore(i, a, b)\n}\n\npredicate ValidInput(k: int, n: int, a: seq<int>, b: seq<int>)\n{\n    k > 0 && n > 0 && |a| == k && |b| == n && n <= k &&\n    (forall i, j :: 0 <= i < j < n ==> b[i] != b[j]) &&\n    (forall i :: 0 <= i < k ==> -2000 <= a[i] <= 2000) &&\n    (forall i :: 0 <= i < n ==> -4000000 <= b[i] <= 4000000)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, n: int, a: seq<int>, b: seq<int>) returns (result: int)\n    requires ValidInput(k, n, a, b)\n    ensures result >= 0\n    ensures result <= k\n    ensures result == |validInitialScores(k, a, b)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_1988", "vc-description": "Given multiple test cases, each containing a string, find the lexicographically smallest\nstring achievable by applying one of n possible transformations, where transformation i\neither rotates the string by i positions or rotates and reverses the prefix based on parity.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 2 &&\n    (s[|s|-1] == '\\n' || (|s| >= 2 && s[|s|-2..] == \"\\n\")) &&\n    exists lines :: lines == split_lines(s) && |lines| >= 1 &&\n    exists lines, t :: lines == split_lines(s) && t == parse_int(lines[0]) && t >= 1 &&\n    (forall lines, t :: \n        (lines == split_lines(s) && t == parse_int(lines[0])) ==> \n        |lines| >= 1 + 2*t) &&\n    (forall lines, t, i :: \n        (lines == split_lines(s) && t == parse_int(lines[0]) && 0 <= i < t) ==> \n        (exists n :: n == parse_int(lines[1 + 2*i]) && n >= 1 && n <= 5000 && \n         |lines[1 + 2*i + 1]| == n)) &&\n    (forall lines, t, i :: \n        (lines == split_lines(s) && t == parse_int(lines[0]) && 0 <= i < t) ==> \n        (forall j :: 0 <= j < |lines[1 + 2*i + 1]| ==> \n         lines[1 + 2*i + 1][j] in \"abcdefghijklmnopqrstuvwxyz\"))\n}\n\npredicate ValidOutput(result: string)\n{\n    |result| >= 0 &&\n    (result == \"\" || result[|result|-1] == '\\n')\n}\n\nfunction transform_string(input_str: string, n: int, k: int): string\n  requires 1 <= k <= n\n  requires |input_str| == n\n{\n    var i := k - 1;\n    if (n - i) % 2 == 0 then\n        input_str[i..] + input_str[..i]\n    else\n        input_str[i..] + reverse_string(input_str[..i])\n}\n\npredicate is_lexicographically_optimal(result_str: string, input_str: string, n: int, k: int)\n  requires |input_str| == n\n{\n    1 <= k <= n &&\n    (exists transformation :: \n      transformation == transform_string(input_str, n, k) && result_str == transformation &&\n      forall other_k :: 1 <= other_k <= n ==> \n        result_str <= transform_string(input_str, n, other_k))\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n  requires ValidInput(s)\n  ensures ValidOutput(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_199", "vc-description": "Given n kegs containing v_i liters of kvass each, pour exactly s liters total \nsuch that the minimum amount remaining in any keg is maximized. Each keg can \nonly have kvass removed, not added. Return -1 if impossible to pour s liters,\notherwise return the maximum possible minimum remaining amount in any keg.", "vc-preamble": "predicate ValidInput(n: int, s: int, v: seq<int>)\n{\n    n > 0 && |v| == n && s >= 0 && forall i :: 0 <= i < |v| ==> v[i] >= 0\n}\n\nfunction sum(v: seq<int>): int\n{\n    if |v| == 0 then 0\n    else v[0] + sum(v[1..])\n}\n\nfunction minSeq(v: seq<int>): int\n    requires |v| > 0\n    ensures (forall i :: 0 <= i < |v| ==> v[i] >= 0) ==> minSeq(v) >= 0\n{\n    if |v| == 1 then v[0]\n    else if v[0] <= minSeq(v[1..]) then v[0]\n    else minSeq(v[1..])\n}\n\nfunction min(a: int, b: int): int\n{\n    if a <= b then a else b\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: int, v: seq<int>) returns (result: int)\n    requires ValidInput(n, s, v)\n    ensures sum(v) < s ==> result == -1\n    ensures sum(v) >= s ==> result == min((sum(v) - s) / n, minSeq(v))\n    ensures result == -1 || result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_201", "vc-description": "Given two types of candies with different weights and joy values, find the maximum joy units\nachievable by selecting whole candies within a weight constraint. Must maximize total joy\nwhile staying within the weight capacity C.", "vc-preamble": "predicate ValidInput(C: int, Hr: int, Hb: int, Wr: int, Wb: int)\n{\n  C >= 0 && Hr > 0 && Hb > 0 && Wr > 0 && Wb > 0\n}\n\npredicate ValidCandyCombination(redCount: int, blueCount: int, C: int, Wr: int, Wb: int)\n{\n  redCount >= 0 && blueCount >= 0 && redCount * Wr + blueCount * Wb <= C\n}\n\nfunction Joy(redCount: int, blueCount: int, Hr: int, Hb: int): int\n{\n  redCount * Hr + blueCount * Hb\n}", "vc-helpers": "", "vc-spec": "method solve(C: int, Hr: int, Hb: int, Wr: int, Wb: int) returns (result: int)\n  requires ValidInput(C, Hr, Hb, Wr, Wb)\n  ensures result >= 0\n  ensures exists redCount: int, blueCount: int :: \n    ValidCandyCombination(redCount, blueCount, C, Wr, Wb) &&\n    result == Joy(redCount, blueCount, Hr, Hb)\n  ensures forall redCount: int, blueCount: int ::\n    ValidCandyCombination(redCount, blueCount, C, Wr, Wb) ==>\n    Joy(redCount, blueCount, Hr, Hb) <= result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2015", "vc-description": "Given three integers representing counts of red, green, and blue lamps,\ndetermine if it's possible to arrange all lamps in a line such that\nno two adjacent lamps have the same color.", "vc-preamble": "predicate ValidInput(r: int, g: int, b: int)\n{\n    r >= 1 && g >= 1 && b >= 1\n}\n\nfunction MaxOf3(r: int, g: int, b: int): int\n{\n    if r >= g && r >= b then r\n    else if g >= r && g >= b then g\n    else b\n}\n\npredicate CanArrange(r: int, g: int, b: int)\n    requires ValidInput(r, g, b)\n{\n    var maxCount := MaxOf3(r, g, b);\n    var total := r + g + b;\n    2 * maxCount <= total + 1\n}", "vc-helpers": "", "vc-spec": "method CheckLampArrangement(r: int, g: int, b: int) returns (result: bool)\n    requires ValidInput(r, g, b)\n    ensures result == CanArrange(r, g, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2025", "vc-description": "Given a positive integer n, express it as a sum of composite numbers using the maximum possible number of summands.\nA composite number is an integer greater than 1 that is not prime (has positive divisors other than 1 and itself).\nFor each query, return the maximum number of composite summands, or -1 if no such splitting exists.", "vc-preamble": "predicate IsComposite(x: int)\n{\n    x >= 4 && exists k :: 2 <= k < x && x % k == 0\n}\n\npredicate ValidInput(queries: seq<int>)\n{\n    forall i :: 0 <= i < |queries| ==> queries[i] >= 1\n}\n\nfunction MaxCompositeSummands(n: int): int\n{\n    if n % 4 == 0 then n / 4\n    else if n % 4 == 1 && n / 4 >= 2 then n / 4 - 1\n    else if n % 4 == 2 && n / 4 >= 1 then n / 4\n    else if n % 4 == 3 && n / 4 >= 3 then n / 4 - 1\n    else -1\n}\n\npredicate ValidResult(queries: seq<int>, results: seq<int>)\n{\n    |results| == |queries| &&\n    forall i :: 0 <= i < |queries| ==> results[i] == MaxCompositeSummands(queries[i]) &&\n    forall i :: 0 <= i < |queries| ==> results[i] >= -1\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<int>) returns (results: seq<int>)\n    requires ValidInput(queries)\n    ensures ValidResult(queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_203", "vc-description": "Determine the winner of an elimination-style voting game between two factions.\nEmployees vote in rounds, can eliminate opponents, and play optimally.\nThe faction with the last remaining employee wins.", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n  1 <= n <= 200000 && |s| == n && \n  forall i :: 0 <= i < n ==> s[i] == 'D' || s[i] == 'R'\n}\n\nfunction CountD(s: string): int\n  requires forall i :: 0 <= i < |s| ==> s[i] == 'D' || s[i] == 'R'\n  ensures CountD(s) >= 0\n  ensures CountD(s) <= |s|\n  ensures CountD(s) == 0 <==> forall i :: 0 <= i < |s| ==> s[i] != 'D'\n{\n  if |s| == 0 then 0\n  else (if s[0] == 'D' then 1 else 0) + CountD(s[1..])\n}\n\nfunction CountR(s: string): int\n  requires forall i :: 0 <= i < |s| ==> s[i] == 'D' || s[i] == 'R'\n  ensures CountR(s) >= 0\n  ensures CountR(s) <= |s|\n  ensures CountR(s) == 0 <==> forall i :: 0 <= i < |s| ==> s[i] != 'R'\n{\n  if |s| == 0 then 0\n  else (if s[0] == 'R' then 1 else 0) + CountR(s[1..])\n}\n\nfunction OptimalEliminationGameWinner(s: string): string\n  requires |s| > 0\n  requires forall i :: 0 <= i < |s| ==> s[i] == 'D' || s[i] == 'R'\n  ensures OptimalEliminationGameWinner(s) == \"D\" || OptimalEliminationGameWinner(s) == \"R\"\n  ensures CountD(s) == 0 ==> OptimalEliminationGameWinner(s) == \"R\"\n  ensures CountR(s) == 0 ==> OptimalEliminationGameWinner(s) == \"D\"\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == 'D') ==> OptimalEliminationGameWinner(s) == \"D\"\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == 'R') ==> OptimalEliminationGameWinner(s) == \"R\"\n  ensures OptimalEliminationGameWinner(s) == \"D\" ==> CountD(s) > 0\n  ensures OptimalEliminationGameWinner(s) == \"R\" ==> CountR(s) > 0\n{\n  if CountD(s) == 0 then \"R\"\n  else if CountR(s) == 0 then \"D\"\n  else if CountD(s) >= CountR(s) then \"D\"\n  else \"R\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: string)\n  requires ValidInput(n, s)\n  ensures result == \"D\" || result == \"R\"\n  ensures result == \"D\" ==> CountD(s) > 0\n  ensures result == \"R\" ==> CountR(s) > 0\n  ensures CountD(s) == 0 ==> result == \"R\"\n  ensures CountR(s) == 0 ==> result == \"D\"\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == 'D') ==> result == \"D\"\n  ensures (forall i :: 0 <= i < |s| ==> s[i] == 'R') ==> result == \"R\"\n  ensures result == OptimalEliminationGameWinner(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2039", "vc-description": "Given an array of integers, count the number of local extrema.\nA local minimum is an element strictly less than both neighbors.\nA local maximum is an element strictly greater than both neighbors.\nFirst and last elements cannot be local extrema since they lack two neighbors.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 1 && |a| == n\n}\n\nfunction CountLocalExtrema(n: int, a: seq<int>): int\n    requires ValidInput(n, a)\n{\n    |set i | 1 <= i < n - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))|\n}\n\npredicate IsLocalExtremum(a: seq<int>, i: int)\n    requires 0 <= i < |a|\n{\n    1 <= i < |a| - 1 && ((a[i] > a[i-1] && a[i] > a[i+1]) || (a[i] < a[i-1] && a[i] < a[i+1]))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures result >= 0\n    ensures n <= 2 ==> result == 0\n    ensures n > 2 ==> result <= n - 2\n    ensures result == CountLocalExtrema(n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_204", "vc-description": "Count pairs of positive integers (w, h) such that:\n- w \u2264 a (width constraint)  \n- h \u2264 b (height constraint)\n- w/h = x/y (aspect ratio constraint)\nThe solution reduces x/y to lowest terms and finds the maximum multiplier k\nsuch that valid pairs have the form (k\u00d7x', k\u00d7y') where x' = x/gcd(x,y) and y' = y/gcd(x,y)", "vc-preamble": "predicate ValidInput(a: int, b: int, x: int, y: int)\n{\n  a > 0 && b > 0 && x > 0 && y > 0\n}\n\nfunction gcd(a: int, b: int): int\n  requires a >= 0 && b >= 0\n  ensures gcd(a, b) >= 0\n  ensures a > 0 ==> gcd(a, b) > 0\n  ensures b > 0 ==> gcd(a, b) > 0\n  ensures gcd(a, b) <= a || a == 0\n  ensures gcd(a, b) <= b || b == 0\n  decreases b\n{\n  if b == 0 then a else gcd(b, a % b)\n}\n\nfunction min(a: int, b: int): int\n{\n  if a <= b then a else b\n}\n\nfunction ExpectedResult(a: int, b: int, x: int, y: int): int\n  requires ValidInput(a, b, x, y)\n{\n  var g := gcd(x, y);\n  var x_reduced := x / g;\n  var y_reduced := y / g;\n  min(a / x_reduced, b / y_reduced)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, x: int, y: int) returns (result: int)\n  requires ValidInput(a, b, x, y)\n  ensures result >= 0\n  ensures result == ExpectedResult(a, b, x, y)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2044", "vc-description": "Given a notebook with infinite pages where each page holds exactly m names,\nwrite names for n consecutive days. On day i, write exactly a_i names.\nFill pages sequentially - when a page becomes full, turn to the next page.\nDetermine how many times you turn pages on each day.", "vc-preamble": "predicate ValidInput(n: int, m: int, a: seq<int>)\n{\n    n >= 1 && m >= 1 && |a| == n && \n    (forall i :: 0 <= i < |a| ==> a[i] >= 1)\n}\n\npredicate ValidOutput(result: seq<int>, n: int)\n{\n    |result| == n && (forall i :: 0 <= i < |result| ==> result[i] >= 0)\n}\n\nfunction ComputePageTurns(a: seq<int>, m: int, i: int, s: int): int\n    requires m >= 1\n    requires i >= 0\n    requires s >= 0\n{\n    if i >= |a| then 0\n    else (s + a[i]) / m\n}\n\nfunction ComputeNextState(a: seq<int>, m: int, i: int, s: int): int\n    requires m >= 1\n    requires i >= 0\n    requires s >= 0\n{\n    if i >= |a| then s\n    else (s + a[i]) % m\n}\n\npredicate CorrectPageTurns(result: seq<int>, a: seq<int>, m: int)\n    requires m >= 1\n{\n    |result| == |a| &&\n    (forall i :: 0 <= i < |a| ==> \n        var s := ComputeStateAt(a, m, i);\n        result[i] == (s + a[i]) / m)\n}\n\nfunction ComputeStateAt(a: seq<int>, m: int, day: int): int\n    requires m >= 1\n    requires day >= 0\n{\n    if day == 0 then 0\n    else if day > |a| then ComputeStateAt(a, m, |a|)\n    else (ComputeStateAt(a, m, day - 1) + a[day - 1]) % m\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, a: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, m, a)\n    ensures ValidOutput(result, n)\n    ensures CorrectPageTurns(result, a, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2049", "vc-description": "Given an array of n integers and m queries, determine for each query whether a specified subsegment forms a \"ladder\".\nA ladder is a sequence that first non-decreases, then non-increases. Formally, there exists a position x such that \nelements are non-decreasing up to position x, then non-increasing from position x onward.", "vc-preamble": "predicate isLadder(arr: seq<int>, l: int, r: int)\n  requires 0 <= l <= r < |arr|\n{\n  if l == r then true\n  else\n    exists k :: l <= k <= r && \n      isNonDecreasing(arr, l, k) && \n      isNonIncreasing(arr, k, r)\n}\n\npredicate isNonDecreasing(arr: seq<int>, start: int, end: int)\n  requires 0 <= start <= end < |arr|\n{\n  forall i :: start <= i < end ==> arr[i] <= arr[i+1]\n}\n\npredicate isNonIncreasing(arr: seq<int>, start: int, end: int)\n  requires 0 <= start <= end < |arr|\n{\n  forall i :: start <= i < end ==> arr[i] >= arr[i+1]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, arr: seq<int>, queries: seq<(int, int)>) returns (results: seq<string>)\n  requires n >= 1 && m >= 1\n  requires |arr| == n\n  requires |queries| == m\n  requires forall i :: 0 <= i < m ==> 1 <= queries[i].0 <= queries[i].1 <= n\n  ensures |results| == m\n  ensures forall i :: 0 <= i < m ==> results[i] == \"Yes\" || results[i] == \"No\"\n  ensures forall i :: 0 <= i < m ==> \n    (results[i] == \"Yes\" <==> isLadder(arr, queries[i].0 - 1, queries[i].1 - 1))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_207", "vc-description": "Given an integer sequence, determine if it can be divided into an odd number of \nnon-empty contiguous subsegments, where each subsegment has odd length and \nbegins and ends with odd numbers.", "vc-preamble": "predicate ValidInput(a: seq<int>)\n{\n    |a| >= 1\n}\n\npredicate CanBeDivided(a: seq<int>)\n    requires ValidInput(a)\n{\n    |a| % 2 == 1 && a[0] % 2 == 1 && a[|a|-1] % 2 == 1\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: string)\n    requires ValidInput(a)\n    ensures CanBeDivided(a) ==> result == \"Yes\"\n    ensures !CanBeDivided(a) ==> result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2074", "vc-description": "Two players play a sequential game on a grid of restaurant costs.\nEmma (first player) chooses a row to maximize final cost.\nJack (second player) then chooses a column to minimize final cost.\nBoth play optimally. Find the resulting cost when both play optimally.", "vc-preamble": "predicate ValidGrid(grid: seq<seq<int>>) {\n    |grid| > 0 && forall i :: 0 <= i < |grid| ==> |grid[i]| > 0\n}\n\nfunction seq_min(s: seq<int>): int\n    requires |s| > 0\n    ensures seq_min(s) in s\n    ensures forall x :: x in s ==> seq_min(s) <= x\n    decreases |s|\n{\n    if |s| == 1 then s[0]\n    else if s[0] <= seq_min(s[1..]) then \n        assert forall x :: x in s[1..] ==> seq_min(s[1..]) <= x;\n        assert forall x :: x in s ==> (x == s[0] || x in s[1..]);\n        assert forall x :: x in s ==> s[0] <= x;\n        s[0]\n    else \n        assert seq_min(s[1..]) < s[0];\n        assert seq_min(s[1..]) in s[1..];\n        assert forall x :: x in s[1..] ==> seq_min(s[1..]) <= x;\n        assert forall x :: x in s ==> (x == s[0] || x in s[1..]);\n        assert forall x :: x in s ==> seq_min(s[1..]) <= x;\n        seq_min(s[1..])\n}\n\nfunction seq_max(s: seq<int>): int\n    requires |s| > 0\n    ensures seq_max(s) in s\n    ensures forall x :: x in s ==> seq_max(s) >= x\n    decreases |s|\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= seq_max(s[1..]) then \n        assert forall x :: x in s[1..] ==> seq_max(s[1..]) >= x;\n        assert forall x :: x in s ==> (x == s[0] || x in s[1..]);\n        assert forall x :: x in s ==> s[0] >= x;\n        s[0]\n    else \n        assert seq_max(s[1..]) > s[0];\n        assert seq_max(s[1..]) in s[1..];\n        assert forall x :: x in s[1..] ==> seq_max(s[1..]) >= x;\n        assert forall x :: x in s ==> (x == s[0] || x in s[1..]);\n        assert forall x :: x in s ==> seq_max(s[1..]) >= x;\n        seq_max(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(grid: seq<seq<int>>) returns (result: int)\n    requires ValidGrid(grid)\n    ensures (\n        var row_mins := seq(|grid|, i requires 0 <= i < |grid| => seq_min(grid[i]));\n        result == seq_max(row_mins)\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_208", "vc-description": "Given coordinates of two trees that are vertices of a square (with sides parallel to coordinate axes),\nfind the coordinates of the other two vertices. Valid cases include: same x-coordinate (vertical edge),\nsame y-coordinate (horizontal edge), or diagonal vertices where |x\u2082-x\u2081| = |y\u2082-y\u2081|.\nReturn -1 if no valid square can be formed.", "vc-preamble": "predicate ValidInput(x1: int, y1: int, x2: int, y2: int)\n{\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 && -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\npredicate IsInvalidCase(x1: int, y1: int, x2: int, y2: int)\n{\n    x1 != x2 && y1 != y2 && abs(x1 - x2) != abs(y1 - y2)\n}\n\npredicate IsDiagonalCase(x1: int, y1: int, x2: int, y2: int)\n{\n    x1 != x2 && y1 != y2 && abs(x1 - x2) == abs(y1 - y2)\n}\n\npredicate IsVerticalEdgeCase(x1: int, y1: int, x2: int, y2: int)\n{\n    x1 == x2\n}\n\npredicate IsHorizontalEdgeCase(x1: int, y1: int, x2: int, y2: int)\n{\n    x1 != x2 && y1 == y2\n}\n\nfunction ExpectedDiagonalResult(x1: int, y1: int, x2: int, y2: int): seq<int>\n{\n    [x1, y2, x2, y1]\n}\n\nfunction ExpectedVerticalResult(x1: int, y1: int, x2: int, y2: int): seq<int>\n{\n    [x1 + abs(y2 - y1), y1, x1 + abs(y2 - y1), y2]\n}\n\nfunction ExpectedHorizontalResult(x1: int, y1: int, x2: int, y2: int): seq<int>\n{\n    [x1, y1 + abs(x2 - x1), x2, y1 + abs(x2 - x1)]\n}\n\npredicate ValidOutput(result: seq<int>)\n{\n    (|result| == 1 && result[0] == -1) ||\n    (|result| == 4 && (forall i :: 0 <= i < 4 ==> -1000 <= result[i] <= 1000))\n}", "vc-helpers": "", "vc-spec": "method solve(x1: int, y1: int, x2: int, y2: int) returns (result: seq<int>)\n    requires ValidInput(x1, y1, x2, y2)\n    ensures ValidOutput(result)\n    ensures IsInvalidCase(x1, y1, x2, y2) ==> result == [-1]\n    ensures IsDiagonalCase(x1, y1, x2, y2) ==> result == ExpectedDiagonalResult(x1, y1, x2, y2)\n    ensures IsVerticalEdgeCase(x1, y1, x2, y2) ==> result == ExpectedVerticalResult(x1, y1, x2, y2)\n    ensures IsHorizontalEdgeCase(x1, y1, x2, y2) ==> result == ExpectedHorizontalResult(x1, y1, x2, y2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2080", "vc-description": "Given q queries with numbers n_i, find the maximum number of edges in a simple undirected graph\nwith n_i vertices where at least half of the edges are bridges. A bridge is an edge whose\nremoval increases the number of connected components in the graph.", "vc-preamble": "predicate ValidInput(n: int) {\n  1 <= n <= 2000000000\n}\n\npredicate ValidOutput(n: int, result: int) {\n  result >= 0 &&\n  result >= n - 1 &&\n  result <= n * (n - 1) / 2\n}\n\nfunction ComputeExpectedResult(n: int): int\n  requires ValidInput(n)\n{\n  var quad_solv_numerator := isqrt(8*n + 1) - 1;\n  var x := quad_solv_numerator / 2;\n  var y := x + 1;\n  var xed := x * (x - 1) / 2 + n - x;\n  var ybr := n - y;\n  var yed := 2 * ybr;\n  if xed > yed then xed else yed\n}\n\nfunction isqrt(n: int): int\n  requires n >= 0\n  ensures isqrt(n) >= 0\n  ensures isqrt(n) * isqrt(n) <= n\n  ensures (isqrt(n) + 1) * (isqrt(n) + 1) > n\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else if n <= 3 then 1\n  else\n    var guess := n / 2;\n    var low := 0;\n    var high := guess + 1;\n    isqrt_helper(n, low, high)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n  requires ValidInput(n)\n  ensures ValidOutput(n, result)\n  ensures result == ComputeExpectedResult(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2086", "vc-description": "Given n timezones where day has n hours, find the optimal start time for a 1-hour contest\nto maximize participants. When it's hour 1 in timezone 1, it's hour i in timezone i.\nPeople participate only if contest starts between hours s and f-1 in their local time.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>, s: int, f: int)\n{\n  n >= 2 && |a| == n && s >= 1 && f > s && f <= n &&\n  forall i :: 0 <= i < n ==> a[i] >= 1\n}\n\nfunction participantCount(a: seq<int>, s: int, f: int, n: int, start: int): int\n  requires |a| == n >= 1\n  requires s >= 1 && f > s && f <= n\n  requires 1 <= start <= n\n{\n  participantCountHelper(a, s, f, n, start, 0)\n}\n\nfunction participantCountHelper(a: seq<int>, s: int, f: int, n: int, start: int, i: int): int\n  requires |a| == n >= 1\n  requires s >= 1 && f > s && f <= n\n  requires 1 <= start <= n\n  requires 0 <= i <= n\n  decreases n - i\n{\n  if i >= n then 0\n  else\n    var localHour := (start + i - 1) % n + 1;\n    var contribution := if s <= localHour < f then a[i] else 0;\n    contribution + participantCountHelper(a, s, f, n, start, i + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>, s: int, f: int) returns (result: int)\n  requires ValidInput(n, a, s, f)\n  ensures 1 <= result <= n\n  ensures forall start :: 1 <= start <= n ==> \n    participantCount(a, s, f, n, result) >= participantCount(a, s, f, n, start)\n  ensures forall start :: 1 <= start <= n && \n    participantCount(a, s, f, n, start) == participantCount(a, s, f, n, result) \n    ==> result <= start", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2100", "vc-description": "Given n cupboards with left and right doors that can be open (1) or closed (0),\nfind the minimum number of operations to make all left doors have the same state\nand all right doors have the same state. Each operation changes one door's state.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := Split(input, '\\n');\n    |lines| >= 1 &&\n    IsValidNumber(lines[0]) &&\n    var n := StringToInt(lines[0]);\n    n >= 0 && n + 1 <= |lines| &&\n    forall i :: 1 <= i <= n && i < |lines| ==>\n        var parts := Split(lines[i], ' ');\n        |parts| >= 2 && IsValidDoorState(parts[0]) && IsValidDoorState(parts[1])\n}\n\npredicate ValidOutput(output: string)\n{\n    IsValidNumber(output)\n}\n\npredicate IsValidNumber(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate IsValidDoorState(s: string)\n{\n    s == \"0\" || s == \"1\"\n}\n\nfunction CalculateMinOperations(input: string): string\n    requires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var n := StringToInt(lines[0]);\n    if n == 0 then \"0\"\n    else\n        var leftZeros := CountLeftZeros(lines, 1, n);\n        var rightZeros := CountRightZeros(lines, 1, n);\n        var leftOps := if leftZeros < n - leftZeros then leftZeros else n - leftZeros;\n        var rightOps := if rightZeros < n - rightZeros then rightZeros else n - rightZeros;\n        IntToString(leftOps + rightOps)\n}", "vc-helpers": "", "vc-spec": "method Solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures ValidOutput(result)\n    ensures result == CalculateMinOperations(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2104", "vc-description": "Given integers l and r where l < r, partition all integers from l to r (inclusive) \ninto exactly (r-l+1)/2 pairs such that each pair (i,j) has gcd(i,j) = 1. \nEach number must appear in exactly one pair.", "vc-preamble": "predicate ValidInput(l: int, r: int)\n{\n    l < r && (r - l) % 2 == 1\n}\n\nfunction gcd(a: int, b: int): int\n    requires a != 0 || b != 0\n    decreases if a >= 0 then a else -a\n{\n    if a == 0 then if b >= 0 then b else -b\n    else gcd(b % a, a)\n}\n\npredicate PairHasGcdOne(pair: string, l: int, r: int)\n{\n    exists i, j :: l <= i <= r && l <= j <= r && i != j &&\n        pair == int_to_string(i) + \" \" + int_to_string(j) &&\n        (i != 0 || j != 0) && gcd(i, j) == 1\n}\n\npredicate ValidSolution(result: seq<string>, l: int, r: int)\n{\n    |result| >= 1 &&\n    result[0] == \"YES\" &&\n    |result| == 1 + (r - l + 1) / 2 &&\n    (forall i :: 1 <= i < |result| ==> PairHasGcdOne(result[i], l, r))\n}", "vc-helpers": "", "vc-spec": "method solve(l: int, r: int) returns (result: seq<string>)\n    requires ValidInput(l, r)\n    ensures ValidSolution(result, l, r)\n    ensures |result| >= 1\n    ensures result[0] == \"YES\"\n    ensures |result| == 1 + (r - l + 1) / 2\n    ensures forall i :: 1 <= i < |result| ==> \n        (exists j :: l <= j <= r - 1 && j % 2 == l % 2 && \n         result[i] == int_to_string(j) + \" \" + int_to_string(j + 1))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2113", "vc-description": "Given a tree with n nodes, determine the maximum number of edges that can be added \nwhile maintaining the bipartite property and keeping the graph simple (no loops or multiple edges).\nSince any tree is bipartite, we can 2-color it into partitions of sizes a and b.\nA complete bipartite graph has a\u00d7b edges, and the tree has n-1 edges, so answer is a\u00d7b-(n-1).", "vc-preamble": "predicate IsConnectedTree(n: int, edges: seq<(int, int)>)\n{\n    n >= 1 && |edges| == n - 1 &&\n    (n == 1 ==> |edges| == 0) &&\n    (n > 1 ==> IsConnectedGraph(n, edges))\n}\n\npredicate IsConnectedGraph(n: int, edges: seq<(int, int)>)\n{\n    n > 1 ==>\n    (forall node :: 2 <= node <= n ==> \n        CanReachNodeOne(node, edges, n))\n}\n\npredicate CanReachNodeOne(target: int, edges: seq<(int, int)>, maxDepth: int)\n    decreases maxDepth\n{\n    if maxDepth <= 0 then false\n    else if target == 1 then true\n    else \n        exists i :: 0 <= i < |edges| && \n            ((edges[i].0 == target && CanReachNodeOne(edges[i].1, edges, maxDepth - 1)) ||\n             (edges[i].1 == target && CanReachNodeOne(edges[i].0, edges, maxDepth - 1)))\n}\n\npredicate ValidTreeInput(n: int, edges: seq<(int, int)>)\n{\n    n >= 1 &&\n    |edges| == n - 1 &&\n    (forall i :: 0 <= i < |edges| ==> 1 <= edges[i].0 <= n && 1 <= edges[i].1 <= n) &&\n    (forall i :: 0 <= i < |edges| ==> edges[i].0 != edges[i].1) &&\n    (forall i, j :: 0 <= i < j < |edges| ==> \n        !(edges[i].0 == edges[j].0 && edges[i].1 == edges[j].1) && \n        !(edges[i].0 == edges[j].1 && edges[i].1 == edges[j].0)) &&\n    (n == 1 ==> |edges| == 0) &&\n    (n > 1 ==> (forall node {:trigger} :: 1 <= node <= n ==> \n        (exists i :: 0 <= i < |edges| && (edges[i].0 == node || edges[i].1 == node)))) &&\n    IsConnectedTree(n, edges)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, edges: seq<(int, int)>) returns (result: int)\n    requires ValidTreeInput(n, edges)\n    ensures result >= 0\n    ensures (exists blue, red :: \n        blue >= 0 && red >= 0 && blue + red == n && result == blue * red - (n - 1))\n    ensures n == 1 ==> result == 0\n    ensures n == 2 ==> result == 0\n    ensures n > 2 ==> (exists blue, red :: \n        blue > 0 && red > 0 && blue + red == n && result == blue * red - (n - 1))\n    ensures result <= (n * n) / 4 - (n - 1) + (if n % 2 == 0 then 0 else 1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2123", "vc-description": "Given n+1 pylons numbered 0 to n, where pylon 0 has height 0 and pylons 1 to n have heights h\u2081, h\u2082, ..., h\u2099.\nA player starts at pylon 0 with 0 energy and wants to reach pylon n by jumping from pylon k to pylon k+1.\nEach jump from pylon k to k+1 changes energy by (h\u2096 - h\u2096\u208a\u2081). Energy must remain non-negative at all times.\nThe player can pay $1 to increase any pylon's height by 1. Find the minimum cost to make the journey possible.", "vc-preamble": "predicate ValidInput(n: int, heights: seq<int>)\n{\n    n > 0 && |heights| == n\n}\n\nfunction MaxInSeq(s: seq<int>): int\n    requires |s| > 0\n    ensures MaxInSeq(s) in s\n    ensures forall i :: 0 <= i < |s| ==> s[i] <= MaxInSeq(s)\n{\n    if |s| == 1 then s[0]\n    else\n        var tailMax := MaxInSeq(s[1..]);\n        if s[0] >= tailMax then s[0] else tailMax\n}\n\npredicate ValidResult(n: int, heights: seq<int>, result: int)\n    requires ValidInput(n, heights)\n{\n    result == MaxInSeq(heights) &&\n    forall i :: 0 <= i < |heights| ==> heights[i] <= result &&\n    exists i :: 0 <= i < |heights| && heights[i] == result\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, heights: seq<int>) returns (result: int)\n    requires ValidInput(n, heights)\n    ensures ValidResult(n, heights, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2133", "vc-description": "Given a tree with vertices colored black (1) or white (0), find the minimum number of paint operations\nto make all vertices the same color. A paint(v) operation changes the color of all vertices u such that\nall vertices on the shortest path from v to u have the same color.", "vc-preamble": "predicate ValidTreeInput(input: string)\n{\n  var lines := SplitLines(input);\n  |lines| >= 2 &&\n  var n := ParseInt(lines[0]);\n  n >= 1 && n <= 200000 &&\n  |lines| == n + 1 &&\n  ValidColorLine(lines[1], n) &&\n  ValidEdgeLines(lines[2..], n) &&\n  var edges := seq(|lines| - 2, i requires 0 <= i < |lines| - 2 => \n    var edge := ParseIntSeq(lines[i + 2]);\n    (edge[0], edge[1])\n  );\n  IsValidTree(n, edges)\n}\n\npredicate ValidColorLine(line: string, n: int)\n{\n  var colors := ParseIntSeq(line);\n  |colors| == n &&\n  forall i :: 0 <= i < |colors| ==> colors[i] == 0 || colors[i] == 1\n}\n\npredicate ValidEdgeLines(lines: seq<string>, n: int)\n{\n  |lines| == n - 1 &&\n  forall i :: 0 <= i < |lines| ==> \n    var edge := ParseIntSeq(lines[i]);\n    |edge| == 2 && \n    1 <= edge[0] <= n && \n    1 <= edge[1] <= n && \n    edge[0] != edge[1]\n}\n\npredicate IsValidTree(n: int, edges: seq<(int, int)>)\n{\n  n >= 1 &&\n  |edges| == n - 1 &&\n  IsConnected(n, edges) &&\n  (forall e :: e in edges ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1) &&\n  NoDuplicateEdges(edges)\n}\n\npredicate IsConnected(n: int, edges: seq<(int, int)>)\n{\n  true\n}\n\npredicate NoDuplicateEdges(edges: seq<(int, int)>)\n{\n  forall i, j :: 0 <= i < j < |edges| ==> \n    edges[i] != edges[j] && \n    (edges[i].0, edges[i].1) != (edges[j].1, edges[j].0)\n}\n\npredicate ValidIntegerOutput(output: string)\n{\n  var trimmed := TrimWhitespace(output);\n  |trimmed| > 0 &&\n  forall c :: c in trimmed ==> '0' <= c <= '9'\n}\n\npredicate AllSameColor(colors: seq<int>)\n{\n  |colors| > 0 ==> forall i :: 0 <= i < |colors| ==> colors[i] == colors[0]\n}\n\nfunction ParseInput(input: string): (int, seq<int>, seq<(int, int)>)\n  requires ValidTreeInput(input)\n{\n  var lines := SplitLines(input);\n  var n := ParseInt(lines[0]);\n  var colors := ParseIntSeq(lines[1]);\n  var edges := seq(|lines| - 2, i requires 0 <= i < |lines| - 2 => \n    var edge := ParseIntSeq(lines[i + 2]);\n    (edge[0], edge[1])\n  );\n  (n, colors, edges)\n}\n\nfunction ParseOutput(output: string): int\n{\n  ParseInt(TrimWhitespace(output))\n}\n\nfunction ComputeMinPaintOps(n: int, colors: seq<int>, edges: seq<(int, int)>): int\n  requires n >= 1\n  requires |colors| == n\n  requires |edges| == n - 1\n{\n  if AllSameColor(colors) then 0\n  else\n    var components := BuildSameColorComponents(colors, edges);\n    var componentGraph := BuildComponentGraph(components, colors, edges);\n    (TreeDiameter(componentGraph) + 1) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n  requires |stdin_input| > 0\n  requires ValidTreeInput(stdin_input)\n  ensures |output| > 0\n  ensures ValidIntegerOutput(output)\n  ensures var result := ParseOutput(output);\n          result >= 0\n  ensures var (n, colors, edges) := ParseInput(stdin_input);\n          n >= 1 ==> var result := ParseOutput(output);\n                     result <= n\n  ensures var (n, colors, edges) := ParseInput(stdin_input);\n          AllSameColor(colors) ==> ParseOutput(output) == 0\n  ensures var (n, colors, edges) := ParseInput(stdin_input);\n          n == 1 ==> ParseOutput(output) == 0\n  ensures var (n, colors, edges) := ParseInput(stdin_input);\n          IsValidTree(n, edges) && n >= 1\n  ensures var (n, colors, edges) := ParseInput(stdin_input);\n          var result := ParseOutput(output);\n          result == ComputeMinPaintOps(n, colors, edges)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_216", "vc-description": "Given a sequence of integers, partition it into two subsequences such that\nevery element belongs to exactly one subsequence. Find the maximum possible\nvalue of B - C, where B is the sum of elements in the first subsequence\nand C is the sum of elements in the second subsequence.", "vc-preamble": "function sum_abs(arr: seq<int>, i: int): int\n    requires 0 <= i <= |arr|\n    decreases |arr| - i\n{\n    if i == |arr| then 0\n    else (if arr[i] >= 0 then arr[i] else -arr[i]) + sum_abs(arr, i + 1)\n}\n\npredicate ValidInput(n: int, arr: seq<int>)\n{\n    0 <= n == |arr|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, arr: seq<int>) returns (result: int)\n    requires ValidInput(n, arr)\n    ensures result == sum_abs(arr, 0)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2167", "vc-description": "Given an array of n integers, find the maximum number of elements that can be made equal\nafter performing any number of operations where each operation chooses two different elements\nand simultaneously increases one by 1 and decreases the other by 1.", "vc-preamble": "predicate ValidInput(n: int, arr: seq<int>)\n{\n  n >= 1 && |arr| == n\n}\n\nfunction sum_seq(s: seq<int>): int\n{\n  if |s| == 0 then 0\n  else s[0] + sum_seq(s[1..])\n}\n\npredicate CorrectResult(n: int, arr: seq<int>, result: int)\n  requires ValidInput(n, arr)\n{\n  (sum_seq(arr) % n == 0 ==> result == n) &&\n  (sum_seq(arr) % n != 0 ==> result == n - 1) &&\n  (result == n || result == n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, arr: seq<int>) returns (result: int)\n  requires ValidInput(n, arr)\n  ensures CorrectResult(n, arr, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2168", "vc-description": "Given n companies, each with employees having specific salaries, merge all companies into one. \nCompanies can only merge if their maximum salaries are equal. You can increase salaries in any \ncompany, but all employees in the same company must receive the same increase. Find the minimum \ntotal salary increase needed to enable merging all companies.", "vc-preamble": "predicate ValidCompanyInput(input: string)\n{\n    var lines := SplitLinesFunc(input);\n    |lines| >= 1 && \n    IsValidPositiveInt(lines[0]) &&\n    var n := ParseIntFunc(lines[0]);\n    n >= 1 && |lines| >= n + 1 &&\n    (forall i :: 1 <= i <= n ==> ValidCompanyLine(lines[i]))\n}\n\npredicate ValidCompanyLine(line: string)\n{\n    var parts := SplitSpacesFunc(line);\n    |parts| >= 1 && IsValidPositiveInt(parts[0]) &&\n    var m := ParseIntFunc(parts[0]);\n    m >= 1 && |parts| == m + 1 &&\n    (forall j :: 1 <= j <= m ==> IsValidPositiveInt(parts[j]))\n}\n\npredicate IsValidPositiveInt(s: string)\n{\n    |s| >= 1 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction ParseCompanies(input: string): seq<seq<int>>\n    requires ValidCompanyInput(input)\n{\n    var lines := SplitLinesFunc(input);\n    var n := ParseIntFunc(lines[0]);\n    seq(n, i requires 0 <= i < n => \n        var parts := SplitSpacesFunc(lines[i + 1]);\n        var m := ParseIntFunc(parts[0]);\n        seq(m, j requires 0 <= j < m => ParseIntFunc(parts[j + 1]))\n    )\n}\n\nfunction CalculateMinimumIncrease(companies: seq<seq<int>>): int\n    requires |companies| >= 1\n    requires forall i :: 0 <= i < |companies| ==> |companies[i]| >= 1\n{\n    var globalMax := GlobalMaxSalary(companies);\n    SumOverCompanies(companies, globalMax)\n}\n\nfunction GlobalMaxSalary(companies: seq<seq<int>>): int\n    requires |companies| >= 1\n    requires forall i :: 0 <= i < |companies| ==> |companies[i]| >= 1\n{\n    MaxInSeqOfSeq(seq(|companies|, i requires 0 <= i < |companies| => MaxInSeqFunc(companies[i])))\n}\n\nfunction SumOverCompanies(companies: seq<seq<int>>, globalMax: int): int\n    requires |companies| >= 1\n    requires forall i :: 0 <= i < |companies| ==> |companies[i]| >= 1\n{\n    if |companies| == 1 then\n        var companyMax := MaxInSeqFunc(companies[0]);\n        var increasePerEmployee := globalMax - companyMax;\n        increasePerEmployee * |companies[0]|\n    else\n        var companyMax := MaxInSeqFunc(companies[0]);\n        var increasePerEmployee := globalMax - companyMax;\n        increasePerEmployee * |companies[0]| + SumOverCompanies(companies[1..], globalMax)\n}\n\nfunction MaxInSeqFunc(s: seq<int>): int\n    requires |s| > 0\n{\n    MaxInSeq(s)\n}\n\nfunction MaxInSeq(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= MaxInSeq(s[1..]) then s[0]\n    else MaxInSeq(s[1..])\n}\n\nfunction MaxInSeqOfSeq(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= MaxInSeqOfSeq(s[1..]) then s[0]\n    else MaxInSeqOfSeq(s[1..])\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n{\n    []\n}\n\nfunction SplitSpacesFunc(s: string): seq<string>\n{\n    []\n}\n\nfunction ParseIntFunc(s: string): int\n    requires IsValidPositiveInt(s)\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: int)\n    requires |input| > 0\n    requires ValidCompanyInput(input)\n    ensures result >= 0\n    ensures result == CalculateMinimumIncrease(ParseCompanies(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_217", "vc-description": "A bus travels back and forth between points x=0 and x=a, making k total journeys.\nThe bus has fuel capacity b and consumes 1 unit per distance unit. There's a gas station at x=f.\nFind minimum refuels needed to complete k journeys, or return -1 if impossible.", "vc-preamble": "predicate ValidInput(a: int, b: int, f: int, k: int) {\n  a > 0 && b > 0 && f > 0 && k > 0 && f < a\n}\n\npredicate ImpossibleConditions(a: int, b: int, f: int, k: int) {\n  b < f ||                                    \n  b < a - f ||                               \n  (k > 1 && b < 2 * a - f) ||               \n  (k == 1 && b < a && b < f)                \n}\n\npredicate FeasibilityConditions(a: int, b: int, f: int, k: int) {\n  b >= f &&                                  \n  b >= a - f &&                             \n  (k <= 1 || b >= 2 * a - f) &&            \n  (k == 1 ==> (b >= a || b >= f))          \n}\n\npredicate SingleJourneyResult(a: int, b: int, f: int, k: int, result: int) {\n  k == 1 && result >= 0 ==> (\n    (b >= a && result == 0) ||                \n    (b < a && b >= f && result == 1)          \n  )\n}\n\npredicate MultiJourneyFeasibility(a: int, b: int, f: int, k: int, result: int) {\n  k > 1 && result >= 0 ==> (\n    b >= f && b >= a - f && b >= 2 * a - f    \n  )\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, f: int, k: int) returns (result: int)\n  requires ValidInput(a, b, f, k)\n  ensures result >= -1\n  ensures result == -1 <==> ImpossibleConditions(a, b, f, k)\n  ensures result >= 0 ==> result <= k\n  ensures result >= 0 ==> FeasibilityConditions(a, b, f, k)\n  ensures SingleJourneyResult(a, b, f, k, result)\n  ensures MultiJourneyFeasibility(a, b, f, k, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2180", "vc-description": "Given an n \u00d7 n chessboard, find the maximum number of \"Coders\" that can be placed\nsuch that none attacks another. A Coder at position (x, y) can attack positions\n(x\u00b11, y) and (x, y\u00b11) (horizontally and vertically adjacent squares).\nOutput the maximum count and a valid placement configuration using checkerboard pattern.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction MaxCoders(n: int): int\n    requires n >= 1\n{\n    n * n / 2 + n * n % 2\n}\n\npredicate ValidOutputFormat(result: seq<string>, n: int) \n    requires n >= 1\n{\n    |result| == n + 1 &&\n    result[0] == IntToString(MaxCoders(n)) &&\n    (forall i :: 1 <= i <= n ==> |result[i]| == n)\n}\n\npredicate ValidCheckerboardPlacement(result: seq<string>, n: int)\n    requires n >= 1\n    requires ValidOutputFormat(result, n)\n{\n    forall i :: 1 <= i <= n ==> forall j :: 0 <= j < n ==>\n        (result[i][j] == 'C' <==> \n            (if (i - 1) % 2 == 0 then j % 2 == 0 else j % 2 == 1))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<string>)\n    requires ValidInput(n)\n    ensures ValidOutputFormat(result, n)\n    ensures ValidCheckerboardPlacement(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2183", "vc-description": "Given three brothers numbered 1, 2, and 3, exactly two brothers arrived on time \nfor a meeting and one brother was late. Given the numbers of the two brothers who \narrived on time, determine the number of the brother who was late.", "vc-preamble": "predicate ValidBrotherNumbers(a: int, b: int)\n{\n  1 <= a <= 3 && 1 <= b <= 3 && a != b\n}\n\nfunction LateBrother(a: int, b: int): int\n  requires ValidBrotherNumbers(a, b)\n{\n  6 - a - b\n}\n\npredicate IsValidResult(a: int, b: int, result: int)\n{\n  ValidBrotherNumbers(a, b) ==> \n    (1 <= result <= 3 && result != a && result != b)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n  requires ValidBrotherNumbers(a, b)\n  ensures IsValidResult(a, b, result)\n  ensures result == LateBrother(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2187", "vc-description": "Given an array of integers, find the minimum number of operations to make it non-decreasing.\nIn each operation, select a contiguous non-decreasing subsegment and add 1 to all elements.\nThe solution sums violations where arr[i] > arr[i+1], as each violation requires (arr[i] - arr[i+1]) operations.", "vc-preamble": "predicate ValidInput(test_cases: seq<seq<int>>)\n{\n    forall i :: 0 <= i < |test_cases| ==> |test_cases[i]| >= 1\n}\n\nfunction SumDifferences(arr: seq<int>, start: int): int\n    requires 0 <= start <= |arr|\n    decreases |arr| - start\n{\n    if start >= |arr| - 1 then 0\n    else (if arr[start] > arr[start + 1] then arr[start] - arr[start + 1] else 0) + SumDifferences(arr, start + 1)\n}\n\npredicate CorrectResult(test_cases: seq<seq<int>>, results: seq<int>)\n{\n    |results| == |test_cases| &&\n    forall i :: 0 <= i < |test_cases| ==> results[i] == SumDifferences(test_cases[i], 0) &&\n    forall i :: 0 <= i < |results| ==> results[i] >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(test_cases: seq<seq<int>>) returns (results: seq<int>)\n    requires ValidInput(test_cases)\n    ensures CorrectResult(test_cases, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2195", "vc-description": "Given two non-negative integers x and y, find the minimum cost to make both equal to zero using these operations:\n1. Pay $a to change exactly one integer by \u00b11\n2. Pay $b to change both integers by \u00b11 in the same direction", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 1 &&\n    IsValidInteger(lines[0]) &&\n    var t := StringToInt(lines[0]);\n    t >= 0 &&\n    |lines| >= 1 + 2 * t &&\n    forall i :: 0 <= i < t ==> \n        (1 + 2*i + 1 < |lines| && |SplitWhitespace(lines[1 + 2*i])| >= 2 &&\n         1 + 2*i + 2 < |lines| && |SplitWhitespace(lines[1 + 2*i + 1])| >= 2 &&\n         IsValidInteger(SplitWhitespace(lines[1 + 2*i])[0]) &&\n         IsValidInteger(SplitWhitespace(lines[1 + 2*i])[1]) &&\n         IsValidInteger(SplitWhitespace(lines[1 + 2*i + 1])[0]) &&\n         IsValidInteger(SplitWhitespace(lines[1 + 2*i + 1])[1]) &&\n         StringToInt(SplitWhitespace(lines[1 + 2*i])[0]) >= 0 &&\n         StringToInt(SplitWhitespace(lines[1 + 2*i])[1]) >= 0 &&\n         StringToInt(SplitWhitespace(lines[1 + 2*i + 1])[0]) >= 1 &&\n         StringToInt(SplitWhitespace(lines[1 + 2*i + 1])[1]) >= 1)\n}\n\npredicate ValidOutput(output: string, input: string)\n{\n    var lines := SplitLines(input);\n    if |lines| == 0 then output == \"\"\n    else\n        var t := StringToInt(lines[0]);\n        var outputLines := if output == \"\" then [] else SplitLines(output);\n        |outputLines| == (if t == 0 then 0 else t) &&\n        forall i :: 0 <= i < |outputLines| ==> IsValidInteger(outputLines[i])\n}\n\npredicate CorrectComputation(input: string, output: string)\n{\n    var lines := SplitLines(input);\n    if |lines| == 0 then output == \"\"\n    else\n        var t := StringToInt(lines[0]);\n        var outputLines := if output == \"\" then [] else SplitLines(output);\n        |outputLines| == (if t == 0 then 0 else t) &&\n        forall i :: 0 <= i < t && 1 + 2*i + 1 < |lines| ==>\n            var xyLine := SplitWhitespace(lines[1 + 2*i]);\n            var abLine := SplitWhitespace(lines[1 + 2*i + 1]);\n            (|xyLine| >= 2 && |abLine| >= 2) ==>\n                var x := StringToInt(xyLine[0]);\n                var y := StringToInt(xyLine[1]);\n                var a := StringToInt(abLine[0]);\n                var b := StringToInt(abLine[1]);\n                var expectedResult := if b <= 2 * a then\n                    b * (if x <= y then x else y) + (if x >= y then x else y - if x <= y then x else y) * a\n                else\n                    a * (x + y);\n                i < |outputLines| && StringToInt(outputLines[i]) == expectedResult\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 &&\n    (s[0] == '-' ==> |s| > 1) &&\n    forall i :: (if s[0] == '-' then 1 else 0) <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction SplitLines(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var parts := SplitByChar(s, '\\n');\n        seq(|parts|, i requires 0 <= i < |parts| => parts[i])\n}\n\nfunction SplitWhitespace(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var parts := SplitByChar(s, ' ');\n        seq(|parts|, i requires 0 <= i < |parts| => parts[i])\n}\n\nfunction SplitByChar(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then [\"\"]\n    else if s[0] == delimiter then\n        [\"\"] + SplitByChar(s[1..], delimiter)\n    else\n        var rest := SplitByChar(s[1..], delimiter);\n        if |rest| == 0 then [s]\n        else [(s[0..1] + rest[0])] + rest[1..]\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' && |s| > 1 then -StringToIntHelper(s[1..])\n    else StringToIntHelper(s)\n}\n\nfunction StringToIntHelper(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then\n        if '0' <= s[0] <= '9' then s[0] as int - '0' as int else 0\n    else\n        StringToIntHelper(s[..|s|-1]) * 10 + \n        (if '0' <= s[|s|-1] <= '9' then s[|s|-1] as int - '0' as int else 0)\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [((n % 10) as char + '0' as char) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures ValidOutput(output, input)\n    ensures CorrectComputation(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_22", "vc-description": "Check if a string is an \"s-palindrome\" - meaning it is symmetric when mirrored horizontally about its center.\nSome letters are symmetric: A, H, I, M, O, o, T, U, V, v, W, w, X, x, Y\nSome letters are mirror pairs: (p,q) and (b,d)\nAll other letters cannot form valid s-palindromes", "vc-preamble": "predicate is_s_palindrome(s: string)\n{\n    var pal := \"AHIMOoTUVvWwXxY\";\n\n    forall i :: 0 <= i < |s| ==> \n        var j := |s| - 1 - i;\n        if i >= j then true\n        else\n            if s[i] == s[j] then s[i] in pal\n            else (s[i] == 'p' && s[j] == 'q') || (s[i] == 'q' && s[j] == 'p') ||\n                 (s[i] == 'b' && s[j] == 'd') || (s[i] == 'd' && s[j] == 'b')\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| >= 1\n    ensures result == \"TAK\" || result == \"NIE\"\n    ensures result == \"TAK\" <==> is_s_palindrome(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2202", "vc-description": "Given a sequence A of N integers and a positive integer p, split A into exactly 2 contiguous,\nnon-overlapping parts (each containing at least 1 element) to maximize the sum of their scores.\nThe score of a part is the sum of its elements modulo p. Find the maximum possible sum of scores.", "vc-preamble": "predicate ValidInput(N: int, p: int, A: seq<int>)\n{\n    N >= 2 && p >= 2 && |A| == N && forall i :: 0 <= i < N ==> A[i] >= 1\n}\n\nfunction MaxSplitScore(A: seq<int>, p: int): int\n    requires |A| >= 2\n    requires p >= 2\n{\n    var scores := seq(|A| - 1, i requires 0 <= i < |A| - 1 => SplitScore(A, i + 1, p));\n    MaxSeq(scores)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, p: int, A: seq<int>) returns (result: int)\n    requires ValidInput(N, p, A)\n    ensures result >= 0\n    ensures result < 2 * p\n    ensures result == MaxSplitScore(A, p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2209", "vc-description": "Given n strings containing only 's' and 'h' characters, arrange them in optimal order\nand concatenate to form a single string. Find the maximum possible \"noise\" which is\nthe number of \"sh\" subsequences in the resulting concatenated string.", "vc-preamble": "predicate ValidInput(input: seq<string>)\n{\n    |input| >= 1 &&\n    (forall i :: 0 <= i < |input[0]| ==> '0' <= input[0][i] <= '9') &&\n    var n := StringToInt(input[0]);\n    n >= 1 && |input| >= n + 1 &&\n    forall i :: 1 <= i <= n ==> (|input[i]| > 0 &&\n        forall j :: 0 <= j < |input[i]| ==> input[i][j] == 's' || input[i][j] == 'h')\n}\n\nfunction StringToInt(s: string): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures StringToInt(s) >= 0\n{\n    if |s| == 0 then 0\n    else StringToInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction CountChar(s: string, c: char): int\n    ensures CountChar(s, c) >= 0\n    ensures CountChar(s, c) <= |s|\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + CountChar(s[1..], c)\n}\n\nfunction CountShSubsequences(s: string): int\n    ensures CountShSubsequences(s) >= 0\n{\n    CountShSubsequencesHelper(s, 0, 0)\n}\n\nfunction CountShSubsequencesHelper(s: string, index: int, s_count: int): int\n    requires 0 <= index <= |s|\n    requires s_count >= 0\n    ensures CountShSubsequencesHelper(s, index, s_count) >= 0\n    decreases |s| - index\n{\n    if index == |s| then 0\n    else if s[index] == 's' then\n        CountShSubsequencesHelper(s, index + 1, s_count + 1)\n    else if s[index] == 'h' then\n        s_count + CountShSubsequencesHelper(s, index + 1, s_count)\n    else\n        CountShSubsequencesHelper(s, index + 1, s_count)\n}\n\nfunction StringRatio(s: string): real\n    requires |s| > 0\n{\n    (CountChar(s, 's') as real) / (|s| as real)\n}\n\nfunction ConcatenateStrings(strings: seq<string>): string\n{\n    if |strings| == 0 then \"\"\n    else strings[0] + ConcatenateStrings(strings[1..])\n}\n\npredicate IsSortedByRatio(strings: seq<string>)\n    requires forall i :: 0 <= i < |strings| ==> |strings[i]| > 0\n{\n    forall i, j :: 0 <= i < j < |strings| ==> StringRatio(strings[i]) <= StringRatio(strings[j])\n}\n\npredicate IsValidArrangement(original: seq<string>, arranged: seq<string>)\n{\n    |arranged| == |original| && multiset(arranged) == multiset(original)\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<string>) returns (result: int)\n    requires ValidInput(input)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2219", "vc-description": "Given integers n and k, find the minimum number of steps to reduce n to 0 using operations:\n1. Decrease n by 1, or 2. Divide n by k (only if n is divisible by k)", "vc-preamble": "function minStepsToZero(n: nat, k: nat): nat\n    requires k >= 2\n    decreases n\n{\n    if n == 0 then 0\n    else if n % k == 0 then 1 + minStepsToZero(n / k, k)\n    else (n % k) + minStepsToZero(n - (n % k), k)\n}\n\npredicate validInput(input: string)\n{\n    |input| > 0 && \n    var lines := splitLinesFunc(input);\n    |lines| >= 1 &&\n    isValidNumber(lines[0]) &&\n    var t := stringToIntFunc(lines[0]);\n    t >= 1 && t <= 100 &&\n    |lines| >= t + 1 &&\n    forall i :: 1 <= i <= t ==> validTestCase(lines[i])\n}\n\npredicate validTestCase(line: string)\n{\n    var parts := splitSpacesFunc(line);\n    |parts| == 2 &&\n    isValidNumber(parts[0]) &&\n    isValidNumber(parts[1]) &&\n    var n := stringToIntFunc(parts[0]);\n    var k := stringToIntFunc(parts[1]);\n    n >= 1 && k >= 2\n}\n\npredicate isValidNumber(s: string)\n{\n    |s| >= 1 &&\n    (s == \"0\" || (s[0] != '0' && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')) &&\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction expectedOutput(input: string): string\n    requires validInput(input)\n{\n    var lines := splitLinesFunc(input);\n    var t := stringToIntFunc(lines[0]);\n    var results := seq(t, i requires 0 <= i < t => \n        var parts := splitSpacesFunc(lines[i+1]);\n        var n := stringToIntFunc(parts[0]);\n        var k := stringToIntFunc(parts[1]);\n        intToStringFunc(minStepsToZero(n, k))\n    );\n    joinLinesSeq(results)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires validInput(input)\n    ensures |result| >= 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] != '\\0'\n    ensures result == expectedOutput(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_222", "vc-description": "Given a positive integer n as a string, find the minimum number of digit deletions \nrequired to transform n into a perfect square, or return -1 if impossible.\nYou can delete any digit from n as long as the result remains a positive integer \nwithout leading zeros. A perfect square is an integer x = y\u00b2 for some positive integer y.", "vc-preamble": "function GenerateSquares(): seq<int>\n    ensures forall i :: 0 <= i < |GenerateSquares()| ==> GenerateSquares()[i] > 0\n{\n    GenerateSquaresHelper(1, 44721)\n}\n\nfunction IsSubsequence(pattern: string, text: string): bool\n{\n    IsSubsequenceHelper(pattern, text, 0, 0)\n}\n\nfunction IntToString(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"0\"\n    else IntToStringHelper(n)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires s[0] != '0' || |s| == 1\n    ensures result == -1 || result >= 0\n    ensures result == -1 ==> forall sq :: sq in GenerateSquares() ==> !IsSubsequence(IntToString(sq), s)\n    ensures result >= 0 ==> exists sq :: sq in GenerateSquares() && IsSubsequence(IntToString(sq), s) && result == |s| - |IntToString(sq)|\n    ensures result >= 0 ==> forall sq :: sq in GenerateSquares() && IsSubsequence(IntToString(sq), s) ==> |s| - |IntToString(sq)| >= result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2220", "vc-description": "Given n emotes with happiness values, use emotes m times total to maximize happiness.\nCannot use the same emote more than k consecutive times.\n\n// Assumes optimal strategy using highest and second highest values", "vc-preamble": "predicate ValidInput(n: int, m: int, k: int, emotes: seq<int>)\n{\n    n >= 2 && k >= 1 && m >= 1 && |emotes| == n &&\n    forall i :: 0 <= i < |emotes| ==> emotes[i] >= 1\n}\n\nfunction MaxHappiness(n: int, m: int, k: int, emotes: seq<int>): int\n    requires ValidInput(n, m, k, emotes)\n{\n    var k_plus_1 := k + 1;\n    var total := m / k_plus_1;\n    var remainder := m % k_plus_1;\n\n    var max_val := MaxValue(emotes);\n    var second_max_val := SecondMaxValue(emotes);\n    remainder * max_val + max_val * (total * k) + second_max_val * total\n}\n\nfunction MaxValue(s: seq<int>): int\n    requires |s| >= 1\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 1\n    ensures MaxValue(s) >= 1\n    ensures exists i :: 0 <= i < |s| && s[i] == MaxValue(s)\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= MaxValue(s[1..]) then s[0]\n    else MaxValue(s[1..])\n}\n\nfunction SecondMaxValue(s: seq<int>): int\n    requires |s| >= 2\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 1\n{\n    var max_val := MaxValue(s);\n    var filtered := FilterOut(s, max_val, 1);\n    if |filtered| > 0 then MaxValue(filtered) else 1\n}\n\nfunction FilterOut(s: seq<int>, val: int, count: int): seq<int>\n    requires count >= 0\n    requires forall i :: 0 <= i < |s| ==> s[i] >= 1\n    ensures forall i :: 0 <= i < |FilterOut(s, val, count)| ==> FilterOut(s, val, count)[i] >= 1\n{\n    if |s| == 0 || count == 0 then s\n    else if s[0] == val then FilterOut(s[1..], val, count - 1)\n    else [s[0]] + FilterOut(s[1..], val, count)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int, emotes: seq<int>) returns (result: int)\n    requires ValidInput(n, m, k, emotes)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2238", "vc-description": "Given an odd integer n (3 \u2264 n \u2264 101), create an n\u00d7n matrix representing a crystal with a diamond pattern.\nUse 'D' for diamond cells and '*' for all other cells.\nThe diamond pattern forms a symmetric diamond shape where the top half starts with 1 'D' and increases by 2 'D's per row\nuntil the middle row has n 'D's, then the bottom half decreases symmetrically.\nAll 'D's in each row are centered with '*' characters filling remaining positions.\n\n// First half (including middle): rows 0 to magic\n\n// Second half: rows magic+1 to n-1", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 3 && n <= 101 && n % 2 == 1\n}\n\npredicate ValidResult(result: seq<string>, n: int)\n{\n    |result| == n &&\n    forall i :: 0 <= i < |result| ==> |result[i]| == n\n}\n\npredicate CorrectDiamondPattern(result: seq<string>, n: int)\n{\n    |result| == n ==> (\n    var magic := (n - 1) / 2;\n\n    (forall i :: 0 <= i <= magic && i < |result| ==> \n        var stars := magic - i;\n        var diamonds := n - 2 * stars;\n        result[i] == RepeatChar('*', stars) + RepeatChar('D', diamonds) + RepeatChar('*', stars)) &&\n\n    (forall i :: magic + 1 <= i < n && i < |result| ==> \n        var u := i - magic;\n        var stars := u;\n        var diamonds := n - 2 * stars;\n        result[i] == RepeatChar('*', stars) + RepeatChar('D', diamonds) + RepeatChar('*', stars))\n    )\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<string>)\n    requires ValidInput(n)\n    ensures ValidResult(result, n)\n    ensures CorrectDiamondPattern(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2241", "vc-description": "Given n notes where each note i has maximum playable volume a_i and required total volume b_i,\nfind piano volume x_i and guitar volume y_i such that 1 \u2264 x_i \u2264 a_i, 1 \u2264 y_i \u2264 a_i, and x_i + y_i = b_i.\nFor playable notes, add x_i \u00d7 y_i to total joy. For unplayable notes, subtract 1.\nReturn the maximum possible total joy.", "vc-preamble": "function sum_contributions(a: seq<int>, b: seq<int>): int\n    requires |a| == |b|\n{\n    if |a| == 0 then 0\n    else \n        (if b[0] > 1 && 2 * a[0] >= b[0] then\n            var x := b[0] / 2;\n            var y := b[0] - x;\n            x * y\n         else -1) + sum_contributions(a[1..], b[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>, b: seq<int>) returns (result: int)\n    requires |a| == |b|\n    ensures result == sum_contributions(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2252", "vc-description": "Given a permutation P of n pages and m queries, determine for each query whether a specific element \nremains in the same position after sorting a subsegment in ascending order. For each query with \nparameters (l, r, x): sort the subsegment P[l...r] in ascending order, check if the element at \nposition x remains unchanged. Each query is independent (permutation resets after each query).", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 2 && \n    var first_line := ParseIntegers(lines[0]);\n    |first_line| == 2 &&\n    var n := first_line[0];\n    var m := first_line[1];\n    n >= 1 && m >= 0 &&\n    |ParseIntegers(lines[1])| == n &&\n    IsValidPermutation(ParseIntegers(lines[1]), n) &&\n    |lines| == 2 + m &&\n    (forall i :: 2 <= i < |lines| ==> \n        var query := ParseIntegers(lines[i]);\n        |query| == 3 &&\n        var l := query[0];\n        var r := query[1];\n        var x := query[2];\n        1 <= l <= x <= r <= n)\n}\n\npredicate IsValidPermutation(p: seq<int>, n: int)\n{\n    |p| == n && \n    (forall i :: 0 <= i < |p| ==> 1 <= p[i] <= n) &&\n    (forall i, j :: 0 <= i < j < |p| ==> p[i] != p[j])\n}\n\npredicate ValidOutputFormat(output: string)\n{\n    var lines := SplitLines(output);\n    forall line :: line in lines ==> line == \"Yes\" || line == \"No\"\n}\n\npredicate OutputMatchesQueries(input: string, output: string)\n{\n    var input_lines := SplitLines(input);\n    var output_lines := SplitLines(output);\n    if |input_lines| < 2 then false\n    else\n        var first_line := ParseIntegers(input_lines[0]);\n        if |first_line| != 2 then false\n        else\n            var n := first_line[0];\n            var m := first_line[1];\n            |input_lines| == 2 + m &&\n            |output_lines| == m &&\n            var p := ParseIntegers(input_lines[1]);\n            forall i :: 0 <= i < m ==> \n                var query := ParseIntegers(input_lines[2 + i]);\n                var l := query[0];\n                var r := query[1]; \n                var x := query[2];\n                var px := p[x - 1];\n                var cnt := l + CountSmallerInRange(p, l - 1, r - 1, px);\n                output_lines[i] == (if cnt == x then \"Yes\" else \"No\")\n}\n\nfunction CountSmallerInRange(p: seq<int>, start: int, end: int, value: int): int\n    decreases if start <= end then end - start + 1 else 0\n{\n    if start > end then 0\n    else if start < 0 || start >= |p| then 0\n    else (if p[start] < value then 1 else 0) + CountSmallerInRange(p, start + 1, end, value)\n}\n\nfunction ParseIntegers(line: string): seq<int>\n{\n    []\n}\n\nfunction SplitLines(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var idx := FindNewline(s, 0);\n        if idx == -1 then [s]\n        else [s[0..idx]] + SplitLines(s[idx+1..])\n}\n\nfunction FindNewline(s: string, start: nat): int\n    requires start <= |s|\n    ensures FindNewline(s, start) == -1 || (start <= FindNewline(s, start) < |s|)\n    decreases |s| - start\n{\n    if start >= |s| then -1\n    else if s[start] == '\\n' then start\n    else FindNewline(s, start + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires '\\n' in stdin_input\n    requires ValidInputFormat(stdin_input)\n    ensures |result| > 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] in \"YesNo \\n\"\n    ensures result != \"\" ==> result[|result|-1] == '\\n'\n    ensures ValidOutputFormat(result)\n    ensures OutputMatchesQueries(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2256", "vc-description": "Given n students in positions 1 to n, with two rival students initially at positions a and b,\nfind the maximum distance between the rivals after performing at most x adjacent swaps.\nDistance between positions p and s is |p - s|.", "vc-preamble": "predicate ValidInput(n: int, x: int, a: int, b: int)\n{\n    2 <= n <= 100 && 0 <= x <= 100 && 1 <= a <= n && 1 <= b <= n && a != b\n}\n\nfunction MaxDistance(n: int, x: int, a: int, b: int): int\n    requires ValidInput(n, x, a, b)\n{\n    var initialDistance := if a >= b then a - b else b - a;\n    var maxPossibleDistance := initialDistance + x;\n    var maxLineDistance := n - 1;\n    if maxPossibleDistance <= maxLineDistance then maxPossibleDistance else maxLineDistance\n}\n\npredicate ValidResult(n: int, x: int, a: int, b: int, result: int)\n    requires ValidInput(n, x, a, b)\n{\n    result == MaxDistance(n, x, a, b) && 0 <= result <= n - 1\n}", "vc-helpers": "", "vc-spec": "method SolveRivalDistance(n: int, x: int, a: int, b: int) returns (result: int)\n    requires ValidInput(n, x, a, b)\n    ensures ValidResult(n, x, a, b, result)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_228", "vc-description": "Given n piles of stones (n even), Alice and Bob alternate turns with Alice first.\nEach turn, a player chooses n/2 nonempty piles and removes positive stones from each.\nA player loses when fewer than n/2 nonempty piles remain. Determine the winner.", "vc-preamble": "function minimum(s: seq<int>): int\n    requires |s| > 0\n    ensures forall i :: 0 <= i < |s| ==> minimum(s) <= s[i]\n    ensures exists i :: 0 <= i < |s| && s[i] == minimum(s)\n{\n    if |s| == 1 then s[0]\n    else if s[0] <= minimum(s[1..]) then s[0]\n    else minimum(s[1..])\n}\n\nfunction countOccurrences(s: seq<int>, val: int): int\n    ensures countOccurrences(s, val) >= 0\n    ensures countOccurrences(s, val) <= |s|\n{\n    if |s| == 0 then 0\n    else (if s[0] == val then 1 else 0) + countOccurrences(s[1..], val)\n}\n\npredicate ValidInput(n: int, piles: seq<int>)\n{\n    n >= 2 && n % 2 == 0 && |piles| == n && forall i :: 0 <= i < |piles| ==> piles[i] >= 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, piles: seq<int>) returns (result: string)\n    requires ValidInput(n, piles)\n    ensures result == \"Alice\" || result == \"Bob\"\n    ensures |piles| > 0 ==> \n        (var minVal := minimum(piles);\n         var count := countOccurrences(piles, minVal);\n         result == (if count > n / 2 then \"Bob\" else \"Alice\"))\n    ensures |piles| == 0 ==> result == \"Alice\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2282", "vc-description": "Given n movement commands ('L' for left, 'R' for right), determine how many\ndifferent final positions are possible when any subset of commands may be ignored.\nThe answer is always n + 1, representing all positions from minimum to maximum.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && exists i :: 0 <= i < |input| && input[i] == '\\n'\n}\n\npredicate ValidCommandInput(input: string)\n{\n    var lines := split(input, '\\n');\n    |lines| >= 2 && lines[0] != \"\" && isValidInteger(lines[0])\n}\n\nfunction ExtractN(input: string): int\n    requires ValidCommandInput(input)\n{\n    var lines := split(input, '\\n');\n    parseInteger(lines[0])\n}\n\npredicate CorrectOutput(input: string, result: string)\n{\n    ValidCommandInput(input) ==> \n        result == intToString(ExtractN(input) + 1) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures CorrectOutput(input, result)\n    ensures !ValidCommandInput(input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2293", "vc-description": "Given n stores and m days of shopping, determine if positive integer values can be assigned \nto stores such that Dora beats Swiper every day. Dora buys from some stores each day, \nSwiper from remaining stores. Dora wins if LCM(her purchases) > LCM(Swiper's purchases).", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n' &&\n    var lines := SplitByNewlines(input);\n    |lines| >= 2 && \n    var firstLineParts := SplitBySpaces(lines[0]);\n    |firstLineParts| >= 2 &&\n    var m := StringToInt(firstLineParts[0]);\n    var n := StringToInt(firstLineParts[1]);\n    m >= 1 && n >= 1 && m + 1 < |lines| &&\n    forall dayIdx :: 1 <= dayIdx <= m ==> \n        var dayLine := SplitBySpaces(lines[dayIdx]);\n        |dayLine| >= 1 &&\n        var s := StringToInt(dayLine[0]);\n        s >= 1 && s < n && s + 1 <= |dayLine| &&\n        forall storeIdx :: 1 <= storeIdx <= s ==> \n            var store := StringToInt(dayLine[storeIdx]);\n            1 <= store <= n\n}\n\nfunction ExtractDoraSet(input: string, dayIndex: int, n: int): set<int>\n    requires |input| > 0\n    requires dayIndex >= 0\n    requires n >= 1\n{\n    var lines := SplitByNewlines(input);\n    if dayIndex + 1 >= |lines| then {}\n    else\n        var dayLine := SplitBySpaces(lines[dayIndex + 1]);\n        if |dayLine| <= 1 then {}\n        else\n            var s := StringToInt(dayLine[0]);\n            if s + 1 > |dayLine| then {}\n            else\n                set storeIdx | 1 <= storeIdx <= s && storeIdx < |dayLine| :: StringToInt(dayLine[storeIdx])\n}\n\nfunction ExtractSwiperSet(input: string, dayIndex: int, n: int): set<int>\n    requires |input| > 0\n    requires dayIndex >= 0\n    requires n >= 1\n{\n    var allStores := set i {:trigger} | 1 <= i <= n :: i;\n    var doraSet := ExtractDoraSet(input, dayIndex, n);\n    allStores - doraSet\n}\n\npredicate SolutionExists(input: string)\n    requires ValidInput(input)\n{\n    var lines := SplitByNewlines(input);\n    var firstLineParts := SplitBySpaces(lines[0]);\n    var m := StringToInt(firstLineParts[0]);\n    var n := StringToInt(firstLineParts[1]);\n    forall i, j :: 0 <= i < m && 0 <= j < m ==> \n        !(ExtractDoraSet(input, i, n) <= ExtractSwiperSet(input, j, n))\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == \"possible\" || result == \"impossible\"\n    ensures result == \"possible\" <==> SolutionExists(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2297", "vc-description": "Given an array where element a[i] = i * (-1)^i (so a[1] = -1, a[2] = 2, a[3] = -3, etc.),\nanswer queries asking for the sum of elements from index l to r inclusive.", "vc-preamble": "predicate ValidQuery(query: (int, int))\n{\n    query.0 >= 1 && query.0 <= query.1\n}\n\npredicate ValidInput(queries: seq<(int, int)>)\n{\n    forall i :: 0 <= i < |queries| ==> ValidQuery(queries[i])\n}\n\nfunction ArrayElement(i: int): int\n    requires i >= 1\n{\n    i * (if i % 2 == 1 then -1 else 1)\n}\n\nfunction RangeSum(l: int, r: int): int\n    requires l >= 1\n    decreases r - l + 1\n{\n    if l > r then 0 else ArrayElement(l) + RangeSum(l + 1, r)\n}\n\nfunction PrefixSum(k: int): int\n{\n    if k % 2 == 0 then k / 2 else -(k + 1) / 2\n}\n\npredicate CorrectResult(queries: seq<(int, int)>, results: seq<int>)\n    requires ValidInput(queries)\n{\n    |results| == |queries| &&\n    forall i :: 0 <= i < |queries| ==> results[i] == PrefixSum(queries[i].1) - PrefixSum(queries[i].0 - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<(int, int)>) returns (results: seq<int>)\n    requires ValidInput(queries)\n    ensures CorrectResult(queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2308", "vc-description": "Given two binary strings x and y representing integers f(x) and f(y), find the non-negative integer k \nthat minimizes the lexicographic value of rev_k, where s_k = f(x) + f(y) \u00d7 2^k and rev_k is the \nbinary representation of s_k written in reverse order.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 1 && \n    IsValidNumber(lines[0]) &&\n    (var T := StringToInt(lines[0]);\n     T >= 0 && |lines| >= 2 * T + 1 &&\n     (forall i :: 1 <= i < 2 * T + 1 ==> i < |lines| && IsBinaryString(lines[i]) && ContainsOne(lines[i])))\n}\n\npredicate ValidOutput(output: string, input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 1 ==>\n    var T := StringToInt(lines[0]);\n    var outputLines := if output == \"\" then [] else SplitLines(output);\n    |outputLines| == T &&\n    (forall i :: 0 <= i < T ==> IsValidNumber(outputLines[i]))\n}\n\npredicate CorrectComputation(output: string, input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 1 ==>\n    var T := StringToInt(lines[0]);\n    var outputLines := if output == \"\" then [] else SplitLines(output);\n    |outputLines| == T &&\n    (forall i :: 0 <= i < T && 1 + 2*i < |lines| && 2 + 2*i < |lines| ==> \n        var x := lines[1 + 2*i];\n        var y := lines[2 + 2*i];\n        var revX := Reverse(x);\n        var revY := Reverse(y);\n        var start := IndexOf(revY, '1');\n        start >= 0 &&\n        var offset := IndexOfFrom(revX, '1', start);\n        StringToInt(outputLines[i]) == offset)\n}\n\npredicate IsBinaryString(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1')\n}\n\npredicate ContainsOne(s: string)\n{\n    exists i :: 0 <= i < |s| && s[i] == '1'\n}\n\npredicate IsValidNumber(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires input[|input|-1] == '\\n'\n    requires ValidInput(input)\n    ensures ValidOutput(output, input)\n    ensures |output| > 0 ==> output[|output|-1] != '\\n'\n    ensures CorrectComputation(output, input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_231", "vc-description": "Vasya needs to drive to house number a on a street with n houses (n is even).\nOdd-numbered houses are on one side from beginning to end, even-numbered houses\nare on the other side from end to beginning. Distance from beginning to houses\n1 and n is 1 unit, and consecutive houses on same side are 1 unit apart.\nFind minimum time to reach house a from street beginning.", "vc-preamble": "predicate ValidInput(n: int, a: int)\n{\n  n > 0 && n % 2 == 0 && 1 <= a <= n\n}\n\nfunction DistanceToHouse(n: int, a: int): int\n  requires ValidInput(n, a)\n  ensures DistanceToHouse(n, a) > 0\n{\n  if a % 2 == 1 then\n    a / 2 + 1\n  else\n    (n - a) / 2 + 1\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_232", "vc-description": "Given an array of n integers representing lightsaber colors (each integer is between 1 and m),\ndetermine if there exists a contiguous subarray where each color i appears exactly k_i times.", "vc-preamble": "function count_occurrences(s: seq<nat>, value: nat): nat\n{\n    if |s| == 0 then 0\n    else if s[0] == value then 1 + count_occurrences(s[1..], value)\n    else count_occurrences(s[1..], value)\n}\n\nfunction sum_seq(s: seq<nat>): nat\n{\n    if |s| == 0 then 0\n    else s[0] + sum_seq(s[1..])\n}\n\npredicate subarray_matches_desired(subarray: seq<nat>, desired: seq<nat>, m: nat)\n    requires |desired| == m\n{\n    forall color :: 1 <= color <= m ==> count_occurrences(subarray, color) == desired[color-1]\n}\n\npredicate ValidInput(n: nat, m: nat, colors: seq<nat>, desired: seq<nat>)\n{\n    |colors| == n &&\n    |desired| == m &&\n    (forall i :: 0 <= i < |colors| ==> 1 <= colors[i] <= m) &&\n    (forall i :: 0 <= i < |desired| ==> desired[i] >= 0) &&\n    sum_seq(desired) <= n\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, m: nat, colors: seq<nat>, desired: seq<nat>) returns (result: string)\n    requires ValidInput(n, m, colors, desired)\n    ensures result == \"YES\" <==> exists i, j :: 0 <= i <= j < n && subarray_matches_desired(colors[i..j+1], desired, m)\n    ensures result == \"YES\" || result == \"NO\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2320", "vc-description": "Given two strings s and t of equal length, determine the minimum number of moves needed to transform s into t.\nIn each move, you can select any character from s and move it to either the beginning or end of the string.\nIf transformation is impossible, return -1.", "vc-preamble": "function CountCharacter(s: string, c: char): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + CountCharacter(s[1..], c)\n}\n\nfunction HasSameCharacterCounts(s: string, t: string): bool\n{\n    |s| == |t| && \n    (forall c :: CountCharacter(s, c) == CountCharacter(t, c))\n}\n\nfunction FindNextMatch(s: string, c: char, start: int): int\n    requires 0 <= start <= |s|\n    ensures start <= FindNextMatch(s, c, start) <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == c then start\n    else FindNextMatch(s, c, start + 1)\n}\n\nfunction CanMatchSubstring(s: string, t: string, i: int, j: int, k: int): bool\n    requires 0 <= i <= j < |t|\n    requires 0 <= k <= |s|\n    requires |s| == |t|\n    decreases j - i + 1, |s| - k\n{\n    if i > j then true\n    else if k >= |s| then false\n    else \n        var nextK := FindNextMatch(s, t[j], k);\n        if nextK >= |s| then false\n        else if i == j then true\n        else \n            assert nextK < |s|;\n            CanMatchSubstring(s, t, i, j-1, nextK+1)\n}\n\nfunction MaxPreservableLength(s: string, t: string, i: int, j: int, maxSoFar: int): int\n    requires 0 <= i <= |t|\n    requires i <= j <= |t|\n    requires |s| == |t|\n    requires maxSoFar >= 0\n    requires maxSoFar <= |s|\n    ensures MaxPreservableLength(s, t, i, j, maxSoFar) >= maxSoFar\n    ensures MaxPreservableLength(s, t, i, j, maxSoFar) <= |s|\n    decreases |t| - i, |t| - j\n{\n    if i >= |t| then maxSoFar\n    else if j >= |t| then MaxPreservableLength(s, t, i+1, i+1, maxSoFar)\n    else \n        var currentLen := j - i + 1;\n        var canMatch := CanMatchSubstring(s, t, i, j, 0);\n        var newMax := if canMatch && currentLen > maxSoFar then currentLen else maxSoFar;\n        MaxPreservableLength(s, t, i, j+1, newMax)\n}\n\nfunction MaxLongestSubsequence(s: string, t: string): int\n    requires |s| == |t|\n    requires |s| >= 0\n    ensures MaxLongestSubsequence(s, t) >= 0\n    ensures MaxLongestSubsequence(s, t) <= |s|\n{\n    if |s| == 0 then 0\n    else MaxPreservableLength(s, t, 0, 0, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, t: string) returns (result: int)\n    requires |s| == |t|\n    requires |s| >= 0\n    ensures result == -1 <==> !HasSameCharacterCounts(s, t)\n    ensures result >= -1\n    ensures result != -1 ==> 0 <= result <= |s|\n    ensures result != -1 ==> HasSameCharacterCounts(s, t)\n    ensures result != -1 ==> result == |s| - MaxLongestSubsequence(s, t)\n    ensures |s| == 0 ==> result == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2321", "vc-description": "Given a string of '>' and '<' characters, determine the minimum number of characters \nto remove so that the remaining string can be reduced to exactly one character using \nthese operations: Choose '>': delete the character immediately to its right (if exists),\nChoose '<': delete the character immediately to its left (if exists).\nProcess multiple test cases where each test case consists of a string length and the string.", "vc-preamble": "predicate IsValidString(s: string)\n{\n    |s| > 0\n}\n\npredicate IsValidProblemString(s: string)\n{\n    forall i :: 0 <= i < |s| ==> s[i] == '>' || s[i] == '<'\n}\n\npredicate IsValidIntegerString(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction StringToInt(s: string): int\n    requires IsValidIntegerString(s)\n{\n    StringToIntHelper(s, |s|)\n}\n\nfunction StringToIntHelper(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n    requires forall i :: 0 <= i < pos ==> '0' <= s[i] <= '9'\n{\n    if pos == 0 then 0\n    else StringToIntHelper(s, pos - 1) * 10 + (s[pos - 1] as int - '0' as int)\n}\n\nfunction MinDeletionsNeeded(s: string): int\n    requires IsValidProblemString(s)\n{\n    var firstGreater := FirstGreaterFromLeft(s);\n    var firstLessFromRight := FirstLessFromRight(s);\n    if firstGreater < firstLessFromRight then firstGreater else firstLessFromRight\n}\n\nfunction FirstGreaterFromLeft(s: string): int\n    requires IsValidProblemString(s)\n    ensures 0 <= FirstGreaterFromLeft(s) <= |s|\n{\n    FirstGreaterFromLeftHelper(s, 0)\n}\n\nfunction FirstGreaterFromLeftHelper(s: string, pos: int): int\n    requires IsValidProblemString(s)\n    requires 0 <= pos <= |s|\n    ensures 0 <= FirstGreaterFromLeftHelper(s, pos) <= |s|\n    decreases |s| - pos\n{\n    if pos >= |s| then |s|\n    else if s[pos] == '>' then pos\n    else FirstGreaterFromLeftHelper(s, pos + 1)\n}\n\nfunction FirstLessFromRight(s: string): int\n    requires IsValidProblemString(s)\n    ensures 0 <= FirstLessFromRight(s) <= |s|\n{\n    FirstLessFromRightHelper(s, |s| - 1)\n}\n\nfunction FirstLessFromRightHelper(s: string, pos: int): int\n    requires IsValidProblemString(s)\n    requires -1 <= pos < |s|\n    ensures 0 <= FirstLessFromRightHelper(s, pos) <= |s|\n    decreases pos + 1\n{\n    if pos < 0 then |s|\n    else if s[pos] == '<' then |s| - 1 - pos\n    else FirstLessFromRightHelper(s, pos - 1)\n}\n\nfunction min(a: int, b: int): int\n{\n    if a < b then a else b\n}", "vc-helpers": "", "vc-spec": "method solve(lines: seq<string>) returns (results: seq<int>)\n    requires |lines| > 0\n    requires forall i :: 0 <= i < |lines| ==> IsValidString(lines[i])\n    requires IsValidIntegerString(lines[0])\n    requires var t := StringToInt(lines[0]); |lines| >= 1 + 2 * t\n    requires forall i :: 0 <= i < StringToInt(lines[0]) ==> \n        IsValidIntegerString(lines[1 + 2*i]) && IsValidProblemString(lines[2 + 2*i])\n    ensures |results| == StringToInt(lines[0])\n    ensures forall r :: r in results ==> r >= 0\n    ensures forall i :: 0 <= i < |results| ==> \n        results[i] == MinDeletionsNeeded(lines[2 + 2*i])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2330", "vc-description": "Given n fridges with weights a\u2081, a\u2082, ..., a\u2099, create exactly m steel chains between fridges \nsuch that all fridges are \"private\". A chain connecting fridges u and v costs a\u1d64 + a\u1d65. \nA fridge is \"private\" if only its owner can unlock it. Find the minimum total cost to create \nexactly m chains making all fridges private, or determine if impossible.", "vc-preamble": "datatype Result = Impossible | Possible(cost: int, edges: seq<(int, int)>)\n\nfunction seq_sum(s: seq<int>): int {\n    if |s| == 0 then 0 else s[0] + seq_sum(s[1..])\n}\n\nfunction seq_sum_first(s: seq<int>, n: int): int\n    requires 0 <= n <= |s|\n{\n    if n == 0 then 0 else s[n-1] + seq_sum_first(s, n-1)\n}\n\nfunction min_index(weights: seq<int>): int\n    requires |weights| > 0\n    ensures 0 <= min_index(weights) < |weights|\n    ensures forall j :: 0 <= j < |weights| ==> weights[min_index(weights)] <= weights[j]\n{\n    min_index_helper(weights, 0, 1)\n}\n\nfunction min_index_helper(weights: seq<int>, current_min: int, next: int): int\n    requires |weights| > 0\n    requires 0 <= current_min < |weights|\n    requires 0 <= next <= |weights|\n    requires forall j :: 0 <= j < next ==> weights[current_min] <= weights[j]\n    ensures 0 <= min_index_helper(weights, current_min, next) < |weights|\n    ensures forall j :: 0 <= j < |weights| ==> weights[min_index_helper(weights, current_min, next)] <= weights[j]\n    decreases |weights| - next\n{\n    if next >= |weights| then current_min\n    else if weights[next] < weights[current_min] then min_index_helper(weights, next, next + 1)\n    else min_index_helper(weights, current_min, next + 1)\n}\n\nfunction min_index_excluding(weights: seq<int>, exclude: int): int\n    requires |weights| > 1\n    requires 0 <= exclude < |weights|\n    ensures 0 <= min_index_excluding(weights, exclude) < |weights|\n    ensures min_index_excluding(weights, exclude) != exclude\n    ensures forall j :: 0 <= j < |weights| && j != exclude ==> \n        weights[min_index_excluding(weights, exclude)] <= weights[j]\n{\n    var first_valid := if exclude == 0 then 1 else 0;\n    min_index_excluding_helper(weights, exclude, first_valid, 0)\n}\n\nfunction min_index_excluding_helper(weights: seq<int>, exclude: int, current_min: int, next: int): int\n    requires |weights| > 1\n    requires 0 <= exclude < |weights|\n    requires 0 <= current_min < |weights|\n    requires current_min != exclude\n    requires 0 <= next <= |weights|\n    requires forall j :: 0 <= j < next && j != exclude ==> weights[current_min] <= weights[j]\n    ensures 0 <= min_index_excluding_helper(weights, exclude, current_min, next) < |weights|\n    ensures min_index_excluding_helper(weights, exclude, current_min, next) != exclude\n    ensures forall j :: 0 <= j < |weights| && j != exclude ==> \n        weights[min_index_excluding_helper(weights, exclude, current_min, next)] <= weights[j]\n    decreases |weights| - next\n{\n    if next >= |weights| then current_min\n    else if next == exclude then min_index_excluding_helper(weights, exclude, current_min, next + 1)\n    else if weights[next] < weights[current_min] then min_index_excluding_helper(weights, exclude, next, next + 1)\n    else min_index_excluding_helper(weights, exclude, current_min, next + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(t: int, cases: seq<(int, int, seq<int>)>) returns (results: seq<Result>)\n    requires t >= 0\n    requires |cases| == t\n    requires forall i :: 0 <= i < t ==> \n        cases[i].0 >= 0 && cases[i].1 >= 0 && |cases[i].2| == cases[i].0\n    ensures |results| == t\n    ensures forall i :: 0 <= i < t ==> \n        var n := cases[i].0;\n        var m := cases[i].1;\n        (n <= 2 || m < n) ==> results[i] == Impossible\n    ensures forall i :: 0 <= i < t ==> \n        var n := cases[i].0;\n        var m := cases[i].1;\n        var weights := cases[i].2;\n        (n > 2 && m >= n && results[i].Possible?) ==> \n            |results[i].edges| == m &&\n            (forall j :: 0 <= j < |results[i].edges| ==> \n                1 <= results[i].edges[j].0 <= n && 1 <= results[i].edges[j].1 <= n &&\n                results[i].edges[j].0 != results[i].edges[j].1)\n    ensures forall i :: 0 <= i < t ==> \n        var n := cases[i].0;\n        var m := cases[i].1;\n        var weights := cases[i].2;\n        (n > 2 && m >= n && results[i].Possible?) ==> \n            var min1_idx := min_index(weights);\n            var min2_idx := min_index_excluding(weights, min1_idx);\n            results[i].cost == 2 * seq_sum(weights) + (m - n) * (weights[min1_idx] + weights[min2_idx])\n    ensures forall i :: 0 <= i < t ==> \n        var n := cases[i].0;\n        var m := cases[i].1;\n        (n > 2 && m >= n && results[i].Possible?) ==> \n            (forall j :: 0 <= j < n ==> \n                results[i].edges[j] == (j + 1, if j == n - 1 then 1 else j + 2)) &&\n            (forall j :: n <= j < m ==> \n                var min1_idx := min_index(cases[i].2);\n                var min2_idx := min_index_excluding(cases[i].2, min1_idx);\n                results[i].edges[j] == (min1_idx + 1, min2_idx + 1))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2340", "vc-description": "Navigate down a cliff from height h to ground using platforms and magic crystals.\nCharacter starts at platform height h, can pull levers to hide current platform and toggle platform at height x-1,\ncan fall safely at most 2 heights, and magic crystals can toggle any platform state (except height h).\nFind minimum number of crystals needed to reach ground safely.", "vc-preamble": "predicate ValidInput(h: int, n: int, platforms: seq<int>)\n{\n    h >= 1 && n >= 1 && |platforms| >= n && n > 0 && platforms[0] == h\n}\n\npredicate ValidCrystalCount(crystals: int, n: int)\n{\n    crystals >= 0 && crystals <= n - 1\n}\n\nfunction CountCrystalsNeeded(h: int, platforms: seq<int>): int\n  requires |platforms| >= 1\n  requires platforms[0] == h\n  requires h >= 1\n{\n    if |platforms| == 1 then 0\n    else CountCrystalsNeededUpTo(h, platforms + [0], |platforms| - 1)\n}\n\nfunction CountCrystalsNeededUpTo(h: int, arr: seq<int>, upTo: int): int\n  requires |arr| >= 1\n  requires 0 <= upTo < |arr|\n  requires arr[0] == h\n  requires h >= 1\n  decreases upTo\n{\n    if upTo == 0 then 0\n    else\n        var curPos := SimulatePositionUpTo(h, arr, upTo - 1);\n        var prevCrystals := CountCrystalsNeededUpTo(h, arr, upTo - 1);\n        if curPos == arr[upTo] then prevCrystals\n        else if upTo + 1 < |arr| && arr[upTo + 1] == arr[upTo] - 1 then prevCrystals\n        else prevCrystals + 1\n}\n\nfunction SimulatePositionUpTo(h: int, arr: seq<int>, upTo: int): int\n  requires |arr| >= 1\n  requires 0 <= upTo < |arr|\n  requires arr[0] == h\n  requires h >= 1\n  decreases upTo\n{\n    if upTo == 0 then h\n    else\n        var prevPos := SimulatePositionUpTo(h, arr, upTo - 1);\n        if prevPos == arr[upTo] then prevPos\n        else if upTo + 1 < |arr| && arr[upTo + 1] == arr[upTo] - 1 then arr[upTo] - 1\n        else prevPos\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n  requires |input| > 0\n  ensures |result| >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_235", "vc-description": "Given n candies, find the minimum k such that Vasya eats at least half of the original candies.\nDaily process: Vasya eats k candies in morning, Petya eats floor(remaining/10) in evening.\nContinue until no candies remain.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 1\n}\n\nfunction vasya_eats_with_strategy(n: int, k: int): int\n    requires n >= 0\n    requires k >= 1\n    decreases n\n{\n    if n <= 0 then 0\n    else\n        var cur := if n < k then n else k;\n        var remaining_after_vasya := n - cur;\n        var remaining_after_petya := remaining_after_vasya - remaining_after_vasya / 10;\n        cur + vasya_eats_with_strategy(remaining_after_petya, k)\n}\n\npredicate IsMinimalSolution(n: int, k: int)\n    requires ValidInput(n)\n    requires k >= 1\n{\n    vasya_eats_with_strategy(n, k) * 2 >= n &&\n    (k == 1 || vasya_eats_with_strategy(n, k - 1) * 2 < n)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures 1 <= result <= n\n    ensures IsMinimalSolution(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2350", "vc-description": "An infinite table is filled starting from cell (1,1) which contains integer 1.\nEach cell (x,y) contains the sum of the cell above it (x-1,y) and the cell to its left (x,y-1).\nFor boundary cases: cell(1,y) = y and cell(x,1) = x.\nGiven start coordinates (x\u2081, y\u2081) and end coordinates (x\u2082, y\u2082), find the number of\ndifferent possible sums when traversing from start to end cell, moving only down or right.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidTestCase(x1: int, y1: int, x2: int, y2: int)\n{\n    1 <= x1 <= x2 && 1 <= y1 <= y2\n}\n\nfunction CountDifferentSums(x1: int, y1: int, x2: int, y2: int): int\n    requires ValidTestCase(x1, y1, x2, y2)\n{\n    (x2 - x1) * (y2 - y1) + 1\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures |output| >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2353", "vc-description": "Given four integers representing sleep requirements and alarm timing,\nsimulate an alarm system where: first alarm rings after b minutes,\nif total sleep >= a then wake permanently, otherwise set alarm for c minutes later\nand spend d minutes falling asleep. If alarm rings while falling asleep (c <= d),\nreset and repeat. Find total time until permanent wake or -1 if never happens.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int)\n{\n    a >= 0 && b >= 0 && c >= 0 && d >= 0\n}\n\npredicate FirstAlarmSufficient(a: int, b: int)\n{\n    a <= b\n}\n\npredicate NeverWakes(a: int, b: int, c: int, d: int)\n{\n    a > b && c <= d\n}\n\npredicate EventuallyWakes(a: int, b: int, c: int, d: int)\n{\n    a > b && c > d\n}\n\nfunction CalculateWakeTime(a: int, b: int, c: int, d: int): int\n    requires ValidInput(a, b, c, d)\n    requires EventuallyWakes(a, b, c, d)\n{\n    var remaining := a - b;\n    var cycles := (remaining - 1) / (c - d) + 1;\n    b + c * cycles\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int) returns (result: int)\n    requires ValidInput(a, b, c, d)\n    ensures FirstAlarmSufficient(a, b) ==> result == b\n    ensures NeverWakes(a, b, c, d) ==> result == -1\n    ensures EventuallyWakes(a, b, c, d) ==> result == CalculateWakeTime(a, b, c, d)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2354", "vc-description": "Fill an n\u00d7n chessboard with numbers 1 to n\u00b2 using a specific pattern:\nPlace first \u2308n\u00b2/2\u2309 numbers in cells where (row + column) is even, filling left-to-right, top-to-bottom\nPlace remaining numbers in cells where (row + column) is odd, filling left-to-right, top-to-bottom\nFor given queries (xi, yi), return the number at each position", "vc-preamble": "predicate ValidInput(n: int, queries: seq<(int, int)>)\n{\n    n > 0 && \n    forall i :: 0 <= i < |queries| ==> 1 <= queries[i].0 <= n && 1 <= queries[i].1 <= n\n}\n\nfunction ChessboardValue(n: int, x: int, y: int): int\n    requires n > 0\n    requires 0 <= x < n && 0 <= y < n\n{\n    if (x + y) % 2 == 0 then\n        1 + (x / 2) * n + (x % 2) * ((n + 1) / 2) + y / 2\n    else\n        (n * n + 1) / 2 + 1 + (x / 2) * n + (x % 2) * (n / 2) + y / 2\n}\n\npredicate ValidResult(n: int, queries: seq<(int, int)>, results: seq<int>)\n    requires ValidInput(n, queries)\n{\n    |results| == |queries| &&\n    forall i :: 0 <= i < |queries| ==> \n        var x, y := queries[i].0 - 1, queries[i].1 - 1;\n        0 <= x < n && 0 <= y < n &&\n        results[i] == ChessboardValue(n, x, y)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, queries: seq<(int, int)>) returns (results: seq<int>)\n    requires ValidInput(n, queries)\n    ensures ValidResult(n, queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2362", "vc-description": "Given a tree with n vertices where each vertex i has value a_i, find the maximum length path \nwhere all values on the path share a common divisor greater than 1. The path length is the \nnumber of vertices on the simple path (inclusive). If no such path exists, return 0.", "vc-preamble": "predicate valid_input_format(stdin_input: string)\n{\n  |stdin_input| > 0 && \n  has_valid_tree_structure(stdin_input) &&\n  all_vertex_values_in_range(stdin_input) &&\n  vertex_count_in_range(stdin_input)\n}\n\npredicate stdin_input_sum_equals_n(stdin_input: string)\n  requires valid_input_format(stdin_input)\n{\n  sum_of_vertex_values(stdin_input) == get_vertex_count(stdin_input)\n}\n\npredicate has_common_prime_paths(stdin_input: string)\n  requires valid_input_format(stdin_input)\n{\n  exists_path_with_common_prime_factor(stdin_input)\n}\n\npredicate no_common_prime_paths(stdin_input: string)\n  requires valid_input_format(stdin_input)\n{\n  !has_common_prime_paths(stdin_input)\n}\n\nfunction max_common_prime_path_length(stdin_input: string): int\n  requires valid_input_format(stdin_input)\n  requires has_common_prime_paths(stdin_input)\n  ensures max_common_prime_path_length(stdin_input) >= 1\n{\n  1\n}\n\npredicate has_valid_tree_structure(stdin_input: string)\n{\n  true\n}\n\npredicate all_vertex_values_in_range(stdin_input: string)\n{\n  true\n}\n\npredicate vertex_count_in_range(stdin_input: string)\n{\n  true\n}\n\npredicate exists_path_with_common_prime_factor(stdin_input: string)\n  requires valid_input_format(stdin_input)\n{\n  true\n}\n\nfunction sum_of_vertex_values(stdin_input: string): int\n  requires valid_input_format(stdin_input)\n{\n  0\n}\n\nfunction get_vertex_count(stdin_input: string): int\n  requires valid_input_format(stdin_input)\n  ensures get_vertex_count(stdin_input) >= 1\n{\n  1\n}\n\nfunction int_to_string(x: int): string\n  requires x >= 0\n  ensures |int_to_string(x)| > 0\n{\n  if x == 0 then \"0\"\n  else if x < 10 then [char_of_digit(x)]\n  else int_to_string(x / 10) + [char_of_digit(x % 10)]\n}\n\nfunction char_of_digit(d: int): char\n  requires 0 <= d <= 9\n{\n  match d\n    case 0 => '0' case 1 => '1' case 2 => '2' case 3 => '3' case 4 => '4'\n    case 5 => '5' case 6 => '6' case 7 => '7' case 8 => '8' case 9 => '9'\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires valid_input_format(stdin_input)\n  requires stdin_input[|stdin_input|-1] == '\\n'\n  ensures |result| > 0\n  ensures result == \"0\" || (exists k: int :: k > 0 && result == int_to_string(k))\n  ensures stdin_input_sum_equals_n(stdin_input) ==> result == \"0\"\n  ensures !stdin_input_sum_equals_n(stdin_input) && no_common_prime_paths(stdin_input) ==> result == \"0\"\n  ensures !stdin_input_sum_equals_n(stdin_input) && has_common_prime_paths(stdin_input) ==> \n    (exists k: int :: k >= 1 && result == int_to_string(k) && k == max_common_prime_path_length(stdin_input))\n  ensures forall k: int :: k >= 0 && result == int_to_string(k) ==> k >= 0\n  ensures result == \"0\" ==> (stdin_input_sum_equals_n(stdin_input) || no_common_prime_paths(stdin_input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2375", "vc-description": "Two players Alice and Brown play a turn-based stone game starting with Alice.\nThere are two piles with X and Y stones. On each turn, a player chooses positive\ninteger i, takes 2i stones from one pile (requiring at least 2i stones),\ndiscards i stones, and places remaining i stones in the other pile.\nThe player who cannot make a valid move loses. Determine winner with optimal play.", "vc-preamble": "function Abs(x: int): int\n{\n  if x >= 0 then x else -x\n}\n\npredicate AliceWins(X: int, Y: int)\n{\n  Abs(X - Y) > 1\n}\n\npredicate BrownWins(X: int, Y: int)\n{\n  Abs(X - Y) <= 1\n}\n\npredicate ValidInput(X: int, Y: int)\n{\n  X >= 0 && Y >= 0\n}", "vc-helpers": "", "vc-spec": "method DetermineWinner(X: int, Y: int) returns (winner: string)\n  requires ValidInput(X, Y)\n  ensures winner == \"Alice\" || winner == \"Brown\"\n  ensures (winner == \"Alice\") <==> AliceWins(X, Y)\n  ensures (winner == \"Brown\") <==> BrownWins(X, Y)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2377", "vc-description": "Find the minimum number of attacks needed to deal at least H total damage to a monster\nusing N katanas. Each katana can be wielded (deals a_i damage, repeatable) or \nthrown (deals b_i damage, once only). Constraints: a_i <= b_i, all values positive.", "vc-preamble": "predicate ValidInput(N: int, H: int, A: seq<int>, B: seq<int>)\n{\n    |A| == N && |B| == N && N > 0 && H > 0 &&\n    (forall i :: 0 <= i < N ==> A[i] > 0 && B[i] > 0) &&\n    (forall i :: 0 <= i < N ==> A[i] <= B[i])\n}\n\nfunction sumSeq(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sumSeq(s[1..])\n}\n\npredicate MaxWieldExists(A: seq<int>, maxA: int)\n{\n    maxA in A && (forall i :: 0 <= i < |A| ==> A[i] <= maxA)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, H: int, A: seq<int>, B: seq<int>) returns (result: int)\n  requires ValidInput(N, H, A, B)\n  ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2379", "vc-description": "Given N days, choose exactly K days to work with constraints:\n- After working, cannot work for next C consecutive days  \n- Can only work on days where S[i] == 'o' (not 'x')\nFind all days that must be worked in every valid selection of K workdays", "vc-preamble": "predicate IsValidWorkSelection(N: int, K: int, C: int, S: string, selection: set<int>)\n    requires |S| == N\n{\n    |selection| == K &&\n    (forall day :: day in selection ==> 0 <= day < N && day < |S| && S[day] == 'o') &&\n    (forall day1, day2 :: day1 in selection && day2 in selection && day1 != day2 ==> \n        day1 < day2 - C || day2 < day1 - C)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, K: int, C: int, S: string) returns (result: seq<int>)\n    requires N > 0\n    requires K > 0\n    requires C >= 0\n    requires K <= N\n    requires |S| == N\n    requires forall i :: 0 <= i < |S| ==> S[i] == 'o' || S[i] == 'x'\n    requires |set i | 0 <= i < |S| && S[i] == 'o'| >= K\n    requires exists validSelection :: IsValidWorkSelection(N, K, C, S, validSelection)\n    ensures forall i :: 0 <= i < |result| ==> 1 <= result[i] <= N\n    ensures forall i :: 0 <= i < |result| ==> S[result[i] - 1] == 'o'\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]\n    ensures |result| <= K", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2386", "vc-description": "Given an integer sequence A of length N, find the minimum value of:\nabs(A\u2081 - (b+1)) + abs(A\u2082 - (b+2)) + ... + abs(A\u2099 - (b+N))\nwhere b is any integer we can choose.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 1 && |a| == n && forall i :: 0 <= i < |a| ==> a[i] >= 1\n}\n\nfunction Transform(a: seq<int>): seq<int>\n{\n    seq(|a|, i requires 0 <= i < |a| => a[i] - (i + 1))\n}\n\nfunction SumAbsDiffs(a: seq<int>, target: int): int\n    ensures SumAbsDiffs(a, target) >= 0\n{\n    if |a| == 0 then 0\n    else Abs(a[0] - target) + SumAbsDiffs(a[1..], target)\n}\n\nfunction MedianOf(a: seq<int>): int\n{\n    var sorted := SortedSeq(a);\n    if |sorted| == 0 then 0\n    else if |sorted| % 2 == 1 then\n        sorted[|sorted| / 2]\n    else if |sorted| == 2 then\n        RoundToInt((sorted[0] as real + sorted[1] as real) / 2.0)\n    else\n        RoundToInt((sorted[|sorted| / 2 - 1] as real + sorted[|sorted| / 2] as real) / 2.0)\n}\n\nfunction SortedSeq(a: seq<int>): seq<int>\n{\n    a\n}\n\nfunction Abs(x: int): int\n    ensures Abs(x) >= 0\n{\n    if x >= 0 then x else -x\n}\n\nfunction RoundToInt(x: real): int\n{\n    if x >= 0.0 then\n        ((x + 0.5).Floor) as int\n    else\n        ((x - 0.5).Floor) as int\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures result >= 0\n    ensures result == SumAbsDiffs(Transform(a), MedianOf(Transform(a)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2396", "vc-description": "Given m ships, each with a destination coordinate expressed as (a+b)/c where a, b, c are positive integers,\ndetermine how many ships (including itself) will have the same destination coordinate for each ship.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidOutput(result: seq<int>, input: string)\n{\n    |result| >= 0 &&\n    (forall i :: 0 <= i < |result| ==> result[i] >= 1) &&\n    (forall i :: 0 <= i < |result| ==> result[i] <= |result|)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: seq<int>)\n    requires ValidInput(input)\n    ensures ValidOutput(result, input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2406", "vc-description": "Simulate a landslide process on an array of strictly increasing heights.\nEach minute, for every position j where h_j + 2 \u2264 h_{j+1}, one unit slides \nfrom position j+1 to position j. All transfers happen simultaneously.\nThe process stops when no position satisfies the sliding condition.\nReturn the final stable heights.", "vc-preamble": "predicate ValidInput(n: int, heights: seq<int>)\n{\n    n > 0 && |heights| == n &&\n    (forall i :: 0 <= i < n ==> heights[i] >= 0) &&\n    (forall i :: 0 <= i < n-1 ==> heights[i] < heights[i+1])\n}\n\npredicate ValidOutput(n: int, result: seq<int>)\n{\n    |result| == n &&\n    (forall i :: 0 <= i < n ==> result[i] >= 0) &&\n    (forall i :: 0 <= i < n-1 ==> result[i] <= result[i+1]) &&\n    (forall i :: 0 <= i < n-1 ==> result[i+1] - result[i] <= 1)\n}\n\npredicate IsStable(result: seq<int>)\n{\n    forall i :: 0 <= i < |result|-1 ==> !(result[i] + 2 <= result[i+1])\n}\n\nfunction sum_seq(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum_seq(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, heights: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, heights)\n    ensures ValidOutput(n, result)\n    ensures sum_seq(result) == sum_seq(heights)\n    ensures IsStable(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2411", "vc-description": "Given n distinct points representing electric poles, count the number of pairs of wires that intersect.\nEvery pair of poles is connected by a wire (infinite straight line). If multiple poles lie on the same line,\nthey share a single wire. Return the number of intersecting wire pairs.", "vc-preamble": "predicate validInputFormat(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n' &&\n    var lines := splitLines(input);\n    |lines| >= 3 && |lines| <= 1001 &&\n    isValidFirstLine(lines[0]) &&\n    var n := parseFirstLineAsNat(lines[0]);\n    n >= 2 && n <= 1000 && |lines| == n + 1 &&\n    (forall i :: 1 <= i < |lines| ==> isValidCoordinateLine(lines[i]))\n}\n\npredicate isNonNegativeNumericString(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\npredicate validCoordinate(point: (int, int))\n{\n    var (x, y) := point;\n    -10000 <= x <= 10000 && -10000 <= y <= 10000\n}\n\nfunction extractN(input: string): nat\n  requires validInputFormat(input)\n{\n    var lines := splitLines(input);\n    parseFirstLineAsNat(lines[0])\n}\n\nfunction extractPoints(input: string): seq<(int, int)>\n  requires validInputFormat(input)\n  ensures var n := extractN(input);\n          |extractPoints(input)| == n\n{\n    [(0, 0), (1, 1)]\n}\n\nfunction countIntersectingLinePairs(points: seq<(int, int)>): nat\n  requires |points| >= 2\n  requires forall i, j :: 0 <= i < j < |points| ==> points[i] != points[j]\n  requires forall i :: 0 <= i < |points| ==> validCoordinate(points[i])\n  ensures countIntersectingLinePairs(points) >= 0\n{\n    var distinctLines := getDistinctLines(points);\n    var slopeGroups := groupLinesBySlope(distinctLines);\n    var totalLines := |distinctLines|;\n    (sumOverSlopeGroups(slopeGroups, totalLines)) / 2\n}\n\nfunction stringToInt(s: string): nat\n  requires isNonNegativeNumericString(s)\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires validInputFormat(stdin_input)\n  ensures |result| > 0\n  ensures isNonNegativeNumericString(result)\n  ensures var n := extractN(stdin_input);\n          var points := extractPoints(stdin_input);\n          |points| == n && n >= 2 && n <= 1000 &&\n          (forall i :: 0 <= i < |points| ==> validCoordinate(points[i])) &&\n          (forall i, j :: 0 <= i < j < |points| ==> points[i] != points[j]) &&\n          stringToInt(result) == countIntersectingLinePairs(points)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2422", "vc-description": "Given an integer n representing total windows in a building, find any valid combination\nof non-negative integers (a, b, c) representing 3-room, 5-room, and 7-room apartments\nsuch that 3a + 5b + 7c = n. Return -1 if no valid combination exists.", "vc-preamble": "predicate ValidSolution(n: int, a: int, b: int, c: int)\n{\n    a >= 0 && b >= 0 && c >= 0 && 3 * a + 5 * b + 7 * c == n\n}\n\npredicate ValidResult(n: int, result: seq<int>)\n{\n    (|result| == 1 && result[0] == -1) ||\n    (|result| == 3 && result[0] >= 0 && result[1] >= 0 && result[2] >= 0 && \n     ValidSolution(n, result[0], result[1], result[2]))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: seq<int>)\n    requires n >= 1\n    ensures ValidResult(n, result)\n    ensures n % 3 == 0 ==> |result| == 3 && result == [n / 3, 0, 0]\n    ensures n % 3 == 1 && n < 7 ==> |result| == 1 && result[0] == -1\n    ensures n % 3 == 1 && n >= 7 ==> |result| == 3 && result == [(n - 7) / 3, 0, 1]\n    ensures n % 3 == 2 && n < 5 ==> |result| == 1 && result[0] == -1\n    ensures n % 3 == 2 && n >= 5 ==> |result| == 3 && result == [(n - 5) / 3, 1, 0]", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2425", "vc-description": "Given a positive integer a, find the maximum possible value of gcd(a \u2295 b, a & b) \nwhere b is chosen from the range [1, a-1] and \u2295 denotes XOR and & denotes AND operations.", "vc-preamble": "function power2(k: int): int\n  requires k >= 0\n{\n  if k == 0 then 1 else 2 * power2(k - 1)\n}\n\npredicate ValidQuery(a: int)\n{\n  2 <= a <= power2(25) - 1\n}\n\npredicate ValidQueries(queries: seq<int>)\n{\n  forall i :: 0 <= i < |queries| ==> ValidQuery(queries[i])\n}\n\nfunction largestProperDivisor(n: int): int\n  requires n > 1\n  ensures largestProperDivisor(n) >= 1\n  ensures largestProperDivisor(n) < n\n  ensures n % largestProperDivisor(n) == 0\n  ensures forall d :: largestProperDivisor(n) < d < n ==> n % d != 0\n{\n  largestProperDivisorHelper(n, 2)\n}\n\nfunction largestProperDivisorHelper(n: int, d: int): int\n  requires n > 1\n  requires d >= 2\n  ensures largestProperDivisorHelper(n, d) >= 1\n  ensures largestProperDivisorHelper(n, d) < n\n  ensures n % largestProperDivisorHelper(n, d) == 0\n  ensures forall k :: largestProperDivisorHelper(n, d) < k < n ==> n % k != 0\n  decreases n - d\n{\n  if d * d > n then 1\n  else if n % d == 0 then \n    var quotient := n / d;\n    if quotient == d then quotient\n    else \n      var remainder_check := largestProperDivisorHelper(n, d + 1);\n      if quotient > remainder_check then quotient else remainder_check\n  else largestProperDivisorHelper(n, d + 1)\n}\n\npredicate ValidResults(queries: seq<int>, results: seq<int>)\n{\n  |results| == |queries| &&\n  forall i :: 0 <= i < |results| ==> results[i] >= 1 &&\n  forall i :: 0 <= i < |queries| ==> \n    (exists c :: 1 <= c <= 26 && power2(c) - 1 >= queries[i] && \n     (c == 1 || power2(c-1) - 1 < queries[i]) &&\n     (power2(c) - 1 > queries[i] ==> results[i] == power2(c) - 1) &&\n     (power2(c) - 1 == queries[i] ==> \n       results[i] == (if power2(c) - 1 <= 1 then 1 else largestProperDivisor(power2(c) - 1))))\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<int>) returns (results: seq<int>)\n  requires ValidQueries(queries)\n  ensures ValidResults(queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2431", "vc-description": "Given n castles with soldiers, two players alternate turns starting with White.\nEach turn a player attacks a castle using mixed (x damage), infantry (y damage, \nforbidden if previous attack on same castle was infantry), or cavalry (z damage,\nforbidden if previous attack on same castle was cavalry). Player making the last\nattack wins. Find number of White's winning first moves using Grundy number theory.\n\n// Implementation uses Grundy number theory", "vc-preamble": "datatype TestCase = TestCase(n: nat, x: nat, y: nat, z: nat, castles: seq<nat>)\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 && \n    var lines := split_by_newline(input);\n    |lines| >= 1 && \n    is_non_negative_integer_string(lines[0]) &&\n    var t := parse_integer(lines[0]);\n    1 <= t <= 1000 &&\n    |lines| == 1 + 2 * t &&\n    forall i :: 0 <= i < t ==>\n        var params_line := lines[1 + 2*i];\n        var castles_line := lines[2 + 2*i];\n        is_valid_test_case_params(params_line) &&\n        is_valid_castles_line(castles_line, get_n_from_params(params_line)) &&\n        get_n_from_params(params_line) <= 300000 &&\n        1 <= get_x_from_params(params_line) <= 5 &&\n        1 <= get_y_from_params(params_line) <= 5 &&\n        1 <= get_z_from_params(params_line) <= 5\n}\n\npredicate ValidOutput(input: string, output: string)\n    requires ValidInput(input)\n{\n    |output| > 0 &&\n    output[|output|-1] == '\\n' &&\n    count_lines(output) == get_test_count(input) &&\n    forall i :: 0 <= i < count_lines(output) ==> \n        var line := get_line(output, i);\n        line != \"\" ==> is_non_negative_integer_string(line)\n}\n\nfunction get_test_count(s: string): nat\n    requires ValidInput(s)\n    ensures 1 <= get_test_count(s) <= 1000\n{\n    parse_integer(split_by_newline(s)[0])\n}\n\nfunction get_test_case(s: string, i: nat): TestCase\n    requires ValidInput(s)\n    requires i < get_test_count(s)\n    ensures var tc := get_test_case(s, i);\n        1 <= tc.n <= 300000 &&\n        1 <= tc.x <= 5 && 1 <= tc.y <= 5 && 1 <= tc.z <= 5 &&\n        |tc.castles| == tc.n &&\n        forall j :: 0 <= j < |tc.castles| ==> tc.castles[j] >= 1\n{\n    var lines := split_by_newline(s);\n    var params_line := lines[1 + 2*i];\n    var castles_line := lines[2 + 2*i];\n    TestCase(\n        get_n_from_params(params_line),\n        get_x_from_params(params_line), \n        get_y_from_params(params_line),\n        get_z_from_params(params_line),\n        parse_castle_array(castles_line)\n    )\n}\n\nfunction count_winning_first_moves(tc: TestCase): nat\n    ensures count_winning_first_moves(tc) <= 3 * tc.n\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(stdin_input, result)\n    ensures forall i :: 0 <= i < get_test_count(stdin_input) ==>\n        var output_val := parse_integer(get_line(result, i));\n        var test_case := get_test_case(stdin_input, i);\n        output_val == count_winning_first_moves(test_case)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2434", "vc-description": "Given two integers n and m where m < n, determine if it's possible to select m vertices \nfrom a regular n-gon such that these m vertices form a regular m-gon with the same center.\nThe solution is \"YES\" if n is divisible by m, \"NO\" otherwise.", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n    var lines := SplitByNewline(input);\n    |lines| >= 1 && \n    IsValidInt(lines[0]) &&\n    var t := ParseInt(lines[0]);\n    t >= 0 && t + 1 <= |lines| &&\n    forall i :: 1 <= i <= t ==> IsValidTwoIntLine(lines[i])\n}\n\npredicate IsValidInt(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate IsValidTwoIntLine(s: string)\n{\n    var parts := SplitBySpace(s);\n    |parts| >= 2 && IsValidInt(parts[0]) && IsValidInt(parts[1])\n}\n\npredicate ValidOutputFormat(output: string, input: string)\n{\n    var inputLines := SplitByNewline(input);\n    if |inputLines| == 0 then output == \"\"\n    else\n        var t := ParseInt(inputLines[0]);\n        var outputLines := SplitByNewline(output);\n        |outputLines| == t &&\n        forall i :: 0 <= i < t ==> (outputLines[i] == \"YES\" || outputLines[i] == \"NO\")\n}\n\npredicate CorrectDivisibilityResults(input: string, output: string)\n{\n    var inputLines := SplitByNewline(input);\n    if |inputLines| == 0 then output == \"\"\n    else\n        var t := ParseInt(inputLines[0]);\n        var outputLines := SplitByNewline(output);\n        |outputLines| == t &&\n        forall i :: 0 <= i < t && i + 1 < |inputLines| ==> \n            var parts := SplitBySpace(inputLines[i + 1]);\n            |parts| >= 2 ==>\n                var x := ParseInt(parts[0]);\n                var y := ParseInt(parts[1]);\n                y != 0 ==>\n                    (outputLines[i] == \"YES\" <==> x % y == 0)\n}\n\nfunction SplitByNewline(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else if s[0] == '\\n' then [\"\"] + SplitByNewline(s[1..])\n    else \n        var rest := SplitByNewline(s[1..]);\n        if |rest| == 0 then [s]\n        else [s[0..1] + rest[0]] + rest[1..]\n}\n\nfunction SplitBySpace(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else if s[0] == ' ' then [\"\"] + SplitBySpace(s[1..])\n    else \n        var rest := SplitBySpace(s[1..]);\n        if |rest| == 0 then [s]\n        else [s[0..1] + rest[0]] + rest[1..]\n}\n\nfunction ParseInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then\n        if '0' <= s[0] <= '9' then s[0] as int - '0' as int else 0\n    else\n        if '0' <= s[0] <= '9' then\n            (s[0] as int - '0' as int) * Pow10(|s| - 1) + ParseInt(s[1..])\n        else 0\n}\n\nfunction Pow10(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 1 else 10 * Pow10(n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInputFormat(input)\n    ensures forall i :: 0 <= i < |output| ==> output[i] in \"YESNO\\n\"\n    ensures ValidOutputFormat(output, input)\n    ensures CorrectDivisibilityResults(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2435", "vc-description": "Given an array of n integers where initially a[x] = 1 and all other elements are 0,\ndetermine how many positions can contain the value 1 after performing m swap operations optimally.\nEach operation i allows swapping any two elements at positions c and d where l_i \u2264 c, d \u2264 r_i.", "vc-preamble": "predicate ValidInput(testCases: seq<(int, int, seq<(int, int)>)>)\n{\n    |testCases| >= 0 &&\n    forall i :: 0 <= i < |testCases| ==> \n        var (n, x, operations) := testCases[i];\n        n >= 1 && 1 <= x <= n && |operations| >= 0 &&\n        (forall j :: 0 <= j < |operations| ==> \n            var (l, r) := operations[j];\n            1 <= l <= r <= n)\n}\n\nfunction computeFinalBounds(x: int, operations: seq<(int, int)>): (int, int)\n    requires forall j :: 0 <= j < |operations| ==> \n        var (l, r) := operations[j];\n        l <= r\n{\n    computeFinalBoundsHelper(x, x, operations, 0)\n}\n\npredicate ValidResults(testCases: seq<(int, int, seq<(int, int)>)>, results: seq<int>)\n    requires ValidInput(testCases)\n{\n    |results| == |testCases| &&\n    forall i :: 0 <= i < |testCases| ==> \n        var (n, x, operations) := testCases[i];\n        var finalBounds := computeFinalBounds(x, operations);\n        results[i] == finalBounds.1 - finalBounds.0 + 1 &&\n        finalBounds.0 <= x <= finalBounds.1 &&\n        results[i] >= 1 &&\n        1 <= finalBounds.0 <= finalBounds.1 <= n\n}", "vc-helpers": "", "vc-spec": "method solve(testCases: seq<(int, int, seq<(int, int)>)>) returns (results: seq<int>)\n    requires ValidInput(testCases)\n    ensures ValidResults(testCases, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_244", "vc-description": "Given 3 shells numbered 0, 1, 2, a ball starts under one shell. An operator makes n moves:\nodd moves swap shells 0 and 1, even moves swap shells 1 and 2. Given the final position x\nafter n moves, determine the initial position of the ball.\n\n// odd move: swap 0 and 1\n\n// even move: swap 1 and 2\n\n// reverse odd move: swap 0 and 1\n\n// reverse even move: swap 1 and 2", "vc-preamble": "predicate ValidPosition(pos: int) {\n    0 <= pos <= 2\n}\n\nfunction SwapMove(pos: int, moveNum: int): int\n    requires ValidPosition(pos)\n    requires moveNum >= 1\n    ensures ValidPosition(SwapMove(pos, moveNum))\n{\n    if moveNum % 2 == 1 then\n        if pos == 0 then 1\n        else if pos == 1 then 0\n        else 2\n    else\n        if pos == 1 then 2\n        else if pos == 2 then 1\n        else 0\n}\n\nfunction ReverseMove(pos: int, moveNum: int): int\n    requires ValidPosition(pos)\n    requires moveNum >= 1\n    ensures ValidPosition(ReverseMove(pos, moveNum))\n{\n    if moveNum % 2 == 1 then\n        if pos == 0 then 1\n        else if pos == 1 then 0\n        else 2\n    else\n        if pos == 1 then 2\n        else if pos == 2 then 1\n        else 0\n}", "vc-helpers": "", "vc-spec": "method ShellGame(n: int, x: int) returns (result: int)\n    requires n >= 1 && n <= 2000000000\n    requires ValidPosition(x)\n    ensures ValidPosition(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2443", "vc-description": "Given a modulus m and a list of n forbidden values, construct the longest possible sequence where:\n- Each sequence element is an integer in [0, m-1]  \n- All prefix products modulo m are distinct\n- No prefix product modulo m equals any forbidden value\n- Sequence length is maximized", "vc-preamble": "function prefixProduct(s: seq<nat>, i: nat, mod: nat): nat\n  requires mod > 0\n  requires i <= |s|\n{\n    if i == 0 then 1\n    else (s[i-1] * prefixProduct(s, i-1, mod)) % mod\n}\n\nfunction prefixProducts(s: seq<nat>, mod: nat): seq<nat>\n  requires mod > 0\n{\n    seq(|s|, i requires 0 <= i < |s| => prefixProduct(s, i+1, mod))\n}\n\npredicate allDistinct<T(==)>(s: seq<T>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n}\n\npredicate noForbiddenProducts(s: seq<nat>, forbidden: seq<nat>, mod: nat)\n  requires mod > 0\n{\n    var products := prefixProducts(s, mod);\n    forall i :: 0 <= i < |products| ==> products[i] !in forbidden\n}\n\npredicate ValidInput(n: nat, m: nat, forbidden: seq<nat>)\n{\n    m >= 1 &&\n    n >= 0 &&\n    |forbidden| == n &&\n    (forall i :: 0 <= i < |forbidden| ==> 0 <= forbidden[i] < m) &&\n    (forall i, j :: 0 <= i < j < |forbidden| ==> forbidden[i] != forbidden[j])\n}\n\npredicate ValidSequence(sequence: seq<nat>, m: nat, forbidden: seq<nat>)\n  requires m > 0\n{\n    (forall i :: 0 <= i < |sequence| ==> 0 <= sequence[i] < m) &&\n    allDistinct([1] + prefixProducts(sequence, m)) &&\n    noForbiddenProducts(sequence, forbidden, m)\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, m: nat, forbidden: seq<nat>) returns (length: nat, sequence: seq<nat>)\n  requires ValidInput(n, m, forbidden)\n  ensures length == |sequence|\n  ensures length >= 0\n  ensures m == 1 ==> length == 0 && sequence == []\n  ensures m > 1 ==> ValidSequence(sequence, m, forbidden)\n  ensures n == 0 && m > 1 ==> length > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2446", "vc-description": "Given a sequence of n integers and q queries, for each query value x, count the number of contiguous subarrays whose greatest common divisor (GCD) equals x.", "vc-preamble": "predicate ValidInput(input: string)\n{\n  var lines := SplitLinesFunc(input);\n  |lines| >= 3 &&\n  ParseIntFunc(lines[0]) > 0 &&\n  ParseIntFunc(lines[2]) >= 0 &&\n  |lines| >= 3 + ParseIntFunc(lines[2]) &&\n  |ParseIntArrayFunc(lines[1])| == ParseIntFunc(lines[0]) &&\n  (forall i {:trigger ParseIntArrayFunc(lines[1])[i]} :: 0 <= i < |ParseIntArrayFunc(lines[1])| ==> ParseIntArrayFunc(lines[1])[i] > 0) &&\n  forall i {:trigger ParseIntFunc(lines[3 + i])} :: 0 <= i < ParseIntFunc(lines[2]) ==> ParseIntFunc(lines[3 + i]) > 0\n}\n\nfunction GetExpectedResults(input: string): seq<int>\n  requires ValidInput(input)\n  ensures forall x :: x in GetExpectedResults(input) ==> x >= 0\n{\n  var lines := SplitLinesFunc(input);\n  var arr := ParseIntArrayFunc(lines[1]);\n  var q := ParseIntFunc(lines[2]);\n  seq(q, i requires 0 <= i < q => CountSubarraysWithGCD(arr, ParseIntFunc(lines[3 + i])))\n}\n\nfunction FormatOutput(results: seq<int>): string\n  requires forall x :: x in results ==> x >= 0\n  ensures forall x :: x in results ==> x >= 0 ==> IntToStringFunc(x) == IntToStringFunc(x)\n{\n  if |results| == 0 then \"\"\n  else if |results| == 1 then (\n    assert results[0] in results;\n    IntToStringFunc(results[0])\n  )\n  else (\n    assert results[0] in results;\n    assert forall x :: x in results[1..] ==> x in results;\n    IntToStringFunc(results[0]) + \"\\n\" + FormatOutput(results[1..])\n  )\n}\n\nfunction CountSubarraysWithGCD(arr: seq<int>, target: int): int\n  requires |arr| > 0\n  requires forall i :: 0 <= i < |arr| ==> arr[i] > 0\n  requires target > 0\n  ensures CountSubarraysWithGCD(arr, target) >= 0\n{\n  |set pair | pair in SubarrayPairs(arr) && SubarrayGCD(arr, pair.0, pair.1) == target|\n}\n\nfunction SubarrayPairs(arr: seq<int>): set<(int, int)>\n  requires |arr| > 0\n{\n  set i, j | 0 <= i <= j < |arr| :: (i, j)\n}\n\nfunction SubarrayGCD(arr: seq<int>, start: int, end: int): int\n  requires 0 <= start <= end < |arr|\n  requires forall i :: 0 <= i < |arr| ==> arr[i] > 0\n  ensures SubarrayGCD(arr, start, end) > 0\n  decreases end - start\n{\n  if start == end then arr[start]\n  else \n    var rest := SubarrayGCD(arr, start + 1, end);\n    assert arr[start] > 0 && rest > 0;\n    gcd(arr[start], rest)\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n  ensures forall line :: line in SplitLinesFunc(s) ==> '\\n' !in line\n{\n  SplitLinesHelper(s, 0, \"\", [])\n}\n\nfunction ParseIntFunc(s: string): int\n  ensures ParseIntFunc(s) >= 0\n{\n  ParseIntHelper(s, 0, 0)\n}\n\nfunction ParseIntArrayFunc(s: string): seq<int>\n  ensures forall x :: x in ParseIntArrayFunc(s) ==> x >= 0\n{\n  ParseIntArrayHelper(s, 0, \"\", [])\n}\n\nfunction IntToStringFunc(n: int): string\n  requires n >= 0\n{\n  if n == 0 then \"0\"\n  else IntToStringHelper(n, \"\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n  requires |input| > 0\n  requires ValidInput(input)\n  ensures result == FormatOutput(GetExpectedResults(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2447", "vc-description": "Given multiple binary strings, determine the minimum number of character flips needed \nto make each string \"good\". A string is \"good\" if it contains neither \"010\" nor \"101\" \nas a subsequence. Input format: first line contains number of test cases t, followed \nby t binary strings. Output the minimum operations needed for each string.\n\n// placeholder implementation\n\n// placeholder implementation\n\n// placeholder implementation\n\n// placeholder implementation", "vc-preamble": "function split_lines(s: string): seq<string>\n{\n    [\"\"]\n}\n\nfunction is_valid_number(s: string): bool\n{\n    true\n}\n\nfunction parse_int(s: string): int\n    requires is_valid_number(s)\n{\n    0\n}\n\nfunction is_binary_string(s: string): bool\n{\n    true\n}\n\nfunction ends_with_newline(s: string): bool\n{\n    |s| > 0 && s[|s|-1] == '\\n'\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    input[|input|-1] == '\\n' &&\n    exists lines :: \n        lines == split_lines(input) &&\n        |lines| >= 2 &&\n        is_valid_number(lines[0]) &&\n        var t := parse_int(lines[0]);\n        t >= 1 && t <= 100 &&\n        |lines| == t + 1 &&\n        forall i :: 1 <= i < |lines| ==> \n            is_binary_string(lines[i]) && |lines[i]| >= 1 && |lines[i]| <= 1000\n}\n\npredicate ValidOutput(result: string)\n{\n    result != \"\" &&\n    (ends_with_newline(result) || result == \"\") &&\n    exists output_lines :: \n        output_lines == split_lines(result) &&\n        |output_lines| >= 1 &&\n        (forall i :: 0 <= i < |output_lines|-1 ==> is_valid_number(output_lines[i])) &&\n        (forall i :: 0 <= i < |output_lines|-1 ==> parse_int(output_lines[i]) >= 0)\n}\n\npredicate CorrectResult(input: string, result: string)\n    requires ValidInput(input)\n{\n    exists input_lines, t :: \n        input_lines == split_lines(input) &&\n        t == parse_int(input_lines[0]) &&\n        var output_lines := split_lines(result);\n        |output_lines| == t + 1 &&\n        forall test_case :: 0 <= test_case < t ==>\n            var s := input_lines[test_case + 1];\n            var min_ops := parse_int(output_lines[test_case]);\n            min_ops == min_operations_to_make_good(s)\n}\n\nfunction min_operations_to_make_good(s: string): int\n    requires is_binary_string(s)\n    ensures min_operations_to_make_good(s) >= 0\n    ensures min_operations_to_make_good(s) <= |s|\n{\n    if |s| == 0 then 0\n    else min_ops_helper(s, 0, |s|)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)\n    ensures CorrectResult(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2451", "vc-description": "Given a building with n towers and h floors each, find minimum travel time between pairs of locations.\nHorizontal passages exist between adjacent towers only on floors a through b (inclusive).\nMoving between adjacent floors or towers takes exactly 1 minute.", "vc-preamble": "predicate ValidBuildingParams(n: int, h: int, a: int, b: int)\n{\n    n >= 1 && h >= 1 && 1 <= a <= b <= h\n}\n\npredicate ValidQuery(query: (int, int, int, int), n: int, h: int)\n{\n    1 <= query.0 <= n && 1 <= query.1 <= h &&\n    1 <= query.2 <= n && 1 <= query.3 <= h\n}\n\npredicate ValidQueries(queries: seq<(int, int, int, int)>, n: int, h: int)\n{\n    forall i :: 0 <= i < |queries| ==> ValidQuery(queries[i], n, h)\n}\n\nfunction MinTravelTime(t1: int, f1: int, t2: int, f2: int, a: int, b: int): int\n{\n    if t1 == t2 then\n        abs(f1 - f2)\n    else if f1 >= a && f1 <= b then\n        abs(t2 - t1) + abs(f2 - f1)\n    else if f1 < a then\n        abs(a - f1) + abs(t2 - t1) + abs(f2 - a)\n    else\n        abs(b - f1) + abs(t2 - t1) + abs(f2 - b)\n}\n\npredicate CorrectResults(queries: seq<(int, int, int, int)>, results: seq<int>, a: int, b: int)\n{\n    |results| == |queries| &&\n    forall i :: 0 <= i < |queries| ==>\n        var t1, f1, t2, f2 := queries[i].0, queries[i].1, queries[i].2, queries[i].3;\n        results[i] == MinTravelTime(t1, f1, t2, f2, a, b)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, h: int, a: int, b: int, queries: seq<(int, int, int, int)>) returns (results: seq<int>)\n    requires ValidBuildingParams(n, h, a, b)\n    requires ValidQueries(queries, n, h)\n    ensures CorrectResults(queries, results, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2456", "vc-description": "Given integers n and r, determine the number of distinct shapes that can be formed\nby painting n consecutive days on calendars where a week can have k days (1 \u2264 k \u2264 r).\nDays are arranged left-to-right in rows, wrapping to the next row when reaching \nthe end of a week. All painted cells must be connected by sides. Two shapes are \nconsidered the same if one can be moved to exactly overlap the other using only \nparallel translations.", "vc-preamble": "predicate ValidInput(n: int, r: int)\n{\n    n >= 1 && r >= 1\n}\n\nfunction ExpectedResult(n: int, r: int): int\n    requires ValidInput(n, r)\n{\n    var k := if r < n - 1 then r else n - 1;\n    k * (k + 1) / 2 + (if r >= n then 1 else 0)\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2457", "vc-description": "Given n grains where each grain weighs between (a-b) and (a+b) grams inclusive,\ndetermine if the total weight of all n grains can fall within the range [c-d, c+d] grams inclusive.\nInput format: first line contains number of test cases t, followed by t lines each containing\n5 integers n, a, b, c, d representing the parameters for each test case.\nOutput \"Yes\" if possible, \"No\" otherwise for each test case.", "vc-preamble": "predicate ValidInput(input: string) {\n    |input| >= 0\n}\n\npredicate ValidTestCase(n: int, a: int, b: int, c: int, d: int) {\n    n >= 1 && n <= 1000 &&\n    a >= 0 && a <= 1000 &&\n    b >= 0 && b < a &&\n    c >= 0 && c <= 1000 &&\n    d >= 0 && d < c\n}\n\nfunction CanAchieveWeight(n: int, a: int, b: int, c: int, d: int): bool {\n    var minWeight := (a - b) * n;\n    var maxWeight := (a + b) * n;\n    var targetMin := c - d;\n    var targetMax := c + d;\n    !(minWeight > targetMax || maxWeight < targetMin)\n}\n\npredicate ValidOutput(output: string) {\n    forall i :: 0 <= i < |output| ==> output[i] in \"YesNo\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)\n    ensures (input == \"\" || input == \"\\n\") ==> result == \"\"\n    ensures input != \"\" && input != \"\\n\" ==> (|result| > 0 ==> result[|result|-1] == '\\n' || (|result| > 3 && result[|result|-4..] in [\"Yes\\n\", \"No\\n\"]))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_246", "vc-description": "Count positive integers x \u2264 n where x - (sum of digits of x) \u2265 s.\nGiven two integers n and s (1 \u2264 n, s \u2264 10^18), return the count of numbers x \u2264 n satisfying the condition.", "vc-preamble": "function SumOfDigits(x: int): int\n  requires x >= 0\n  decreases x\n{\n  if x == 0 then 0\n  else (x % 10) + SumOfDigits(x / 10)\n}\n\nfunction Check(x: int, s: int): bool\n  requires x >= 0\n{\n  x - SumOfDigits(x) >= s\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: int) returns (result: int)\n  requires n >= 1 && s >= 1\n  ensures result >= 0\n  ensures result <= n\n  ensures result == |set x | 1 <= x <= n && Check(x, s)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2465", "vc-description": "Given an angle measurement in degrees, find the minimum number of vertices n for a regular n-gon \nthat contains three vertices a, b, c such that the angle \u2220abc equals the given angle. \nIf no such n-gon exists, return -1.", "vc-preamble": "predicate ValidInput(angles: seq<int>)\n{\n  forall i :: 0 <= i < |angles| ==> 1 <= angles[i] < 180\n}\n\nfunction ComputeAnswer(angle: int): int\n  requires 1 <= angle < 180\n{\n  var g := gcd(angle, 180);\n  var de_over_g := angle / g;\n  var n180_over_g := 180 / g;\n  if de_over_g == n180_over_g - 1 then n180_over_g * 2 else n180_over_g\n}\n\npredicate CorrectOutput(angles: seq<int>, result: seq<int>)\n  requires ValidInput(angles)\n{\n  |result| == |angles| &&\n  forall i :: 0 <= i < |angles| ==> result[i] == ComputeAnswer(angles[i])\n}", "vc-helpers": "", "vc-spec": "method solve(angles: seq<int>) returns (result: seq<int>)\n  requires ValidInput(angles)\n  ensures CorrectOutput(angles, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2466", "vc-description": "Given a list of distinct integers, generate all possible permutations of the elements.\nEach permutation should be a list containing all elements from the input in a different order.", "vc-preamble": "function factorial(n: nat): nat\n{\n    if n == 0 then 1 else n * factorial(n - 1)\n}\n\npredicate IsPermutation(perm: seq<int>, original: seq<int>)\n{\n    |perm| == |original| && multiset(perm) == multiset(original)\n}\n\npredicate AllDistinct<T(==)>(s: seq<T>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n}", "vc-helpers": "", "vc-spec": "method permute(nums: seq<int>) returns (result: seq<seq<int>>)\n    requires AllDistinct(nums)\n    ensures |result| == factorial(|nums|)\n    ensures forall p :: p in result ==> IsPermutation(p, nums)\n    ensures AllDistinct(result)\n    ensures forall perm :: IsPermutation(perm, nums) ==> perm in result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2467", "vc-description": "Find all unique combinations of exactly k distinct numbers from the range [1, 9] that sum to n.\nEach number must be from 1 to 9, used at most once per combination, with no duplicate combinations.", "vc-preamble": "function sum(s: seq<int>): int\n{\n    if |s| == 0 then 0\n    else s[0] + sum(s[1..])\n}\n\npredicate isDistinct(s: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |s| ==> s[i] != s[j]\n}\n\npredicate isSorted(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| - 1 ==> s[i] < s[i + 1]\n}\n\npredicate isValidCombination(combo: seq<int>, k: int, n: int)\n{\n    |combo| == k &&\n    sum(combo) == n &&\n    (forall j :: 0 <= j < |combo| ==> 1 <= combo[j] <= 9) &&\n    isDistinct(combo) &&\n    isSorted(combo)\n}\n\npredicate isValidExtension(temp: seq<int>, combo: seq<int>, k: int, n: int, start: int)\n{\n    |combo| == k &&\n    sum(combo) == n &&\n    (forall j :: 0 <= j < |combo| ==> 1 <= combo[j] <= 9) &&\n    isDistinct(combo) &&\n    isSorted(combo) &&\n    |combo| >= |temp| &&\n    (forall i :: 0 <= i < |temp| ==> temp[i] == combo[i]) &&\n    (forall i :: |temp| <= i < |combo| ==> combo[i] >= start)\n}", "vc-helpers": "", "vc-spec": "method combinationSum3(k: int, n: int) returns (result: seq<seq<int>>)\n    requires k > 0 && n > 0 && k <= 9\n    ensures forall i :: 0 <= i < |result| ==> |result[i]| == k\n    ensures forall i :: 0 <= i < |result| ==> sum(result[i]) == n\n    ensures forall i :: 0 <= i < |result| ==> forall j :: 0 <= j < |result[i]| ==> 1 <= result[i][j] <= 9\n    ensures forall i :: 0 <= i < |result| ==> isDistinct(result[i])\n    ensures forall i :: 0 <= i < |result| ==> isSorted(result[i])\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n    ensures forall combo :: isValidCombination(combo, k, n) ==> combo in result\n    ensures forall combo :: combo in result ==> isValidCombination(combo, k, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2486", "vc-description": "Given N cards with positive integers, determine how many cards are \"unnecessary.\"\nA subset of cards is \"good\" if the sum of its numbers is at least K.\nA card is \"unnecessary\" if for every good subset containing this card, \nremoving the card from that subset still results in a good subset.\nCount the number of unnecessary cards.", "vc-preamble": "function UnnecessaryCardsCount(sorted: seq<int>, k: int): int\n  requires forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]\n  requires forall i :: 0 <= i < |sorted| ==> sorted[i] >= 1\n  requires k >= 1\n{\n  if |sorted| == 0 then 0\n  else\n    UnnecessaryCardsCountHelper(sorted, k, 0, 0, 0)\n}\n\nfunction UnnecessaryCardsCountHelper(sorted: seq<int>, k: int, temp: int, ans: int, i: int): int\n  requires forall x, y :: 0 <= x < y < |sorted| ==> sorted[x] >= sorted[y]\n  requires forall x :: 0 <= x < |sorted| ==> sorted[x] >= 1\n  requires k >= 1\n  requires 0 <= i <= |sorted|\n  requires temp >= 0\n  requires ans >= 0\n  decreases |sorted| - i\n{\n  if i >= |sorted| then ans\n  else\n    var x := sorted[i];\n    if temp + x < k then\n      UnnecessaryCardsCountHelper(sorted, k, temp + x, ans + 1, i + 1)\n    else\n      UnnecessaryCardsCountHelper(sorted, k, 0, 0, i + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, a: seq<int>) returns (result: int)\n  requires n >= 1\n  requires k >= 1\n  requires |a| == n\n  requires forall i :: 0 <= i < |a| ==> a[i] >= 1\n  ensures result >= 0\n  ensures result <= n\n  ensures exists sorted :: \n    |sorted| == |a| &&\n    multiset(sorted) == multiset(a) &&\n    (forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] >= sorted[j]) &&\n    (forall i :: 0 <= i < |sorted| ==> sorted[i] >= 1) &&\n    result == UnnecessaryCardsCount(sorted, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2501", "vc-description": "Given N attendees numbered 1 to N with heights A_i, count the number of pairs (i,j) \nwhere i \u2260 j such that the absolute difference of their numbers equals the sum of their heights: \n|i - j| = A_i + A_j.", "vc-preamble": "predicate ValidInput(A: array<int>)\n  reads A\n{\n  A.Length >= 2 && forall i :: 0 <= i < A.Length ==> A[i] >= 1\n}\n\nfunction abs(x: int): int\n{\n  if x >= 0 then x else -x\n}\n\npredicate ValidPair(A: array<int>, i: int, j: int)\n  reads A\n  requires 0 <= i < A.Length && 0 <= j < A.Length\n{\n  i != j && abs((i+1) - (j+1)) == A[i] + A[j]\n}\n\nfunction CountValidPairs(A: array<int>): int\n  reads A\n  requires ValidInput(A)\n{\n  |set i, j | 0 <= i < A.Length && 0 <= j < A.Length && ValidPair(A, i, j) :: (i, j)|\n}", "vc-helpers": "", "vc-spec": "method solve(A: array<int>) returns (result: int)\n  requires ValidInput(A)\n  ensures result >= 0\n  ensures result == CountValidPairs(A)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2516", "vc-description": "Given a string S of length N containing only digits 0-9 and a prime number P,\ncount how many contiguous substrings of S are divisible by P when interpreted\nas base-10 integers.", "vc-preamble": "predicate isPrime(p: int)\n    requires p >= 2\n{\n    forall k :: 2 <= k < p ==> p % k != 0\n}\n\npredicate ValidInput(n: int, p: int, s: string)\n{\n    n >= 1 &&\n    p >= 2 &&\n    isPrime(p) &&\n    |s| == n &&\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction substringToInt(s: string): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    requires |s| > 0\n{\n    if |s| == 1 then s[0] as int - '0' as int\n    else substringToInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\npredicate ValidResult(result: int, n: int)\n{\n    result >= 0 && result <= n * (n + 1) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: int, s: string) returns (result: int)\n    requires ValidInput(n, p, s)\n    ensures ValidResult(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2522", "vc-description": "Given two sorted sequences A and B of length N, determine if B can be reordered \nso that A[i] \u2260 B[i] for all positions i. If possible, output any valid reordering of B.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>, b: seq<int>)\n{\n    |a| == n && |b| == n && n >= 1 &&\n    (forall i :: 0 <= i < n-1 ==> a[i] <= a[i+1]) &&\n    (forall i :: 0 <= i < n-1 ==> b[i] <= b[i+1])\n}\n\npredicate ValidReordering(a: seq<int>, reordered_b: seq<int>)\n    requires |a| == |reordered_b|\n{\n    forall i :: 0 <= i < |a| ==> a[i] != reordered_b[i]\n}\n\npredicate IsReorderingOf(original: seq<int>, reordered: seq<int>)\n{\n    |original| == |reordered| && multiset(original) == multiset(reordered)\n}\n\npredicate IsRotation(original: seq<int>, rotated: seq<int>)\n{\n    |original| == |rotated| && \n    (exists k :: 0 <= k < |original| && rotated == original[k..] + original[..k])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>, b: seq<int>) returns (result: (bool, seq<int>))\n    requires ValidInput(n, a, b)\n    ensures result.0 ==> |result.1| == n\n    ensures result.0 ==> IsReorderingOf(b, result.1)\n    ensures result.0 ==> ValidReordering(a, result.1)\n    ensures !result.0 ==> result.1 == []\n    ensures result.0 ==> IsRotation(b, result.1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_253", "vc-description": "Given three positive integers k\u2081, k\u2082, k\u2083 (each \u2264 1500), determine if there exist \nstarting times x\u2081, x\u2082, x\u2083 such that every integer t \u2265 max(x\u2081, x\u2082, x\u2083) can be written \nas x\u1d62 + j\u00b7k\u1d62 for some i \u2208 {1,2,3} and non-negative integer j. In other words, \ndetermine if the union of three arithmetic progressions can cover all sufficiently \nlarge positive integers.\n\n// a == 2", "vc-preamble": "predicate ValidInput(nums: seq<int>)\n{\n    |nums| == 3 &&\n    forall i :: 0 <= i < |nums| ==> nums[i] > 0 &&\n    forall i :: 0 <= i < |nums| ==> nums[i] <= 1500\n}\n\nfunction computeResult(x: int, y: int, z: int): string\n    requires x > 0 && y > 0 && z > 0\n    requires x <= 1500 && y <= 1500 && z <= 1500\n{\n    var sorted := sortThree(x, y, z);\n    var a := sorted.0;\n    var b := sorted.1;\n    var c := sorted.2;\n\n    if a > 3 then \"NO\"\n    else if a == 3 then\n        if b > 3 then \"NO\"\n        else if b == 3 then\n            if c > 3 then \"NO\" else \"YES\"\n        else \"NO\"\n    else if a == 1 then \"YES\"\n    else\n        if b == 2 then \"YES\"\n        else if b > 4 then \"NO\"\n        else if b == 4 then\n            if c == 4 then \"YES\" else \"NO\"\n        else \"NO\"\n}", "vc-helpers": "", "vc-spec": "method solve(nums: seq<int>) returns (result: string)\n    requires ValidInput(nums)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == computeResult(nums[0], nums[1], nums[2])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2548", "vc-description": "Given an array of n integers (each from 0 to 9), count the number of subarrays \nwhere the sum of elements equals the length of the subarray.\nA subarray from index l to r is \"good\" if: sum(a[l] + a[l+1] + ... + a[r]) = (r - l + 1)", "vc-preamble": "predicate ValidInput(digits: seq<int>)\n{\n    |digits| >= 1 && forall i :: 0 <= i < |digits| ==> 0 <= digits[i] <= 9\n}\n\npredicate IsGoodSubarray(digits: seq<int>, start: int, end: int)\n    requires 0 <= start <= end < |digits|\n{\n    var subarray_sum := Sum(digits[start..end+1]);\n    var subarray_length := end - start + 1;\n    subarray_sum == subarray_length\n}\n\nfunction Sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + Sum(s[1..])\n}\n\nfunction CountGoodSubarrays(digits: seq<int>): int\n    requires ValidInput(digits)\n{\n    CountGoodSubarraysHelper(digits, 0, map[0 := 1], 0, 0)\n}\n\nfunction CountGoodSubarraysHelper(digits: seq<int>, pos: int, freq_map: map<int, int>, \n                                current_sum: int, current_count: int): int\n    requires 0 <= pos <= |digits|\n    requires ValidInput(digits)\n    requires current_count == pos\n    requires current_sum >= 0\n    requires forall k :: k in freq_map ==> freq_map[k] >= 0\n    requires 0 in freq_map ==> freq_map[0] >= 1\n    ensures CountGoodSubarraysHelper(digits, pos, freq_map, current_sum, current_count) >= 0\n    decreases |digits| - pos\n{\n    if pos >= |digits| then 0\n    else\n        var new_sum := current_sum + digits[pos];\n        var new_count := current_count + 1;\n        var diff := new_count - new_sum;\n        var contribution := if diff in freq_map then freq_map[diff] else 0;\n        var new_freq_map := freq_map[diff := if diff in freq_map then freq_map[diff] + 1 else 1];\n        contribution + CountGoodSubarraysHelper(digits, pos + 1, new_freq_map, new_sum, new_count)\n}", "vc-helpers": "", "vc-spec": "method CountGoodSubarraysInArray(digits: seq<int>) returns (count: int)\n    requires ValidInput(digits)\n    ensures count >= 0\n    ensures count == CountGoodSubarrays(digits)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2550", "vc-description": "Given n students with scores between 0 and m, redistribute scores to maximize student 1's score\nwhile preserving the total sum and keeping all scores within [0, m].", "vc-preamble": "predicate ValidInput(n: int, m: int, scores: seq<int>)\n{\n    n >= 1 && m >= 1 && |scores| == n &&\n    forall i :: 0 <= i < |scores| ==> 0 <= scores[i] <= m\n}\n\nfunction Sum(nums: seq<int>): int\n    ensures Sum(nums) >= 0 || exists i :: 0 <= i < |nums| && nums[i] < 0\n{\n    if |nums| == 0 then 0\n    else nums[0] + Sum(nums[1..])\n}\n\nfunction min(a: int, b: int): int\n    ensures min(a, b) == a || min(a, b) == b\n    ensures min(a, b) <= a && min(a, b) <= b\n    ensures min(a, b) == a <==> a <= b\n{\n    if a <= b then a else b\n}\n\npredicate ValidRedistribution(original: seq<int>, redistributed: seq<int>, m: int)\n{\n    |redistributed| == |original| &&\n    Sum(redistributed) == Sum(original) &&\n    forall i :: 0 <= i < |redistributed| ==> 0 <= redistributed[i] <= m\n}\n\nfunction MaxPossibleFirstScore(n: int, m: int, scores: seq<int>): int\n    requires ValidInput(n, m, scores)\n    ensures MaxPossibleFirstScore(n, m, scores) == min(Sum(scores), m)\n{\n    min(Sum(scores), m)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, scores: seq<int>) returns (result: int)\n    requires ValidInput(n, m, scores)\n    ensures result == MaxPossibleFirstScore(n, m, scores)\n    ensures result == min(Sum(scores), m)\n    ensures exists redistributed :: (ValidRedistribution(scores, redistributed, m) && \n            redistributed[0] == result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2553", "vc-description": "Given an array of n integers, determine if it's possible to select exactly x elements \nsuch that their sum is odd. A sum is odd if and only if it contains an odd number of odd elements.\n\n// Placeholder implementation\n\n// Placeholder implementation\n\n// Placeholder implementation\n\n// Placeholder implementation\n\n// Placeholder implementation\n\n// Placeholder implementation", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n' &&\n    CountLines(input) >= 1 &&\n    exists q: nat :: (1 <= q <= 100 && \n        ParseFirstLine(input) == q &&\n        CountLines(input) == 1 + 2 * q &&\n        ValidTestCasesFormat(input, q))\n}\n\npredicate ValidTestCasesFormat(input: string, q: nat)\n    requires 1 <= q <= 100\n    requires CountLines(input) >= 1 + 2 * q\n{\n    forall i :: 0 <= i < q ==> \n        exists n, x: nat :: (1 <= x <= n <= 1000 &&\n        GetTestCaseN(input, i) == n &&\n        GetTestCaseX(input, i) == x &&\n        |GetTestCaseArray(input, i)| == n &&\n        forall j :: 0 <= j < n ==> 1 <= GetTestCaseArray(input, i)[j] <= 1000)\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| >= 0 && \n    (|output| == 0 || output[|output|-1] == '\\n') &&\n    forall i :: 0 <= i < CountLines(output) ==> \n        (GetLine(output, i) == \"Yes\" || GetLine(output, i) == \"No\")\n}\n\npredicate OutputMatchesAlgorithm(input: string, output: string)\n    requires ValidInput(input)\n{\n    var q := ParseFirstLine(input);\n    CountLines(output) == q &&\n    forall i :: 0 <= i < q ==>\n        var arr := GetTestCaseArray(input, i);\n        var x := GetTestCaseX(input, i);\n        var expected := if CanSelectOddSum(arr, x) then \"Yes\" else \"No\";\n        GetLine(output, i) == expected\n}\n\npredicate CanSelectOddSum(arr: seq<int>, x: nat)\n    requires x <= |arr|\n{\n    var odd_count := CountOddElements(arr);\n    var even_count := |arr| - odd_count;\n\n    if x == |arr| then\n        odd_count % 2 == 1\n    else if odd_count > 0 && even_count > 0 then\n        true\n    else if even_count == 0 then\n        x % 2 == 1\n    else\n        false\n}\n\nfunction CountOddElements(arr: seq<int>): nat\n    ensures CountOddElements(arr) <= |arr|\n    decreases |arr|\n{\n    if |arr| == 0 then 0\n    else if arr[0] % 2 == 1 then 1 + CountOddElements(arr[1..])\n    else CountOddElements(arr[1..])\n}\n\nfunction ParseFirstLine(input: string): nat\n    requires |input| > 0\n    requires CountLines(input) >= 1\n{\n    1\n}\n\nfunction GetTestCaseN(input: string, case_index: nat): nat\n    requires |input| > 0\n    requires CountLines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nfunction GetTestCaseX(input: string, case_index: nat): nat\n    requires |input| > 0\n    requires CountLines(input) >= 1 + 2 * (case_index + 1)\n{\n    1\n}\n\nfunction GetTestCaseArray(input: string, case_index: nat): seq<int>\n    requires |input| > 0\n    requires CountLines(input) >= 1 + 2 * (case_index + 1)\n{\n    [1]\n}\n\nfunction CountLines(s: string): nat\n{\n    if |s| == 0 then 0 else 1\n}\n\nfunction GetLine(s: string, line_index: nat): string\n    requires line_index < CountLines(s)\n{\n    if line_index == 0 then \"No\" else \"\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(output)\n    ensures OutputMatchesAlgorithm(stdin_input, output)\n    ensures CountLines(output) == ParseFirstLine(stdin_input)\n    ensures forall i :: 0 <= i < CountLines(output) ==> \n        (GetLine(output, i) == \"Yes\" || GetLine(output, i) == \"No\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2556", "vc-description": "Given n rooms, for each room i install at most c_i radiators to achieve at least sum_i total sections.\nEach radiator with k sections costs k\u00b2 burles. Find the minimum cost for each room.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidOutput(input: string, output: string)\n    requires ValidInput(input)\n{\n    var inputPairs := GetInputPairs(input);\n    var expectedResults := seq(|inputPairs|, i requires 0 <= i < |inputPairs| => \n        if inputPairs[i].0 > 0 && inputPairs[i].1 >= 0 then\n            ComputeMinimumCost(inputPairs[i].0, inputPairs[i].1)\n        else 0);\n    output == FormatResults(expectedResults)\n}\n\nfunction ComputeMinimumCost(c: int, s: int): int\n    requires c > 0 && s >= 0\n    ensures ComputeMinimumCost(c, s) >= 0\n{\n    var a := s / c;\n    var r := s % c;\n    (c - r) * a * a + r * (a + 1) * (a + 1)\n}\n\nfunction GetInputPairs(input: string): seq<(int, int)>\n    requires |input| > 0\n    ensures |GetInputPairs(input)| >= 0\n{\n    var lines := SplitLines(input);\n    if |lines| == 0 then []\n    else \n        var n := ParseInt(lines[0]);\n        GetPairsFromLines(lines, 1, n)\n}\n\nfunction FormatResults(results: seq<int>): string\n    requires forall j :: 0 <= j < |results| ==> results[j] >= 0\n    ensures |FormatResults(results)| >= 0\n{\n    FormatResultsHelper(results, 0, \"\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_256", "vc-description": "Game theory problem: Two teams of 2 players each compete. Each player has defense and attack skills.\nTeam 1 chooses their defense/attack assignment first, then Team 2 responds optimally.\nA team wins if their defense > opponent's attack AND their attack > opponent's defense.\nDetermine which team can guarantee a win with optimal play, or if neither can.\n\n// player 1 defense\n\n// player 1 attack\n\n// player 2 defense\n\n// player 2 attack\n\n// player 3 defense\n\n// player 3 attack\n\n// player 4 defense\n\n// player 4 attack", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 4 &&\n    (forall i :: 0 <= i < 4 ==> ValidPlayerLine(lines[i]))\n}\n\npredicate ValidPlayerLine(line: string)\n{\n    var parts := SplitByChar(line, ' ');\n    |parts| == 2 &&\n    IsValidInteger(parts[0]) &&\n    IsValidInteger(parts[1])\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction ComputeResult(input: string): string\n{\n    var lines := SplitLines(input);\n    if |lines| < 4 then \"\"\n    else\n        var player1 := ParseLine(lines[0]);\n        var player2 := ParseLine(lines[1]);\n        var player3 := ParseLine(lines[2]);\n        var player4 := ParseLine(lines[3]);\n\n        if |player1| != 2 || |player2| != 2 || |player3| != 2 || |player4| != 2 then \"\"\n        else\n            var a := player1[0];\n            var b := player1[1];\n            var c := player2[0];\n            var d := player2[1];\n            var x := player3[0];\n            var y := player3[1];\n            var z := player4[0];\n            var w := player4[1];\n\n            var Team1 := (a > w && a > y && d > x && d > z) || (c > w && c > y && b > x && b > z);\n            var Team2 := ((x > b && w > c) || (z > b && y > c)) && ((x > d && w > a) || (z > d && y > a));\n\n            if Team1 then \"Team 1\\n\"\n            else if Team2 then \"Team 2\\n\"\n            else \"Draw\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == ComputeResult(input)\n    ensures result == \"Team 1\\n\" || result == \"Team 2\\n\" || result == \"Draw\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2560", "vc-description": "Given a target sum n and a range of coin denominations [l, r], determine if it's possible \nto make exactly the sum n using coins with denominations between l and r (inclusive).\nYou have unlimited coins of each valid denomination.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\nfunction CanMakeSum(n: int, l: int, r: int): bool\n{\n    l > 0 && l <= r && n > 0 && n % l <= (r - l) * (n / l)\n}\n\npredicate ValidOutput(result: string)\n{\n    |result| >= 0 && forall i :: 0 <= i < |result| ==> result[i] in \"Yes\\nNo\\n \"\n}\n\npredicate CorrectSolution(input: string, result: string)\n{\n    var lines := SplitLines(input);\n    |lines| > 0 ==> \n    (var t := ParseInt(lines[0]);\n     var outputLines := SplitLines(result);\n     |outputLines| >= 1 && (|outputLines| == 1 ==> outputLines[0] == \"\") &&\n     (|outputLines| > 1 ==> outputLines[|outputLines|-1] == \"\") &&\n     forall i :: 1 <= i <= t && i < |lines| ==>\n        (var parts := SplitSpaces(lines[i]);\n         |parts| >= 3 ==>\n         (var n := ParseInt(parts[0]);\n          var l := ParseInt(parts[1]);\n          var r := ParseInt(parts[2]);\n          var expectedOutput := if CanMakeSum(n, l, r) then \"Yes\" else \"No\";\n          i-1 < |outputLines| && outputLines[i-1] == expectedOutput)))\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)\n    ensures CorrectSolution(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2568", "vc-description": "Given a string of '+' and '-' characters, simulate finding the minimum initial value\nneeded to keep a running sum non-negative throughout the string. Count the total\nnumber of characters processed across all attempts until finding a successful initial value.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == '+' || s[i] == '-'\n}\n\nfunction computeResult(s: string): int\n    requires forall i :: 0 <= i < |s| ==> s[i] == '+' || s[i] == '-'\n{\n    computeResultHelper(s, 0, 0, 0, |s|)\n}\n\nfunction computeResultHelper(s: string, i: int, cur: int, pm: int, ans: int): int\n    requires forall j :: 0 <= j < |s| ==> s[j] == '+' || s[j] == '-'\n    requires 0 <= i <= |s|\n    requires pm <= cur\n    requires ans >= |s|\n    decreases |s| - i\n{\n    if i == |s| then ans\n    else if s[i] == '+' then\n        computeResultHelper(s, i + 1, cur + 1, pm, ans)\n    else\n        var newCur := cur - 1;\n        if newCur < pm then\n            computeResultHelper(s, i + 1, newCur, newCur, ans + i + 1)\n        else\n            computeResultHelper(s, i + 1, newCur, pm, ans)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result >= |s|\n    ensures result == computeResult(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2583", "vc-description": "Two players play a game starting with integer n. Players alternate turns, with the first player moving first.\nOn each turn, a player must make exactly one of these moves:\n1. Divide n by any odd divisor of n greater than 1\n2. Subtract 1 from n (only if n > 1)\nThe player unable to make a move loses. Determine the winner assuming both players play optimally.", "vc-preamble": "function determineWinner(n: int): string\nrequires n >= 1\nensures determineWinner(n) == \"FastestFinger\" || determineWinner(n) == \"Ashishgup\"\nensures (n == 1) ==> determineWinner(n) == \"FastestFinger\"\nensures (n == 2) ==> determineWinner(n) == \"Ashishgup\"\nensures (n > 2 && isPowerOfTwo(n)) ==> determineWinner(n) == \"FastestFinger\"\nensures (n > 2 && !isPowerOfTwo(n) && n % 4 != 2) ==> determineWinner(n) == \"Ashishgup\"\nensures (n > 2 && !isPowerOfTwo(n) && n % 4 == 2) ==> (determineWinner(n) == \"FastestFinger\" <==> isLimitedPrime(n / 2))\n{\n    if n == 1 then \"FastestFinger\"\n    else if n == 2 then \"Ashishgup\"\n    else if isPowerOfTwo(n) then \"FastestFinger\"\n    else if n % 4 != 2 then \"Ashishgup\"\n    else if isLimitedPrime(n / 2) then \"FastestFinger\"\n    else \"Ashishgup\"\n}\n\nfunction isPowerOfTwo(n: int): bool\nrequires n >= 1\nensures n == 1 ==> isPowerOfTwo(n)\nensures n > 1 ==> (isPowerOfTwo(n) <==> (n % 2 == 0 && isPowerOfTwo(n / 2)))\n{\n    if n <= 0 then false\n    else n == 1 || (n % 2 == 0 && isPowerOfTwo(n / 2))\n}\n\nfunction isLimitedPrime(p: int): bool\nrequires p >= 1\nensures p == 1 ==> !isLimitedPrime(p)\nensures p == 2 ==> isLimitedPrime(p)\nensures p > 2 && p % 2 == 0 ==> !isLimitedPrime(p)\nensures p > 2 && p % 2 != 0 ==> (isLimitedPrime(p) <==> isLimitedPrimeHelper(p, 3))\n{\n    if p <= 1 then false\n    else if p == 2 then true\n    else if p % 2 == 0 then false\n    else isLimitedPrimeHelper(p, 3)\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<int>) returns (result: seq<string>)\nrequires |input| >= 1\nrequires input[0] >= 1\nrequires |input| == input[0] + 1\nrequires forall i :: 1 <= i < |input| ==> input[i] >= 1\nensures |result| == input[0]\nensures forall i :: 0 <= i < |result| ==> result[i] == \"FastestFinger\" || result[i] == \"Ashishgup\"\nensures forall i :: 1 <= i < |input| ==> result[i-1] == determineWinner(input[i])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_259", "vc-description": "Given n bus routes with start times and intervals, find which route has the earliest bus\narriving at or after target time t. Each route i has first bus at time s_i and subsequent\nbuses every d_i minutes. Return the 1-indexed route number.", "vc-preamble": "predicate ValidInput(n: int, t: int, routes: seq<(int, int)>)\n{\n  n > 0 && |routes| == n && \n  forall i :: 0 <= i < n ==> routes[i].1 > 0\n}\n\nfunction getNextArrivalTime(firstTime: int, interval: int, targetTime: int): int\n  requires interval > 0\n{\n  if firstTime >= targetTime then firstTime\n  else firstTime + ((targetTime - firstTime + interval - 1) / interval) * interval\n}\n\npredicate IsOptimalRoute(routes: seq<(int, int)>, t: int, routeIndex: int)\n  requires 0 <= routeIndex < |routes|\n  requires forall i :: 0 <= i < |routes| ==> routes[i].1 > 0\n{\n  forall i :: 0 <= i < |routes| ==> \n    getNextArrivalTime(routes[routeIndex].0, routes[routeIndex].1, t) <= \n    getNextArrivalTime(routes[i].0, routes[i].1, t)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, t: int, routes: seq<(int, int)>) returns (result: int)\n  requires ValidInput(n, t, routes)\n  ensures 1 <= result <= n\n  ensures IsOptimalRoute(routes, t, result - 1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2594", "vc-description": "Given a rectangular park represented as an n\u00d7m grid of squares, find the minimum number \nof lanterns needed to light up all squares. Lanterns are placed on edges between squares,\nand each lantern illuminates adjacent squares (up to 2 squares, or 1 if on boundary).", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| > 0 &&\n    var t := ParseInt(lines[0]);\n    t > 0 && |lines| >= t + 1 &&\n    forall i {:trigger SplitSpaces(lines[i+1])} :: 0 <= i < t ==>\n        var parts := SplitSpaces(lines[i+1]);\n        |parts| >= 2 &&\n        var n := ParseInt(parts[0]);\n        var m := ParseInt(parts[1]);\n        n >= 1 && m >= 1\n}\n\nfunction MinLanterns(n: int, m: int): int\n    requires n >= 1 && m >= 1\n{\n    (n * m + 1) / 2\n}\n\npredicate ValidOutput(input: string, output: seq<int>)\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var t := ParseInt(lines[0]);\n    |output| == t &&\n    forall i {:trigger output[i]} :: 0 <= i < t ==>\n        var parts := SplitSpaces(lines[i+1]);\n        |parts| >= 2 &&\n        var n := ParseInt(parts[0]);\n        var m := ParseInt(parts[1]);\n        n >= 1 && m >= 1 &&\n        output[i] == MinLanterns(n, m)\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2602", "vc-description": "Given vanilla cookies (a), chocolate cookies (b), type-1 guests (n), and type-2 guests (m),\ndetermine if there exists an ordering of all guests such that no guest gets angry.\nType-1 guests choose vanilla if v > c, else chocolate.\nType-2 guests choose chocolate if v > c, else vanilla.\nA guest gets angry if their chosen cookie type has 0 cookies available.\n\n// First check: must have enough total cookies\n\n// Second check: type-2 guests are the limiting factor\n\n// They will take from the minority cookie type, so we need\n\n// enough of the minority type to satisfy all type-2 guests", "vc-preamble": "predicate ValidTestCase(a: nat, b: nat, n: nat, m: nat)\n{\n    n + m > 0\n}\n\npredicate CanSatisfyAllGuests(a: nat, b: nat, n: nat, m: nat)\n{\n\n    a + b >= n + m &&\n\n    m <= min(a, b)\n}\n\nfunction min(x: nat, y: nat): nat\n{\n    if x <= y then x else y\n}", "vc-helpers": "", "vc-spec": "method SolveCookieDistribution(a: nat, b: nat, n: nat, m: nat) returns (result: bool)\n    requires ValidTestCase(a, b, n, m)\n    ensures result == CanSatisfyAllGuests(a, b, n, m)\n    ensures result ==> (a + b >= n + m && m <= min(a, b))\n    ensures !result ==> (a + b < n + m || m > min(a, b))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2612", "vc-description": "Find the maximum number of models that can be selected to form a \"beautiful arrangement.\"\nA beautiful arrangement is a subsequence of models arranged in increasing order of their indices,\nwhere for any two adjacent models with indices i and j (i < j), j must be divisible by i\nand the size of model i must be strictly less than the size of model j.\n\n// All indices are distinct\n\n// Indices are in increasing order\n\n// Adjacent elements satisfy divisibility constraint\n\n// Adjacent elements satisfy size constraint", "vc-preamble": "predicate is_valid_beautiful_arrangement(arrangement: seq<int>, sizes: seq<int>)\n    requires forall i :: 0 <= i < |arrangement| ==> 1 <= arrangement[i] <= |sizes|\n{\n    |arrangement| >= 1 &&\n\n    (forall i, j :: 0 <= i < j < |arrangement| ==> arrangement[i] != arrangement[j]) &&\n\n    (forall i :: 0 <= i < |arrangement| - 1 ==> arrangement[i] < arrangement[i + 1]) &&\n\n    (forall i :: 0 <= i < |arrangement| - 1 ==> arrangement[i + 1] % arrangement[i] == 0) &&\n\n    (forall i :: 0 <= i < |arrangement| - 1 ==> sizes[arrangement[i] - 1] < sizes[arrangement[i + 1] - 1])\n}\n\npredicate ValidInput(n: int, sizes: seq<int>)\n{\n    n >= 1 && |sizes| == n && forall i :: 0 <= i < n ==> sizes[i] >= 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, sizes: seq<int>) returns (result: int)\n    requires ValidInput(n, sizes)\n    ensures 1 <= result <= n\n    ensures forall arrangement :: (forall i :: 0 <= i < |arrangement| ==> 1 <= arrangement[i] <= |sizes|) && is_valid_beautiful_arrangement(arrangement, sizes) ==> |arrangement| <= result\n    ensures exists arrangement :: (forall i :: 0 <= i < |arrangement| ==> 1 <= arrangement[i] <= |sizes|) && is_valid_beautiful_arrangement(arrangement, sizes) && |arrangement| == result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2616", "vc-description": "Given n piles of stones, two players alternate turns removing stones from the leftmost non-empty pile.\nThe player who cannot make a move loses. Determine the winner when both players play optimally.", "vc-preamble": "predicate ValidInput(testCases: seq<seq<int>>) {\n    forall i :: 0 <= i < |testCases| ==> \n        |testCases[i]| >= 1 && \n        forall j :: 0 <= j < |testCases[i]| ==> testCases[i][j] >= 1\n}\n\npredicate ValidResults(results: seq<string>) {\n    forall i :: 0 <= i < |results| ==> \n        results[i] == \"First\" || results[i] == \"Second\"\n}\n\nfunction CountLeadingOnes(piles: seq<int>): nat\n    requires forall j :: 0 <= j < |piles| ==> piles[j] >= 1\n{\n    if |piles| == 0 then 0\n    else if piles[0] != 1 then 0\n    else 1 + CountLeadingOnes(piles[1..])\n}\n\npredicate CorrectGameResult(piles: seq<int>, result: string)\n    requires |piles| >= 1\n    requires forall j :: 0 <= j < |piles| ==> piles[j] >= 1\n    requires result == \"First\" || result == \"Second\"\n{\n    var onesCount := |set j | 0 <= j < |piles| && piles[j] == 1|;\n    var allOnes := (onesCount == |piles|);\n    var leadingOnes := CountLeadingOnes(piles);\n    if allOnes then\n        (if onesCount % 2 == 1 then result == \"First\" else result == \"Second\")\n    else\n        (if leadingOnes % 2 == 1 then result == \"Second\" else result == \"First\")\n}", "vc-helpers": "", "vc-spec": "method solve(testCases: seq<seq<int>>) returns (results: seq<string>)\n    requires ValidInput(testCases)\n    ensures |results| == |testCases|\n    ensures ValidResults(results)\n    ensures forall i :: 0 <= i < |testCases| ==> CorrectGameResult(testCases[i], results[i])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2621", "vc-description": "Given n columns with initial heights, determine if a character can move from column 1 to column n.\nCharacter starts at column 1 with m blocks in bag. At each column, character can remove/add blocks\nand move to next column if height difference is at most k.\n\n// Simplified for compilation\n\n// Simplified for compilation", "vc-preamble": "predicate validInput(n: int, m: int, k: int, H: seq<int>)\n{\n    n >= 1 && n == |H| && m >= 0 && k >= 0 && \n    (forall i :: 0 <= i < |H| ==> H[i] >= 0)\n}\n\nfunction canReachEnd(n: int, m: int, k: int, H: seq<int>): bool\n    requires validInput(n, m, k, H)\n{\n    simulateGame(0, m, n, k, H)\n}\n\nfunction simulateGame(pos: int, blocks: int, n: int, k: int, H: seq<int>): bool\n    requires 0 <= pos < n\n    requires n == |H|\n    requires k >= 0\n    requires blocks >= 0\n    requires forall i :: 0 <= i < |H| ==> H[i] >= 0\n    decreases n - pos\n{\n    if pos == n - 1 then\n        true\n    else\n        var h1 := H[pos];\n        var h2 := H[pos + 1];\n        if h1 >= h2 then\n            var newBlocks := if h2 >= k then blocks + (h1 - h2) + k else blocks + h1;\n            simulateGame(pos + 1, newBlocks, n, k, H)\n        else\n            if h2 > h1 + blocks + k then\n                false\n            else\n                var newBlocks := \n                    if h2 <= k then blocks + h1\n                    else if (h2 - h1) <= k then blocks + k - (h2 - h1)\n                    else blocks - (h2 - h1 - k);\n                newBlocks >= 0 && simulateGame(pos + 1, newBlocks, n, k, H)\n}\n\npredicate validCompleteInputFormat(input: string)\n{\n    |input| > 0 && input[|input|-1] == '\\n'\n}\n\npredicate validOutputFormat(output: string, input: string)\n{\n    |output| >= 0 && \n    (output == \"\" || output[|output|-1] == '\\n') &&\n    (forall i :: 0 <= i < |output| ==> output[i] == 'Y' || output[i] == 'E' || output[i] == 'S' || output[i] == 'N' || output[i] == 'O' || output[i] == '\\n')\n}\n\npredicate correctGameResults(output: string, input: string)\n{\n    true\n}\n\npredicate outputMatchesTestCaseCount(output: string, input: string)\n{\n    true\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires stdin_input[|stdin_input|-1] == '\\n'\n    requires validCompleteInputFormat(stdin_input)\n    ensures |result| >= 0\n    ensures forall i :: 0 <= i < |result| ==> result[i] == 'Y' || result[i] == 'E' || result[i] == 'S' || result[i] == 'N' || result[i] == 'O' || result[i] == '\\n'\n    ensures result == \"\" || result[|result|-1] == '\\n'\n    ensures validOutputFormat(result, stdin_input)\n    ensures correctGameResults(result, stdin_input)\n    ensures outputMatchesTestCaseCount(result, stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2622", "vc-description": "Given two maps: First map N \u00d7 M grid, Second map M \u00d7 N grid.\nFind positions i and j such that the M \u00d7 M section from the first map \nstarting at row i equals the M \u00d7 M section from the second map starting at column j.\nOutput the 1-indexed positions i and j.", "vc-preamble": "predicate validInputFormat(input: string)\n{\n    var lines := parseLinesFunc(input);\n    |lines| >= 3 &&\n    var firstLine := parseIntsFunc(lines[0]);\n    |firstLine| >= 2 &&\n    var n := firstLine[0];\n    var m := firstLine[1];\n    n >= 1 && m >= 1 && m <= n &&\n    |lines| >= 1 + n + m &&\n    (forall k :: 1 <= k <= n ==> k < |lines| && |lines[k]| >= m) &&\n    (forall k :: 1 + n <= k < 1 + n + m ==> k < |lines| && |lines[k]| >= n)\n}\n\npredicate validSolution(input: string, result: string)\n{\n    var lines := parseLinesFunc(input);\n    if |lines| < 3 then true else\n    var firstLine := parseIntsFunc(lines[0]);\n    if |firstLine| < 2 then true else\n    var n := firstLine[0];\n    var m := firstLine[1];\n    if n <= 0 || m <= 0 || m > n then true else\n    var resultParts := parseIntsFunc(result);\n    if |resultParts| < 2 then false else\n    var i := resultParts[0];\n    var j := resultParts[1];\n    1 <= i <= n - m + 1 && 1 <= j <= n - m + 1 &&\n    if |lines| >= 1 + n + m then correctSubMatricesMatch(lines, n, m, i - 1, j - 1) else false\n}\n\npredicate solutionExists(input: string)\n{\n    if !validInputFormat(input) then false else\n    var lines := parseLinesFunc(input);\n    var firstLine := parseIntsFunc(lines[0]);\n    var n := firstLine[0];\n    var m := firstLine[1];\n    exists i, j :: (0 <= i <= n - m && 0 <= j <= n - m &&\n        correctSubMatricesMatch(lines, n, m, i, j))\n}\n\npredicate solutionFound(input: string, result: string)\n{\n    validSolution(input, result) &&\n    if !validInputFormat(input) then false else\n    var lines := parseLinesFunc(input);\n    var firstLine := parseIntsFunc(lines[0]);\n    var n := firstLine[0];\n    var m := firstLine[1];\n    var resultParts := parseIntsFunc(result);\n    if |resultParts| >= 2 then\n        var i := resultParts[0] - 1;\n        var j := resultParts[1] - 1;\n        correctSubMatricesMatch(lines, n, m, i, j)\n    else false\n}\n\npredicate correctMatrixMatching(input: string, result: string)\n{\n    if !validInputFormat(input) then true else\n    var lines := parseLinesFunc(input);\n    var firstLine := parseIntsFunc(lines[0]);\n    var n := firstLine[0];\n    var m := firstLine[1];\n    var resultParts := parseIntsFunc(result);\n    if |resultParts| >= 2 then\n        var i := resultParts[0] - 1;\n        var j := resultParts[1] - 1;\n        0 <= i <= n - m && 0 <= j <= n - m &&\n        (forall r, c {:trigger lines[1 + i + r][c]} {:trigger lines[1 + n + r][j + c]} :: (0 <= r < m && 0 <= c < m) ==>\n            (1 + i + r < |lines| && c < |lines[1 + i + r]| &&\n            r < m && 1 + n + r < |lines| && j + c < |lines[1 + n + r]|) ==>\n            lines[1 + i + r][c] == lines[1 + n + r][j + c])\n    else false\n}\n\npredicate alwaysReturnsFirstMatch(input: string, result: string)\n{\n    if !validInputFormat(input) then true else\n    var lines := parseLinesFunc(input);\n    var firstLine := parseIntsFunc(lines[0]);\n    var n := firstLine[0];\n    var m := firstLine[1];\n    var resultParts := parseIntsFunc(result);\n    if |resultParts| >= 2 then\n        var resultI := resultParts[0] - 1;\n        var resultJ := resultParts[1] - 1;\n        forall i, j {:trigger correctSubMatricesMatch(lines, n, m, i, j)} :: (0 <= i <= n - m && 0 <= j <= n - m &&\n            (i < resultI || (i == resultI && j < resultJ))) ==>\n            !correctSubMatricesMatch(lines, n, m, i, j)\n    else false\n}\n\npredicate correctSubMatricesMatch(lines: seq<string>, n: int, m: int, i: int, j: int)\n    requires |lines| >= 1 + n + m\n    requires 0 <= i <= n - m && 0 <= j <= n - m\n{\n    forall r, c {:trigger lines[1 + i + r][c]} {:trigger lines[1 + n + r][j + c]} :: (0 <= r < m && 0 <= c < m) ==>\n        (1 + i + r < |lines| && c < |lines[1 + i + r]| &&\n        1 + n + r < |lines| && j + c < |lines[1 + n + r]|) ==>\n        lines[1 + i + r][c] == lines[1 + n + r][j + c]\n}\n\nfunction parseLinesFunc(input: string): seq<string>\n{\n    [\"\"]\n}\n\nfunction parseIntsFunc(line: string): seq<int>\n{\n    [1, 1]\n}\n\nfunction intToStringFunc(n: int): string\n    ensures |intToStringFunc(n)| > 0\n{\n    if n == 0 then \"0\"\n    else if n == 1 then \"1\"\n    else if n == 2 then \"2\"\n    else if n == 3 then \"3\"\n    else if n == 4 then \"4\"\n    else if n == 5 then \"5\"\n    else if n == 6 then \"6\"\n    else if n == 7 then \"7\"\n    else if n == 8 then \"8\"\n    else if n == 9 then \"9\"\n    else \"10\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires validInputFormat(stdin_input)\n    ensures |result| > 0\n    ensures exists i, j :: i >= 1 && j >= 1 && result == intToStringFunc(i) + \" \" + intToStringFunc(j)\n    ensures validSolution(stdin_input, result)\n    ensures solutionExists(stdin_input) ==> solutionFound(stdin_input, result)\n    ensures correctMatrixMatching(stdin_input, result)\n    ensures alwaysReturnsFirstMatch(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2627", "vc-description": "Given a 2D binary matrix containing only \"0\"s and \"1\"s, find the area of the largest rectangle that contains only \"1\"s.", "vc-preamble": "predicate ValidMatrix(matrix: seq<seq<string>>)\n{\n    (forall i :: 0 <= i < |matrix| ==> |matrix[i]| == (if |matrix| == 0 then 0 else |matrix[0]|)) &&\n    (forall i, j :: 0 <= i < |matrix| && 0 <= j < |matrix[i]| ==> matrix[i][j] == \"0\" || matrix[i][j] == \"1\")\n}\n\nfunction MaxPossibleArea(matrix: seq<seq<string>>): int\n{\n    |matrix| * (if |matrix| == 0 then 0 else |matrix[0]|)\n}\n\npredicate EmptyMatrix(matrix: seq<seq<string>>)\n{\n    |matrix| == 0 || |matrix[0]| == 0\n}", "vc-helpers": "", "vc-spec": "method maximalRectangle(matrix: seq<seq<string>>) returns (result: int)\n    requires ValidMatrix(matrix)\n    ensures result >= 0\n    ensures EmptyMatrix(matrix) ==> result == 0\n    ensures result <= MaxPossibleArea(matrix)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2629", "vc-description": "Given a positive integer n, create an n\u00d7n matrix filled with integers from 1 to n\u00b2 \narranged in clockwise spiral order, starting from the top-left corner.\n\n// Top row of current layer\n\n// Right column of current layer\n\n// Bottom row of current layer\n\n// Left column of current layer", "vc-preamble": "function min(a: int, b: int): int\n{\n  if a <= b then a else b\n}\n\nfunction SpiralOrder(row: int, col: int, n: int): int\n  requires 0 <= row < n && 0 <= col < n && n >= 1\n  decreases n - 2 * min(min(row, col), min(n-1-row, n-1-col)) - 1\n{\n  var layer := min(min(row, col), min(n-1-row, n-1-col));\n  var layerStart := 4 * layer * (n - layer - 1) + layer;\n\n  if row == layer then\n\n    layerStart + (col - layer)\n  else if col == n - 1 - layer then\n\n    layerStart + (n - 2 * layer - 1) + (row - layer)\n  else if row == n - 1 - layer then\n\n    layerStart + 2 * (n - 2 * layer - 1) + (n - 1 - layer - col)\n  else\n\n    layerStart + 3 * (n - 2 * layer - 1) + (n - 1 - layer - row)\n}\n\npredicate ValidInput(n: int)\n{\n  n >= 1\n}\n\npredicate ValidSpiralMatrix(matrix: array2<int>, n: int)\n  reads matrix\n{\n  matrix.Length0 == n && matrix.Length1 == n &&\n  (forall i, j :: 0 <= i < n && 0 <= j < n ==> matrix[i, j] == SpiralOrder(i, j, n) + 1)\n}", "vc-helpers": "", "vc-spec": "method generateMatrix(n: int) returns (matrix: array2<int>)\n  requires ValidInput(n)\n  ensures ValidSpiralMatrix(matrix, n)\n  ensures matrix.Length0 == n && matrix.Length1 == n\n  ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> 1 <= matrix[i, j] <= n * n\n  ensures forall v :: 1 <= v <= n * n ==> exists i, j :: 0 <= i < n && 0 <= j < n && matrix[i, j] == v", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_263", "vc-description": "Given n benches with initial occupancies and m additional people to seat,\nfind the minimum and maximum possible values of k, where k is the maximum\noccupancy of any single bench after all m people are seated.\nFor minimum k: distribute people as evenly as possible.\nFor maximum k: add all m people to the bench with current maximum occupancy.", "vc-preamble": "predicate ValidInput(n: nat, m: nat, benches: seq<nat>)\n{\n    n > 0 && m > 0 && |benches| == n && forall i :: 0 <= i < n ==> benches[i] > 0\n}\n\nfunction max_seq(s: seq<nat>): nat\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= max_seq(s[1..]) then s[0]\n    else max_seq(s[1..])\n}\n\nfunction sum_seq(s: seq<nat>): nat\n{\n    if |s| == 0 then 0\n    else s[0] + sum_seq(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, m: nat, benches: seq<nat>) returns (minimum: nat, maximum: nat)\n    requires ValidInput(n, m, benches)\n    ensures maximum == max_seq(benches) + m\n    ensures var total := sum_seq(benches) + m;\n            var current_max := max_seq(benches);\n            if total <= current_max * n then minimum == current_max\n            else minimum == (total + n - 1) / n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2630", "vc-description": "Given an m\u00d7n grid where 0 represents empty cell and 1 represents obstacle,\nfind the number of unique paths from top-left (0,0) to bottom-right (m-1,n-1).\nMovement is restricted to right and down only, cannot pass through obstacles.", "vc-preamble": "predicate ValidGrid(grid: seq<seq<int>>)\n{\n    |grid| > 0 && |grid[0]| > 0 &&\n    (forall i :: 0 <= i < |grid| ==> |grid[i]| == |grid[0]|) &&\n    (forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[i]| ==> grid[i][j] in {0, 1})\n}\n\nfunction DPPathCount(grid: seq<seq<int>>): int\n    requires ValidGrid(grid)\n    ensures DPPathCount(grid) >= 0\n    ensures grid[0][0] == 1 ==> DPPathCount(grid) == 0\n    ensures grid[|grid|-1][|grid[0]|-1] == 1 ==> DPPathCount(grid) == 0\n    ensures |grid| == 1 && |grid[0]| == 1 ==> \n            DPPathCount(grid) == (if grid[0][0] == 0 then 1 else 0)\n    ensures (forall i, j :: 0 <= i < |grid| && 0 <= j < |grid[0]| ==> grid[i][j] == 0) ==> \n            DPPathCount(grid) == Binomial(|grid| + |grid[0]| - 2, |grid| - 1)\n    ensures |grid| == 1 ==> \n            (DPPathCount(grid) > 0 <==> (forall j :: 0 <= j < |grid[0]| ==> grid[0][j] == 0))\n    ensures |grid[0]| == 1 ==> \n            (DPPathCount(grid) > 0 <==> (forall i :: 0 <= i < |grid| ==> grid[i][0] == 0))\n{\n    var m := |grid|;\n    var n := |grid[0]|;\n    if grid[0][0] == 1 || grid[m-1][n-1] == 1 then 0\n    else \n        if m == 1 && n == 1 then 1\n        else if m == 1 then \n            if forall j :: 0 <= j < n ==> grid[0][j] == 0 then 1 else 0\n        else if n == 1 then\n            if forall i :: 0 <= i < m ==> grid[i][0] == 0 then 1 else 0\n        else if forall i, j :: 0 <= i < m && 0 <= j < n ==> grid[i][j] == 0 then\n            Binomial(m + n - 2, m - 1)\n        else\n            var path := InitializePath(grid);\n            ComputePaths(grid, path, m, n)\n}\n\nfunction Binomial(n: int, k: int): int\n    requires n >= 0 && k >= 0\n    ensures Binomial(n, k) >= 0\n    decreases n, k\n{\n    if k > n then 0\n    else if k == 0 || k == n then 1\n    else if k == 1 then n\n    else Binomial(n-1, k-1) + Binomial(n-1, k)\n}", "vc-helpers": "", "vc-spec": "method uniquePathsWithObstacles(obstacleGrid: seq<seq<int>>) returns (result: int)\n    requires ValidGrid(obstacleGrid)\n    ensures result >= 0\n    ensures obstacleGrid[0][0] == 1 ==> result == 0\n    ensures obstacleGrid[|obstacleGrid|-1][|obstacleGrid[0]|-1] == 1 ==> result == 0\n    ensures |obstacleGrid| == 1 && |obstacleGrid[0]| == 1 ==> \n            result == (if obstacleGrid[0][0] == 0 then 1 else 0)\n    ensures result == DPPathCount(obstacleGrid)\n    ensures (forall i, j :: 0 <= i < |obstacleGrid| && 0 <= j < |obstacleGrid[0]| ==> obstacleGrid[i][j] == 0) ==> \n            result == Binomial(|obstacleGrid| + |obstacleGrid[0]| - 2, |obstacleGrid| - 1)\n    ensures |obstacleGrid| == 1 ==> \n            (result > 0 <==> (forall j :: 0 <= j < |obstacleGrid[0]| ==> obstacleGrid[0][j] == 0))\n    ensures |obstacleGrid[0]| == 1 ==> \n            (result > 0 <==> (forall i :: 0 <= i < |obstacleGrid| ==> obstacleGrid[i][0] == 0))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2632", "vc-description": "Given an m\u00d7n grid of non-negative integers, find the minimum sum path from the top-left corner \nto the bottom-right corner. You can only move right or down.\n\n// right\n\n// down", "vc-preamble": "predicate ValidPath(path: seq<(int, int)>, m: int, n: int)\n{\n    |path| >= 1 &&\n    path[0] == (0, 0) &&\n    path[|path|-1] == (m-1, n-1) &&\n    (forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < m && 0 <= path[i].1 < n) &&\n    forall i :: 0 <= i < |path|-1 ==> \n        (path[i+1].0 == path[i].0 && path[i+1].1 == path[i].1 + 1) ||\n        (path[i+1].0 == path[i].0 + 1 && path[i+1].1 == path[i].1)\n}\n\nfunction PathSum(path: seq<(int, int)>, grid: array2<int>): int\n    requires forall i :: 0 <= i < |path| ==> 0 <= path[i].0 < grid.Length0 && 0 <= path[i].1 < grid.Length1\n    reads grid\n{\n    if |path| == 0 then 0\n    else grid[path[0].0, path[0].1] + PathSum(path[1..], grid)\n}\n\npredicate ValidInput(grid: array2<int>)\n    reads grid\n{\n    grid.Length0 > 0 && grid.Length1 > 0 &&\n    forall i, j :: 0 <= i < grid.Length0 && 0 <= j < grid.Length1 ==> grid[i, j] >= 0\n}", "vc-helpers": "", "vc-spec": "method minPathSum(grid: array2<int>) returns (result: int)\n    requires ValidInput(grid)\n    ensures result >= 0\n    ensures grid.Length0 == 1 && grid.Length1 == 1 ==> result == grid[0, 0]", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2633", "vc-description": "Find the minimum initial health required for a character to travel from the top-left \ncorner to the bottom-right corner of an M x N grid. The character can only move right \nor down, and dies if health drops to 0 or below at any point.", "vc-preamble": "predicate ValidDungeon(dungeon: seq<seq<int>>)\n{\n    |dungeon| > 0 &&\n    (forall i :: 0 <= i < |dungeon| ==> |dungeon[i]| > 0) &&\n    (forall i :: 0 <= i < |dungeon| ==> |dungeon[i]| == |dungeon[0]|)\n}\n\npredicate isValidPath(dungeon: seq<seq<int>>, path: seq<(int, int)>)\n    requires ValidDungeon(dungeon)\n{\n    |path| > 0 &&\n    path[0] == (0, 0) &&\n    path[|path|-1] == (|dungeon|-1, |dungeon[0]|-1) &&\n    (forall i :: 0 <= i < |path| ==> \n        var (r, c) := path[i];\n        0 <= r < |dungeon| && 0 <= c < |dungeon[0]|) &&\n    forall i :: 0 <= i < |path|-1 ==> \n        (path[i].1 == path[i+1].1 && path[i].0 + 1 == path[i+1].0) ||\n        (path[i].0 == path[i+1].0 && path[i].1 + 1 == path[i+1].1)\n}\n\nfunction healthAtStep(dungeon: seq<seq<int>>, path: seq<(int, int)>, step: int, initialHealth: int): int\n    requires ValidDungeon(dungeon)\n    requires isValidPath(dungeon, path)\n    requires 0 <= step < |path|\n    decreases step\n{\n    if step == 0 then \n        var (r, c) := path[0];\n        initialHealth + dungeon[r][c]\n    else\n        var (r, c) := path[step];\n        healthAtStep(dungeon, path, step-1, initialHealth) + dungeon[r][c]\n}\n\npredicate canSurvivePath(dungeon: seq<seq<int>>, path: seq<(int, int)>, initialHealth: int)\n    requires ValidDungeon(dungeon)\n    requires isValidPath(dungeon, path)\n{\n    forall i :: 0 <= i < |path| ==> \n        healthAtStep(dungeon, path, i, initialHealth) > 0\n}", "vc-helpers": "", "vc-spec": "method calculateMinimumHP(dungeon: seq<seq<int>>) returns (result: int)\n    requires ValidDungeon(dungeon)\n    ensures result >= 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2647", "vc-description": "Given an H\u00d7W grid where each cell is either black (#) or white (.), find the maximum number \nof white cells that can be changed to black such that a path still exists from cell (1,1) to \ncell (H,W). Movement is allowed only through white cells in 4 directions. Cells (1,1) and \n(H,W) cannot be changed and must be white. Return -1 if no path exists initially.\n\n// Simplified for placeholder", "vc-preamble": "predicate isValidInput(input: string)\n{\n    |input| > 0 &&\n    true\n}\n\npredicate isValidOutput(output: string)\n{\n    |output| > 0 &&\n    (output == \"-1\\n\" || \n     (output != \"-1\\n\" && |output| > 1 && output[|output|-1] == '\\n'))\n}\n\ndatatype GridData = GridData(h: int, w: int, cells: seq<seq<char>>)\n\npredicate validGrid(grid: GridData)\n{\n    grid.h > 0 && grid.w > 0 && \n    |grid.cells| == grid.h &&\n    (forall i :: 0 <= i < grid.h ==> |grid.cells[i]| == grid.w) &&\n    (forall i, j :: 0 <= i < grid.h && 0 <= j < grid.w ==> \n        grid.cells[i][j] == '.' || grid.cells[i][j] == '#') &&\n    grid.cells[0][0] == '.' && grid.cells[grid.h-1][grid.w-1] == '.'\n}\n\nfunction parseInput(input: string): GridData\n    requires isValidInput(input)\n    ensures validGrid(parseInput(input))\n{\n    GridData(1, 1, [['.']])\n}\n\npredicate pathExists(grid: GridData)\n    requires validGrid(grid)\n{\n    true\n}\n\nfunction maxChangeableWhiteCells(grid: GridData): int\n    requires validGrid(grid)\n    requires pathExists(grid)\n    ensures 0 <= maxChangeableWhiteCells(grid) <= countWhiteCells(grid) - 2\n    ensures maxChangeableWhiteCells(grid) == countWhiteCells(grid) - minCutSize(grid)\n{\n    0\n}\n\nfunction countWhiteCells(grid: GridData): int\n    requires validGrid(grid)\n    ensures countWhiteCells(grid) >= 2\n{\n    2\n}\n\nfunction minCutSize(grid: GridData): int\n    requires validGrid(grid)\n    requires pathExists(grid)\n    ensures minCutSize(grid) >= 2\n    ensures minCutSize(grid) <= countWhiteCells(grid)\n{\n    2\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires |stdin_input| > 0\n    requires isValidInput(stdin_input)\n    ensures isValidOutput(output)\n    ensures output == \"-1\\n\" || \n            (exists result: int :: result >= 0 && output == intToString(result) + \"\\n\")\n    ensures output == \"-1\\n\" <==> !pathExists(parseInput(stdin_input))\n    ensures output != \"-1\\n\" ==> \n            (exists result: int, grid: GridData :: \n                grid == parseInput(stdin_input) &&\n                result == maxChangeableWhiteCells(grid) &&\n                output == intToString(result) + \"\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_2659", "vc-description": "Given S(n) as the sum of digits in decimal notation of integer n, an integer n is called a \"Snuke number\" \nif for all positive integers m > n, the inequality n/S(n) \u2264 m/S(m) holds.\nGiven an integer K, find the K smallest Snuke numbers.", "vc-preamble": "function SumOfDigits(n: int): int\n  requires n >= 0\n{\n  if n < 10 then n\n  else (n % 10) + SumOfDigits(n / 10)\n}\n\npredicate ValidOutput(result: seq<int>, k: int)\n{\n  |result| == k &&\n  (forall i :: 0 <= i < k ==> result[i] > 0) &&\n  (forall i :: 0 <= i < k - 1 ==> result[i] < result[i + 1]) &&\n  (k >= 1 ==> result[0] == 1) &&\n  (k >= 2 ==> result[1] == 2) &&\n  (k >= 3 ==> result[2] == 3) &&\n  (k >= 4 ==> result[3] == 4) &&\n  (k >= 5 ==> result[4] == 5) &&\n  (k >= 6 ==> result[5] == 6) &&\n  (k >= 7 ==> result[6] == 7) &&\n  (k >= 8 ==> result[7] == 8) &&\n  (k >= 9 ==> result[8] == 9) &&\n  (k >= 10 ==> result[9] == 19)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int) returns (result: seq<int>)\n  requires k >= 1\n  ensures ValidOutput(result, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_27", "vc-description": "Given a string s of n lowercase Latin letters, find the minimum number of operations\nto construct it starting from an empty string. Operations are: (1) add one character\nto the end (unlimited use), (2) copy current string and append it to itself (at most once).", "vc-preamble": "predicate ValidInput(n: nat, s: string)\n{\n    |s| == n\n}\n\nfunction MaxCopySavings(s: string, n: nat): nat\n    requires |s| == n\n    ensures MaxCopySavings(s, n) <= n / 2\n{\n    MaxCopySavingsUpTo(s, n, n / 2)\n}\n\nfunction MaxCopySavingsUpTo(s: string, n: nat, limit: nat): nat\n    requires |s| == n\n    requires limit <= n / 2\n    ensures MaxCopySavingsUpTo(s, n, limit) <= limit\n    decreases limit\n{\n    if limit == 0 then 0\n    else\n        var i := limit - 1;\n        var current := if CanCopyAt(s, n, i) then i else 0;\n        var prev := MaxCopySavingsUpTo(s, n, i);\n        if current > prev then current else prev\n}\n\npredicate CanCopyAt(s: string, n: nat, i: nat)\n    requires |s| == n\n    requires i < n / 2\n{\n    var prefix_len := i + 1;\n    var end_pos := i + 1 + prefix_len;\n    end_pos <= n && s[0..prefix_len] == s[i+1..end_pos]\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, s: string) returns (result: nat)\n    requires ValidInput(n, s)\n    ensures result <= n\n    ensures n == 0 ==> result == 0\n    ensures n > 0 ==> result >= 1\n    ensures result == n - MaxCopySavings(s, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_271", "vc-description": "Given a non-negative integer n, round it to the nearest integer that ends with 0.\nIf n already ends with 0, return n unchanged. When there are two equally distant\noptions (when the last digit is 5), use banker's rounding (round half to even).", "vc-preamble": "predicate ValidResult(n: int, result: int)\n  requires n >= 0\n{\n  var quotient := n / 10;\n  var remainder := n % 10;\n  result % 10 == 0 && \n  result >= 0 &&\n  (remainder < 5 ==> result == quotient * 10) &&\n  (remainder > 5 ==> result == (quotient + 1) * 10) &&\n  (remainder == 5 ==> (quotient % 2 == 0 ==> result == quotient * 10) && \n                      (quotient % 2 == 1 ==> result == (quotient + 1) * 10))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n  requires n >= 0\n  ensures ValidResult(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_287", "vc-description": "Given n apartments numbered 1 to n arranged in a row, with exactly k apartments already inhabited,\nfind the minimum and maximum possible number of \"good\" apartments. A good apartment is one that is\navailable for sale (not inhabited) and has at least one inhabited apartment adjacent to it.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 0 && k <= n\n}\n\npredicate ValidOutput(result: seq<int>, n: int, k: int)\n{\n    |result| == 2 && \n    result[0] >= 0 && \n    result[1] >= 0 && \n    result[0] <= result[1] &&\n    result[0] <= n - k &&\n    result[1] <= n - k\n}\n\nfunction MinGoodApartments(n: int, k: int): int\n    requires ValidInput(n, k)\n{\n    if k == 0 || k == n then 0 else 1\n}\n\nfunction MaxGoodApartments(n: int, k: int): int\n    requires ValidInput(n, k)\n{\n    if k == 0 || k == n then 0\n    else if n - k < k * 2 then n - k\n    else k * 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: seq<int>)\n    requires ValidInput(n, k)\n    ensures ValidOutput(result, n, k)\n    ensures result[0] == MinGoodApartments(n, k)\n    ensures result[1] == MaxGoodApartments(n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_29", "vc-description": "Given a 6-digit ticket (string of digits 0-9), find the minimum number of digit replacements needed to make it \"lucky\".\nA ticket is lucky when the sum of its first three digits equals the sum of its last three digits.\nAny digit can be replaced with any digit 0-9.", "vc-preamble": "function charToInt(c: char): int\n  requires '0' <= c <= '9'\n{\n  c as int - '0' as int\n}\n\nfunction isLucky(digits: seq<int>): bool\n  requires |digits| == 6\n  requires forall i :: 0 <= i < |digits| ==> 0 <= digits[i] <= 9\n{\n  var sum1 := digits[0] + digits[1] + digits[2];\n  var sum2 := digits[3] + digits[4] + digits[5];\n  sum1 == sum2\n}\n\npredicate ValidTicket(ticket: string)\n{\n  |ticket| == 6 && forall i :: 0 <= i < |ticket| ==> '0' <= ticket[i] <= '9'\n}\n\npredicate canMakeLuckyWith0Changes(digits: seq<int>)\n  requires |digits| == 6\n  requires forall i :: 0 <= i < |digits| ==> 0 <= digits[i] <= 9\n{\n  isLucky(digits)\n}\n\npredicate canMakeLuckyWith1Change(digits: seq<int>)\n  requires |digits| == 6\n  requires forall i :: 0 <= i < |digits| ==> 0 <= digits[i] <= 9\n{\n  exists pos :: 0 <= pos < 6 &&\n    exists newDigit :: 0 <= newDigit <= 9 &&\n      var newDigits := digits[..pos] + [newDigit] + digits[pos+1..];\n      isLucky(newDigits)\n}\n\npredicate canMakeLuckyWith2Changes(digits: seq<int>)\n  requires |digits| == 6\n  requires forall i :: 0 <= i < |digits| ==> 0 <= digits[i] <= 9\n{\n  exists i, j :: 0 <= j < i < 6 &&\n    exists k, l :: 0 <= k <= 9 && 0 <= l <= 9 &&\n      var newDigits := digits[..i] + [k] + digits[i+1..];\n      var finalDigits := newDigits[..j] + [l] + newDigits[j+1..];\n      isLucky(finalDigits)\n}", "vc-helpers": "", "vc-spec": "method solve(ticket: string) returns (result: int)\n  requires ValidTicket(ticket)\n  ensures 0 <= result <= 3\n  ensures var digits := seq(6, i requires 0 <= i < 6 => charToInt(ticket[i]));\n          result == 0 <==> canMakeLuckyWith0Changes(digits)\n  ensures var digits := seq(6, i requires 0 <= i < 6 => charToInt(ticket[i]));\n          result == 1 <==> (!canMakeLuckyWith0Changes(digits) && canMakeLuckyWith1Change(digits))\n  ensures var digits := seq(6, i requires 0 <= i < 6 => charToInt(ticket[i]));\n          result == 2 <==> (!canMakeLuckyWith0Changes(digits) && !canMakeLuckyWith1Change(digits) && canMakeLuckyWith2Changes(digits))\n  ensures var digits := seq(6, i requires 0 <= i < 6 => charToInt(ticket[i]));\n          result == 3 <==> (!canMakeLuckyWith0Changes(digits) && !canMakeLuckyWith1Change(digits) && !canMakeLuckyWith2Changes(digits))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_291", "vc-description": "Given two initial weights a and b where a \u2264 b, determine after how many years \nLimak (starting weight a) becomes strictly heavier than Bob (starting weight b).\nEach year, Limak's weight triples and Bob's weight doubles.", "vc-preamble": "function pow(base: int, exp: int): int\n  requires exp >= 0\n  ensures exp == 0 ==> pow(base, exp) == 1\n  ensures exp > 0 && base > 0 ==> pow(base, exp) > 0\n  ensures exp > 0 && base == 0 ==> pow(base, exp) == 0\n{\n  if exp == 0 then 1\n  else base * pow(base, exp - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (years: int)\n  requires 1 <= a <= b <= 10\n  ensures years >= 0\n  ensures a * pow(3, years) > b * pow(2, years)\n  ensures years == 0 || a * pow(3, years - 1) <= b * pow(2, years - 1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_298", "vc-description": "Two players take turns removing exactly k consecutive sticks from either end of a row of n sticks.\nThe first player moves first. The game ends when fewer than k sticks remain.\nDetermine if the first player wins by making strictly more moves than the second player.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    k >= 1 && n >= 1 && k <= n\n}\n\nfunction TotalMoves(n: int, k: int): int\n    requires ValidInput(n, k)\n{\n    n / k\n}\n\npredicate FirstPlayerWins(n: int, k: int)\n    requires ValidInput(n, k)\n{\n    TotalMoves(n, k) % 2 == 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: string)\n    requires ValidInput(n, k)\n    ensures FirstPlayerWins(n, k) ==> result == \"YES\"\n    ensures !FirstPlayerWins(n, k) ==> result == \"NO\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_299", "vc-description": "Given n exercises with repetition counts, determine which muscle group receives the most total repetitions.\nExercises cycle through three types based on position (0-indexed):\n- Position 0, 3, 6, ... : chest exercises\n- Position 1, 4, 7, ... : biceps exercises  \n- Position 2, 5, 8, ... : back exercises\nReturn the muscle group with the highest total repetitions.", "vc-preamble": "function ChestTotal(reps: seq<int>): int\n{\n    sum(seq(|reps|, i requires 0 <= i < |reps| => if i % 3 == 0 then reps[i] else 0))\n}\n\nfunction BicepsTotal(reps: seq<int>): int\n{\n    sum(seq(|reps|, i requires 0 <= i < |reps| => if i % 3 == 1 then reps[i] else 0))\n}\n\nfunction BackTotal(reps: seq<int>): int\n{\n    sum(seq(|reps|, i requires 0 <= i < |reps| => if i % 3 == 2 then reps[i] else 0))\n}\n\npredicate ValidInput(reps: seq<int>)\n{\n    |reps| > 0 && forall i | 0 <= i < |reps| :: reps[i] > 0\n}\n\npredicate IsWinner(muscle: string, reps: seq<int>)\n    requires ValidInput(reps)\n{\n    var chestTotal := ChestTotal(reps);\n    var bicepsTotal := BicepsTotal(reps);\n    var backTotal := BackTotal(reps);\n\n    match muscle\n        case \"chest\" => chestTotal >= bicepsTotal && chestTotal >= backTotal\n        case \"biceps\" => bicepsTotal > chestTotal && bicepsTotal >= backTotal\n        case \"back\" => backTotal > chestTotal && backTotal > bicepsTotal\n        case _ => false\n}", "vc-helpers": "", "vc-spec": "method FindStrongestMuscleGroup(reps: seq<int>) returns (result: string)\n    requires ValidInput(reps)\n    ensures result == \"chest\" || result == \"biceps\" || result == \"back\"\n    ensures IsWinner(result, reps)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_302", "vc-description": "Given a positive integer n, find the minimum number of digit 1s needed to represent n \nas a sum and/or difference of repunits (numbers containing only 1s: 1, 11, 111, 1111, ...).\n\n// simplified for larger values", "vc-preamble": "function pow(base: nat, exp: nat): nat\n{\n    if exp == 0 then 1 else base * pow(base, exp - 1)\n}\n\nfunction repunit(n: nat): nat\n    requires n >= 0\n    ensures n == 0 ==> repunit(n) == 0\n    ensures n > 0 ==> repunit(n) > 0\n{\n    if n == 0 then 0 \n    else if n == 1 then 1\n    else if n == 2 then 11\n    else if n == 3 then 111\n    else if n == 4 then 1111\n    else if n == 5 then 11111\n    else n\n}\n\npredicate ValidInput(n: nat)\n{\n    true\n}\n\npredicate ValidOutput(n: nat, result: nat)\n{\n    (n == 0 ==> result == 0) &&\n    (n > 0 ==> result > 0)\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_307", "vc-description": "Given k_2 digits '2', k_3 digits '3', k_5 digits '5', and k_6 digits '6',\nform integers 32 and 256 to maximize their sum. Each digit can only be used once.\nTo form 256: need one '2', one '5', one '6'\nTo form 32: need one '3', one '2'", "vc-preamble": "predicate ValidInput(k2: int, k3: int, k5: int, k6: int)\n{\n    k2 >= 0 && k3 >= 0 && k5 >= 0 && k6 >= 0 &&\n    k2 <= 5000000 && k3 <= 5000000 && k5 <= 5000000 && k6 <= 5000000\n}\n\nfunction OptimalSum(k2: int, k3: int, k5: int, k6: int): int\n    requires ValidInput(k2, k3, k5, k6)\n{\n    var count256 := min(min(k2, k5), k6);\n    var remaining_k2 := k2 - count256;\n    var count32 := min(k3, remaining_k2);\n    256 * count256 + 32 * count32\n}", "vc-helpers": "", "vc-spec": "method solve(k2: int, k3: int, k5: int, k6: int) returns (result: int)\n    requires ValidInput(k2, k3, k5, k6)\n    ensures result >= 0\n    ensures result == OptimalSum(k2, k3, k5, k6)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_315", "vc-description": "Given n consecutive days and a minimum requirement k, find the minimum additional walks needed\nso that for any two consecutive days, the total walks is at least k. Can only increase walks.", "vc-preamble": "function sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\npredicate ValidInput(n: int, k: int, a: seq<int>)\n{\n    n >= 1 && |a| == n && k >= 0 && forall i :: 0 <= i < n ==> a[i] >= 0\n}\n\npredicate ValidOutput(a: seq<int>, finalSchedule: seq<int>, additionalWalks: int, k: int)\n{\n    |finalSchedule| == |a| &&\n    additionalWalks >= 0 &&\n    forall i :: 0 <= i < |a| ==> finalSchedule[i] >= a[i] &&\n    forall i :: 0 <= i < |a| - 1 ==> finalSchedule[i] + finalSchedule[i + 1] >= k &&\n    additionalWalks == sum(finalSchedule) - sum(a)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, a: seq<int>) returns (additionalWalks: int, finalSchedule: seq<int>)\n    requires ValidInput(n, k, a)\n    ensures ValidOutput(a, finalSchedule, additionalWalks, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_3805", "vc-description": "Two wires run from left to right between a wall and device. Given a string of '+' and '-' \nrepresenting wire crossings, determine if wires can be untangled by free movement without\nunplugging. Uses stack algorithm where same adjacent characters cancel out.", "vc-preamble": "function ExtractFirstLine(input: string): string\n{\n    if |input| == 0 then \"\"\n    else if input[0] == '\\n' then \"\"\n    else \n        var rest := ExtractFirstLine(input[1..]);\n        [input[0]] + rest\n}\n\nfunction ProcessString(input: string, stack: seq<char>): seq<char>\n{\n    if |input| == 0 then stack\n    else\n        var c := input[0];\n        var newStack := if |stack| > 0 && stack[|stack| - 1] == c \n                       then stack[..|stack| - 1] \n                       else stack + [c];\n        ProcessString(input[1..], newStack)\n}\n\npredicate StackAlgorithmResultsInEmptyStack(input: string)\n{\n    var stack := ProcessString(input, []);\n    |stack| == 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    ensures result == \"Yes\\n\" || result == \"No\\n\"\n    ensures result == \"Yes\\n\" <==> StackAlgorithmResultsInEmptyStack(ExtractFirstLine(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4088", "vc-description": "Given a string s of lowercase letters and an array b, find a string t such that:\n1. t is formed by removing some characters from s and rearranging the remaining characters\n2. For each position i in t, b[i] equals the sum of distances |i-j| to all positions j where t[j] > t[i] lexicographically\nProcess multiple test cases from stdin input and return formatted results", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n    |input| > 0 && \n    exists lines: seq<string> ::\n        lines == SplitLines(input) &&\n        |lines| >= 1 &&\n        IsValidInteger(lines[0]) &&\n        var t := StringToInt(lines[0]);\n        1 <= t <= 100 &&\n        |lines| >= 1 + 3*t &&\n        forall i :: 0 <= i < t ==> \n            var base_idx := 1 + 3*i;\n            base_idx + 2 < |lines| &&\n            IsValidString(lines[base_idx]) &&\n            IsValidInteger(lines[base_idx + 1]) &&\n            IsValidIntegerArray(lines[base_idx + 2]) &&\n            var s := lines[base_idx];\n            var m := StringToInt(lines[base_idx + 1]);\n            var b_array := ParseIntegerArray(lines[base_idx + 2]);\n            1 <= |s| <= 50 &&\n            (forall j :: 0 <= j < |s| ==> 'a' <= s[j] <= 'z') &&\n            1 <= m <= |s| &&\n            |b_array| == m &&\n            forall k :: 0 <= k < m ==> 0 <= b_array[k] <= 1225\n}\n\npredicate ValidOutputFormat(output: string, input: string)\n    requires ValidInputFormat(input)\n{\n    var test_cases := GetTestCases(input);\n    |test_cases| > 0 ==> \n    exists output_lines: seq<string> ::\n        output_lines == SplitLines(output) &&\n        |output_lines| >= |test_cases| &&\n        forall i :: 0 <= i < |test_cases| ==> \n            var (s, m, b) := test_cases[i];\n            i < |output_lines| &&\n            |output_lines[i]| == m &&\n            forall j :: 0 <= j < |output_lines[i]| ==> 'a' <= output_lines[i][j] <= 'z'\n}\n\npredicate OutputSatisfiesConstraints(output: string, input: string)\n    requires ValidInputFormat(input)\n{\n    var test_cases := GetTestCases(input);\n    var output_lines := SplitLines(output);\n    |test_cases| > 0 && |output_lines| >= |test_cases| ==>\n    forall i :: 0 <= i < |test_cases| ==> \n        var (s, m, b) := test_cases[i];\n        i < |output_lines| &&\n        var t := output_lines[i];\n        |t| == m &&\n        (forall j :: 0 <= j < m ==> \n            b[j] == SumDistancesToGreaterChars(t, j))\n}\n\npredicate PreservesCharacterUsage(output: string, input: string)\n    requires ValidInputFormat(input)\n{\n    var test_cases := GetTestCases(input);\n    var output_lines := SplitLines(output);\n    |test_cases| > 0 && |output_lines| >= |test_cases| ==>\n    forall i :: 0 <= i < |test_cases| ==> \n        var (s, m, b) := test_cases[i];\n        i < |output_lines| &&\n        var t := output_lines[i];\n        forall c :: 'a' <= c <= 'z' ==> CountChar(t, c) <= CountChar(s, c)\n}\n\npredicate ContainsNewlineTerminatedResults(output: string)\n{\n    |output| > 0 ==> output[|output|-1] == '\\n'\n}\n\nfunction SumDistancesToGreaterChars(t: string, j: int): int\n    requires 0 <= j < |t|\n{\n    SumDistancesToGreaterCharsHelper(t, j, 0)\n}\n\nfunction AbsDiff(i: int, j: int): int\n    ensures AbsDiff(i, j) >= 0\n    ensures AbsDiff(i, j) == if i >= j then i - j else j - i\n{\n    if i >= j then i - j else j - i\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInputFormat(stdin_input)\n    ensures ValidOutputFormat(result, stdin_input)\n    ensures OutputSatisfiesConstraints(result, stdin_input)\n    ensures PreservesCharacterUsage(result, stdin_input)\n    ensures result != \"\" ==> ContainsNewlineTerminatedResults(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_409", "vc-description": "Given a string s consisting of uppercase Latin letters, determine if it contains \ntwo non-overlapping substrings \"AB\" and \"BA\". Return \"YES\" if both substrings \nexist without overlapping, \"NO\" otherwise.", "vc-preamble": "function CountSubstring(s: string, pattern: string): nat\n{\n    if |pattern| == 0 || |s| < |pattern| then 0\n    else if s[..|pattern|] == pattern then 1 + CountSubstring(s[1..], pattern)\n    else CountSubstring(s[1..], pattern)\n}\n\nfunction FindIndex(s: string, pattern: string): int\n{\n    if |pattern| == 0 || |s| < |pattern| then -1\n    else if s[..|pattern|] == pattern then 0\n    else \n        var rest := FindIndex(s[1..], pattern);\n        if rest == -1 then -1 else 1 + rest\n}\n\npredicate HasNonOverlappingABAndBA(s: string)\n{\n    var abIndex := FindIndex(s, \"AB\");\n    var baIndex := FindIndex(s, \"BA\");\n\n    (abIndex >= 0 && baIndex >= 0) &&\n    (\n        (abIndex >= 0 && abIndex + 2 < |s| && CountSubstring(s[abIndex + 2..], \"BA\") > 0) ||\n        (baIndex >= 0 && baIndex + 2 < |s| && CountSubstring(s[baIndex + 2..], \"AB\") > 0)\n    )\n}\n\npredicate ValidInput(input: string)\n{\n    |input| >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == \"YES\" <==> HasNonOverlappingABAndBA(if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures (var s := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n             CountSubstring(s, \"AB\") == 0 || CountSubstring(s, \"BA\") == 0) ==> result == \"NO\"\n    ensures (var s := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n             var abIndex := FindIndex(s, \"AB\");\n             var baIndex := FindIndex(s, \"BA\");\n             CountSubstring(s, \"AB\") > 0 && CountSubstring(s, \"BA\") > 0 &&\n             !((abIndex >= 0 && abIndex + 2 < |s| && CountSubstring(s[abIndex + 2..], \"BA\") > 0) ||\n               (baIndex >= 0 && baIndex + 2 < |s| && CountSubstring(s[baIndex + 2..], \"AB\") > 0))) ==> result == \"NO\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4111", "vc-description": "Given n candies with weights, determine how many candies can be given to dad\nsuch that when the remaining n-1 candies are eaten in numerical order (one per day),\nthe sum of weights eaten on even-numbered days equals the sum on odd-numbered days.", "vc-preamble": "predicate ValidInput(n: int, arr: seq<int>)\n{\n  n >= 1 && |arr| == n && forall i :: 0 <= i < n ==> arr[i] >= 1\n}\n\nfunction sum_even_indices(arr: seq<int>, start: int): int\n  requires 0 <= start <= |arr|\n  decreases |arr| - start\n{\n  if start == |arr| then 0\n  else\n    var contribution := if start % 2 == 0 then arr[start] else 0;\n    contribution + sum_even_indices(arr, start + 1)\n}\n\nfunction sum_odd_indices(arr: seq<int>, start: int): int\n  requires 0 <= start <= |arr|\n  decreases |arr| - start\n{\n  if start == |arr| then 0\n  else\n    var contribution := if start % 2 == 1 then arr[start] else 0;\n    contribution + sum_odd_indices(arr, start + 1)\n}\n\nfunction count_balanced_removals(arr: seq<int>): int\n{\n  var n := |arr|;\n  if n == 0 then 0 else\n  count_helper(arr, 0, sum_even_indices(arr, 0), sum_odd_indices(arr, 0), 0, 0)\n}\n\nfunction count_helper(arr: seq<int>, i: int, count1: int, count2: int, temp1: int, temp2: int): int\n  requires 0 <= i <= |arr|\n  decreases |arr| - i\n{\n  if i == |arr| then 0\n  else\n    var contribution := \n      if i % 2 == 0 then\n        var val1 := temp1 + count2 - temp2;\n        var val2 := temp2 + count1 - temp1 - arr[i];\n        if val1 == val2 then 1 else 0\n      else\n        var val1 := temp1 + count2 - temp2 - arr[i];\n        var val2 := temp2 + count1 - temp1;\n        if val1 == val2 then 1 else 0;\n    var new_temp1 := if i % 2 == 0 then temp1 + arr[i] else temp1;\n    var new_temp2 := if i % 2 == 1 then temp2 + arr[i] else temp2;\n    contribution + count_helper(arr, i + 1, count1, count2, new_temp1, new_temp2)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, arr: seq<int>) returns (result: int)\n  requires ValidInput(n, arr)\n  ensures 0 <= result <= n\n  ensures result == count_balanced_removals(arr)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4115", "vc-description": "Find the minimum number of character changes needed to make a string a palindrome.\nIn each operation, you can change any character to any other lowercase letter.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 1\n}\n\nfunction count_mismatches_up_to(s: string, limit: int): int\n    requires |s| >= 1\n    requires 0 <= limit <= |s|\n    ensures count_mismatches_up_to(s, limit) >= 0\n    ensures count_mismatches_up_to(s, limit) <= limit\n{\n    if limit == 0 then 0\n    else \n        var n := |s| - 1;\n        var mismatch := if s[limit-1] != s[n - (limit-1)] then 1 else 0;\n        count_mismatches_up_to(s, limit-1) + mismatch\n}\n\nfunction count_mismatches(s: string): int\n    requires |s| >= 1\n    ensures count_mismatches(s) >= 0\n{\n    count_mismatches_up_to(s, |s|)\n}\n\npredicate ValidResult(s: string, result: int)\n    requires ValidInput(s)\n{\n    result >= 0 && result <= |s| / 2 && result == (count_mismatches(s) / 2)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures ValidResult(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4142", "vc-description": "Given a string containing only 'L', 'R', 'U', 'D' characters, determine if it is \"easily playable\".\nA string is easily playable if odd positions (1-indexed) contain no 'L' and even positions contain no 'R'.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    1 <= |s| <= 100 && forall i :: 0 <= i < |s| ==> s[i] in {'L', 'R', 'U', 'D'}\n}\n\npredicate EasilyPlayable(s: string)\n{\n    (forall i :: 0 <= i < |s| && i % 2 == 0 ==> s[i] != 'L') &&\n    (forall i :: 0 <= i < |s| && i % 2 == 1 ==> s[i] != 'R')\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures result == \"Yes\" <==> EasilyPlayable(s)\n    ensures result in", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4143", "vc-description": "Given N people starting at City 1, find the minimum time for all people to reach City 6\nthrough a sequential 5-segment transportation system with different capacities per segment.\nEach transport departs at integer times with specified capacity. Transfer time is negligible.", "vc-preamble": "predicate ValidInput(N: int, A: int, B: int, C: int, D: int, E: int)\n{\n    N >= 1 && A >= 1 && B >= 1 && C >= 1 && D >= 1 && E >= 1\n}\n\nfunction MinCapacity(A: int, B: int, C: int, D: int, E: int): int\n    requires A >= 1 && B >= 1 && C >= 1 && D >= 1 && E >= 1\n{\n    var temp1 := if A <= B then A else B;\n    var temp2 := if temp1 <= C then temp1 else C;\n    var temp3 := if temp2 <= D then temp2 else D;\n    if temp3 <= E then temp3 else E\n}\n\nfunction CeilDiv(a: int, b: int): int\n    requires a >= 0 && b >= 1\n{\n    (a + b - 1) / b\n}\n\npredicate CorrectResult(N: int, A: int, B: int, C: int, D: int, E: int, result: int)\n    requires ValidInput(N, A, B, C, D, E)\n{\n    var minCap := MinCapacity(A, B, C, D, E);\n    var groups := CeilDiv(N, minCap);\n    result == 4 + groups\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, A: int, B: int, C: int, D: int, E: int) returns (result: int)\n    requires ValidInput(N, A, B, C, D, E)\n    ensures CorrectResult(N, A, B, C, D, E, result)\n    ensures result >= 5", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4147", "vc-description": "Given N bamboos with lengths, find minimum magic points (MP) to create exactly three bamboos \nwith target lengths A, B, and C. Operations: Extension Magic (1 MP per unit), Shortening Magic \n(1 MP per unit), Composition Magic (10 MP to combine two bamboos). Input format: first line \ncontains N A B C, followed by N lines with bamboo lengths. Output minimum MP needed.", "vc-preamble": "ghost predicate ValidInput(input: string)\n{\n    exists lines :: (lines == split_lines(input) &&\n    |lines| >= 2 &&\n    exists N, A, B, C :: \n        parse_first_line_bamboo(lines[0]) == (N, A, B, C) &&\n        3 <= N <= 8 &&\n        1 <= C < B < A <= 1000 &&\n        |lines| >= N + 1 &&\n        forall i :: 1 <= i <= N ==> \n            exists li :: parse_bamboo_length(lines[i]) == li && 1 <= li <= 1000)\n}\n\nghost predicate ValidAssignment(input: string, assignment: seq<nat>)\n    requires ValidInput(input)\n{\n    exists lines, N, A, B, C :: \n        lines == split_lines(input) &&\n        parse_first_line_bamboo(lines[0]) == (N, A, B, C) &&\n        |assignment| == N &&\n        (forall i :: 0 <= i < N ==> assignment[i] < 4) &&\n        HasAllThreeGroups(assignment)\n}\n\nghost predicate HasAllThreeGroups(assignment: seq<nat>)\n{\n    (exists i :: 0 <= i < |assignment| && assignment[i] == 1) &&\n    (exists i :: 0 <= i < |assignment| && assignment[i] == 2) &&\n    (exists i :: 0 <= i < |assignment| && assignment[i] == 3)\n}\n\nghost function CalculateAssignmentCost(input: string, assignment: seq<nat>): nat\n    requires ValidInput(input)\n    requires ValidAssignment(input, assignment)\n{\n    CompositionCost(assignment) + AdjustmentCost(input, assignment)\n}\n\nghost function CompositionCost(assignment: seq<nat>): nat\n{\n    var group_a_size := CountGroupMembers(assignment, 1);\n    var group_b_size := CountGroupMembers(assignment, 2);\n    var group_c_size := CountGroupMembers(assignment, 3);\n    (if group_a_size > 0 then (group_a_size - 1) * 10 else 0) +\n    (if group_b_size > 0 then (group_b_size - 1) * 10 else 0) +\n    (if group_c_size > 0 then (group_c_size - 1) * 10 else 0)\n}\n\nghost function AdjustmentCost(input: string, assignment: seq<nat>): nat\n    requires ValidInput(input)\n    requires ValidAssignment(input, assignment)\n{\n    var lines := split_lines(input);\n    var (N, A, B, C) := parse_first_line_bamboo(lines[0]);\n    var sum_a := CalculateGroupSum(input, assignment, 1);\n    var sum_b := CalculateGroupSum(input, assignment, 2);\n    var sum_c := CalculateGroupSum(input, assignment, 3);\n    AbsDiff(sum_a, A) + AbsDiff(sum_b, B) + AbsDiff(sum_c, C)\n}\n\nghost function CountGroupMembers(assignment: seq<nat>, group: nat): nat\n{\n    if |assignment| == 0 then 0\n    else (if assignment[0] == group then 1 else 0) + CountGroupMembers(assignment[1..], group)\n}\n\nghost function CalculateGroupSum(input: string, assignment: seq<nat>, group: nat): nat\n    requires ValidInput(input)\n{\n    0\n}\n\nghost function AbsDiff(a: nat, b: nat): nat\n{\n    if a >= b then a - b else b - a\n}\n\nghost function split_lines(s: string): seq<string>\n{\n    []\n}\n\nghost function parse_first_line_bamboo(line: string): (nat, nat, nat, nat)\n{\n    (0, 0, 0, 0)\n}\n\nghost function parse_bamboo_length(line: string): nat\n{\n    0\n}\n\nfunction int_to_string(n: nat): string\n{\n    \"\"\n}\n\nghost function string_to_int(s: string): nat\n{\n    0\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires stdin_input[|stdin_input|-1] == '\\n' || exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n'\n    requires ValidInput(stdin_input + (if stdin_input[|stdin_input|-1] == '\\n' then \"\" else \"\\n\"))\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures exists val :: val >= 0 && result == int_to_string(val) + \"\\n\"\n    ensures forall assignment :: ValidAssignment(stdin_input + (if stdin_input[|stdin_input|-1] == '\\n' then \"\" else \"\\n\"), assignment) ==>\n        string_to_int(result[..|result|-1]) <= CalculateAssignmentCost(stdin_input + (if stdin_input[|stdin_input|-1] == '\\n' then \"\" else \"\\n\"), assignment)\n    decreases *", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4148", "vc-description": "Given a string S of uppercase English letters and an integer N, shift each character in S by N positions forward in the alphabet. The alphabet wraps around (A follows Z).", "vc-preamble": "function split_lines(input: string): seq<string>\nrequires |input| > 0\n{\n    var newline_pos := find_newline(input, 0);\n    if newline_pos == -1 then [input]\n    else if newline_pos >= 0 && newline_pos < |input| then\n        if newline_pos + 1 >= |input| then [input[..newline_pos], \"\"]\n        else [input[..newline_pos], input[newline_pos+1..]]\n    else [input]\n}\n\nfunction find_newline(input: string, start: int): int\nrequires 0 <= start <= |input|\nensures find_newline(input, start) == -1 || (0 <= find_newline(input, start) < |input|)\ndecreases |input| - start\n{\n    if start >= |input| then -1\n    else if input[start] == '\\n' then start\n    else find_newline(input, start + 1)\n}\n\nfunction is_valid_number(s: string): bool\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction string_to_nat(s: string): nat\nrequires is_valid_number(s)\ndecreases |s|\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then (s[0] as int - '0' as int) as nat\n    else (s[0] as int - '0' as int) as nat * 10 + string_to_nat(s[1..])\n}\n\nfunction caesar_shift(s: string, n: nat): string\nrequires forall i :: 0 <= i < |s| ==> 'A' <= s[i] <= 'Z'\nrequires n <= 26\ndecreases |s|\nensures |caesar_shift(s, n)| == |s|\nensures forall i :: 0 <= i < |s| ==> 'A' <= caesar_shift(s, n)[i] <= 'Z'\nensures forall i :: 0 <= i < |s| ==> \n    var shifted_val := (s[i] as int - 'A' as int + n) % 26;\n    caesar_shift(s, n)[i] == (('A' as int + shifted_val) as char)\n{\n    if |s| == 0 then \"\"\n    else \n        var shifted_val := (s[0] as int - 'A' as int + n) % 26;\n        var shifted_char := ('A' as int + shifted_val) as char;\n        [shifted_char] + caesar_shift(s[1..], n)\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    (exists i :: 0 <= i < |input| && input[i] == '\\n') &&\n    var lines := split_lines(input);\n    |lines| >= 2 &&\n    is_valid_number(lines[0]) &&\n    string_to_nat(lines[0]) <= 26 &&\n    |lines[1]| >= 1 && |lines[1]| <= 10000 &&\n    (forall j :: 0 <= j < |lines[1]| ==> 'A' <= lines[1][j] <= 'Z')\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires ValidInput(input)\nensures var lines := split_lines(input);\n        var n := string_to_nat(lines[0]);\n        var s := lines[1];\n        result == caesar_shift(s, n) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4159", "vc-description": "Given three integers A, B, and K, where Takahashi has A cookies and Aoki has B cookies initially.\nTakahashi performs exactly K actions, where each action follows this priority:\n1. If Takahashi has cookies, he eats one of his own cookies\n2. Otherwise, if Aoki has cookies, Takahashi eats one of Aoki's cookies  \n3. Otherwise, do nothing\nDetermine how many cookies Takahashi and Aoki have after all K actions.", "vc-preamble": "predicate ValidInput(A: int, B: int, K: int)\n{\n    A >= 0 && B >= 0 && K >= 0\n}\n\nfunction ExpectedTakahashiCookies(A: int, B: int, K: int): int\n    requires ValidInput(A, B, K)\n{\n    if A >= K then A - K\n    else 0\n}\n\nfunction ExpectedAokiCookies(A: int, B: int, K: int): int\n    requires ValidInput(A, B, K)\n{\n    if A >= K then B\n    else if K - A < B then B - (K - A)\n    else 0\n}\n\npredicate CorrectResult(A: int, B: int, K: int, takahashi: int, aoki: int)\n    requires ValidInput(A, B, K)\n{\n    takahashi == ExpectedTakahashiCookies(A, B, K) &&\n    aoki == ExpectedAokiCookies(A, B, K) &&\n    takahashi >= 0 && aoki >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, K: int) returns (takahashi: int, aoki: int)\n    requires ValidInput(A, B, K)\n    ensures CorrectResult(A, B, K, takahashi, aoki)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4160", "vc-description": "Find the minimum number of years needed for a bank balance to reach a target amount.\nStarting with 100 yen, the balance grows each year by adding 1% interest (rounded down).\nGiven a target amount X, determine how many years it takes for the balance to reach X yen or above.\nThe yearly calculation is: new_balance = current_balance + floor(current_balance / 100)", "vc-preamble": "function calculateDeposit(initial: int, years: int): int\n    requires initial >= 0\n    requires years >= 0\n{\n    if years == 0 then initial\n    else \n        var prevDeposit := calculateDeposit(initial, years - 1);\n        prevDeposit + prevDeposit / 100\n}", "vc-helpers": "", "vc-spec": "method solve(X: int) returns (years: int)\n    requires X >= 101\n    ensures years >= 0\n    ensures var finalDeposit := calculateDeposit(100, years); finalDeposit >= X\n    ensures years == 0 || calculateDeposit(100, years - 1) < X", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4165", "vc-description": "Given N side lengths of a polygon, determine if the polygon can be drawn in a 2D plane.\nA polygon can be drawn if and only if the longest side length is strictly less than \nthe sum of all other side lengths.", "vc-preamble": "predicate ValidInput(sides: seq<int>)\n{\n    |sides| >= 3 && forall i :: 0 <= i < |sides| ==> sides[i] > 0\n}\n\nfunction canFormPolygon(sides: seq<int>): bool\n    requires ValidInput(sides)\n{\n    var sortedSides := quicksort(sides);\n    var longest := sortedSides[|sortedSides|-1];\n    var sumOfOthers := sumExceptLast(sortedSides);\n    sumOfOthers > longest\n}\n\nfunction quicksort(s: seq<int>): seq<int>\n    ensures multiset(quicksort(s)) == multiset(s)\n    ensures forall i, j :: 0 <= i <= j < |quicksort(s)| ==> quicksort(s)[i] <= quicksort(s)[j]\n    decreases |s|\n{\n    if |s| <= 1 then s\n    else\n        var pivot := s[0];\n        var left := filter(s[1..], x => x < pivot);\n        var equal := filter(s, x => x == pivot);\n        var right := filter(s[1..], x => x > pivot);\n\n        assert s == [s[0]] + s[1..];\n        assert multiset(s) == multiset([s[0]]) + multiset(s[1..]);\n        assert s[0] == pivot;\n        assert multiset([s[0]]) == multiset([pivot]);\n\n        filterPreservesInclusion(s[1..], x => x < pivot);\n        filterPreservesInclusion(s[1..], x => x == pivot);\n        filterPreservesInclusion(s[1..], x => x > pivot);\n\n        quicksort(left) + equal + quicksort(right)\n}\n\nfunction filter(s: seq<int>, pred: int -> bool): seq<int>\n    ensures |filter(s, pred)| <= |s|\n    ensures forall x :: x in multiset(filter(s, pred)) ==> x in multiset(s)\n    ensures forall x :: x in multiset(filter(s, pred)) ==> pred(x)\n    ensures multiset(filter(s, pred)) <= multiset(s)\n    decreases |s|\n{\n    if |s| == 0 then []\n    else if pred(s[0]) then \n        var rest := filter(s[1..], pred);\n        assert s == [s[0]] + s[1..];\n        assert multiset(s) == multiset([s[0]]) + multiset(s[1..]);\n        assert multiset(rest) <= multiset(s[1..]);\n        assert multiset([s[0]] + rest) == multiset([s[0]]) + multiset(rest);\n        assert multiset([s[0]]) + multiset(rest) <= multiset([s[0]]) + multiset(s[1..]);\n        [s[0]] + rest\n    else \n        var rest := filter(s[1..], pred);\n        assert multiset(rest) <= multiset(s[1..]);\n        assert s == [s[0]] + s[1..];\n        assert multiset(s) == multiset([s[0]]) + multiset(s[1..]);\n        assert multiset(rest) <= multiset(s[1..]) <= multiset(s);\n        rest\n}\n\nfunction sumExceptLast(s: seq<int>): int\n    requires |s| >= 1\n{\n    if |s| == 1 then 0\n    else s[0] + sumExceptLast(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(sides: seq<int>) returns (result: string)\n    requires ValidInput(sides)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures result == \"Yes\" <==> canFormPolygon(sides)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4167", "vc-description": "Count ordered triples (a,b,c) where 1 \u2264 a,b,c \u2264 N and a+b, b+c, c+a are all divisible by K", "vc-preamble": "predicate ValidTriple(a: int, b: int, c: int, N: int, K: int)\n    requires K >= 1\n{\n    1 <= a <= N && 1 <= b <= N && 1 <= c <= N &&\n    (a + b) % K == 0 && (b + c) % K == 0 && (c + a) % K == 0\n}\n\nfunction CountValidTriples(N: int, K: int): int\n    requires N >= 1 && K >= 1\n{\n    if K % 2 == 1 then\n        var cnt1 := N / K;\n        cnt1 * cnt1 * cnt1\n    else\n        var cnt1 := N / K;\n        var cnt2 := N / K + (if N % K >= K / 2 then 1 else 0);\n        cnt1 * cnt1 * cnt1 + cnt2 * cnt2 * cnt2\n}\n\npredicate ValidInput(N: int, K: int)\n{\n    N >= 1 && K >= 1\n}\n\nfunction CountDivisibleByK(n: int, K: int): int\n    requires K >= 1\n{\n    if n <= 0 then 0 else n / K\n}\n\nfunction CountWithRemainderHalfK(n: int, K: int): int\n    requires K >= 1\n{\n    if n <= 0 then 0 else n / K + (if n % K >= K / 2 then 1 else 0)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, K: int) returns (result: int)\n    requires ValidInput(N, K)\n    ensures result >= 0\n    ensures result == CountValidTriples(N, K)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4173", "vc-description": "Find the minimum cost to purchase exactly n liters of water using 1-liter bottles \n(costing a burles each) and 2-liter bottles (costing b burles each), with infinite \nsupply of both types available. Process multiple queries efficiently.", "vc-preamble": "predicate ValidQuery(query: (int, int, int))\n{\n    query.0 > 0 && query.1 > 0 && query.2 > 0\n}\n\nfunction MinCostForQuery(n: int, a: int, b: int): int\n    requires n > 0 && a > 0 && b > 0\n{\n    if n % 2 == 0 then\n        if n * a <= (n / 2) * b then n * a else (n / 2) * b\n    else\n        if n * a <= (n / 2) * b + a then n * a else (n / 2) * b + a\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<(int, int, int)>) returns (results: seq<int>)\n    requires forall i | 0 <= i < |queries| :: ValidQuery(queries[i])\n    ensures |results| == |queries|\n    ensures forall i | 0 <= i < |queries| :: \n        var n := queries[i].0;\n        var a := queries[i].1;\n        var b := queries[i].2;\n        results[i] == (if n % 2 == 0 then\n            if n * a <= (n / 2) * b then n * a else (n / 2) * b\n        else\n            if n * a <= (n / 2) * b + a then n * a else (n / 2) * b + a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4175", "vc-description": "Given N words announced in a shiritori game, determine if all shiritori rules were followed.\nShiritori rules: 1) No word can be repeated, 2) For each consecutive pair of words, \nthe last character of the first word must equal the first character of the second word.", "vc-preamble": "predicate NoRepeats(words: seq<string>)\n{\n    forall i, j :: 0 <= i < j < |words| ==> words[i] != words[j]\n}\n\npredicate ConsecutiveCharsMatch(words: seq<string>)\n    requires forall i :: 0 <= i < |words| ==> |words[i]| > 0\n{\n    forall i :: 0 <= i < |words| - 1 ==> words[i][|words[i]| - 1] == words[i+1][0]\n}\n\npredicate ValidShiritori(words: seq<string>)\n    requires forall i :: 0 <= i < |words| ==> |words[i]| > 0\n{\n    NoRepeats(words) && ConsecutiveCharsMatch(words)\n}", "vc-helpers": "", "vc-spec": "method solve(words: seq<string>) returns (result: string)\n    requires forall i :: 0 <= i < |words| ==> |words[i]| > 0\n    ensures result == \"Yes\" || result == \"No\"\n    ensures result == \"Yes\" <==> ValidShiritori(words)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4176", "vc-description": "Given two integers A and B representing possible numbers of guests at a party,\nfind the minimum number of snack pieces that can be evenly distributed among\nthe guests in both scenarios (A guests or B guests). Each piece must go to\nexactly one guest, and each guest must receive the same number of pieces\nwithin each scenario. This is equivalent to finding the LCM of A and B.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    exists spaceIndex :: 0 <= spaceIndex < |input| && input[spaceIndex] == ' ' &&\n    forall i :: 0 <= i < |input| ==> (input[i] == ' ' || ('0' <= input[i] <= '9'))\n}\n\nfunction ParseTwoInts(s: string): (int, int)\n    requires ValidInput(s)\n    ensures ParseTwoInts(s).0 > 0 && ParseTwoInts(s).1 > 0\n{\n    var spaceIndex := FindSpace(s, 0);\n    if spaceIndex == -1 || spaceIndex == 0 || spaceIndex == |s| - 1 then (1, 1)\n    else\n        var firstPart := s[..spaceIndex];\n        var secondPart := s[spaceIndex+1..];\n        if |firstPart| == 0 || |secondPart| == 0 then (1, 1)\n        else if !(forall i :: 0 <= i < |firstPart| ==> '0' <= firstPart[i] <= '9') then (1, 1)\n        else if !(forall i :: 0 <= i < |secondPart| ==> '0' <= secondPart[i] <= '9') then (1, 1)\n        else\n            var first := StringToInt(firstPart);\n            var second := StringToInt(secondPart);\n            if first <= 0 || second <= 0 then (1, 1)\n            else (first, second)\n}\n\nfunction LCM(a: int, b: int): int\n    requires a > 0 && b > 0\n    ensures LCM(a, b) > 0\n    ensures LCM(a, b) % a == 0 && LCM(a, b) % b == 0\n{\n    (a * b) / gcd(a, b)\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| > 0 &&\n    forall i :: 0 <= i < |output| ==> ('0' <= output[i] <= '9')\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures var nums := ParseTwoInts(input); \n            var a := nums.0; \n            var b := nums.1;\n            result == IntToString(LCM(a, b))\n    ensures ValidOutput(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4177", "vc-description": "Given a string S consisting of lowercase English letters, replace every character with 'x' and output the result.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 1 && |s| <= 100 && forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\npredicate ValidOutput(s: string, result: string)\n{\n    |result| == |s| && forall i :: 0 <= i < |result| ==> result[i] == 'x'\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures ValidOutput(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4178", "vc-description": "Given N squares with heights, determine if it's possible to make heights non-decreasing\nfrom left to right. For each square, you can decrease its height by 1 or leave unchanged.", "vc-preamble": "function maxHeightUpTo(heights: seq<int>, index: int): int\n  requires |heights| > 0\n  requires -1 <= index < |heights|\n{\n  if index < 0 then 0\n  else if index == 0 then heights[0]\n  else if heights[index] > maxHeightUpTo(heights, index - 1) \n    then heights[index]\n    else maxHeightUpTo(heights, index - 1)\n}\n\npredicate ValidInput(n: int, heights: seq<int>)\n{\n  n >= 1 && |heights| == n && (forall i :: 0 <= i < |heights| ==> heights[i] >= 1)\n}\n\npredicate CanMakeNonDecreasing(heights: seq<int>)\n  requires |heights| > 0\n{\n  forall i :: 0 <= i < |heights| ==> heights[i] >= maxHeightUpTo(heights, i) - 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, heights: seq<int>) returns (result: string)\n  requires ValidInput(n, heights)\n  ensures result == \"Yes\" <==> CanMakeNonDecreasing(heights)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4180", "vc-description": "Given a cost N yen, calculate the change received when paying with the minimum number of 1000-yen bills.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    1 <= n <= 10000\n}\n\npredicate ValidChange(change: int)\n{\n    0 <= change <= 999\n}\n\nfunction CorrectChange(n: int): int\n    requires ValidInput(n)\n{\n    (1000 - n % 1000) % 1000\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (change: int)\n    requires ValidInput(n)\n    ensures ValidChange(change)\n    ensures change == CorrectChange(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4182", "vc-description": "Two empires A and B have capitals at coordinates X and Y respectively.\nEmpire A wants to control cities at coordinates x\u2081, x\u2082, ..., x\u2099, and \nEmpire B wants to control cities at coordinates y\u2081, y\u2082, ..., y\u2098.\nThey reach agreement if there exists integer Z such that X < Z \u2264 Y,\nall x\u1d62 < Z, and all y\u1d62 \u2265 Z. Otherwise war breaks out.", "vc-preamble": "predicate ValidInput(n: int, m: int, x: int, y: int, xx: seq<int>, yy: seq<int>)\n{\n    |xx| == n && |yy| == m && n >= 1 && m >= 1 && x < y\n}\n\npredicate AgreementPossible(n: int, m: int, x: int, y: int, xx: seq<int>, yy: seq<int>)\n    requires ValidInput(n, m, x, y, xx, yy)\n{\n    var combined_x := xx + [x];\n    var combined_y := yy + [y];\n    (exists max_val :: max_val in combined_x && \n                     (forall v :: v in combined_x ==> v <= max_val) &&\n     exists min_val :: min_val in combined_y && \n                     (forall v :: v in combined_y ==> v >= min_val) &&\n                     max_val < min_val)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, x: int, y: int, xx: seq<int>, yy: seq<int>) returns (result: string)\n    requires ValidInput(n, m, x, y, xx, yy)\n    ensures result == \"No War\" || result == \"War\"\n    ensures result == \"No War\" <==> AgreementPossible(n, m, x, y, xx, yy)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4183", "vc-description": "Given N clocks where clock i completes one rotation in T_i seconds,\nfind the minimum positive time when all clocks return to their starting position.\nThis is equivalent to finding the LCM of all rotation periods.", "vc-preamble": "function gcd(a: int, b: int): int\n  requires a > 0 && b >= 0\n  ensures gcd(a, b) > 0\n  ensures gcd(a, b) <= a\n  ensures b > 0 ==> gcd(a, b) <= b\n  decreases b\n{\n  if b == 0 then a else gcd(b, a % b)\n}\n\nfunction lcm(a: int, b: int): int\n  requires a > 0 && b > 0\n  ensures lcm(a, b) >= a && lcm(a, b) >= b\n  ensures lcm(a, b) > 0\n{\n  (a * b) / gcd(a, b)\n}\n\nfunction lcmSeq(nums: seq<int>): int\n  requires |nums| > 0\n  requires forall i :: 0 <= i < |nums| ==> nums[i] > 0\n  ensures lcmSeq(nums) > 0\n  ensures forall i :: 0 <= i < |nums| ==> lcmSeq(nums) >= nums[i]\n{\n  if |nums| == 1 then nums[0]\n  else lcm(nums[0], lcmSeq(nums[1..]))\n}\n\npredicate ValidInput(periods: seq<int>)\n{\n  |periods| > 0 && |periods| <= 100 &&\n  forall i :: 0 <= i < |periods| ==> periods[i] > 0\n}\n\npredicate CorrectResult(periods: seq<int>, result: int)\n  requires ValidInput(periods)\n{\n  result == lcmSeq(periods)\n}", "vc-helpers": "", "vc-spec": "method FindMinimumTime(periods: seq<int>) returns (result: int)\n  requires ValidInput(periods)\n  ensures CorrectResult(periods, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4188", "vc-description": "Given 16 facts with numerical claims, determine whether each fact is true (1) or false (0) in reality.\nEach fact is numbered from 1 to 16 based on order of appearance. Input n specifies which fact to check.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    1 <= n <= 16\n}\n\nfunction FactTruthValues(): seq<int>\n{\n    [1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0]\n}\n\npredicate ValidOutput(result: int)\n{\n    result == 0 || result == 1\n}\n\nfunction ExpectedOutput(n: int): int\n    requires ValidInput(n)\n{\n    FactTruthValues()[n - 1]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures ValidOutput(result)\n    ensures result == ExpectedOutput(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4192", "vc-description": "Determine if Takahashi can travel D meters in T minutes at a speed of S meters per minute.\nPrint \"Yes\" if he can travel the distance in the given time, otherwise print \"No\".", "vc-preamble": "predicate ValidInput(D: int, T: int, S: int)\n{\n    1 <= D <= 10000 && 1 <= T <= 10000 && 1 <= S <= 10000\n}\n\npredicate CanTravel(D: int, T: int, S: int)\n{\n    D <= T * S\n}", "vc-helpers": "", "vc-spec": "method solve(D: int, T: int, S: int) returns (result: string)\n    requires ValidInput(D, T, S)\n    ensures CanTravel(D, T, S) ==> result == \"Yes\"\n    ensures !CanTravel(D, T, S) ==> result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4194", "vc-description": "Given N vacation days and M assignments where assignment i takes A_i days to complete,\nfind the maximum number of days available for hanging out. Each assignment must be\ncompleted on consecutive days, and no hanging out is allowed on assignment days.\nIf all assignments cannot be completed within the vacation period, return -1.", "vc-preamble": "predicate ValidInput(N: int, M: int, A: seq<int>)\n{\n    N >= 0 && M >= 0 && M == |A|\n}\n\npredicate CanCompleteAllAssignments(N: int, A: seq<int>)\n{\n    sum(A) <= N\n}\n\nfunction TotalAssignmentDays(A: seq<int>): int\n{\n    sum(A)\n}\n\nfunction sum(s: seq<int>): int\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, M: int, A: seq<int>) returns (result: int)\n    requires ValidInput(N, M, A)\n    ensures M == 0 ==> result == N\n    ensures M > 0 && CanCompleteAllAssignments(N, A) ==> result == N - TotalAssignmentDays(A)\n    ensures M > 0 && !CanCompleteAllAssignments(N, A) ==> result == -1\n    ensures result >= -1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4199", "vc-description": "Count how many people can ride a roller coaster given their heights and a minimum height requirement.\nInput: N (number of people), K (minimum height requirement), and N heights.\nOutput: Number of people who can ride (height >= K).", "vc-preamble": "predicate ValidInput(n: int, k: int, heights: seq<int>)\n{\n    n >= 1 && k >= 1 && |heights| == n && \n    forall i :: 0 <= i < |heights| ==> heights[i] >= 1\n}\n\nfunction CountEligible(heights: seq<int>, k: int): int\n{\n    |set i | 0 <= i < |heights| && heights[i] >= k :: i|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, heights: seq<int>) returns (count: int)\n    requires ValidInput(n, k, heights)\n    ensures 0 <= count <= |heights|\n    ensures count == CountEligible(heights, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4206", "vc-description": "Given a string of digits representing a positive integer, find the maximum number of valid numbers \ndivisible by 3 that can be obtained by making vertical cuts between adjacent digits.\nNumbers cannot have leading zeros (except single digit \"0\"), and a number is divisible by 3 \nif the sum of its digits is divisible by 3.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    input[|input|-1] == '\\n' &&\n    |input| >= 2 &&\n    (forall i :: 0 <= i < |input|-1 ==> '0' <= input[i] <= '9') &&\n    (input[0] != '0' || |input| == 2)\n}\n\nfunction MaxDivisibleBy3Segments(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    ensures MaxDivisibleBy3Segments(s) >= 0\n    ensures MaxDivisibleBy3Segments(s) <= |s|\n{\n    MaxDivisibleBy3SegmentsHelper(s, 0, \"\", 0)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures exists count :: 0 <= count <= |input|-1 && result == IntToString(count) + \"\\n\"\n    ensures exists count :: count == MaxDivisibleBy3Segments(input[0..|input|-1]) && result == IntToString(count) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4211", "vc-description": "Given an integer sequence B of length N-1, find the maximum possible sum of an integer sequence A of length N \nthat satisfies the constraint: B_i >= max(A_i, A_{i+1}) for all valid i.", "vc-preamble": "predicate ValidInput(n: int, b: seq<int>)\n{\n  n >= 2 && |b| == n - 1 && forall i :: 0 <= i < |b| ==> b[i] >= 0\n}\n\npredicate CorrectResult(n: int, b: seq<int>, result: int)\n  requires ValidInput(n, b)\n{\n  if n == 2 then\n    result == 2 * b[0]\n  else\n    result == b[0] + b[n-2] + sum_mins(b, n-2)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, b: seq<int>) returns (result: int)\n  requires ValidInput(n, b)\n  ensures CorrectResult(n, b, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4215", "vc-description": "Given a window of width A and two curtains each of horizontal length B,\ndetermine the minimum total horizontal length of the uncovered part when \nthe curtains are optimally positioned to minimize uncovered area.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    1 <= a <= 100 && 1 <= b <= 100\n}\n\nfunction UncoveredLength(a: int, b: int): int\n{\n    max(0, a - 2 * b)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result >= 0\n    ensures result == UncoveredLength(a, b)\n    ensures result == if a > 2 * b then a - 2 * b else 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4216", "vc-description": "Given a positive integer N, find the minimum value of F(A,B) over all pairs of positive integers (A,B) \nsuch that A \u00d7 B = N, where F(A,B) is defined as the maximum of the number of digits in A and the number of digits in B.", "vc-preamble": "function numDigits(n: int): int\n  requires n >= 1\n  ensures numDigits(n) >= 1\n  decreases n\n{\n  if n < 10 then 1\n  else 1 + numDigits(n / 10)\n}\n\npredicate ValidInput(N: int) {\n  N >= 1\n}\n\nfunction F(a: int, b: int): int\n  requires a >= 1 && b >= 1\n{\n  var digitsA := numDigits(a);\n  var digitsB := numDigits(b);\n  if digitsA > digitsB then digitsA else digitsB\n}\n\npredicate IsFactorPair(a: int, b: int, N: int) {\n  a >= 1 && b >= 1 && a * b == N\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: int)\n  requires ValidInput(N)\n  ensures result >= 1\n  ensures exists a, b :: IsFactorPair(a, b, N) && result == F(a, b)\n  ensures forall a, b :: IsFactorPair(a, b, N) ==> result <= F(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4220", "vc-description": "Given an integer K and a string S of lowercase English letters, output S unchanged if its length is at most K.\nOtherwise, output the first K characters of S followed by \"...\".", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    (exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n') &&\n    (var newline_pos := find_newline(stdin_input, 0);\n     var K_str := stdin_input[0..newline_pos];\n     is_valid_positive_integer(K_str)) &&\n    (var newline_pos := find_newline(stdin_input, 0);\n     var K_str := stdin_input[0..newline_pos];\n     var K := string_to_int(K_str);\n     1 <= K <= 100) &&\n    (var newline_pos := find_newline(stdin_input, 0);\n     var rest := stdin_input[newline_pos+1..];\n     var S := if |rest| > 0 && rest[|rest|-1] == '\\n' then rest[0..|rest|-1] else rest;\n     1 <= |S| <= 100 && forall i :: 0 <= i < |S| ==> 'a' <= S[i] <= 'z')\n}\n\nfunction ExtractK(stdin_input: string): int\n    requires ValidInput(stdin_input)\n{\n    var newline_pos := find_newline(stdin_input, 0);\n    var K_str := stdin_input[0..newline_pos];\n    string_to_int(K_str)\n}\n\nfunction ExtractS(stdin_input: string): string\n    requires ValidInput(stdin_input)\n{\n    var newline_pos := find_newline(stdin_input, 0);\n    var rest := stdin_input[newline_pos+1..];\n    if |rest| > 0 && rest[|rest|-1] == '\\n' then rest[0..|rest|-1] else rest\n}\n\npredicate CorrectOutput(stdin_input: string, result: string)\n    requires ValidInput(stdin_input)\n{\n    var K := ExtractK(stdin_input);\n    var S := ExtractS(stdin_input);\n    K >= 1 && K <= 100 &&\n    |S| >= 1 && |S| <= 100 &&\n    (forall i :: 0 <= i < |S| ==> 'a' <= S[i] <= 'z') &&\n    (|S| <= K ==> result == S + \"\\n\") &&\n    (|S| > K ==> result == S[0..K] + \"...\" + \"\\n\")\n}\n\nfunction find_newline(s: string, start: nat): nat\n    requires start <= |s|\n    ensures find_newline(s, start) <= |s|\n    ensures find_newline(s, start) >= start\n    ensures find_newline(s, start) < |s| ==> s[find_newline(s, start)] == '\\n'\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == '\\n' then start\n    else find_newline(s, start + 1)\n}\n\nfunction is_valid_positive_integer(s: string): bool\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] >= '0' && s[i] <= '9' && s != \"0\"\n}\n\nfunction string_to_int(s: string): int\n    requires is_valid_positive_integer(s)\n    ensures string_to_int(s) >= 1\n{\n    string_to_int_helper(s, 0, 0)\n}\n\nfunction string_to_int_helper(s: string, pos: nat, acc: int): int\n    requires pos <= |s|\n    requires acc >= 0\n    requires forall i :: 0 <= i < pos ==> s[i] >= '0' && s[i] <= '9'\n    requires is_valid_positive_integer(s)\n    ensures string_to_int_helper(s, pos, acc) >= 1\n    decreases |s| - pos\n{\n    if pos >= |s| then \n        if acc == 0 then 1 else acc\n    else if s[pos] >= '0' && s[pos] <= '9' then\n        string_to_int_helper(s, pos + 1, acc * 10 + (s[pos] as int - '0' as int))\n    else\n        if acc == 0 then 1 else acc\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures CorrectOutput(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4221", "vc-description": "Convert a singular noun string containing only lowercase English letters to plural form.\nIf the string does not end with 's', append 's'.\nIf the string ends with 's', append 'es'.", "vc-preamble": "predicate ValidInput(s: string) \n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\npredicate CorrectPlural(s: string, result: string)\n{\n    if |s| > 0 && s[|s| - 1] == 's' then\n        result == s + \"es\"\n    else\n        result == s + \"s\"\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures CorrectPlural(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4224", "vc-description": "Given an array of positive integers, find the maximum number of operations possible where each operation\nallows dividing elements by 2 (if even) or multiplying by 3, with at least one division by 2 required per operation.", "vc-preamble": "predicate ValidInput(a: seq<int>) {\n  forall i :: 0 <= i < |a| ==> a[i] > 0\n}\n\nfunction CountFactorsOfTwo(n: int): int\n  requires n > 0\n  decreases n\n{\n  if n % 2 == 0 then 1 + CountFactorsOfTwo(n / 2)\n  else 0\n}\n\nfunction SumFactors(a: seq<int>, i: int): int\n  requires 0 <= i <= |a|\n  requires forall j :: 0 <= j < |a| ==> a[j] > 0\n  decreases |a| - i\n{\n  if i == |a| then 0\n  else CountFactorsOfTwo(a[i]) + SumFactors(a, i + 1)\n}\n\nfunction MaxOperations(a: seq<int>): int\n  requires ValidInput(a)\n{\n  SumFactors(a, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: int)\n  requires ValidInput(a)\n  ensures result >= 0\n  ensures result == MaxOperations(a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4225", "vc-description": "Given A cards with value 1, B cards with value 0, and C cards with value -1,\nfind the maximum possible sum when picking exactly K cards.\nThe optimal strategy is to pick cards with highest values first.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int, K: int)\n{\n    A >= 0 && B >= 0 && C >= 0 && K >= 1 && K <= A + B + C\n}\n\nfunction MaxSum(A: int, B: int, C: int, K: int): int\n    requires ValidInput(A, B, C, K)\n{\n    if K <= A + B then\n        if K <= A then K else A\n    else\n        A - (K - A - B)\n}\n\npredicate ParsedValues(input: string, A: int, B: int, C: int, K: int)\n{\n    exists parts :: |parts| >= 4 && \n        parts == SplitStringPure(input) &&\n        A == StringToIntPure(parts[0]) &&\n        B == StringToIntPure(parts[1]) &&\n        C == StringToIntPure(parts[2]) &&\n        K == StringToIntPure(parts[3]) &&\n        ValidInput(A, B, C, K)\n}\n\nfunction IntToStringPure(n: int): string\n    requires n >= -2000000000 && n <= 2000000000\n    ensures |IntToStringPure(n)| > 0\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringPureHelper(-n)\n    else IntToStringPureHelper(n)\n}\n\nfunction IntToStringPureHelper(n: int): string\n    requires n > 0\n    ensures |IntToStringPureHelper(n)| > 0\n    decreases n\n{\n    if n < 10 then [('0' as int + n) as char]\n    else IntToStringPureHelper(n / 10) + [('0' as int + (n % 10)) as char]\n}\n\nfunction SplitStringPure(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else SplitStringHelper(s, 0, \"\", [])\n}\n\nfunction SplitStringHelper(s: string, i: int, current: string, parts: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then parts + [current] else parts\n    else if s[i] == ' ' || s[i] == '\\n' then\n        if |current| > 0 then \n            SplitStringHelper(s, i+1, \"\", parts + [current])\n        else \n            SplitStringHelper(s, i+1, \"\", parts)\n    else\n        SplitStringHelper(s, i+1, current + [s[i]], parts)\n}\n\nfunction StringToIntPure(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntHelper(s, 1)\n    else StringToIntHelper(s, 0)\n}\n\nfunction StringToIntHelper(s: string, start: int): int\n    requires 0 <= start <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then 0\n    else if '0' <= s[start] <= '9' then\n        (s[start] as int - '0' as int) + 10 * StringToIntHelper(s, start + 1)\n    else\n        StringToIntHelper(s, start + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures (exists A, B, C, K :: \n        ParsedValues(input, A, B, C, K) &&\n        (var maxSum := MaxSum(A, B, C, K);\n         maxSum >= -2000000000 && maxSum <= 2000000000 &&\n         result == IntToStringPure(maxSum) + \"\\n\")) ||\n    (forall A, B, C, K :: !ParsedValues(input, A, B, C, K) ==> result == \"0\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4229", "vc-description": "Given a positive integer N, calculate the sum of all numbers in the first N terms of the FizzBuzz sequence.\nThe FizzBuzz sequence transforms each position i (1 to N) as follows:\n- If i is divisible by both 3 and 5: term = \"FizzBuzz\" (skip from sum)\n- If i is divisible by 3 only: term = \"Fizz\" (skip from sum)  \n- If i is divisible by 5 only: term = \"Buzz\" (skip from sum)\n- Otherwise: term = i (include in sum)\nReturn the sum of all numeric terms only.", "vc-preamble": "function int_to_string(i: int): string\n    requires i >= 0\n    ensures |int_to_string(i)| > 0\n{\n    \"1\"\n}\n\nfunction parse_int_from_string(s: string): int\n    requires |s| > 0\n    ensures parse_int_from_string(s) >= 1\n{\n    1\n}\n\npredicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0\n}\n\nfunction sum_of_non_fizzbuzz_numbers(n: int): int\n    requires n >= 0\n    ensures sum_of_non_fizzbuzz_numbers(n) >= 0\n    decreases n\n{\n    if n == 0 then 0\n    else\n        var num := n;\n        if num % 3 > 0 && num % 5 > 0 then\n            sum_of_non_fizzbuzz_numbers(n - 1) + num\n        else\n            sum_of_non_fizzbuzz_numbers(n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures |result| > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4231", "vc-description": "Given an H\u00d7W grid of white cells, choose h rows and w columns to paint black.\nAll cells that are either in a chosen row OR in a chosen column will be painted black.\nDetermine how many white cells remain after painting.", "vc-preamble": "predicate ValidInput(H: int, W: int, h: int, w: int)\n{\n    1 <= H <= 20 && 1 <= W <= 20 && 1 <= h <= H && 1 <= w <= W\n}\n\nfunction WhiteCellsRemaining(H: int, W: int, h: int, w: int): int\n    requires ValidInput(H, W, h, w)\n{\n    (H - h) * (W - w)\n}", "vc-helpers": "", "vc-spec": "method solve(H: int, W: int, h: int, w: int) returns (result: int)\n    requires ValidInput(H, W, h, w)\n    ensures result == WhiteCellsRemaining(H, W, h, w)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4233", "vc-description": "Given an n\u00d7m grid containing '*' and '.' characters, find a set of stars that exactly reproduces this pattern.\nA star has a center (x,y) and size s, placing '*' at the center and s positions in each cardinal direction.\nOutput the number of stars and their parameters, or \"-1\" if impossible.\n\n// Each star is valid and within bounds\n\n// The stars exactly cover all '*' positions\n\n// center\n\n// horizontal ray\n\n// vertical ray", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := Split(input, '\\n');\n    |lines| >= 1 && \n    (var firstLine := Split(lines[0], ' ');\n     |firstLine| == 2 &&\n     StringToInt(firstLine[0]) > 0 && StringToInt(firstLine[1]) > 0 &&\n     (var n := StringToInt(firstLine[0]);\n      var m := StringToInt(firstLine[1]);\n      n >= 3 && m >= 3 && |lines| >= n + 1 &&\n      (forall i :: 1 <= i <= n ==> i < |lines| && |lines[i]| >= m) &&\n      (forall i :: 1 <= i <= n ==> forall j :: 0 <= j < m ==> lines[i][j] in {'*', '.'})))\n}\n\nghost predicate ExistsValidStarDecomposition(input: string)\nrequires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var firstLine := Split(lines[0], ' ');\n    var n := StringToInt(firstLine[0]);\n    var m := StringToInt(firstLine[1]);\n\n    exists k: int, stars: seq<(int, int, int)> :: \n        0 <= k <= n * m && |stars| == k &&\n        (forall s :: s in stars ==> \n            1 <= s.0 <= n && 1 <= s.1 <= m && 1 <= s.2 <= min(n, m)) &&\n        ValidStarDecomposition(input, stars)\n}\n\npredicate ValidStarDecomposition(input: string, stars: seq<(int, int, int)>)\nrequires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var firstLine := Split(lines[0], ' ');\n    var n := StringToInt(firstLine[0]);\n    var m := StringToInt(firstLine[1]);\n\n    (forall s :: s in stars ==> \n        s.0 >= 1 && s.0 <= n && s.1 >= 1 && s.1 <= m && s.2 > 0 &&\n        ValidStar(n, m, s.0, s.1, s.2)) &&\n\n    (forall i, j :: 1 <= i <= n && 1 <= j <= m ==>\n        (lines[i][j-1] == '*' <==> CoveredByStars(stars, i, j)) &&\n        (lines[i][j-1] == '.' <==> !CoveredByStars(stars, i, j)))\n}\n\npredicate ValidStar(n: int, m: int, x: int, y: int, s: int)\n{\n    x >= 1 && x <= n && y >= 1 && y <= m && s > 0 &&\n    x - s >= 1 && x + s <= n && y - s >= 1 && y + s <= m\n}\n\npredicate CoveredByStars(stars: seq<(int, int, int)>, i: int, j: int)\n{\n    exists s :: s in stars && CoveredByStar(s.0, s.1, s.2, i, j)\n}\n\npredicate CoveredByStar(x: int, y: int, size: int, i: int, j: int)\n{\n    (i == x && j == y) ||\n    (i == x && 1 <= AbsInt(j - y) <= size) ||\n    (j == y && 1 <= AbsInt(i - x) <= size)\n}\n\npredicate StartsWithIntAndValidFormat(s: string, k: int)\n{\n    |s| > 0 && \n    |IntToString(k)| <= |s| && \n    s[..|IntToString(k)|] == IntToString(k)\n}\n\nfunction FormatStarOutput(k: int, stars: seq<(int, int, int)>): string\nrequires k >= 0 && |stars| == k\n{\n    var result := IntToString(k) + \"\\n\";\n    var idx := 0;\n    FormatStarOutputHelper(result, stars, idx)\n}\n\nfunction FormatStarOutputHelper(result: string, stars: seq<(int, int, int)>, idx: int): string\nrequires 0 <= idx <= |stars|\ndecreases |stars| - idx\n{\n    if idx >= |stars| then result\n    else \n        var newResult := result + IntToString(stars[idx].0) + \" \" + IntToString(stars[idx].1) + \" \" + IntToString(stars[idx].2) + \"\\n\";\n        FormatStarOutputHelper(newResult, stars, idx + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires |input| > 0\nensures ValidInput(input) ==> \n    (result == \"-1\\n\" <==> !ExistsValidStarDecomposition(input))\nensures ValidInput(input) && result != \"-1\\n\" ==>\n    (exists k: int, stars: seq<(int, int, int)> ::\n        k >= 0 && |stars| == k &&\n        ValidStarDecomposition(input, stars) &&\n        result == FormatStarOutput(k, stars))\nensures ValidInput(input) ==> result != \"\"\nensures !ValidInput(input) ==> result == \"-1\\n\"\nensures result == \"-1\\n\" || (exists k: int :: k >= 0 && StartsWithIntAndValidFormat(result, k))\nensures result == \"\" || result[|result|-1..] == \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4234", "vc-description": "Given a string of lowercase letters, delete the minimum number of characters to make it \"good\".\nA string is \"good\" if its length is even and each character at odd positions (1st, 3rd, 5th, ...)\ndiffers from the character at the next even position (2nd, 4th, 6th, ...).", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n    n == |s| && n >= 0\n}\n\npredicate IsGoodString(s: string)\n{\n    |s| % 2 == 0 && forall i :: 0 <= i < |s|/2 ==> s[2*i] != s[2*i+1]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (deletedCount: int, result: string)\n    requires ValidInput(n, s)\n    ensures deletedCount >= 0\n    ensures deletedCount == |s| - |result|\n    ensures IsGoodString(result)\n    ensures deletedCount + |result| == |s|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4237", "vc-description": "Given four integers A, B, C, and D, find the count of integers in the range [A, B] (inclusive) \nthat are divisible by neither C nor D.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int, D: int) {\n  A >= 1 && B >= A && C >= 1 && D >= 1\n}\n\npredicate NotDivisibleByEither(x: int, C: int, D: int)\n  requires C > 0 && D > 0\n{\n  x % C != 0 && x % D != 0\n}\n\nfunction CountNotDivisible(A: int, B: int, C: int, D: int): int\n  requires ValidInput(A, B, C, D)\n{\n  |set x | A <= x <= B && NotDivisibleByEither(x, C, D)|\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int, D: int) returns (result: int)\n  requires ValidInput(A, B, C, D)\n  ensures result >= 0\n  ensures result == f(B, C, D) - f(A - 1, C, D)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4242", "vc-description": "Given positive integers A and B, find the K-th largest positive integer that divides both A and B.\nThe K-th largest common divisor is guaranteed to exist for the given inputs.", "vc-preamble": "function CommonDivisors(A: int, B: int): set<int>\n  requires A > 0 && B > 0\n{\n  set d | 1 <= d <= A && A % d == 0 && B % d == 0\n}\n\npredicate ValidInput(A: int, B: int, K: int)\n{\n  A > 0 && B > 0 && K >= 1 && |CommonDivisors(A, B)| >= K\n}\n\npredicate IsKthLargestCommonDivisor(A: int, B: int, K: int, result: int)\n  requires ValidInput(A, B, K)\n{\n  result > 0 &&\n  A % result == 0 && B % result == 0 &&\n  result in CommonDivisors(A, B) &&\n  |set d | d in CommonDivisors(A, B) && d > result| == K - 1\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, K: int) returns (result: int)\n  requires ValidInput(A, B, K)\n  ensures IsKthLargestCommonDivisor(A, B, K, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4245", "vc-description": "Given a single socket that can be extended using power strips, find the minimum number of power strips needed to have at least B empty sockets. Each power strip has A sockets and when plugged into an empty socket, it replaces that 1 socket with A sockets (net gain of A-1 sockets).", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n  a > 1 && b >= 0\n}\n\nfunction SocketsAfterStrips(strips: int, a: int): int\n  requires a > 1 && strips >= 0\n{\n  1 + strips * (a - 1)\n}\n\nfunction CeilingDivision(x: int, y: int): int\n  requires y > 0\n{\n  if x % y == 0 then x / y\n  else if x >= 0 then x / y + 1\n  else x / y\n}\n\nfunction MinStripsNeeded(a: int, b: int): int\n  requires ValidInput(a, b)\n{\n  if b <= 1 then 0\n  else CeilingDivision(b - 1, a - 1)\n}\n\npredicate CorrectResult(a: int, b: int, result: int)\n  requires ValidInput(a, b)\n{\n  result >= 0 &&\n  SocketsAfterStrips(result, a) >= b &&\n  (result == 0 || SocketsAfterStrips(result - 1, a) < b)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n  requires ValidInput(a, b)\n  ensures CorrectResult(a, b, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4246", "vc-description": "Given two strings S and T, each of length 3, representing weather forecasts and actual weather \nrespectively for 3 consecutive days, count how many days the forecast was correct.\nEach character represents weather: 'S' = sunny, 'C' = cloudy, 'R' = rainy.\nInput: Two lines with strings of length 3 containing only 'S', 'C', 'R' characters.\nOutput: Integer representing the number of days where forecast matched actual weather.", "vc-preamble": "predicate is_valid_input(input: string)\n    requires |input| > 0\n{\n    var lines := parse_lines(input);\n    |lines| >= 2 && |lines[0]| == 3 && |lines[1]| == 3\n}\n\nfunction count_matches_from_input(input: string): int\n    requires |input| > 0\n    requires is_valid_input(input)\n    ensures 0 <= count_matches_from_input(input) <= 3\n{\n    var lines := parse_lines(input);\n    count_matches(lines[0], lines[1])\n}\n\nfunction count_matches(s: string, t: string): int\n    requires |s| == |t| == 3\n    ensures 0 <= count_matches(s, t) <= 3\n    ensures count_matches(s, t) == \n        (if s[0] == t[0] then 1 else 0) +\n        (if s[1] == t[1] then 1 else 0) +\n        (if s[2] == t[2] then 1 else 0)\n{\n    (if s[0] == t[0] then 1 else 0) +\n    (if s[1] == t[1] then 1 else 0) +\n    (if s[2] == t[2] then 1 else 0)\n}\n\nfunction compute_result(input: string): string\n    requires |input| > 0\n    ensures |compute_result(input)| >= 2\n    ensures compute_result(input)[|compute_result(input)|-1] == '\\n'\n    ensures compute_result(input)[0] in {'0', '1', '2', '3'}\n    ensures is_valid_input(input) ==> \n        compute_result(input) == int_to_string(count_matches_from_input(input)) + \"\\n\"\n    ensures !is_valid_input(input) ==> compute_result(input) == \"0\\n\"\n{\n    var lines := parse_lines(input);\n    if |lines| < 2 then \"0\\n\"\n    else if |lines[0]| != 3 || |lines[1]| != 3 then \"0\\n\"\n    else int_to_string(count_matches(lines[0], lines[1])) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == compute_result(input)\n    ensures |result| >= 2 && result[|result|-1] == '\\n'\n    ensures result[0] in", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4247", "vc-description": "Given a permutation p of integers {1, 2, ..., n}, count how many elements p_i \n(where 1 < i < n) are the median (second smallest) value among the three \nconsecutive elements p_{i-1}, p_i, and p_{i+1}.", "vc-preamble": "predicate ValidInput(n: int, p: seq<int>)\n{\n    |p| == n && n >= 3\n}\n\nfunction CountMedianElements(p: seq<int>, n: int): int\n    requires ValidInput(n, p)\n{\n    |set i | 0 <= i < n - 2 && IsMedianOfThree(p[i], p[i + 1], p[i + 2]) :: i|\n}\n\npredicate IsMedianOfThree(a: int, b: int, c: int)\n{\n    (a < b < c) || (a > b > c)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: seq<int>) returns (result: int)\n    requires ValidInput(n, p)\n    ensures result >= 0\n    ensures result <= n - 2\n    ensures result == CountMedianElements(p, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4252", "vc-description": "Given a string of lowercase Latin letters, find the minimum number of characters \nto remove so that the resulting string does not contain \"xxx\" (three consecutive x's) \nas a substring. Characters can be removed from any positions. If the string initially \ndoesn't contain \"xxx\", return 0.", "vc-preamble": "predicate ValidInput(s: string) \n{\n    |s| >= 3\n}\n\nfunction CountExcessivePositions(s: string): int\n{\n    CountExcessivePositionsHelper(s, 0, 0)\n}\n\nfunction CountExcessivePositionsHelper(s: string, pos: int, consecutiveX: int): int\n    requires 0 <= pos <= |s|\n    requires consecutiveX >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| then 0\n    else\n        var newConsecutiveX := if s[pos] == 'x' then consecutiveX + 1 else 0;\n        var currentContribution := if newConsecutiveX > 2 then 1 else 0;\n        currentContribution + CountExcessivePositionsHelper(s, pos + 1, newConsecutiveX)\n}\n\nfunction ConsecutiveXCount(s: string, pos: int): int\n    requires 0 <= pos <= |s|\n{\n    if pos == 0 then 0\n    else if s[pos - 1] == 'x' then 1 + ConsecutiveXCount(s, pos - 1)\n    else 0\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result >= 0\n    ensures result <= |s|\n    ensures result == CountExcessivePositions(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4253", "vc-description": "Calculate the area of a regular dodecagon inscribed in a circle of radius r.\nThe area formula is 3r\u00b2. Input is an integer r (1 \u2264 r \u2264 100).\nOutput is the integer area.", "vc-preamble": "predicate ValidInput(r: int)\n{\n    1 <= r <= 100\n}\n\nfunction DodecagonArea(r: int): int\n    requires ValidInput(r)\n{\n    3 * r * r\n}\n\nfunction int_to_string(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"0\"\n    else if n < 10 then [('0' as int + n) as char]\n    else int_to_string(n / 10) + int_to_string(n % 10)\n}\n\nfunction string_to_int(s: string): int\n    requires |s| > 0\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 1 then (s[0] as int) - ('0' as int)\n    else string_to_int(s[..|s|-1]) * 10 + ((s[|s|-1] as int) - ('0' as int))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires |stdin_input| > 0\n    requires exists r: int :: ValidInput(r) && (stdin_input == int_to_string(r) || stdin_input == int_to_string(r) + \"\\n\")\n    ensures exists r: int :: (ValidInput(r) && \n            (stdin_input == int_to_string(r) || stdin_input == int_to_string(r) + \"\\n\") &&\n            output == int_to_string(DodecagonArea(r)) + \"\\n\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4254", "vc-description": "Given the number of sheep S and wolves W, determine if the situation is \"safe\" or \"unsafe\".\nOutput \"unsafe\" if the number of wolves is greater than or equal to the number of sheep,\notherwise output \"safe\". Input is a string containing two integers separated by space.", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n    var trimmed := TrimNewlines(input);\n    var spaceIndex := FindSpace(trimmed);\n    spaceIndex >= 0 && spaceIndex < |trimmed| - 1 &&\n    IsValidInteger(trimmed[..spaceIndex]) &&\n    IsValidInteger(trimmed[spaceIndex+1..])\n}\n\npredicate ValidInput(input: string, S: int, W: int)\n{\n    ValidInputFormat(input) &&\n    var trimmed := TrimNewlines(input);\n    var spaceIndex := FindSpace(trimmed);\n    var sStr := trimmed[..spaceIndex];\n    var wStr := trimmed[spaceIndex+1..];\n    StringToInt(sStr) == S && StringToInt(wStr) == W\n}\n\npredicate IsValidInteger(s: string)\n{\n    if |s| == 0 then false\n    else if s[0] == '-' then\n        |s| > 1 && forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9'\n    else\n        forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction TrimNewlines(s: string): string\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == '\\n' then TrimNewlines(s[..|s|-1])\n    else s\n}\n\nfunction FindSpace(s: string): int\n{\n    FindSpaceHelper(s, 0)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' && |s| > 1 then\n        -StringToIntHelper(s[1..], 0, 0)\n    else\n        StringToIntHelper(s, 0, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"safe\\n\" || result == \"unsafe\\n\" || result == \"\"\n    ensures ValidInputFormat(input) ==> \n        var trimmed := TrimNewlines(input);\n        var spaceIndex := FindSpace(trimmed);\n        var S := StringToInt(trimmed[..spaceIndex]);\n        var W := StringToInt(trimmed[spaceIndex+1..]);\n        (W < S ==> result == \"safe\\n\") && (W >= S ==> result == \"unsafe\\n\")\n    ensures !ValidInputFormat(input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4255", "vc-description": "Given a right triangle with a 90\u00b0 angle at vertex B, and the lengths of all three sides AB, BC, and CA,\ncalculate the area of the triangle. The area is computed as (AB * BC) / 2 where AB and BC are the two\nlegs of the right triangle. Input consists of three integers representing the side lengths, and output\nis the integer area.", "vc-preamble": "predicate ValidInput(ab: int, bc: int, ca: int)\n{\n    1 <= ab <= 100 && 1 <= bc <= 100 && 1 <= ca <= 100\n}\n\nfunction TriangleArea(ab: int, bc: int): int\n    requires ab >= 1 && bc >= 1\n{\n    (ab * bc) / 2\n}\n\npredicate ValidArea(ab: int, bc: int, area: int)\n    requires ab >= 1 && bc >= 1\n{\n    area == TriangleArea(ab, bc) && area >= 0 && area <= 5000\n}", "vc-helpers": "", "vc-spec": "method solve(ab: int, bc: int, ca: int) returns (result: string)\n    requires ValidInput(ab, bc, ca)\n    ensures exists area :: ValidArea(ab, bc, area) && result == IntToString(area) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4256", "vc-description": "Given three integers A (cost per drink), B (available money), and C (maximum drinks desired),\ndetermine how many drinks will be purchased. The number of drinks purchased is the minimum of:\n- How many drinks can be afforded: B // A  \n- The satisfaction limit: C", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    exists i, j :: 0 <= i < j < |input| && input[i] == ' ' && input[j] == ' ' &&\n    (\n        var parts := SplitStringSpec(input);\n        |parts| >= 3 && \n        IsValidInteger(parts[0]) && IsValidInteger(parts[1]) && IsValidInteger(parts[2]) &&\n        var A := StringToIntSpec(parts[0]);\n        var B := StringToIntSpec(parts[1]);\n        var C := StringToIntSpec(parts[2]);\n        1 <= A <= 100 && 1 <= B <= 100 && 1 <= C <= 100\n    )\n}\n\nfunction ComputeDrinks(A: int, B: int, C: int): int\n    requires A >= 1 && B >= 1 && C >= 1\n{\n    if B / A < C then B / A else C\n}\n\nfunction IsValidInteger(s: string): bool\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction StringToIntSpec(s: string): int\n    requires IsValidInteger(s)\n    ensures StringToIntSpec(s) >= 0\n{\n    if |s| == 1 then s[0] as int - '0' as int\n    else StringToIntSpec(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction SplitStringSpec(s: string): seq<string>\n    ensures forall i :: 0 <= i < |SplitStringSpec(s)| ==> |SplitStringSpec(s)[i]| > 0\n    ensures forall i :: 0 <= i < |SplitStringSpec(s)| ==> forall j :: 0 <= j < |SplitStringSpec(s)[i]| ==> SplitStringSpec(s)[i][j] != ' ' && SplitStringSpec(s)[i][j] != '\\n' && SplitStringSpec(s)[i][j] != '\\t'\n{\n    if |s| == 0 then []\n    else \n        var parts := SplitHelper(s, 0, \"\");\n        parts\n}\n\nfunction SplitHelper(s: string, index: int, current: string): seq<string>\n    requires 0 <= index <= |s|\n    requires forall j :: 0 <= j < |current| ==> current[j] != ' ' && current[j] != '\\n' && current[j] != '\\t'\n    decreases |s| - index\n    ensures forall i :: 0 <= i < |SplitHelper(s, index, current)| ==> |SplitHelper(s, index, current)[i]| > 0\n    ensures forall i :: 0 <= i < |SplitHelper(s, index, current)| ==> forall j :: 0 <= j < |SplitHelper(s, index, current)[i]| ==> SplitHelper(s, index, current)[i][j] != ' ' && SplitHelper(s, index, current)[i][j] != '\\n' && SplitHelper(s, index, current)[i][j] != '\\t'\n{\n    if index >= |s| then\n        if |current| > 0 then [current] else []\n    else if s[index] == ' ' || s[index] == '\\n' || s[index] == '\\t' then\n        if |current| > 0 then [current] + SplitHelper(s, index + 1, \"\")\n        else SplitHelper(s, index + 1, \"\")\n    else\n        SplitHelper(s, index + 1, current + [s[index]])\n}\n\nfunction IntToStringSpec(n: int): string\n    requires n >= 0\n    ensures |IntToStringSpec(n)| > 0\n    ensures forall i :: 0 <= i < |IntToStringSpec(n)| ==> '0' <= IntToStringSpec(n)[i] <= '9'\n{\n    if n == 0 then \"0\"\n    else if n < 10 then [('0' as int + n) as char]\n    else IntToStringSpec(n / 10) + [('0' as int + (n % 10)) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures (\n        var parts := SplitStringSpec(input);\n        var A := StringToIntSpec(parts[0]);\n        var B := StringToIntSpec(parts[1]);\n        var C := StringToIntSpec(parts[2]);\n        var drinks := ComputeDrinks(A, B, C);\n        result == IntToStringSpec(drinks) + \"\\n\"\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4258", "vc-description": "A machine produces B biscuits at regular intervals of A seconds, starting at time A seconds.\nProductions occur at times A, 2A, 3A, 4A, ... seconds after activation.\nCalculate the total number of biscuits produced within the first T + 0.5 seconds.", "vc-preamble": "predicate ValidInput(A: int, B: int, T: int)\n{\n    1 <= A <= 20 && 1 <= B <= 20 && 1 <= T <= 20\n}\n\nfunction ProductionCount(A: int, T: int): int\n    requires A > 0\n{\n    T / A\n}\n\nfunction TotalBiscuits(A: int, B: int, T: int): int\n    requires A > 0\n{\n    B * ProductionCount(A, T)\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, T: int) returns (result: int)\n    requires ValidInput(A, B, T)\n    ensures result == TotalBiscuits(A, B, T)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4261", "vc-description": "Given two bottles where Bottle 1 has capacity A milliliters and currently contains B milliliters,\nand Bottle 2 currently contains C milliliters, transfer as much water as possible from Bottle 2\nto Bottle 1 and determine how much water remains in Bottle 2.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= b <= a <= 20 && 1 <= c <= 20\n}\n\nfunction RemainingWater(a: int, b: int, c: int): int\n    requires ValidInput(a, b, c)\n{\n    var availableSpace := a - b;\n    var remaining := c - availableSpace;\n    if remaining >= 0 then remaining else 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n             var parts := SplitOnSpaces(trimmed);\n             |parts| == 3\n    requires var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n             var parts := SplitOnSpaces(trimmed);\n             |parts| == 3 ==>\n             (forall i :: 0 <= i < |parts[0]| ==> '0' <= parts[0][i] <= '9') &&\n             (forall i :: 0 <= i < |parts[1]| ==> '0' <= parts[1][i] <= '9') &&\n             (forall i :: 0 <= i < |parts[2]| ==> '0' <= parts[2][i] <= '9') &&\n             |parts[0]| > 0 && |parts[1]| > 0 && |parts[2]| > 0\n    requires var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n             var parts := SplitOnSpaces(trimmed);\n             |parts| == 3 ==>\n             ValidInput(StringToInt(parts[0]), StringToInt(parts[1]), StringToInt(parts[2]))\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n            var parts := SplitOnSpaces(trimmed);\n            var a := StringToInt(parts[0]);\n            var b := StringToInt(parts[1]);\n            var c := StringToInt(parts[2]);\n            result == IntToString(RemainingWater(a, b, c)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4267", "vc-description": "Given a room temperature in degrees Celsius, determine whether to turn on an air conditioner.\nThe air conditioner should be turned on if and only if the temperature is 30\u00b0C or higher.", "vc-preamble": "predicate ValidTemperature(temp: int)\n{\n    -40 <= temp <= 40\n}\n\nfunction ExpectedOutput(temp: int): string\n{\n    if temp >= 30 then \"Yes\\n\" else \"No\\n\"\n}\n\npredicate CorrectOutput(temp: int, output: string)\n{\n    output == ExpectedOutput(temp)\n}", "vc-helpers": "", "vc-spec": "method solve(X: int) returns (result: string)\n    requires ValidTemperature(X)\n    ensures CorrectOutput(X, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4269", "vc-description": "Given a 4-digit security code, determine if it is \"hard to enter\". A code is hard to enter\nif it contains any two consecutive digits that are the same. Output \"Bad\" if the code is \nhard to enter, \"Good\" otherwise.", "vc-preamble": "predicate IsHardToEnter(s: string)\n    requires |s| == 4\n{\n    s[0] == s[1] || s[1] == s[2] || s[2] == s[3]\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| == 4\n    ensures result == \"Bad\" <==> IsHardToEnter(s)\n    ensures result == \"Good\" <==> !IsHardToEnter(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4271", "vc-description": "Calculate total satisfaction points from eating N dishes in a specific order.\nEach dish provides base satisfaction, plus bonus points for eating consecutive dishes in sequence.", "vc-preamble": "predicate ValidInput(N: int, A: seq<int>, B: seq<int>, C: seq<int>)\n{\n    N >= 1 &&\n    |A| == N &&\n    |B| == N &&\n    |C| == N - 1 &&\n    (forall i :: 0 <= i < N ==> 1 <= A[i] <= N) &&\n    (forall i, j :: 0 <= i < j < N ==> A[i] != A[j])\n}\n\nfunction SumSatisfaction(A: seq<int>, B: seq<int>, C: seq<int>, N: int): int\n    requires N >= 1\n    requires |A| == N\n    requires |B| == N\n    requires |C| == N - 1\n    requires forall i :: 0 <= i < N ==> 1 <= A[i] <= N\n{\n    SumSatisfactionUpTo(A, B, C, N)\n}\n\nfunction SumSatisfactionUpTo(A: seq<int>, B: seq<int>, C: seq<int>, k: int): int\n    requires 0 <= k <= |A|\n    requires |B| == |A|\n    requires |C| == |A| - 1\n    requires forall i :: 0 <= i < |A| ==> 1 <= A[i] <= |A|\n{\n    if k == 0 then 0\n    else\n        var prevSum := SumSatisfactionUpTo(A, B, C, k-1);\n        var baseContrib := B[A[k-1] - 1];\n        var bonusContrib := if k > 1 && A[k-1] == A[k-2] + 1 then C[A[k-1] - 2] else 0;\n        prevSum + baseContrib + bonusContrib\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, A: seq<int>, B: seq<int>, C: seq<int>) returns (result: int)\n    requires ValidInput(N, A, B, C)\n    ensures result == SumSatisfaction(A, B, C, N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4274", "vc-description": "Given N total test cases and M passed test cases, determine if all test cases \nwere passed. Input is a string with N and M separated by space. Output \"Yes\" \nif M = N (all passed), \"No\" otherwise. Constraints: 1 \u2264 N \u2264 100, 0 \u2264 M \u2264 N.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    exists lines :: lines == Split(input, '\\n') && |lines| > 0 &&\n    exists parts :: parts == Split(lines[0], ' ') && |parts| == 2 &&\n    exists n, m :: n == StringToInt(parts[0]) && \n                   m == StringToInt(parts[1]) &&\n                   1 <= n <= 100 && 0 <= m <= n\n}\n\nfunction ExtractN(input: string): int\nrequires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var parts := Split(lines[0], ' ');\n    StringToInt(parts[0])\n}\n\nfunction ExtractM(input: string): int\nrequires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var parts := Split(lines[0], ' ');\n    StringToInt(parts[1])\n}\n\npredicate CorrectOutput(input: string, result: string)\nrequires ValidInput(input)\n{\n    var n := ExtractN(input);\n    var m := ExtractM(input);\n    (n == m ==> result == \"Yes\") && (n != m ==> result == \"No\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires ValidInput(input)\nensures CorrectOutput(input, result)\nensures result == \"Yes\" || result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4275", "vc-description": "Given a string of length 6 consisting of lowercase English letters, determine if it is \"coffee-like\".\nA string is coffee-like if characters at positions 3 and 4 are equal, AND characters at positions 5 and 6 are equal (using 1-based indexing).", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| == 6 && forall i :: 0 <= i < 6 ==> 'a' <= s[i] <= 'z'\n}\n\npredicate IsCoffeeLike(s: string)\nrequires ValidInput(s)\n{\n    s[2] == s[3] && s[4] == s[5]\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\nrequires ValidInput(s)\nensures result == \"Yes\" || result == \"No\"\nensures IsCoffeeLike(s) <==> result == \"Yes\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4277", "vc-description": "Given N people traveling together, determine the minimum cost between two transportation options:\nTrain costs A yen per person (total: N*A), Taxi costs B yen total (fixed cost).\nFind the minimum total travel expense.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int)\n{\n    1 <= n <= 20 && 1 <= a <= 50 && 1 <= b <= 50\n}\n\nfunction TrainCost(n: int, a: int): int\n{\n    n * a\n}\n\nfunction MinimumCost(n: int, a: int, b: int): int\n{\n    var trainCost := TrainCost(n, a);\n    if trainCost < b then trainCost else b\n}\n\npredicate CorrectResult(input: string, result: string)\n{\n    var lines := SplitString(input, '\\n');\n    if |lines| > 0 then\n        var parts := SplitString(lines[0], ' ');\n        if |parts| >= 3 && IsValidInteger(parts[0]) && IsValidInteger(parts[1]) && IsValidInteger(parts[2]) then\n            var n := StringToInt(parts[0]);\n            var a := StringToInt(parts[1]);\n            var b := StringToInt(parts[2]);\n            ValidInput(n, a, b) ==> result == IntToString(MinimumCost(n, a, b)) + \"\\n\"\n        else\n            result == \"\"\n    else\n        result == \"\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures CorrectResult(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4284", "vc-description": "Given q queries with battery charge k, n turns, and two actions with costs a and b (where b < a),\nfind the maximum number of Action A turns possible while completing exactly n turns and keeping\ncharge > 0 at the end, or return -1 if impossible.", "vc-preamble": "predicate ValidQuery(k: int, n: int, a: int, b: int)\n{\n    k > 0 && n > 0 && a > 0 && b > 0 && b < a\n}\n\nfunction MaxActionATurns(k: int, n: int, a: int, b: int): int\n    requires ValidQuery(k, n, a, b)\n{\n    if n * b > k then \n        -1\n    else \n        var maxPossible := (k - n * b - 1) / (a - b);\n        if n <= maxPossible then n else maxPossible\n}\n\npredicate ValidResult(result: int, k: int, n: int, a: int, b: int)\n    requires ValidQuery(k, n, a, b)\n{\n    result == -1 || (0 <= result <= n)\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<(int, int, int, int)>) returns (results: seq<int>)\n    requires |queries| > 0\n    requires forall i :: 0 <= i < |queries| ==> \n        var (k, n, a, b) := queries[i];\n        ValidQuery(k, n, a, b)\n    ensures |results| == |queries|\n    ensures forall i :: 0 <= i < |queries| ==> \n        var (k, n, a, b) := queries[i];\n        results[i] == MaxActionATurns(k, n, a, b)\n    ensures forall i :: 0 <= i < |results| ==> \n        var (k, n, a, b) := queries[i];\n        ValidResult(results[i], k, n, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4294", "vc-description": "Given two integers X and A (both between 0 and 9 inclusive), output 0 if X is less than A, otherwise output 10.", "vc-preamble": "predicate ValidInput(x: int, a: int)\n{\n    0 <= x <= 9 && 0 <= a <= 9\n}\n\npredicate CorrectOutput(x: int, a: int, result: int)\n{\n    result == (if x < a then 0 else 10)\n}", "vc-helpers": "", "vc-spec": "method Solve(x: int, a: int) returns (result: int)\n    requires ValidInput(x, a)\n    ensures CorrectOutput(x, a, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4295", "vc-description": "Given integers N and K, repeatedly perform the operation N := |N - K| to find\nthe minimum possible value N can achieve after zero or more operations.", "vc-preamble": "predicate ValidInput(n: int, k: int) {\n    n >= 0 && k >= 1\n}\n\nfunction MinValue(n: int, k: int): int\n    requires ValidInput(n, k)\n{\n    var remainder := n % k;\n    var complement := k - remainder;\n    if remainder <= complement then remainder else complement\n}\n\npredicate IsCorrectResult(n: int, k: int, result: int) \n    requires ValidInput(n, k)\n{\n    result == MinValue(n, k) &&\n    result >= 0 &&\n    result < k\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures IsCorrectResult(n, k, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4297", "vc-description": "Given a positive integer N, find the smallest positive integer that is divisible by both 2 and N.\nThis is equivalent to finding the least common multiple of 2 and N.", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 1\n}\n\npredicate DivisibleByBoth(result: int, n: int)\n    requires n >= 1\n{\n    result % 2 == 0 && result % n == 0\n}\n\npredicate IsSmallest(result: int, n: int)\n    requires n >= 1\n{\n    forall k: int :: 1 <= k < result ==> !(k % 2 == 0 && k % n == 0)\n}\n\nfunction LCM(a: int, b: int): int\n    requires a >= 1 && b >= 1\n{\n    if a % b == 0 then a\n    else if b % a == 0 then b\n    else a * b\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result >= 1\n    ensures DivisibleByBoth(result, n)\n    ensures IsSmallest(result, n)\n    ensures (n % 2 == 0 ==> result == n) && (n % 2 != 0 ==> result == n * 2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4298", "vc-description": "Given N apple trees numbered 1 to N in a row, find the minimum number of inspectors\nneeded to inspect all trees. Each inspector at position i covers trees from (i-D) to (i+D).", "vc-preamble": "predicate ValidInput(N: int, D: int)\n{\n  N >= 1 && N <= 20 && D >= 1 && D <= 20\n}\n\nfunction CoverageRange(position: int, D: int): (int, int)\n{\n  (position - D, position + D)\n}\n\npredicate TreesCovered(N: int, D: int, inspectors: int)\n{\n  inspectors >= 1 && inspectors <= N && inspectors == ((N - 1) / (2 * D + 1)) + 1\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4299", "vc-description": "Given a positive integer N (1 \u2264 N \u2264 999), determine the pronunciation of the Japanese counter word \"\u672c\" \nbased on the ones digit of N. The pronunciation rules are: \"hon\" for ones digits 2,4,5,7,9; \n\"pon\" for ones digits 0,1,6,8; and \"bon\" for ones digit 3.", "vc-preamble": "predicate ValidInput(N: int) {\n    1 <= N <= 999\n}\n\npredicate IsHonDigit(digit: int) {\n    digit == 2 || digit == 4 || digit == 5 || digit == 7 || digit == 9\n}\n\npredicate IsPonDigit(digit: int) {\n    digit == 0 || digit == 1 || digit == 6 || digit == 8\n}\n\npredicate IsBonDigit(digit: int) {\n    digit == 3\n}\n\nfunction CorrectPronunciation(N: int): string\n    requires ValidInput(N)\n{\n    var ones_digit := N % 10;\n    if IsHonDigit(ones_digit) then \"hon\\n\"\n    else if IsPonDigit(ones_digit) then \"pon\\n\"\n    else \"bon\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: string)\n    requires ValidInput(N)\n    ensures result == CorrectPronunciation(N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4301", "vc-description": "Given a sequence of N integers, for each position i, find the maximum value \namong all N-1 elements excluding the element at position i.", "vc-preamble": "function max_of_seq(s: seq<int>): int\n    requires |s| >= 1\n    ensures forall i :: 0 <= i < |s| ==> s[i] <= max_of_seq(s)\n    ensures exists i :: 0 <= i < |s| && s[i] == max_of_seq(s)\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= max_of_seq(s[1..]) then s[0]\n    else max_of_seq(s[1..])\n}\n\nfunction max_excluding(s: seq<int>, exclude_idx: int): int\n    requires 0 <= exclude_idx < |s|\n    requires |s| >= 2\n{\n    var others := s[..exclude_idx] + s[exclude_idx+1..];\n    max_of_seq(others)\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<int>) returns (result: seq<int>)\n    requires |input| >= 2\n    ensures |result| == |input|\n    ensures forall i :: 0 <= i < |input| ==> result[i] == max_excluding(input, i)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4304", "vc-description": "Given uncovered heights of two adjacent towers after snowfall, find the snow depth.\nTowers have triangular number heights: 1, 3, 6, 10, ... (i-th tower height = i*(i+1)/2).\nSnow covers uniformly to same depth everywhere.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n  a >= 1 && b > a && b < 499500\n}\n\npredicate ValidSnowDepth(a: int, b: int, depth: int)\n{\n  depth >= 1 &&\n  ((b - a) * (b - a) - (a + b)) >= 2 &&\n  ((b - a) * (b - a) - (a + b)) % 2 == 0\n}\n\nfunction SnowDepthFormula(a: int, b: int): int\n  requires ValidInput(a, b)\n  requires ValidSnowDepth(a, b, ((b - a) * (b - a) - (a + b)) / 2)\n{\n  ((b - a) * (b - a) - (a + b)) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n  requires ValidInput(a, b)\n  requires ValidSnowDepth(a, b, ((b - a) * (b - a) - (a + b)) / 2)\n  ensures result >= 1\n  ensures result == SnowDepthFormula(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4305", "vc-description": "Given a monster with health H and attack damage A, find the minimum number of attacks needed to reduce the monster's health to 0 or below.", "vc-preamble": "predicate ValidInput(H: int, A: int)\n{\n    H >= 1 && A >= 1\n}\n\npredicate IsMinimumAttacks(attacks: int, H: int, A: int)\n{\n    attacks >= 1 &&\n    attacks * A >= H &&\n    (attacks - 1) * A < H\n}\n\nfunction CeilDiv(H: int, A: int): int\n    requires A > 0\n{\n    (H + A - 1) / A\n}", "vc-helpers": "", "vc-spec": "method solve(H: int, A: int) returns (attacks: int)\n    requires ValidInput(H, A)\n    ensures IsMinimumAttacks(attacks, H, A)\n    ensures attacks == CeilDiv(H, A)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4306", "vc-description": "Given two time intervals [A, B) and [C, D), find the length of their intersection.\nAlice holds a button from time A to time B (exclusive).\nBob holds a button from time C to time D (exclusive).\nCalculate how many seconds both are holding their buttons simultaneously.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int)\n{\n    0 <= a < b <= 100 && 0 <= c < d <= 100\n}\n\nfunction min(x: int, y: int): int\n{\n    if x < y then x else y\n}\n\nfunction max(x: int, y: int): int\n{\n    if x > y then x else y\n}\n\nfunction IntervalOverlapLength(a: int, b: int, c: int, d: int): int\n{\n    if min(b, d) - max(a, c) > 0 then min(b, d) - max(a, c) else 0\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int) returns (result: int)\n    requires ValidInput(a, b, c, d)\n    ensures result >= 0\n    ensures result == IntervalOverlapLength(a, b, c, d)\n    ensures result <= 100", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4307", "vc-description": "Count how many odd positive integers between 1 and N (inclusive) have exactly 8 positive divisors,\nwhere N is between 1 and 200.", "vc-preamble": "predicate IsOdd(n: int) {\n    n % 2 == 1\n}\n\nfunction CountDivisors(n: nat): nat\n    requires n > 0\n{\n    |set d | 1 <= d <= n && n % d == 0|\n}\n\npredicate HasEightDivisors(n: nat)\n    requires n > 0\n{\n    CountDivisors(n) == 8\n}\n\nfunction CountOddWithEightDivisors(N: nat): nat {\n    |set i | 1 <= i <= N && IsOdd(i) && i > 0 && HasEightDivisors(i)|\n}\n\npredicate ValidInput(N: int) {\n    1 <= N <= 200\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (count: int)\n    requires ValidInput(N)\n    ensures N < 105 ==> count == 0\n    ensures 105 <= N < 135 ==> count == 1\n    ensures 135 <= N < 165 ==> count == 2\n    ensures 165 <= N < 189 ==> count == 3\n    ensures 189 <= N < 195 ==> count == 4\n    ensures N >= 195 ==> count == 5\n    ensures 0 <= count <= 5", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4308", "vc-description": "Distribute N crackers to K users as evenly as possible and find the minimum \npossible absolute difference between the maximum and minimum number of crackers \nreceived by any user.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 1 && n <= 100 && k <= 100\n}\n\nfunction MinCrackerDifference(n: int, k: int): int\n    requires k > 0\n{\n    if n % k == 0 then 0 else 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures result == MinCrackerDifference(n, k)\n    ensures result == 0 <==> n % k == 0\n    ensures result == 1 <==> n % k != 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4310", "vc-description": "Given three tasks with integer values A1, A2, A3, find the minimum cost to complete all tasks.\nRules: Complete any one task first at cost 0, then completing task i followed by task j costs |Aj - Ai|.\nAll tasks must be completed.", "vc-preamble": "predicate ValidInput(A1: int, A2: int, A3: int)\n{\n    1 <= A1 <= 100 && 1 <= A2 <= 100 && 1 <= A3 <= 100\n}\n\nfunction MaxOfThree(A1: int, A2: int, A3: int): int\n{\n    if A1 >= A2 && A1 >= A3 then A1 else if A2 >= A3 then A2 else A3\n}\n\nfunction MinOfThree(A1: int, A2: int, A3: int): int\n{\n    if A1 <= A2 && A1 <= A3 then A1 else if A2 <= A3 then A2 else A3\n}\n\nfunction MinimumCost(A1: int, A2: int, A3: int): int\n{\n    MaxOfThree(A1, A2, A3) - MinOfThree(A1, A2, A3)\n}", "vc-helpers": "", "vc-spec": "method solve(A1: int, A2: int, A3: int) returns (result: int)\n    requires ValidInput(A1, A2, A3)\n    ensures result >= 0\n    ensures result == MinimumCost(A1, A2, A3)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4312", "vc-description": "Two monsters battle in turns. Takahashi's monster (health A, strength B) attacks first,\nthen they alternate. Each attack reduces opponent's health by attacker's strength.\nFirst monster to reach 0 or below health loses. Determine if Takahashi wins.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int, D: int)\n{\n  1 <= A <= 100 && 1 <= B <= 100 && 1 <= C <= 100 && 1 <= D <= 100\n}\n\nfunction TurnsToDefeat(health: int, strength: int): int\n  requires strength > 0\n{\n  (health + strength - 1) / strength\n}\n\npredicate TakahashiWins(A: int, B: int, C: int, D: int)\n  requires ValidInput(A, B, C, D)\n{\n  var takahashi_turns := TurnsToDefeat(C, B);\n  var aoki_turns := TurnsToDefeat(A, D);\n  aoki_turns >= takahashi_turns\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int, D: int) returns (result: string)\n  requires ValidInput(A, B, C, D)\n  ensures result == (if TakahashiWins(A, B, C, D) then \"Yes\" else \"No\")\n  ensures result == \"Yes\" || result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4313", "vc-description": "Given N gems with values and costs, select a subset to maximize total profit\n(sum of selected values minus sum of selected costs). Only gems with positive\nprofit should be selected to achieve maximum profit.", "vc-preamble": "function SumOfPositiveProfits(values: seq<int>, costs: seq<int>, n: int): int\n    requires |values| >= n\n    requires |costs| >= n\n    requires n >= 0\n{\n    if n == 0 then 0\n    else \n        var profit := values[n-1] - costs[n-1];\n        SumOfPositiveProfits(values, costs, n-1) + (if profit > 0 then profit else 0)\n}\n\npredicate ValidInput(n: int, values: seq<int>, costs: seq<int>)\n{\n    |values| == n && |costs| == n && n >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, values: seq<int>, costs: seq<int>) returns (result: int)\n    requires ValidInput(n, values, costs)\n    ensures result >= 0\n    ensures result == SumOfPositiveProfits(values, costs, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4317", "vc-description": "Given two integers A and B, find the maximum value among A + B, A - B, and A \u00d7 B.\nInput constraints: -100 \u2264 A, B \u2264 100", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 3 &&\n    exists spacePos :: 0 < spacePos < |input| - 1 && input[spacePos] == ' ' &&\n    (forall i :: 0 <= i < spacePos ==> input[i] != ' ') &&\n    (forall i :: spacePos + 1 <= i < |input| ==> input[i] != ' ' || input[i] == '\\n') &&\n    isValidInteger(getAString(input)) && isValidInteger(getBString(input)) &&\n    -100 <= getA(input) <= 100 && -100 <= getB(input) <= 100\n}\n\nfunction getA(input: string): int\n    requires |input| >= 3\n    requires exists spacePos :: 0 < spacePos < |input| - 1 && input[spacePos] == ' '\n    requires isValidInteger(getAString(input))\n{\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var spaceIndex := findSpace(trimmed);\n    parseInt(trimmed[..spaceIndex])\n}\n\nfunction getB(input: string): int\n    requires |input| >= 3\n    requires exists spacePos :: 0 < spacePos < |input| - 1 && input[spacePos] == ' '\n    requires isValidInteger(getBString(input))\n{\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var spaceIndex := findSpace(trimmed);\n    parseInt(trimmed[spaceIndex+1..])\n}\n\nfunction getAString(input: string): string\n    requires |input| >= 3\n    requires exists spacePos :: 0 < spacePos < |input| - 1 && input[spacePos] == ' '\n{\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var spaceIndex := findSpace(trimmed);\n    trimmed[..spaceIndex]\n}\n\nfunction getBString(input: string): string\n    requires |input| >= 3\n    requires exists spacePos :: 0 < spacePos < |input| - 1 && input[spacePos] == ' '\n{\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var spaceIndex := findSpace(trimmed);\n    trimmed[spaceIndex+1..]\n}\n\nfunction max3(a: int, b: int, c: int): int\n    ensures max3(a, b, c) >= a && max3(a, b, c) >= b && max3(a, b, c) >= c\n    ensures max3(a, b, c) == a || max3(a, b, c) == b || max3(a, b, c) == c\n{\n    if a >= b && a >= c then a\n    else if b >= c then b\n    else c\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures var maxVal := max3(getA(input) + getB(input), getA(input) - getB(input), getA(input) * getB(input));\n            result == intToString(maxVal) + \"\\n\"\n    ensures var maxVal := max3(getA(input) + getB(input), getA(input) - getB(input), getA(input) * getB(input));\n            -10000 <= maxVal <= 10000", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4318", "vc-description": "Given N mountains indexed from west to east with heights, count how many mountain inns \nallow ocean visibility. Mountain 1 (westmost) always has visibility. Mountain i (i \u2265 2) \nhas visibility if and only if its height is greater than or equal to the maximum height \nof all mountains to its west.", "vc-preamble": "function maxHeightUpTo(heights: seq<int>, up_to_index: int): int\n  requires 0 <= up_to_index < |heights|\n  decreases up_to_index\n{\n  if up_to_index == 0 then heights[0]\n  else if heights[up_to_index] >= maxHeightUpTo(heights, up_to_index - 1) then heights[up_to_index]\n  else maxHeightUpTo(heights, up_to_index - 1)\n}\n\npredicate hasOceanVisibility(heights: seq<int>, mountain_index: int)\n  requires 0 <= mountain_index < |heights|\n{\n  mountain_index == 0 || heights[mountain_index] >= maxHeightUpTo(heights, mountain_index - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, heights: seq<int>) returns (result: int)\n  requires N > 0\n  requires |heights| == N\n  requires N <= 20\n  requires forall i :: 0 <= i < N ==> 1 <= heights[i] <= 100\n  ensures 1 <= result <= N\n  ensures result == |set i | 0 <= i < N && hasOceanVisibility(heights, i)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4326", "vc-description": "Given N students, divide them into groups such that the number of groups \ncontaining 3 or more students is maximized. Groups with 2 or fewer students \nare not counted toward the result.", "vc-preamble": "predicate ValidInput(n: int) {\n    1 <= n <= 1000\n}\n\nfunction MaxGroupsWithAtLeastThree(n: int): int\n    requires ValidInput(n)\n{\n    n / 3\n}\n\npredicate ValidSolution(n: int, result: int) \n    requires ValidInput(n)\n{\n    result == MaxGroupsWithAtLeastThree(n) &&\n    result >= 0 &&\n    result <= n\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4327", "vc-description": "Given A whole apples and P apple pieces, determine the maximum number of apple pies that can be made.\nEach whole apple can be cut into 3 pieces, and each apple pie requires 2 pieces to make.", "vc-preamble": "predicate ValidInput(A: int, P: int)\n{\n    0 <= A <= 100 && 0 <= P <= 100\n}\n\nfunction TotalPieces(A: int, P: int): int\n    requires ValidInput(A, P)\n{\n    A * 3 + P\n}\n\nfunction MaxPies(A: int, P: int): int\n    requires ValidInput(A, P)\n{\n    TotalPieces(A, P) / 2\n}", "vc-helpers": "", "vc-spec": "method CalculateMaxPies(A: int, P: int) returns (pies: int)\n    requires ValidInput(A, P)\n    ensures pies == MaxPies(A, P)\n    ensures pies >= 0\n    ensures pies == (A * 3 + P) / 2", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_433", "vc-description": "Given a circular building with n entrances numbered 1 to n, determine the final entrance\nnumber after walking from entrance a by b entrances. Positive b means walking forward\n(increasing order), negative b means walking backward (decreasing order), and b=0 means\nstaying at the starting entrance.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int) {\n    n >= 1 && 1 <= a <= n && -100 <= b <= 100\n}\n\nfunction FinalEntrance(n: int, a: int, b: int): int\n    requires ValidInput(n, a, b)\n{\n    ((a - 1 + b) % n + n) % n + 1\n}\n\npredicate ValidOutput(result: int, n: int) {\n    1 <= result <= n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int) returns (result: int)\n    requires ValidInput(n, a, b)\n    ensures ValidOutput(result, n)\n    ensures result == FinalEntrance(n, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4331", "vc-description": "Given a three-digit integer N, determine if it contains the digit 7.\nReturn \"Yes\" if N contains the digit 7, \"No\" otherwise.", "vc-preamble": "predicate ValidInput(N: int) {\n    100 <= N <= 999\n}\n\npredicate ContainsSeven(N: int) \n    requires ValidInput(N)\n{\n    (N % 10) == 7 || ((N / 10) % 10) == 7 || (N / 100) == 7\n}\n\npredicate ValidOutput(result: string) {\n    result == \"Yes\\n\" || result == \"No\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: string)\n    requires ValidInput(N)\n    ensures ValidOutput(result)\n    ensures result == \"Yes\\n\" <==> ContainsSeven(N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4332", "vc-description": "Given an integer N, determine if the sum of its digits divides N evenly.\nLet S(N) be the sum of all digits in the decimal representation of N.\nCheck if N is divisible by S(N).\nInput: A single integer N (1 \u2264 N \u2264 10^9)\nOutput: \"Yes\" if S(N) divides N, \"No\" otherwise", "vc-preamble": "predicate IsDigit(c: char)\n{\n    '0' <= c <= '9'\n}\n\nfunction DigitValue(c: char): int\n    requires IsDigit(c)\n{\n    c as int - '0' as int\n}\n\nfunction SumOfDigits(s: string): int\n{\n    if |s| == 0 then 0\n    else if IsDigit(s[0]) then DigitValue(s[0]) + SumOfDigits(s[1..])\n    else SumOfDigits(s[1..])\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if IsDigit(s[0]) then StringToInt(s[1..]) + DigitValue(s[0]) * Power10(|s|-1)\n    else StringToInt(s[1..])\n}\n\nfunction Power10(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 1 else 10 * Power10(n-1)\n}\n\nfunction CleanInput(input: string): string\n{\n    if |input| == 0 then \"\"\n    else if input[|input|-1] == '\\n' || input[|input|-1] == ' ' then CleanInput(input[..|input|-1])\n    else input\n}\n\npredicate ValidPositiveIntegerString(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> IsDigit(s[i])) && \n    (|s| > 1 ==> s[0] != '0') && \n    StringToInt(s) > 0\n}\n\npredicate ValidInput(input: string)\n{\n    ValidPositiveIntegerString(CleanInput(input))\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures var cleaned := CleanInput(input);\n            var n := StringToInt(cleaned);\n            var digitSum := SumOfDigits(cleaned);\n            digitSum > 0 && \n            ((result == \"Yes\") <==> (n % digitSum == 0)) &&\n            ((result == \"No\") <==> (n % digitSum != 0))\n    ensures var cleaned := CleanInput(input);\n            var n := StringToInt(cleaned);\n            n >= 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4333", "vc-description": "Given two adjacent vertices of a square in counter-clockwise order, find the coordinates of the remaining two vertices.\nThe input consists of four integers representing coordinates (x1,y1) and (x2,y2) of two adjacent vertices.\nThe output should be four integers representing coordinates (x3,y3) and (x4,y4) of the remaining vertices in counter-clockwise order.", "vc-preamble": "predicate ValidInput(x1: int, y1: int, x2: int, y2: int) {\n    (x1, y1) != (x2, y2) &&\n    -100 <= x1 <= 100 && -100 <= y1 <= 100 &&\n    -100 <= x2 <= 100 && -100 <= y2 <= 100\n}\n\nfunction ComputeThirdVertex(x1: int, y1: int, x2: int, y2: int): (int, int) {\n    (x2 - (y2 - y1), y2 + (x2 - x1))\n}\n\nfunction ComputeFourthVertex(x1: int, y1: int, x2: int, y2: int): (int, int) {\n    (x1 - (y2 - y1), y1 + (x2 - x1))\n}\n\npredicate ValidOutput(x1: int, y1: int, x2: int, y2: int, result: seq<int>) {\n    |result| == 4 &&\n    result[0] == ComputeThirdVertex(x1, y1, x2, y2).0 &&\n    result[1] == ComputeThirdVertex(x1, y1, x2, y2).1 &&\n    result[2] == ComputeFourthVertex(x1, y1, x2, y2).0 &&\n    result[3] == ComputeFourthVertex(x1, y1, x2, y2).1\n}", "vc-helpers": "", "vc-spec": "method solve(x1: int, y1: int, x2: int, y2: int) returns (result: seq<int>)\n    requires ValidInput(x1, y1, x2, y2)\n    ensures ValidOutput(x1, y1, x2, y2, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4335", "vc-description": "Given a positive integer N and a string S of length N consisting of lowercase English letters,\ndetermine whether S can be expressed as the concatenation of two identical strings (S = T + T for some string T).\nReturn \"Yes\" if S is a concatenation of two copies of some string; otherwise, return \"No\".", "vc-preamble": "predicate ValidInput(N: int, S: string)\n{\n    1 <= N <= 100 && |S| == N && forall i :: 0 <= i < |S| ==> 'a' <= S[i] <= 'z'\n}\n\npredicate IsConcatenationOfTwoCopies(S: string)\n{\n    |S| % 2 == 0 && forall i :: 0 <= i < |S|/2 ==> S[i] == S[|S|/2 + i]\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, S: string) returns (result: string)\n    requires ValidInput(N, S)\n    ensures result == \"Yes\" || result == \"No\"\n    ensures N % 2 != 0 ==> result == \"No\"\n    ensures N % 2 == 0 ==> (result == \"Yes\" <==> IsConcatenationOfTwoCopies(S))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4337", "vc-description": "Given N colorful crackers with colors P, W, G, or Y, determine if exactly 3 or 4 distinct colors are present.\nThe bag always contains at least one cracker of each color P, W, and G.\nOutput \"Three\" if 3 distinct colors, \"Four\" if 4 distinct colors.", "vc-preamble": "predicate ValidInput(n: int, colors: seq<char>)\n{\n    1 <= n <= 100 &&\n    |colors| == n &&\n    (forall c | c in colors :: c in {'P', 'W', 'G', 'Y'}) &&\n    'P' in colors && 'W' in colors && 'G' in colors\n}\n\nfunction DistinctColors(colors: seq<char>): set<char>\n{\n    set c | c in colors\n}\n\nfunction SolutionString(distinctCount: int): string\n    requires distinctCount == 3 || distinctCount == 4\n{\n    if distinctCount == 3 then \"Three\" else \"Four\"\n}", "vc-helpers": "", "vc-spec": "method Solve(n: int, colors: seq<char>) returns (result: string)\n    requires ValidInput(n, colors)\n    ensures var distinctColors := DistinctColors(colors);\n            |distinctColors| == 3 || |distinctColors| == 4\n    ensures var distinctColors := DistinctColors(colors);\n            (|distinctColors| == 3 ==> result == \"Three\") &&\n            (|distinctColors| == 4 ==> result == \"Four\")\n    ensures result == \"Three\" || result == \"Four\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4340", "vc-description": "Transform an array of integers where odd numbers remain unchanged and even numbers are decremented by 1.", "vc-preamble": "function TransformElement(x: int): int\n{\n    if x % 2 == 0 then x - 1 else x\n}\n\npredicate ValidTransformation(input: seq<int>, output: seq<int>)\n{\n    |output| == |input| &&\n    forall i :: 0 <= i < |input| ==> output[i] == TransformElement(input[i])\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: seq<int>)\n    ensures ValidTransformation(a, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4343", "vc-description": "Given two strings s and t of length k consisting of lowercase Latin letters,\nwhere s is lexicographically less than t, find the median string in the\nlexicographically ordered list of all strings of length k that are\nlexicographically between s and t (inclusive).", "vc-preamble": "function median_string(s: string, t: string, k: int): string\n    requires k >= 1\n    requires |s| == k && |t| == k\n    requires forall i :: 0 <= i < k ==> 'a' <= s[i] <= 'z'\n    requires forall i :: 0 <= i < k ==> 'a' <= t[i] <= 'z'\n    requires s < t\n{\n    var s_val := string_to_base26(s);\n    var t_val := string_to_base26(t);\n    var median_val := (s_val + t_val) / 2;\n    base26_to_string(median_val, k)\n}\n\nfunction string_to_base26(s: string): nat\n    requires forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n{\n    if |s| == 0 then 0\n    else (s[0] as int - 'a' as int) * pow26(|s| - 1) + string_to_base26(s[1..])\n}\n\nfunction base26_to_string(val: nat, k: int): string\n    requires k >= 1\n    ensures |base26_to_string(val, k)| == k\n    ensures forall i :: 0 <= i < k ==> 'a' <= base26_to_string(val, k)[i] <= 'z'\n{\n    if k == 1 then [((val % 26) + ('a' as int)) as char]\n    else base26_to_string(val / 26, k - 1) + [((val % 26) + ('a' as int)) as char]\n}\n\nfunction pow26(n: nat): nat\n{\n    if n == 0 then 1 else 26 * pow26(n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, s: string, t: string) returns (result: string)\n    requires k >= 1\n    requires |s| == k\n    requires |t| == k\n    requires forall i :: 0 <= i < k ==> 'a' <= s[i] <= 'z'\n    requires forall i :: 0 <= i < k ==> 'a' <= t[i] <= 'z'\n    requires s < t\n    ensures |result| == k\n    ensures forall i :: 0 <= i < k ==> 'a' <= result[i] <= 'z'\n    ensures s <= result <= t\n    ensures result == median_string(s, t, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4346", "vc-description": "Count visible lanterns on a train path from point 1 to point L. \nLanterns are located at positions divisible by v (i.e., at positions v, 2v, 3v, ...). \nA standing train blocks visibility at positions l through r (inclusive). \nDetermine how many lanterns are visible (not blocked by the standing train).", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| > 0 &&\n    IsValidInteger(lines[0]) &&\n    var t := ParseInt(lines[0]);\n    t >= 0 && |lines| >= t + 1 &&\n    (forall i :: 1 <= i <= t ==> (\n        |SplitSpaces(lines[i])| >= 4 &&\n        (forall j :: 0 <= j < 4 ==> IsValidInteger(SplitSpaces(lines[i])[j])) &&\n        var parts := SplitSpaces(lines[i]);\n        var L := ParseInt(parts[0]);\n        var v := ParseInt(parts[1]);\n        var l := ParseInt(parts[2]);\n        var r := ParseInt(parts[3]);\n        L >= 1 && v >= 1 && l >= 1 && r >= l && r <= L\n    ))\n}\n\npredicate ValidOutput(output: string, input: string)\n{\n    forall c :: c in output ==> (c >= '0' && c <= '9') || c == '-' || c == '\\n'\n}\n\npredicate OutputMatchesAlgorithm(output: string, input: string)\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var t := ParseInt(lines[0]);\n    t >= 0 &&\n    var expectedLines := seq(t, i requires 0 <= i < t => \n        if i + 1 < |lines| && |SplitSpaces(lines[i + 1])| >= 4 then\n            var parts := SplitSpaces(lines[i + 1]);\n            var L := ParseInt(parts[0]);\n            var v := ParseInt(parts[1]);\n            var l := ParseInt(parts[2]);\n            var r := ParseInt(parts[3]);\n            var totalLanterns := L / v;\n            var blockedLanterns := r / v - (l - 1) / v;\n            var visibleLanterns := totalLanterns - blockedLanterns;\n            IntToString(visibleLanterns)\n        else\n            \"0\"\n    );\n    output == JoinLines(expectedLines)\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && (\n        (s[0] == '-' && |s| > 1 && forall i :: 1 <= i < |s| ==> s[i] >= '0' && s[i] <= '9') ||\n        (s[0] != '-' && forall i :: 0 <= i < |s| ==> s[i] >= '0' && s[i] <= '9')\n    )\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures ValidOutput(output, input)\n    ensures OutputMatchesAlgorithm(output, input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4347", "vc-description": "Given n people where n is even, find the number of ways to divide them into exactly two \nindistinguishable round dances, each containing exactly n/2 people. A round dance is a \ncircular arrangement where rotations are considered identical, and both the rotations \nwithin each dance and the two dances themselves are indistinguishable.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 2 && n % 2 == 0 && n <= 20\n}\n\nfunction ExpectedResult(n: int): int\n    requires ValidInput(n)\n{\n    var half := n / 2;\n    var factN := factorial(n);\n    var factHalf := factorial(half);\n    var factHalfMinus1 := factorial(half - 1);\n    var binomial := factN / (factHalf * factHalf);\n    var arrangements := factHalfMinus1 * factHalfMinus1;\n    (binomial * arrangements) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == ExpectedResult(n)\n    ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4351", "vc-description": "Given a three-digit positive integer N (100 \u2264 N \u2264 999), determine if it is palindromic\n(reads the same forwards and backwards in decimal notation).", "vc-preamble": "predicate ValidInput(n: int)\n{\n  100 <= n <= 999\n}\n\npredicate IsPalindromic(n: int)\n  requires ValidInput(n)\n{\n  var hundreds := n / 100;\n  var units := n % 10;\n  hundreds == units\n}\n\npredicate IsWhitespace(c: char)\n{\n  c == ' ' || c == '\\n' || c == '\\t' || c == '\\r'\n}\n\npredicate IsDigit(c: char)\n{\n  '0' <= c <= '9'\n}\n\npredicate CanParseAsInt(s: string)\n{\n  |s| > 0 && (\n    (|s| == 1 && IsDigit(s[0])) ||\n    (|s| > 1 && s[0] == '-' && forall i :: 1 <= i < |s| ==> IsDigit(s[i])) ||\n    (|s| > 1 && IsDigit(s[0]) && forall i :: 1 <= i < |s| ==> IsDigit(s[i]))\n  )\n}\n\nfunction ParseIntValue(s: string): int\n  requires CanParseAsInt(s)\n{\n  if |s| == 1 then s[0] as int - '0' as int\n  else if s[0] == '-' then -ParsePositiveInt(s[1..])\n  else ParsePositiveInt(s)\n}\n\nfunction ParsePositiveInt(s: string): int\n  requires |s| > 0 && forall i :: 0 <= i < |s| ==> IsDigit(s[i])\n  decreases |s|\n{\n  if |s| == 1 then s[0] as int - '0' as int\n  else ParsePositiveInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction TokenizeInput(input: string): seq<string>\n{\n  if |input| == 0 then []\n  else TokenizeFromIndex(input, 0, \"\", [])\n}\n\nfunction TokenizeFromIndex(input: string, index: int, current_token: string, acc: seq<string>): seq<string>\n  requires 0 <= index <= |input|\n  decreases |input| - index, if index < |input| && IsWhitespace(input[index]) then 1 else 0\n{\n  if index == |input| then\n    if |current_token| > 0 then acc + [current_token] else acc\n  else if IsWhitespace(input[index]) then\n    if |current_token| > 0 then\n      TokenizeFromIndex(input, SkipWhitespace(input, index), \"\", acc + [current_token])\n    else\n      TokenizeFromIndex(input, SkipWhitespace(input, index), \"\", acc)\n  else\n    TokenizeFromIndex(input, index + 1, current_token + [input[index]], acc)\n}\n\nfunction SkipWhitespace(input: string, index: int): int\n  requires 0 <= index <= |input|\n  ensures SkipWhitespace(input, index) <= |input|\n  ensures index < |input| && IsWhitespace(input[index]) ==> SkipWhitespace(input, index) > index\n  decreases |input| - index\n{\n  if index == |input| || !IsWhitespace(input[index]) then index\n  else SkipWhitespace(input, index + 1)\n}\n\npredicate ValidStringInput(stdin_input: string)\n{\n  var tokens := TokenizeInput(stdin_input);\n  |tokens| == 1 && CanParseAsInt(tokens[0]) && ValidInput(ParseIntValue(tokens[0]))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  ensures result == \"Yes\\n\" || result == \"No\\n\" || result == \"\"\n  ensures ValidStringInput(stdin_input) ==> \n    (result == \"Yes\\n\" <==> IsPalindromic(ParseIntValue(TokenizeInput(stdin_input)[0])))\n  ensures !ValidStringInput(stdin_input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4353", "vc-description": "Given a string containing comma-separated words, replace all commas with spaces.\nThe input string has length 19 with format: 5 lowercase letters, comma, 7 lowercase letters, comma, 5 lowercase letters.", "vc-preamble": "predicate ValidInput(s: string)\n{\n  |s| == 19 && \n  |s| >= 2 && s[5] == ',' && s[13] == ',' &&\n  forall i :: 0 <= i < |s| ==> (s[i] == ',' || ('a' <= s[i] <= 'z'))\n}\n\nfunction CommasToSpaces(s: string): string\n  requires ValidInput(s)\n{\n  seq(|s|, i requires 0 <= i < |s| => if s[i] == ',' then ' ' else s[i])\n}\n\npredicate CorrectOutput(s: string, result: string)\n  requires ValidInput(s)\n{\n  |result| == |s| + 1 &&\n  result[|result| - 1] == '\\n' &&\n  forall i :: 0 <= i < |s| ==> \n    (s[i] == ',' ==> result[i] == ' ') &&\n    (s[i] != ',' ==> result[i] == s[i])\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n  requires ValidInput(s)\n  ensures CorrectOutput(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4362", "vc-description": "Given a single English letter (either uppercase A-Z or lowercase a-z), \noutput \"A\" if the input letter is uppercase, or \"a\" if the input letter is lowercase.", "vc-preamble": "predicate IsLowercaseLetter(c: char)\n{\n    'a' <= c <= 'z'\n}\n\npredicate AllLowercase(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> IsLowercaseLetter(s[i])\n}\n\npredicate ValidOutput(result: string)\n{\n    result == \"A\" || result == \"a\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    ensures ValidOutput(result)\n    ensures AllLowercase(input) ==> result == \"a\"\n    ensures (|input| == 0 || !AllLowercase(input)) ==> result == \"A\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4363", "vc-description": "Given two integers K and S, count the number of ordered triples (X, Y, Z) where\neach of X, Y, Z is an integer in the range [0, K] and X + Y + Z = S.", "vc-preamble": "predicate ValidInput(k: int, s: int) {\n    k >= 0 && s >= 0 && s <= 3 * k\n}\n\npredicate IsValidTriple(k: int, s: int, x: int, y: int, z: int) {\n    0 <= x <= k && 0 <= y <= k && 0 <= z <= k && x + y + z == s\n}\n\nfunction CountValidTriples(k: int, s: int): int\n    requires k >= 0\n{\n    CountValidTriplesHelper(k, s, 0)\n}\n\nfunction CountValidTriplesHelper(k: int, s: int, z: int): int\n    requires k >= 0\n    requires z >= 0\n    decreases if k >= z then k + 1 - z else 0\n{\n    if z > k then 0\n    else CountValidTriplesForZ(k, s, z) + CountValidTriplesHelper(k, s, z + 1)\n}\n\nfunction CountValidTriplesForZ(k: int, s: int, z: int): int\n    requires k >= 0\n    requires z >= 0\n{\n    CountValidTriplesForZHelper(k, s, z, 0)\n}\n\nfunction CountValidTriplesForZHelper(k: int, s: int, z: int, y: int): int\n    requires k >= 0\n    requires z >= 0\n    requires y >= 0\n    decreases if k >= y then k + 1 - y else 0\n{\n    if y > k then 0\n    else \n        var x := s - y - z;\n        var thisCount := if 0 <= x <= k then 1 else 0;\n        thisCount + CountValidTriplesForZHelper(k, s, z, y + 1)\n}", "vc-helpers": "", "vc-spec": "method CountTriples(k: int, s: int) returns (count: int)\n    requires ValidInput(k, s)\n    ensures count == CountValidTriples(k, s)\n    ensures count >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4364", "vc-description": "Given a 4-digit string, determine which date format(s) it represents:\nYYMM (year-month), MMYY (month-year), AMBIGUOUS (both valid), or NA (neither valid).\nValid months are 01-12, years can be any two digits 00-99.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 4 && forall i :: 0 <= i < 4 ==> '0' <= s[i] <= '9'\n}\n\nfunction charPairToInt(c1: char, c2: char): int\n    requires '0' <= c1 <= '9' && '0' <= c2 <= '9'\n    ensures 0 <= charPairToInt(c1, c2) <= 99\n{\n    (c1 as int - '0' as int) * 10 + (c2 as int - '0' as int)\n}\n\npredicate ValidMonth(n: int)\n{\n    1 <= n <= 12\n}\n\nfunction GetFirstPair(s: string): int\n    requires ValidInput(s)\n    ensures 0 <= GetFirstPair(s) <= 99\n{\n    charPairToInt(s[0], s[1])\n}\n\nfunction GetSecondPair(s: string): int\n    requires ValidInput(s)\n    ensures 0 <= GetSecondPair(s) <= 99\n{\n    charPairToInt(s[2], s[3])\n}\n\npredicate CorrectResult(s: string, result: string)\n    requires ValidInput(s)\n{\n    var s1 := GetFirstPair(s);\n    var s2 := GetSecondPair(s);\n    var s1_valid := ValidMonth(s1);\n    var s2_valid := ValidMonth(s2);\n    (s1_valid && s2_valid ==> result == \"AMBIGUOUS\\n\") &&\n    (s1_valid && !s2_valid ==> result == \"MMYY\\n\") &&\n    (!s1_valid && s2_valid ==> result == \"YYMM\\n\") &&\n    (!s1_valid && !s2_valid ==> result == \"NA\\n\")\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures result in [\"AMBIGUOUS\\n\", \"MMYY\\n\", \"YYMM\\n\", \"NA\\n\"]\n    ensures CorrectResult(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4365", "vc-description": "Given an integer K (2 \u2264 K \u2264 100), count the number of ways to choose one even number and one odd number from the integers 1 through K (inclusive). Order of selection does not matter.", "vc-preamble": "predicate ValidInput(K: int) {\n    2 <= K <= 100\n}\n\nfunction CountOddNumbers(K: int): int\n    requires K >= 1\n{\n    (K + 1) / 2\n}\n\nfunction CountEvenNumbers(K: int): int\n    requires K >= 1\n{\n    K / 2\n}\n\nfunction ExpectedResult(K: int): int\n    requires ValidInput(K)\n{\n    CountOddNumbers(K) * CountEvenNumbers(K)\n}\n\npredicate CorrectResult(K: int, result: int)\n    requires ValidInput(K)\n{\n    result == ExpectedResult(K)\n}", "vc-helpers": "", "vc-spec": "method CountEvenOddPairs(K: int) returns (result: int)\n    requires ValidInput(K)\n    ensures CorrectResult(K, result)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4366", "vc-description": "Given current time A (0-23) and hours B until contest begins (0-23), \ndetermine the contest start time in 24-hour format using modular arithmetic.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    exists A, B :: 0 <= A <= 23 && 0 <= B <= 23 && \n    (input == IntToString(A) + \" \" + IntToString(B) + \"\\n\" ||\n     input == IntToString(A) + \" \" + IntToString(B))\n}\n\nfunction ContestStartTime(A: int, B: int): int\n    requires 0 <= A <= 23 && 0 <= B <= 23\n    ensures 0 <= ContestStartTime(A, B) <= 23\n{\n    (A + B) % 24\n}\n\npredicate CorrectOutput(input: string, result: string)\n    requires ValidInput(input)\n{\n    exists A, B :: 0 <= A <= 23 && 0 <= B <= 23 && \n    (input == IntToString(A) + \" \" + IntToString(B) + \"\\n\" ||\n     input == IntToString(A) + \" \" + IntToString(B)) &&\n    result == IntToString(ContestStartTime(A, B)) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures CorrectOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4370", "vc-description": "Given a circular cake divided into 16 equal pieces, determine if two people can take A and B pieces \nrespectively such that neither person takes two adjacent pieces. The maximum number of non-adjacent \npieces any person can take from 16 pieces arranged in a circle is 8.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    1 <= a <= 16 && 1 <= b <= 16 && a + b <= 16\n}\n\npredicate CanTakeNonAdjacent(pieces: int, total: int)\n{\n    pieces <= total / 2\n}\n\npredicate BothCanTake(a: int, b: int)\n{\n    CanTakeNonAdjacent(a, 16) && CanTakeNonAdjacent(b, 16)\n}", "vc-helpers": "", "vc-spec": "method SolveCakeProblem(a: int, b: int) returns (result: string)\n    requires ValidInput(a, b)\n    ensures BothCanTake(a, b) <==> result == \"Yay!\"\n    ensures !BothCanTake(a, b) <==> result == \":(\"\n    ensures result == \"Yay!\" || result == \":(\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4371", "vc-description": "Given a string S of digits (1-9), find the minimum absolute difference between 753 and any 3-digit number formed by taking three consecutive digits from S.", "vc-preamble": "predicate ValidInput(S: string)\n{\n    |S| >= 3 && forall i :: 0 <= i < |S| ==> '1' <= S[i] <= '9'\n}\n\nfunction StringToInt(s: string): int\n    requires |s| == 3\n    requires forall i :: 0 <= i < |s| ==> '1' <= s[i] <= '9'\n    ensures StringToInt(s) >= 111\n    ensures StringToInt(s) <= 999\n{\n    100 * ((s[0] as int) - ('0' as int)) + \n    10 * ((s[1] as int) - ('0' as int)) + \n    ((s[2] as int) - ('0' as int))\n}\n\nfunction abs(x: int): int\n    ensures abs(x) >= 0\n    ensures abs(x) == x || abs(x) == -x\n{\n    if x >= 0 then x else -x\n}\n\npredicate IsMinimumDifference(S: string, result: int)\n    requires ValidInput(S)\n{\n    result >= 0 &&\n    (exists i :: 0 <= i <= |S| - 3 && result == abs(753 - StringToInt(S[i..i+3]))) &&\n    (forall i :: 0 <= i <= |S| - 3 ==> result <= abs(753 - StringToInt(S[i..i+3])))\n}", "vc-helpers": "", "vc-spec": "method solve(S: string) returns (result: int)\n    requires ValidInput(S)\n    ensures IsMinimumDifference(S, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4380", "vc-description": "Given two integers A and B (each between 1 and 3 inclusive), determine if there exists \nan integer C (also between 1 and 3 inclusive) such that the product A \u00d7 B \u00d7 C is odd.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    1 <= a <= 3 && 1 <= b <= 3\n}\n\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\n\npredicate ExistsOddProduct(a: int, b: int)\n  requires ValidInput(a, b)\n{\n    exists c :: 1 <= c <= 3 && IsOdd(a * b * c)\n}\n\nfunction ShouldAnswerYes(a: int, b: int): bool\n  requires ValidInput(a, b)\n{\n    a != 2 && b != 2\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: string)\n  requires ValidInput(a, b)\n  ensures result == (if ShouldAnswerYes(a, b) then \"Yes\" else \"No\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4381", "vc-description": "Calculate the total cost to travel from Station A to Station C using a special discount ticket.\nGiven train fare X yen (A to B) and bus fare Y yen (B to C), if you take the train first then the bus,\nthe bus fare becomes half price. Find the total cost A to C.", "vc-preamble": "predicate ValidInput(trainFare: int, busFare: int)\n{\n    1 <= trainFare <= 100 && 1 <= busFare <= 100 && busFare % 2 == 0\n}\n\nfunction TotalCost(trainFare: int, busFare: int): int\n    requires ValidInput(trainFare, busFare)\n{\n    trainFare + busFare / 2\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires exists i :: 0 <= i < |input| && input[i] == ' '\n    requires var parts := split(replace(input, \"\\n\", \"\"), ' '); \n             |parts| >= 2 && \n             isValidInteger(parts[0]) && \n             isValidInteger(parts[1])\n    requires var parts := split(replace(input, \"\\n\", \"\"), ' ');\n             var trainFare := stringToInt(parts[0]);\n             var busFare := stringToInt(parts[1]);\n             ValidInput(trainFare, busFare)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures var parts := split(replace(input, \"\\n\", \"\"), ' ');\n            var trainFare := stringToInt(parts[0]);\n            var busFare := stringToInt(parts[1]);\n            result == intToString(TotalCost(trainFare, busFare)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4383", "vc-description": "Determine if a child's age qualifies for Shichi-Go-San celebration.\nShichi-Go-San celebrates children who are exactly 3, 5, or 7 years old.\nInput is a string containing an integer X (1 \u2264 X \u2264 9).\nOutput \"YES\" if X is 3, 5, or 7, otherwise \"NO\".", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0 && exists i: int :: 0 <= i < |s| && '0' <= s[i] <= '9'\n}\n\npredicate IsCelebratedAge(age: int)\n{\n    age == 3 || age == 5 || age == 7\n}\n\nfunction ParseIntegerValue(s: string): int\n    requires |s| > 0\n    requires exists i: int :: 0 <= i < |s| && '0' <= s[i] <= '9'\n{\n    ParseIntegerHelper(s, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures var n := ParseIntegerValue(stdin_input); \n            IsCelebratedAge(n) ==> result == \"YES\\n\"\n    ensures var n := ParseIntegerValue(stdin_input);\n            !IsCelebratedAge(n) ==> result == \"NO\\n\"\n    ensures result == \"YES\\n\" || result == \"NO\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4384", "vc-description": "Given an integer N (1 \u2264 N \u2264 1998), determine the first three characters of the N-th AtCoder Beginner Contest label.\nContest labeling system: Rounds 1-999 use \"ABC\", rounds 1000-1998 use \"ABD\".", "vc-preamble": "predicate ValidInput(n: int) {\n    1 <= n <= 1998\n}\n\nfunction ExpectedResult(n: int): string\n    requires ValidInput(n)\n{\n    if n < 1000 then \"ABC\" else \"ABD\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n    requires ValidInput(n)\n    ensures result == ExpectedResult(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4385", "vc-description": "Given 5 antennas at coordinates a, b, c, d, e (where a < b < c < d < e) and a communication range k,\ndetermine if there exists any pair of antennas that cannot communicate directly. Two antennas can\ncommunicate if the distance between them is at most k. The distance between antennas at coordinates\np and q (where p < q) is q - p. Output \"Yay!\" if all pairs can communicate, \":(\" otherwise.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int, e: int, k: int) {\n    0 <= a <= 123 && 0 <= b <= 123 && 0 <= c <= 123 && \n    0 <= d <= 123 && 0 <= e <= 123 && 0 <= k <= 123 &&\n    a < b < c < d < e\n}\n\npredicate AllPairsCanCommunicate(a: int, b: int, c: int, d: int, e: int, k: int) {\n    (e - a) <= k\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int, e: int, k: int) returns (result: string)\n    requires ValidInput(a, b, c, d, e, k)\n    ensures result == \"Yay!\" <==> AllPairsCanCommunicate(a, b, c, d, e, k)\n    ensures result == \":(\" <==> !AllPairsCanCommunicate(a, b, c, d, e, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4386", "vc-description": "Given an integer a and a string s of lowercase English letters, \noutput s if a >= 3200, otherwise output \"red\".", "vc-preamble": "predicate ValidInput(input: string)\n{\n  |input| > 0 &&\n  (exists i :: 0 < i < |input| && input[i] == '\\n') &&\n  (forall i :: 0 <= i < |input| ==> input[i] == '\\n' || ('0' <= input[i] <= '9') || ('a' <= input[i] <= 'z')) &&\n  (exists i :: 0 < i < |input| && input[i] == '\\n' && (forall j :: 0 <= j < i ==> '0' <= input[j] <= '9'))\n}\n\npredicate ValidParsedInput(a: int, s: string)\n{\n  2800 <= a < 5000 &&\n  1 <= |s| <= 10 &&\n  (forall j :: 0 <= j < |s| ==> 'a' <= s[j] <= 'z')\n}\n\npredicate CorrectOutput(a: int, s: string, result: string)\n{\n  (a >= 3200 ==> result == s + \"\\n\") &&\n  (a < 3200 ==> result == \"red\\n\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n  requires ValidInput(input)\n  requires exists a: int, s: string :: \n    parseInput(input) == (a, s) && ValidParsedInput(a, s)\n  ensures exists a: int, s: string :: \n    parseInput(input) == (a, s) && \n    ValidParsedInput(a, s) &&\n    CorrectOutput(a, s, result)\n  ensures |result| > 0\n  ensures result[|result|-1] == '\\n'\n  ensures (exists a: int, s: string :: \n    parseInput(input) == (a, s) && a >= 3200) ==> \n    (exists s: string :: result == s + \"\\n\" && 1 <= |s| <= 10 && (forall j :: 0 <= j < |s| ==> 'a' <= s[j] <= 'z'))\n  ensures (exists a: int, s: string :: \n    parseInput(input) == (a, s) && a < 3200) ==> result == \"red\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4387", "vc-description": "Given a contestant's rating R, determine which contest they are eligible for:\nABC for ratings less than 1200, ARC for ratings from 1200 to less than 2800,\nand AGC for ratings 2800 and above.", "vc-preamble": "predicate ValidRating(R: int) {\n    0 <= R <= 4208\n}\n\nfunction ContestForRating(R: int): string {\n    if R < 1200 then \"ABC\\n\"\n    else if R < 2800 then \"ARC\\n\" \n    else \"AGC\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(R: int) returns (result: string)\n    requires ValidRating(R)\n    ensures result == ContestForRating(R)\n    ensures R < 1200 ==> result == \"ABC\\n\"\n    ensures 1200 <= R < 2800 ==> result == \"ARC\\n\"\n    ensures R >= 2800 ==> result == \"AGC\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4388", "vc-description": "Given a three-digit string containing only digits '1' and '9', swap each '1' with '9' \nand each '9' with '1', then return the transformed string with a newline appended.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 3 &&\n    forall i :: 0 <= i < 3 ==> (input[i] == '1' || input[i] == '9')\n}\n\nfunction SwapDigit(c: char): char\n    requires c == '1' || c == '9'\n{\n    if c == '1' then '9' else '1'\n}\n\nfunction TransformString(s: string): string\n    requires |s| >= 3\n    requires forall i :: 0 <= i < 3 ==> (s[i] == '1' || s[i] == '9')\n{\n    [SwapDigit(s[0]), SwapDigit(s[1]), SwapDigit(s[2])]\n}\n\npredicate ValidOutput(input: string, result: string)\n    requires ValidInput(input)\n{\n    |result| == 4 &&\n    result[3] == '\\n' &&\n    forall i :: 0 <= i < 3 ==> \n        (input[i] == '1' ==> result[i] == '9') && \n        (input[i] == '9' ==> result[i] == '1')\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4390", "vc-description": "Given two positive integers a and b, find the minimum number of increments needed \nto make a divisible by b. In each move, you can increase a by 1.", "vc-preamble": "predicate ValidInput(test_cases: seq<(int, int)>)\n{\n    forall i :: 0 <= i < |test_cases| ==> \n        test_cases[i].0 > 0 && test_cases[i].1 > 0\n}\n\nfunction MinMovesToDivisible(a: int, b: int): int\n    requires a > 0 && b > 0\n{\n    (b - a % b) % b\n}\n\npredicate ValidOutput(test_cases: seq<(int, int)>, results: seq<int>)\n    requires ValidInput(test_cases)\n{\n    |results| == |test_cases| &&\n    forall i :: 0 <= i < |results| ==> \n        results[i] == MinMovesToDivisible(test_cases[i].0, test_cases[i].1) &&\n        results[i] >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(test_cases: seq<(int, int)>) returns (results: seq<int>)\n    requires ValidInput(test_cases)\n    ensures ValidOutput(test_cases, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4392", "vc-description": "Given an array and a set of allowed swap positions, determine if the array can be sorted \nin non-decreasing order using only adjacent swaps at the allowed positions. An allowed swap\nexchanges elements at positions i and i+1 if position i is in the allowed set.", "vc-preamble": "predicate ValidInput(a: array<int>, allowedPos: array<bool>)\n    reads a, allowedPos\n{\n    a.Length > 1 && allowedPos.Length == a.Length\n}\n\npredicate IsSorted(a: array<int>)\n    reads a\n{\n    forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n}\n\npredicate CanReachConfiguration(original: seq<int>, target: seq<int>, allowed: seq<bool>)\n{\n    |original| == |target| == |allowed| &&\n    multiset(original) == multiset(target)\n}\n\nfunction SortSequence(s: seq<int>): seq<int>\n{\n    if |s| <= 1 then s\n    else\n        var sorted := BubbleSortSeq(s);\n        sorted\n}\n\nfunction BubbleSortSeq(s: seq<int>): seq<int>\n{\n    if |s| <= 1 then s\n    else BubbleSortHelper(s, |s|)\n}\n\nfunction BubbleSortHelper(s: seq<int>, passes: nat): seq<int>\n    decreases passes\n{\n    if passes == 0 then s\n    else \n        var afterPass := BubblePass(s);\n        BubbleSortHelper(afterPass, passes - 1)\n}\n\nfunction BubblePass(s: seq<int>): seq<int>\n{\n    if |s| <= 1 then s\n    else BubblePassHelper(s, 0)\n}\n\nfunction BubblePassHelper(s: seq<int>, pos: nat): seq<int>\n    requires pos <= |s|\n    decreases |s| - pos\n{\n    if pos >= |s| - 1 then s\n    else if s[pos] > s[pos + 1] then\n        var swapped := s[pos := s[pos + 1]][pos + 1 := s[pos]];\n        BubblePassHelper(swapped, pos + 1)\n    else\n        BubblePassHelper(s, pos + 1)\n}", "vc-helpers": "", "vc-spec": "method CanSort(a: array<int>, allowedPos: array<bool>) returns (result: bool)\n    requires ValidInput(a, allowedPos)\n    modifies a\n    ensures multiset(a[..]) == multiset(old(a[..]))\n    ensures result == IsSorted(a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4398", "vc-description": "Given two strings S and T of equal length N, create a new string by alternating characters \nfrom S and T in the order: S[0], T[0], S[1], T[1], ..., S[N-1], T[N-1].", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 2 &&\n    (var n := StringToInt(lines[0]);\n     var parts := SplitBySpace(lines[1]);\n     |parts| >= 2 &&\n     n >= 0 &&\n     n <= |parts[0]| && n <= |parts[1]|)\n}\n\nfunction GetN(input: string): int\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    StringToInt(lines[0])\n}\n\nfunction GetS(input: string): string\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var parts := SplitBySpace(lines[1]);\n    parts[0]\n}\n\nfunction GetT(input: string): string\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var parts := SplitBySpace(lines[1]);\n    parts[1]\n}\n\nfunction AlternateChars(s: string, t: string, n: int): string\n    requires n >= 0\n    requires n <= |s| && n <= |t|\n    ensures |AlternateChars(s, t, n)| == 2 * n\n    ensures forall i :: 0 <= i < n ==> \n        i * 2 < |AlternateChars(s, t, n)| && \n        i * 2 + 1 < |AlternateChars(s, t, n)| &&\n        AlternateChars(s, t, n)[i * 2] == s[i] && \n        AlternateChars(s, t, n)[i * 2 + 1] == t[i]\n{\n    if n == 0 then \"\"\n    else [s[0]] + [t[0]] + AlternateChars(s[1..], t[1..], n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures ValidInput(input) ==> \n        (var n := GetN(input);\n         var s := GetS(input);\n         var t := GetT(input);\n         |result| == 2 * n + 1 &&\n         result[|result| - 1] == '\\n' &&\n         result[0..|result|-1] == AlternateChars(s, t, n))\n    ensures !ValidInput(input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4399", "vc-description": "Given a string of length 3 representing railway companies ('A' or 'B') operating 3 stations,\ndetermine if any bus service will exist. Bus services connect stations operated by different companies.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| == 3 && forall i :: 0 <= i < |input| ==> input[i] == 'A' || input[i] == 'B'\n}\n\npredicate BusServiceExists(input: string)\n    requires ValidInput(input)\n{\n    input[0] != input[1] || input[1] != input[2]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == \"Yes\" <==> BusServiceExists(input)\n    ensures result == \"Yes\" || result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_440", "vc-description": "Given a string of lowercase Latin letters, repeatedly remove consecutive vowels \nby deleting the second vowel in each consecutive pair until no consecutive vowels remain.\nVowels are defined as: a, e, i, o, u, y. Process the string from left to right.", "vc-preamble": "predicate IsVowel(c: char)\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'\n}\n\npredicate NoConsecutiveVowels(s: seq<char>)\n{\n    forall i :: 0 <= i < |s| - 1 ==> !(IsVowel(s[i]) && IsVowel(s[i+1]))\n}\n\npredicate ValidOutput(input: seq<char>, output: seq<char>)\n{\n    |output| <= |input| &&\n    NoConsecutiveVowels(output) &&\n    (|input| > 0 ==> |output| > 0) &&\n    (|input| > 0 ==> output[0] == input[0])\n}", "vc-helpers": "", "vc-spec": "method solve(s: seq<char>) returns (result: seq<char>)\n    ensures ValidOutput(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4400", "vc-description": "Given a string S of length 3 representing weather records for 3 consecutive days\n(where 'S' means sunny and 'R' means rainy), find the maximum number of consecutive rainy days.", "vc-preamble": "predicate ValidInput(s: string) {\n    |s| == 3 && forall i :: 0 <= i < |s| ==> s[i] == 'S' || s[i] == 'R'\n}\n\nfunction MaxConsecutiveRainyDays(s: string): int\n    requires ValidInput(s)\n{\n    if s == \"RRR\" then 3\n    else if s[0..2] == \"RR\" || s[1..3] == \"RR\" then 2\n    else if 'R' in s then 1\n    else 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: int)\n    requires ValidInput(input)\n    ensures result == MaxConsecutiveRainyDays(input)\n    ensures 0 <= result <= 3", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4403", "vc-description": "Given a string of exactly 4 characters containing only '+' and '-',\ncalculate the sum where each '+' contributes +1 and each '-' contributes -1.", "vc-preamble": "predicate ValidInput(s: string) {\n    |s| == 4 && forall i :: 0 <= i < |s| ==> s[i] == '+' || s[i] == '-'\n}\n\nfunction CountChar(s: string, c: char): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == c then 1 else 0) + CountChar(s[1..], c)\n}\n\nfunction CalculateSum(s: string): int\n    requires ValidInput(s)\n{\n    CountChar(s, '+') - CountChar(s, '-')\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result == CalculateSum(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4404", "vc-description": "Given a string representing a valid date in 2019 in format yyyy/mm/dd,\ndetermine if the date is on or before April 30, 2019.\nReturn \"Heisei\" if on or before April 30, 2019, otherwise return \"TBD\".", "vc-preamble": "predicate IsValidDateString(s: string, y: int, m: int, d: int)\n{\n    |s| >= 10 && \n    s[4] == '/' && s[7] == '/' &&\n    StringToInt(s[0..4]) == y &&\n    StringToInt(s[5..7]) == m &&\n    StringToInt(s[8..10]) == d\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then CharToDigit(s[0])\n    else if |s| == 2 then CharToDigit(s[0]) * 10 + CharToDigit(s[1])\n    else if |s| == 4 then CharToDigit(s[0]) * 1000 + CharToDigit(s[1]) * 100 + CharToDigit(s[2]) * 10 + CharToDigit(s[3])\n    else 0\n}\n\nfunction CharToDigit(c: char): int\n{\n    if '0' <= c <= '9' then (c as int) - ('0' as int) else 0\n}\n\npredicate ValidInput(s: string)\n{\n    exists y, m, d :: IsValidDateString(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31\n}\n\npredicate CorrectOutput(s: string, result: string)\n{\n    exists y, m, d :: IsValidDateString(s, y, m, d) && y == 2019 && 1 <= m <= 12 && 1 <= d <= 31 && \n    ((m < 4 || (m == 4 && d <= 30)) ==> result == \"Heisei\") && \n    ((m > 4 || (m == 4 && d > 30)) ==> result == \"TBD\")\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\nrequires |stdin_input| > 0\nrequires ValidInput(stdin_input)\nensures CorrectOutput(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4413", "vc-description": "Given n students with distinct programming skills, divide them into the minimum number of teams \nsuch that no two students with skills differing by exactly 1 are on the same team.", "vc-preamble": "predicate ValidInput(skills: seq<int>)\n{\n    |skills| >= 0\n}\n\npredicate HasAdjacentSkills(skills: seq<int>)\n{\n    exists i, j :: 0 <= i < j < |skills| && (skills[i] - skills[j] == 1 || skills[j] - skills[i] == 1)\n}", "vc-helpers": "", "vc-spec": "method solve(skills: seq<int>) returns (teams: int)\n    requires ValidInput(skills)\n    ensures teams == 1 || teams == 2\n    ensures teams == 2 <==> HasAdjacentSkills(skills)\n    ensures teams == 1 <==> !HasAdjacentSkills(skills)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4418", "vc-description": "Given an array of n integers where each element is one of {4, 8, 15, 16, 23, 42}, \nfind the minimum number of elements to remove to make the array \"good\".\nA \"good\" array must have length divisible by 6 and can be split into complete \nsubsequences of exactly \"4, 8, 15, 16, 23, 42\" (in that order).", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 0 && |a| == n && forall i :: 0 <= i < |a| ==> a[i] in {4, 8, 15, 16, 23, 42}\n}\n\nfunction number_of_complete_subsequences(n: int, a: seq<int>): int\n  requires ValidInput(n, a)\n  ensures 0 <= number_of_complete_subsequences(n, a) <= n\n{\n    var k := [4, 8, 15, 16, 23, 42];\n    var s := [n, 0, 0, 0, 0, 0, 0];\n    var final_s := process_array(s, a, k, 0);\n    final_s[6]\n}\n\nfunction process_array(s: seq<int>, a: seq<int>, k: seq<int>, index: int): seq<int>\n  requires |s| == 7 && |k| == 6\n  requires 0 <= index <= |a|\n  requires forall i :: 0 <= i < |a| ==> a[i] in {4, 8, 15, 16, 23, 42}\n  requires k == [4, 8, 15, 16, 23, 42]\n  requires forall i :: 0 <= i < 7 ==> s[i] >= 0\n  ensures |process_array(s, a, k, index)| == 7\n  ensures forall i :: 0 <= i < 7 ==> process_array(s, a, k, index)[i] >= 0\n  ensures s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] == process_array(s, a, k, index)[0] + process_array(s, a, k, index)[1] + process_array(s, a, k, index)[2] + process_array(s, a, k, index)[3] + process_array(s, a, k, index)[4] + process_array(s, a, k, index)[5] + process_array(s, a, k, index)[6]\n  ensures process_array(s, a, k, index)[6] <= s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6]\n  ensures index < |a| ==> process_array(s, a, k, index) == process_array(update_state(s, a[index], k), a, k, index + 1)\n  decreases |a| - index\n{\n    if index == |a| then s\n    else\n        var ai := a[index];\n        var new_s := update_state(s, ai, k);\n        process_array(new_s, a, k, index + 1)\n}\n\nfunction update_state(s: seq<int>, ai: int, k: seq<int>): seq<int>\n  requires |s| == 7 && |k| == 6\n  requires ai in {4, 8, 15, 16, 23, 42}\n  requires k == [4, 8, 15, 16, 23, 42]\n  requires forall i :: 0 <= i < 7 ==> s[i] >= 0\n  ensures |update_state(s, ai, k)| == 7\n  ensures forall i :: 0 <= i < 7 ==> update_state(s, ai, k)[i] >= 0\n  ensures s[0] + s[1] + s[2] + s[3] + s[4] + s[5] + s[6] == update_state(s, ai, k)[0] + update_state(s, ai, k)[1] + update_state(s, ai, k)[2] + update_state(s, ai, k)[3] + update_state(s, ai, k)[4] + update_state(s, ai, k)[5] + update_state(s, ai, k)[6]\n{\n    if ai == k[5] && s[5] > 0 then s[6 := s[6] + 1][5 := s[5] - 1]\n    else if ai == k[4] && s[4] > 0 then s[5 := s[5] + 1][4 := s[4] - 1]\n    else if ai == k[3] && s[3] > 0 then s[4 := s[4] + 1][3 := s[3] - 1]\n    else if ai == k[2] && s[2] > 0 then s[3 := s[3] + 1][2 := s[2] - 1]\n    else if ai == k[1] && s[1] > 0 then s[2 := s[2] + 1][1 := s[1] - 1]\n    else if ai == k[0] && s[0] > 0 then s[1 := s[1] + 1][0 := s[0] - 1]\n    else s\n}\n\nfunction number_of_complete_subsequences_partial(n: int, a: seq<int>, k: seq<int>, index: int): int\n  requires ValidInput(n, a)\n  requires |k| == 6\n  requires k == [4, 8, 15, 16, 23, 42]\n  requires 0 <= index <= |a|\n  ensures 0 <= number_of_complete_subsequences_partial(n, a, k, index) <= n\n{\n    var s := [n, 0, 0, 0, 0, 0, 0];\n    var partial_a := if index == 0 then [] else a[0..index];\n    var final_s := process_array(s, partial_a, k, 0);\n    final_s[6]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n  requires ValidInput(n, a)\n  ensures 0 <= result <= n\n  ensures result == n - 6 * (number_of_complete_subsequences(n, a))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_442", "vc-description": "Given a hash function H(x,y) = x\u00b2 + 2xy + x + 1 where x and y are positive integers,\ndetermine if there exists a pair of positive integers (x,y) such that H(x,y) = r \nfor a given positive integer r. If such a pair exists, return the pair (x,y) with \nthe smallest possible value of x. If no such pair exists, return empty sequence.", "vc-preamble": "function H(x: int, y: int): int\n{\n    x * x + 2 * x * y + x + 1\n}\n\npredicate ValidInput(r: int)\n{\n    r > 0\n}\n\npredicate ValidSolution(result: seq<int>, r: int)\n{\n    if |result| == 0 then\n        true\n    else\n        |result| == 2 && result[0] > 0 && result[1] > 0 && H(result[0], result[1]) == r\n}\n\npredicate HasSolution(r: int)\n{\n    r > 4 && r % 2 == 1\n}", "vc-helpers": "", "vc-spec": "method solve(r: int) returns (result: seq<int>)\n    requires ValidInput(r)\n    ensures ValidSolution(result, r)\n    ensures |result| == 0 || |result| == 2\n    ensures |result| == 2 ==> result[0] > 0 && result[1] > 0\n    ensures |result| == 2 ==> H(result[0], result[1]) == r\n    ensures r <= 4 ==> |result| == 0\n    ensures r > 4 && r % 2 == 0 ==> |result| == 0\n    ensures r > 4 && r % 2 == 1 ==> |result| == 2 && result[0] == 1 && result[1] == (r - 3) / 2", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4426", "vc-description": "Given a day of the week as a string, determine how many days until the next Sunday.\nInput is one of \"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", or \"SAT\".\nOutput is the number of days until the next Sunday (1-7, where 7 means next Sunday is in a week).", "vc-preamble": "predicate ValidDay(day: string) {\n    day in [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"]\n}\n\nfunction DaysUntilSunday(day: string): int\n    requires ValidDay(day)\n{\n    match day\n    case \"SUN\" => 7\n    case \"MON\" => 6  \n    case \"TUE\" => 5\n    case \"WED\" => 4\n    case \"THU\" => 3\n    case \"FRI\" => 2\n    case \"SAT\" => 1\n}", "vc-helpers": "", "vc-spec": "method DaysToNextSunday(day: string) returns (result: int)\n    requires ValidDay(day)\n    ensures result >= 1 && result <= 7\n    ensures result == DaysUntilSunday(day)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4427", "vc-description": "Given a recurrence relation x_{i+1} = r \u00d7 x_i - D starting from year 2000, \ncalculate the values for years 2001 through 2010.\nInput: Three integers r, D, x_2000 where 2 \u2264 r \u2264 5, 1 \u2264 D \u2264 100, D < x_2000 \u2264 200\nOutput: 10 lines containing x_{2001}, x_{2002}, ..., x_{2010} respectively", "vc-preamble": "predicate ValidInput(input: string)\n    requires |input| > 0\n{\n    var tokens := parseInputPure(input);\n    |tokens| == 3 && \n    2 <= tokens[0] <= 5 &&\n    1 <= tokens[1] <= 100 &&\n    tokens[1] < tokens[2] <= 200\n}\n\nfunction calculateRecurrence(r: int, D: int, x0: int, n: int): int\n    requires n >= 1\n    decreases n\n{\n    if n == 1 then r * x0 - D\n    else r * calculateRecurrence(r, D, x0, n - 1) - D\n}\n\nfunction generateExpectedOutput(r: int, D: int, x0: int): string\n{\n    generateOutputUpToIteration(r, D, x0, 10)\n}\n\nfunction generateOutputUpToIteration(r: int, D: int, x0: int, iterations: int): string\n    requires iterations >= 0\n{\n    if iterations == 0 then \"\"\n    else \n        var currentValue := calculateRecurrence(r, D, x0, iterations);\n        var previousOutput := generateOutputUpToIteration(r, D, x0, iterations - 1);\n        previousOutput + intToString(currentValue) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures var tokens := parseInputPure(input);\n            result == generateExpectedOutput(tokens[0], tokens[1], tokens[2])", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_443", "vc-description": "Given n packets of balloons, divide all packets between two people such that:\n1. Each person gets at least one packet\n2. All packets are distributed \n3. The total number of balloons each person receives is different\nFind any valid distribution or return empty sequence if impossible.", "vc-preamble": "predicate ValidInput(n: int, packets: seq<int>)\n{\n    n >= 1 && |packets| == n && forall i :: 0 <= i < |packets| ==> packets[i] >= 1\n}\n\npredicate IsPossible(n: int, packets: seq<int>)\n    requires ValidInput(n, packets)\n{\n    n >= 2 && (n > 2 || packets[0] != packets[1])\n}\n\nfunction SumPackets(packets: seq<int>): int\n{\n    if |packets| == 0 then 0 else packets[0] + SumPackets(packets[1..])\n}\n\npredicate ValidSolution(n: int, packets: seq<int>, result: seq<int>)\n    requires ValidInput(n, packets)\n{\n    if !IsPossible(n, packets) then\n        |result| == 0\n    else\n        |result| == 2 && result[0] == 1 && 1 <= result[1] <= n &&\n        exists minIndex :: 0 <= minIndex < |packets| && \n        result[1] == minIndex + 1 &&\n        (forall j :: 0 <= j < |packets| ==> packets[minIndex] <= packets[j]) &&\n        (forall k :: 0 <= k < minIndex ==> packets[k] > packets[minIndex])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, packets: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, packets)\n    ensures ValidSolution(n, packets, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4430", "vc-description": "Given n objects with sizes and m boxes of capacity k, find the maximum number of objects\nthat can be packed using a greedy algorithm by potentially removing leftmost objects.\nThe greedy algorithm processes objects from left to right, placing each object in the\ncurrent box if it fits, otherwise using a new empty box.", "vc-preamble": "function GreedyPackFromEnd(a: seq<int>, boxes: int, capacity: int): int\n    requires boxes >= 1\n    requires capacity >= 1\n    requires forall i :: 0 <= i < |a| ==> 1 <= a[i] <= capacity\n{\n    GreedyPackFromEndHelper(a, |a| - 1, boxes, capacity, capacity)\n}\n\nfunction GreedyPackFromEndHelper(a: seq<int>, pos: int, boxes_left: int, capacity: int, current_box_space: int): int\n    requires capacity >= 1\n    requires forall i :: 0 <= i < |a| ==> 1 <= a[i] <= capacity\n    requires boxes_left >= 1\n    requires 0 <= current_box_space <= capacity\n    decreases pos + 1\n{\n    if pos < 0 then 0\n    else if pos >= |a| then 0\n    else if a[pos] > capacity then 0\n    else if a[pos] <= current_box_space then\n        1 + GreedyPackFromEndHelper(a, pos - 1, boxes_left, capacity, current_box_space - a[pos])\n    else if boxes_left > 1 then\n        1 + GreedyPackFromEndHelper(a, pos - 1, boxes_left - 1, capacity, capacity - a[pos])\n    else\n        0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int, a: seq<int>) returns (result: int)\n    requires n >= 0\n    requires m >= 1\n    requires k >= 1\n    requires |a| == n\n    requires forall i :: 0 <= i < |a| ==> 1 <= a[i] <= k\n    ensures 0 <= result <= n\n    ensures result == GreedyPackFromEnd(a, m, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4431", "vc-description": "Given a string of n lowercase Latin letters and k available letters on a broken keyboard,\ncount how many substrings of the string can be typed using only the available letters.", "vc-preamble": "predicate ValidInput(n: nat, k: nat, s: string, available: seq<char>)\n{\n    n == |s| &&\n    k == |available| &&\n    forall i, j :: 0 <= i < j < |available| ==> available[i] != available[j]\n}\n\nfunction CountValidSubstrings(s: string, availableSet: set<char>): nat\n{\n    if |s| == 0 then 0\n    else\n        var segments := GetMaximalValidSegments(s, availableSet, 0);\n        SumSegmentCounts(segments)\n}\n\nfunction GetMaximalValidSegments(s: string, availableSet: set<char>, startIdx: nat): seq<nat>\n    requires startIdx <= |s|\n    decreases |s| - startIdx\n{\n    if startIdx >= |s| then []\n    else\n        var segmentLength := GetNextSegmentLength(s, availableSet, startIdx);\n        if segmentLength == 0 then\n            GetMaximalValidSegments(s, availableSet, startIdx + 1)\n        else\n            var skipLength := SkipInvalidChars(s, availableSet, startIdx + segmentLength);\n            var nextIdx := startIdx + segmentLength + skipLength;\n            if nextIdx <= |s| then\n                [segmentLength] + GetMaximalValidSegments(s, availableSet, nextIdx)\n            else\n                [segmentLength]\n}\n\nfunction GetNextSegmentLength(s: string, availableSet: set<char>, startIdx: nat): nat\n    requires startIdx <= |s|\n    ensures GetNextSegmentLength(s, availableSet, startIdx) <= |s| - startIdx\n    decreases |s| - startIdx\n{\n    if startIdx >= |s| || s[startIdx] !in availableSet then 0\n    else 1 + GetNextSegmentLength(s, availableSet, startIdx + 1)\n}\n\nfunction SkipInvalidChars(s: string, availableSet: set<char>, startIdx: nat): nat\n    requires startIdx <= |s|\n    ensures SkipInvalidChars(s, availableSet, startIdx) <= |s| - startIdx\n    decreases |s| - startIdx\n{\n    if startIdx >= |s| || s[startIdx] in availableSet then 0\n    else 1 + SkipInvalidChars(s, availableSet, startIdx + 1)\n}\n\nfunction SumSegmentCounts(segments: seq<nat>): nat\n{\n    if |segments| == 0 then 0\n    else segments[0] * (segments[0] + 1) / 2 + SumSegmentCounts(segments[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, k: nat, s: string, available: seq<char>) returns (result: nat)\n    requires ValidInput(n, k, s, available)\n    ensures result <= n * (n + 1) / 2\n    ensures result == CountValidSubstrings(s, set c | c in available)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4441", "vc-description": "Read an integer N from input. If N=1, print \"Hello World\". If N=2, read two additional integers A and B, then print their sum.\nConstraints: N is 1 or 2, A and B are integers between 1 and 9 (inclusive).", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0\n}\n\nfunction ExpectedOutput(stdin_input: string): string\n{\n    var lines := SplitLinesFunc(stdin_input);\n    if |lines| >= 1 then\n        var n := StringToInt(lines[0]);\n        if n == 1 then \"Hello World\\n\"\n        else if n != 1 && |lines| >= 3 then\n            var a := StringToInt(lines[1]);\n            var b := StringToInt(lines[2]);\n            IntToString(a + b) + \"\\n\"\n        else \"\"\n    else \"\"\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n{\n    SplitLinesFuncHelper(s, 0, \"\", [])\n}\n\nfunction SplitLinesFuncHelper(s: string, i: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if current == \"\" then acc else acc + [current]\n    else if s[i] == '\\n' then\n        SplitLinesFuncHelper(s, i + 1, \"\", acc + [current])\n    else\n        SplitLinesFuncHelper(s, i + 1, current + [s[i]], acc)\n}\n\nfunction StringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if s[0] == '-' then -StringToIntHelper(s[1..])\n    else StringToIntHelper(s)\n}\n\nfunction StringToIntHelper(s: string): int\n{\n    if |s| == 0 then 0\n    else StringToIntHelper(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [(n % 10 + '0' as int) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures result == ExpectedOutput(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4443", "vc-description": "Given a lowercase English letter (not 'z'), output the next letter in alphabetical order.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && 'a' <= input[0] <= 'y'\n}\n\nfunction NextChar(c: char): char\n    requires 'a' <= c <= 'y'\n{\n    (c as int + 1) as char\n}\n\npredicate ValidOutput(input: string, output: string)\n    requires ValidInput(input)\n{\n    |output| == 2 &&\n    output[0] == NextChar(input[0]) &&\n    output[1] == '\\n' &&\n    'b' <= output[0] <= 'z'\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4444", "vc-description": "Given two strings S and T as space-separated input, concatenate T and S (in that order) and output the result.\nInput format: \"S T\" where S and T contain only lowercase English letters.\nOutput format: \"TS\\n\" (T concatenated with S followed by newline).", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 2 &&\n    (exists i :: 0 < i < |input| && input[i] == ' ') &&\n    (forall i :: 0 <= i < |input| ==> (input[i] == ' ' || input[i] == '\\n' || ('a' <= input[i] <= 'z'))) &&\n    (exists i :: 0 < i < |input| && input[i] == ' ' && \n     (forall j :: 0 <= j < i ==> input[j] != ' ' && input[j] != '\\n') &&\n     (forall j :: i+1 <= j < |input| ==> input[j] != ' ' && input[j] != '\\n'))\n}\n\npredicate ValidOutput(output: string)\n{\n    |output| > 0 &&\n    output[|output|-1] == '\\n' &&\n    (forall i :: 0 <= i < |output|-1 ==> ('a' <= output[i] <= 'z'))\n}\n\nfunction ExtractStrings(input: string): (string, string)\n    requires ValidInput(input)\n{\n    var spacePos :| 0 < spacePos < |input| && input[spacePos] == ' ' &&\n                   (forall j :: 0 <= j < spacePos ==> input[j] != ' ') &&\n                   (forall j :: spacePos+1 <= j < |input| ==> input[j] != ' ' && input[j] != '\\n');\n    var s := input[..spacePos];\n    var t := if input[|input|-1] == '\\n' then input[spacePos+1..|input|-1] else input[spacePos+1..];\n    (s, t)\n}\n\npredicate CorrectConcatenation(input: string, output: string)\n    requires ValidInput(input)\n{\n    var (s, t) := ExtractStrings(input);\n    output == t + s + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures ValidOutput(output)\n    ensures CorrectConcatenation(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4446", "vc-description": "Given n monsters with health points, player and opponent take turns attacking until each monster dies.\nPlayer attacks first with damage a, opponent with damage b. Player gets 1 point for killing a monster.\nPlayer can skip opponent's turn at most k times total. Find maximum points achievable.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, k: int, H: seq<int>)\n{\n    n > 0 && a > 0 && b > 0 && k >= 0 && |H| == n && \n    forall i :: 0 <= i < |H| ==> H[i] > 0\n}\n\nfunction ProcessHealthValues(H: seq<int>, a: int, b: int): seq<int>\n    requires a > 0 && b > 0\n    requires forall i :: 0 <= i < |H| ==> H[i] > 0\n    ensures |ProcessHealthValues(H, a, b)| == |H|\n    ensures forall i :: 0 <= i < |H| ==> \n        var h_mod := H[i] % (a + b);\n        ProcessHealthValues(H, a, b)[i] == (if h_mod == 0 then a + b else h_mod)\n    ensures forall i :: 0 <= i < |ProcessHealthValues(H, a, b)| ==> \n        1 <= ProcessHealthValues(H, a, b)[i] <= a + b\n{\n    if |H| == 0 then []\n    else \n        var h_mod := H[0] % (a + b);\n        var h_final := if h_mod == 0 then a + b else h_mod;\n        [h_final] + ProcessHealthValues(H[1..], a, b)\n}\n\nfunction CountKillableMonsters(sorted_health: seq<int>, a: int, k: int): int\n    requires a > 0 && k >= 0\n    requires forall i, j :: 0 <= i < j < |sorted_health| ==> sorted_health[i] <= sorted_health[j]\n    requires forall i :: 0 <= i < |sorted_health| ==> sorted_health[i] > 0\n    ensures 0 <= CountKillableMonsters(sorted_health, a, k) <= |sorted_health|\n{\n    CountKillableHelper(sorted_health, a, k, 0, 0)\n}\n\nfunction CountKillableHelper(sorted_health: seq<int>, a: int, remaining_k: int, index: int, acc: int): int\n    requires a > 0 && remaining_k >= 0 && 0 <= index <= |sorted_health| && acc >= 0\n    requires forall i, j :: 0 <= i < j < |sorted_health| ==> sorted_health[i] <= sorted_health[j]\n    requires forall i :: 0 <= i < |sorted_health| ==> sorted_health[i] > 0\n    ensures CountKillableHelper(sorted_health, a, remaining_k, index, acc) >= acc\n    ensures CountKillableHelper(sorted_health, a, remaining_k, index, acc) <= acc + (|sorted_health| - index)\n    decreases |sorted_health| - index\n{\n    if index >= |sorted_health| then acc\n    else\n        var x := sorted_health[index];\n        if x <= a then\n            CountKillableHelper(sorted_health, a, remaining_k, index + 1, acc + 1)\n        else\n            var needed_skips := (x + a - 1) / a - 1;\n            if remaining_k >= needed_skips then\n                CountKillableHelper(sorted_health, a, remaining_k - needed_skips, index + 1, acc + 1)\n            else\n                CountKillableHelper(sorted_health, a, remaining_k, index + 1, acc)\n}", "vc-helpers": "", "vc-spec": "method SolveCore(n: int, a: int, b: int, k: int, H: seq<int>) returns (result: int)\n    requires ValidInput(n, a, b, k, H)\n    ensures 0 <= result <= n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4460", "vc-description": "Given five integers representing the values of variables x\u2081, x\u2082, x\u2083, x\u2084, x\u2085, find which variable has the value 0.\nInitially, each variable x\u1d62 had value i, but exactly one variable was changed to 0.\nInput: Five space-separated integers. Output: The index i (1-indexed) of the variable x\u1d62 that has value 0.", "vc-preamble": "predicate validInput(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> s[i] == ' ' || s[i] == '\\n' || ('0' <= s[i] <= '9') || s[i] == '-')\n}\n\npredicate validNumber(s: string)\n{\n    |s| == 0 || (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9' || (i == 0 && s[i] == '-'))\n}\n\nfunction countZeros(numbers: seq<int>): int\n{\n    if |numbers| == 0 then 0\n    else (if numbers[0] == 0 then 1 else 0) + countZeros(numbers[1..])\n}\n\nfunction findZeroIndex(numbers: seq<int>): int\n    requires |numbers| > 0\n    requires countZeros(numbers) == 1\n{\n    if numbers[0] == 0 then 0\n    else if |numbers| > 1 then 1 + findZeroIndex(numbers[1..])\n    else 0\n}\n\nfunction parseInts(s: string): seq<int>\n    requires |s| > 0\n    requires validInput(s)\n{\n    parseIntsHelper(s, 0, \"\", [])\n}\n\nfunction generateOutput(numbers: seq<int>): string\n{\n    generateOutputHelper(numbers, 0, \"\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires validInput(input)\n    requires |input| > 0\n    ensures var numbers := parseInts(input);\n            result == generateOutput(numbers)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4464", "vc-description": "Given three integers A, B, and C, determine if it's possible to select one or more \npositive multiples of A such that their sum is congruent to C modulo B.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int)\n{\n  1 <= A <= 100 && 1 <= B <= 100 && 0 <= C < B\n}\n\npredicate IsSolvable(A: int, B: int, C: int)\n{\n  exists i :: 1 <= i < B && (i * (A % B)) % B == C\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int) returns (result: string)\n  requires ValidInput(A, B, C)\n  ensures result == \"YES\" <==> IsSolvable(A, B, C)\n  ensures result == \"NO\" || result == \"YES\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4465", "vc-description": "Calculate the remaining area of a rectangular farm after placing one vertical road\nand one horizontal road, each 1 yard wide, that span the entire width/height.", "vc-preamble": "predicate ValidFarmDimensions(a: int, b: int)\n{\n    a >= 2 && b >= 2 && a <= 100 && b <= 100\n}\n\nfunction RemainingFarmArea(a: int, b: int): int\n    requires ValidFarmDimensions(a, b)\n{\n    a * b - a - b + 1\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidFarmDimensions(a, b)\n    ensures result == RemainingFarmArea(a, b)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4466", "vc-description": "Given a seat of width X centimeters, determine the maximum number of people that can sit on it.\nEach person occupies Y centimeters, and there must be at least Z centimeters of gap between \nany two people and between each end of the seat and the nearest person.", "vc-preamble": "predicate ValidInput(x: int, y: int, z: int)\n{\n    x >= 1 && y >= 1 && z >= 1 && y + 2 * z <= x\n}\n\nfunction MaxPeople(x: int, y: int, z: int): int\n    requires ValidInput(x, y, z)\n{\n    (x - z) / (y + z)\n}\n\npredicate ValidSolution(x: int, y: int, z: int, result: int)\n    requires ValidInput(x, y, z)\n{\n    result == MaxPeople(x, y, z) &&\n    result >= 0 &&\n    result * (y + z) <= x - z < (result + 1) * (y + z)\n}", "vc-helpers": "", "vc-spec": "method solve(x: int, y: int, z: int) returns (result: int)\n    requires ValidInput(x, y, z)\n    ensures ValidSolution(x, y, z, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4469", "vc-description": "Given a shelf, process queries of three types:\n- L id: Add book with index id to the leftmost position\n- R id: Add book with index id to the rightmost position  \n- ? id: Find the minimum number of books to remove from either end to make book id leftmost or rightmost\nFor each ? query, output the minimum number of removals needed.", "vc-preamble": "predicate ValidInput(queries: seq<(char, int)>)\n{\n    && |queries| > 0\n    && (forall i :: 0 <= i < |queries| ==> queries[i].0 in {'L', 'R', '?'})\n    && (forall i :: 0 <= i < |queries| ==> queries[i].1 > 0)\n    && (forall i, j :: 0 <= i < j < |queries| && queries[i].0 in {'L', 'R'} && queries[j].0 in {'L', 'R'} ==> queries[i].1 != queries[j].1)\n    && (forall i :: 0 <= i < |queries| && queries[i].0 == '?' ==> \n        exists j :: 0 <= j < i && queries[j].0 in {'L', 'R'} && queries[j].1 == queries[i].1)\n    && (exists i :: 0 <= i < |queries| && queries[i].0 == '?')\n}\n\npredicate ValidOutput(queries: seq<(char, int)>, results: seq<int>)\n    requires ValidInput(queries)\n{\n    && |results| == |set i | 0 <= i < |queries| && queries[i].0 == '?'|\n    && (forall i :: 0 <= i < |results| ==> results[i] >= 0)\n    && (forall r_idx :: 0 <= r_idx < |results| ==> \n        (exists q_idx :: 0 <= q_idx < |queries| && queries[q_idx].0 == '?' &&\n         results[r_idx] == ComputeMinRemovals(queries, q_idx)))\n    && (forall q_idx :: 0 <= q_idx < |queries| && queries[q_idx].0 == '?' ==>\n        (exists r_idx :: 0 <= r_idx < |results| &&\n         results[r_idx] == ComputeMinRemovals(queries, q_idx)))\n}\n\ndatatype BookshelfState = BookshelfState(positions: map<int, int>, head: int, tail: int)\n\nfunction ComputeMinRemovals(queries: seq<(char, int)>, query_idx: int): int\n    requires 0 <= query_idx < |queries|\n    requires queries[query_idx].0 == '?'\n    requires forall i :: 0 <= i < |queries| ==> queries[i].0 in {'L', 'R', '?'}\n    requires forall i :: 0 <= i < |queries| ==> queries[i].1 > 0\n    requires forall i, j :: 0 <= i < j < |queries| && queries[i].0 in {'L', 'R'} && queries[j].0 in {'L', 'R'} ==> queries[i].1 != queries[j].1\n    requires forall i :: 0 <= i < |queries| && queries[i].0 == '?' ==> \n        exists j :: 0 <= j < i && queries[j].0 in {'L', 'R'} && queries[j].1 == queries[i].1\n{\n    var book_id := queries[query_idx].1;\n    var state := SimulateQueries(queries, query_idx);\n    assert book_id in state.positions;\n    var pos := state.positions[book_id];\n    var left_removals := pos - state.head;\n    var right_removals := state.tail - pos;\n    var min_removals := if left_removals <= right_removals then left_removals else right_removals;\n    min_removals - 1\n}", "vc-helpers": "", "vc-spec": "method solve(queries: seq<(char, int)>) returns (results: seq<int>)\n    requires ValidInput(queries)\n    ensures ValidOutput(queries, results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4470", "vc-description": "Given an integer n, find the minimum number of operations to transform it to 1, or return -1 if impossible.\nAllowed operations: 1) n \u2192 n/2 if n divisible by 2, 2) n \u2192 2n/3 if n divisible by 3, 3) n \u2192 4n/5 if n divisible by 5.", "vc-preamble": "predicate ValidInput(n: nat)\n{\n    n > 0\n}\n\npredicate CanReachOne(n: nat)\n    requires n > 0\n{\n    OnlyFactors235(n)\n}\n\npredicate OnlyFactors235(n: nat)\n    requires n > 0\n{\n    ReduceByFactors235(n) == 1\n}\n\nfunction ReduceByFactors235(n: nat): nat\n    requires n > 0\n    decreases n\n{\n    if n == 1 then 1\n    else if n % 2 == 0 then ReduceByFactors235(n / 2)\n    else if n % 3 == 0 then ReduceByFactors235(n / 3)\n    else if n % 5 == 0 then ReduceByFactors235(n / 5)\n    else n\n}\n\nfunction MinMovesToOne(n: nat): nat\n    requires n > 0\n    requires CanReachOne(n)\n    decreases n\n{\n    if n == 1 then 0\n    else if n % 2 == 0 then 1 + MinMovesToOne(n / 2)\n    else if n % 3 == 0 then 2 + MinMovesToOne(n / 3)\n    else if n % 5 == 0 then 3 + MinMovesToOne(n / 5)\n    else 0\n}", "vc-helpers": "", "vc-spec": "method Solve(n: nat) returns (result: int)\n    requires ValidInput(n)\n    ensures result >= -1\n    ensures result == -1 <==> !CanReachOne(n)\n    ensures result >= 0 ==> CanReachOne(n) && result == MinMovesToOne(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4476", "vc-description": "Given two positive integers a and b, find the minimum number of moves to transform \na into b using these operations: add any positive odd integer to a, or subtract \nany positive even integer from a. It is guaranteed that b can always be obtained from a.", "vc-preamble": "predicate ValidInput(input: seq<(int, int)>)\n{\n    forall i :: 0 <= i < |input| ==> input[i].0 >= 1 && input[i].1 >= 1\n}\n\nfunction MinMoves(a: int, b: int): int\n    requires a >= 1 && b >= 1\n{\n    if a == b then 0\n    else if a < b then\n        if (b - a) % 2 == 1 then 1 else 2\n    else\n        if (a - b) % 2 == 0 then 1 else 2\n}\n\npredicate ValidOutput(input: seq<(int, int)>, result: seq<int>)\n    requires ValidInput(input)\n{\n    |result| == |input| &&\n    forall i :: 0 <= i < |input| ==> result[i] == MinMoves(input[i].0, input[i].1) &&\n    forall i :: 0 <= i < |result| ==> result[i] >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<(int, int)>) returns (result: seq<int>)\n    requires ValidInput(input)\n    ensures ValidOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4477", "vc-description": "Given an apartment number x consisting of the same repeated digit, calculate the total number of digits pressed when calling all \"boring\" apartments (apartments with all same digits) in a specific order until apartment x answers. The calling order is: All apartments with digit 1 (1, 11, 111, 1111), then digit 2 (2, 22, 222, 2222), and so on through digit 9.\n\n// Sum digits for all previous complete digit groups (1-9, 11-99, etc.)\n\n// Sum digits for current digit group up to and including x", "vc-preamble": "predicate IsBoringApartment(x: int)\n{\n    (x >= 1 && x <= 9) ||\n    (x >= 11 && x <= 99 && x % 11 == 0 && x / 11 >= 1 && x / 11 <= 9) ||\n    (x >= 111 && x <= 999 && x % 111 == 0 && x / 111 >= 1 && x / 111 <= 9) ||\n    (x >= 1111 && x <= 9999 && x % 1111 == 0 && x / 1111 >= 1 && x / 1111 <= 9)\n}\n\nfunction DigitCount(n: int): int\n    requires n >= 1 && n <= 9999\n{\n    if n <= 9 then 1\n    else if n <= 99 then 2\n    else if n <= 999 then 3\n    else 4\n}\n\nfunction BoringApartmentValue(digit: int, length: int): int\n    requires 1 <= digit <= 9\n    requires 1 <= length <= 4\n{\n    if length == 1 then digit\n    else if length == 2 then digit * 11\n    else if length == 3 then digit * 111\n    else digit * 1111\n}\n\nfunction TotalDigitsPressed(x: int): int\n    requires IsBoringApartment(x)\n    requires 1 <= x <= 9999\n{\n    var digit := if x <= 9 then x \n                 else if x <= 99 then x / 11\n                 else if x <= 999 then x / 111\n                 else x / 1111;\n    var length := DigitCount(x);\n\n    var prevDigits := if digit == 1 then 0 else (digit - 1) * (1 + 2 + 3 + 4);\n\n    var currentDigits := (length * (length + 1)) / 2;\n\n    prevDigits + currentDigits\n}", "vc-helpers": "", "vc-spec": "method solve(x: int) returns (result: int)\n    requires IsBoringApartment(x)\n    requires 1 <= x <= 9999\n    ensures result >= 0\n    ensures result == TotalDigitsPressed(x)\n    ensures x == 1 ==> result == 1\n    ensures x == 22 ==> result == 13\n    ensures x == 777 ==> result == 66\n    ensures x == 9999 ==> result == 90", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_448", "vc-description": "Given n children numbered 1 to n, where child i needs at least a_i candies.\nChildren initially line up in order 1, 2, ..., n.\nDistribution algorithm:\n1. Give m candies to the first child in line\n2. If the child has received enough candies (\u2265 a_i), they go home\n3. Otherwise, the child goes to the end of the line\n4. Repeat until all children go home\nFind which child goes home last.", "vc-preamble": "predicate ValidInput(n: int, m: int, a: seq<int>) {\n    n > 0 && m > 0 && |a| == n && forall i :: 0 <= i < |a| ==> a[i] > 0\n}\n\npredicate ValidResult(result: int, n: int) {\n    1 <= result <= n\n}\n\nfunction SumCandiesStillNeeded(queue: seq<seq<int>>): nat\n    requires forall child :: child in queue ==> |child| == 3 && child[0] >= 0 && child[1] > 0\n{\n    if |queue| == 0 then 0\n    else\n        var child := queue[0];\n        var stillNeeded := if child[1] <= child[0] then 0 else child[1] - child[0];\n        stillNeeded + SumCandiesStillNeeded(queue[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, m, a)\n    ensures ValidResult(result, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4482", "vc-description": "Given N integers, find the minimum cost to make all integers equal by transforming some of them.\nEach integer can be transformed at most once. The cost of transforming integer x to integer y is (x-y)\u00b2.", "vc-preamble": "function sum_squares(p: int, a: seq<int>): int\n{\n    if |a| == 0 then 0\n    else (p - a[0]) * (p - a[0]) + sum_squares(p, a[1..])\n}\n\npredicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 1 && n <= 100 && |a| == n && \n    forall i :: 0 <= i < |a| ==> -100 <= a[i] <= 100\n}\n\npredicate IsOptimalCost(result: int, a: seq<int>)\n{\n    result >= 0 &&\n    exists p :: -100 <= p <= 100 && result == sum_squares(p, a) &&\n    forall p :: -100 <= p <= 100 ==> result <= sum_squares(p, a)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures IsOptimalCost(result, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4486", "vc-description": "Given a string s of lowercase English letters, extract all characters at odd-numbered positions\n(using 1-based indexing) and concatenate them into a new string. This corresponds to extracting\ncharacters at even indices in 0-based indexing (positions 0, 2, 4, 6, ...).", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 1 && forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\nfunction ExpectedLength(s: string): nat\n{\n    (|s| + 1) / 2\n}\n\npredicate CorrectExtraction(s: string, result: string)\n{\n    |result| == ExpectedLength(s) &&\n    forall i :: 0 <= i < |result| ==> 0 <= 2*i < |s| && result[i] == s[2*i] &&\n    forall i :: 0 <= i < |s| && i % 2 == 0 ==> exists j :: 0 <= j < |result| && result[j] == s[i] && j == i / 2\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures CorrectExtraction(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4487", "vc-description": "Given three strings A, B, and C, determine if they form a word chain.\nA word chain exists if the last character of A equals the first character of B\nand the last character of B equals the first character of C.\nOutput \"YES\" if both conditions are true, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidParsedInput(parts: seq<string>)\n{\n    |parts| == 3 && |parts[0]| > 0 && |parts[1]| > 0 && |parts[2]| > 0\n}\n\npredicate IsWordChain(a: string, b: string, c: string)\n    requires |a| > 0 && |b| > 0 && |c| > 0\n{\n    a[|a|-1] == b[0] && b[|b|-1] == c[0]\n}\n\nfunction ExpectedResult(input: string): string\n    requires ValidInput(input)\n{\n    var stripped := if |input| > 0 && input[|input|-1] == '\\n' then input[0..|input|-1] else input;\n    var parts := SplitOnSpaces(stripped);\n    if ValidParsedInput(parts) then\n        if IsWordChain(parts[0], parts[1], parts[2]) then \"YES\\n\" else \"NO\\n\"\n    else\n        \"\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == ExpectedResult(input)\n    ensures result == \"YES\\n\" || result == \"NO\\n\" || result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4488", "vc-description": "Compare two large positive integers A and B and determine their relative magnitude.\nInput consists of two positive integers on separate lines, each up to 100 digits.\nOutput \"GREATER\" if A > B, \"LESS\" if A < B, or \"EQUAL\" if A = B.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLinesSpec(input);\n    |lines| >= 2 && IsValidInteger(lines[0]) && IsValidInteger(lines[1])\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction SplitLinesSpec(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else if s[0] == '\\n' then SplitLinesSpec(s[1..])\n    else \n        var nextNewline := FindNextNewline(s, 0);\n        if nextNewline == -1 then [s]\n        else \n            assert nextNewline >= 0 && nextNewline < |s|;\n            [s[0..nextNewline]] + SplitLinesSpec(s[nextNewline+1..])\n}\n\nfunction FindNextNewline(s: string, start: nat): int\n    requires start <= |s|\n    decreases |s| - start\n    ensures FindNextNewline(s, start) == -1 || (start <= FindNextNewline(s, start) < |s|)\n    ensures FindNextNewline(s, start) != -1 ==> s[FindNextNewline(s, start)] == '\\n'\n    ensures FindNextNewline(s, start) == -1 ==> forall i :: start <= i < |s| ==> s[i] != '\\n'\n    ensures FindNextNewline(s, start) != -1 ==> forall i :: start <= i < FindNextNewline(s, start) ==> s[i] != '\\n'\n{\n    if start >= |s| then -1\n    else if s[start] == '\\n' then start\n    else FindNextNewline(s, start + 1)\n}\n\nfunction ParseIntSpec(s: string): int\n    requires IsValidInteger(s)\n{\n    ParseIntHelper(s, 0)\n}\n\nfunction ParseIntHelper(s: string, pos: nat): int\n    requires pos <= |s|\n    decreases |s| - pos\n{\n    if pos >= |s| || s[pos] == '\\n' || s[pos] == '\\r' then 0\n    else if '0' <= s[pos] <= '9' then\n        (s[pos] as int - '0' as int) + 10 * ParseIntHelper(s, pos + 1)\n    else\n        ParseIntHelper(s, pos + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures ValidInput(input) ==>\n        var lines := SplitLinesSpec(input);\n        var a := ParseIntSpec(lines[0]);\n        var b := ParseIntSpec(lines[1]);\n        (result == \"LESS\\n\" <==> a < b) &&\n        (result == \"GREATER\\n\" <==> a > b) &&\n        (result == \"EQUAL\\n\" <==> a == b)\n    ensures !ValidInput(input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4489", "vc-description": "Given N blue cards and M red cards with strings, find maximum net earnings.\nWhen a string is announced, earn 1 yen per blue card with that string and\nlose 1 yen per red card with that string. Find the optimal string to maximize earnings.", "vc-preamble": "function count_occurrences(cards: seq<string>, target: string): int\n    ensures count_occurrences(cards, target) >= 0\n{\n    if |cards| == 0 then 0\n    else if cards[0] == target then 1 + count_occurrences(cards[1..], target)\n    else count_occurrences(cards[1..], target)\n}\n\nfunction get_unique_strings(all_strings: seq<string>): seq<string>\n{\n    if |all_strings| == 0 then []\n    else \n        var rest_unique := get_unique_strings(all_strings[1..]);\n        if all_strings[0] in rest_unique then rest_unique\n        else [all_strings[0]] + rest_unique\n}\n\nfunction max_net_earnings(blue_cards: seq<string>, red_cards: seq<string>): int\n    ensures max_net_earnings(blue_cards, red_cards) >= 0\n{\n    var unique_blue := get_unique_strings(blue_cards);\n    max_net_earnings_helper(unique_blue, blue_cards, red_cards, 0, 0)\n}\n\nfunction max_net_earnings_helper(unique_blue: seq<string>, blue_cards: seq<string>, red_cards: seq<string>, index: int, current_max: int): int\n    requires 0 <= index <= |unique_blue|\n    ensures max_net_earnings_helper(unique_blue, blue_cards, red_cards, index, current_max) >= current_max\n    decreases |unique_blue| - index\n{\n    if index >= |unique_blue| then current_max\n    else\n        var s := unique_blue[index];\n        var blue_count := count_occurrences(blue_cards, s);\n        var red_count := count_occurrences(red_cards, s);\n        var net := blue_count - red_count;\n        var new_max := if net > current_max then net else current_max;\n        max_net_earnings_helper(unique_blue, blue_cards, red_cards, index + 1, new_max)\n}", "vc-helpers": "", "vc-spec": "method solve(blue_cards: seq<string>, red_cards: seq<string>) returns (result: int)\n    ensures result >= 0\n    ensures result == max_net_earnings(blue_cards, red_cards)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_449", "vc-description": "Given an integer n representing dollars, find the minimum number of bills \nneeded to represent this amount using denominations of $1, $5, $10, $20, and $100.", "vc-preamble": "predicate ValidInput(n: int) {\n    n >= 1\n}\n\nfunction MinBills(n: int): int\n    requires n >= 1\n{\n    n / 100 + (n % 100) / 20 + ((n % 100) % 20) / 10 + (((n % 100) % 20) % 10) / 5 + ((((n % 100) % 20) % 10) % 5)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result >= 0\n    ensures result == MinBills(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4490", "vc-description": "Given a DNA base represented by a single letter (A, C, G, or T), find its complementary base\naccording to the pairing rules: A pairs with T, T pairs with A, C pairs with G, G pairs with C", "vc-preamble": "predicate ValidDNABase(c: char)\n{\n    c in {'A', 'T', 'C', 'G'}\n}\n\nfunction DNAComplement(c: char): char\n    requires ValidDNABase(c)\n{\n    match c\n        case 'A' => 'T'\n        case 'T' => 'A'\n        case 'C' => 'G'\n        case 'G' => 'C'\n}\n\npredicate ValidInput(input: string)\n{\n    var input_line := if exists i :: 0 <= i < |input| && input[i] == '\\n'\n                      then input[..find_newline(input)]\n                      else input;\n    |input_line| == 1 && ValidDNABase(input_line[0])\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    ensures var input_line := if exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n'\n                              then stdin_input[..find_newline(stdin_input)]\n                              else stdin_input;\n            if ValidInput(stdin_input) then\n                result == [DNAComplement(input_line[0])] + \"\\n\"\n            else\n                result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4491", "vc-description": "Given a 2\u00d7N grid where each cell contains candies, find the maximum number of candies\nthat can be collected when traveling from top-left to bottom-right. You can only move\nright or down, and you collect all candies from visited cells.", "vc-preamble": "predicate ValidInput(n: int, a_1: seq<int>, a_2: seq<int>)\n{\n    n >= 1 &&\n    |a_1| == n && |a_2| == n &&\n    forall i :: 0 <= i < n ==> 1 <= a_1[i] <= 100 && 1 <= a_2[i] <= 100\n}\n\nfunction sum_range(s: seq<int>, start: int, end: int): int\n    requires 0 <= start <= end <= |s|\n    requires forall i :: start <= i < end ==> s[i] >= 1\n    decreases end - start\n    ensures sum_range(s, start, end) >= 0\n    ensures start < end ==> sum_range(s, start, end) >= end - start\n    ensures start < end && (forall i :: start <= i < end ==> s[i] <= 100) ==> sum_range(s, start, end) <= (end - start) * 100\n{\n    if start == end then 0\n    else s[start] + sum_range(s, start + 1, end)\n}\n\npredicate IsValidResult(n: int, a_1: seq<int>, a_2: seq<int>, result: int)\n    requires ValidInput(n, a_1, a_2)\n{\n    result >= n + 1 &&\n    result <= (n + 1) * 100 &&\n    exists i :: 0 <= i < n && result == sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n) &&\n    forall i :: 0 <= i < n ==> result >= sum_range(a_1, 0, i + 1) + sum_range(a_2, i, n)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a_1: seq<int>, a_2: seq<int>) returns (result: int)\n    requires ValidInput(n, a_1, a_2)\n    ensures IsValidResult(n, a_1, a_2, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4492", "vc-description": "Given N boxes in a row with a_i candies in the i-th box, find the minimum number of candies \nto eat such that every pair of adjacent boxes contains at most x candies in total.\nOperation: Choose any box with at least one candy and eat one candy from it.\nObjective: For all i from 1 to N-1, ensure a_i + a_{i+1} \u2264 x.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitByNewlineSpec(input);\n    |lines| >= 2 &&\n    var firstLine := SplitBySpaceSpec(lines[0]);\n    |firstLine| >= 2 &&\n    var N := ParseIntSpec(firstLine[0]);\n    var x := ParseIntSpec(firstLine[1]);\n    N >= 2 && x >= 0 &&\n    var secondLine := SplitBySpaceSpec(lines[1]);\n    |secondLine| == N &&\n    (forall i :: 0 <= i < N ==> ParseIntSpec(secondLine[i]) >= 0)\n}\n\nfunction MinimumCandiesNeeded(input: string): int\n    requires ValidInput(input)\n    ensures MinimumCandiesNeeded(input) >= 0\n{\n    var lines := SplitByNewlineSpec(input);\n    var firstLine := SplitBySpaceSpec(lines[0]);\n    var N := ParseIntSpec(firstLine[0]);\n    var x := ParseIntSpec(firstLine[1]);\n    var secondLine := SplitBySpaceSpec(lines[1]);\n    var A := seq(N, i requires 0 <= i < N => ParseIntSpec(secondLine[i]));\n    ComputeMinimumOperations(A, x)\n}\n\nfunction ComputeMinimumOperations(A: seq<int>, x: int): int\n    requires |A| >= 2\n    requires x >= 0\n    requires forall i :: 0 <= i < |A| ==> A[i] >= 0\n    ensures ComputeMinimumOperations(A, x) >= 0\n{\n    var A0 := if A[0] > x then x else A[0];\n    var cnt0 := if A[0] > x then A[0] - x else 0;\n    ComputeOperationsFromIndex(A, x, 1, [A0] + A[1..], cnt0)\n}\n\nfunction ComputeOperationsFromIndex(originalA: seq<int>, x: int, index: int, currentA: seq<int>, currentCount: int): int\n    requires |originalA| >= 2\n    requires x >= 0\n    requires 1 <= index <= |originalA|\n    requires |currentA| == |originalA|\n    requires currentCount >= 0\n    requires forall i :: 0 <= i < |originalA| ==> originalA[i] >= 0\n    ensures ComputeOperationsFromIndex(originalA, x, index, currentA, currentCount) >= currentCount\n    decreases |originalA| - index\n{\n    if index >= |originalA| then currentCount\n    else\n        var newValue := if currentA[index] + currentA[index-1] > x then x - currentA[index-1] else currentA[index];\n        var additionalOps := if currentA[index] + currentA[index-1] > x then currentA[index] + currentA[index-1] - x else 0;\n        var newA := currentA[index := newValue];\n        ComputeOperationsFromIndex(originalA, x, index + 1, newA, currentCount + additionalOps)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result == IntToString(MinimumCandiesNeeded(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4494", "vc-description": "Given the type of contest held last week (\"ABC\" or \"ARC\"), determine the type \nof contest to be held this week. Contests alternate between these two types.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    (var s := if input[|input|-1] == '\\n' then input[..|input|-1] else input;\n     s == \"ABC\" || s == \"ARC\")\n}\n\nfunction NormalizeInput(input: string): string\n    requires |input| > 0\n{\n    if input[|input|-1] == '\\n' then input[..|input|-1] else input\n}\n\nfunction ExpectedOutput(input: string): string\n    requires ValidInput(input)\n{\n    var s := NormalizeInput(input);\n    if s == \"ABC\" then \"ARC\\n\" else \"ABC\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == ExpectedOutput(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4495", "vc-description": "Given nonnegative integers a and b (where a \u2264 b) and a positive integer x,\ncount how many integers in the range [a, b] inclusive are divisible by x.", "vc-preamble": "predicate ValidInput(a: int, b: int, x: int)\n{\n    a >= 0 && b >= a && x > 0\n}\n\nfunction CountDivisibleInRange(a: int, b: int, x: int): int\n    requires ValidInput(a, b, x)\n    ensures CountDivisibleInRange(a, b, x) >= 0\n{\n    if a == 0 then\n        b / x + 1\n    else\n        b / x - (a - 1) / x\n}", "vc-helpers": "", "vc-spec": "method CountDivisible(a: int, b: int, x: int) returns (count: int)\n    requires ValidInput(a, b, x)\n    ensures count == CountDivisibleInRange(a, b, x)\n    ensures count >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4496", "vc-description": "Given an integer D representing a December date (22-25), output the corresponding Christmas-related string:\nD=25: \"Christmas\", D=24: \"Christmas Eve\", D=23: \"Christmas Eve Eve\", D=22: \"Christmas Eve Eve Eve\"", "vc-preamble": "predicate ValidInput(d: int) {\n    22 <= d <= 25\n}\n\nfunction ExpectedOutput(d: int): string\n    requires ValidInput(d)\n{\n    var eveCount := 25 - d;\n    var baseString := \"Christmas\";\n    if eveCount == 0 then baseString\n    else baseString + RepeatEve(eveCount)\n}\n\nfunction RepeatEve(count: int): string\n    requires count >= 0\n    decreases count\n{\n    if count == 0 then \"\"\n    else \" Eve\" + RepeatEve(count - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(d: int) returns (result: string)\n    requires ValidInput(d)\n    ensures result == ExpectedOutput(d)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4498", "vc-description": "Given three integer positions a, b, c on a number line and an integer communication range d,\ndetermine if positions a and c can communicate either directly (distance \u2264 d) or indirectly\nthrough position b (both a-b and b-c distances \u2264 d).", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int)\n{\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100 && 1 <= d <= 100\n}\n\npredicate CanCommunicate(a: int, b: int, c: int, d: int)\n{\n    abs(a - c) <= d || (abs(a - b) <= d && abs(b - c) <= d)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int) returns (result: string)\n    requires ValidInput(a, b, c, d)\n    ensures result == \"Yes\" <==> CanCommunicate(a, b, c, d)\n    ensures result == \"Yes\" || result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_45", "vc-description": "Given positive integers n and k, find a strictly increasing sequence of k positive integers \nthat sum to n and have the maximum possible greatest common divisor (GCD). \nIf no such sequence exists, return -1.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n > 0 && k > 0\n}\n\npredicate IsStrictlyIncreasing(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| - 1 ==> s[i] < s[i+1]\n}\n\npredicate AllPositive(s: seq<int>)\n{\n    forall i :: 0 <= i < |s| ==> s[i] > 0\n}\n\nfunction sum(s: seq<int>): int\n    decreases |s|\n{\n    if |s| == 0 then 0 else s[0] + sum(s[1..])\n}\n\npredicate ValidSequence(s: seq<int>, n: int, k: int)\n{\n    |s| == k && AllPositive(s) && IsStrictlyIncreasing(s) && sum(s) == n\n}\n\npredicate IsPossible(n: int, k: int)\n{\n    k * (k + 1) / 2 <= n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: seq<int>)\n    requires ValidInput(n, k)\n    ensures (|result| == 1 && result[0] == -1) || \n            (ValidSequence(result, n, k))\n    ensures (|result| == 1 && result[0] == -1) <==> !IsPossible(n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4501", "vc-description": "Given N cards with integers written on them, count the number of ways to select\none or more cards such that the average of the selected cards equals exactly A.", "vc-preamble": "predicate valid_input_format(stdin_input: string)\n{\n    var lines := split_lines_func(stdin_input);\n    |lines| >= 2 &&\n    var first_line := split_spaces_func(lines[0]);\n    var second_line := split_spaces_func(lines[1]);\n    |first_line| == 2 &&\n    is_valid_integer(first_line[0]) &&\n    is_valid_integer(first_line[1]) &&\n    var N := string_to_int_func(first_line[0]);\n    var A := string_to_int_func(first_line[1]);\n    1 <= N <= 50 &&\n    1 <= A <= 50 &&\n    |second_line| == N &&\n    (forall j | 0 <= j < |second_line| :: \n        is_valid_integer(second_line[j]) &&\n        1 <= string_to_int_func(second_line[j]) <= 50)\n}\n\npredicate is_valid_output(output: string)\n{\n    |output| > 1 && \n    output[|output|-1] == '\\n' &&\n    var result_str := output[..|output|-1];\n    is_valid_integer(result_str) &&\n    string_to_int_func(result_str) >= 0\n}\n\npredicate output_represents_correct_count(stdin_input: string, output: string)\n    requires valid_input_format(stdin_input)\n    requires is_valid_output(output)\n{\n    var lines := split_lines_func(stdin_input);\n    var first_line := split_spaces_func(lines[0]);\n    var second_line := split_spaces_func(lines[1]);\n    var N := string_to_int_func(first_line[0]);\n    var A := string_to_int_func(first_line[1]);\n    var cards := seq(N, i requires 0 <= i < N => string_to_int_func(second_line[i]));\n    var result := string_to_int_func(output[..|output|-1]);\n    result == count_valid_selections(cards, A)\n}\n\nfunction count_valid_selections(cards: seq<int>, A: int): int\n{\n    var differences := seq(|cards|, i requires 0 <= i < |cards| => cards[i] - A);\n    var total := count_zero_sum_subsets(differences);\n    if total > 0 then total - 1 else 0\n}\n\nfunction count_zero_sum_subsets(differences: seq<int>): nat\n{\n    if |differences| == 0 then 1\n    else\n        var rest_count := count_zero_sum_subsets(differences[1..]);\n        rest_count + count_subsets_with_sum(differences[1..], -differences[0])\n}\n\nfunction count_subsets_with_sum(differences: seq<int>, target: int): nat\n{\n    if |differences| == 0 then if target == 0 then 1 else 0\n    else\n        count_subsets_with_sum(differences[1..], target) +\n        count_subsets_with_sum(differences[1..], target - differences[0])\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires |stdin_input| > 0\n    requires valid_input_format(stdin_input)\n    ensures |output| > 0\n    ensures output[|output|-1] == '\\n'\n    ensures is_valid_output(output)\n    ensures output_represents_correct_count(stdin_input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4502", "vc-description": "Given an integer sequence a of length n, simulate n operations on an initially empty sequence b:\nOperation i: Append a[i] to the end of b, then reverse the entire sequence b\nOutput the final sequence b after all n operations.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>) {\n    n >= 1 && |a| == n\n}\n\nfunction simulateOperations(a: seq<int>): seq<int>\n    requires |a| >= 1\n    decreases |a|\n{\n    if |a| == 1 then \n        [a[0]]\n    else\n        var prev := simulateOperations(a[..|a|-1]);\n        reverseSeq(prev + [a[|a|-1]])\n}\n\nfunction computeResult(a: seq<int>): seq<int>\n    requires |a| >= 1\n    ensures |computeResult(a)| == |a|\n{\n    var n := |a|;\n    var o := seq(if n % 2 == 0 then n / 2 else (n + 1) / 2, i requires 0 <= i < (if n % 2 == 0 then n / 2 else (n + 1) / 2) => a[2*i]);\n    var e := seq(n / 2, i requires 0 <= i < n / 2 => a[2*i + 1]);\n    if n % 2 == 0 then\n        reverseSeq(e) + o\n    else\n        reverseSeq(o) + e\n}\n\nfunction reverseSeq(s: seq<int>): seq<int>\n    ensures |reverseSeq(s)| == |s|\n    ensures forall i :: 0 <= i < |s| ==> reverseSeq(s)[i] == s[|s| - 1 - i]\n{\n    if |s| == 0 then []\n    else reverseSeq(s[1..]) + [s[0]]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, a)\n    ensures |result| == n\n    ensures result == computeResult(a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4504", "vc-description": "Given an even string S, find the length of the longest even string that can be \nobtained by deleting one or more characters from the end of S. An even string\nis one that can be split into two identical halves.", "vc-preamble": "predicate IsEvenString(s: string)\n{\n    |s| >= 2 && |s| % 2 == 0 && s[..|s|/2] == s[|s|/2..]\n}\n\npredicate ValidInput(S: string)\n{\n    |S| >= 2 && IsEvenString(S)\n}\n\npredicate ValidSolution(S: string, result: int)\n{\n    2 <= result < |S| && result % 2 == 0 && IsEvenString(S[..result])\n}\n\npredicate IsMaximalSolution(S: string, result: int)\n{\n    ValidSolution(S, result) && \n    forall k :: result < k < |S| && k % 2 == 0 ==> !IsEvenString(S[..k])\n}", "vc-helpers": "", "vc-spec": "method solve(S: string) returns (result: int)\n    requires ValidInput(S)\n    requires exists k :: ValidSolution(S, k)\n    ensures ValidSolution(S, result)\n    ensures IsMaximalSolution(S, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4505", "vc-description": "Given a string S of length 3 containing only characters 'a', 'b', and 'c',\ndetermine if S is a permutation of \"abc\" (i.e., contains exactly one occurrence\neach of 'a', 'b', and 'c'). Return \"Yes\\n\" if it is a permutation, \"No\\n\" otherwise.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    (|s| == 3 || (|s| == 4 && s[3] == '\\n')) &&\n    forall i :: 0 <= i < (if |s| == 4 then 3 else |s|) ==> (s[i] == 'a' || s[i] == 'b' || s[i] == 'c')\n}\n\nfunction GetInputChars(s: string): string\n    requires ValidInput(s)\n{\n    if |s| == 4 then s[..3] else s\n}\n\npredicate IsPermutationOfABC(input_chars: string)\n    requires |input_chars| == 3\n    requires forall i :: 0 <= i < |input_chars| ==> (input_chars[i] == 'a' || input_chars[i] == 'b' || input_chars[i] == 'c')\n{\n    input_chars[0] != input_chars[1] && \n    input_chars[1] != input_chars[2] && \n    input_chars[0] != input_chars[2]\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| >= 3\n    requires ValidInput(s)\n    ensures result == \"Yes\\n\" || result == \"No\\n\"\n    ensures result == \"Yes\\n\" <==> IsPermutationOfABC(GetInputChars(s))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4508", "vc-description": "Given an undirected tree with n vertices, add the minimum number of edges \nsuch that the shortest path from vertex 1 to any other vertex is at most 2.\nLoops and multiple edges are not allowed.", "vc-preamble": "predicate ValidInput(n: int, edges: seq<(int, int)>)\n{\n    n >= 2 && |edges| == n - 1 &&\n    forall e :: e in edges ==> 1 <= e.0 <= n && 1 <= e.1 <= n && e.0 != e.1\n}\n\npredicate AllVerticesWithinDistance2(n: int, edges: seq<(int, int)>)\n    requires n >= 2\n{\n    forall v :: 2 <= v <= n ==> ShortestPathDistance(n, edges, 1, v) <= 2\n}\n\nfunction ShortestPathDistance(n: int, edges: seq<(int, int)>, start: int, end: int): int\n    requires n >= 1 && 1 <= start <= n && 1 <= end <= n\n{\n    if start == end then 0 else ComputeShortestPath(n, edges, start, end)\n}\n\nfunction ComputeShortestPath(n: int, edges: seq<(int, int)>, start: int, end: int): int\n    requires n >= 1 && 1 <= start <= n && 1 <= end <= n\n{\n    var adj := BuildAdjacencyList(n, edges);\n    BFS(adj, n, start, end)\n}\n\nfunction BuildAdjacencyList(n: int, edges: seq<(int, int)>): seq<seq<int>>\n    requires n >= 1\n    ensures |BuildAdjacencyList(n, edges)| == n + 1\n{\n    var adj := seq(n + 1, i => []);\n    AddEdgesToAdjList(adj, edges)\n}\n\nfunction AddEdgesToAdjList(adj: seq<seq<int>>, edges: seq<(int, int)>): seq<seq<int>>\n    requires |adj| >= 1\n    ensures |AddEdgesToAdjList(adj, edges)| == |adj|\n    decreases |edges|\n{\n    if |edges| == 0 then adj\n    else \n        var e := edges[0];\n        if 1 <= e.0 < |adj| && 1 <= e.1 < |adj| then\n            var newAdj := adj[e.0 := adj[e.0] + [e.1]][e.1 := adj[e.1] + [e.0]];\n            AddEdgesToAdjList(newAdj, edges[1..])\n        else\n            AddEdgesToAdjList(adj, edges[1..])\n}\n\nfunction BFS(adj: seq<seq<int>>, n: int, start: int, end: int): int\n    requires n >= 1 && |adj| == n + 1 && 1 <= start <= n && 1 <= end <= n\n{\n    if start == end then 0 else\n    if end in adj[start] then 1 else\n    if DistanceIs2(adj, start, end) then 2\n    else 3\n}\n\npredicate DistanceIs2(adj: seq<seq<int>>, start: int, end: int)\n    requires |adj| > 0 && 0 <= start < |adj|\n{\n    exists neighbor :: neighbor in adj[start] && 0 <= neighbor < |adj| && end in adj[neighbor]\n}\n\npredicate IsMinimalSolution(n: int, originalEdges: seq<(int, int)>, numEdgesToAdd: int)\n    requires ValidInput(n, originalEdges)\n{\n    numEdgesToAdd >= 0\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures |output| > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4528", "vc-description": "Calculate the number of minutes remaining until New Year (00:00) given the current time in 24-hour format.\nInput is a sequence of (hour, minute) pairs representing current times.\nOutput is the corresponding minutes remaining until midnight for each test case.", "vc-preamble": "predicate ValidInput(testCases: seq<(int, int)>)\n{\n    forall i :: 0 <= i < |testCases| ==> \n        0 <= testCases[i].0 < 24 && \n        0 <= testCases[i].1 < 60 && \n        !(testCases[i].0 == 0 && testCases[i].1 == 0)\n}\n\nfunction MinutesUntilMidnight(h: int, m: int): int\n    requires 0 <= h < 24\n    requires 0 <= m < 60\n    requires !(h == 0 && m == 0)\n{\n    1440 - (h * 60 + m)\n}\n\npredicate ValidOutput(results: seq<int>)\n{\n    forall i :: 0 <= i < |results| ==> 1 <= results[i] <= 1439\n}", "vc-helpers": "", "vc-spec": "method solve(testCases: seq<(int, int)>) returns (results: seq<int>)\n    requires ValidInput(testCases)\n    ensures |results| == |testCases|\n    ensures forall i :: 0 <= i < |results| ==> results[i] == MinutesUntilMidnight(testCases[i].0, testCases[i].1)\n    ensures ValidOutput(results)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4534", "vc-description": "Given a non-negative integer k where 0 \u2264 k \u2264 33, return the kth row of Pascal's triangle \nas a list of integers. Row indexing starts from 0. In Pascal's triangle, each element \nequals the sum of the two elements directly above it in the previous row.", "vc-preamble": "function binomial(n: int, k: int): int\n    requires 0 <= k <= n\n{\n    if k == 0 || k == n then 1\n    else if k == 1 then n\n    else binomial(n-1, k-1) + binomial(n-1, k)\n}", "vc-helpers": "", "vc-spec": "method getRow(k: int) returns (result: seq<int>)\n    requires 0 <= k <= 33\n    ensures |result| == k + 1\n    ensures forall i :: 0 <= i < |result| ==> result[i] == binomial(k, i)\n    ensures forall i :: 0 <= i < |result| ==> result[i] > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4538", "vc-description": "Given N points in a 2D plane, count how many points are within distance D from the origin (0,0).\nDistance is measured using Euclidean distance, and we check if distance <= D.", "vc-preamble": "predicate ValidInput(N: int, D: int, points: seq<(int, int)>)\n{\n    N >= 0 && D >= 0 && |points| >= N\n}\n\npredicate WithinDistance(point: (int, int), D: int)\n{\n    point.0 * point.0 + point.1 * point.1 <= D * D\n}\n\nfunction CountPointsWithinDistance(N: int, D: int, points: seq<(int, int)>): int\n    requires ValidInput(N, D, points)\n{\n    |set i | 0 <= i < N && WithinDistance(points[i], D)|\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, D: int, points: seq<(int, int)>) returns (result: int)\n    requires ValidInput(N, D, points)\n    ensures 0 <= result <= N\n    ensures result == CountPointsWithinDistance(N, D, points)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4539", "vc-description": "Given an integer N, determine if N is divisible by the sum of its digits (when written in base 10).\nReturn \"Yes\" if N is divisible by the sum of its digits, otherwise return \"No\".", "vc-preamble": "function sumOfDigits(n: int): int\n  requires n >= 0\n  ensures n > 0 ==> sumOfDigits(n) > 0\n  ensures n == 0 ==> sumOfDigits(n) == 0\n{\n  if n == 0 then 0\n  else (n % 10) + sumOfDigits(n / 10)\n}\n\npredicate ValidInput(N: int)\n{\n  N >= 1\n}\n\npredicate IsDivisibleByDigitSum(N: int)\n  requires N >= 1\n{\n  N % sumOfDigits(N) == 0\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: string)\n  requires ValidInput(N)\n  ensures result == \"Yes\" || result == \"No\"\n  ensures result == \"Yes\" <==> IsDivisibleByDigitSum(N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4541", "vc-description": "Given a single lowercase English letter, determine if it is a vowel (a, e, i, o, u) or consonant.\nReturn \"vowel\" if the letter is a vowel, otherwise return \"consonant\".", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| == 1 && 'a' <= input[0] <= 'z'\n}\n\npredicate IsVowel(c: char)\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n}\n\nfunction ExpectedOutput(input: string): string\n    requires ValidInput(input)\n{\n    if IsVowel(input[0]) then \"vowel\" else \"consonant\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == ExpectedOutput(input)\n    ensures result == \"vowel\" || result == \"consonant\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4542", "vc-description": "Given a string of stones ('B' for black, 'W' for white), find the minimum number \nof stones to place at either end to make all stones the same color. When placing \na stone, all stones of opposite color between the new stone and the nearest \nexisting stone of the same color are flipped.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> s[i] == 'B' || s[i] == 'W'\n}\n\nfunction CountSegments(s: string): int\n    requires |s| > 0\n    ensures CountSegments(s) >= 1\n    ensures CountSegments(s) <= |s|\n{\n    if |s| == 1 then 1\n    else \n        CountSegments(s[..|s|-1]) + (if s[|s|-1] != s[|s|-2] then 1 else 0)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result >= 0\n    ensures result == CountSegments(s) - 1\n    ensures result <= |s| - 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4543", "vc-description": "Given two positive integers a and b, determine whether their string concatenation \n(a followed by b) forms a perfect square number. Return \"Yes\" if it's a perfect \nsquare, \"No\" otherwise.", "vc-preamble": "predicate IsPerfectSquare(n: int)\n  requires n >= 0\n{\n  var sqrt_n := Sqrt(n);\n  sqrt_n * sqrt_n == n\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: string)\n  requires a >= 1 && a <= 100\n  requires b >= 1 && b <= 100\n  ensures result == \"Yes\" || result == \"No\"\n  ensures var a_str := IntToString(a);\n          var b_str := IntToString(b);\n          var concat_str := a_str + b_str;\n          var concat_num := StringToInt(concat_str);\n          result == \"Yes\" <==> IsPerfectSquare(concat_num)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4545", "vc-description": "Given an N\u00d7N grid with N\u00b2 total squares where A squares are painted white,\ndetermine how many squares are painted black (N\u00b2 - A).", "vc-preamble": "predicate ValidInput(N: int, A: int)\n{\n    1 <= N <= 100 && 0 <= A <= N * N\n}\n\nfunction BlackSquares(N: int, A: int): int\n    requires ValidInput(N, A)\n{\n    N * N - A\n}\n\npredicate ValidOutput(N: int, A: int, result: int)\n    requires ValidInput(N, A)\n{\n    result == BlackSquares(N, A) && result >= 0\n}", "vc-helpers": "", "vc-spec": "method CalculateBlackSquares(N: int, A: int) returns (blackSquares: int)\n    requires ValidInput(N, A)\n    ensures ValidOutput(N, A, blackSquares)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4546", "vc-description": "Given three integers a, b, and c representing the heights of three poles,\ndetermine if they form an arithmetic sequence (i.e., b - a = c - b).\nInput is a string containing three space-separated integers.\nOutput is \"YES\\n\" if arithmetic sequence, \"NO\\n\" otherwise.", "vc-preamble": "predicate ValidThreeIntegers(input: string, a: int, b: int, c: int)\n{\n    var parts := SplitBySpacesFunc(input);\n    |parts| == 3 && \n    IsValidInteger(parts[0]) &&\n    IsValidInteger(parts[1]) &&\n    IsValidInteger(parts[2]) &&\n    ParseIntFunc(parts[0]) == a &&\n    ParseIntFunc(parts[1]) == b &&\n    ParseIntFunc(parts[2]) == c\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && \n    (s[0] != '-' || |s| > 1) &&\n    (s[0] == '-' ==> forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9') &&\n    (s[0] != '-' ==> forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')\n}\n\nfunction SplitBySpacesFunc(s: string): seq<string>\n{\n    SplitBySpacesHelper(s, 0, \"\", [])\n}\n\nfunction SplitBySpacesHelper(s: string, i: int, current: string, parts: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then parts + [current] else parts\n    else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' then\n        if |current| > 0 then\n            SplitBySpacesHelper(s, i + 1, \"\", parts + [current])\n        else\n            SplitBySpacesHelper(s, i + 1, current, parts)\n    else\n        SplitBySpacesHelper(s, i + 1, current + [s[i]], parts)\n}\n\nfunction ParseIntFunc(s: string): int\n    requires |s| > 0\n    requires IsValidInteger(s)\n{\n    if |s| > 0 && s[0] == '-' then\n        -ParseUnsignedInt(s[1..])\n    else\n        ParseUnsignedInt(s)\n}\n\nfunction ParseUnsignedInt(s: string): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n    decreases |s|\n{\n    if |s| == 0 then 0\n    else ParseUnsignedInt(s[..|s|-1]) * 10 + (s[|s|-1] as int - '0' as int)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures (exists a: int, b: int, c: int :: ValidThreeIntegers(input, a, b, c)) ==> \n            (result == \"YES\\n\" || result == \"NO\\n\")\n    ensures (exists a: int, b: int, c: int :: ValidThreeIntegers(input, a, b, c)) ==> \n            (exists a: int, b: int, c: int :: ValidThreeIntegers(input, a, b, c) && \n             (result == \"YES\\n\" <==> b - a == c - b))\n    ensures !(exists a: int, b: int, c: int :: ValidThreeIntegers(input, a, b, c)) ==> \n            result == \"\"\n    ensures (forall a1: int, b1: int, c1: int, a2: int, b2: int, c2: int ::\n        ValidThreeIntegers(input, a1, b1, c1) && ValidThreeIntegers(input, a2, b2, c2) ==>\n        a1 == a2 && b1 == b2 && c1 == c2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4547", "vc-description": "Given a two-digit integer N (10 \u2264 N \u2264 99), determine whether the digit 9 appears \nin the decimal representation of N. Return \"Yes\" if 9 appears, \"No\" otherwise.", "vc-preamble": "function clean_input(s: string): string\n{\n    if |s| == 0 then s\n    else if s[|s|-1] == '\\n' || s[|s|-1] == '\\r' || s[|s|-1] == ' ' then\n        clean_input(s[..|s|-1])\n    else s\n}\n\npredicate contains_digit_nine(s: string)\n{\n    exists i :: 0 <= i < |s| && s[i] == '9'\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\nrequires |stdin_input| > 0\nensures result == \"Yes\\n\" || result == \"No\\n\"\nensures result == \"Yes\\n\" <==> contains_digit_nine(clean_input(stdin_input))\nensures result == \"No\\n\" <==> !contains_digit_nine(clean_input(stdin_input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4550", "vc-description": "Given three candy packs with a, b, and c candies respectively, determine if it's possible \nto distribute these packs between two students such that each receives the same total number \nof candies. Each pack must be given entirely to one student.", "vc-preamble": "predicate ValidInputFormat(input: string)\n{\n    |input| > 0 && \n    var nums := ExtractNumbers(input, 0, [], \"\");\n    |nums| >= 3 && \n    (forall i :: 0 <= i < 3 ==> 1 <= nums[i] <= 100)\n}\n\nfunction ParseThreeIntsFunc(input: string): (int, int, int)\n    requires |input| > 0\n    requires ValidInputFormat(input)\n    ensures ParseThreeIntsFunc(input).0 >= 1 && ParseThreeIntsFunc(input).1 >= 1 && ParseThreeIntsFunc(input).2 >= 1\n    ensures ParseThreeIntsFunc(input).0 <= 100 && ParseThreeIntsFunc(input).1 <= 100 && ParseThreeIntsFunc(input).2 <= 100\n{\n    var nums := ExtractNumbers(input, 0, [], \"\");\n    (nums[0], nums[1], nums[2])\n}\n\npredicate CanDistributeEqually(a: int, b: int, c: int)\n{\n    a + b == c || b + c == a || c + a == b\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInputFormat(input)\n    ensures result == \"Yes\\n\" || result == \"No\\n\"\n    ensures var numbers := ParseThreeIntsFunc(input);\n            var a := numbers.0;\n            var b := numbers.1; \n            var c := numbers.2;\n            result == \"Yes\\n\" <==> CanDistributeEqually(a, b, c)\n    ensures var numbers := ParseThreeIntsFunc(input);\n            numbers.0 >= 1 && numbers.1 >= 1 && numbers.2 >= 1 &&\n            numbers.0 <= 100 && numbers.1 <= 100 && numbers.2 <= 100", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4551", "vc-description": "Given four integer weights A, B, C, D, determine the direction a balance scale tips when:\n- Left pan contains masses with weights A and B  \n- Right pan contains masses with weights C and D\nCompare the total weights on each side and output \"Left\", \"Right\", or \"Balanced\"", "vc-preamble": "predicate ValidParseable(input: string)\n{\n    var parts := SplitStringPure(input);\n    |parts| >= 4\n}\n\npredicate AllPartsAreIntegers(input: string)\n{\n    var parts := SplitStringPure(input);\n    |parts| >= 4 &&\n    IsValidInteger(parts[0]) &&\n    IsValidInteger(parts[1]) &&\n    IsValidInteger(parts[2]) &&\n    IsValidInteger(parts[3])\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && (forall i :: 0 <= i < |s| ==> ('0' <= s[i] <= '9') || (i == 0 && s[i] == '-'))\n}\n\npredicate ValidParse(input: string, a: int, b: int, c: int, d: int)\n{\n    var parts := SplitStringPure(input);\n    |parts| >= 4 && \n    IsValidInteger(parts[0]) &&\n    IsValidInteger(parts[1]) &&\n    IsValidInteger(parts[2]) &&\n    IsValidInteger(parts[3]) &&\n    StringToIntPure(parts[0]) == a &&\n    StringToIntPure(parts[1]) == b &&\n    StringToIntPure(parts[2]) == c &&\n    StringToIntPure(parts[3]) == d\n}\n\nfunction SplitStringPure(s: string): seq<string>\n{\n    SplitStringHelper(s, 0, \"\", [])\n}\n\nfunction SplitStringHelper(s: string, i: int, current: string, acc: seq<string>): seq<string>\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i == |s| then\n        if |current| > 0 then acc + [current] else acc\n    else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\t' then\n        if |current| > 0 then\n            SplitStringHelper(s, i + 1, \"\", acc + [current])\n        else\n            SplitStringHelper(s, i + 1, \"\", acc)\n    else\n        SplitStringHelper(s, i + 1, current + [s[i]], acc)\n}\n\nfunction StringToIntPure(s: string): int\n    requires IsValidInteger(s)\n{\n    if |s| > 0 && s[0] == '-' then\n        -StringToIntHelperUnsigned(s, 1, 0)\n    else\n        StringToIntHelperUnsigned(s, 0, 0)\n}\n\nfunction StringToIntHelperUnsigned(s: string, i: int, acc: int): int\n    requires 0 <= i <= |s|\n    decreases |s| - i\n{\n    if i == |s| then acc\n    else if '0' <= s[i] <= '9' then\n        StringToIntHelperUnsigned(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    else\n        acc\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    ensures (forall a, b, c, d: int :: \n        ValidParse(input, a, b, c, d) ==> \n        (result == \"Left\\n\" <==> a + b > c + d) &&\n        (result == \"Right\\n\" <==> a + b < c + d) &&\n        (result == \"Balanced\\n\" <==> a + b == c + d))\n    ensures ValidParseable(input) && AllPartsAreIntegers(input) ==> (result == \"Left\\n\" || result == \"Right\\n\" || result == \"Balanced\\n\")\n    ensures (!ValidParseable(input) || !AllPartsAreIntegers(input)) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4553", "vc-description": "Given integers A and B, and a string S of length A+B+1, determine if S follows \nthe postal code format where the character at position A+1 (1-indexed) is a hyphen '-'\nand all other characters are digits 0-9.", "vc-preamble": "predicate ValidPostalCode(A: int, B: int, S: string)\n    requires A >= 1 && B >= 1 && A <= 5 && B <= 5\n    requires |S| == A + B + 1\n    requires forall i :: 0 <= i < |S| ==> (S[i] == '-' || ('0' <= S[i] <= '9'))\n{\n    S[A] == '-' && forall i :: 0 <= i < |S| && i != A ==> S[i] != '-'\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, S: string) returns (result: string)\n    requires A >= 1 && B >= 1\n    requires A <= 5 && B <= 5\n    requires |S| == A + B + 1\n    requires forall i :: 0 <= i < |S| ==> (S[i] == '-' || ('0' <= S[i] <= '9'))\n    ensures result == \"Yes\" || result == \"No\"\n    ensures result == \"Yes\" <==> ValidPostalCode(A, B, S)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4554", "vc-description": "Given two rectangles with width W, where Rectangle 1 spans horizontally [a, a+W] \nand Rectangle 2 spans horizontally [b, b+W], find the minimum horizontal distance \nRectangle 2 must be moved so that the two rectangles connect (overlap or touch).", "vc-preamble": "predicate ValidInput(W: int, a: int, b: int)\n{\n    W >= 1 && a >= 1 && b >= 1\n}\n\nfunction AbsDiff(x: int, y: int): int\n{\n    if x >= y then x - y else y - x\n}\n\nfunction MinMoveDistance(W: int, a: int, b: int): int\n    requires ValidInput(W, a, b)\n{\n    var distance := AbsDiff(a, b);\n    if distance <= W then 0\n    else distance - W\n}\n\npredicate RectanglesConnect(W: int, a: int, b: int)\n    requires ValidInput(W, a, b)\n{\n    AbsDiff(a, b) <= W\n}", "vc-helpers": "", "vc-spec": "method solve(W: int, a: int, b: int) returns (result: int)\n    requires ValidInput(W, a, b)\n    ensures result == MinMoveDistance(W, a, b)\n    ensures result >= 0\n    ensures RectanglesConnect(W, a, b) <==> result == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4556", "vc-description": "Given a contest name in the format \"AtCoder s Contest\" where s is a string of length 1 to 100 characters \nstarting with an uppercase English letter followed by lowercase English letters, output the abbreviation \"AxC\" \nwhere x is the first character of s.\n\n// Minimum: \"AtCoder X Contest\\n\"\n\n// Input ends with newline\n\n// Middle word is non-empty\n\n// First char is uppercase\n\n// Rest are lowercase\n\n// \"AxC\\n\" format\n\n// Second char is first char of middle word", "vc-preamble": "predicate ValidInput(input: string)\n{\n    && |input| >= 18\n    && input[|input| - 1] == '\\n'\n    && input[0..7] == \"AtCoder\"\n    && input[7] == ' '\n    && exists spacePos :: 8 <= spacePos < |input| - 8 && input[spacePos] == ' ' && \n       input[spacePos + 1..spacePos + 8] == \"Contest\" &&\n       spacePos + 8 == |input| - 1\n    && exists spacePos :: 8 <= spacePos < |input| - 8 && input[spacePos] == ' ' && \n       spacePos > 8 &&\n       'A' <= input[8] <= 'Z' &&\n       (forall k :: 9 <= k < spacePos ==> 'a' <= input[k] <= 'z')\n}\n\npredicate ValidOutput(input: string, result: string)\n{\n    && |result| == 4\n    && result[0] == 'A'\n    && result[2] == 'C'\n    && result[3] == '\\n'\n    && exists spacePos :: 8 <= spacePos < |input| - 8 && input[spacePos] == ' ' && \n       result[1] == input[8]\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4557", "vc-description": "Given A animals that are definitely cats and B animals of unknown type (could be cats or dogs),\ndetermine if it's possible to have exactly X cats in total among the A + B animals.", "vc-preamble": "predicate ValidInput(a: int, b: int, x: int)\n{\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= x <= 200\n}\n\npredicate CanHaveExactlyCats(a: int, b: int, x: int)\n{\n    a <= x <= a + b\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, x: int) returns (result: string)\n    requires ValidInput(a, b, x)\n    ensures result == \"YES\" <==> CanHaveExactlyCats(a, b, x)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4560", "vc-description": "Given A 1-yen coins and unlimited 500-yen coins, determine if you can pay exactly N yen.\nReturn \"Yes\" if exact payment is possible, \"No\" otherwise.", "vc-preamble": "predicate ValidInput(n: int, a: int)\n{\n    1 <= n <= 10000 && 0 <= a <= 1000\n}\n\npredicate CanPayExactly(n: int, a: int)\n{\n    n % 500 <= a\n}\n\npredicate ValidOutput(result: string)\n{\n    result == \"Yes\" || result == \"No\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int) returns (result: string)\n    requires ValidInput(n, a)\n    ensures ValidOutput(result)\n    ensures result == \"Yes\" <==> CanPayExactly(n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4561", "vc-description": "Given three integers X, A, and B where X is the maximum number of days past \nbest-by date that won't cause stomachache, A is the number of days before \nbest-by date when food was bought, and B is the number of days after purchase \nwhen food was eaten. Determine if eating the food results in \"delicious\", \n\"safe\", or \"dangerous\" outcome.", "vc-preamble": "predicate ValidOutcome(outcome: string)\n{\n    outcome in {\"delicious\", \"safe\", \"dangerous\"}\n}\n\nfunction DaysPastBestBy(A: int, B: int): int\n{\n    B - A\n}\n\nfunction ExpectedOutcome(X: int, A: int, B: int): string\n{\n    var daysPast := DaysPastBestBy(A, B);\n    if daysPast <= 0 then \"delicious\"\n    else if daysPast <= X then \"safe\"  \n    else \"dangerous\"\n}", "vc-helpers": "", "vc-spec": "method DetermineFoodSafety(X: int, A: int, B: int) returns (outcome: string)\n    requires X >= 0\n    ensures outcome == ExpectedOutcome(X, A, B)\n    ensures ValidOutcome(outcome)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4567", "vc-description": "Given N questions with scores, find the maximum possible sum of a subset \nsuch that the sum is NOT a multiple of 10. If no such sum exists, return 0.", "vc-preamble": "predicate ValidInput(scores: seq<int>) {\n    |scores| > 0 && |scores| <= 100 &&\n    forall i :: 0 <= i < |scores| ==> 1 <= scores[i] <= 100\n}\n\nfunction sum(scores: seq<int>): int {\n    if |scores| == 0 then 0\n    else scores[0] + sum(scores[1..])\n}\n\npredicate AllMultiplesOf10(scores: seq<int>) {\n    forall i :: 0 <= i < |scores| ==> scores[i] % 10 == 0\n}\n\npredicate IsSmallestNonMultiple(scores: seq<int>, value: int) {\n    value in scores && \n    value % 10 != 0 &&\n    forall x :: x in scores && x % 10 != 0 ==> value <= x\n}\n\npredicate CorrectResult(scores: seq<int>, result: int) {\n    var totalSum := sum(scores);\n    if totalSum % 10 != 0 then\n        result == totalSum\n    else if AllMultiplesOf10(scores) then\n        result == 0\n    else\n        exists smallestNonMultiple :: \n            IsSmallestNonMultiple(scores, smallestNonMultiple) &&\n            result == totalSum - smallestNonMultiple\n}", "vc-helpers": "", "vc-spec": "method solve(scores: seq<int>) returns (result: int)\n    requires ValidInput(scores)\n    ensures CorrectResult(scores, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4569", "vc-description": "Given today's weather from a 3-day repeating cycle (Sunny \u2192 Cloudy \u2192 Rainy \u2192 Sunny \u2192 ...), determine tomorrow's weather.", "vc-preamble": "predicate ValidWeather(weather: string)\n{\n    weather == \"Sunny\" || weather == \"Cloudy\" || weather == \"Rainy\"\n}\n\nfunction TrimNewline(input: string): string\n{\n    if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input\n}\n\nfunction NextWeather(weather: string): string\n    requires ValidWeather(weather)\n{\n    if weather == \"Sunny\" then \"Cloudy\"\n    else if weather == \"Cloudy\" then \"Rainy\"\n    else \"Sunny\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    ensures var trimmed := TrimNewline(input);\n            if ValidWeather(trimmed) then \n                result == NextWeather(trimmed) + \"\\n\"\n            else \n                result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4570", "vc-description": "Given two parking fee plans:\n- Plan 1: A yen per hour (total: A\u00d7N yen for N hours)\n- Plan 2: B yen flat rate (regardless of duration)\nFind the minimum cost to park for N hours.\nInput: Three integers N, A, B where N is parking duration in hours (1 \u2264 N \u2264 20),\nA is hourly rate for Plan 1 (1 \u2264 A \u2264 100), and B is flat rate for Plan 2 (1 \u2264 B \u2264 2000).\nOutput: The minimum parking fee (integer)", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var parts := SplitStringFunc(input);\n    |parts| >= 3 && \n    (forall i :: 0 <= i < 3 ==> |parts[i]| > 0 && IsValidInteger(parts[i])) &&\n    var n := StringToIntFunc(parts[0]);\n    var a := StringToIntFunc(parts[1]);\n    var b := StringToIntFunc(parts[2]);\n    1 <= n <= 20 && 1 <= a <= 100 && 1 <= b <= 2000\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && \n    (s[0] == '-' || ('0' <= s[0] <= '9')) &&\n    forall i :: 1 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction SplitStringFunc(s: string): seq<string>\n{\n    SplitStringHelper(s, 0, 0, [])\n}\n\nfunction SplitStringHelper(s: string, i: int, start: int, acc: seq<string>): seq<string>\nrequires 0 <= i <= |s|\nrequires 0 <= start <= |s|\ndecreases |s| - i\n{\n    if i == |s| then\n        if i > start then acc + [s[start..i]] else acc\n    else if s[i] == ' ' || s[i] == '\\n' || s[i] == '\\r' then\n        var newAcc := if i > start then acc + [s[start..i]] else acc;\n        SplitStringHelper(s, i + 1, i + 1, newAcc)\n    else\n        SplitStringHelper(s, i + 1, start, acc)\n}\n\nfunction StringToIntFunc(s: string): int\nrequires |s| > 0\nrequires IsValidInteger(s)\n{\n    if |s| > 0 && s[0] == '-' then\n        -StringToIntHelper(s, 1, 0)\n    else\n        StringToIntHelper(s, 0, 0)\n}\n\nfunction StringToIntHelper(s: string, i: int, acc: int): int\nrequires 0 <= i <= |s|\ndecreases |s| - i\n{\n    if i == |s| then acc\n    else if '0' <= s[i] <= '9' then\n        StringToIntHelper(s, i + 1, acc * 10 + (s[i] as int - '0' as int))\n    else\n        StringToIntHelper(s, i + 1, acc)\n}\n\nfunction IntToStringFunc(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n, \"\")\n    else IntToStringHelper(n, \"\")\n}\n\nfunction IntToStringHelper(n: int, acc: string): string\nrequires n >= 0\ndecreases n\n{\n    if n == 0 then acc\n    else\n        var digit := n % 10;\n        IntToStringHelper(n / 10, [('0' as int + digit) as char] + acc)\n}\n\nfunction MinParkingCost(n: int, a: int, b: int): int\n{\n    var plan1Cost := n * a;\n    var plan2Cost := b;\n    if plan1Cost <= plan2Cost then plan1Cost else plan2Cost\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\nrequires |input| > 0\nrequires ValidInput(input)\nensures exists n, a, b :: \n    var parts := SplitStringFunc(input);\n    n == StringToIntFunc(parts[0]) &&\n    a == StringToIntFunc(parts[1]) && \n    b == StringToIntFunc(parts[2]) &&\n    result == IntToStringFunc(MinParkingCost(n, a, b)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4571", "vc-description": "Given N test cases where M are \"hard\" (1900ms each, 1/2 success probability) \nand (N-M) are \"easy\" (100ms each, always succeed), find the expected total \nexecution time across all submissions until one submission succeeds.", "vc-preamble": "predicate ValidInput(n: int, m: int) {\n  1 <= n <= 100 && 1 <= m <= n && m <= 5\n}\n\nfunction power(base: int, exp: int): int\n  requires exp >= 0\n  decreases exp\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\nfunction ExpectedTime(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  (1900 * m + 100 * (n - m)) * power(2, m)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures result == ExpectedTime(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4575", "vc-description": "Given N participants in a D-day training camp, where participant i eats chocolate on days 1, A_i+1, 2\u00d7A_i+1, 3\u00d7A_i+1, etc. \n(i.e., day 1 and then every A_i days thereafter). At the end of the camp, X chocolate pieces remain. \nFind the total number of chocolate pieces prepared initially.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := Split(input, '\\n');\n    |lines| >= 2 &&\n    ParseInt(lines[0]) >= 1 &&\n    var n := ParseInt(lines[0]);\n    var secondLineParts := Split(lines[1], ' ');\n    |secondLineParts| >= 2 &&\n    ParseInt(secondLineParts[0]) >= 1 &&\n    ParseInt(secondLineParts[1]) >= 0 &&\n    |lines| >= 2 + n &&\n    (forall i :: 0 <= i < n ==> ParseInt(lines[2 + i]) >= 1)\n}\n\nfunction ComputeExpectedResult(input: string): string\n    requires ValidInput(input)\n{\n    var lines := Split(input, '\\n');\n    var n := ParseInt(lines[0]);\n    var secondLineParts := Split(lines[1], ' ');\n    var d := ParseInt(secondLineParts[0]);\n    var x := ParseInt(secondLineParts[1]);\n    var totalEaten := SumEatenForParticipants(lines, d, n);\n    IntToString(x + totalEaten)\n}\n\nfunction SumEatenForParticipants(lines: seq<string>, d: int, count: int): int\n    requires |lines| >= 2 + count\n    requires d >= 1\n    requires count >= 0\n{\n    if count == 0 then 0\n    else\n        var a := ParseInt(lines[2 + count - 1]);\n        var eaten := if a > 0 then (d + a - 1) / a else 0;\n        eaten + SumEatenForParticipants(lines, d, count - 1)\n}\n\nfunction Split(s: string, delimiter: char): seq<string>\n{\n    if |s| == 0 then []\n    else SplitHelper(s, delimiter, 0, 0, [])\n}\n\nfunction SplitHelper(s: string, delimiter: char, start: int, current: int, acc: seq<string>): seq<string>\n    requires 0 <= start <= current <= |s|\n    decreases |s| - current\n{\n    if current == |s| then\n        if start == current then acc\n        else acc + [s[start..current]]\n    else if s[current] == delimiter then\n        SplitHelper(s, delimiter, current + 1, current + 1, acc + [s[start..current]])\n    else\n        SplitHelper(s, delimiter, start, current + 1, acc)\n}\n\nfunction ParseInt(s: string): int\n{\n    if |s| == 0 then 0\n    else ParseIntHelper(s, 0, 0)\n}\n\nfunction ParseIntHelper(s: string, index: int, acc: int): int\n    requires 0 <= index <= |s|\n    decreases |s| - index\n{\n    if index == |s| then acc\n    else if '0' <= s[index] <= '9' then\n        ParseIntHelper(s, index + 1, acc * 10 + (s[index] as int - '0' as int))\n    else\n        acc\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n > 0\n    decreases n\n{\n    if n < 10 then [(n + '0' as int) as char]\n    else IntToStringHelper(n / 10) + [(n % 10 + '0' as int) as char]\n}", "vc-helpers": "", "vc-spec": "method Solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result == ComputeExpectedResult(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4579", "vc-description": "Given N strings, count the number of distinct strings.\nInput: A sequence of strings (length >= 1)\nOutput: Integer representing the count of distinct strings", "vc-preamble": "function DistinctStrings(strings: seq<string>): set<string>\n{\n    set i | 0 <= i < |strings| :: strings[i]\n}\n\npredicate ValidInput(strings: seq<string>)\n{\n    |strings| >= 1\n}", "vc-helpers": "", "vc-spec": "method solve(strings: seq<string>) returns (count: int)\n    requires ValidInput(strings)\n    ensures count >= 1\n    ensures count <= |strings|\n    ensures count == |DistinctStrings(strings)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4581", "vc-description": "Calculate the price of a bowl of ramen based on selected toppings.\nBase price is 700 yen, each topping ('o') adds 100 yen.\nInput is a 3-character string with 'o' (included) or 'x' (not included).", "vc-preamble": "predicate ValidInput(s: string) {\n    |s| == 3 && forall i :: 0 <= i < |s| ==> s[i] == 'o' || s[i] == 'x'\n}\n\nfunction countO(s: string): int\n    ensures countO(s) >= 0\n    ensures countO(s) <= |s|\n{\n    if |s| == 0 then 0\n    else (if s[0] == 'o' then 1 else 0) + countO(s[1..])\n}\n\nfunction CalculatePrice(s: string): int\n    requires ValidInput(s)\n    ensures CalculatePrice(s) >= 700\n    ensures CalculatePrice(s) == countO(s) * 100 + 700\n{\n    countO(s) * 100 + 700\n}\n\nfunction IntToString(n: int) : string\n    requires n >= 0\n{\n    if n == 0 then \"0\"\n    else IntToStringHelper(n, \"\")\n}\n\nfunction IntToStringHelper(n: int, acc: string) : string\n    requires n >= 0\n    decreases n\n{\n    if n == 0 then acc\n    else IntToStringHelper(n / 10, [((n % 10) + 48) as char] + acc)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures result == IntToString(CalculatePrice(s)) + \"\\n\"\n    ensures CalculatePrice(s) >= 700", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4582", "vc-description": "Given two characters representing AtCoDeer's honesty status and claim about TopCoDeer,\ndetermine whether TopCoDeer is actually honest or dishonest.\nAn honest player tells the truth, a dishonest player lies.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 3 &&\n    input[1] == ' ' &&\n    input[0] in {'H', 'D'} &&\n    input[2] in {'H', 'D'} &&\n    (|input| == 3 || (|input| > 3 && input[3] == '\\n'))\n}\n\nfunction CorrectOutput(input: string): string\n    requires ValidInput(input)\n{\n    if (input[0] == 'H' && input[2] == 'H') || (input[0] == 'D' && input[2] == 'D')\n    then \"H\\n\"\n    else \"D\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == CorrectOutput(input)\n    ensures result == \"H\\n\" || result == \"D\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4583", "vc-description": "Given a 4-digit string ABCD, find operators op1, op2, op3 (each + or -) such that\nA op1 B op2 C op3 D = 7. Return the complete equation as \"A op1 B op2 C op3 D=7\".", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| == 5 && |input[..4]| == 4 && \n    (forall i :: 0 <= i < 4 ==> '0' <= input[i] <= '9') &&\n    input[4] == '\\n'\n}\n\nfunction CharToDigit(c: char): int\n    requires '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}\n\nfunction EvaluateExpression(a: int, b: int, c: int, d: int, op1: char, op2: char, op3: char): int\n    requires op1 in {'+', '-'} && op2 in {'+', '-'} && op3 in {'+', '-'}\n{\n    var b_val := if op1 == '+' then b else -b;\n    var c_val := if op2 == '+' then c else -c;\n    var d_val := if op3 == '+' then d else -d;\n    a + b_val + c_val + d_val\n}\n\npredicate SolutionExists(input: string)\n    requires ValidInput(input)\n{\n    var a := CharToDigit(input[0]);\n    var b := CharToDigit(input[1]);\n    var c := CharToDigit(input[2]);\n    var d := CharToDigit(input[3]);\n    exists op1, op2, op3 :: op1 in {'+', '-'} && op2 in {'+', '-'} && op3 in {'+', '-'} &&\n        EvaluateExpression(a, b, c, d, op1, op2, op3) == 7\n}\n\npredicate ValidOutput(result: string, input: string)\n    requires ValidInput(input)\n{\n    |result| == 10 && result[7..9] == \"=7\" && result[9] == '\\n' &&\n    result[0] == input[0] && result[2] == input[1] && \n    result[4] == input[2] && result[6] == input[3] &&\n    result[1] in {'+', '-'} && result[3] in {'+', '-'} && result[5] in {'+', '-'} &&\n    var a := CharToDigit(input[0]);\n    var b := CharToDigit(input[1]);\n    var c := CharToDigit(input[2]);\n    var d := CharToDigit(input[3]);\n    EvaluateExpression(a, b, c, d, result[1], result[3], result[5]) == 7\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    requires SolutionExists(input)\n    ensures ValidOutput(result, input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4584", "vc-description": "Given N company members with ID numbers 1 to N, where each member (except member 1) has exactly one immediate boss with a smaller ID number.\nFor member i (where i > 1), their immediate boss is member A_i. Count the number of immediate subordinates for each member.", "vc-preamble": "predicate ValidInput(n: int, aa: seq<int>)\n{\n    n >= 2 &&\n    |aa| == n - 1 &&\n    forall i :: 0 <= i < |aa| ==> 1 <= aa[i] < i + 2\n}\n\nfunction SubordinateCount(aa: seq<int>, boss_id: int): int\n{\n    |set j | 0 <= j < |aa| && aa[j] == boss_id|\n}\n\npredicate ValidOutput(n: int, aa: seq<int>, result: seq<int>)\n{\n    |result| == n &&\n    forall i :: 0 <= i < n ==> result[i] >= 0 &&\n    forall i :: 0 <= i < n ==> result[i] == SubordinateCount(aa, i + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, aa: seq<int>) returns (result: seq<int>)\n    requires ValidInput(n, aa)\n    ensures ValidOutput(n, aa, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4585", "vc-description": "Find the minimum time needed for a kangaroo to reach position X on a number line.\nThe kangaroo starts at position 0 at time 0. At each time step i (i = 1, 2, 3, ...),\nthe kangaroo can stay at current position or jump exactly i units left or right.", "vc-preamble": "predicate ValidInput(x: int)\n{\n  x >= 1\n}\n\nfunction TriangularNumber(n: int): int\n  requires n >= 0\n{\n  n * (n + 1) / 2\n}\n\npredicate IsMinimalTime(t: int, x: int)\n  requires x >= 1\n{\n  t >= 1 && \n  TriangularNumber(t) >= x &&\n  (t == 1 || TriangularNumber(t - 1) < x)\n}", "vc-helpers": "", "vc-spec": "method solve(x: int) returns (result: int)\n  requires ValidInput(x)\n  ensures IsMinimalTime(result, x)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4586", "vc-description": "Given a 4-digit integer N, determine if it is \"good\". \nA 4-digit integer is \"good\" if it contains three or more consecutive identical digits.", "vc-preamble": "predicate ValidInput(N: int) {\n  1000 <= N <= 9999\n}\n\nfunction ExtractDigits(N: int): (int, int, int, int)\n  requires ValidInput(N)\n{\n  var d1 := N / 1000;\n  var d2 := (N / 100) % 10;\n  var d3 := (N / 10) % 10;\n  var d4 := N % 10;\n  (d1, d2, d3, d4)\n}\n\npredicate IsGood(N: int)\n  requires ValidInput(N)\n{\n  var (d1, d2, d3, d4) := ExtractDigits(N);\n  (d1 == d2 && d2 == d3) || (d2 == d3 && d3 == d4)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: string)\n  requires ValidInput(N)\n  ensures result == \"Yes\" || result == \"No\"\n  ensures result == \"Yes\" <==> IsGood(N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4588", "vc-description": "Given two hexadecimal digits X and Y (each being one of A, B, C, D, E, or F representing values 10, 11, 12, 13, 14, 15 respectively), \ncompare their values and output the comparison result: \"<\" if X < Y, \">\" if X > Y, \"=\" if X = Y.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    (|input| == 3 && input[1] == ' ') || \n    (|input| == 4 && input[1] == ' ' && input[3] == '\\n')\n}\n\npredicate ValidHexDigit(c: char)\n{\n    c in {'A', 'B', 'C', 'D', 'E', 'F'}\n}\n\npredicate ValidInputFormat(input: string)\n{\n    |input| >= 3 &&\n    ValidInput(input) &&\n    ValidHexDigit(input[0]) &&\n    ValidHexDigit(input[2])\n}\n\npredicate CorrectComparison(x: char, y: char, result: string)\n{\n    result in {\"<\\n\", \">\\n\", \"=\\n\"} &&\n    ((x as int < y as int) <==> (result == \"<\\n\")) &&\n    ((x as int > y as int) <==> (result == \">\\n\")) &&\n    ((x as int == y as int) <==> (result == \"=\\n\"))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInputFormat(stdin_input)\n    ensures CorrectComparison(stdin_input[0], stdin_input[2], result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4594", "vc-description": "Given N mochi with diameters, find the maximum number of layers in a kagami mochi.\nA kagami mochi is a stack where each layer has a strictly smaller diameter than the layer below it.\nThis is equivalent to counting the number of distinct diameters in the input.", "vc-preamble": "predicate ValidInput(diameters: seq<int>)\n{\n    |diameters| > 0 && forall i :: 0 <= i < |diameters| ==> diameters[i] > 0\n}\n\nfunction num_distinct(s: seq<int>): int\n    ensures num_distinct(s) >= 0\n    ensures num_distinct(s) <= |s|\n    ensures |s| == 0 ==> num_distinct(s) == 0\n    ensures |s| > 0 ==> num_distinct(s) >= 1\n{\n    if |s| == 0 then 0\n    else if s[0] in s[1..] then num_distinct(s[1..])\n    else 1 + num_distinct(s[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(diameters: seq<int>) returns (result: int)\n    requires ValidInput(diameters)\n    ensures result == num_distinct(diameters)\n    ensures result >= 1\n    ensures result <= |diameters|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4602", "vc-description": "Given N balls at coordinates (x_i, i) for i = 1 to N, and 2N robots (N type-A at (0,i) and N type-B at (K,i)),\nfind the minimum total distance to collect all balls. Each robot can collect the ball on its corresponding line\nand return to its starting position. Type-A robot travels 2\u00d7x_i, Type-B robot travels 2\u00d7(K-x_i).", "vc-preamble": "predicate ValidInput(s: string) {\n    var lines := SplitByNewlines(s);\n    |lines| >= 3 &&\n    IsPositiveInteger(lines[0]) &&\n    IsPositiveInteger(lines[1]) &&\n    var n := StringToInt(lines[0]);\n    var k := StringToInt(lines[1]);\n    1 <= n <= 100 &&\n    1 <= k <= 100 &&\n    IsValidXArray(lines[2], n, k)\n}\n\npredicate ValidOutput(result: string) {\n    |result| >= 2 &&\n    result[|result|-1] == '\\n' &&\n    IsNonNegativeInteger(result[..|result|-1])\n}\n\npredicate CorrectSolution(input: string, output: string) {\n    ValidInput(input) && ValidOutput(output) ==>\n        var lines := SplitByNewlines(input);\n        var n := StringToInt(lines[0]);\n        var k := StringToInt(lines[1]);\n        var x := ParseIntArray(lines[2]);\n        |x| == n &&\n        (forall i :: 0 <= i < n ==> 0 < x[i] < k) &&\n        var expectedSum := ComputeMinDistance(x, k);\n        StringToInt(output[..|output|-1]) == expectedSum\n}\n\npredicate IsPositiveInteger(s: string) {\n    IsNonNegativeInteger(s) && |s| > 0 && (|s| > 1 || s[0] != '0') && StringToInt(s) > 0\n}\n\npredicate IsNonNegativeInteger(s: string) {\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate IsValidXArray(s: string, n: int, k: int) {\n    var x := ParseIntArray(s);\n    |x| == n && forall i :: 0 <= i < n ==> 0 < x[i] < k\n}\n\nfunction ComputeMinDistance(x: seq<int>, k: int): int\n    requires forall i :: 0 <= i < |x| ==> 0 < x[i] < k\n    ensures ComputeMinDistance(x, k) >= 0\n{\n    Sum(seq(|x|, i requires 0 <= i < |x| => 2 * Min(k - x[i], x[i])))\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires |s| > 0\n    requires ValidInput(s)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures ValidOutput(result)\n    ensures CorrectSolution(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4603", "vc-description": "Given costs of ordinary and unlimited tickets for train and bus travel,\nfind the minimum total fare by choosing the cheaper option for each mode.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int, D: int)\n{\n    1 <= A <= 1000 && 1 <= B <= 1000 && 1 <= C <= 1000 && 1 <= D <= 1000\n}\n\nfunction MinTotalFare(A: int, B: int, C: int, D: int): int\n{\n    (if A < B then A else B) + (if C < D then C else D)\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int, D: int) returns (result: int)\n    requires ValidInput(A, B, C, D)\n    ensures result == MinTotalFare(A, B, C, D)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4605", "vc-description": "Find the sum of all integers i where 1 \u2264 i \u2264 N and the sum of digits of i (in base 10) is between A and B inclusive.", "vc-preamble": "predicate ValidInput(N: int, A: int, B: int)\n{\n  N >= 1 && A >= 1 && A <= B && B <= 36\n}\n\nfunction digitSum(n: int): int\n  requires n >= 0\n{\n  if n == 0 then 0\n  else (n % 10) + digitSum(n / 10)\n}\n\nfunction sumInRange(N: int, A: int, B: int): int\n  requires N >= 0\n  requires A >= 1 && A <= B\n{\n  if N == 0 then 0\n  else if A <= digitSum(N) <= B then N + sumInRange(N-1, A, B)\n  else sumInRange(N-1, A, B)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, A: int, B: int) returns (result: int)\n  requires ValidInput(N, A, B)\n  ensures result == sumInRange(N, A, B)\n  ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4606", "vc-description": "Given an integer N where 100 \u2264 N \u2264 999, return the string \"ABC\" concatenated with the string representation of N.", "vc-preamble": "predicate ValidInput(n: int) {\n    100 <= n <= 999\n}\n\npredicate ValidOutput(n: int, result: string)\n    requires ValidInput(n)\n{\n    |result| == 6 && result[0..3] == \"ABC\" && result[3..] == IntToString(n)\n}\n\nfunction IntToString(n: int): string\n    requires n >= 0\n    ensures n == 0 ==> |IntToString(n)| == 1\n    ensures 1 <= n <= 9 ==> |IntToString(n)| == 1\n    ensures 10 <= n <= 99 ==> |IntToString(n)| == 2\n    ensures 100 <= n <= 999 ==> |IntToString(n)| == 3\n    decreases n\n{\n    if n == 0 then \"0\"\n    else if n < 10 then [('0' as int + n) as char]\n    else IntToString(n / 10) + [('0' as int + (n % 10)) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: string)\n    requires ValidInput(n)\n    ensures ValidOutput(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4607", "vc-description": "Count the number of \"Takahashi\" dates from 2018-1-1 through 2018-a-b (inclusive).\nA Takahashi date is one where the month and day numbers are equal (e.g., 1-1, 2-2, 3-3, etc.).", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    1 <= a <= 12 && 1 <= b <= 31\n}\n\nfunction TakahashiCount(a: int, b: int): int\n    requires ValidInput(a, b)\n{\n    if a > b then a - 1 else a\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result == TakahashiCount(a, b)\n    ensures a > b ==> result == a - 1\n    ensures a <= b ==> result == a", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_461", "vc-description": "Find the minimum distance Winnie-the-Pooh must travel to have n meals.\nWinnie starts at Rabbit's house and has his first meal there.\nThere are 3 houses: Rabbit, Owl, and Eeyore, forming a triangle.\nDistances: Rabbit\u2194Owl = a meters, Rabbit\u2194Eeyore = b meters, Owl\u2194Eeyore = c meters.\nAfter each meal, Winnie must leave the current house and go to one of the two adjacent houses.\nHe needs n meals total, so he makes (n-1) moves.\nFind the minimum total distance for all moves.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int, c: int)\n{\n  1 <= n <= 100 && 1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nfunction MinDistance(n: int, a: int, b: int, c: int): int\n  requires ValidInput(n, a, b, c)\n  ensures MinDistance(n, a, b, c) >= 0\n  ensures n == 1 ==> MinDistance(n, a, b, c) == 0\n{\n  if n == 1 then 0\n  else (n - 1) * min(a, b)\n}\n\nfunction min(x: int, y: int): int\n{\n  if x <= y then x else y\n}\n\nfunction max(x: int, y: int): int\n{\n  if x >= y then x else y\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, c: int) returns (result: int)\n  requires ValidInput(n, a, b, c)\n  ensures result >= 0\n  ensures n == 1 ==> result == 0\n  ensures result <= (n-1) * max(a, max(b, c))\n  ensures result == MinDistance(n, a, b, c)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4611", "vc-description": "Given N checkpoints with coordinates (x_i, y_i) and times t_i, determine if it's possible \nto visit each checkpoint at the specified time, starting from (0,0) at time 0. \nAt each time step, you must move to an adjacent cell (up, down, left, right) and cannot \nstay in the same position.", "vc-preamble": "datatype Checkpoint = Checkpoint(t: int, x: int, y: int)\n\npredicate ValidInputFormat(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| > 0 && IsValidInteger(lines[0]) && \n    (var n := ParseInt(lines[0]); \n     n >= 0 && n + 1 == |lines| &&\n     (forall i :: 1 <= i < |lines| ==> IsValidCheckpointLine(lines[i])))\n}\n\npredicate CanVisitAllCheckpoints(input: string)\n    requires ValidInputFormat(input)\n{\n    var lines := SplitLines(input);\n    var n := ParseInt(lines[0]);\n    if n == 0 then true\n    else\n        var checkpoints := ParseCheckpoints(lines[1..]);\n        |checkpoints| == n &&\n        CheckpointsFeasible(checkpoints, 0, 0, 0)\n}\n\npredicate CheckpointsFeasible(checkpoints: seq<Checkpoint>, currentT: int, currentX: int, currentY: int)\n{\n    if |checkpoints| == 0 then true\n    else\n        var cp := checkpoints[0];\n        var dt := cp.t - currentT;\n        var dx := if currentX >= cp.x then currentX - cp.x else cp.x - currentX;\n        var dy := if currentY >= cp.y then currentY - cp.y else cp.y - currentY;\n        var dis := dx + dy;\n        if dt < dis then false\n        else if (dt - dis) % 2 != 0 then false\n        else CheckpointsFeasible(checkpoints[1..], cp.t, cp.x, cp.y)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInputFormat(stdin_input)\n    ensures result == \"Yes\\n\" || result == \"No\\n\"\n    ensures result == \"Yes\\n\" <==> CanVisitAllCheckpoints(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4614", "vc-description": "Given three integers A, B, and C where exactly two are equal and one is different,\nfind the integer that is different from the other two.", "vc-preamble": "predicate containsThreeSpaceSeparatedIntegers(input: string)\n{\n    exists i, j, k :: (0 <= i < j < k <= |input| &&\n    isValidIntegerSubstring(input, 0, i) &&\n    input[i] == ' ' &&\n    isValidIntegerSubstring(input, i+1, j) &&\n    input[j] == ' ' &&\n    isValidIntegerSubstring(input, j+1, k) &&\n    (k == |input| || input[k] == '\\n'))\n}\n\npredicate exactlyTwoAreEqual(input: string)\n    requires containsThreeSpaceSeparatedIntegers(input)\n{\n    var nums := parseThreeNumbers(input);\n    (nums.0 == nums.1 && nums.0 != nums.2) ||\n    (nums.0 == nums.2 && nums.0 != nums.1) ||\n    (nums.1 == nums.2 && nums.1 != nums.0)\n}\n\npredicate isValidIntegerString(s: string)\n{\n    if |s| == 0 then false\n    else if s == \"0\" then true\n    else if |s| > 0 && s[0] == '-' then \n        |s| > 1 && isDigitSequence(s[1..]) && s[1] != '0'\n    else isDigitSequence(s) && s[0] != '0'\n}\n\npredicate isDigitSequence(s: string)\n{\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate isValidIntegerSubstring(s: string, start: int, end: int)\n    requires 0 <= start <= end <= |s|\n{\n    if start == end then false\n    else\n        var substr := s[start..end];\n        isValidIntegerString(substr)\n}\n\nfunction findDifferentNumber(input: string): string\n    requires containsThreeSpaceSeparatedIntegers(input)\n    requires exactlyTwoAreEqual(input)\n{\n    var nums := parseThreeNumbers(input);\n    var different := if nums.0 == nums.1 then nums.2\n                    else if nums.0 == nums.2 then nums.1\n                    else nums.0;\n    intToStringPure(different)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires containsThreeSpaceSeparatedIntegers(input)\n    requires exactlyTwoAreEqual(input)\n    ensures |result| > 0\n    ensures isValidIntegerString(result)\n    ensures result == findDifferentNumber(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4615", "vc-description": "Find the sugar water mixture with maximum density given constraints on water and sugar operations.\nOperations: add 100A or 100B grams water, add C or D grams sugar.\nE grams sugar can dissolve per 100 grams water. Beaker capacity is F grams.\nMaximize density = (100 \u00d7 sugar_mass) / (water_mass + sugar_mass).", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int, e: int, f: int)\n{\n    1 <= a < b <= 30 &&\n    1 <= c < d <= 30 &&\n    1 <= e <= 100 &&\n    100 * a <= f <= 3000\n}\n\npredicate ValidSolution(a: int, b: int, c: int, d: int, e: int, f: int, total_mass: int, sugar_mass: int)\n{\n    total_mass > 0 && sugar_mass >= 0 &&\n    total_mass <= f &&\n    sugar_mass <= total_mass\n}\n\nfunction Density(total_mass: int, sugar_mass: int): int\n    requires total_mass >= 0 && sugar_mass >= 0\n{\n    if total_mass > 0 then (100 * sugar_mass) / total_mass else 0\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int, e: int, f: int) returns (total_mass: int, sugar_mass: int)\n    requires ValidInput(a, b, c, d, e, f)\n    ensures ValidSolution(a, b, c, d, e, f, total_mass, sugar_mass)\n    ensures total_mass >= 0 && sugar_mass >= 0\n    ensures total_mass <= f\n    ensures sugar_mass <= total_mass\n    ensures exists water_units :: water_units > 0 && total_mass == water_units * 100 + sugar_mass\n    ensures exists water_units :: water_units > 0 && sugar_mass <= water_units * e\n    ensures exists i1, j1, i2, j2 :: \n        i1 >= 0 && j1 >= 0 && i2 >= 0 && j2 >= 0 &&\n        i1 <= 30 / a && j1 <= 30 / b &&\n        i2 <= 3000 / c && j2 <= 3000 / d &&\n        total_mass == (a * i1 + b * j1) * 100 + (c * i2 + d * j2) &&\n        sugar_mass == c * i2 + d * j2 &&\n        a * i1 + b * j1 > 0\n    ensures total_mass > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4616", "vc-description": "Given a string of at least 3 lowercase English letters, create an abbreviation by replacing\nthe middle characters with their count. Format: first_character + count_of_middle_characters + last_character.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 3 && |s| <= 100 && forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\npredicate ValidAbbreviation(s: string, result: string)\n{\n    |result| >= 3 &&\n    |s| >= 3 &&\n    result[0] == s[0] &&\n    result[|result|-1] == s[|s|-1] &&\n    result == [s[0]] + IntToString(|s| - 2) + [s[|s|-1]]\n}\n\nfunction IntToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n < 0 then \"-\" + IntToStringHelper(-n)\n    else IntToStringHelper(n)\n}\n\nfunction IntToStringHelper(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"\"\n    else IntToStringHelper(n / 10) + [(('0' as int) + (n % 10)) as char]\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures ValidAbbreviation(s, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4617", "vc-description": "Given a 2\u00d73 grid of lowercase English letters, determine if the grid remains identical after a 180-degree rotation.\nInput consists of two lines, each containing 3 characters.\nOutput \"YES\" if unchanged after rotation, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(lines: seq<string>)\n{\n    |lines| >= 2 && |lines[0]| > 0 && |lines[1]| > 0\n}\n\npredicate IsSymmetric(first_row: string, second_row: string)\n{\n    reverse(first_row) == second_row\n}\n\nfunction split_lines(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else if s[0] == '\\n' then [\"\"] + split_lines(s[1..])\n    else \n        var rest := split_lines(s[1..]);\n        if |rest| == 0 then [[s[0]]]\n        else [rest[0] + [s[0]]] + rest[1..]\n}\n\nfunction reverse(s: string): string\n{\n    if |s| == 0 then \"\"\n    else reverse(s[1..]) + [s[0]]\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures var normalized_input := stdin_input + if stdin_input[|stdin_input|-1] == '\\n' then \"\" else \"\\n\";\n            var lines := split_lines(normalized_input);\n            ValidInput(lines) ==> (result == \"YES\\n\" <==> IsSymmetric(lines[0], lines[1]))\n    ensures var normalized_input := stdin_input + if stdin_input[|stdin_input|-1] == '\\n' then \"\" else \"\\n\";\n            var lines := split_lines(normalized_input);\n            !ValidInput(lines) ==> result == \"NO\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_462", "vc-description": "Given three distinct integers representing positions of three friends on a number line,\nfind the minimum total distance they need to travel to meet at a single point.", "vc-preamble": "predicate ValidInput(x1: int, x2: int, x3: int) {\n    1 <= x1 <= 100 && 1 <= x2 <= 100 && 1 <= x3 <= 100 &&\n    x1 != x2 && x1 != x3 && x2 != x3\n}\n\nfunction MinTotalDistance(x1: int, x2: int, x3: int): int\n    requires ValidInput(x1, x2, x3)\n{\n    var max_pos := if x1 >= x2 && x1 >= x3 then x1\n                  else if x2 >= x1 && x2 >= x3 then x2\n                  else x3;\n    var min_pos := if x1 <= x2 && x1 <= x3 then x1\n                  else if x2 <= x1 && x2 <= x3 then x2\n                  else x3;\n    max_pos - min_pos\n}", "vc-helpers": "", "vc-spec": "method FindMinimumTotalDistance(x1: int, x2: int, x3: int) returns (result: int)\n    requires ValidInput(x1, x2, x3)\n    ensures result == MinTotalDistance(x1, x2, x3)\n    ensures result >= 1 && result <= 99", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4635", "vc-description": "Given two integers n and k, construct a string of length n using only the first k letters \nof the alphabet ('a', 'b', ..., k-th letter). Each of the k letters must appear at least once.\nMaximize the minimum frequency among all letters used. The optimal strategy is to distribute\ncharacters as evenly as possible by cycling through the k letters repeatedly.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    (exists lines :: lines == SplitByNewline(input) && \n     |lines| >= 1 && \n     IsValidInteger(lines[0]) &&\n     StringToIntVal(lines[0]) >= 0 &&\n     |lines| >= StringToIntVal(lines[0]) + 1 &&\n     (forall i :: 1 <= i <= StringToIntVal(lines[0]) && i < |lines| ==> ValidTestCaseLine(lines[i])))\n}\n\npredicate ValidTestCaseLine(line: string)\n{\n    exists parts :: (parts == SplitBySpace(line) &&\n                    |parts| >= 2 &&\n                    IsValidInteger(parts[0]) &&\n                    IsValidInteger(parts[1]) &&\n                    StringToIntVal(parts[0]) > 0 &&\n                    StringToIntVal(parts[1]) > 0 &&\n                    StringToIntVal(parts[1]) <= 26)\n}\n\npredicate IsValidInteger(s: string)\n{\n    |s| > 0 && \n    (|s| == 1 || s[0] != '0' || s == \"0\") &&\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction StringToIntVal(s: string): int\n    requires IsValidInteger(s)\n    ensures StringToIntVal(s) >= 0\n{\n    if |s| == 0 then 0 else\n    if |s| == 1 then (s[0] as int) - 48 else\n    StringToIntVal(s[0..|s|-1]) * 10 + ((s[|s|-1] as int) - 48)\n}\n\npredicate CyclicPatternCorrect(n: int, k: int, output: string)\n    requires n > 0 && k > 0 && k <= 26\n{\n    |output| == n &&\n    (forall j :: 0 <= j < n ==> output[j] == ((j % k) + 97) as char)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures |result| >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4659", "vc-description": "Generate the first numRows rows of Pascal's triangle, where each number is the sum\nof the two numbers directly above it in the previous row.", "vc-preamble": "predicate ValidPascalTriangle(triangle: seq<seq<int>>, numRows: int)\n{\n  |triangle| == numRows &&\n  (numRows == 0 ==> triangle == []) &&\n  (numRows > 0 ==> (\n    forall i :: 0 <= i < |triangle| ==> |triangle[i]| == i + 1\n  )) &&\n  (numRows > 0 ==> (\n    forall i :: 0 <= i < |triangle| ==> triangle[i][0] == 1 && triangle[i][|triangle[i]| - 1] == 1\n  )) &&\n  (numRows > 1 ==> (\n    forall i :: 1 <= i < |triangle| ==> \n      forall j :: 1 <= j < |triangle[i]| - 1 ==> \n        triangle[i][j] == triangle[i-1][j-1] + triangle[i-1][j]\n  ))\n}", "vc-helpers": "", "vc-spec": "method generate(numRows: int) returns (result: seq<seq<int>>)\n  requires numRows >= 0\n  ensures ValidPascalTriangle(result, numRows)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4676", "vc-description": "Given two strings O and E representing characters at odd-numbered and even-numbered positions\nof a password respectively, restore the original password by interleaving the characters.\nInput format: O on first line, E on second line, separated by newline.\nOutput: interleaved password where characters alternate between O and E.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := split(input, '\\n');\n    |lines| >= 2 &&\n    var O := lines[0];\n    var E := lines[1];\n    var a := |O|;\n    var b := |E|;\n    (a == b || a == b + 1) &&\n    (a > 0 || b == 0)\n}\n\nfunction GetO(input: string): string\n    requires ValidInput(input)\n{\n    split(input, '\\n')[0]\n}\n\nfunction GetE(input: string): string\n    requires ValidInput(input)\n{\n    split(input, '\\n')[1]\n}\n\nfunction CorrectResult(input: string): string\n    requires ValidInput(input)\n{\n    var O := GetO(input);\n    var E := GetE(input);\n    var a := |O|;\n    var b := |E|;\n    if a == b then\n        InterleaveEqual(O, E)\n    else\n        InterleaveUnequal(O, E)\n}\n\nfunction InterleaveEqual(O: string, E: string): string\n    requires |O| == |E|\n{\n    if |O| == 0 then \"\"\n    else [O[0], E[0]] + InterleaveEqual(O[1..], E[1..])\n}\n\nfunction InterleaveUnequal(O: string, E: string): string\n    requires |O| == |E| + 1\n{\n    if |E| == 0 then O\n    else [O[0], E[0]] + InterleaveUnequal(O[1..], E[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == CorrectResult(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4677", "vc-description": "Simulate a 3-key text editor that processes keystrokes: '0' and '1' append characters,\n'B' deletes the rightmost character if the string is non-empty.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 1 && |s| <= 10 && forall i :: 0 <= i < |s| ==> s[i] in {'0', '1', 'B'}\n}\n\nfunction SimulateKeystrokes(keystrokes: string): string\n{\n    if |keystrokes| == 0 then \"\"\n    else \n        var prev := SimulateKeystrokes(keystrokes[..|keystrokes|-1]);\n        var lastKey := keystrokes[|keystrokes|-1];\n        if lastKey == 'B' then\n            if |prev| > 0 then prev[..|prev|-1] else prev\n        else\n            prev + [lastKey]\n}\n\npredicate ValidOutput(result: string)\n{\n    forall i :: 0 <= i < |result| ==> result[i] in {'0', '1'}\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures ValidOutput(result)\n    ensures result == SimulateKeystrokes(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4679", "vc-description": "Three players (Alice, Bob, Charlie) play a card game with decks of cards labeled 'a', 'b', or 'c'.\nAlice starts first. On each turn, if current player's deck is empty, they win the game.\nOtherwise, discard the top card; the letter determines next player ('a'\u2192Alice, 'b'\u2192Bob, 'c'\u2192Charlie).\nGiven initial decks as strings, determine the winner.", "vc-preamble": "predicate ValidDeck(deck: string)\n{\n    forall i :: 0 <= i < |deck| ==> deck[i] == 'a' || deck[i] == 'b' || deck[i] == 'c'\n}\n\npredicate ValidInput(A: string, B: string, C: string)\n{\n    ValidDeck(A) && ValidDeck(B) && ValidDeck(C)\n}\n\npredicate ValidWinner(winner: char)\n{\n    winner == 'A' || winner == 'B' || winner == 'C'\n}", "vc-helpers": "", "vc-spec": "method solve(A: string, B: string, C: string) returns (result: char)\n    requires ValidInput(A, B, C)\n    ensures ValidWinner(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4680", "vc-description": "Given three integers A, B, and C representing syllable counts of three phrases,\ndetermine if these phrases can be arranged to form a Haiku. A Haiku requires\nexactly two phrases with 5 syllables and one phrase with 7 syllables.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int)\n{\n    1 <= A <= 10 && 1 <= B <= 10 && 1 <= C <= 10\n}\n\npredicate CanFormHaiku(A: int, B: int, C: int)\n{\n    (A == 5 && B == 5 && C == 7) ||\n    (A == 5 && B == 7 && C == 5) ||\n    (A == 7 && B == 5 && C == 5)\n}\n\npredicate ValidOutput(result: string)\n{\n    result in {\"YES\", \"NO\"}\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int) returns (result: string)\n    requires ValidInput(A, B, C)\n    ensures ValidOutput(result)\n    ensures result == \"YES\" <==> CanFormHaiku(A, B, C)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4681", "vc-description": "Compute the N-th Lucas number where the Lucas sequence is defined as:\nL\u2080 = 2, L\u2081 = 1, and L\u1d62 = L\u1d62\u208b\u2081 + L\u1d62\u208b\u2082 for i \u2265 2", "vc-preamble": "function Lucas(n: int): int\n    requires n >= 0\n{\n    if n == 0 then 2\n    else if n == 1 then 1\n    else Lucas(n-1) + Lucas(n-2)\n}\n\npredicate ValidInput(n: int) {\n    1 <= n <= 86\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == Lucas(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4688", "vc-description": "Given N balls in a row and K available colors, count the number of ways to paint \nthe balls such that no two adjacent balls have the same color. The solution is\nbased on the combinatorial formula: first ball has K choices, each subsequent \nball has (K-1) choices, giving K * (K-1)^(N-1) total ways.", "vc-preamble": "function Power(base: int, exp: int): int\n  requires exp >= 0\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\npredicate ValidInput(n: int, k: int)\n{\n  1 <= n <= 1000 && 2 <= k <= 1000\n}\n\nfunction PaintingWays(n: int, k: int): int\n  requires ValidInput(n, k)\n{\n  k * Power(k - 1, n - 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n  requires ValidInput(n, k)\n  ensures result == PaintingWays(n, k)\n  ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4690", "vc-description": "Given dimensions of two rectangles (A\u00d7B and C\u00d7D), return the area of the rectangle with the larger area.\nIf both rectangles have equal areas, return that common area.", "vc-preamble": "predicate ValidInput(A: int, B: int, C: int, D: int)\n{\n    1 <= A <= 10000 && 1 <= B <= 10000 && 1 <= C <= 10000 && 1 <= D <= 10000\n}\n\nfunction MaxArea(A: int, B: int, C: int, D: int): int\n{\n    if A * B >= C * D then A * B else C * D\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int, C: int, D: int) returns (result: int)\n    requires ValidInput(A, B, C, D)\n    ensures result == MaxArea(A, B, C, D)\n    ensures result >= A * B && result >= C * D\n    ensures result == A * B || result == C * D", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4692", "vc-description": "Calculate how many hours remain from M o'clock (24-hour format) on December 30th \nuntil New Year (0 o'clock on January 1st). M is an integer between 1 and 23 inclusive.", "vc-preamble": "predicate ValidInput(M: int)\n{\n    1 <= M <= 23\n}\n\nfunction HoursUntilNewYear(M: int): int\n    requires ValidInput(M)\n{\n    48 - M\n}\n\npredicate ValidOutput(M: int, result: int)\n    requires ValidInput(M)\n{\n    result == HoursUntilNewYear(M) && 25 <= result <= 47\n}", "vc-helpers": "", "vc-spec": "method solve(M: int) returns (result: int)\n    requires ValidInput(M)\n    ensures ValidOutput(M, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4695", "vc-description": "Given integers x and y where 1 \u2264 x < y \u2264 12, determine if they belong to the same group \naccording to Snuke's division of integers 1 through 12 into three groups based on some criterion.\nInput: Two space-separated integers x and y\nOutput: \"Yes\" if x and y are in the same group, \"No\" otherwise", "vc-preamble": "predicate ValidInput(input: string)\n    requires |input| > 0\n{\n    var parts := SplitStringPure(input);\n    |parts| >= 2 && IsValidInt(parts[0]) && IsValidInt(parts[1])\n}\n\npredicate SameGroup(a: int, b: int)\n{\n    var n1 := [1, 3, 5, 7, 8, 10, 12];\n    var n2 := [4, 6, 9, 11];\n    (a in n1 && b in n1) || (a in n2 && b in n2) || (a == 2 && b == 2)\n}\n\npredicate CorrectOutput(input: string, result: string)\n    requires |input| > 0\n{\n    if ValidInput(input) then\n        var parts := SplitStringPure(input);\n        var a := StringToIntPure(parts[0]);\n        var b := StringToIntPure(parts[1]);\n        (result == \"Yes\\n\" <==> SameGroup(a, b)) && (result == \"No\\n\" <==> !SameGroup(a, b))\n    else\n        result == \"\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"Yes\\n\" || result == \"No\\n\" || result == \"\"\n    ensures CorrectOutput(input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4697", "vc-description": "Given N S-shaped pieces and M c-shaped pieces, find the maximum number of \"Scc groups\"\nthat can be formed. Each Scc group requires exactly 1 S-shaped piece and 2 c-shaped pieces.\nAdditionally, 2 c-shaped pieces can be combined to create 1 S-shaped piece.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n    n >= 0 && m >= 0\n}\n\nfunction MaxSccGroups(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n    var directGroups := if n < m / 2 then n else m / 2;\n    var remainingCPieces := m - directGroups * 2;\n    var additionalGroups := remainingCPieces / 4;\n    directGroups + additionalGroups\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures result >= 0\n  ensures result == MaxSccGroups(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_470", "vc-description": "Given 5 cards with positive integers, find the minimum sum of remaining cards \nafter optionally discarding exactly 2 or 3 cards that have the same number \n(at most one such discard operation allowed).", "vc-preamble": "predicate ValidInput(cards: seq<int>)\n{\n    |cards| == 5 && forall i :: 0 <= i < |cards| ==> cards[i] > 0\n}\n\nfunction minPossibleSum(cards: seq<int>): int\n    requires ValidInput(cards)\n    ensures minPossibleSum(cards) >= 0\n    ensures minPossibleSum(cards) <= sum(cards)\n{\n    minPossibleSumUpToIndex(cards, 5)\n}", "vc-helpers": "", "vc-spec": "method solve(cards: seq<int>) returns (result: int)\n    requires ValidInput(cards)\n    ensures result >= 0\n    ensures result <= sum(cards)\n    ensures result == minPossibleSum(cards)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4701", "vc-description": "Start with value 1 and perform exactly N operations. Each operation is either:\nOperation A: multiply current value by 2, or Operation B: add K to current value.\nFind the minimum possible final value after N operations.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k >= 1\n}\n\nfunction ApplyOperations(start: int, operations: seq<bool>, k: int): int\n    requires k >= 1\n    requires start >= 1\n    ensures ApplyOperations(start, operations, k) >= start\n    decreases |operations|\n{\n    if |operations| == 0 then start\n    else if operations[0] then ApplyOperations(start * 2, operations[1..], k)\n    else ApplyOperations(start + k, operations[1..], k)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures result >= 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4702", "vc-description": "Given an integer x where 0 \u2264 x \u2264 1 represented as a string, output the logical NOT of x.\nIf x = 0, output 1. If x = 1, output 0.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    (input[0] == '0' || input[0] == '1') && \n    (|input| == 1 || (|input| > 1 && input[1] == '\\n'))\n}\n\nfunction LogicalNot(digit: char): string\n    requires digit == '0' || digit == '1'\n{\n    if digit == '0' then \"1\\n\" else \"0\\n\"\n}\n\npredicate CorrectOutput(input: string, output: string)\n    requires ValidInput(input)\n{\n    output == LogicalNot(input[0])\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires ValidInput(input)\n    ensures CorrectOutput(input, output)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4705", "vc-description": "Calculate the net amount paid by a customer for N meals at a restaurant.\nEach meal costs 800 yen. For every 15 meals ordered, the customer receives\n200 yen cashback. Return the net amount (total cost minus cashback).", "vc-preamble": "predicate ValidInput(N: int)\n{\n    1 <= N <= 100\n}\n\nfunction TotalCost(N: int): int\n    requires ValidInput(N)\n{\n    800 * N\n}\n\nfunction Cashback(N: int): int\n    requires ValidInput(N)\n{\n    (N / 15) * 200\n}\n\nfunction NetAmount(N: int): int\n    requires ValidInput(N)\n{\n    TotalCost(N) - Cashback(N)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int) returns (result: int)\n    requires ValidInput(N)\n    ensures result == NetAmount(N)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4706", "vc-description": "Given a 3\u00d73 grid of lowercase English letters, extract and concatenate \nthe characters on the main diagonal (from top-left to bottom-right) \nto form a string of length 3.", "vc-preamble": "predicate ValidInput(lines: seq<string>)\n{\n    |lines| == 3 && forall i :: 0 <= i < 3 ==> |lines[i]| == 3\n}\n\nfunction ExtractDiagonal(lines: seq<string>): string\n    requires ValidInput(lines)\n{\n    [lines[0][0], lines[1][1], lines[2][2]]\n}", "vc-helpers": "", "vc-spec": "method solve(lines: seq<string>) returns (result: string)\n    requires ValidInput(lines)\n    ensures |result| == 4\n    ensures result[0] == lines[0][0]\n    ensures result[1] == lines[1][1] \n    ensures result[2] == lines[2][2]\n    ensures result[3] == '\\n'\n    ensures result == ExtractDiagonal(lines) + ['\\n']", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4708", "vc-description": "Calculate the total cost for N nights of accommodation with tiered pricing.\nFirst K nights cost X yen each, remaining nights (if any) cost Y yen each.\nInput: Four integers N, K, X, Y on separate lines.\nOutput: Single integer representing the total cost.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitString(input, '\\n');\n    |lines| >= 4 &&\n    IsValidInteger(lines[0]) &&\n    IsValidInteger(lines[1]) &&\n    IsValidInteger(lines[2]) &&\n    IsValidInteger(lines[3]) &&\n    var N := StringToInt(lines[0]);\n    var K := StringToInt(lines[1]);\n    var X := StringToInt(lines[2]);\n    var Y := StringToInt(lines[3]);\n    1 <= N <= 10000 && 1 <= K <= 10000 && 1 <= Y < X <= 10000\n}\n\npredicate ValidOutput(output: string, input: string)\n{\n    var lines := SplitString(input, '\\n');\n    if |lines| >= 4 && \n       IsValidInteger(lines[0]) &&\n       IsValidInteger(lines[1]) &&\n       IsValidInteger(lines[2]) &&\n       IsValidInteger(lines[3]) then\n        var N := StringToInt(lines[0]);\n        var K := StringToInt(lines[1]);\n        var X := StringToInt(lines[2]);\n        var Y := StringToInt(lines[3]);\n        var expectedAns := if K < N then K * X + (N - K) * Y else N * X;\n        output == IntToString(expectedAns) + \"\\n\"\n    else\n        output == \"\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures ValidOutput(output, input)\n    ensures ValidInput(input) ==> \n        var lines := SplitString(input, '\\n');\n        var N := StringToInt(lines[0]);\n        var K := StringToInt(lines[1]);\n        var X := StringToInt(lines[2]);\n        var Y := StringToInt(lines[3]);\n        1 <= N <= 10000 && 1 <= K <= 10000 && 1 <= Y < X <= 10000 ==>\n        var expectedAns := if K < N then K * X + (N - K) * Y else N * X;\n        output == IntToString(expectedAns) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4710", "vc-description": "Given an integer rating x, classify it as \"ABC\" if x < 1200, otherwise \"ARC\".\nThe input must be between 1 and 3000 inclusive.", "vc-preamble": "predicate ValidInput(x: int) {\n    1 <= x <= 3000\n}\n\npredicate CorrectOutput(x: int, result: string) {\n    (x < 1200 ==> result == \"ABC\\n\") &&\n    (x >= 1200 ==> result == \"ARC\\n\")\n}", "vc-helpers": "", "vc-spec": "method solve(x: int) returns (result: string)\n    requires ValidInput(x)\n    ensures CorrectOutput(x, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4711", "vc-description": "Given three bell prices a, b, and c (in yen), find the minimum cost to purchase exactly two bells of different types.\nConstraints: 1 \u2264 a, b, c \u2264 10000 (integers)", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int) {\n    1 <= a <= 10000 && 1 <= b <= 10000 && 1 <= c <= 10000\n}\n\nfunction MinOfThree(x: int, y: int, z: int): int {\n    if x <= y && x <= z then x\n    else if y <= z then y\n    else z\n}\n\nfunction CorrectResult(a: int, b: int, c: int): int {\n    MinOfThree(a + b, a + c, b + c)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int) returns (result: int)\n    requires ValidInput(a, b, c)\n    ensures result == CorrectResult(a, b, c)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4713", "vc-description": "Given a string S of length N containing only characters 'I' and 'D', simulate the following process:\nStart with x = 0. For each character in S from left to right:\nIf the character is 'I', increment x by 1. If the character is 'D', decrement x by 1.\nFind the maximum value that x reaches during this entire process (including the initial value 0).", "vc-preamble": "function MaxValue(S: string): int\n{\n    MaxValueUpToIndex(S, |S|)\n}\n\nfunction MaxValueUpToIndex(S: string, upTo: int): int\n    requires 0 <= upTo <= |S|\n{\n    if upTo == 0 then 0\n    else \n        var currentValue := CurrentValueAtIndex(S, upTo);\n        var maxBefore := MaxValueUpToIndex(S, upTo - 1);\n        if currentValue > maxBefore then currentValue else maxBefore\n}\n\nfunction CurrentValueAtIndex(S: string, index: int): int\n    requires 0 <= index <= |S|\n{\n    if index == 0 then 0\n    else CurrentValueAtIndex(S, index - 1) + (if S[index - 1] == 'I' then 1 else -1)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, S: string) returns (result: int)\n    requires 1 <= N <= 100\n    requires N == |S|\n    requires forall i :: 0 <= i < |S| ==> S[i] == 'I' || S[i] == 'D'\n    ensures result >= 0\n    ensures result == MaxValue(S)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4714", "vc-description": "Count the number of palindromic numbers in the range [A, B] inclusive.\nA palindromic number is a positive integer that reads the same forwards and backwards when written in decimal notation.\nConstraints: 10000 \u2264 A \u2264 B \u2264 99999", "vc-preamble": "predicate isPalindromic(n: int)\n  requires n >= 0\n{\n  var s := intToString(n);\n  forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - 1 - i]\n}\n\nfunction countPalindromicNumbers(a: int, b: int): int\n  requires 10000 <= a <= b <= 99999\n  ensures countPalindromicNumbers(a, b) >= 0\n  ensures countPalindromicNumbers(a, b) <= b - a + 1\n  decreases b - a + 1\n{\n  if a > b then 0\n  else if a == b then (if isPalindromic(a) then 1 else 0)\n  else (if isPalindromic(a) then 1 else 0) + countPalindromicNumbers(a + 1, b)\n}\n\npredicate isValidInteger(s: string)\n{\n  |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\npredicate ValidInput(stdin_input: string)\n{\n  |stdin_input| > 0 &&\n  exists i :: 0 <= i < |stdin_input| && stdin_input[i] == ' ' &&\n  var parts := splitOnSpace(stdin_input);\n  |parts| == 2 && \n  isValidInteger(parts[0]) && \n  isValidInteger(parts[1]) &&\n  stringToInt(parts[0]) >= 10000 &&\n  stringToInt(parts[1]) >= 10000 &&\n  stringToInt(parts[0]) <= 99999 &&\n  stringToInt(parts[1]) <= 99999 &&\n  stringToInt(parts[0]) <= stringToInt(parts[1])\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires ValidInput(stdin_input)\n  ensures |result| > 0\n  ensures result[|result|-1] == '\\n'\n  ensures var parts := splitOnSpace(stdin_input);\n          var a := stringToInt(parts[0]);\n          var b := stringToInt(parts[1]);\n          result == intToString(countPalindromicNumbers(a, b)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4715", "vc-description": "Given three integers representing colors, count the number of distinct colors.\nInput constraints: 1 \u2264 a,b,c \u2264 100\nOutput: number of different kinds of colors (1, 2, or 3)", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\nfunction CountDistinctColors(a: int, b: int, c: int): int\n{\n    if a == b && b == c then 1\n    else if a == b || b == c || a == c then 2\n    else 3\n}\n\npredicate AllSame(a: int, b: int, c: int)\n{\n    a == b && b == c\n}\n\npredicate ExactlyTwoSame(a: int, b: int, c: int)\n{\n    (a == b && b != c) || (b == c && a != b) || (a == c && a != b)\n}\n\npredicate AllDifferent(a: int, b: int, c: int)\n{\n    a != b && b != c && a != c\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int) returns (result: int)\n    requires ValidInput(a, b, c)\n    ensures 1 <= result <= 3\n    ensures result == CountDistinctColors(a, b, c)\n    ensures result == 1 <==> AllSame(a, b, c)\n    ensures result == 2 <==> ExactlyTwoSame(a, b, c)\n    ensures result == 3 <==> AllDifferent(a, b, c)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4717", "vc-description": "Given three distinct positions x, a, and b on a number line, determine whether position a or position b \nis closer to position x. Output \"A\" if position a is closer, \"B\" if position b is closer.\nDistance between two positions s and t is |s-t|.", "vc-preamble": "predicate ValidInput(x: int, a: int, b: int)\n{\n    1 <= x <= 1000 &&\n    1 <= a <= 1000 &&\n    1 <= b <= 1000 &&\n    x != a && x != b && a != b &&\n    Distance(x, a) != Distance(x, b)\n}\n\nfunction Distance(s: int, t: int): nat\n{\n    if s >= t then s - t else t - s\n}\n\npredicate CorrectResult(x: int, a: int, b: int, result: string)\n{\n    (result == \"A\" <==> Distance(x, a) < Distance(x, b)) &&\n    (result == \"B\" <==> Distance(x, b) < Distance(x, a))\n}", "vc-helpers": "", "vc-spec": "method solve(x: int, a: int, b: int) returns (result: string)\nrequires ValidInput(x, a, b)\nensures result == \"A\" || result == \"B\"\nensures CorrectResult(x, a, b, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4718", "vc-description": "Given a date string in format \"2017/01/dd\" where dd represents a day from 01 to 31,\nreplace the year \"2017\" with \"2018\" and output the corrected date string.", "vc-preamble": "predicate ValidInput(dateStr: string) \n{\n    |dateStr| == 10 && dateStr[0..4] == \"2017\"\n}\n\npredicate ValidOutput(input: string, output: string)\n    requires |input| >= 4\n{\n    output == \"2018\" + input[4..] &&\n    |output| == 10 &&\n    output[0..4] == \"2018\" &&\n    output[4..] == input[4..]\n}", "vc-helpers": "", "vc-spec": "method solve(dateStr: string) returns (result: string)\n    requires ValidInput(dateStr)\n    ensures ValidOutput(dateStr, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_472", "vc-description": "Given a positive integer n, find the smallest positive integer x such that\nx\u00b2 + s(x)\u00b7x - n = 0, where s(x) is the sum of digits of x in decimal notation.\nIf no such positive integer x exists, return -1.", "vc-preamble": "function digitSum(n: int): int\n  requires n >= 0\n  decreases n\n{\n  if n == 0 then 0\n  else (n % 10) + digitSum(n / 10)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n  requires n >= 1\n  ensures n == 1 ==> result == -1\n  ensures n > 1 && result > 0 ==> result * result + digitSum(result) * result == n\n  ensures n > 1 && result > 0 ==> forall y :: y > 0 && y < result ==> y * y + digitSum(y) * y != n\n  ensures n > 1 && result == -1 ==> forall x :: x > 0 ==> x * x + digitSum(x) * x != n\n  ensures result == -1 || result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4721", "vc-description": "Given n east-west streets and m north-south streets in a city where all streets intersect,\ndetermine the number of rectangular blocks formed by the street grid.\nn east-west streets create (n-1) horizontal strips, m north-south streets create (m-1) vertical strips,\nresulting in (n-1) * (m-1) rectangular blocks.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n    2 <= n <= 100 && 2 <= m <= 100\n}\n\nfunction CountBlocks(n: int, m: int): int\n    requires ValidInput(n, m)\n{\n    (n - 1) * (m - 1)\n}\n\npredicate CorrectOutput(n: int, m: int, blocks: int)\n{\n    ValidInput(n, m) && blocks == CountBlocks(n, m)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (blocks: int)\n    requires ValidInput(n, m)\n    ensures CorrectOutput(n, m, blocks)\n    ensures blocks >= 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4722", "vc-description": "Given two integers A and B representing cookies in two tins, determine if cookies\ncan be distributed equally among three goats by choosing A, B, or A+B total cookies.", "vc-preamble": "predicate ValidInput(A: int, B: int)\n{\n    1 <= A <= 100 && 1 <= B <= 100\n}\n\npredicate DistributionPossible(A: int, B: int)\n{\n    A % 3 == 0 || B % 3 == 0 || (A + B) % 3 == 0\n}", "vc-helpers": "", "vc-spec": "method solve(A: int, B: int) returns (result: string)\n    requires ValidInput(A, B)\n    ensures result == \"Possible\" <==> DistributionPossible(A, B)\n    ensures result == \"Possible\" || result == \"Impossible\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_4724", "vc-description": "Given a current rating R and target rating G, find the required performance P\nsuch that the new rating equals G, where new rating = (R + P) / 2 = G.", "vc-preamble": "predicate ValidInput(R: int, G: int) {\n    0 <= R <= 4500 && 0 <= G <= 4500\n}\n\nfunction RequiredPerformance(R: int, G: int): int {\n    2 * G - R\n}\n\npredicate CorrectResult(R: int, G: int, P: int) {\n    (R + P) == 2 * G\n}", "vc-helpers": "", "vc-spec": "method solve(R: int, G: int) returns (result: int)\n    requires ValidInput(R, G)\n    ensures result == RequiredPerformance(R, G)\n    ensures CorrectResult(R, G, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_473", "vc-description": "Given a wake-up time and sleep duration, both in \"hh:mm\" 24-hour format,\ncalculate the bedtime by subtracting the sleep duration from the wake-up time.\nHandle day wrap-around when the bedtime falls on the previous day.", "vc-preamble": "predicate ValidTimeFormat(time_str: string)\n{\n    |time_str| == 5 &&\n    time_str[2] == ':' &&\n    '0' <= time_str[0] <= '9' && '0' <= time_str[1] <= '9' &&\n    '0' <= time_str[3] <= '9' && '0' <= time_str[4] <= '9' &&\n    (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int) <= 23 &&\n    (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int) <= 59\n}\n\npredicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    exists i :: 0 <= i < |stdin_input| && stdin_input[i] == '\\n' &&\n    exists i, j :: 0 <= i < j < |stdin_input| && stdin_input[i] == '\\n' && stdin_input[j] == '\\n' &&\n    var first_nl := FindFirstNewline(stdin_input);\n    var second_nl := FindSecondNewline(stdin_input, first_nl);\n    var s := stdin_input[..first_nl];\n    var t := stdin_input[first_nl+1..second_nl];\n    ValidTimeFormat(s) && ValidTimeFormat(t)\n}\n\nfunction ParseTime(time_str: string): (int, int)\n    requires ValidTimeFormat(time_str)\n    ensures var (h, m) := ParseTime(time_str); 0 <= h <= 23 && 0 <= m <= 59\n{\n    var h := (time_str[0] as int - '0' as int) * 10 + (time_str[1] as int - '0' as int);\n    var m := (time_str[3] as int - '0' as int) * 10 + (time_str[4] as int - '0' as int);\n    (h, m)\n}\n\nfunction CalculateBedtime(wake_hour: int, wake_min: int, sleep_hour: int, sleep_min: int): (int, int)\n    requires 0 <= wake_hour <= 23 && 0 <= wake_min <= 59\n    requires 0 <= sleep_hour <= 23 && 0 <= sleep_min <= 59\n    ensures var (h, m) := CalculateBedtime(wake_hour, wake_min, sleep_hour, sleep_min); 0 <= h <= 23 && 0 <= m <= 59\n{\n    var wake_total_min := wake_hour * 60 + wake_min;\n    var sleep_total_min := sleep_hour * 60 + sleep_min;\n    var bed_total_min := (wake_total_min - sleep_total_min + 24 * 60) % (24 * 60);\n    (bed_total_min / 60, bed_total_min % 60)\n}\n\npredicate ValidOutput(result: string)\n{\n    |result| == 6 &&\n    result[|result|-1] == '\\n' &&\n    result[2] == ':' &&\n    '0' <= result[0] <= '9' && '0' <= result[1] <= '9' &&\n    '0' <= result[3] <= '9' && '0' <= result[4] <= '9' &&\n    (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int) <= 23 &&\n    (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int) <= 59\n}\n\npredicate CorrectBedtime(stdin_input: string, result: string)\n    requires ValidInput(stdin_input) && ValidOutput(result)\n{\n    var first_nl := FindFirstNewline(stdin_input);\n    var second_nl := FindSecondNewline(stdin_input, first_nl);\n    var s := stdin_input[..first_nl];\n    var t := stdin_input[first_nl+1..second_nl];\n    var (wake_hour, wake_min) := ParseTime(s);\n    var (sleep_hour, sleep_min) := ParseTime(t);\n    var (bed_hour, bed_min) := CalculateBedtime(wake_hour, wake_min, sleep_hour, sleep_min);\n    var result_hour := (result[0] as int - '0' as int) * 10 + (result[1] as int - '0' as int);\n    var result_min := (result[3] as int - '0' as int) * 10 + (result[4] as int - '0' as int);\n    result_hour == bed_hour && result_min == bed_min\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(result)\n    ensures CorrectBedtime(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_475", "vc-description": "Count the number of ways to paint n bricks in a row using m colors such that exactly k bricks \nhave a different color than the brick immediately to their left. The first brick is not counted \nin this comparison. Result should be modulo 998,244,353.", "vc-preamble": "predicate ValidInput(n: nat, m: nat, k: nat) {\n    n >= 1 && m >= 1 && k >= 0 && k <= n - 1\n}\n\nfunction factorial(n: nat): nat\n{\n    if n == 0 then 1\n    else n * factorial(n - 1)\n}\n\nfunction binomial(n: nat, k: nat): nat\n    requires k <= n\n{\n    if factorial(k) == 0 || factorial(n - k) == 0 then 0\n    else factorial(n) / (factorial(k) * factorial(n - k))\n}\n\nfunction power(base: nat, exp: nat): nat\n{\n    if exp == 0 then 1\n    else base * power(base, exp - 1)\n}\n\nfunction ExpectedResult(n: nat, m: nat, k: nat): nat\n    requires ValidInput(n, m, k)\n{\n    (m * power(m - 1, k) * binomial(n - 1, k)) % 998244353\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, m: nat, k: nat) returns (result: nat)\n    requires ValidInput(n, m, k)\n    ensures result < 998244353", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_48", "vc-description": "Given an n \u00d7 m multiplication table where element at row i and column j equals i\u00b7j (1-indexed),\nfind the k-th smallest number among all n\u00b7m elements in the table.", "vc-preamble": "function countLessValue(n: int, m: int, target: int): int\n  requires n >= 0 && m >= 1 && target >= 1\n  ensures countLessValue(n, m, target) >= 0\n  ensures countLessValue(n, m, target) <= n * m\n{\n  if n == 0 then 0\n  else \n    var maxJ := (target - 1) / n;\n    var actualMaxJ := if maxJ > m then m else maxJ;\n    var contribution := if actualMaxJ >= 1 then actualMaxJ else 0;\n    contribution + countLessValue(n - 1, m, target)\n}\n\nfunction countLessOrEqualValue(n: int, m: int, target: int): int\n  requires n >= 1 && m >= 1 && target >= 0\n  ensures countLessOrEqualValue(n, m, target) >= 0\n  ensures countLessOrEqualValue(n, m, target) <= n * m\n{\n  if target <= 0 then 0\n  else if target >= n * m then n * m\n  else countLessValue(n, m, target + 1)\n}\n\npredicate ValidInput(n: int, m: int, k: int)\n{\n  1 <= n <= 500000 && 1 <= m <= 500000 && 1 <= k <= n * m\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int) returns (result: int)\n  requires ValidInput(n, m, k)\n  ensures 1 <= result <= n * m\n  ensures countLessOrEqualValue(n, m, result) >= k\n  ensures result == 1 || countLessOrEqualValue(n, m, result - 1) < k", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_483", "vc-description": "Given n particles on a line at distinct even-integer positions, where each particle moves \nleft (L) or right (R) at speed 1 unit per microsecond, find the time of the first collision \nbetween any two particles, or return -1 if no collision occurs.", "vc-preamble": "predicate ValidInput(n: int, directions: string, positions: seq<int>)\n{\n    n >= 1 &&\n    |directions| == n &&\n    |positions| == n &&\n    (forall i :: 0 <= i < n ==> directions[i] == 'R' || directions[i] == 'L') &&\n    (forall i :: 0 <= i < n ==> positions[i] % 2 == 0 && positions[i] >= 0) &&\n    (forall i, j :: 0 <= i < j < n ==> positions[i] < positions[j])\n}\n\npredicate HasCollision(directions: string, positions: seq<int>)\n    requires |directions| == |positions|\n{\n    exists i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L'\n}\n\nfunction CollisionTime(i: int, positions: seq<int>): int\n    requires 0 <= i < |positions|-1\n{\n    (positions[i+1] - positions[i]) / 2\n}\n\npredicate IsMinimalCollisionTime(result: int, directions: string, positions: seq<int>)\n    requires |directions| == |positions|\n{\n    (forall i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L' ==> \n        CollisionTime(i, positions) >= result) &&\n    (exists i :: 0 <= i < |directions|-1 && directions[i] == 'R' && directions[i+1] == 'L' && \n        CollisionTime(i, positions) == result)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, directions: string, positions: seq<int>) returns (result: int)\n    requires ValidInput(n, directions, positions)\n    ensures result == -1 || result >= 0\n    ensures result != -1 ==> HasCollision(directions, positions)\n    ensures result == -1 ==> !HasCollision(directions, positions)\n    ensures result != -1 ==> IsMinimalCollisionTime(result, directions, positions)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_484", "vc-description": "Given a rectangular piece of paper of dimensions a \u00d7 b and n rectangular seals with dimensions x_i \u00d7 y_i,\nfind the maximum total area that can be covered by placing exactly two different seals on the paper.\nEach seal can be rotated 90 degrees, and the impressions must not overlap (but can touch).\nIf no two seals can fit on the paper, return 0.", "vc-preamble": "function checkPairFunc(seal1: (int, int), seal2: (int, int), a: int, b: int): int\n    requires a >= 1 && b >= 1\n    requires seal1.0 >= 1 && seal1.1 >= 1\n    requires seal2.0 >= 1 && seal2.1 >= 1\n    ensures checkPairFunc(seal1, seal2, a, b) >= 0\n    ensures checkPairFunc(seal1, seal2, a, b) <= seal1.0 * seal1.1 + seal2.0 * seal2.1\n{\n    var orientations := [(seal1, seal2), (seal1, (seal2.1, seal2.0)), ((seal1.1, seal1.0), seal2), ((seal1.1, seal1.0), (seal2.1, seal2.0))];\n\n    var area0 := if canFit(orientations[0].0, orientations[0].1, a, b) then\n        orientations[0].0.0 * orientations[0].0.1 + orientations[0].1.0 * orientations[0].1.1\n    else\n        0;\n\n    var area1 := if canFit(orientations[1].0, orientations[1].1, a, b) then\n        orientations[1].0.0 * orientations[1].0.1 + orientations[1].1.0 * orientations[1].1.1\n    else\n        0;\n\n    var area2 := if canFit(orientations[2].0, orientations[2].1, a, b) then\n        orientations[2].0.0 * orientations[2].0.1 + orientations[2].1.0 * orientations[2].1.1\n    else\n        0;\n\n    var area3 := if canFit(orientations[3].0, orientations[3].1, a, b) then\n        orientations[3].0.0 * orientations[3].0.1 + orientations[3].1.0 * orientations[3].1.1\n    else\n        0;\n\n    max(max(area0, area1), max(area2, area3))\n}\n\nfunction canFit(r1: (int, int), r2: (int, int), a: int, b: int): bool\n    requires a >= 1 && b >= 1\n    requires r1.0 >= 1 && r1.1 >= 1\n    requires r2.0 >= 1 && r2.1 >= 1\n{\n    (r1.0 + r2.0 <= a && max(r1.1, r2.1) <= b) || (max(r1.0, r2.0) <= a && r1.1 + r2.1 <= b)\n}\n\nfunction max(x: int, y: int): int\n{\n    if x >= y then x else y\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int, seals: seq<(int, int)>) returns (result: int)\n    requires n >= 0\n    requires a >= 1 && b >= 1\n    requires |seals| == n\n    requires forall i :: 0 <= i < n ==> seals[i].0 >= 1 && seals[i].1 >= 1\n    ensures result >= 0\n    ensures result == 0 ==> (forall i, j :: 0 <= i < n && i < j < n ==> checkPairFunc(seals[i], seals[j], a, b) == 0)\n    ensures result > 0 ==> (exists i, j :: 0 <= i < n && i < j < n && checkPairFunc(seals[i], seals[j], a, b) == result)\n    ensures forall i, j :: 0 <= i < n && i < j < n ==> checkPairFunc(seals[i], seals[j], a, b) <= result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_486", "vc-description": "Given a positive integer n, find the maximum product of digits among all integers from 1 to n inclusive.\nThe product of digits is calculated by multiplying all individual digits together.", "vc-preamble": "function ProductOfDigits(x: int): int\n  requires x >= 0\n{\n  if x == 0 then 1\n  else if x < 10 then x\n  else (x % 10) * ProductOfDigits(x / 10)\n}\n\nfunction MaxProductOfDigitsInRange(n: int): int\n  requires n >= 1\n{\n  if n == 1 then 1\n  else\n    var current := ProductOfDigits(n);\n    var rest := MaxProductOfDigitsInRange(n - 1);\n    if current > rest then current else rest\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n  requires n >= 1\n  ensures result == MaxProductOfDigitsInRange(n)\n  ensures result >= 1\n  ensures forall k :: 1 <= k <= n ==> ProductOfDigits(k) <= result\n  ensures exists k :: 1 <= k <= n && ProductOfDigits(k) == result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_491", "vc-description": "Given an integer n representing a bank account balance, perform at most one operation:\ndelete the last digit, delete the digit before the last digit, or do nothing.\nFind the maximum possible balance after performing the operation.\nConstraint: absolute value of n is at least 10.\n\n// delete last digit\n\n// delete digit before last", "vc-preamble": "predicate ValidInput(n: int)\n{\n    n >= 10 || n <= -10\n}\n\nfunction MaxBalanceAfterOperation(n: int): int\n    requires ValidInput(n)\n{\n    if n >= 0 then n\n    else \n        var s := IntToString(n);\n        var option1 := StringToInt(s[..|s|-1]);\n        var option2 := StringToInt(s[..|s|-2] + s[|s|-1..]);\n        if option1 > option2 then option1 else option2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == MaxBalanceAfterOperation(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_492", "vc-description": "A spinner has 4 positions encoded as v, >, ^, < (representing positions 0, 1, 2, 3 respectively).\nThe spinner rotates by changing position every second, either clockwise or counter-clockwise.\nGiven the starting position, ending position, and rotation duration n seconds, determine the rotation direction.", "vc-preamble": "function CharToPosSpec(c: string): int\n{\n    if c == \"v\" then 0\n    else if c == \">\" then 1\n    else if c == \"^\" then 2\n    else if c == \"<\" then 3\n    else 0\n}\n\nfunction SplitLinesSpec(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var i := FindNewline(s, 0);\n        if i == |s| then [s]\n        else [s[0..i]] + SplitLinesSpec(s[i+1..])\n}\n\nfunction FindNewline(s: string, start: int): int\n    requires 0 <= start <= |s|\n    ensures start <= FindNewline(s, start) <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == '\\n' then start\n    else FindNewline(s, start + 1)\n}\n\nfunction SplitBySpaceSpec(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else\n        var i := FindSpace(s, 0);\n        if i == |s| then [s]\n        else [s[0..i]] + SplitBySpaceSpec(s[i+1..])\n}\n\nfunction FindSpace(s: string, start: int): int\n    requires 0 <= start <= |s|\n    ensures start <= FindSpace(s, start) <= |s|\n    decreases |s| - start\n{\n    if start >= |s| then |s|\n    else if s[start] == ' ' then start\n    else FindSpace(s, start + 1)\n}\n\nfunction StringToIntSpec(s: string): int\n{\n    StringToIntHelper(s, 0, 0, false)\n}\n\nfunction StringToIntHelper(s: string, pos: int, acc: int, negative: bool): int\n    requires 0 <= pos <= |s|\n    decreases |s| - pos\n{\n    if pos >= |s| then (if negative then -acc else acc)\n    else if pos == 0 && s[pos] == '-' then StringToIntHelper(s, pos + 1, acc, true)\n    else if '0' <= s[pos] <= '9' then \n        StringToIntHelper(s, pos + 1, acc * 10 + (s[pos] as int - '0' as int), negative)\n    else StringToIntHelper(s, pos + 1, acc, negative)\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidOutput(result: string)\n{\n    result == \"cw\" || result == \"ccw\" || result == \"undefined\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)\n    ensures |input| > 0 ==> (\n        var lines := SplitLinesSpec(input);\n        |lines| >= 2 ==> (\n            var positions := SplitBySpaceSpec(lines[0]);\n            |positions| >= 2 ==> (\n                var startChar := positions[0];\n                var endChar := positions[1];\n                var n := StringToIntSpec(lines[1]);\n                var startPos := CharToPosSpec(startChar);\n                var endPos := CharToPosSpec(endChar);\n                var ccw := (startPos + n) % 4 == endPos;\n                var cw := (startPos - n) % 4 == endPos;\n                (cw && !ccw ==> result == \"cw\") &&\n                (ccw && !cw ==> result == \"ccw\") &&\n                (!(cw && !ccw) && !(ccw && !cw) ==> result == \"undefined\")\n            )\n        )\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_498", "vc-description": "Given a classroom with n lanes and m desks per lane, where each desk has 2 seats (left and right),\nfind the lane, desk, and side for seat number k. Seats are numbered 1 to 2nm in order:\nby lane first, then by desk within each lane, then left seat before right seat within each desk.", "vc-preamble": "predicate ValidInput(n: int, m: int, k: int)\n{\n    1 <= n <= 10000 && 1 <= m <= 10000 && 1 <= k <= 2 * n * m\n}\n\npredicate ValidOutput(n: int, m: int, lane: int, desk: int, side: string)\n{\n    1 <= lane <= n && 1 <= desk <= m && (side == \"L\" || side == \"R\")\n}\n\npredicate CorrectSolution(n: int, m: int, k: int, lane: int, desk: int, side: string)\n    requires ValidInput(n, m, k)\n{\n    lane == (k - 1) / (2 * m) + 1 &&\n    desk == (k - 1) % (2 * m) / 2 + 1 &&\n    (side == \"L\" <==> (k - 1) % (2 * m) % 2 == 0)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int) returns (lane: int, desk: int, side: string)\n    requires ValidInput(n, m, k)\n    ensures ValidOutput(n, m, lane, desk, side)\n    ensures CorrectSolution(n, m, k, lane, desk, side)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_5", "vc-description": "Given n browser tabs indexed 1 to n with cursor at position pos, find minimum time to close\nall tabs except those in range [l, r]. Operations: move cursor (1 sec), close all tabs to\nleft of cursor (1 sec), close all tabs to right of cursor (1 sec).", "vc-preamble": "predicate ValidInput(n: int, pos: int, l: int, r: int)\n{\n    1 <= n <= 100 && 1 <= pos <= n && 1 <= l <= r <= n\n}\n\npredicate NoTabsToClose(l: int, r: int, n: int)\n{\n    l == 1 && r == n\n}\n\npredicate OnlyCloseRight(l: int, r: int, n: int)\n{\n    l == 1 && r < n\n}\n\npredicate OnlyCloseLeft(l: int, r: int, n: int)\n{\n    l > 1 && r == n\n}\n\npredicate CloseBothSides(l: int, r: int, n: int)\n{\n    l > 1 && r < n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, pos: int, l: int, r: int) returns (result: int)\n    requires ValidInput(n, pos, l, r)\n    ensures result >= 0\n    ensures NoTabsToClose(l, r, n) ==> result == 0\n    ensures OnlyCloseRight(l, r, n) ==> result == abs(pos - r) + 1\n    ensures OnlyCloseLeft(l, r, n) ==> result == abs(pos - l) + 1\n    ensures CloseBothSides(l, r, n) && l <= pos <= r && pos - l < r - pos ==> result == (pos - l) + 1 + (r - l) + 1\n    ensures CloseBothSides(l, r, n) && l <= pos <= r && pos - l >= r - pos ==> result == (r - pos) + 1 + (r - l) + 1\n    ensures CloseBothSides(l, r, n) && pos > r ==> result == (pos - r) + 1 + (r - l) + 1\n    ensures CloseBothSides(l, r, n) && pos < l ==> result == (l - pos) + 1 + (r - l) + 1\n    ensures result <= 2 * n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_50", "vc-description": "You start with r bourles and no shares. There are n buying opportunities and m selling opportunities for shares. \nFind the maximum bourles you can have after trading. You can buy any number of shares at any buying price \nand sell any number of shares (up to what you own) at any selling price.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && '\\n' in input &&\n    var lines := SplitLinesFunc(input);\n    |lines| >= 3 &&\n    ValidIntLine(lines[0], 3) &&\n    ValidIntLine(lines[1]) &&\n    ValidIntLine(lines[2]) &&\n    var firstLine := SplitIntsFunc(lines[0]);\n    var S := SplitIntsFunc(lines[1]);\n    var B := SplitIntsFunc(lines[2]);\n    |firstLine| == 3 && firstLine[0] >= 1 && firstLine[1] >= 1 && firstLine[2] >= 1 &&\n    |S| == firstLine[0] && |B| == firstLine[1]\n}\n\nfunction ParseInput(input: string): (int, int, int, seq<int>, seq<int>)\n    requires ValidInput(input)\n    ensures var result := ParseInput(input);\n        result.0 >= 1 && result.1 >= 1 && result.2 >= 1 &&\n        |result.3| == result.0 && |result.4| == result.1 &&\n        (forall i :: 0 <= i < |result.3| ==> result.3[i] >= 1) &&\n        (forall i :: 0 <= i < |result.4| ==> result.4[i] >= 1)\n{\n    var lines := SplitLinesFunc(input);\n    var firstLine := SplitIntsFunc(lines[0]);\n    var S := SplitIntsFunc(lines[1]);\n    var B := SplitIntsFunc(lines[2]);\n    (firstLine[0], firstLine[1], firstLine[2], S, B)\n}\n\nfunction ComputeMaxBourles(r: int, S: seq<int>, B: seq<int>): int\n    requires r >= 1\n    requires |S| >= 1 && |B| >= 1\n    requires forall i :: 0 <= i < |S| ==> S[i] >= 1\n    requires forall i :: 0 <= i < |B| ==> B[i] >= 1\n{\n    var x := MinSeqFunc(S);\n    var y := MaxSeqFunc(B);\n    var cnt := (r % x) + (r / x) * y;\n    if r > cnt then r else cnt\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires '\\n' in input\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures exists n, m, r, S, B :: \n        ParseInput(input) == (n, m, r, S, B) &&\n        n >= 1 && m >= 1 && r >= 1 &&\n        |S| == n && |B| == m &&\n        (forall i :: 0 <= i < |S| ==> S[i] >= 1) &&\n        (forall i :: 0 <= i < |B| ==> B[i] >= 1) &&\n        result == IntToStringFunc(ComputeMaxBourles(r, S, B)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_502", "vc-description": "Given three distinct points a, b, and c, determine if there exists a rotation center and angle \nsuch that rotating point a gives point b, and rotating point b gives point c.\nThe rotation must map a \u2192 b and b \u2192 c using the same center and angle.\nFor a valid rotation to exist, the distances |ab| and |bc| must be equal and \nthe three points cannot be collinear.", "vc-preamble": "function lengthSqr(p1: (int, int), p2: (int, int)): int\n{\n    (p1.0 - p2.0) * (p1.0 - p2.0) + (p1.1 - p2.1) * (p1.1 - p2.1)\n}\n\npredicate ValidRotationExists(a: (int, int), b: (int, int), c: (int, int))\n{\n    var distABSqr := lengthSqr(a, b);\n    var distBCSqr := lengthSqr(b, c);\n    var dx1 := c.0 - b.0;\n    var dy1 := c.1 - b.1;\n    var dx2 := b.0 - a.0;\n    var dy2 := b.1 - a.1;\n    distABSqr == distBCSqr && dx1 * dy2 != dy1 * dx2\n}\n\nfunction parseInputFunc(input: string): seq<int>\n    requires |input| > 0\n{\n    parseInputHelper(input, 0, [], \"\")\n}\n\nfunction parseInputHelper(input: string, i: int, result: seq<int>, current: string): seq<int>\n    requires 0 <= i <= |input|\n    decreases |input| - i\n{\n    if i == |input| then\n        if |current| > 0 then result + [stringToInt(current)]\n        else result\n    else\n        var ch := input[i];\n        if ch == ' ' || ch == '\\n' || ch == '\\t' then\n            if |current| > 0 then\n                parseInputHelper(input, i + 1, result + [stringToInt(current)], \"\")\n            else\n                parseInputHelper(input, i + 1, result, \"\")\n        else if ('0' <= ch <= '9') || ch == '-' then\n            parseInputHelper(input, i + 1, result, current + [ch])\n        else\n            parseInputHelper(input, i + 1, result, current)\n}\n\nfunction stringToInt(s: string): int\n{\n    if |s| == 0 then 0\n    else if |s| == 1 && s[0] == '-' then 0\n    else if s[0] == '-' && |s| > 1 && isDigitString(s[1..]) then -stringToIntHelper(s[1..])\n    else if isDigitString(s) then stringToIntHelper(s)\n    else 0\n}\n\nfunction isDigitString(s: string): bool\n{\n    forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction stringToIntHelper(s: string): int\n    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n{\n    if |s| == 0 then 0\n    else if |s| == 1 then charToDigit(s[0])\n    else stringToIntHelper(s[..|s|-1]) * 10 + charToDigit(s[|s|-1])\n}\n\nfunction charToDigit(c: char): int\n    requires '0' <= c <= '9'\n{\n    (c as int) - ('0' as int)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"Yes\" || result == \"No\" || result == \"\"\n    ensures var coords := parseInputFunc(input); \n            |coords| != 6 ==> result == \"\"\n    ensures var coords := parseInputFunc(input);\n            |coords| == 6 ==> \n                var a := (coords[0], coords[1]);\n                var b := (coords[2], coords[3]);\n                var c := (coords[4], coords[5]);\n                (ValidRotationExists(a, b, c) ==> result == \"Yes\") &&\n                (!ValidRotationExists(a, b, c) ==> result == \"No\")", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_505", "vc-description": "Given an n\u00d7m rectangular maze with a robot starting at position 'X', find the lexicographically smallest path of exactly k moves that returns the robot to its starting position.\nThe maze contains '.' for empty cells, '*' for obstacles, and 'X' for the robot's starting position.\nRobot can move in 4 directions: L (left), R (right), U (up), D (down) and can only move to empty cells.\nReturn the lexicographically smallest string of length k consisting of characters 'D', 'L', 'R', 'U' that returns the robot to start, or \"IMPOSSIBLE\".", "vc-preamble": "predicate ValidInput(n: int, m: int, k: int, grid: seq<string>)\n{\n    n > 0 && m > 0 && k >= 0 &&\n    |grid| == n &&\n    (forall i :: 0 <= i < n ==> |grid[i]| == m) &&\n    (exists i, j :: 0 <= i < n && 0 <= j < m && grid[i][j] == 'X') &&\n    (forall i :: 0 <= i < n ==> forall c :: c in grid[i] ==> c == '.' || c == '*' || c == 'X') &&\n    |set i,j | 0 <= i < n && 0 <= j < m && grid[i][j] == 'X' :: (i,j)| == 1\n}\n\nfunction GetNextPosition(x: int, y: int, move: char): (int, int)\n{\n    match move\n        case 'D' => (x + 1, y)\n        case 'L' => (x, y - 1)\n        case 'R' => (x, y + 1)\n        case 'U' => (x - 1, y)\n        case _ => (x, y)\n}\n\nfunction SimulatePath(startX: int, startY: int, path: string, grid: seq<string>, n: int, m: int): (int, int)\n    decreases |path|\n{\n    if |path| == 0 then (startX, startY)\n    else \n        var nextPos := GetNextPosition(startX, startY, path[0]);\n        SimulatePath(nextPos.0, nextPos.1, path[1..], grid, n, m)\n}\n\npredicate ValidPath(startX: int, startY: int, path: string, grid: seq<string>, n: int, m: int)\n{\n    forall i :: 0 <= i <= |path| ==> \n        var pos := SimulatePath(startX, startY, path[..i], grid, n, m);\n        0 <= pos.0 < n && 0 <= pos.1 < m && \n        pos.0 < |grid| && pos.1 < |grid[pos.0]| &&\n        grid[pos.0][pos.1] != '*'\n}\n\npredicate PathReturnsToStart(startX: int, startY: int, path: string, grid: seq<string>, n: int, m: int)\n{\n    var finalPos := SimulatePath(startX, startY, path, grid, n, m);\n    finalPos.0 == startX && finalPos.1 == startY\n}\n\npredicate ValidDirections(path: string)\n{\n    forall c :: c in path ==> c == 'D' || c == 'L' || c == 'R' || c == 'U'\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, k: int, grid: seq<string>) returns (result: string)\n    requires ValidInput(n, m, k, grid)\n    ensures k % 2 == 1 ==> result == \"IMPOSSIBLE\"\n    ensures k % 2 == 0 ==> (\n        result == \"IMPOSSIBLE\" || \n        (|result| == k && ValidDirections(result))\n    )\n    ensures result != \"IMPOSSIBLE\" ==> |result| == k\n    ensures result != \"IMPOSSIBLE\" ==> (\n        exists startX, startY :: 0 <= startX < n && 0 <= startY < m && \n        grid[startX][startY] == 'X' &&\n        PathReturnsToStart(startX, startY, result, grid, n, m)\n    )\n    ensures result != \"IMPOSSIBLE\" ==> (\n        exists startX, startY :: 0 <= startX < n && 0 <= startY < m && \n        grid[startX][startY] == 'X' &&\n        ValidPath(startX, startY, result, grid, n, m)\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_506", "vc-description": "Given a rectangular sheet of paper with dimensions a \u00d7 b millimeters (where a > b),\ndetermine how many square pieces can be cut from it using the following process:\n1. From the current rectangle, cut the largest possible square\n2. Continue with the remaining rectangular strip (if any exists)  \n3. Repeat until only a square remains\n4. Count the total number of squares cut", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    a > 0 && b > 0\n}\n\nfunction countSquares(a: int, b: int): int\n    requires a >= 0 && b >= 0\n    ensures a > 0 && b > 0 && a > b ==> countSquares(a, b) >= 1\n    ensures a > 0 && b > 0 && b > a ==> countSquares(a, b) >= 1\n    ensures a > 0 && b > 0 && a == b ==> countSquares(a, b) == 1\n    decreases a + b\n{\n    if a == 0 || b == 0 then 0\n    else if a > b then a / b + countSquares(a % b, b)\n    else b / a + countSquares(a, b % a)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result >= 0\n    ensures (a == b) ==> (result == 1)\n    ensures a > b ==> result >= 1\n    ensures result == countSquares(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_510", "vc-description": "Three ropewalkers are positioned at coordinates a, b, and c on an infinite line.\nEach second, exactly one ropewalker can move by 1 unit left or right.\nFind the minimum time needed so that the distance between every pair of ropewalkers is at least d.", "vc-preamble": "function pos1(a: int, b: int, c: int): int\n{\n    if a <= b && a <= c then a\n    else if b <= a && b <= c then b\n    else c\n}\n\nfunction pos2(a: int, b: int, c: int): int\n{\n    if a <= b && a <= c then\n        if b <= c then b else c\n    else if b <= a && b <= c then\n        if a <= c then a else c\n    else\n        if a <= b then a else b\n}\n\nfunction pos3(a: int, b: int, c: int): int\n{\n    if a <= b && a <= c then\n        if b <= c then c else b\n    else if b <= a && b <= c then\n        if a <= c then c else a\n    else\n        if a <= b then b else a\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int) returns (result: int)\n    requires 1 <= a <= 1_000_000_000\n    requires 1 <= b <= 1_000_000_000\n    requires 1 <= c <= 1_000_000_000\n    requires 1 <= d <= 1_000_000_000\n    ensures result >= 0\n    ensures result == (if d > (pos2(a, b, c) - pos1(a, b, c)) then d - (pos2(a, b, c) - pos1(a, b, c)) else 0) +\n                     (if d > (pos3(a, b, c) - pos2(a, b, c)) then d - (pos3(a, b, c) - pos2(a, b, c)) else 0)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_511", "vc-description": "Given a function f(a, b) defined as f(a, 0) = 0 and f(a, b) = 1 + f(a, b - gcd(a, b)) for b > 0,\ncalculate f(x, y) for given integers x and y. The input is a string containing two integers\nseparated by a space, and the output is a string containing the result.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    (exists i :: 0 <= i < |input| && input[i] == ' ') &&\n    (forall j :: 0 <= j < |input| ==> ('0' <= input[j] <= '9' || input[j] == ' ' || input[j] == '\\n'))\n}\n\nfunction gcd(a: nat, b: nat): nat\n    ensures gcd(a, b) > 0 || (a == 0 && b == 0)\n    ensures a > 0 ==> gcd(a, b) <= a\n    ensures b > 0 ==> gcd(a, b) <= b\n    ensures (a != 0 || b != 0) ==> (a % gcd(a, b) == 0 && b % gcd(a, b) == 0)\n    ensures gcd(a, 0) == a\n    ensures gcd(0, b) == b\n    decreases a + b\n{\n    if a == 0 then b\n    else if b == 0 then a  \n    else if a > b then gcd(a - b, b)\n    else gcd(a, b - a)\n}\n\nfunction f_mathematical(x: nat, y: nat): nat\n    ensures y == 0 ==> f_mathematical(x, y) == 0\n    ensures y > 0 ==> f_mathematical(x, y) > 0\n    ensures y > 0 ==> f_mathematical(x, y) <= y\n    ensures y > 0 ==> f_mathematical(x, y) == 1 + f_mathematical(x, y - gcd(x, y))\n    decreases y\n{\n    if y == 0 then 0\n    else \n        var g := gcd(x, y);\n        if g >= y then 1\n        else 1 + f_mathematical(x, y - g)\n}\n\npredicate ValidOutput(result: string)\n{\n    |result| > 0 &&\n    forall i :: 0 <= i < |result| ==> ('0' <= result[i] <= '9' || result[i] == '\\n') &&\n    result[|result|-1] == '\\n'\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_520", "vc-description": "Given a list of university entrance years for groups that student Igor joined,\ndetermine Igor's university entrance year. Igor joins his own group and all groups\nwhere the entrance year differs by at most x years from his entrance year.\nThe solution computes Igor's entrance year as the average of all group years.", "vc-preamble": "function sumRange(s: seq<int>, start: int, end: int): int\n    requires 0 <= start <= end <= |s|\n    decreases end - start\n{\n    if start == end then 0\n    else s[start] + sumRange(s, start + 1, end)\n}\n\npredicate ValidInput(n: int, years: seq<int>)\n{\n    n > 0 && |years| == n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, years: seq<int>) returns (result: int)\n    requires ValidInput(n, years)\n    ensures result == sumRange(years, 0, |years|) / n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_529", "vc-description": "Given a string and an integer n (0 \u2264 n \u2264 26), transform the string by:\n1. Converting the entire string to lowercase\n2. For each character, if it is lexicographically smaller than the nth letter \n   of the alphabet (0-indexed), convert it to uppercase; otherwise, keep it lowercase\n3. When n = 26, use '|' as the comparison character (which comes after 'z')", "vc-preamble": "predicate ValidInput(s: string, n: int)\n{\n  0 <= n <= 26\n}\n\nfunction GetComparisonChar(n: int): char\n  requires 0 <= n <= 26\n{\n  var alphabet := \"abcdefghijklmnopqrstuvwxyz|\";\n  alphabet[n]\n}\n\nfunction IsLowercase(c: char): bool\n{\n  'a' <= c <= 'z'\n}\n\nfunction IsUppercase(c: char): bool\n{\n  'A' <= c <= 'Z'\n}\n\nfunction ToLowercase(c: char): char\n{\n  if IsUppercase(c) then (c as int - 'A' as int + 'a' as int) as char\n  else c\n}\n\nfunction ToUppercase(c: char): char\n{\n  if IsLowercase(c) then (c as int - 'a' as int + 'A' as int) as char\n  else c\n}\n\nfunction TransformString(s: string, n: int): string\n  requires ValidInput(s, n)\n{\n  var compChar := GetComparisonChar(n);\n  TransformWithCompChar(ToLowercaseString(s), compChar)\n}\n\nfunction ToLowercaseString(s: string): string\n{\n  if |s| == 0 then \"\"\n  else [ToLowercase(s[0])] + ToLowercaseString(s[1..])\n}\n\nfunction TransformWithCompChar(s: string, compChar: char): string\n{\n  if |s| == 0 then \"\"\n  else if s[0] < compChar then [ToUppercase(s[0])] + TransformWithCompChar(s[1..], compChar)\n  else [s[0]] + TransformWithCompChar(s[1..], compChar)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, n: int) returns (result: string)\n  requires ValidInput(s, n)\n  ensures result == TransformString(s, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_530", "vc-description": "Two players play a game with binary strings. They alternate turns choosing positions\nfrom strings of length 2n, collecting characters to form the largest possible binary\nnumbers. Determine the winner with optimal play.", "vc-preamble": "predicate ValidInput(n: int, a: string, b: string)\n{\n    n > 0 && |a| == 2 * n && |b| == 2 * n &&\n    (forall i :: 0 <= i < |a| ==> a[i] == '0' || a[i] == '1') &&\n    (forall i :: 0 <= i < |b| ==> b[i] == '0' || b[i] == '1')\n}\n\nfunction CountPositions(a: string, b: string, ac: char, bc: char, len: int): int\n    requires len >= 0 && len <= |a| && len <= |b|\n    requires ac == '0' || ac == '1'\n    requires bc == '0' || bc == '1'\n{\n    |set i | 0 <= i < len && a[i] == ac && b[i] == bc|\n}\n\nfunction ComputeGameOutcome(t00: int, t01: int, t10: int, t11: int): int\n{\n    t11 % 2 + (t10 - t01 + 1 - t11 % 2) / 2\n}\n\npredicate CorrectOutcome(result: string, d: int)\n{\n    (d > 0 ==> result == \"First\") &&\n    (d < 0 ==> result == \"Second\") &&\n    (d == 0 ==> result == \"Draw\")\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: string, b: string) returns (result: string)\n    requires ValidInput(n, a, b)\n    ensures result == \"First\" || result == \"Second\" || result == \"Draw\"\n    ensures (exists t00, t01, t10, t11: int ::\n        t00 >= 0 && t01 >= 0 && t10 >= 0 && t11 >= 0 &&\n        t00 + t01 + t10 + t11 == 2 * n &&\n        t00 == CountPositions(a, b, '0', '0', 2 * n) &&\n        t01 == CountPositions(a, b, '0', '1', 2 * n) &&\n        t10 == CountPositions(a, b, '1', '0', 2 * n) &&\n        t11 == CountPositions(a, b, '1', '1', 2 * n) &&\n        CorrectOutcome(result, ComputeGameOutcome(t00, t01, t10, t11)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_533", "vc-description": "Given two football teams with a1 and a2 players respectively, where players from team 1\nare sent off after k1 yellow cards and players from team 2 are sent off after k2 yellow cards.\nA total of n yellow cards were shown during the match. Find the minimum and maximum number\nof players that could have been sent off.", "vc-preamble": "predicate ValidInput(a1: int, a2: int, k1: int, k2: int, n: int) {\n    a1 >= 1 && a2 >= 1 && k1 >= 1 && k2 >= 1 && n >= 1\n}\n\nfunction MinimumSentOff(a1: int, a2: int, k1: int, k2: int, n: int): int\n    requires ValidInput(a1, a2, k1, k2, n)\n{\n    var max_non_sendoff_cards := (k1 - 1) * a1 + (k2 - 1) * a2;\n    if n - max_non_sendoff_cards > 0 then n - max_non_sendoff_cards else 0\n}\n\nfunction MaximumSentOff(a1: int, a2: int, k1: int, k2: int, n: int): int\n    requires ValidInput(a1, a2, k1, k2, n)\n{\n    if k1 < k2 then\n        var team1_sent := if n / k1 < a1 then n / k1 else a1;\n        var remaining_cards := n - team1_sent * k1;\n        team1_sent + remaining_cards / k2\n    else\n        var team2_sent := if n / k2 < a2 then n / k2 else a2;\n        var remaining_cards := n - team2_sent * k2;\n        team2_sent + remaining_cards / k1\n}\n\npredicate ValidResult(a1: int, a2: int, k1: int, k2: int, n: int, minimum: int, maximum: int)\n    requires ValidInput(a1, a2, k1, k2, n)\n{\n    minimum >= 0 && maximum >= 0 &&\n    minimum <= maximum &&\n    maximum <= a1 + a2 &&\n    minimum <= n &&\n    maximum <= n &&\n    minimum == MinimumSentOff(a1, a2, k1, k2, n) &&\n    maximum == MaximumSentOff(a1, a2, k1, k2, n)\n}", "vc-helpers": "", "vc-spec": "method solve(a1: int, a2: int, k1: int, k2: int, n: int) returns (minimum: int, maximum: int)\n    requires ValidInput(a1, a2, k1, k2, n)\n    ensures ValidResult(a1, a2, k1, k2, n, minimum, maximum)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_537", "vc-description": "Given n students and a ratio k, distribute awards (diplomas and certificates) to maximize \nthe number of winners while following constraints: certificates = k \u00d7 diplomas, \ntotal winners \u2264 n/2. Output the number of diplomas, certificates, and non-winners.", "vc-preamble": "predicate ValidInput(n: int, k: int) {\n    n >= 0 && k >= 0 && k + 1 > 0\n}\n\npredicate ValidOutput(result: seq<int>, n: int, k: int) {\n    |result| == 3 &&\n    result[0] >= 0 && result[1] >= 0 && result[2] >= 0 &&\n    result[1] == result[0] * k &&\n    result[0] + result[1] <= n / 2 &&\n    result[2] == n - result[0] - result[1]\n}\n\nfunction OptimalDiplomas(n: int, k: int): int\n    requires ValidInput(n, k)\n{\n    (n / 2) / (k + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: seq<int>)\n    requires ValidInput(n, k)\n    ensures ValidOutput(result, n, k)\n    ensures result[0] == OptimalDiplomas(n, k)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_540", "vc-description": "Given an n\u00d7m grid representing an ice cave level, determine if you can move from starting position (r1, c1) to target position (r2, c2) and fall through the target cell.\nGrid representation: '.' = intact ice, 'X' = cracked ice\nMovement rules: Move to side-adjacent cells only, cannot move to same cell, moving to intact ice cracks it, moving to cracked ice causes fall through\nGoal: Reach (r2, c2) when it's cracked ice and fall through it\nStarting cell (r1, c1) is guaranteed to contain 'X' in the input", "vc-preamble": "predicate ValidInputFormat(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    |stdin_input| >= 7 &&\n    ContainsRequiredNewlines(stdin_input) &&\n    EndsWithNewlineOrCanAppend(stdin_input) &&\n    HasValidStructure(stdin_input) &&\n    AllGridCharactersValid(stdin_input) &&\n    HasExactlyRequiredLines(stdin_input)\n}\n\npredicate ValidGridBounds(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    var parsed := ParseDimensions(stdin_input);\n    parsed.0 >= 1 && parsed.0 <= 500 && parsed.1 >= 1 && parsed.1 <= 500\n}\n\npredicate ValidCoordinates(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    var dims := ParseDimensions(stdin_input);\n    var coords := ParseCoordinates(stdin_input);\n    coords.0 >= 1 && coords.0 <= dims.0 && coords.1 >= 1 && coords.1 <= dims.1 &&\n    coords.2 >= 1 && coords.2 <= dims.0 && coords.3 >= 1 && coords.3 <= dims.1\n}\n\npredicate StartingCellIsCracked(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    var grid := ParseGrid(stdin_input);\n    var coords := ParseCoordinates(stdin_input);\n    ValidGridIndex(grid, coords.0-1, coords.1-1) &&\n    grid[coords.0-1][coords.1-1] == 'X'\n}\n\npredicate WellFormedInput(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    ValidInputFormat(stdin_input) &&\n    ValidGridBounds(stdin_input) &&\n    ValidCoordinates(stdin_input) &&\n    StartingCellIsCracked(stdin_input) &&\n    GridContainsOnlyValidChars(stdin_input) &&\n    CoordinatesWithinBounds(stdin_input)\n}\n\npredicate CanSolveIceMaze(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    var grid := ParseGrid(stdin_input);\n    var coords := ParseCoordinates(stdin_input);\n    var r1, c1, r2, c2 := coords.0-1, coords.1-1, coords.2-1, coords.3-1;\n    var targetIsCracked := grid[r2][c2] == 'X';\n    var surroundingDots := CountSurroundingIntactIce(grid, r2, c2);\n\n    if targetIsCracked then\n        if r1 == r2 && c1 == c2 then\n            surroundingDots >= 1\n        else\n            CanReachTargetWithBFS(grid, r1, c1, r2, c2)\n    else\n        if surroundingDots >= 2 then\n            CanReachTargetWithBFS(grid, r1, c1, r2, c2)\n        else if surroundingDots == 0 then\n            false\n        else\n            IsAdjacent(r1+1, c1+1, r2+1, c2+1)\n}\n\nfunction ParseDimensions(stdin_input: string): (int, int)\n    requires |stdin_input| > 0\n    ensures ParseDimensions(stdin_input).0 >= 1 && ParseDimensions(stdin_input).1 >= 1\n{\n    (1, 1)\n}\n\nfunction ParseGrid(stdin_input: string): seq<seq<char>>\n    requires |stdin_input| > 0\n    ensures |ParseGrid(stdin_input)| > 0\n    ensures forall i :: 0 <= i < |ParseGrid(stdin_input)| ==> |ParseGrid(stdin_input)[i]| > 0\n    ensures forall i, j :: 0 <= i < |ParseGrid(stdin_input)| && 0 <= j < |ParseGrid(stdin_input)[i]| ==> \n        (ParseGrid(stdin_input)[i][j] == '.' || ParseGrid(stdin_input)[i][j] == 'X')\n{\n    [['X']]\n}\n\nfunction ParseCoordinates(stdin_input: string): (int, int, int, int)\n    requires |stdin_input| > 0\n    ensures ParseCoordinates(stdin_input).0 >= 1 && ParseCoordinates(stdin_input).1 >= 1\n    ensures ParseCoordinates(stdin_input).2 >= 1 && ParseCoordinates(stdin_input).3 >= 1\n{\n    (1, 1, 1, 1)\n}\n\npredicate ValidGridIndex(grid: seq<seq<char>>, r: int, c: int)\n{\n    0 <= r < |grid| && 0 <= c < |grid[r]|\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInputFormat(stdin_input)\n    requires ValidGridBounds(stdin_input)\n    requires ValidCoordinates(stdin_input)\n    requires StartingCellIsCracked(stdin_input)\n    requires WellFormedInput(stdin_input)\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures |result| > 0\n    ensures result == \"YES\\n\" <==> CanSolveIceMaze(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_543", "vc-description": "Determine if pizza requirements for n consecutive days can be fulfilled using only:\n- Discount: Buy exactly 2 pizzas on the same day\n- Coupon: Buy exactly 1 pizza on each of two consecutive days\nCannot buy more pizzas than needed on any day, and cannot have unused coupons after the last day.", "vc-preamble": "predicate ValidInput(pizzas: seq<int>) {\n    forall i :: 0 <= i < |pizzas| ==> pizzas[i] >= 0\n}\n\nfunction validatePizzaSolution(pizzas: seq<int>, index: int, d: bool, p: int): bool\n    requires 0 <= index <= |pizzas|\n    requires p == 0 || p == 1\n    decreases |pizzas| - index\n{\n    if index == |pizzas| then\n        d && p == 0\n    else\n        var requirement := pizzas[index];\n        var newP := if requirement % 2 == 1 then 1 - p else p;\n        var newD := if requirement % 2 == 0 && p == 1 && requirement == 0 then false else d;\n        validatePizzaSolution(pizzas, index + 1, newD, newP)\n}\n\npredicate CanFulfillRequirements(pizzas: seq<int>) {\n    validatePizzaSolution(pizzas, 0, true, 0)\n}", "vc-helpers": "", "vc-spec": "method solve(pizzas: seq<int>) returns (result: string)\n    requires ValidInput(pizzas)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanFulfillRequirements(pizzas)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_548", "vc-description": "Two players play a game on an array of integers, alternating turns.\nFirst player removes subsegments with odd sum, second player removes subsegments with even sum.\nAfter removal, remaining parts are concatenated. Player who cannot move loses.\nDetermine the winner assuming optimal play.", "vc-preamble": "predicate AllEven(a: seq<int>)\n{\n    forall i :: 0 <= i < |a| ==> a[i] % 2 == 0\n}\n\npredicate HasOdd(a: seq<int>)\n{\n    exists i :: 0 <= i < |a| && a[i] % 2 == 1\n}", "vc-helpers": "", "vc-spec": "method solve(a: seq<int>) returns (result: string)\n    ensures result == \"Second\" <==> AllEven(a)\n    ensures result == \"First\" <==> HasOdd(a)\n    ensures result == \"First\" || result == \"Second\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_553", "vc-description": "Given n promotional codes (each exactly 6 digits), find the maximum number k such that \nany promotional code can be uniquely identified even when typed with at most k digit errors.\nThis requires finding the minimum Hamming distance between any pair of promotional codes,\nthen computing k = floor((min_distance - 1) / 2).", "vc-preamble": "function splitLines(s: string): seq<string>\n    requires |s| > 0\n    ensures |splitLines(s)| >= 1\n{\n    [s]\n}\n\nfunction parseInteger(s: string): int\n    requires |s| > 0\n{\n    6\n}\n\nfunction hammingDistance(s1: string, s2: string): int\n    requires |s1| == |s2| == 6\n    ensures 0 <= hammingDistance(s1, s2) <= 6\n    ensures hammingDistance(s1, s2) == 0 <==> s1 == s2\n{\n    if s1 == s2 then 0 else 6\n}\n\npredicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0\n}\n\npredicate ValidOutput(output: string, stdin_input: string)\n    requires ValidInput(stdin_input)\n{\n    |output| >= 2 &&\n    output[|output|-1] == '\\n' &&\n    exists lines: seq<string> :: \n        lines == splitLines(stdin_input) &&\n        |lines| >= 1 &&\n        exists n: int :: \n            n >= 1 && \n            n == 6 &&\n            |lines| >= 1 &&\n            exists k: int :: \n                0 <= k <= 6 &&\n                k == 6 &&\n                parseInteger(output[0..|output|-1]) == k\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (output: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(output, stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_56", "vc-description": "Simulate pouring champagne into a pyramid of glasses for t seconds.\nThe pyramid has n levels where level i has i glasses (1-indexed).\nEach second, 1 unit is poured into the top glass. Each glass has capacity 1.\nWhen a glass overflows, excess champagne splits equally to the two glasses below.\nCount the number of completely full glasses after t seconds.", "vc-preamble": "predicate ValidInput(n: int, t: int) {\n  1 <= n <= 10 && 0 <= t <= 10000\n}\n\nfunction TotalGlasses(n: int): int {\n  n * (n + 1) / 2\n}\n\npredicate ValidResult(result: int, n: int, t: int) {\n  result >= 0 && result <= TotalGlasses(n)\n}\n\npredicate CorrectForEdgeCases(result: int, n: int, t: int) {\n  (t == 0 ==> result == 0) &&\n  (n == 1 && t >= 1 ==> result == 1) &&\n  (n == 1 && t == 0 ==> result == 0) &&\n  (t >= 1 && n > 1 ==> result >= 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, t: int) returns (result: int)\n  requires ValidInput(n, t)\n  ensures ValidResult(result, n, t)\n  ensures CorrectForEdgeCases(result, n, t)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_566", "vc-description": "Given r red balloons, g green balloons, and b blue balloons, determine the maximum number of tables that can be decorated.\nEach table requires exactly 3 balloons, and no table can have all 3 balloons of the same color.", "vc-preamble": "predicate ValidInput(r: int, g: int, b: int) {\n    r >= 0 && g >= 0 && b >= 0\n}\n\nfunction MaxTables(r: int, g: int, b: int): int\n    requires ValidInput(r, g, b)\n{\n    min(min(min((r + g + b) / 3, r + g), r + b), g + b)\n}\n\nfunction min(a: int, b: int): int {\n    if a <= b then a else b\n}", "vc-helpers": "", "vc-spec": "method solve(r: int, g: int, b: int) returns (result: int)\n    requires ValidInput(r, g, b)\n    ensures result == MaxTables(r, g, b)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_569", "vc-description": "Given a string of lowercase English letters, find the minimum number of character \nchanges needed to make all substrings distinct. If the string length exceeds 26,\nit's impossible since we only have 26 distinct lowercase letters available.", "vc-preamble": "predicate ValidInput(n: int, s: string) {\n    n == |s| && n >= 1\n}\n\nfunction CountDistinctChars(s: string): int {\n    |set c | c in s|\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: int)\n    requires ValidInput(n, s)\n    ensures n > 26 ==> result == -1\n    ensures n <= 26 ==> result >= 0 && result < n\n    ensures n <= 26 ==> result == |s| - CountDistinctChars(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_584", "vc-description": "Given a string containing letters, underscores, and properly matched parentheses,\nfind the length of the longest word outside parentheses and count words inside parentheses.\nWords are maximal sequences of consecutive letters separated by underscores or parentheses.", "vc-preamble": "function IsLetter(c: char): bool\n{\n    ('a' <= c <= 'z') || ('A' <= c <= 'Z')\n}\n\npredicate ValidParentheses(input: string)\n{\n    var newlinePos := FindNewline(input);\n    if newlinePos >= |input| then true\n    else\n        var s := if newlinePos + 1 < |input| then input[newlinePos + 1..] else \"\";\n        IsValidParenthesesSequence(s, 0, 0)\n}\n\npredicate IsValidParenthesesSequence(s: string, pos: int, balance: int)\n    requires 0 <= pos <= |s|\n    requires balance >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| then balance == 0\n    else\n        var c := s[pos];\n        var newBalance := if c == '(' then balance + 1 \n                         else if c == ')' then balance - 1 \n                         else balance;\n        newBalance >= 0 && IsValidParenthesesSequence(s, pos + 1, newBalance)\n}\n\nfunction LongestWordOutside(input: string): int\n{\n    var newlinePos := FindNewline(input);\n    if newlinePos >= |input| then 0\n    else\n        var s := if newlinePos + 1 < |input| then input[newlinePos + 1..] else \"\";\n        ComputeLongestOutside(s, 0, 0, 0, 0)\n}\n\nfunction CountWordsInside(input: string): int\n{\n    var newlinePos := FindNewline(input);\n    if newlinePos >= |input| then 0\n    else\n        var s := if newlinePos + 1 < |input| then input[newlinePos + 1..] else \"\";\n        ComputeCountInside(s, 0, 0, 0)\n}\n\npredicate ValidOutput(input: string, len_out: int, count_in: int)\n{\n    len_out >= 0 && count_in >= 0 &&\n    len_out == LongestWordOutside(input) &&\n    count_in == CountWordsInside(input)\n}\n\nfunction FindNewline(input: string): int\n    ensures 0 <= FindNewline(input) <= |input|\n{\n    FindNewlineHelper(input, 0)\n}\n\nfunction FindNewlineHelper(input: string, pos: int): int\n    requires 0 <= pos <= |input|\n    ensures pos <= FindNewlineHelper(input, pos) <= |input|\n    decreases |input| - pos\n{\n    if pos >= |input| then pos\n    else if input[pos] == '\\n' then pos\n    else FindNewlineHelper(input, pos + 1)\n}\n\nfunction ComputeLongestOutside(s: string, pos: int, balance: int, cur: int, best: int): int\n    requires 0 <= pos <= |s|\n    requires balance >= 0\n    requires cur >= 0 && best >= 0\n    ensures ComputeLongestOutside(s, pos, balance, cur, best) >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| then\n        if cur > best && balance == 0 then cur else best\n    else\n        var c := s[pos];\n        var newBalance := if c == '(' then balance + 1 \n                         else if c == ')' then (if balance > 0 then balance - 1 else 0)\n                         else balance;\n        var newCur := if IsLetter(c) then cur + 1\n                     else if cur > 0 then 0\n                     else cur;\n        var newBest := if !IsLetter(c) && cur > 0 && balance == 0 then\n                          if cur > best then cur else best\n                      else best;\n        ComputeLongestOutside(s, pos + 1, newBalance, newCur, newBest)\n}\n\nfunction ComputeCountInside(s: string, pos: int, balance: int, cur: int): int\n    requires 0 <= pos <= |s|\n    requires balance >= 0\n    requires cur >= 0\n    ensures ComputeCountInside(s, pos, balance, cur) >= 0\n    decreases |s| - pos\n{\n    if pos >= |s| then 0\n    else\n        var c := s[pos];\n        var newBalance := if c == '(' then balance + 1 \n                         else if c == ')' then (if balance > 0 then balance - 1 else 0)\n                         else balance;\n        var newCur := if IsLetter(c) then cur + 1\n                     else if cur > 0 then 0\n                     else cur;\n        var wordEnded := !IsLetter(c) && cur > 0;\n        var countIncrement := if wordEnded && balance > 0 then 1 else 0;\n        countIncrement + ComputeCountInside(s, pos + 1, newBalance, newCur)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: (int, int))\n    requires |input| > 0\n    requires exists i :: 0 <= i < |input| && input[i] == '\\n'\n    requires forall i :: 0 <= i < |input| ==> (IsLetter(input[i]) || input[i] == '_' || input[i] == '(' || input[i] == ')' || input[i] == '\\n' || input[i] == '\\r' || ('0' <= input[i] <= '9'))\n    requires ValidParentheses(input)\n    ensures result.0 >= 0 && result.1 >= 0\n    ensures result.0 == LongestWordOutside(input)\n    ensures result.1 == CountWordsInside(input)\n    ensures ValidOutput(input, result.0, result.1)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_59", "vc-description": "Given an array of n integers where each integer from 1 to n appears exactly once,\ndetermine if the array can be sorted in ascending order using only allowed adjacent swaps.\nYou can swap elements at positions i and i+1 only if the i-th character in a given\nbinary string is '1'. You can perform any number of such swaps in any order.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>, p: string)\n{\n    n >= 2 &&\n    |a| == n &&\n    |p| == n - 1 &&\n    (forall i :: 0 <= i < |p| ==> p[i] == '0' || p[i] == '1') &&\n    (forall i :: 0 <= i < |a| ==> 1 <= a[i] <= n) &&\n    (forall i :: 1 <= i <= n ==> exists j :: 0 <= j < |a| && a[j] == i)\n}\n\nfunction max_up_to(a: seq<int>, i: int): int\n    requires 0 <= i < |a|\n    decreases i\n{\n    if i == 0 then a[0]\n    else if a[i] > max_up_to(a, i-1) then a[i]\n    else max_up_to(a, i-1)\n}\n\npredicate CanSort(n: int, a: seq<int>, p: string)\n    requires ValidInput(n, a, p)\n{\n    forall i :: 0 <= i < n - 1 ==> \n        (p[i] == '0' ==> max_up_to(a, i) <= i + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>, p: string) returns (result: string)\n    requires ValidInput(n, a, p)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> CanSort(n, a, p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_600", "vc-description": "Two friends at integer positions a and b on a number line need to meet at the same position.\nEach move costs increasing tiredness: 1st move costs 1, 2nd move costs 2, etc.\nFind the minimum total tiredness for both friends to meet.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    a >= 1 && a <= 1000 && b >= 1 && b <= 1000 && a != b\n}\n\nfunction OptimalMeetingPoint(a: int, b: int): int\n{\n    (a + b) / 2\n}\n\nfunction MinimumTotalTiredness(a: int, b: int): int\n    requires ValidInput(a, b)\n{\n    var c := OptimalMeetingPoint(a, b);\n    tirednessForSteps(abs(c - a)) + tirednessForSteps(abs(b - c))\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result >= 0\n    ensures result == MinimumTotalTiredness(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_601", "vc-description": "Given two people with carrying capacities p and f, and a shop containing cnt_s swords\n(each weighing s units) and cnt_w war axes (each weighing w units), find the maximum\ntotal number of items both people can carry. The input contains multiple test cases.", "vc-preamble": "predicate validInput(input: string)\n{\n    |input| > 0 && \n    var lines := splitFunc(input, '\\n');\n    |lines| >= 1 &&\n    parseIntFunc(lines[0]) >= 0 &&\n    |lines| >= 1 + 3 * parseIntFunc(lines[0])\n}\n\nfunction processTestCases(input: string): seq<int>\n    requires validInput(input)\n{\n    var lines := splitFunc(input, '\\n');\n    var t := parseIntFunc(lines[0]);\n    processTestCasesHelper(input, lines, 1, 0, t, [])\n}\n\nfunction formatOutput(results: seq<int>): string\n{\n    formatOutputHelper(results, 0, \"\")\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    requires validInput(input)\n    ensures |result| >= 0\n    ensures result == formatOutput(processTestCases(input))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_602", "vc-description": "Given an integer a (1 \u2264 a \u2264 40), output the last name of the a-th President of the United States.", "vc-preamble": "predicate ValidInput(a: int) {\n    1 <= a <= 40\n}\n\nfunction Presidents(): seq<string> {\n    [\n        \"Washington\", \"Adams\", \"Jefferson\", \"Madison\", \"Monroe\", \"Adams\", \"Jackson\", \n        \"Van Buren\", \"Harrison\", \"Tyler\", \"Polk\", \"Taylor\", \"Fillmore\", \"Pierce\", \n        \"Buchanan\", \"Lincoln\", \"Johnson\", \"Grant\", \"Hayes\", \"Garfield\", \"Arthur\", \n        \"Cleveland\", \"Harrison\", \"Cleveland\", \"McKinley\", \"Roosevelt\", \"Taft\", \n        \"Wilson\", \"Harding\", \"Coolidge\", \"Hoover\", \"Roosevelt\", \"Truman\", \n        \"Eisenhower\", \"Kennedy\", \"Johnson\", \"Nixon\", \"Ford\", \"Carter\", \"Reagan\"\n    ]\n}", "vc-helpers": "", "vc-spec": "method solve(a: int) returns (result: string)\n    requires ValidInput(a)\n    ensures result == Presidents()[a - 1]", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_604", "vc-description": "Given an array of integers, find the minimum number of seconds needed to make all elements zero.\nIn each second, you can add an arbitrary integer to all non-zero elements in the array.\nThe key insight is that the answer equals the number of distinct non-zero values in the array.\n\n// No specific constraints on input beyond being a sequence of integers", "vc-preamble": "predicate ValidInput(arr: seq<int>) {\n    true\n}\n\nfunction DistinctNonZeroCount(arr: seq<int>): int {\n    |set x | x in arr && x != 0|\n}", "vc-helpers": "", "vc-spec": "method solve(arr: seq<int>) returns (result: int)\n    requires ValidInput(arr)\n    ensures result >= 0\n    ensures result <= |arr|\n    ensures result == DistinctNonZeroCount(arr)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_605", "vc-description": "Compare scores of two contestants Misha and Vasya in a programming contest.\nMisha solved a problem worth 'a' points and submitted it 'c' minutes after start.\nVasya solved a problem worth 'b' points and submitted it 'd' minutes after start.\nScoring formula: max(3p/10, p - p*t/250) where p is original points, t is time.\nReturn \"Misha\", \"Vasya\", or \"Tie\" based on who scored higher.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int)\n{\n    250 <= a <= 3500 && a % 250 == 0 &&\n    250 <= b <= 3500 && b % 250 == 0 &&\n    0 <= c <= 180 &&\n    0 <= d <= 180\n}\n\nfunction CalculateScore(points: int, time: int): real\n    requires points >= 0 && time >= 0\n{\n    var min_score := 3.0 * points as real / 10.0;\n    var time_adjusted := points as real - points as real * time as real / 250.0;\n    if min_score >= time_adjusted then min_score else time_adjusted\n}\n\npredicate CorrectResult(a: int, b: int, c: int, d: int, result: string)\n    requires ValidInput(a, b, c, d)\n{\n    var misha_score := CalculateScore(a, c);\n    var vasya_score := CalculateScore(b, d);\n    (result == \"Misha\" <==> misha_score > vasya_score) &&\n    (result == \"Vasya\" <==> vasya_score > misha_score) &&\n    (result == \"Tie\" <==> misha_score == vasya_score)\n}", "vc-helpers": "", "vc-spec": "method DetermineWinner(a: int, b: int, c: int, d: int) returns (result: string)\n    requires ValidInput(a, b, c, d)\n    ensures result == \"Misha\" || result == \"Vasya\" || result == \"Tie\"\n    ensures CorrectResult(a, b, c, d, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_607", "vc-description": "Given integers n and m, compute the sum of happiness values for all permutations of length n, \nmodulo prime number m. A permutation's happiness is the count of its framed segments, where\na framed segment [l,r] satisfies max{elements} - min{elements} = r - l.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 && \n    (var nm := ParseTwoInts(input);\n     var n := nm.0; var m := nm.1;\n     n > 0 && m > 0)\n}\n\nfunction ParseTwoInts(input: string): (int, int)\n    requires |input| > 0\n{\n    var lines := SplitLinesFunc(input);\n    if |lines| == 0 then (0, 0)\n    else \n        var parts := SplitSpacesFunc(lines[0]);\n        if |parts| < 2 then (0, 0)\n        else (StringToInt(parts[0]), StringToInt(parts[1]))\n}\n\nfunction ComputeHappinessSum(n: int, m: int): int\n    requires n > 0 && m > 0\n{\n    SumUpToSize(n, m, n)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (output: string)\n    requires |input| > 0\n    ensures |output| >= 0\n    ensures ValidInput(input) ==> \n        (var nm := ParseTwoInts(input);\n         var n := nm.0; var m := nm.1;\n         output == IntToString(ComputeHappinessSum(n, m)) + \"\\n\")\n    ensures ValidInput(input) ==> |output| > 0 && output[|output|-1] == '\\n'\n    ensures ValidInput(input) ==> forall c :: c in output ==> (c == '\\n' || ('0' <= c <= '9'))\n    ensures !ValidInput(input) ==> output == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_610", "vc-description": "Given n red cubes and m blue cubes, two players take turns placing cubes in a line.\nPetya moves first and wants to maximize same-color adjacent pairs.\nVasya moves second and wants to maximize different-color adjacent pairs.\nBoth players play optimally. Calculate final scores for both players.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n  n >= 1 && m >= 1\n}\n\nfunction OptimalVasyaScore(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  if n < m then n else m\n}\n\nfunction OptimalPetyaScore(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  n + m - 1 - OptimalVasyaScore(n, m)\n}\n\nfunction TotalAdjacentPairs(n: int, m: int): int\n  requires ValidInput(n, m)\n{\n  n + m - 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (petyaScore: int, vasyaScore: int)\n  requires ValidInput(n, m)\n  ensures vasyaScore == OptimalVasyaScore(n, m)\n  ensures petyaScore == OptimalPetyaScore(n, m)\n  ensures petyaScore + vasyaScore == TotalAdjacentPairs(n, m)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_613", "vc-description": "Find the number of polynomials P(x) with non-negative integer coefficients \nsuch that P(t) = a and P(P(t)) = b, where t, a, and b are given positive integers.\nSince P(t) = a, the second condition becomes P(a) = b.\nOutput \"inf\" if infinitely many such polynomials exist, otherwise output the count.", "vc-preamble": "predicate ValidInput(t: int, a: int, b: int)\n{\n    t > 0 && a > 0 && b > 0\n}\n\npredicate ValidOutput(res: string)\n{\n    res == \"0\" || res == \"1\" || res == \"2\" || res == \"inf\"\n}\n\npredicate InfiniteCase(t: int, a: int, b: int)\n{\n    a == t && a == b && a == 1\n}\n\npredicate TwoSolutionsCase(t: int, a: int, b: int)\n{\n    a == t && a == b && a != 1\n}\n\npredicate ZeroSolutionsCase(t: int, a: int, b: int)\n{\n    (t == 2 && a == 3 && b > 10000) ||\n    (a == t && a != b) ||\n    (a != t && (a - b) % (t - a) == 0) ||\n    (a != t && (a - b) % (t - a) != 0 && t == b)\n}\n\npredicate OneSolutionCase(t: int, a: int, b: int)\n{\n    a != t && (a - b) % (t - a) != 0 && t != b\n}", "vc-helpers": "", "vc-spec": "method solve(t: int, a: int, b: int) returns (res: string)\n    requires ValidInput(t, a, b)\n    requires t != a || a == t\n    ensures ValidOutput(res)\n    ensures InfiniteCase(t, a, b) ==> res == \"inf\"\n    ensures TwoSolutionsCase(t, a, b) ==> res == \"2\"\n    ensures ZeroSolutionsCase(t, a, b) ==> res == \"0\"\n    ensures OneSolutionCase(t, a, b) ==> res == \"1\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_619", "vc-description": "Sasha has x chizhiks and Masha has y chizhiks. Coconuts cost z chizhiks each.\nFind the maximum number of coconuts they can buy together by potentially exchanging\nchizhiks, and determine the minimum number of chizhiks that must be exchanged.", "vc-preamble": "predicate ValidInput(x: int, y: int, z: int)\n{\n  x >= 0 && y >= 0 && z > 0\n}\n\nfunction MaxCoconuts(x: int, y: int, z: int): int\n  requires ValidInput(x, y, z)\n{\n  (x + y) / z\n}\n\nfunction MinExchange(x: int, y: int, z: int): int\n  requires ValidInput(x, y, z)\n{\n  var rx := x % z;\n  var ry := y % z;\n  if rx + ry < z then 0\n  else z - if rx > ry then rx else ry\n}", "vc-helpers": "", "vc-spec": "method solve(x: int, y: int, z: int) returns (coconuts: int, exchange: int)\n  requires ValidInput(x, y, z)\n  ensures coconuts == MaxCoconuts(x, y, z)\n  ensures exchange == MinExchange(x, y, z)\n  ensures coconuts >= x / z + y / z\n  ensures coconuts <= x / z + y / z + 1\n  ensures exchange >= 0 && exchange < z", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_62", "vc-description": "Two players play a game on a sequence of n non-negative integers. Each player can either\nreduce a single element by some value or globally reduce all elements by the minimum value.\nThe player who cannot make a move (all elements are 0) loses. Determine the winner assuming\nboth players play optimally.", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    (stdin_input[|stdin_input|-1] == '\\n' || !('\\n' in stdin_input))\n}\n\npredicate ValidResult(result: string)\n{\n    result == \"BitAryo\" || result == \"BitLGM\"\n}\n\nfunction GameResult(stdin_input: string): string\n    requires ValidInput(stdin_input)\n{\n    var lines := splitLines(stdin_input);\n    if |lines| >= 1 then\n        var n := parseInt(lines[0]);\n        if n == 3 && |lines| >= 2 then\n            var values := parseInts(lines[1]);\n            if |values| == 3 then\n                var xorResult := xorSequence(values);\n                if xorResult == 0 then \"BitAryo\" else \"BitLGM\"\n            else \"BitLGM\"\n        else if n == 2 && |lines| >= 2 then\n            var values := parseInts(lines[1]);\n            if |values| == 2 && values[0] >= 0 && values[1] >= 0 then\n                var sortedValues := if values[0] <= values[1] then values else [values[1], values[0]];\n                if goldenRatioRelation(sortedValues) then \"BitAryo\" else \"BitLGM\"\n            else \"BitLGM\"\n        else if |lines| >= 2 then\n            var value := parseInt(lines[1]);\n            if value == 0 then \"BitAryo\" else \"BitLGM\"\n        else \"BitLGM\"\n    else \"BitLGM\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidResult(result)\n    ensures result == GameResult(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_623", "vc-description": "Given two joysticks with initial charge levels a1 and a2 percent, determine the maximum number of minutes a game can last.\nEach minute, exactly one joystick must be connected to a charger (gains 1% charge) while the other loses 2% charge.\nGame continues while both joysticks have positive charge (> 0%). If a joystick has exactly 1% charge at the start of a minute,\nit must be charged to avoid reaching 0%. Find the maximum number of minutes before at least one joystick reaches 0% charge.", "vc-preamble": "function CountValidMinutes(a: int, b: int): int\n    requires a >= 0 && b >= 0\n    decreases a + b\n{\n    if a <= 0 || b <= 0 then 0\n    else if a == 1 && b == 1 then 0\n    else (if a > 1 || b > 1 then 1 else 0) + \n         CountValidMinutes(if a < b then a + 1 else a - 2, if a < b then b - 2 else b + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(a1: int, a2: int) returns (result: int)\n    requires a1 >= 1 && a2 >= 1\n    ensures result >= 0\n    ensures result == CountValidMinutes(a1, a2)\n    ensures (a1 == 1 && a2 == 1) ==> result == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_625", "vc-description": "Given a positive integer n, calculate the value of the alternating sum:\nf(n) = -1 + 2 - 3 + 4 - 5 + ... + (-1)^n \u00d7 n", "vc-preamble": "function AlternatingSum(n: int): int\n    requires n > 0\n{\n    if n == 1 then -1\n    else AlternatingSum(n-1) + (if n % 2 == 0 then n else -n)\n}\n\npredicate ValidInput(n: int) {\n    n > 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures result == AlternatingSum(n)\n    ensures n % 2 == 0 ==> result == n / 2\n    ensures n % 2 != 0 ==> result == n / 2 - n", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_631", "vc-description": "Given an array of n integers, determine if it's possible to reorder the elements \nto make the double sum equal a target value m. The double sum is defined as\nsum over i from 1 to n of (sum over j from i to n of a_j/j).\nNo elements may be added or removed from the array.", "vc-preamble": "predicate valid_input_format(s: string)\n{\n    |s| >= 7 && \n    exists pos :: 0 < pos < |s| && s[pos] == '\\n'\n}\n\nfunction get_test_count(stdin_input: string): int\n    requires valid_input_format(stdin_input)\n    ensures get_test_count(stdin_input) >= 1\n{\n    1\n}\n\nfunction get_array_sum(stdin_input: string, test_idx: int): int\n    requires valid_input_format(stdin_input)\n    requires 0 <= test_idx < get_test_count(stdin_input)\n{\n    0\n}\n\nfunction get_target_m(stdin_input: string, test_idx: int): int\n    requires valid_input_format(stdin_input)\n    requires 0 <= test_idx < get_test_count(stdin_input)\n{\n    0\n}\n\nfunction expected_output_for_input(stdin_input: string): string\n    requires valid_input_format(stdin_input)\n{\n    compute_expected_output(stdin_input, 0, get_test_count(stdin_input))\n}\n\npredicate behavioral_correctness(stdin_input: string, result: string)\n    requires valid_input_format(stdin_input)\n{\n    var T := get_test_count(stdin_input);\n    count_responses(result) == T &&\n    (forall i :: 0 <= i < T ==>\n        var array_sum := get_array_sum(stdin_input, i);\n        var target_m := get_target_m(stdin_input, i);\n        var response := get_response_at_index(result, i);\n        (array_sum == target_m <==> response == \"YES\\n\") &&\n        (array_sum != target_m <==> response == \"NO\\n\"))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires valid_input_format(stdin_input)\n    requires |stdin_input| > 0\n    requires stdin_input != \"\"\n    requires '\\n' in stdin_input\n    requires exists pos :: 0 <= pos < |stdin_input| && stdin_input[pos] == '\\n'\n    requires forall i :: 0 <= i < |stdin_input| ==> \n        stdin_input[i] in", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_641", "vc-description": "Calculate how many candies will be saved in the year 2016 based on a savings plan.\nInput format: \"x of week\" (x=1-7, Monday-Sunday) or \"x of month\" (x=1-31).\nSave one candy on the specified day each week/month.\n2016 is a leap year starting on Friday, week starts on Monday.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0 &&\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var parts := SplitOnSpace(trimmed);\n    |parts| >= 1\n}\n\nfunction GetExpectedResult(input: string): string\n    requires ValidInput(input)\n{\n    var trimmed := if |input| > 0 && input[|input|-1] == '\\n' then input[..|input|-1] else input;\n    var parts := SplitOnSpace(trimmed);\n    if parts[|parts|-1] == \"month\" then\n        if parts[0] == \"31\" then \"7\\n\"\n        else if parts[0] == \"30\" then \"11\\n\"\n        else \"12\\n\"\n    else\n        if parts[0] == \"5\" || parts[0] == \"6\" then \"53\\n\"\n        else \"52\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == GetExpectedResult(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_644", "vc-description": "Execute a sequence of commands (for n, end, add) that manipulate an integer variable x starting at 0.\nCommands form valid nested loops. Check if x exceeds 2^32 - 1 at any point during execution.\nReturn \"OVERFLOW!!!\" if overflow occurs, otherwise return the final value of x.", "vc-preamble": "predicate ValidInput(lines: seq<string>)\n{\n    |lines| > 0\n}\n\nfunction MAX_VALUE(): int { 4294967295 }\n\npredicate IsOverflow(x: int)\n{\n    x > MAX_VALUE()\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput([input])\n    ensures result == \"OVERFLOW!!!\" || result != \"OVERFLOW!!!\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_645", "vc-description": "Given n cards with letters/digits, determine minimum cards to flip to verify:\n\"If a card has a vowel on one side, then it has an even digit on the other side.\"\nInput: string representing visible sides. Output: minimum flips needed.", "vc-preamble": "predicate IsVowel(c: char) {\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n}\n\npredicate IsOddDigit(c: char) {\n  c == '1' || c == '3' || c == '5' || c == '7' || c == '9'\n}\n\npredicate NeedsFlipping(c: char) {\n  IsVowel(c) || IsOddDigit(c)\n}\n\nfunction CountFlips(s: string): int {\n  |set i | 0 <= i < |s| && NeedsFlipping(s[i])|\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n  requires |s| >= 1 && |s| <= 50\n  ensures |result| > 0\n  ensures result == toString(CountFlips(s)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_648", "vc-description": "Given integers m and b, find the maximum sum of bananas that can be collected from an optimally placed rectangle.\nEach lattice point (x,y) where x,y >= 0 contains x+y bananas.\nA line is defined by y = -x/m + b.\nA rectangle with axis-aligned sides can be placed anywhere such that all points are on or under the line.\nThe rectangle can be degenerate (a line segment or single point).", "vc-preamble": "predicate ValidInput(m: int, b: int)\n{\n  1 <= m <= 1000 && 1 <= b <= 10000\n}\n\nfunction f(x: int, y: int): int\n  requires x >= 0 && y >= 0\n{\n  (x * (x + 1) * (y + 1) + y * (y + 1) * (x + 1)) / 2\n}\n\npredicate ValidRectangleCorner(k: int, m: int, b: int)\n{\n  0 <= k && b - k >= 0\n}\n\nfunction RectangleValue(k: int, m: int, b: int): int\n  requires ValidRectangleCorner(k, m, b)\n  requires m >= 1\n{\n  f(k * m, b - k)\n}", "vc-helpers": "", "vc-spec": "method solve(m: int, b: int) returns (result: int)\n  requires ValidInput(m, b)\n  ensures result >= -1\n  ensures forall k :: ValidRectangleCorner(k, m, b) ==> result >= RectangleValue(k, m, b)\n  ensures exists k :: ValidRectangleCorner(k, m, b) && result == RectangleValue(k, m, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_65", "vc-description": "Given an array of integers, find the minimum distance between any two occurrences \nof the minimum value in the array. The minimum value is guaranteed to appear at least twice.", "vc-preamble": "function seq_min(s: seq<int>): int\n    requires |s| > 0\n    ensures seq_min(s) in s\n    ensures forall k :: 0 <= k < |s| ==> seq_min(s) <= s[k]\n{\n    if |s| == 1 then s[0]\n    else if s[0] <= seq_min(s[1..]) then s[0]\n    else seq_min(s[1..])\n}\n\npredicate ValidInput(arr: seq<int>)\n{\n    |arr| >= 2 && \n    exists i, j :: 0 <= i < j < |arr| && arr[i] == arr[j] == seq_min(arr)\n}", "vc-helpers": "", "vc-spec": "method solve(arr: seq<int>) returns (result: int)\n    requires ValidInput(arr)\n    ensures result > 0\n    ensures result <= |arr| - 1\n    ensures exists i, j :: 0 <= i < j < |arr| && arr[i] == arr[j] == seq_min(arr) && j - i == result\n    ensures forall i, j :: 0 <= i < j < |arr| && arr[i] == arr[j] == seq_min(arr) ==> j - i >= result", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_650", "vc-description": "Given a string of uppercase letters A-Z with length 1-10, determine if all letters\nbelong to the same predefined group. Group 1: A,E,F,H,I,K,L,M,N,T,V,W,X,Y,Z.\nGroup 2: B,C,D,G,J,O,P,Q,R,S,U. Output \"YES\" if all letters in same group, \"NO\" otherwise.", "vc-preamble": "predicate ValidInput(word: string) \n{\n    1 <= |word| <= 10 && forall i :: 0 <= i < |word| ==> 'A' <= word[i] <= 'Z'\n}\n\nfunction Group1(): string { \"AEFHIKLMNTVWXYZ\" }\nfunction Group2(): string { \"BCDGJOPQRSU\" }\n\npredicate AllInGroup1(word: string)\n{\n    forall i :: 0 <= i < |word| ==> word[i] in Group1()\n}\n\npredicate AllInGroup2(word: string)\n{\n    forall i :: 0 <= i < |word| ==> word[i] in Group2()\n}\n\npredicate AllInSameGroup(word: string)\n{\n    AllInGroup1(word) || AllInGroup2(word)\n}", "vc-helpers": "", "vc-spec": "method solve(word: string) returns (result: string)\n    requires ValidInput(word)\n    ensures AllInSameGroup(word) <==> result == \"YES\"\n    ensures result == \"YES\" || result == \"NO\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_651", "vc-description": "Given a 2D maze and a sequence of movement instructions (digits 0-3), determine how many ways\nthe instructions can be interpreted to successfully navigate from start to exit. Each digit\nmust map to a unique direction (up, down, left, right). The robot stops upon reaching the exit\nor crashes when hitting obstacles/boundaries.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 3 &&\n    HasValidDimensions(lines) &&\n    HasValidGrid(lines) &&\n    HasStartAndEnd(lines) &&\n    HasValidPath(lines)\n}\n\npredicate HasValidDimensions(lines: seq<string>)\n    requires |lines| >= 1\n{\n    var dimensions := ParseTwoInts(lines[0]);\n    var n := dimensions.0;\n    var m := dimensions.1;\n    n > 0 && m > 0 && |lines| >= n + 2\n}\n\npredicate HasValidGrid(lines: seq<string>)\n    requires |lines| >= 1\n{\n    var dimensions := ParseTwoInts(lines[0]);\n    var n := dimensions.0;\n    var m := dimensions.1;\n    n > 0 && m > 0 && |lines| >= n + 2 &&\n    forall i :: 1 <= i <= n && i < |lines| ==>\n        forall j :: 0 <= j < |lines[i]| && j < m ==>\n            lines[i][j] in {'.', '#', 'S', 'E'}\n}\n\npredicate HasStartAndEnd(lines: seq<string>)\n    requires |lines| >= 1\n{\n    var dimensions := ParseTwoInts(lines[0]);\n    var n := dimensions.0;\n    var m := dimensions.1;\n    n > 0 && m > 0 && |lines| >= n + 2 &&\n    (exists i, j :: 1 <= i <= n && i < |lines| && 0 <= j < |lines[i]| && j < m && lines[i][j] == 'S') &&\n    (exists i, j :: 1 <= i <= n && i < |lines| && 0 <= j < |lines[i]| && j < m && lines[i][j] == 'E') &&\n    CountOccurrences(lines, n, m, 'S') == 1 &&\n    CountOccurrences(lines, n, m, 'E') == 1\n}\n\npredicate HasValidPath(lines: seq<string>)\n    requires |lines| >= 1\n{\n    var dimensions := ParseTwoInts(lines[0]);\n    var n := dimensions.0;\n    var m := dimensions.1;\n    n > 0 && m > 0 && |lines| >= n + 2 &&\n    ValidPathString(lines[n + 1])\n}\n\npredicate ValidPathString(path: string)\n{\n    forall i :: 0 <= i < |path| ==> '0' <= path[i] <= '3'\n}\n\npredicate ValidResult(result: string)\n{\n    |result| > 0 &&\n    forall c :: c in result ==> ('0' <= c <= '9') || c == '\\n'\n}\n\nfunction CountValidWays(input: string): int\n    requires ValidInput(input)\n    ensures CountValidWays(input) >= 0\n    ensures CountValidWays(input) <= 24\n{\n    var lines := SplitLines(input);\n    var dimensions := ParseTwoInts(lines[0]);\n    var n := dimensions.0;\n    var m := dimensions.1;\n    var start := FindStart(lines, n, m);\n    var end := FindEnd(lines, n, m);\n    var path := lines[n + 1];\n    CountPermutationsReachingGoal(lines, n, m, path, start, end)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    ensures ValidResult(result)\n    ensures var numResult := StringToInt(if '\\n' in result then result[..|result|-1] else result);\n            0 <= numResult <= 24\n    ensures ValidInput(stdin_input) ==>\n            var numResult := StringToInt(if '\\n' in result then result[..|result|-1] else result);\n            numResult == CountValidWays(stdin_input)\n    ensures !ValidInput(stdin_input) ==>\n            StringToInt(if '\\n' in result then result[..|result|-1] else result) == 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_656", "vc-description": "Given n winter days with temperature forecasts, minimize tire changes to drive safely.\nStart with summer tires (safe when temp >= 0). Winter tires safe at any temp but \nlimited to k days total. Must drive safely every day. Can change tires at start of any day.\nReturn minimum tire changes needed, or -1 if impossible.", "vc-preamble": "function count_negative_temp_days(temps: seq<int>): int\n{\n    if |temps| == 0 then 0\n    else (if temps[0] < 0 then 1 else 0) + count_negative_temp_days(temps[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, temps: seq<int>) returns (result: int)\n  requires n >= 1\n  requires k >= 0 && k <= n\n  requires |temps| == n\n  requires forall i :: 0 <= i < n ==> -20 <= temps[i] <= 20\n  ensures result == -1 <==> count_negative_temp_days(temps) > k\n  ensures result != -1 ==> result >= 0\n  ensures result == 0 ==> forall i :: 0 <= i < n ==> temps[i] >= 0\n  ensures result > 0 ==> exists i :: 0 <= i < n && temps[i] < 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_657", "vc-description": "Given initial counts of yellow and blue crystals, determine the minimum additional crystals needed to produce a specified number of colored balls.\nYellow ball requires 2 yellow crystals, green ball requires 1 yellow + 1 blue crystal, blue ball requires 3 blue crystals.", "vc-preamble": "function max(a: int, b: int): int\n{\n    if a >= b then a else b\n}\n\npredicate ValidInput(a: int, b: int, x: int, y: int, z: int)\n{\n    a >= 0 && b >= 0 && x >= 0 && y >= 0 && z >= 0\n}\n\nfunction YellowCrystalsNeeded(x: int, y: int): int\n{\n    x * 2 + y\n}\n\nfunction BlueCrystalsNeeded(y: int, z: int): int\n{\n    y + z * 3\n}\n\nfunction MinAdditionalCrystals(a: int, b: int, x: int, y: int, z: int): int\n{\n    max(0, YellowCrystalsNeeded(x, y) - a) + max(0, BlueCrystalsNeeded(y, z) - b)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, x: int, y: int, z: int) returns (result: int)\n    requires ValidInput(a, b, x, y, z)\n    ensures result >= 0\n    ensures result == MinAdditionalCrystals(a, b, x, y, z)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_66", "vc-description": "Two athletes Willman and Bolt compete in a race with step lengths w and b meters respectively.\nThe race distance L is chosen uniformly at random from integers 1 to t (inclusive).\nEach athlete can take at most floor(L/step_length) steps, traveling floor(L/step_length) * step_length distance.\nThey tie when they travel the same total distance: floor(L/w) * w = floor(L/b) * b.\nFind the probability that they tie, expressed as an irreducible fraction.", "vc-preamble": "predicate ValidInput(t: int, w: int, b: int)\n{\n  t > 0 && w > 0 && b > 0\n}\n\npredicate ValidFraction(numerator: int, denominator: int)\n{\n  numerator >= 0 && denominator > 0 && numerator <= denominator\n}\n\npredicate IsIrreducibleFraction(numerator: int, denominator: int)\n  requires ValidFraction(numerator, denominator)\n{\n  gcd(numerator, denominator) == 1\n}", "vc-helpers": "", "vc-spec": "method solve(t: int, w: int, b: int) returns (numerator: int, denominator: int)\n  requires ValidInput(t, w, b)\n  ensures ValidFraction(numerator, denominator)\n  ensures IsIrreducibleFraction(numerator, denominator)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_666", "vc-description": "Find the n-th element (1-indexed) in an infinite sequence constructed as blocks:\nBlock 1: [1], Block 2: [1,2], Block 3: [1,2,3], etc.\nThe complete sequence is: 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5, ...", "vc-preamble": "function TriangularNumber(m: int): int\n    requires m >= 0\n{\n    m * (m + 1) / 2\n}\n\npredicate ValidInput(n: int)\n{\n    n >= 1\n}\n\npredicate ValidResult(n: int, result: int)\n    requires ValidInput(n)\n{\n    result >= 1 && result <= n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures ValidResult(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_673", "vc-description": "Given two integers n and k, find the smallest integer x such that x > n and x is divisible by k.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n    n >= 1 && k > 0\n}\n\npredicate IsCorrectResult(n: int, k: int, result: int)\n    requires k > 0\n{\n    result > n && result % k == 0 && forall x :: n < x < result ==> x % k != 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n    requires ValidInput(n, k)\n    ensures IsCorrectResult(n, k, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_679", "vc-description": "Given a string representing a row of cells with flowers (A, B, C) or empty cells (.),\ndetermine if it's possible for at least one cell to contain all three colors after\nsome flowers wither and spread petals to adjacent cells.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 0 && forall i :: 0 <= i < |s| ==> s[i] in {'A', 'B', 'C', '.'}\n}\n\npredicate HasAllThreeColors(s: string, start: int)\n    requires 0 <= start <= |s| - 3\n{\n    'A' in s[start..start+3] && 'B' in s[start..start+3] && 'C' in s[start..start+3]\n}\n\npredicate PossibleToGetAllColors(s: string)\n{\n    |s| >= 3 && exists i :: 0 <= i <= |s| - 3 && HasAllThreeColors(s, i)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures result == \"Yes\" ==> PossibleToGetAllColors(s)\n    ensures result == \"No\" ==> !PossibleToGetAllColors(s)\n    ensures result == \"Yes\" || result == \"No\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_682", "vc-description": "Given starting position (r1, c1) and ending position (r2, c2) on an 8\u00d78 chessboard,\nfind the minimum number of moves required for a rook, bishop, and king to move from\nthe starting position to the ending position. Return 0 if a piece cannot reach the destination.", "vc-preamble": "predicate ValidPosition(r: int, c: int)\n{\n    1 <= r <= 8 && 1 <= c <= 8\n}\n\nfunction RookMoves(r1: int, c1: int, r2: int, c2: int): int\n    requires ValidPosition(r1, c1) && ValidPosition(r2, c2)\n{\n    if r1 == r2 && c1 == c2 then 0\n    else if r1 == r2 || c1 == c2 then 1\n    else 2\n}\n\nfunction BishopMoves(r1: int, c1: int, r2: int, c2: int): int\n    requires ValidPosition(r1, c1) && ValidPosition(r2, c2)\n{\n    if r1 == r2 && c1 == c2 then 0\n    else \n        var row_diff := if r1 >= r2 then r1 - r2 else r2 - r1;\n        var col_diff := if c1 >= c2 then c1 - c2 else c2 - c1;\n        if row_diff == col_diff then 1\n        else if (r1 + c1) % 2 == (r2 + c2) % 2 then 2\n        else 0\n}\n\nfunction KingMoves(r1: int, c1: int, r2: int, c2: int): int\n    requires ValidPosition(r1, c1) && ValidPosition(r2, c2)\n{\n    var row_diff := if r1 >= r2 then r1 - r2 else r2 - r1;\n    var col_diff := if c1 >= c2 then c1 - c2 else c2 - c1;\n    if row_diff >= col_diff then row_diff else col_diff\n}\n\npredicate ValidResult(result: seq<int>, r1: int, c1: int, r2: int, c2: int)\n    requires ValidPosition(r1, c1) && ValidPosition(r2, c2)\n{\n    |result| == 3 &&\n    result[0] == RookMoves(r1, c1, r2, c2) &&\n    result[1] == BishopMoves(r1, c1, r2, c2) &&\n    result[2] == KingMoves(r1, c1, r2, c2)\n}", "vc-helpers": "", "vc-spec": "method solve(r1: int, c1: int, r2: int, c2: int) returns (result: seq<int>)\n    requires ValidPosition(r1, c1) && ValidPosition(r2, c2)\n    ensures ValidResult(result, r1, c1, r2, c2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_696", "vc-description": "Given a prime number p, find the count of primitive roots modulo p.\nA primitive root modulo prime p is an integer x where 1 \u2264 x < p such that\nx^k \u2262 1 (mod p) for all positive integers k < p-1, but x^(p-1) \u2261 1 (mod p).", "vc-preamble": "predicate ValidInput(p: int) {\n    2 <= p < 2000\n}\n\nfunction CountPrimitiveRoots(p: int): int\n    requires ValidInput(p)\n{\n    if p == 2 then 1\n    else |set i | 1 <= i < p-1 && (forall j :: 2 <= j <= i ==> !((p-1) % j == 0 && i % j == 0))|\n}", "vc-helpers": "", "vc-spec": "method solve(p: int) returns (result: int)\n    requires ValidInput(p)\n    ensures result >= 0\n    ensures result == CountPrimitiveRoots(p)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_701", "vc-description": "Given two distinct strings s and t, determine if s can be transformed into t using character removal and/or character swapping operations.\nReturn \"array\" if only swapping needed, \"automaton\" if only removal needed, \"both\" if both operations needed, or \"need tree\" if impossible.", "vc-preamble": "function ParseLines(stdin_input: string): seq<string>\n    decreases |stdin_input|\n{\n    if |stdin_input| == 0 then []\n    else\n        var newline_pos := FindNewline(stdin_input, 0);\n        if newline_pos == -1 then [stdin_input]\n        else if newline_pos == 0 then ParseLines(stdin_input[1..])\n        else if newline_pos < |stdin_input| && newline_pos >= 0\n        then [stdin_input[..newline_pos]] + ParseLines(stdin_input[newline_pos+1..])\n        else []\n}\n\nfunction FindNewline(s: string, start: int): int\n    requires 0 <= start\n    decreases |s| - start\n    ensures FindNewline(s, start) == -1 || (start <= FindNewline(s, start) < |s|)\n{\n    if start >= |s| then -1\n    else if s[start] == '\\n' then start\n    else FindNewline(s, start + 1)\n}\n\npredicate ValidInput(stdin_input: string)\n{\n    var lines := ParseLines(stdin_input);\n    |lines| >= 2 && |lines[0]| > 0 && |lines[1]| > 0 &&\n    (forall c :: c in lines[0] ==> 'a' <= c <= 'z') &&\n    (forall c :: c in lines[1] ==> 'a' <= c <= 'z')\n}\n\nfunction IsSubsequence(s: string, t: string): bool\n{\n    if |s| == 0 then true\n    else if |t| == 0 then false\n    else if s[0] == t[0] then IsSubsequence(s[1..], t[1..])\n    else IsSubsequence(s, t[1..])\n}\n\nfunction SortString(s: string): string\n    decreases |s|\n{\n    if |s| <= 1 then s\n    else \n        var pivot := s[0];\n        var smaller := FilterChars(s[1..], pivot, true, false);\n        var equal := FilterChars(s, pivot, false, true);\n        var larger := FilterChars(s[1..], pivot, false, false);\n        SortString(smaller) + equal + SortString(larger)\n}\n\nfunction FilterChars(s: string, pivot: char, takeLess: bool, takeEqual: bool): string\n    decreases |s|\n    ensures |FilterChars(s, pivot, takeLess, takeEqual)| <= |s|\n{\n    if |s| == 0 then \"\"\n    else \n        var first := s[0];\n        var rest := FilterChars(s[1..], pivot, takeLess, takeEqual);\n        if (takeLess && first < pivot) || (takeEqual && first == pivot) || (!takeLess && !takeEqual && first > pivot)\n        then [first] + rest\n        else rest\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires ValidInput(stdin_input)\n    ensures result in [\"array\", \"automaton\", \"both\", \"need tree\"]\n    ensures var lines := ParseLines(stdin_input);\n            var s := lines[0];\n            var t := lines[1];\n            var sx := SortString(s);\n            var tx := SortString(t);\n            ((sx == tx && result == \"array\") ||\n             (sx != tx && IsSubsequence(t, s) && result == \"automaton\") ||\n             (sx != tx && !IsSubsequence(t, s) && IsSubsequence(tx, sx) && result == \"both\") ||\n             (sx != tx && !IsSubsequence(t, s) && !IsSubsequence(tx, sx) && result == \"need tree\"))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_703", "vc-description": "Store `a` nuts in boxes using `b` available divisors. Each box can have at most `k` sections.\nA box with `x` divisors has `x+1` sections. Each section holds at most `v` nuts.\nFind minimum number of boxes needed.", "vc-preamble": "function min(x: int, y: int): int\n{\n    if x <= y then x else y\n}\n\npredicate ValidInput(k: int, a: int, b: int, v: int)\n{\n    2 <= k <= 1000 && 1 <= a <= 1000 && 1 <= b <= 1000 && 1 <= v <= 1000\n}\n\nfunction BoxCapacity(numBoxes: int, k: int, b: int, v: int): int\n    requires numBoxes >= 0\n{\n    v * (numBoxes + min(b, (k - 1) * numBoxes))\n}\n\npredicate CanStoreNuts(numBoxes: int, k: int, a: int, b: int, v: int)\n    requires numBoxes >= 0\n{\n    a <= BoxCapacity(numBoxes, k, b, v)\n}\n\npredicate IsMinimalSolution(result: int, k: int, a: int, b: int, v: int)\n    requires result >= 1\n{\n    CanStoreNuts(result, k, a, b, v) &&\n    (result == 1 || !CanStoreNuts(result - 1, k, a, b, v))\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, a: int, b: int, v: int) returns (result: int)\n    requires ValidInput(k, a, b, v)\n    ensures result >= 1\n    ensures result <= 1009\n    ensures IsMinimalSolution(result, k, a, b, v)\n    ensures exists i :: 1 <= i <= 1009 && CanStoreNuts(i, k, a, b, v) && result == i && \n            (forall j :: 1 <= j < i ==> !CanStoreNuts(j, k, a, b, v))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_709", "vc-description": "Find the minimum number of bacteria to add to an initially empty box to achieve exactly x bacteria at some point in time.\nEach morning we can add bacteria, each night bacteria double.", "vc-preamble": "function CountOnesInBinary(n: int): int\n    requires n >= 1\n    ensures CountOnesInBinary(n) >= 1\n    decreases n\n{\n    if n == 1 then 1\n    else if n % 2 == 1 then 1 + CountOnesInBinary(n / 2)\n    else CountOnesInBinary(n / 2)\n}\n\npredicate ValidInput(x: int) {\n    x >= 1\n}\n\npredicate ValidOutput(x: int, result: int) {\n    ValidInput(x) && result == CountOnesInBinary(x)\n}", "vc-helpers": "", "vc-spec": "method MinBacteria(x: int) returns (result: int)\n    requires ValidInput(x)\n    ensures ValidOutput(x, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_715", "vc-description": "Given a multiple-choice question with four options (A, B, C, D), predict a child's choice.\nCalculate the length of each option's description (excluding prefix \"A.\", \"B.\", etc.).\nA choice is \"great\" if its description is either at least twice shorter than all others\nOR at least twice longer than all others. If exactly one choice is great, select it.\nOtherwise, select choice C.", "vc-preamble": "predicate ValidResult(result: string) {\n    result in [\"A\", \"B\", \"C\", \"D\"]\n}\n\nfunction ChoiceFromIndex(index: int): string\n    requires 0 <= index <= 3\n    ensures ChoiceFromIndex(index) in [\"A\", \"B\", \"C\", \"D\"]\n{\n    if index == 0 then \"A\"\n    else if index == 1 then \"B\"\n    else if index == 2 then \"C\"\n    else \"D\"\n}\n\nfunction SplitLines(s: string): seq<string>\n    ensures forall line :: line in SplitLines(s) ==> '\\n' !in line\n{\n    if |s| == 0 then []\n    else SplitLinesHelper(s, 0, [])\n}\n\nfunction SortLengthsWithIndices(lengths: seq<int>): seq<(int, int)>\n    requires |lengths| == 4\n    ensures |SortLengthsWithIndices(lengths)| == 4\n    ensures forall i :: 0 <= i < 4 ==> SortLengthsWithIndices(lengths)[i].1 in {0, 1, 2, 3}\n    ensures forall i, j :: 0 <= i < j < 4 ==> SortLengthsWithIndices(lengths)[i].0 <= SortLengthsWithIndices(lengths)[j].0\n{\n    var pairs := [(lengths[0], 0), (lengths[1], 1), (lengths[2], 2), (lengths[3], 3)];\n    SortPairsFunc(pairs)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures ValidResult(result)\n    ensures (var lines := SplitLines(input);\n             if |lines| < 4 then result == \"C\"\n             else (\n                 var lengths := [|lines[0]| - 2, |lines[1]| - 2, |lines[2]| - 2, |lines[3]| - 2];\n                 var sortedPairs := SortLengthsWithIndices(lengths);\n                 var shortestTwiceShorter := sortedPairs[0].0 * 2 <= sortedPairs[1].0;\n                 var longestTwiceLonger := sortedPairs[3].0 >= sortedPairs[2].0 * 2;\n                 if shortestTwiceShorter && longestTwiceLonger then result == \"C\"\n                 else if shortestTwiceShorter then result == ChoiceFromIndex(sortedPairs[0].1)\n                 else if longestTwiceLonger then result == ChoiceFromIndex(sortedPairs[3].1)\n                 else result == \"C\"\n             ))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_719", "vc-description": "Find the k-th smallest perfect positive integer, where a perfect integer \nis one whose digits sum to exactly 10.", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0 &&\n    exists k: int :: k >= 1 && k <= 10000 && stdin_input == int_to_string(k) + \"\\n\"\n}\n\nfunction kth_perfect_number(k: int): int\n    requires k >= 1 && k <= 10000\n    ensures kth_perfect_number(k) > 0\n    ensures digit_sum(kth_perfect_number(k)) == 10\n    ensures forall i: int :: 1 <= i < k ==> kth_perfect_number(i) < kth_perfect_number(k)\n    ensures forall n: int :: 0 < n < kth_perfect_number(k) && digit_sum(n) == 10 ==> \n        exists j: int :: 1 <= j < k && kth_perfect_number(j) == n\n{\n    if k == 1 then 19\n    else if k == 2 then 28\n    else if k == 3 then 37\n    else if k == 4 then 46\n    else if k == 5 then 55\n    else if k == 6 then 64\n    else if k == 7 then 73\n    else if k == 8 then 82\n    else if k == 9 then 91\n    else if k == 10 then 109\n    else 10 * (k - 9) + 99\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures exists k: int :: k >= 1 && k <= 10000 && \n        stdin_input == int_to_string(k) + \"\\n\" &&\n        result == int_to_string(kth_perfect_number(k)) + \"\\n\"\n    ensures |result| > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_72", "vc-description": "Three players each have a ribbon (string). The beauty of a ribbon is the maximum frequency of any character.\nIn n turns, each player must change exactly one character. After n turns, the player with highest beauty wins.\nFind the winner assuming optimal play, or \"Draw\" if tied.", "vc-preamble": "predicate ValidInput(input: string) {\n    |input| > 0\n}\n\npredicate ValidOutput(result: string) {\n    result == \"Kuro\" || result == \"Shiro\" || result == \"Katie\" || result == \"Draw\" || result == \"\"\n}\n\nfunction OptimalScore(ribbon: string, turns: int): int\n    requires |ribbon| >= 0 && turns >= 0\n    ensures OptimalScore(ribbon, turns) >= 0\n{\n    var maxFreq := MaxCharFreq(ribbon);\n    var length := |ribbon|;\n    if turns == 1 && maxFreq == length then \n        if maxFreq > 0 then maxFreq - 1 else 0\n    else if length < maxFreq + turns then length\n    else maxFreq + turns\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result)\n    ensures var lines := SplitLines(input);\n            if |lines| < 4 then result == \"\"\n            else (\n                var turns := ParseInt(lines[0]);\n                var s0 := lines[1];\n                var s1 := lines[2]; \n                var s2 := lines[3];\n                var score0 := OptimalScore(s0, turns);\n                var score1 := OptimalScore(s1, turns);\n                var score2 := OptimalScore(s2, turns);\n                var maxScore := Max3(score0, score1, score2);\n                var winners := (if score0 == maxScore then 1 else 0) + (if score1 == maxScore then 1 else 0) + (if score2 == maxScore then 1 else 0);\n                (winners > 1 ==> result == \"Draw\") &&\n                (winners == 1 && score0 == maxScore ==> result == \"Kuro\") &&\n                (winners == 1 && score1 == maxScore ==> result == \"Shiro\") &&\n                (winners == 1 && score2 == maxScore ==> result == \"Katie\")\n            )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_726", "vc-description": "Given n hotels at distinct integer coordinates on a number line, find the number of positions \nwhere a new hotel can be built such that the minimum distance from the new hotel to any \nexisting hotel is exactly d.", "vc-preamble": "predicate ValidInput(n: int, d: int, hotels: seq<int>)\n{\n    n > 0 && d > 0 && |hotels| == n &&\n    (forall i :: 0 <= i < n - 1 ==> hotels[i] < hotels[i + 1])\n}\n\nfunction SumContributions(hotels: seq<int>, d: int, i: int): int\n    requires 0 <= i <= |hotels| - 1\n    requires d > 0\n    requires forall j :: 0 <= j < |hotels| - 1 ==> hotels[j] < hotels[j + 1]\n{\n    if i == 0 then 0\n    else\n        var gap := hotels[i] - hotels[i-1];\n        var contribution := if gap == 2*d then 1 else if gap > 2*d then 2 else 0;\n        contribution + SumContributions(hotels, d, i-1)\n}\n\npredicate CorrectResult(n: int, d: int, hotels: seq<int>, result: int)\n    requires ValidInput(n, d, hotels)\n{\n    result == 2 + SumContributions(hotels, d, n-1) && result >= 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, d: int, hotels: seq<int>) returns (result: int)\n    requires ValidInput(n, d, hotels)\n    ensures CorrectResult(n, d, hotels, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_73", "vc-description": "Calculate the minimum number of days needed to finish reading a book with c pages.\nDay 1: Read min(v_1, v_0) pages. Day n (n >= 2): Go back l pages, then read min(v_1, v_0 + (n-1) * a) pages total.\nThe book is finished when the last page is read for the first time.", "vc-preamble": "function computePosition(days: int, v0: int, v1: int, a: int, l: int): int\n    requires days >= 0\n    requires v0 >= 0 && v1 >= v0 && a >= 0 && l >= 0\n    decreases days\n{\n    if days == 0 then 0\n    else\n        var prevPos := computePosition(days - 1, v0, v1, a, l);\n        var afterReread := if prevPos - l > 0 then prevPos - l else 0;\n        var readToday := if v1 < v0 + a * (days - 1) then v1 else v0 + a * (days - 1);\n        afterReread + readToday\n}", "vc-helpers": "", "vc-spec": "method solve(c: int, v0: int, v1: int, a: int, l: int) returns (result: int)\n    requires 1 <= c <= 1000\n    requires 0 <= l < v0 <= v1 <= 1000\n    requires 0 <= a <= 1000\n    ensures result >= 1\n    ensures computePosition(result, v0, v1, a, l) >= c\n    ensures forall days :: 1 <= days < result ==> computePosition(days, v0, v1, a, l) < c", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_736", "vc-description": "Given a staircase with n steps, find the minimum number of moves to reach the top\nwhere each move climbs 1 or 2 steps, and total moves must be a multiple of m.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n  n > 0 && n <= 10000 && m > 1 && m <= 10\n}\n\nfunction MinMoves(n: int): int\n  requires n > 0\n{\n  if n % 2 == 0 then n / 2 else n / 2 + 1\n}\n\npredicate ValidMoveCount(n: int, k: int)\n  requires n > 0\n{\n  MinMoves(n) <= k <= n\n}\n\npredicate IsValidSolution(n: int, m: int, result: int)\n  requires ValidInput(n, m)\n{\n  result == -1 || (result > 0 && result % m == 0 && ValidMoveCount(n, result))\n}\n\npredicate NoSmallerSolution(n: int, m: int, result: int)\n  requires ValidInput(n, m)\n{\n  result == -1 ==> forall k :: (MinMoves(n) <= k <= n) ==> k % m != 0\n}\n\npredicate IsMinimalSolution(n: int, m: int, result: int)\n  requires ValidInput(n, m)\n{\n  result != -1 ==> forall k :: (MinMoves(n) <= k <= n && k < result) ==> k % m != 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: int)\n  requires ValidInput(n, m)\n  ensures IsValidSolution(n, m, result)\n  ensures NoSmallerSolution(n, m, result)\n  ensures IsMinimalSolution(n, m, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_743", "vc-description": "Given n positive integers, repeatedly perform operations where you select two indices i,j\nwith x_i > x_j and set x_i = x_i - x_j. Find the minimum possible sum after any number of operations.", "vc-preamble": "predicate ValidInput(n: int, ar: seq<int>)\n{\n  n >= 2 && |ar| == n && forall i :: 0 <= i < n ==> ar[i] > 0\n}\n\nfunction GCD(x: int, y: int): int\n  requires x > 0 && y > 0\n  ensures GCD(x, y) > 0\n  decreases if x < y then y else x\n{\n  if x == y then x\n  else if x < y then GCD(x, y - x)\n  else GCD(x - y, y)\n}\n\nfunction GCDOfSequence(ar: seq<int>): int\n  requires |ar| >= 1\n  requires forall i :: 0 <= i < |ar| ==> ar[i] > 0\n  ensures GCDOfSequence(ar) > 0\n  decreases |ar|\n{\n  if |ar| == 1 then ar[0]\n  else GCD(ar[0], GCDOfSequence(ar[1..]))\n}\n\nfunction MinimalSum(n: int, ar: seq<int>): int\n  requires ValidInput(n, ar)\n{\n  GCDOfSequence(ar) * n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, ar: seq<int>) returns (result: int)\n  requires ValidInput(n, ar)\n  ensures result == MinimalSum(n, ar)\n  ensures result > 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_744", "vc-description": "Given a sequence of n days where you were either in Seattle (S) or San Francisco (F),\ndetermine if you made more flights from Seattle to San Francisco than from San Francisco\nto Seattle during this period. You fly at night between consecutive days when you change cities.", "vc-preamble": "function count_sf_flights(s: string): int\n{\n    if |s| <= 1 then 0\n    else (if s[|s|-1] == 'F' && s[|s|-2] != 'F' then 1 else 0) + count_sf_flights(s[..|s|-1])\n}\n\nfunction count_fs_flights(s: string): int\n{\n    if |s| <= 1 then 0\n    else (if s[|s|-1] == 'S' && s[|s|-2] != 'S' then 1 else 0) + count_fs_flights(s[..|s|-1])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: string)\n    requires n >= 2\n    requires |s| == n\n    requires forall i :: 0 <= i < |s| ==> s[i] == 'S' || s[i] == 'F'\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> count_sf_flights(s) > count_fs_flights(s)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_748", "vc-description": "Given a sequence of n positive integers (n divisible by 3), each \u2264 7,\npartition into groups of 3 elements (a,b,c) where a < b < c and a|b, b|c.\nReturn the partition or empty sequence if impossible.", "vc-preamble": "predicate ValidInput(n: int, numbers: seq<int>)\n{\n    n >= 3 && n % 3 == 0 &&\n    |numbers| == n &&\n    forall i :: 0 <= i < |numbers| ==> 1 <= numbers[i] <= 7\n}\n\npredicate ValidTriplet(triplet: seq<int>)\n{\n    |triplet| == 3 &&\n    triplet[0] < triplet[1] < triplet[2] &&\n    triplet[0] > 0 && triplet[1] > 0 && triplet[2] > 0 &&\n    triplet[1] % triplet[0] == 0 && triplet[2] % triplet[1] == 0\n}\n\nfunction FlattenPartition(result: seq<seq<int>>): seq<int>\n{\n    if |result| == 0 then [] else\n    result[0] + FlattenPartition(result[1..])\n}\n\npredicate ValidPartition(result: seq<seq<int>>, numbers: seq<int>)\n{\n    |result| == |numbers| / 3 &&\n    (forall i :: 0 <= i < |result| ==> ValidTriplet(result[i])) &&\n    multiset(numbers) == multiset(FlattenPartition(result))\n}\n\npredicate NoPartitionExists(result: seq<seq<int>>)\n{\n    |result| == 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, numbers: seq<int>) returns (result: seq<seq<int>>)\n    requires ValidInput(n, numbers)\n    ensures NoPartitionExists(result) || ValidPartition(result, numbers)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_750", "vc-description": "Given n friends to invite and notebooks with k sheets each (one color per notebook),\nfind the minimum number of notebooks needed. Each invitation requires exactly 2 red \nsheets, 5 green sheets, and 8 blue sheets.", "vc-preamble": "predicate ValidInput(n: int, k: int)\n{\n  n >= 1 && k >= 1\n}\n\nfunction SheetsNeeded(n: int): (int, int, int)\n{\n  (2 * n, 5 * n, 8 * n)\n}\n\nfunction TotalSheetsNeeded(n: int): int\n{\n  2 * n + 5 * n + 8 * n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n  requires ValidInput(n, k)\n  ensures result == CeilDiv(2 * n, k) + CeilDiv(5 * n, k) + CeilDiv(8 * n, k)\n  ensures result >= 0\n  ensures result >= (TotalSheetsNeeded(n) + k - 1) / k", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_752", "vc-description": "Given two lists of T-shirt sizes (previous year and current year), find the minimum number \nof character replacements needed to transform the previous year's list into the current year's \nlist. Each replacement changes one character in one T-shirt size to any uppercase Latin letter. \nThe lists are unordered (only the frequency of each size matters).", "vc-preamble": "predicate validInput(stdin_input: string)\n{\n    var lines := splitLines(stdin_input);\n    |lines| >= 1 && \n    (var n := parseInteger(lines[0]);\n     n >= 0 && |lines| >= 2*n + 1 && \n     (forall i :: 1 <= i <= 2*n ==> i < |lines| && |lines[i]| > 0))\n}\n\nfunction computeMismatches(stdin_input: string): nat\n    requires validInput(stdin_input)\n    ensures computeMismatches(stdin_input) <= parseInteger(splitLines(stdin_input)[0])\n{\n    var lines := splitLines(stdin_input);\n    var n := parseInteger(lines[0]);\n    if n == 0 then 0\n    else\n        var prevSizes := countSizes(lines[1..n+1]);\n        var currentSizes := lines[n+1..2*n+1];\n        countUnmatchedSizes(prevSizes, currentSizes)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    requires validInput(stdin_input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n' || (|result| > 1 && result[|result|-2..] == \"\\r\\n\")\n    ensures exists mismatches: nat :: result == intToString(mismatches) + \"\\n\" && \n            mismatches == computeMismatches(stdin_input)\n    ensures (var lines := splitLines(stdin_input);\n             var n := parseInteger(lines[0]);\n             n >= 0 ==> (var mismatches := computeMismatches(stdin_input);\n                        mismatches <= n &&\n                        result == intToString(mismatches) + \"\\n\"))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_753", "vc-description": "Given a monitor with aspect ratio a:b and a movie with aspect ratio c:d,\nfit the movie on screen while preserving its aspect ratio and maximizing area.\nCalculate the ratio of empty screen area to total screen area as an irreducible fraction.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int, d: int) {\n    a > 0 && b > 0 && c > 0 && d > 0\n}\n\npredicate IsValidFractionString(s: string, num: int, den: int) {\n    num >= 0 && den > 0 && \n    gcd(num, den) == 1 &&\n    s == intToString(num) + \"/\" + intToString(den)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int, d: int) returns (result: string)\n    requires ValidInput(a, b, c, d)\n    ensures a * d == b * c ==> result == \"0/1\"\n    ensures a * d > b * c ==> exists numerator, denominator :: \n        numerator > 0 && denominator > 0 && \n        gcd(numerator, denominator) == 1 &&\n        result == intToString(numerator) + \"/\" + intToString(denominator) &&\n        numerator * a * d == (a * d - b * c) * denominator\n    ensures a * d < b * c ==> exists numerator, denominator :: \n        numerator > 0 && denominator > 0 && \n        gcd(numerator, denominator) == 1 &&\n        result == intToString(numerator) + \"/\" + intToString(denominator) &&\n        numerator * b * c == (b * c - a * d) * denominator", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_754", "vc-description": "Given n stones in a row colored R, G, or B, find the minimum number of stones\nto remove so that no two adjacent stones have the same color.", "vc-preamble": "predicate ValidInput(n: int, s: string)\n{\n    n >= 1 && |s| == n\n}\n\nfunction count_adjacent_same_pairs(s: string, n: int): int\n    requires n >= 1\n    requires |s| == n\n{\n    count_adjacent_same_pairs_up_to(s, n)\n}\n\nfunction count_adjacent_same_pairs_up_to(s: string, i: int): int\n    requires |s| >= i >= 0\n{\n    if i <= 1 then 0\n    else (if s[i-1] == s[i-2] then 1 else 0) + count_adjacent_same_pairs_up_to(s, i-1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, s: string) returns (result: int)\n    requires ValidInput(n, s)\n    ensures result >= 0\n    ensures result <= n - 1\n    ensures result == count_adjacent_same_pairs(s, n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_755", "vc-description": "Find the minimum number of steps to move from position 0 to position x on a number line,\nwhere each step can move forward by 1, 2, 3, 4, or 5 positions.", "vc-preamble": "predicate ValidInput(x: int)\n{\n  x >= 1\n}\n\npredicate IsMinimalSteps(x: int, steps: int)\n  requires x >= 1\n{\n  steps >= 1 &&\n  steps * 5 >= x &&\n  (steps - 1) * 5 < x\n}", "vc-helpers": "", "vc-spec": "", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_756", "vc-description": "Given a 90-minute game with certain interesting minutes, determine how many\nminutes are watched before turning off the TV. The TV turns off immediately\nafter 15 consecutive boring minutes occur.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>) {\n    n >= 1 && n <= 90 &&\n    |a| == n &&\n    (forall i :: 0 <= i < n ==> 1 <= a[i] <= 90) &&\n    (forall i :: 0 <= i < n - 1 ==> a[i] < a[i + 1])\n}\n\nfunction findCutoff(a: seq<int>, index: int, cutoff: int): int\n    requires 0 <= index <= |a|\n    decreases |a| - index\n{\n    if index >= |a| then cutoff\n    else if a[index] > cutoff then cutoff\n    else findCutoff(a, index + 1, a[index] + 15)\n}\n\nfunction min(x: int, y: int): int\n{\n    if x <= y then x else y\n}\n\npredicate ValidOutput(result: int, n: int, a: seq<int>) {\n    ValidInput(n, a) ==>\n    (1 <= result <= 90 &&\n     result == min(90, findCutoff(a, 0, 15)))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures ValidOutput(result, n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_76", "vc-description": "Given n commentary boxes and m delegations, make the number of boxes divisible by m at minimum cost.\nYou can build a box for cost a or demolish a box for cost b.\nFind the minimum cost to make n divisible by m.", "vc-preamble": "predicate ValidInput(n: int, m: int, a: int, b: int)\n{\n    n >= 1 && m >= 1 && a >= 1 && b >= 1\n}\n\nfunction MinCostToDivisible(n: int, m: int, a: int, b: int): int\n    requires ValidInput(n, m, a, b)\n{\n    var k := n % m;\n    if k * b < (m - k) * a then k * b else (m - k) * a\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, a: int, b: int) returns (result: int)\n    requires ValidInput(n, m, a, b)\n    ensures result == MinCostToDivisible(n, m, a, b)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_760", "vc-description": "Given a string s and integer k, find the maximum possible length of a tandem repeat substring\nthat can appear after appending k characters to s. A tandem repeat of length 2n has its first\nhalf exactly matching its second half.", "vc-preamble": "function is_tandem_repeat(s: seq<char>): bool\n{\n    if |s| % 2 != 0 then false\n    else\n        var half_len := |s| / 2;\n        var first_half := s[0..half_len];\n        var second_half := s[half_len..];\n        forall i :: 0 <= i < half_len ==> \n            (first_half[i] == '*' || second_half[i] == '*' || first_half[i] == second_half[i])\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, k: int) returns (result: int)\n    requires k >= 1\n    requires |s| >= 1\n    ensures result >= 0\n    ensures result % 2 == 0\n    ensures result <= |s| + k\n    ensures forall i, n :: 0 <= i < |s| + k && 2 <= n <= |s| + k - i && n % 2 == 0 && \n            is_tandem_repeat((s + seq(k, j => '*'))[i..i+n]) ==> n <= result\n    ensures result == 0 ==> forall i, n :: 0 <= i < |s| + k && 2 <= n <= |s| + k - i && n % 2 == 0 ==> \n            !is_tandem_repeat((s + seq(k, j => '*'))[i..i+n])\n    ensures result > 0 ==> exists i, n :: 0 <= i < |s| + k && 2 <= n <= |s| + k - i && n % 2 == 0 && \n            (is_tandem_repeat((s + seq(k, j => '*'))[i..i+n]) && n == result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_777", "vc-description": "Given a string of lowercase letters, determine how many distinct strings can be created by\ninserting exactly one additional lowercase letter (a-z) at any position in the string.\nFor a string of length n, we can insert at n+1 positions with 26 character choices,\ngiving 26\u00d7(n+1) total combinations. However, n duplicates occur, resulting in\n26\u00d7(n+1) - n = 25\u00d7n + 26 distinct strings.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| >= 1 && |s| <= 20 && forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\nfunction DistinctStringsCount(s: string): int\n    requires ValidInput(s)\n{\n    |s| * 25 + 26\n}\n\nfunction int_to_string(n: int): string\n    requires n >= 0\n{\n    if n == 0 then \"0\"\n    else int_to_string_helper(n, \"\")\n}\n\nfunction int_to_string_helper(n: int, acc: string): string\n    requires n >= 0\n    decreases n\n{\n    if n == 0 then acc\n    else int_to_string_helper(n / 10, [char_of_digit(n % 10)] + acc)\n}\n\nfunction char_of_digit(d: int): char\n    requires 0 <= d <= 9\n{\n    match d\n    case 0 => '0' case 1 => '1' case 2 => '2' case 3 => '3' case 4 => '4'\n    case 5 => '5' case 6 => '6' case 7 => '7' case 8 => '8' case 9 => '9'\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: string)\n    requires ValidInput(s)\n    ensures result == int_to_string(DistinctStringsCount(s))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_781", "vc-description": "Given an 8\u00d78 board where each cell is colored black (B) or white (W), determine if it's possible to transform it \ninto a proper chessboard using only cyclic right shifts on individual rows. A proper chessboard has no adjacent \ncells (horizontally or vertically) with the same color and the upper-left cell is white.", "vc-preamble": "predicate ValidInput(input: seq<string>)\n{\n    |input| == 8 &&\n    (forall i :: 0 <= i < 8 ==> |input[i]| == 8) &&\n    (forall i, j :: 0 <= i < 8 && 0 <= j < 8 ==> input[i][j] in {'W', 'B'})\n}\n\npredicate HasAlternatingRow(row: string)\n    requires |row| == 8\n    requires forall j :: 0 <= j < 8 ==> row[j] in {'W', 'B'}\n{\n    forall k :: 1 <= k < 8 ==> row[k] != row[k-1]\n}\n\npredicate AllRowsHaveAlternatingPattern(input: seq<string>)\n    requires ValidInput(input)\n{\n    forall i :: 0 <= i < 8 ==> HasAlternatingRow(input[i])\n}", "vc-helpers": "", "vc-spec": "method solve(input: seq<string>) returns (result: string)\n    requires ValidInput(input)\n    ensures result in", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_785", "vc-description": "Given a rectangular room with dimensions a \u00d7 b meters, accommodate exactly n students \nsuch that each student has at least 6 square meters of space. You can increase either \nor both dimensions by any positive integer amount. Find the minimum possible area and \ncorresponding dimensions.", "vc-preamble": "predicate ValidInput(n: int, a: int, b: int)\n{\n  n > 0 && a > 0 && b > 0\n}\n\npredicate ValidOutput(result: seq<int>, n: int, a: int, b: int)\n{\n  |result| == 3 &&\n  result[0] >= 6 * n &&\n  result[1] > 0 && result[2] > 0 &&\n  result[0] == result[1] * result[2] &&\n  ((result[1] >= a && result[2] >= b) || (result[1] >= b && result[2] >= a))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: int, b: int) returns (result: seq<int>)\n  requires ValidInput(n, a, b)\n  ensures ValidOutput(result, n, a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_787", "vc-description": "Given a string q and an integer k, split the string into exactly k non-empty substrings\nsuch that the substrings concatenate to form the original string and each substring \nstarts with a different character (all first characters are distinct).", "vc-preamble": "function concat_seqs(seqs: seq<seq<char>>): seq<char>\n{\n    if |seqs| == 0 then []\n    else seqs[0] + concat_seqs(seqs[1..])\n}\n\npredicate ValidSplit(result: seq<seq<char>>, k: int, q: seq<char>)\n{\n    |result| == k &&\n    (forall i :: 0 <= i < |result| ==> |result[i]| > 0) &&\n    (forall i, j :: 0 <= i < j < |result| ==> result[i][0] != result[j][0]) &&\n    concat_seqs(result) == q\n}", "vc-helpers": "", "vc-spec": "method solve(k: int, q: seq<char>) returns (result: seq<seq<char>>)\n    requires k >= 0\n    requires |q| >= 0\n    ensures k <= 0 || |q| == 0 ==> |result| == 0\n    ensures k > 0 && |q| > 0 ==> (\n        (|result| == 0) || ValidSplit(result, k, q)\n    )", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_788", "vc-description": "Calculate a score from a string starting with 'A' followed by exactly 6 digits.\nScore formula: sum of all 6 digits + 9 * count of zero digits + 1", "vc-preamble": "predicate ValidInput(s: string) \n{\n    |s| == 7 && s[0] == 'A' && forall i :: 1 <= i < 7 ==> '0' <= s[i] <= '9'\n}\n\nfunction DigitSum(s: string, start: int, end: int): int\n    requires 0 <= start <= end <= |s|\n    requires forall i :: start <= i < end ==> '0' <= s[i] <= '9'\n    decreases end - start\n{\n    if start >= end then 0\n    else (s[start] as int - '0' as int) + DigitSum(s, start + 1, end)\n}\n\nfunction ZeroCount(s: string, start: int, end: int): int\n    requires 0 <= start <= end <= |s|\n    decreases end - start\n{\n    if start >= end then 0\n    else (if s[start] == '0' then 1 else 0) + ZeroCount(s, start + 1, end)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures result == DigitSum(s, 1, 7) + 9 * ZeroCount(s, 1, 7) + 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_789", "vc-description": "Given a lucky number n (containing only digits 4 and 7), find its 1-based index\nwhen all lucky numbers are sorted in increasing order. Lucky numbers are positive\nintegers containing only the digits 4 and 7.", "vc-preamble": "predicate ValidLuckyNumber(n: string)\n{\n    |n| > 0 && forall i :: 0 <= i < |n| ==> n[i] == '4' || n[i] == '7'\n}\n\nfunction convertToBinary(n: string): string\n    requires forall i :: 0 <= i < |n| ==> n[i] == '4' || n[i] == '7'\n    ensures |convertToBinary(n)| == |n|\n    ensures forall i :: 0 <= i < |n| ==> (n[i] == '4' ==> convertToBinary(n)[i] == '0') && (n[i] == '7' ==> convertToBinary(n)[i] == '1')\n{\n    if |n| == 0 then \"\"\n    else if n[0] == '4' then \"0\" + convertToBinary(n[1..])\n    else \"1\" + convertToBinary(n[1..])\n}\n\nfunction pow2(n: int): int\n    requires n >= 0\n    ensures pow2(n) > 0\n{\n    if n == 0 then 1\n    else 2 * pow2(n - 1)\n}\n\nfunction binaryToInt(s: string): int\n    requires forall i :: 0 <= i < |s| ==> s[i] == '0' || s[i] == '1'\n    ensures binaryToInt(s) >= 0\n{\n    if |s| == 0 then 0\n    else if s[0] == '1' then pow2(|s|-1) + binaryToInt(s[1..])\n    else binaryToInt(s[1..])\n}\n\npredicate ValidResult(n: string, result: int)\n    requires ValidLuckyNumber(n)\n{\n    result > 0 && result == 2 * (pow2(|n|-1) - 1) + binaryToInt(convertToBinary(n)) + 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: string) returns (result: int)\n    requires ValidLuckyNumber(n)\n    ensures ValidResult(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_792", "vc-description": "Given a credit card account starting with 0 money and n consecutive days of transactions,\ndetermine the minimum number of days deposits are needed to satisfy all constraints.\nEach day deposits can be made in the morning, then transactions occur in the evening.\nIf any evening transaction causes the balance to exceed limit d, return -1.\nOn days when evening transaction is 0 (balance check days), the balance after the\ntransaction must be non-negative. Morning deposits can be any positive integer amount.", "vc-preamble": "predicate ValidInput(n: int, d: int, transactions: seq<int>)\n{\n  n >= 1 && d >= 1 &&\n  |transactions| == n &&\n  forall i :: 0 <= i < n ==> -10000 <= transactions[i] <= 10000\n}\n\nfunction prefix_sum(transactions: seq<int>, index: int): int\n  requires 0 <= index < |transactions|\n{\n  if index == 0 then transactions[0]\n  else prefix_sum(transactions, index - 1) + transactions[index]\n}\n\nfunction count_zero_transactions(transactions: seq<int>): int\n{\n  if |transactions| == 0 then 0\n  else (if transactions[0] == 0 then 1 else 0) + count_zero_transactions(transactions[1..])\n}\n\nfunction balance_after_day(transactions: seq<int>, deposits: seq<int>, day: int): int\n  requires 0 <= day < |transactions|\n  requires |deposits| == |transactions|\n{\n  if day == 0 then deposits[0] + transactions[0]\n  else balance_after_day(transactions, deposits, day - 1) + deposits[day] + transactions[day]\n}\n\nfunction count_positive_deposits(deposits: seq<int>): int\n{\n  if |deposits| == 0 then 0\n  else (if deposits[0] > 0 then 1 else 0) + count_positive_deposits(deposits[1..])\n}\n\npredicate valid_deposits_schedule(transactions: seq<int>, d: int, deposits_schedule: seq<int>, num_deposits: int)\n  requires |deposits_schedule| == |transactions|\n  requires forall i :: 0 <= i < |deposits_schedule| ==> deposits_schedule[i] >= 0\n{\n  num_deposits == count_positive_deposits(deposits_schedule) &&\n  forall i :: 0 <= i < |transactions| ==> \n    (deposits_schedule[i] > 0 ==> transactions[i] == 0)\n}\n\nfunction filter_positive(deposits: seq<int>): seq<int>\n{\n  if |deposits| == 0 then []\n  else if deposits[0] > 0 then [deposits[0]] + filter_positive(deposits[1..])\n  else filter_positive(deposits[1..])\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, d: int, transactions: seq<int>) returns (result: int)\n  requires ValidInput(n, d, transactions)\n  ensures result == -1 || result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_795", "vc-description": "Count the number of integer right triangles (a, b, c) where:\n- a\u00b2 + b\u00b2 = c\u00b2 (Pythagorean theorem)\n- 1 \u2264 a \u2264 b \u2264 c \u2264 n\n- All sides are positive integers", "vc-preamble": "predicate ValidInput(input: string)\n{\n  |input| > 0\n}\n\npredicate ValidN(n: int)\n{\n  n >= 1 && n <= 10000\n}\n\nfunction CountPythagoreanTriplesViaPrimitives(n: int): int\n  requires ValidN(n)\n{\n  var m := IntegerSquareRoot(n);\n  CountFromPrimitives(n, m, 1, 1)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires ValidInput(stdin_input)\n  ensures |result| > 0\n  ensures result == IntToString(CountPythagoreanTriplesViaPrimitives(ExtractInteger(stdin_input)))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_804", "vc-description": "Given a string of lowercase Latin letters and an integer k, find the minimum number of \ncharacter changes needed to make the string contain at least k different letters.\nReturn \"impossible\" if the string length is less than k.", "vc-preamble": "predicate ValidInput(s: string, k: int)\n{\n    1 <= k <= 26 && 1 <= |s| <= 1000 && \n    forall i :: 0 <= i < |s| ==> 'a' <= s[i] <= 'z'\n}\n\nfunction UniqueChars(s: string): set<char>\n{\n    set c | c in s\n}\n\nfunction MinChanges(s: string, k: int): int\n    requires ValidInput(s, k)\n    requires |s| >= k\n{\n    var unique := UniqueChars(s);\n    if k <= |unique| then 0 else k - |unique|\n}\n\npredicate IsImpossible(s: string, k: int)\n    requires ValidInput(s, k)\n{\n    |s| < k\n}", "vc-helpers": "", "vc-spec": "method solve(s: string, k: int) returns (result: string)\n    requires ValidInput(s, k)\n    ensures IsImpossible(s, k) ==> result == \"impossible\"\n    ensures !IsImpossible(s, k) ==> result == IntToString(MinChanges(s, k))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_807", "vc-description": "Find maximum profit from borrowing a honey barrel on day d, selling it for price x_d,\nbuying a new barrel on day d+1 for price x_{d+1}, and paying rental cost c.\nProfit = x_d - x_{d+1} - c. Only execute if profitable, otherwise return 0.", "vc-preamble": "predicate ValidInput(n: int, c: int, prices: seq<int>) {\n    n >= 2 && |prices| == n && c >= 0 &&\n    (forall i :: 0 <= i < |prices| ==> prices[i] >= 0)\n}\n\nfunction ProfitForDay(prices: seq<int>, day: int, c: int): int\n    requires 0 <= day < |prices| - 1\n{\n    prices[day] - prices[day + 1] - c\n}\n\nfunction MaxPossibleProfit(prices: seq<int>, c: int): int\n    requires |prices| >= 2\n{\n    var profits := seq(|prices| - 1, i requires 0 <= i < |prices| - 1 => ProfitForDay(prices, i, c));\n    if |profits| == 0 then 0 else\n    var maxProfit := profits[0];\n    if |profits| == 1 then maxProfit else\n    seq_max(profits)\n}\n\nfunction seq_max(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[0] >= seq_max(s[1..]) then s[0]\n    else seq_max(s[1..])\n}\n\npredicate CorrectResult(n: int, c: int, prices: seq<int>, result: int) {\n    ValidInput(n, c, prices) ==>\n    (result >= 0 &&\n     (result == 0 <==> (forall i :: 0 <= i < n - 1 ==> ProfitForDay(prices, i, c) <= 0)) &&\n     (result > 0 ==> (exists i :: 0 <= i < n - 1 && ProfitForDay(prices, i, c) == result)) &&\n     (forall i :: 0 <= i < n - 1 ==> ProfitForDay(prices, i, c) <= result))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, c: int, prices: seq<int>) returns (result: int)\n    requires ValidInput(n, c, prices)\n    ensures CorrectResult(n, c, prices, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_811", "vc-description": "Given `a` initial candles and the ability to create 1 new candle from `b` burnt-out candles,\ndetermine the maximum number of hours the room can be lit. Each candle burns for exactly 1 hour.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n  a >= 1 && a <= 1000 && b >= 2 && b <= 1000\n}\n\nfunction TotalBurningHours(a: int, b: int): int\n  requires a >= 0 && b >= 2\n  ensures TotalBurningHours(a, b) >= a\n  decreases a\n{\n  if a == 0 then 0\n  else if a < b then a\n  else a + TotalBurningHours(a / b, b)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n  requires ValidInput(a, b)\n  ensures result >= a\n  ensures result == TotalBurningHours(a, b)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_813", "vc-description": "Given n apples numbered 1 to n, distribute all apples between two hamsters (Arthur and Alexander) \nsuch that each hamster receives only apples they like. Arthur gets '1', Alexander gets '2'.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLines(input);\n    |lines| >= 3 && |SplitSpaces(lines[0])| >= 3 &&\n    var n := ParseInt(SplitSpaces(lines[0])[0]);\n    n > 0\n}\n\npredicate ValidOutput(input: string, result: seq<char>)\n    requires ValidInput(input)\n{\n    var lines := SplitLines(input);\n    var n := ParseInt(SplitSpaces(lines[0])[0]);\n    |result| == 2 * n - 1 &&\n    (forall i :: 0 <= i < n ==> result[2*i] == '1' || result[2*i] == '2') &&\n    (forall i :: 0 <= i < n-1 ==> result[2*i+1] == ' ')\n}\n\npredicate CorrectAssignment(input: string, result: seq<char>)\n    requires ValidInput(input)\n    requires ValidOutput(input, result)\n{\n    var lines := SplitLines(input);\n    var n := ParseInt(SplitSpaces(lines[0])[0]);\n    var arthurApples := ParseIntSeq(SplitSpaces(lines[1]));\n    var arthurSet := set x | x in arthurApples;\n    forall i :: 1 <= i <= n ==> \n        (i in arthurSet ==> result[2*(i-1)] == '1') &&\n        (i !in arthurSet ==> result[2*(i-1)] == '2')\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: seq<char>)\n    requires |input| > 0\n    ensures !ValidInput(input) ==> |result| == 0\n    ensures ValidInput(input) ==> ValidOutput(input, result) && CorrectAssignment(input, result)\n    ensures forall i :: 0 <= i < |result| ==> result[i] == '1' || result[i] == '2' || result[i] == ' '", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_821", "vc-description": "Two participants compete in a typing race. Each participant has a ping delay and typing speed.\nThe total time for participant i is 2*t_i + s*v_i where t_i is ping, v_i is typing speed per character, s is text length.\nDetermine winner based on who completes first, or declare friendship if tied.", "vc-preamble": "predicate ValidInput(s: int, v1: int, v2: int, t1: int, t2: int)\n{\n    1 <= s <= 1000 && 1 <= v1 <= 1000 && 1 <= v2 <= 1000 && 1 <= t1 <= 1000 && 1 <= t2 <= 1000\n}\n\nfunction ParticipantTime(s: int, v: int, t: int): int\n{\n    2 * t + s * v\n}\n\nfunction CorrectResult(s: int, v1: int, v2: int, t1: int, t2: int): string\n{\n    var time1 := ParticipantTime(s, v1, t1);\n    var time2 := ParticipantTime(s, v2, t2);\n    if time1 < time2 then \"First\"\n    else if time1 > time2 then \"Second\"\n    else \"Friendship\"\n}\n\npredicate ValidResult(result: string)\n{\n    result == \"First\" || result == \"Second\" || result == \"Friendship\"\n}", "vc-helpers": "", "vc-spec": "method solve(s: int, v1: int, v2: int, t1: int, t2: int) returns (result: string)\n    requires ValidInput(s, v1, v2, t1, t2)\n    ensures ValidResult(result)\n    ensures result == CorrectResult(s, v1, v2, t1, t2)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_823", "vc-description": "Given an infinite spiral starting at (0,0) that visits every integer point,\ndetermine the number of turns required to reach point (x,y) from origin.\nThe spiral follows: (0,0) \u2192 (1,0) \u2192 (1,1) \u2192 (-1,1) \u2192 (-1,-1) \u2192 (2,-1) \u2192 ...\nA turn occurs when direction changes (right\u2192up, up\u2192left, left\u2192down, down\u2192right).", "vc-preamble": "predicate ValidInput(x: int, y: int) {\n    -100 <= x <= 100 && -100 <= y <= 100\n}\n\npredicate IsOriginOrFirstPoint(x: int, y: int) {\n    (x == 0 && y == 0) || (x == 1 && y == 0)\n}\n\npredicate IsRightEdge(x: int, y: int) {\n    x >= 1 && -x + 1 < y <= x\n}\n\npredicate IsLeftEdge(x: int, y: int) {\n    x < 0 && x <= y < -x\n}\n\npredicate IsTopEdge(x: int, y: int) {\n    y > 0 && -y <= x < y\n}\n\nfunction ComputeTurns(x: int, y: int): int\n    requires ValidInput(x, y)\n{\n    if IsOriginOrFirstPoint(x, y) then 0\n    else if IsRightEdge(x, y) then 1 + 4 * (x - 1)\n    else if IsLeftEdge(x, y) then 3 + 4 * (-x - 1)\n    else if IsTopEdge(x, y) then 2 + 4 * (y - 1)\n    else -4 * y\n}", "vc-helpers": "", "vc-spec": "method solve(x: int, y: int) returns (result: int)\n    requires ValidInput(x, y)\n    ensures result >= 0\n    ensures result == ComputeTurns(x, y)\n    ensures IsOriginOrFirstPoint(x, y) ==> result == 0\n    ensures IsRightEdge(x, y) ==> result == 1 + 4 * (x - 1)\n    ensures IsLeftEdge(x, y) ==> result == 3 + 4 * (-x - 1)\n    ensures IsTopEdge(x, y) ==> result == 2 + 4 * (y - 1)\n    ensures !(IsOriginOrFirstPoint(x, y) || IsRightEdge(x, y) || IsLeftEdge(x, y) || IsTopEdge(x, y)) ==> result == -4 * y", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_826", "vc-description": "Find the minimum cost to obtain logs of lengths 1, 2, 3, ..., n.\nWe can purchase logs of lengths 1, 2, 3, ..., n+1 (each costing 1 unit),\ncut them into smaller pieces, and discard unwanted pieces.", "vc-preamble": "predicate ValidInput(n: int)\n{\n  n >= 1\n}\n\npredicate IsOptimalSavings(n: int, savings: int)\n  requires n >= 1\n{\n  savings >= 0 &&\n  (2 + savings) * (savings + 1) / 2 > n + 1 &&\n  (savings == 0 || (2 + (savings - 1)) * savings / 2 <= n + 1)\n}\n\npredicate IsMinimalSavings(n: int, savings: int)\n  requires n >= 1\n{\n  IsOptimalSavings(n, savings) &&\n  (forall j :: j >= 0 && j < savings ==> (2 + j) * (j + 1) / 2 <= n + 1)\n}\n\nfunction OptimalCost(n: int, savings: int): int\n  requires n >= 1\n  requires IsOptimalSavings(n, savings)\n{\n  n - savings + 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n  requires ValidInput(n)\n  ensures result >= 1\n  ensures result <= n\n  ensures exists savings :: IsMinimalSavings(n, savings) && result == OptimalCost(n, savings)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_838", "vc-description": "Count non-empty sets of cells in a binary grid where all cells have the same color (0 or 1)\nand every pair of cells in the set shares either a row or a column.", "vc-preamble": "predicate ValidInput(stdin_input: string)\n{\n    |stdin_input| > 0\n}\n\npredicate ValidGrid(grid: array2<int>)\n    reads grid\n{\n    grid.Length0 > 0 && grid.Length1 > 0 &&\n    forall i, j :: 0 <= i < grid.Length0 && 0 <= j < grid.Length1 ==> \n        grid[i, j] == 0 || grid[i, j] == 1\n}\n\nfunction count_valid_sets(grid: array2<int>): int\n    requires ValidGrid(grid)\n    reads grid\n    ensures count_valid_sets(grid) >= grid.Length0 * grid.Length1\n{\n    grid.Length0 * grid.Length1 + \n    sum_row_contributions(grid) + \n    sum_col_contributions(grid)\n}\n\nfunction sum_row_contributions(grid: array2<int>): int\n    reads grid\n    ensures sum_row_contributions(grid) >= 0\n{\n    sum_row_contributions_helper(grid, 0)\n}\n\nfunction sum_row_contributions_helper(grid: array2<int>, row: int): int\n    requires 0 <= row <= grid.Length0\n    reads grid\n    ensures sum_row_contributions_helper(grid, row) >= 0\n    decreases grid.Length0 - row\n{\n    if row == grid.Length0 then 0\n    else row_contribution(grid, row) + sum_row_contributions_helper(grid, row + 1)\n}\n\nfunction row_contribution(grid: array2<int>, row: int): int\n    requires 0 <= row < grid.Length0\n    reads grid\n    ensures row_contribution(grid, row) >= 0\n{\n    var cnt0 := count_in_row(grid, row, 0);\n    var cnt1 := count_in_row(grid, row, 1);\n    (if cnt0 > 1 then power(2, cnt0) - cnt0 - 1 else 0) +\n    (if cnt1 > 1 then power(2, cnt1) - cnt1 - 1 else 0)\n}\n\nfunction sum_col_contributions(grid: array2<int>): int\n    reads grid\n    ensures sum_col_contributions(grid) >= 0\n{\n    sum_col_contributions_helper(grid, 0)\n}\n\nfunction sum_col_contributions_helper(grid: array2<int>, col: int): int\n    requires 0 <= col <= grid.Length1\n    reads grid\n    ensures sum_col_contributions_helper(grid, col) >= 0\n    decreases grid.Length1 - col\n{\n    if col == grid.Length1 then 0\n    else col_contribution(grid, col) + sum_col_contributions_helper(grid, col + 1)\n}\n\nfunction col_contribution(grid: array2<int>, col: int): int\n    requires 0 <= col < grid.Length1\n    reads grid\n    ensures col_contribution(grid, col) >= 0\n{\n    var cnt0 := count_in_col(grid, col, 0);\n    var cnt1 := count_in_col(grid, col, 1);\n    (if cnt0 > 1 then power(2, cnt0) - cnt0 - 1 else 0) +\n    (if cnt1 > 1 then power(2, cnt1) - cnt1 - 1 else 0)\n}\n\nfunction count_in_row(grid: array2<int>, row: int, value: int): int\n    requires 0 <= row < grid.Length0\n    reads grid\n    ensures count_in_row(grid, row, value) >= 0\n    ensures count_in_row(grid, row, value) <= grid.Length1\n{\n    count_in_row_helper(grid, row, value, 0)\n}\n\nfunction count_in_row_helper(grid: array2<int>, row: int, value: int, col: int): int\n    requires 0 <= row < grid.Length0\n    requires 0 <= col <= grid.Length1\n    reads grid\n    ensures count_in_row_helper(grid, row, value, col) >= 0\n    ensures count_in_row_helper(grid, row, value, col) <= grid.Length1 - col\n    decreases grid.Length1 - col\n{\n    if col == grid.Length1 then 0\n    else (if grid[row, col] == value then 1 else 0) + count_in_row_helper(grid, row, value, col + 1)\n}\n\nfunction count_in_col(grid: array2<int>, col: int, value: int): int\n    requires 0 <= col < grid.Length1\n    reads grid\n    ensures count_in_col(grid, col, value) >= 0\n    ensures count_in_col(grid, col, value) <= grid.Length0\n{\n    if grid.Length0 == 0 then 0\n    else count_col_helper(grid, col, value, 0)\n}\n\nfunction count_col_helper(grid: array2<int>, col: int, value: int, row: int): int\n    requires 0 <= col < grid.Length1\n    requires 0 <= row <= grid.Length0\n    reads grid\n    ensures count_col_helper(grid, col, value, row) >= 0\n    ensures count_col_helper(grid, col, value, row) <= grid.Length0 - row\n    decreases grid.Length0 - row\n{\n    if row == grid.Length0 then 0\n    else (if grid[row, col] == value then 1 else 0) + count_col_helper(grid, col, value, row + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures exists output_value: int :: output_value >= 0 && result == int_to_string(output_value) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_842", "vc-description": "Given a string input, extract the first line and create an even-length palindrome\nby concatenating the line with its reverse, followed by a newline.", "vc-preamble": "predicate ValidInput(s: string)\n{\n    |s| > 0\n}\n\nfunction ExtractFirstLine(s: string): string\n    requires |s| > 0\n    ensures |ExtractFirstLine(s)| >= 0\n{\n    var newline_pos := FindFirstNewline(s);\n    if newline_pos == -1 then s else s[..newline_pos]\n}\n\nfunction FindFirstNewline(s: string): int\n    ensures FindFirstNewline(s) == -1 || (0 <= FindFirstNewline(s) < |s|)\n    ensures FindFirstNewline(s) == -1 <==> (forall i :: 0 <= i < |s| ==> s[i] != '\\n')\n    ensures FindFirstNewline(s) != -1 ==> s[FindFirstNewline(s)] == '\\n'\n    ensures FindFirstNewline(s) != -1 ==> (forall i :: 0 <= i < FindFirstNewline(s) ==> s[i] != '\\n')\n{\n    if |s| == 0 then -1\n    else if s[0] == '\\n' then 0\n    else \n        var rest_result := FindFirstNewline(s[1..]);\n        if rest_result == -1 then -1 else rest_result + 1\n}\n\nfunction ReverseString(s: string): string\n    ensures |ReverseString(s)| == |s|\n    ensures forall i :: 0 <= i < |s| ==> ReverseString(s)[i] == s[|s| - 1 - i]\n{\n    if |s| == 0 then \"\" else ReverseString(s[1..]) + [s[0]]\n}\n\npredicate ValidOutput(result: string, input: string)\n    requires |input| > 0\n{\n    |result| >= 1 &&\n    result[|result| - 1] == '\\n' &&\n    exists n: string :: \n        n == ExtractFirstLine(input) &&\n        result == n + ReverseString(n) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures ValidOutput(result, stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_847", "vc-description": "Given n cards with integers (absolute value \u2264 x), find the minimum number of additional cards\nneeded to make the total sum equal to zero. Additional cards can have integer values from -x to x.", "vc-preamble": "function sum(cards: seq<int>): int\n{\n    if |cards| == 0 then 0\n    else cards[0] + sum(cards[1..])\n}\n\nfunction abs(x: int): int\n{\n    if x >= 0 then x else -x\n}\n\npredicate ValidInput(cards: seq<int>, x: int)\n{\n    x > 0 && |cards| >= 1 && forall i :: 0 <= i < |cards| ==> -x <= cards[i] <= x\n}", "vc-helpers": "", "vc-spec": "method solve(cards: seq<int>, x: int) returns (result: int)\n    requires ValidInput(cards, x)\n    ensures result >= 0\n    ensures result == if sum(cards) == 0 then 0 else (abs(sum(cards)) + x - 1) / x", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_858", "vc-description": "Given N attendees at a brain dinner (including Heidi), determine the minimum number of brains needed\nin a chest for Heidi to survive. Heidi makes the first proposal for brain distribution, which must be \naccepted by at least half of all attendees (including herself) for her to survive.", "vc-preamble": "predicate IsPowerOfTwo(n: int) \n    decreases n\n{\n    if n <= 0 then false\n    else if n == 1 then true\n    else if n % 2 == 1 then false\n    else IsPowerOfTwo(n / 2)\n}\n\npredicate ValidInput(n: int) {\n    n >= 1\n}\n\npredicate CorrectResult(n: int, result: int) {\n    if n % 2 == 1 then \n        result == (n - 1) / 2\n    else \n        exists z :: 1 <= z <= n && IsPowerOfTwo(z) && z <= n && z * 2 > n && result == (n - z) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(n: int) returns (result: int)\n    requires ValidInput(n)\n    ensures CorrectResult(n, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_862", "vc-description": "Allen starts at the end of queue 1 and moves cyclically through n queues.\nEach minute, one person from each non-empty queue enters the fan zone.\nIf Allen is at the front of his current queue, he enters; otherwise he moves to the next queue.\nFind which entrance Allen will use to enter the fan zone.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>) {\n  n >= 2 && |a| == n && (forall i :: 0 <= i < n ==> a[i] >= 0)\n}\n\nfunction ComputeB(a: seq<int>, i: int): int\n  requires 0 <= i < |a|\n{\n  a[i] - i\n}\n\nfunction ComputeC(n: int, b: int): int\n  requires n >= 2\n{\n  if b < 0 then b / n else (b + n - 1) / n\n}\n\nfunction ComputeCC(n: int, a: seq<int>, i: int): int\n  requires ValidInput(n, a) && 0 <= i < n\n{\n  var b := ComputeB(a, i);\n  var c := ComputeC(n, b);\n  n * c\n}\n\npredicate IsOptimalEntrance(n: int, a: seq<int>, entrance: int)\n  requires ValidInput(n, a) && 1 <= entrance <= n\n{\n  var i := entrance - 1;\n  forall j :: 0 <= j < n ==> \n    (var cci := ComputeCC(n, a, i);\n     var ccj := ComputeCC(n, a, j);\n     cci <= ccj && (cci < ccj || i <= j))\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n  requires ValidInput(n, a)\n  ensures 1 <= result <= n\n  ensures IsOptimalEntrance(n, a, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_864", "vc-description": "Given n participants and m food packages where each package has a food type,\ndetermine the maximum number of days an expedition can last under these constraints:\n- Each participant eats exactly one package per day\n- Each participant must eat the same food type throughout the entire expedition\n- Different participants can eat different food types", "vc-preamble": "function possible(n: int, foodTypes: seq<int>, days: int): bool\n    requires n >= 0\n    requires days >= 0\n    requires forall i :: 0 <= i < |foodTypes| ==> foodTypes[i] >= 1\n{\n    if days == 0 then true\n    else\n        var totalParticipants := countTotalParticipants(foodTypes, days, 1);\n        totalParticipants >= n\n}\n\nfunction countTotalParticipants(foodTypes: seq<int>, days: int, currentType: int): int\n    requires days >= 0\n    requires currentType >= 1\n    decreases 101 - currentType\n    ensures countTotalParticipants(foodTypes, days, currentType) >= 0\n    ensures days > 0 ==> countTotalParticipants(foodTypes, days + 1, currentType) <= countTotalParticipants(foodTypes, days, currentType)\n{\n    if currentType > 100 then 0\n    else\n        var packagesOfThisType := countPackages(foodTypes, currentType);\n        var participantsForThisType := if days > 0 then packagesOfThisType / days else 0;\n        participantsForThisType + countTotalParticipants(foodTypes, days, currentType + 1)\n}\n\nfunction countPackages(foodTypes: seq<int>, targetType: int): int\n    requires targetType >= 1\n    ensures countPackages(foodTypes, targetType) >= 0\n    ensures countPackages(foodTypes, targetType) <= |foodTypes|\n{\n    if |foodTypes| == 0 then 0\n    else if foodTypes[0] == targetType then 1 + countPackages(foodTypes[1..], targetType)\n    else countPackages(foodTypes[1..], targetType)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, foodTypes: seq<int>) returns (result: int)\n    requires 1 <= n <= 100\n    requires 1 <= m <= 100\n    requires |foodTypes| == m\n    requires forall i :: 0 <= i < |foodTypes| ==> 1 <= foodTypes[i] <= 100\n    ensures result >= 0\n    ensures result <= m\n    ensures result > 0 ==> possible(n, foodTypes, result)\n    ensures !possible(n, foodTypes, result + 1)\n    ensures forall d :: d > result ==> !possible(n, foodTypes, d)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_869", "vc-description": "Given a red socks and b blue socks, determine the maximum number of days to wear\ndifferent colored socks (one red, one blue per day), then the number of days to\nwear same colored socks afterwards (two socks of same color per day). Each day,\nworn socks are discarded.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n  a >= 1 && b >= 1\n}\n\nfunction MaxDifferentDays(a: int, b: int): int\n{\n  if a < b then a else b\n}\n\nfunction RemainingAfterDifferent(a: int, b: int): int\n{\n  if a > b then a - MaxDifferentDays(a, b) else b - MaxDifferentDays(a, b)\n}\n\nfunction SameDays(a: int, b: int): int\n{\n  RemainingAfterDifferent(a, b) / 2\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (days_different: int, days_same: int)\n  requires ValidInput(a, b)\n  ensures days_different == MaxDifferentDays(a, b)\n  ensures days_same == SameDays(a, b)\n  ensures days_different >= 0\n  ensures days_same >= 0\n  ensures days_different <= a && days_different <= b", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_87", "vc-description": "Given a month number and the weekday of its first day, determine how many columns \nare needed for a calendar table where each column represents one week (Monday through Sunday).\nThe calendar places dates sequentially and a new column is needed when transitioning \nfrom Sunday to Monday.", "vc-preamble": "predicate ValidInput(m: int, d: int)\n{\n    1 <= m <= 12 && 1 <= d <= 7\n}\n\nfunction DaysInMonth(m: int): int\n    requires 1 <= m <= 12\n{\n    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][m-1]\n}\n\nfunction ColumnsNeeded(m: int, d: int): int\n    requires ValidInput(m, d)\n{\n    1 + (d - 1 + DaysInMonth(m) - 1) / 7\n}", "vc-helpers": "", "vc-spec": "method solve(m: int, d: int) returns (result: int)\n    requires ValidInput(m, d)\n    ensures result == ColumnsNeeded(m, d)\n    ensures 4 <= result <= 6", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_877", "vc-description": "Given n problems numbered 1 to n in ascending order of difficulty and m pairs \nof similar problems, split the problems into two non-empty divisions such that:\n1. Each problem belongs to exactly one division\n2. All problems in division 1 are harder than all problems in division 2  \n3. Similar problems must be in different divisions\nCount the number of valid ways to make this split.", "vc-preamble": "predicate ValidInput(n: int, m: int, pairs: seq<(int, int)>)\n{\n    n >= 2 && \n    m >= 0 && \n    |pairs| == m &&\n    (forall i :: 0 <= i < |pairs| ==> 1 <= pairs[i].0 <= n && 1 <= pairs[i].1 <= n) &&\n    (forall i :: 0 <= i < |pairs| ==> pairs[i].0 != pairs[i].1)\n}\n\nfunction computeFinalL(pairs: seq<(int, int)>): int\n{\n    if |pairs| == 0 then 1\n    else \n        var x := pairs[|pairs|-1].0;\n        var y := pairs[|pairs|-1].1;\n        var minVal := if x < y then x else y;\n        var restL := computeFinalL(pairs[..|pairs|-1]);\n        if restL > minVal then restL else minVal\n}\n\nfunction computeFinalR(n: int, pairs: seq<(int, int)>): int\n{\n    if |pairs| == 0 then n\n    else\n        var x := pairs[|pairs|-1].0;\n        var y := pairs[|pairs|-1].1;\n        var maxVal := if x > y then x else y;\n        var restR := computeFinalR(n, pairs[..|pairs|-1]);\n        if restR < maxVal then restR else maxVal\n}\n\nfunction max(a: int, b: int): int\n{\n    if a > b then a else b\n}\n\npredicate ValidResult(n: int, pairs: seq<(int, int)>, result: int)\n{\n    result >= 0 &&\n    result <= n - 1 &&\n    result == max(computeFinalR(n, pairs) - computeFinalL(pairs), 0)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int, pairs: seq<(int, int)>) returns (result: int)\n    requires ValidInput(n, m, pairs)\n    ensures ValidResult(n, pairs, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_883", "vc-description": "There are n+1 people (Dima and n friends) standing in a circle. Each person shows 1-5 fingers.\nStarting from Dima, they count around the circle a total number equal to the sum of all fingers.\nThe person where counting stops must clean the apartment.\nGiven the fingers shown by Dima's n friends, determine how many different ways Dima can show\nhis fingers (1-5) such that he does NOT have to clean the apartment.", "vc-preamble": "predicate ValidInput(n: int, friends: seq<int>)\n{\n  n >= 1 && |friends| == n && forall i :: 0 <= i < |friends| ==> 1 <= friends[i] <= 5\n}\n\nfunction sum_sequence(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + sum_sequence(s[1..])\n}\n\npredicate DimaCleans(n: int, friends: seq<int>, dima_fingers: int)\n  requires ValidInput(n, friends)\n  requires 1 <= dima_fingers <= 5\n{\n  var total_sum := sum_sequence(friends) + dima_fingers;\n  var total_people := n + 1;\n  total_sum % total_people == 1\n}\n\nfunction CountValidChoices(n: int, friends: seq<int>): int\n  requires ValidInput(n, friends)\n{\n  CountValidChoicesHelper(n, friends, 1)\n}\n\nfunction CountValidChoicesHelper(n: int, friends: seq<int>, finger_count: int): int\n  requires ValidInput(n, friends)\n  requires 1 <= finger_count <= 6\n  decreases 6 - finger_count\n{\n  if finger_count > 5 then\n    0\n  else if !DimaCleans(n, friends, finger_count) then\n    1 + CountValidChoicesHelper(n, friends, finger_count + 1)\n  else\n    CountValidChoicesHelper(n, friends, finger_count + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, friends: seq<int>) returns (result: int)\n  requires ValidInput(n, friends)\n  ensures 0 <= result <= 5\n  ensures result == CountValidChoices(n, friends)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_889", "vc-description": "Given a 4\u00d74 grid where each cell is either black ('#') or white ('.'), \ndetermine if it's possible to create a 2\u00d72 square of uniform color by \nrepainting at most one cell. Return \"YES\" if possible, \"NO\" otherwise.", "vc-preamble": "function ParseInputLines(input: string): seq<string>\n{\n    SplitByNewlineSimple(input, 0, [])\n}\n\nfunction SplitByNewlineSimple(input: string, pos: int, acc: seq<string>): seq<string>\n    requires 0 <= pos <= |input|\n    decreases |input| - pos\n{\n    if pos >= |input| then acc\n    else \n        var nextNewline := FindNextNewline(input, pos);\n        if nextNewline == -1 then\n            if pos < |input| then acc + [input[pos..]] else acc\n        else\n            SplitByNewlineSimple(input, nextNewline + 1, acc + [input[pos..nextNewline]])\n}\n\nfunction FindNextNewline(input: string, start: int): int\n    requires 0 <= start <= |input|\n    ensures FindNextNewline(input, start) == -1 || (start <= FindNextNewline(input, start) < |input|)\n    decreases |input| - start\n{\n    if start >= |input| then -1\n    else if input[start] == '\\n' then start\n    else FindNextNewline(input, start + 1)\n}\n\nfunction CountBlackInSquare(lines: seq<string>, row: int, col: int): int\n    requires 0 <= row < |lines| - 1\n    requires row + 1 < |lines|\n    requires 0 <= col < |lines[row]| - 1\n    requires 0 <= col < |lines[row + 1]| - 1\n    requires col + 1 < |lines[row]|\n    requires col + 1 < |lines[row + 1]|\n{\n    (if lines[row][col] == '#' then 1 else 0) +\n    (if lines[row][col + 1] == '#' then 1 else 0) +\n    (if lines[row + 1][col] == '#' then 1 else 0) +\n    (if lines[row + 1][col + 1] == '#' then 1 else 0)\n}\n\npredicate ValidGrid(lines: seq<string>)\n{\n    |lines| == 4 && (forall k :: 0 <= k < 4 ==> |lines[k]| >= 4)\n}\n\npredicate CanMakeUniformSquare(lines: seq<string>)\n    requires ValidGrid(lines)\n{\n    exists i, j :: 0 <= i <= 2 && 0 <= j <= 2 && \n        i + 1 < |lines| && j + 1 < |lines[i]| && j + 1 < |lines[i + 1]| &&\n        (var blackCount := CountBlackInSquare(lines, i, j);\n         blackCount >= 3 || blackCount <= 1)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> \n        (var lines := ParseInputLines(input);\n         ValidGrid(lines) && CanMakeUniformSquare(lines))", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_894", "vc-description": "Given a rectangle with vertices at (0,0) and (x,y), find two points A=(x\u2081,y\u2081) and C=(x\u2082,y\u2082) \nsuch that triangle ABC with B=(0,0) is right-angled and isosceles at B, contains the entire \nrectangle, has minimum area, and all coordinates are integers with x\u2081 < x\u2082.", "vc-preamble": "predicate ValidInput(x: int, y: int)\n{\n    x != 0 && y != 0\n}\n\npredicate ValidOutput(result: seq<int>, x: int, y: int)\n{\n    |result| == 4 &&\n    result[0] < result[2] &&\n    (x * y > 0 && x < 0 ==> result == [x + y, 0, 0, x + y]) &&\n    (x * y > 0 && x >= 0 ==> result == [0, x + y, x + y, 0]) &&\n    (x * y <= 0 && x < 0 ==> result == [x - y, 0, 0, y - x]) &&\n    (x * y <= 0 && x >= 0 ==> result == [0, y - x, x - y, 0])\n}", "vc-helpers": "", "vc-spec": "method solve(x: int, y: int) returns (result: seq<int>)\n    requires ValidInput(x, y)\n    ensures ValidOutput(result, x, y)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_895", "vc-description": "Given n students who perform rituals at times t_i, find the maximum number of students \nthat can be visited by a \"freebie\" present for exactly T consecutive seconds.\nAll visited students must have ritual times within the same T-second interval.", "vc-preamble": "predicate ValidInput(n: int, times: seq<int>, T: int)\n{\n    n >= 1 && |times| == n && T >= 1 && \n    forall i :: 0 <= i < |times| ==> 1 <= times[i] <= 1000\n}\n\nfunction maxStudentsInWindow(times: seq<int>, T: int): int\n    requires T >= 1\n    requires forall i :: 0 <= i < |times| ==> 1 <= times[i] <= 1000\n{\n    maxStudentsInWindowUpTo(times, T, 1000)\n}\n\nfunction maxStudentsInWindowUpTo(times: seq<int>, T: int, maxStart: int): int\n    requires T >= 1\n    requires forall i :: 0 <= i < |times| ==> 1 <= times[i] <= 1000\n    requires maxStart >= 0\n    ensures 0 <= maxStudentsInWindowUpTo(times, T, maxStart) <= |times|\n{\n    if maxStart < 1 then 0\n    else\n        var count := countStudentsInWindow(times, maxStart, T);\n        var restMax := maxStudentsInWindowUpTo(times, T, maxStart - 1);\n        if count > restMax then count else restMax\n}\n\nfunction countStudentsInWindow(times: seq<int>, start: int, T: int): int\n    requires T >= 1\n    requires forall i :: 0 <= i < |times| ==> 1 <= times[i] <= 1000\n    requires start >= 1\n    ensures 0 <= countStudentsInWindow(times, start, T) <= |times|\n{\n    countStudentsInWindowHelper(times, start, T, 0)\n}\n\nfunction countStudentsInWindowHelper(times: seq<int>, start: int, T: int, index: int): int\n    requires T >= 1\n    requires forall i :: 0 <= i < |times| ==> 1 <= times[i] <= 1000\n    requires start >= 1\n    requires 0 <= index <= |times|\n    ensures 0 <= countStudentsInWindowHelper(times, start, T, index) <= |times| - index\n    decreases |times| - index\n{\n    if index == |times| then 0\n    else\n        var countRest := countStudentsInWindowHelper(times, start, T, index + 1);\n        if start <= times[index] <= start + T - 1 then countRest + 1 else countRest\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, times: seq<int>, T: int) returns (result: int)\n    requires ValidInput(n, times, T)\n    ensures result >= 0\n    ensures result <= n\n    ensures result == maxStudentsInWindow(times, T)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_901", "vc-description": "Given n parallel universes and m groups, determine if there exists a scenario \nwhere at least one group contains only traitors. In each universe, exactly one \nperson (Rick or Morty) is a traitor. A group is dangerous if all its members \ncould potentially be traitors in some assignment, which happens when the group \ndoesn't contain both Rick and Morty from any single universe.", "vc-preamble": "function SplitLines(s: string): seq<string>\n    requires |s| >= 0\n    ensures |SplitLines(s)| >= 0\n    ensures |s| == 0 ==> |SplitLines(s)| == 0\n    ensures |s| > 0 ==> |SplitLines(s)| >= 1\n    ensures forall i :: 0 <= i < |SplitLines(s)| ==> |SplitLines(s)[i]| >= 0\n{\n    if |s| == 0 then [] else [s]\n}\n\nfunction SplitInts(s: string): seq<int>\n    requires |s| >= 0\n    ensures |SplitInts(s)| >= 0\n{\n    []\n}\n\nfunction SeqToSet(s: seq<int>): set<int>\n{\n    set x | x in s\n}\n\nfunction is_dangerous_group(group_data: seq<int>): bool\n{\n    if |group_data| <= 1 then false\n    else\n        var group_members := group_data[1..];\n        var member_set := SeqToSet(group_members);\n        forall member :: member in member_set ==> -member !in member_set\n}\n\npredicate exists_dangerous_group(stdin_input: string)\n    requires |stdin_input| > 0\n{\n    var lines := SplitLines(stdin_input);\n    if |lines| == 0 then false\n    else\n        var first_line := SplitInts(lines[0]);\n        if |first_line| < 2 then false\n        else\n            var n := first_line[0];\n            var m := first_line[1];\n            if m <= 0 || n <= 0 then false\n            else\n                exists i :: 1 <= i <= m && i < |lines| && \n                    is_dangerous_group(SplitInts(lines[i]))\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures (result == \"YES\\n\") <==> exists_dangerous_group(stdin_input)\n    ensures (result == \"NO\\n\") <==> !exists_dangerous_group(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_909", "vc-description": "Given three positive integers a, b, and c, find the maximum possible value \nof an arithmetic expression formed by inserting operation signs ('+' or '*') \nbetween the numbers and optionally adding brackets. The numbers must remain \nin order a, b, c. All six possible expressions must be considered:\na + b + c, a + b * c, a * b + c, a * b * c, (a + b) * c, a * (b + c)", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= a <= 10 && 1 <= b <= 10 && 1 <= c <= 10\n}\n\nfunction AllExpressions(a: int, b: int, c: int): seq<int>\n{\n    [a * b * c, a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c]\n}\n\nfunction MaxExpression(a: int, b: int, c: int): int\n    requires ValidInput(a, b, c)\n{\n    var exprs := AllExpressions(a, b, c);\n    if exprs[0] >= exprs[1] && exprs[0] >= exprs[2] && exprs[0] >= exprs[3] && exprs[0] >= exprs[4] && exprs[0] >= exprs[5] then exprs[0]\n    else if exprs[1] >= exprs[2] && exprs[1] >= exprs[3] && exprs[1] >= exprs[4] && exprs[1] >= exprs[5] then exprs[1]\n    else if exprs[2] >= exprs[3] && exprs[2] >= exprs[4] && exprs[2] >= exprs[5] then exprs[2]\n    else if exprs[3] >= exprs[4] && exprs[3] >= exprs[5] then exprs[3]\n    else if exprs[4] >= exprs[5] then exprs[4]\n    else exprs[5]\n}\n\npredicate IsMaxOfAllExpressions(result: int, a: int, b: int, c: int)\n    requires ValidInput(a, b, c)\n{\n    var exprs := AllExpressions(a, b, c);\n    result in exprs && forall i :: 0 <= i < |exprs| ==> result >= exprs[i]\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int) returns (result: int)\n    requires ValidInput(a, b, c)\n    ensures IsMaxOfAllExpressions(result, a, b, c)\n    ensures result == MaxExpression(a, b, c)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_911", "vc-description": "Given n problems with initial scores and solving times, where problems are sorted by increasing\ndifficulty. Two contestants (Limak and Radewoosh) solve all problems in opposite orders.\nWhen problem i is submitted at time x, it awards max(0, p_i - c*x) points where c is penalty rate.\nDetermine who scores more total points.", "vc-preamble": "predicate ValidInput(n: int, c: int, P: seq<int>, T: seq<int>)\n{\n    n > 0 && c > 0 && |P| == n && |T| == n &&\n    (forall i :: 0 <= i < n ==> P[i] > 0) &&\n    (forall i :: 0 <= i < n ==> T[i] > 0) &&\n    (forall i :: 0 <= i < n-1 ==> P[i] < P[i+1]) &&\n    (forall i :: 0 <= i < n-1 ==> T[i] < T[i+1])\n}\n\nfunction calculateLimakScore(n: int, c: int, P: seq<int>, T: seq<int>): int\n    requires n > 0 && |P| == n && |T| == n\n{\n    if n == 0 then 0\n    else \n        var cumulativeTime := sum(T[..1]);\n        var score := if P[0] - c * cumulativeTime > 0 then P[0] - c * cumulativeTime else 0;\n        score + calculateLimakScoreHelper(n-1, c, P[1..], T[1..], cumulativeTime)\n}\n\nfunction calculateLimakScoreHelper(remaining: int, c: int, P: seq<int>, T: seq<int>, prevTime: int): int\n    requires remaining >= 0 && |P| == remaining && |T| == remaining\n{\n    if remaining == 0 then 0\n    else \n        var cumulativeTime := prevTime + T[0];\n        var score := if P[0] - c * cumulativeTime > 0 then P[0] - c * cumulativeTime else 0;\n        score + calculateLimakScoreHelper(remaining-1, c, P[1..], T[1..], cumulativeTime)\n}\n\nfunction calculateRadewooshScore(n: int, c: int, P: seq<int>, T: seq<int>): int\n    requires n > 0 && |P| == n && |T| == n\n{\n    calculateRadewooshScoreHelper(n, c, P, T, 0)\n}\n\nfunction calculateRadewooshScoreHelper(remaining: int, c: int, P: seq<int>, T: seq<int>, prevTime: int): int\n    requires remaining >= 0 && |P| >= remaining && |T| >= remaining\n{\n    if remaining == 0 then 0\n    else \n        var idx := remaining - 1;\n        var cumulativeTime := prevTime + T[idx];\n        var score := if P[idx] - c * cumulativeTime > 0 then P[idx] - c * cumulativeTime else 0;\n        score + calculateRadewooshScoreHelper(remaining-1, c, P, T, cumulativeTime)\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, c: int, P: seq<int>, T: seq<int>) returns (result: string)\n    requires ValidInput(n, c, P, T)\n    ensures result == \"Limak\" || result == \"Radewoosh\" || result == \"Tie\"\n    ensures var limakScore := calculateLimakScore(n, c, P, T);\n            var radewooshScore := calculateRadewooshScore(n, c, P, T);\n            (result == \"Limak\" <==> limakScore > radewooshScore) &&\n            (result == \"Radewoosh\" <==> limakScore < radewooshScore) &&\n            (result == \"Tie\" <==> limakScore == radewooshScore)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_913", "vc-description": "Given n problems and two robots, determine the minimum possible maximum point value\nneeded to ensure the first robot scores strictly more points than the second robot.\nReturn -1 if the first robot cannot outperform the second robot.", "vc-preamble": "predicate ValidInput(n: int, r: seq<int>, b: seq<int>)\n{\n    n > 0 && |r| == n && |b| == n &&\n    (forall i :: 0 <= i < n ==> r[i] == 0 || r[i] == 1) &&\n    (forall i :: 0 <= i < n ==> b[i] == 0 || b[i] == 1)\n}\n\nfunction RobotAdvantageCount(n: int, r: seq<int>, b: seq<int>): int\n    requires ValidInput(n, r, b)\n{\n    |set i | 0 <= i < n && r[i] == 1 && b[i] == 0|\n}\n\nfunction OpponentAdvantageCount(n: int, r: seq<int>, b: seq<int>): int\n    requires ValidInput(n, r, b)\n{\n    |set i | 0 <= i < n && r[i] == 0 && b[i] == 1|\n}\n\npredicate CanWin(n: int, r: seq<int>, b: seq<int>)\n    requires ValidInput(n, r, b)\n{\n    RobotAdvantageCount(n, r, b) > 0\n}\n\nfunction MinMaxPointValue(n: int, r: seq<int>, b: seq<int>): int\n    requires ValidInput(n, r, b)\n    requires CanWin(n, r, b)\n{\n    OpponentAdvantageCount(n, r, b) / RobotAdvantageCount(n, r, b) + 1\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, r: seq<int>, b: seq<int>) returns (result: int)\n    requires ValidInput(n, r, b)\n    ensures if CanWin(n, r, b) then result == MinMaxPointValue(n, r, b) else result == -1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_925", "vc-description": "Given a 2-digit number displayed on a 7-segment digital counter, count how many \n2-digit numbers (00-99) could have been the intended display before some light \nsegments potentially broke (turned off). Segments can only break by turning OFF.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 2 && \n    '0' <= input[0] <= '9' && \n    '0' <= input[1] <= '9' &&\n    (input[|input|-1] == '\\n' || (input[0] != '\\n' && input[1] != '\\n'))\n}\n\nfunction GoodDigitCount(digit: char): int\n    requires '0' <= digit <= '9'\n    ensures GoodDigitCount(digit) >= 1 && GoodDigitCount(digit) <= 7\n{\n    if digit == '0' then 2\n    else if digit == '1' then 7\n    else if digit == '2' then 2\n    else if digit == '3' then 3\n    else if digit == '4' then 3\n    else if digit == '5' then 4\n    else if digit == '6' then 2\n    else if digit == '7' then 5\n    else if digit == '8' then 1\n    else 2\n}\n\nfunction ComputeTotalGoodCount(input: string): int\n    requires ValidInput(input)\n    ensures ComputeTotalGoodCount(input) >= 1 && ComputeTotalGoodCount(input) <= 49\n{\n    GoodDigitCount(input[0]) * GoodDigitCount(input[1])\n}\n\npredicate ValidOutput(result: string, expectedCount: int)\n{\n    |result| >= 2 && \n    result[|result|-1] == '\\n' &&\n    (forall c :: c in result ==> c == '\\n' || ('0' <= c <= '9')) &&\n    expectedCount >= 1 && expectedCount <= 49\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures ValidOutput(result, ComputeTotalGoodCount(input))\n    ensures result == IntToString(ComputeTotalGoodCount(input)) + \"\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_93", "vc-description": "Given two 2x2 sliding puzzles with tiles A, B, C and empty cell X,\ndetermine if there exists a sequence of moves that can make both puzzles\nreach the same configuration. A move slides a tile adjacent to the empty\ncell into the empty cell.", "vc-preamble": "function countNewlines(s: string): int\n{\n    if |s| == 0 then 0\n    else (if s[0] == '\\n' then 1 else 0) + countNewlines(s[1..])\n}\n\npredicate ValidInput(input: string)\n{\n    |input| > 0 && '\\n' in input && countNewlines(input) >= 3\n}\n\nfunction extractAndNormalizePuzzle1(input: string): string\n    requires ValidInput(input)\n{\n    var lines := splitLines(input);\n    if |lines| >= 2 then\n        var line1 := lines[0];\n        var line2 := reverse(lines[1]);\n        var combined := line1 + line2;\n        removeFirstX(combined)\n    else\n        \"\"\n}\n\nfunction extractAndNormalizePuzzle2(input: string): string\n    requires ValidInput(input)\n{\n    var lines := splitLines(input);\n    if |lines| >= 4 then\n        var line3 := lines[2];\n        var line4 := reverse(lines[3]);\n        var combined := line3 + line4;\n        removeFirstX(combined)\n    else\n        \"\"\n}\n\npredicate CanReachSameConfig(input: string)\n    requires ValidInput(input)\n{\n    exists rotation :: 0 <= rotation < 4 && \n        extractAndNormalizePuzzle1(input) == rotatePuzzleLeft(extractAndNormalizePuzzle2(input), rotation)\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures result == \"YES\\n\" || result == \"NO\\n\"\n    ensures result == \"YES\\n\" <==> CanReachSameConfig(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_935", "vc-description": "Given a grid with n horizontal and m vertical sticks, two players take turns\nremoving intersection points. When an intersection is removed, all sticks \npassing through it are removed. The player who cannot make a move loses.\nAkshat goes first. Determine the winner when both players play optimally.", "vc-preamble": "predicate ValidInput(n: int, m: int)\n{\n    1 <= n <= 100 && 1 <= m <= 100\n}\n\nfunction GameMoves(n: int, m: int): int\n    requires ValidInput(n, m)\n{\n    if n < m then n else m\n}\n\nfunction Winner(n: int, m: int): string\n    requires ValidInput(n, m)\n{\n    var moves := GameMoves(n, m);\n    if moves % 2 == 1 then \"Akshat\" else \"Malvika\"\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, m: int) returns (result: string)\n    requires ValidInput(n, m)\n    ensures result == Winner(n, m)\n    ensures result == \"Akshat\" || result == \"Malvika\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_940", "vc-description": "Given three stick lengths, find the minimum number of operations to form a triangle\nwith positive area, where each operation increases any stick's length by 1 centimeter.\nA triangle has positive area if it satisfies the triangle inequality: the sum of any\ntwo sides must be greater than the third side.", "vc-preamble": "predicate ValidInput(a: int, b: int, c: int)\n{\n    1 <= a <= 100 && 1 <= b <= 100 && 1 <= c <= 100\n}\n\npredicate IsTriangle(a: int, b: int, c: int)\n{\n    a + b > c && a + c > b && b + c > a\n}\n\nfunction MinOperationsNeeded(a: int, b: int, c: int): int\n    requires ValidInput(a, b, c)\n{\n    var max_val := max(max(a, b), c);\n    var sum_of_other_two := a + b + c - max_val;\n    max(0, max_val - sum_of_other_two + 1)\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int, c: int) returns (result: int)\n    requires ValidInput(a, b, c)\n    ensures result >= 0\n    ensures result == MinOperationsNeeded(a, b, c)\n    ensures result == 0 <==> IsTriangle(a, b, c)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_948", "vc-description": "Given an n\u00d7m grid of lowercase Latin letters, count the number of 2\u00d72 squares \nwhere the four letters can form the word \"face\" (i.e., the four letters are \nexactly 'f', 'a', 'c', 'e' in any arrangement). Overlapping squares are counted separately.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| > 0\n}\n\npredicate ValidGrid(grid: seq<string>, n: int, m: int)\n{\n    n >= 1 && m >= 1 && |grid| == n &&\n    forall i :: 0 <= i < |grid| ==> |grid[i]| == m\n}\n\nfunction CountFaceSquares(input: string): int\n    requires |input| > 0\n    ensures CountFaceSquares(input) >= 0\n{\n    var lines := SplitLinesFunc(input);\n    if |lines| == 0 then 0\n    else\n        var firstLine := lines[0];\n        var nm := SplitSpacesFunc(firstLine);\n        if |nm| < 2 then 0\n        else\n            var n := StringToIntFunc(nm[0]);\n            var m := StringToIntFunc(nm[1]);\n            if n < 1 || m < 1 || |lines| < n + 1 then 0\n            else\n                var grid := lines[1..n+1];\n                CountValidSquares(grid, n, m)\n}\n\nfunction CountFaceSquaresAsString(input: string): string\n    requires |input| > 0\n    ensures |CountFaceSquaresAsString(input)| > 0\n{\n    var count := CountFaceSquares(input);\n    IntToStringFunc(count) + \"\\n\"\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires ValidInput(input)\n    ensures |result| > 0\n    ensures result == CountFaceSquaresAsString(input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_949", "vc-description": "Find the greatest common divisor of all integers in the range [a, b] inclusive,\nwhere 1 \u2264 a \u2264 b. If a = b, the GCD is a. If a < b, the GCD is 1 since\nconsecutive integers are coprime.", "vc-preamble": "predicate ValidInput(a: int, b: int)\n{\n    1 <= a <= b\n}\n\nfunction GcdOfRange(a: int, b: int): int\n    requires ValidInput(a, b)\n{\n    if a == b then a else 1\n}", "vc-helpers": "", "vc-spec": "method solve(a: int, b: int) returns (result: int)\n    requires ValidInput(a, b)\n    ensures result == GcdOfRange(a, b)\n    ensures a == b ==> result == a\n    ensures a < b ==> result == 1", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_95", "vc-description": "Given an array of integers, determine if it is unimodal.\nAn array is unimodal if it follows this exact pattern:\n1. An optional strictly increasing sequence at the beginning\n2. An optional constant sequence in the middle  \n3. An optional strictly decreasing sequence at the end\nAll three parts are optional, but if present, they must appear in this exact order.", "vc-preamble": "predicate ValidInput(n: nat, arr: seq<int>)\n{\n    n > 0 && |arr| == n && forall i :: 0 <= i < |arr| ==> arr[i] >= 1\n}\n\npredicate IsUnimodal(arr: seq<int>)\n    requires forall i :: 0 <= i < |arr| ==> arr[i] >= 1\n{\n    if |arr| <= 1 then true\n    else\n        var phases := ComputePhases(arr);\n        phases.0 <= phases.1 <= phases.2 == |arr| &&\n        (forall i, j :: 0 <= i < j < phases.0 ==> arr[i] < arr[j]) &&\n        (forall i :: phases.0 <= i < phases.1 ==> arr[i] == (if phases.0 > 0 then arr[phases.0] else arr[0])) &&\n        (forall i, j :: phases.1 <= i < j < phases.2 ==> arr[i] > arr[j]) &&\n        (phases.0 > 0 && phases.1 < |arr| ==> arr[phases.0-1] >= (if phases.1 > phases.0 then arr[phases.0] else arr[phases.1]))\n}\n\nfunction ComputePhases(arr: seq<int>): (int, int, int)\n    requires forall i :: 0 <= i < |arr| ==> arr[i] >= 1\n    ensures var (incEnd, constEnd, decEnd) := ComputePhases(arr); 0 <= incEnd <= constEnd <= decEnd <= |arr|\n{\n    var incEnd := ComputeIncreasingEnd(arr, 0, 0);\n    var constEnd := ComputeConstantEnd(arr, incEnd, if incEnd > 0 then arr[incEnd-1] else 0);\n    var decEnd := ComputeDecreasingEnd(arr, constEnd, if constEnd > incEnd then arr[incEnd] else if incEnd > 0 then arr[incEnd-1] else 0);\n    (incEnd, constEnd, decEnd)\n}", "vc-helpers": "", "vc-spec": "method solve(n: nat, arr: seq<int>) returns (result: string)\n    requires ValidInput(n, arr)\n    ensures result == \"YES\" || result == \"NO\"\n    ensures result == \"YES\" <==> IsUnimodal(arr)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_954", "vc-description": "Given a string, determine how many distinct strings can be obtained by repeatedly \napplying a cyclic shift operation. A cyclic shift moves the last character of the \nstring to the beginning.", "vc-preamble": "function CyclicShiftForward(s: string): string\n    requires |s| > 0\n{\n    s[1..] + [s[0]]\n}\n\npredicate ValidInput(s: string)\n{\n    |s| > 0\n}\n\nfunction ApplyShifts(s: string, steps: nat): string\n    requires |s| > 0\n    decreases steps\n{\n    if steps == 0 then s\n    else CyclicShiftForward(ApplyShifts(s, steps - 1))\n}\n\nfunction AllDistinctCyclicShifts(s: string): set<string>\n    requires |s| > 0\n{\n    set i | 0 <= i < |s| :: ApplyShifts(s, i)\n}", "vc-helpers": "", "vc-spec": "method solve(s: string) returns (result: int)\n    requires ValidInput(s)\n    ensures 1 <= result <= |s|\n    ensures result == |AllDistinctCyclicShifts(s)|", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_960", "vc-description": "Find the smallest positive integer x such that (x div k) \u00d7 (x mod k) = n,\nwhere x div k is integer division and x mod k is the remainder.", "vc-preamble": "predicate ValidInput(n: int, k: int) {\n  n >= 1 && k >= 2\n}\n\npredicate SatisfiesConstraint(x: int, n: int, k: int) {\n  x > 0 && k > 0 && (x / k) * (x % k) == n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int) returns (result: int)\n  requires ValidInput(n, k)\n  ensures result > 0\n  ensures SatisfiesConstraint(result, n, k)\n  ensures forall x :: x > 0 && (x / k) * (x % k) == n ==> result <= x", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_963", "vc-description": "Given N cells numbered 1 to N, find the number of ways to move from cell 1 to cell N.\nYou have K non-intersecting integer segments [L\u2081,R\u2081], [L\u2082,R\u2082], ..., [L\u2096,R\u2096].\nLet S be the union of all integers in these segments.\nFrom cell i, you can move to cell i+d where d \u2208 S, provided i+d \u2264 N.\nReturn the count modulo 998244353.", "vc-preamble": "predicate ValidInput(N: int, K: int, segments: seq<(int, int)>)\n{\n  N >= 2 &&\n  K >= 1 &&\n  |segments| == K &&\n  (forall i :: 0 <= i < K ==> segments[i].0 >= 1 && segments[i].1 <= N && segments[i].0 <= segments[i].1) &&\n  (forall i, j :: 0 <= i < j < K ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0)\n}\n\nfunction computeWaysDP(N: int, K: int, segments: seq<(int, int)>): int\n  requires ValidInput(N, K, segments)\n  ensures 0 <= computeWaysDP(N, K, segments) < 998244353\n{\n  var dp := map i {:trigger} | 0 <= i <= N :: if i == 1 then 1 else 0;\n  var prefixSum := map i {:trigger} | 0 <= i <= N :: if i == 1 then 1 else 0;\n  computeWaysDPHelper(N, K, segments, dp, prefixSum, 2)\n}\n\nfunction computeWaysDPHelper(N: int, K: int, segments: seq<(int, int)>, dp: map<int, int>, prefixSum: map<int, int>, pos: int): int\n  requires N >= 2 && K >= 1 && |segments| == K && 2 <= pos <= N + 1\n  requires forall i :: 0 <= i <= N ==> i in dp && i in prefixSum\n  requires forall i :: 0 <= i < K ==> segments[i].0 >= 1 && segments[i].1 <= N && segments[i].0 <= segments[i].1\n  requires forall i, j :: 0 <= i < j < K ==> segments[i].1 < segments[j].0 || segments[j].1 < segments[i].0\n  ensures 0 <= computeWaysDPHelper(N, K, segments, dp, prefixSum, pos) < 998244353\n  decreases N - pos + 1\n{\n  if pos > N then dp[N] % 998244353\n  else\n    var newDpVal := computeSegmentContributions(pos, K, segments, prefixSum, 0, 0);\n    var newPrefixSumVal := (prefixSum[pos-1] + newDpVal) % 998244353;\n    var updatedDP := dp[pos := newDpVal];\n    var updatedPrefixSum := prefixSum[pos := newPrefixSumVal];\n    computeWaysDPHelper(N, K, segments, updatedDP, updatedPrefixSum, pos + 1)\n}\n\nfunction computeSegmentContributions(pos: int, K: int, segments: seq<(int, int)>, prefixSum: map<int, int>, segIndex: int, acc: int): int\n  requires pos >= 2 && K >= 1 && |segments| == K && 0 <= segIndex <= K\n  requires forall i :: 0 <= i < pos ==> i in prefixSum\n  requires forall i :: 0 <= i < K ==> segments[i].0 >= 1 && segments[i].0 <= segments[i].1\n  requires 0 <= acc < 998244353\n  ensures 0 <= computeSegmentContributions(pos, K, segments, prefixSum, segIndex, acc) < 998244353\n  decreases K - segIndex\n{\n  if segIndex >= K then acc\n  else\n    var start := segments[segIndex].0;\n    var end := segments[segIndex].1;\n    var i_s := if pos - start >= 0 then pos - start else 0;\n    var i_e := if pos - end - 1 >= 0 then pos - end - 1 else 0;\n    var contribution := (prefixSum[i_s] - prefixSum[i_e] + 998244353) % 998244353;\n    var newAcc := (acc + contribution) % 998244353;\n    computeSegmentContributions(pos, K, segments, prefixSum, segIndex + 1, newAcc)\n}", "vc-helpers": "", "vc-spec": "method solve(N: int, K: int, segments: seq<(int, int)>) returns (result: int)\n  requires ValidInput(N, K, segments)\n  ensures 0 <= result < 998244353\n  ensures result == computeWaysDP(N, K, segments)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_965", "vc-description": "Given n players in a poker game with statuses \"ALLIN\" (A), \"IN\" (I), or \"FOLDED\" (F),\ndetermine how many players can show their hands. A player can show if their status\nis not \"FOLDED\" and all other players have status \"ALLIN\" or \"FOLDED\".", "vc-preamble": "predicate ValidInput(n: int, statuses: string)\n{\n    n >= 2 && |statuses| == n && \n    forall i :: 0 <= i < |statuses| ==> statuses[i] in {'A', 'I', 'F'}\n}\n\nfunction CountStatus(statuses: string, status: char): int\n{\n    |set i | 0 <= i < |statuses| && statuses[i] == status|\n}\n\nfunction ExpectedResult(statuses: string): int\n{\n    var cnt_I := CountStatus(statuses, 'I');\n    var cnt_A := CountStatus(statuses, 'A');\n    if cnt_I == 0 then cnt_A\n    else if cnt_I == 1 then 1\n    else 0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, statuses: string) returns (result: int)\n    requires ValidInput(n, statuses)\n    ensures result == ExpectedResult(statuses)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_966", "vc-description": "Given a year number, find the minimum year that is strictly greater than the given year \nand contains only distinct digits (no repeated digits).", "vc-preamble": "predicate ValidInput(y: int)\n{\n    1000 <= y <= 9000\n}\n\nfunction HasDistinctDigits(n: int): bool\n{\n    var digits := NumberToDigits(n);\n    AllDistinct(digits)\n}\n\nfunction NumberToDigits(n: int): seq<int>\n{\n    if n == 0 then [0]\n    else if n > 0 then NumberToDigitsHelper(n, [])\n    else NumberToDigitsHelper(-n, [])\n}\n\nfunction NumberToDigitsHelper(n: int, acc: seq<int>): seq<int>\nrequires n >= 0\ndecreases n\n{\n    if n == 0 then acc\n    else NumberToDigitsHelper(n / 10, [n % 10] + acc)\n}\n\npredicate AllDistinct(digits: seq<int>)\n{\n    forall i, j :: 0 <= i < j < |digits| ==> digits[i] != digits[j]\n}", "vc-helpers": "", "vc-spec": "method solve(y: int) returns (result: int)\nrequires ValidInput(y)\nensures result > y\nensures HasDistinctDigits(result)\nensures forall n :: y < n < result ==> !HasDistinctDigits(n)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_967", "vc-description": "Given n threads initially ordered 1, 2, ..., n, after some messages are posted, \nthe threads are reordered such that the thread now at position i was originally \nat position a_i. When a message is posted in a thread, that thread moves to the \ntop of the list. Find the number of threads that must have received new messages.\nA thread \"surely has a new message\" if there is no possible sequence of message \nposts that could result in the given reordering without that thread receiving a message.", "vc-preamble": "predicate ValidInput(n: int, a: seq<int>)\n{\n    n >= 1 &&\n    |a| == n &&\n    (forall i :: 0 <= i < n ==> 1 <= a[i] <= n) &&\n    (forall i, j :: 0 <= i < j < n ==> a[i] != a[j])\n}\n\npredicate ValidOutput(n: int, result: int)\n{\n    0 <= result <= n\n}\n\nfunction ReversedArray(a: seq<int>): seq<int>\n    requires |a| >= 1\n    ensures |ReversedArray(a)| == |a|\n{\n    seq(|a|, i requires 0 <= i < |a| => a[|a|-1-i])\n}\n\npredicate HasIncreasingPair(ar: seq<int>)\n{\n    exists i :: 1 <= i < |ar| && ar[i] > ar[i-1]\n}\n\nfunction CorrectResult(n: int, a: seq<int>): int\n    requires ValidInput(n, a)\n    ensures ValidOutput(n, CorrectResult(n, a))\n{\n    var ar := ReversedArray(a);\n    if HasIncreasingPair(ar) then\n        var min_i := MinIndex(ar, n);\n        n - min_i\n    else\n        0\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures ValidOutput(n, result)\n    ensures result == CorrectResult(n, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_968", "vc-description": "Given n people, each with a first name and last name, determine if each person can choose \neither their first or last name as a handle such that when the handles are sorted \nlexicographically, they appear in the exact order specified by permutation p.", "vc-preamble": "predicate ValidInput(input: string)\n  requires |input| > 0\n{\n  var parsed := ParseInput(input);\n  parsed.Valid && \n  parsed.n >= 1 && \n  |parsed.names| == parsed.n &&\n  |parsed.permutation| == parsed.n &&\n  (forall i :: 0 <= i < parsed.n ==> 1 <= parsed.permutation[i] <= parsed.n) &&\n  (forall i, j :: 0 <= i < j < parsed.n ==> parsed.permutation[i] != parsed.permutation[j]) &&\n  (forall i :: 0 <= i < parsed.n ==> |parsed.names[i].0| > 0 && |parsed.names[i].1| > 0) &&\n  AllNamesDistinct(parsed.names)\n}\n\npredicate AllNamesDistinct(names: seq<(string, string)>)\n{\n  forall i, j :: 0 <= i < |names| && 0 <= j < |names| ==>\n    (i != j ==> names[i].0 != names[j].0 && names[i].0 != names[j].1 && \n                names[i].1 != names[j].0 && names[i].1 != names[j].1)\n}\n\npredicate CanAssignHandlesGreedy(input: string)\n  requires |input| > 0\n  requires ValidInput(input)\n{\n  var parsed := ParseInput(input);\n  var all_handles := CreateAllHandlePairs(parsed.names);\n  var sorted_handles := SortHandlePairs(all_handles);\n  GreedyAssignmentWorks(sorted_handles, parsed.permutation, parsed.n)\n}\n\ndatatype ParseResult = ParseResult(\n  Valid: bool,\n  n: int,\n  names: seq<(string, string)>,\n  permutation: seq<int>\n)\n\ndatatype IntResult = IntResult(Valid: bool, Value: int)\n\ndatatype IntSequenceResult = IntSequenceResult(Valid: bool, Sequence: seq<int>)\n\nfunction ParseInput(input: string): ParseResult\n  requires |input| > 0\n{\n  var lines := SplitLines(input);\n  if |lines| < 2 then ParseResult(false, 0, [], [])\n  else\n    var n_result := ParseInt(lines[0]);\n    if !n_result.Valid || n_result.Value <= 0 || |lines| != n_result.Value + 2\n    then ParseResult(false, 0, [], [])\n    else\n      var names := ParseNames(lines[1..n_result.Value+1]);\n      var perm := ParseIntSequence(lines[n_result.Value+1]);\n      if |names| == n_result.Value && perm.Valid && |perm.Sequence| == n_result.Value\n      then ParseResult(true, n_result.Value, names, perm.Sequence)\n      else ParseResult(false, 0, [], [])\n}\n\npredicate LexLess(a: string, b: string)\n{\n  if |a| == 0 then |b| > 0\n  else if |b| == 0 then false\n  else if a[0] < b[0] then true\n  else if a[0] > b[0] then false\n  else LexLess(a[1..], b[1..])\n}\n\npredicate LexLessOrEqual(a: string, b: string)\n{\n  LexLess(a, b) || a == b\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n  requires |stdin_input| > 0\n  requires ValidInput(stdin_input)\n  ensures result == \"YES\" || result == \"NO\"\n  ensures result == \"YES\" <==> CanAssignHandlesGreedy(stdin_input)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_98", "vc-description": "Given a rectangular board and two rectangular paintings, determine if both paintings \ncan be placed on the board without overlapping or extending beyond edges. Each rectangle \ncan be rotated 90 degrees.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    var lines := SplitLinesFunc(input);\n    |lines| >= 3 &&\n    var boardParts := SplitSpacesFunc(lines[0]);\n    var paint1Parts := SplitSpacesFunc(lines[1]);\n    var paint2Parts := SplitSpacesFunc(lines[2]);\n    |boardParts| >= 2 && |paint1Parts| >= 2 && |paint2Parts| >= 2 &&\n    IsValidInt(boardParts[0]) && IsValidInt(boardParts[1]) &&\n    IsValidInt(paint1Parts[0]) && IsValidInt(paint1Parts[1]) &&\n    IsValidInt(paint2Parts[0]) && IsValidInt(paint2Parts[1])\n}\n\npredicate CanPlaceBothPaintings(a: int, b: int, c: int, d: int, e: int, f: int)\n{\n    (c+e <= a && Max(d,f) <= b) ||\n    (c+e <= b && Max(d,f) <= a) ||\n    (c+f <= a && Max(d,e) <= b) ||\n    (c+f <= b && Max(d,e) <= a) ||\n    (d+e <= a && Max(c,f) <= b) ||\n    (d+e <= b && Max(c,f) <= a) ||\n    (d+f <= a && Max(c,e) <= b) ||\n    (d+f <= b && Max(c,e) <= a)\n}\n\nfunction Max(x: int, y: int): int\n{\n    if x >= y then x else y\n}\n\npredicate IsValidInt(s: string)\n{\n    |s| > 0 && forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'\n}\n\nfunction SplitLinesFunc(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else SplitLinesHelper(s, 0, \"\", [])\n}\n\nfunction SplitLinesHelper(s: string, i: nat, current: string, lines: seq<string>): seq<string>\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then lines + [current] else lines\n    else if s[i] == '\\n' then\n        if |current| > 0 then \n            SplitLinesHelper(s, i+1, \"\", lines + [current])\n        else \n            SplitLinesHelper(s, i+1, \"\", lines)\n    else\n        SplitLinesHelper(s, i+1, current + [s[i]], lines)\n}\n\nfunction SplitSpacesFunc(s: string): seq<string>\n{\n    if |s| == 0 then []\n    else SplitSpacesHelper(s, 0, \"\", [])\n}\n\nfunction SplitSpacesHelper(s: string, i: nat, current: string, parts: seq<string>): seq<string>\n    decreases |s| - i\n{\n    if i >= |s| then\n        if |current| > 0 then parts + [current] else parts\n    else if s[i] == ' ' || s[i] == '\\t' then\n        if |current| > 0 then \n            SplitSpacesHelper(s, i+1, \"\", parts + [current])\n        else \n            SplitSpacesHelper(s, i+1, \"\", parts)\n    else\n        SplitSpacesHelper(s, i+1, current + [s[i]], parts)\n}\n\nfunction ParseIntFunc(s: string): int\n    requires IsValidInt(s)\n{\n    ParseIntHelper(s, 0, 0)\n}\n\nfunction ParseIntHelper(s: string, i: nat, acc: nat): nat\n    requires i <= |s|\n    requires forall j :: 0 <= j < |s| ==> '0' <= s[j] <= '9'\n    decreases |s| - i\n{\n    if i >= |s| then acc\n    else ParseIntHelper(s, i+1, acc * 10 + (s[i] as int - '0' as int))\n}", "vc-helpers": "", "vc-spec": "method solve(input: string) returns (result: string)\n    requires |input| > 0\n    ensures result == \"YES\\n\" || result == \"NO\\n\" || result == \"\"\n    ensures ValidInput(input) ==> (\n        result == \"YES\\n\" <==> (\n            var lines := SplitLinesFunc(input);\n            var boardParts := SplitSpacesFunc(lines[0]);\n            var paint1Parts := SplitSpacesFunc(lines[1]);\n            var paint2Parts := SplitSpacesFunc(lines[2]);\n            var a := ParseIntFunc(boardParts[0]);\n            var b := ParseIntFunc(boardParts[1]);\n            var c := ParseIntFunc(paint1Parts[0]);\n            var d := ParseIntFunc(paint1Parts[1]);\n            var e := ParseIntFunc(paint2Parts[0]);\n            var f := ParseIntFunc(paint2Parts[1]);\n            CanPlaceBothPaintings(a, b, c, d, e, f)\n        )\n    )\n    ensures !ValidInput(input) ==> result == \"\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_983", "vc-description": "Given an array of n integers and coefficients p, q, r, find the maximum value of \np\u00b7a_i + q\u00b7a_j + r\u00b7a_k where indices i, j, k satisfy 1 \u2264 i \u2264 j \u2264 k \u2264 n.", "vc-preamble": "function max_prefix(s: seq<int>, i: int): int\n    requires 0 <= i < |s|\n{\n    if i == 0 then s[0]\n    else if s[i] > max_prefix(s, i-1) then s[i]\n    else max_prefix(s, i-1)\n}\n\nfunction max_seq(s: seq<int>): int\n    requires |s| > 0\n{\n    if |s| == 1 then s[0]\n    else if s[|s|-1] > max_seq(s[..|s|-1]) then s[|s|-1]\n    else max_seq(s[..|s|-1])\n}\n\nfunction max_expression(n: int, p: int, q: int, r: int, a: seq<int>): int\n    requires n > 0\n    requires |a| == n\n{\n    var s1 := seq(n, i requires 0 <= i < n => a[i] * p);\n    var s2 := seq(n, i requires 0 <= i < n => max_prefix(s1, i) + a[i] * q);\n    var s3 := seq(n, i requires 0 <= i < n => max_prefix(s2, i) + a[i] * r);\n    max_seq(s3)\n}\n\npredicate ValidInput(n: int, a: seq<int>)\n{\n    n > 0 && |a| == n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, p: int, q: int, r: int, a: seq<int>) returns (result: int)\n    requires ValidInput(n, a)\n    ensures result == max_expression(n, p, q, r, a)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_985", "vc-description": "Given n bishops on a 1000\u00d71000 grid, count the number of pairs that attack each other.\nTwo bishops attack each other if and only if they are on the same diagonal (either main diagonal or anti-diagonal).\nMain diagonal: x - y is constant, Anti-diagonal: x + y is constant.", "vc-preamble": "predicate ValidInput(positions: seq<(int, int)>)\n{\n    |positions| >= 1 && |positions| <= 200000 &&\n    (forall i :: 0 <= i < |positions| ==> \n        1 <= positions[i].0 <= 1000 && 1 <= positions[i].1 <= 1000) &&\n    (forall i, j :: 0 <= i < j < |positions| ==> positions[i] != positions[j])\n}\n\nfunction CountAttackingPairs(positions: seq<(int, int)>): int\n    requires ValidInput(positions)\n{\n    |set i, j | 0 <= i < j < |positions| && \n               (positions[i].0 + positions[i].1 == positions[j].0 + positions[j].1 ||\n                positions[i].0 - positions[i].1 == positions[j].0 - positions[j].1) :: (i, j)|\n}\n\npredicate ValidOutput(positions: seq<(int, int)>, result: int)\n    requires ValidInput(positions)\n{\n    result == CountAttackingPairs(positions) && result >= 0\n}", "vc-helpers": "", "vc-spec": "method SolveBishops(positions: seq<(int, int)>) returns (result: int)\n    requires ValidInput(positions)\n    ensures ValidOutput(positions, result)\n    ensures result >= 0", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_986", "vc-description": "Given n books numbered 1 to n and a library with capacity k, over n consecutive days\na person requests book a_i on day i. The library starts empty and each book costs 1 CHF.\nWhen at capacity, one existing book must be removed before adding a new one.\nFind the minimum cost to satisfy all requests using optimal cache replacement strategy.", "vc-preamble": "predicate ValidInput(n: int, k: int, requests: seq<int>)\n{\n    n >= 1 && k >= 1 && |requests| == n &&\n    forall i :: 0 <= i < |requests| ==> 1 <= requests[i] <= n\n}\n\npredicate ValidSolution(n: int, k: int, requests: seq<int>, cost: int)\n{\n    ValidInput(n, k, requests) && cost >= 0 && cost <= n\n}", "vc-helpers": "", "vc-spec": "method solve(n: int, k: int, requests: seq<int>) returns (cost: int)\n    requires ValidInput(n, k, requests)\n    ensures ValidSolution(n, k, requests, cost)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_989", "vc-description": "Given a sequence of n integers, perform at most k operations where each operation\nincreases or decreases any element by 1. Find the minimum possible difference\nbetween the maximum and minimum elements after performing these operations.", "vc-preamble": "predicate ValidInput(input: string)\n{\n    |input| >= 5 && hasValidFormat(input)\n}\n\npredicate hasValidFormat(input: string)\n{\n    exists firstNewline: nat :: \n        firstNewline < |input| && \n        input[firstNewline] == '\\n' &&\n        (|input| == firstNewline + 1 || input[|input| - 1] == '\\n')\n}\n\npredicate IsValidResultString(result: string)\n{\n    |result| > 0 && \n    (result == \"0\" || (result[0] != '0' && forall i :: 0 <= i < |result| ==> isDigit(result[i])))\n}\n\npredicate isDigit(c: char)\n{\n    '0' <= c <= '9'\n}\n\npredicate RepresentsMinimumDifference(input: string, result: string)\n{\n    ValidInput(input) && \n    IsValidResultString(result) &&\n    result == \"0\"\n}\n\nfunction max(a: seq<int>): int\n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else if a[0] >= max(a[1..]) then a[0]\n    else max(a[1..])\n}\n\nfunction min(a: seq<int>): int  \n    requires |a| > 0\n{\n    if |a| == 1 then a[0]\n    else if a[0] <= min(a[1..]) then a[0] \n    else min(a[1..])\n}\n\nfunction intToString(n: int): string\n{\n    if n == 0 then \"0\"\n    else if n > 0 then intToStringHelper(n)\n    else \"-\" + intToStringHelper(-n)\n}", "vc-helpers": "", "vc-spec": "method solve(stdin_input: string) returns (result: string)\n    requires ValidInput(stdin_input)\n    ensures IsValidResultString(result)\n    ensures RepresentsMinimumDifference(stdin_input, result)", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
{"id": "apps_test_992", "vc-description": "Given N positive integers A\u2081, A\u2082, ..., A\u2099 and a positive integer S,\nfor each non-empty subset T of {1, 2, ..., N}, define f(T) as the number \nof non-empty subsets of T whose corresponding A values sum to S.\nFind the sum of f(T) over all 2\u1d3a - 1 non-empty subsets T, modulo 998244353.", "vc-preamble": "predicate ValidInput(n: int, s: int, a: seq<int>)\n{\n    n >= 1 && n <= 3000 &&\n    s >= 1 && s <= 3000 &&\n    |a| == n &&\n    forall i :: 0 <= i < n ==> a[i] >= 1 && a[i] <= 3000\n}\n\nfunction ComputeSubsetSumWays(n: int, s: int, a: seq<int>): int\n    requires ValidInput(n, s, a)\n{\n    var dp := ComputeDPTable(n, s, a);\n    if |dp| > n && |dp[n]| > s then dp[n][s] else 0\n}\n\nfunction ComputeDPTable(n: int, s: int, a: seq<int>): seq<seq<int>>\n    requires n >= 1 && s >= 1 && |a| == n\n    requires forall i :: 0 <= i < n ==> a[i] >= 1\n    ensures |ComputeDPTable(n, s, a)| == n + 1\n    ensures forall i :: 0 <= i < |ComputeDPTable(n, s, a)| ==> |ComputeDPTable(n, s, a)[i]| == s + 1\n    decreases n\n{\n    if n == 1 then\n        var base := seq(s+1, j => if j == 0 then 1 else 0);\n        var new_row := seq(s+1, j requires 0 <= j < s+1 => \n            var doubled := (base[j] * 2) % 998244353;\n            if j >= a[0] && j - a[0] >= 0 && j - a[0] < s+1 then \n                (doubled + base[j - a[0]]) % 998244353\n            else \n                doubled\n        );\n        [base, new_row]\n    else\n        var prev_dp := ComputeDPTable(n-1, s, a[..n-1]);\n        var new_row := seq(s+1, j requires 0 <= j < s+1 => \n            var doubled := (prev_dp[n-1][j] * 2) % 998244353;\n            if j >= a[n-1] && j - a[n-1] >= 0 && j - a[n-1] < s+1 then \n                (doubled + prev_dp[n-1][j - a[n-1]]) % 998244353\n            else \n                doubled\n        );\n        prev_dp + [new_row]\n}\n\nfunction SplitLines(s: string): seq<string>\n{\n    [\"\", \"\"]\n}\n\nfunction SplitWhitespace(s: string): seq<string>  \n{\n    [\"\"]\n}\n\nfunction StringToInt(s: string): int\n{\n    0\n}\n\nfunction IntToString(n: int): string\n{\n    \"0\"\n}\n\npredicate ValidParsedInput(input: string, n: int, s: int, a: seq<int>)\n{\n    var lines := SplitLines(input);\n    |lines| >= 2 &&\n    var first_line := SplitWhitespace(lines[0]);\n    var second_line := SplitWhitespace(lines[1]);\n    |first_line| >= 2 && |second_line| == n &&\n    n == StringToInt(first_line[0]) &&\n    s == StringToInt(first_line[1]) &&\n    |a| == n &&\n    (forall i :: 0 <= i < n ==> (a[i] == StringToInt(second_line[i]))) &&\n    ValidInput(n, s, a)\n}\n\npredicate ValidParsedInputExists(input: string)\n{\n    var lines := SplitLines(input);\n    if |lines| < 2 then false\n    else\n        var first_line := SplitWhitespace(lines[0]);\n        var second_line := SplitWhitespace(lines[1]);\n        if |first_line| < 2 || |second_line| == 0 then false\n        else\n            var n := StringToInt(first_line[0]);\n            var s := StringToInt(first_line[1]);\n            n >= 1 && n <= 3000 && s >= 1 && s <= 3000 && |second_line| == n &&\n            forall i :: 0 <= i < n ==> \n                var ai := StringToInt(second_line[i]);\n                ai >= 1 && ai <= 3000\n}", "vc-helpers": "", "vc-spec": "method Solve(stdin_input: string) returns (result: string)\n    requires |stdin_input| > 0\n    ensures |result| > 0\n    ensures result[|result|-1] == '\\n'\n    ensures \n        if ValidParsedInputExists(stdin_input) then\n            exists n, s, a :: \n                ValidParsedInput(stdin_input, n, s, a) &&\n                StringToInt(result[..|result|-1]) == ComputeSubsetSumWays(n, s, a) % 998244353\n        else\n            result == \"0\\n\"", "vc-code": "{\n  assume {:axiom} false;\n}", "vc-postamble": "", "qa_metadata": {"functions_with_default_values": [], "methods_with_bodies": [], "score": 338, "near_duplicates": {"examples": [], "total_count": 0}, "base_score": 338}}
