vc-description: |-
  Assume you are creating a webshop and you would like to help the user in the search. You have products with brands, prices and name. You have the history of opened products (the most recently opened being the first item).
  
  Your task is to create a list of brands ordered by popularity, if two brands have the same popularity level then choose the one which was opened last from the two and second the other one.
  
  Product popularity is calculated from the history. If a product is more times in the history than it is more popular.
  
  Your function will have one parameter which will be always an array/list of object.
  
  example product:
  {
    name: "Phone",
    price: 25,
    brand: "Fake brand"
  }

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def sorted_brands (history : List Product) : List String :=
    sorry

vc-theorems: |-
  theorem sorted_brands_unique_brands {history : List Product} : 
    let result := sorted_brands history
    List.length result = List.length (List.eraseDups result) := by
    sorry
  
  theorem sorted_brands_subset {history : List Product} :
    let result := sorted_brands history
    match history with
    | [] => result = []
    | _ => result = (List.map (fun h => h.brand) history).eraseDups 
    := by 
    sorry
  
  theorem sorted_brands_frequency_order {history : List Product} :
    let result := sorted_brands history
    let brand_counts := fun b => 
      (List.filter (fun h => h.brand = b) history).length
    ∀ (i j : Fin result.length), i.val < j.val →
      brand_counts (result[i]) ≥ brand_counts (result[j]) := by
    sorry
  
  theorem sorted_brands_equal_freq_ordering {history : List Product} :
    let result := sorted_brands history
    let brand_counts := fun b => 
      (List.filter (fun h => h.brand = b) history).length
    let first_index := fun b => 
      Option.get! (List.findIdx? (fun h => h.brand = b) history)
    ∀ (i j : Fin result.length), i.val < j.val →
      brand_counts (result[i]) = brand_counts (result[j]) →
      first_index (result[i]) < first_index (result[j]) := by
    sorry
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval sorted_brands []
  
  /--
  info: ['Fake brand']
  -/
  #guard_msgs in
  #eval sorted_brands [product1]
  
  /--
  info: ['Fake brand', 'Other brand']
  -/
  #guard_msgs in
  #eval sorted_brands [product1, product2, product3, product1]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

