vc-description: |-
  Given an integer array arr and an integer k, modify the array by repeating it k times.
  For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].
  Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.
  As the answer can be very large, return the answer modulo 10^9 + 7.
  
  Example 1:
  Input: arr = [1,2], k = 3
  Output: 9
  
  Example 2:
  Input: arr = [1,-2,1], k = 5
  Output: 2
  
  Example 3:
  Input: arr = [-1,-2], k = 7
  Output: 0
  
  Constraints:
  
  1 <= arr.length <= 10^5
  1 <= k <= 10^5
  -10^4 <= arr[i] <= 10^4

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def MOD := 1000000007
  
  def kConcatenationMaxSum (arr : List Int) (k : Nat) : Int :=
    sorry

vc-theorems: |-
  theorem kconcat_nonnegative (arr : List Int) (k : Nat) :
    k > 0 → kConcatenationMaxSum arr k ≥ 0 := sorry
  
  theorem kconcat_mod_bound (arr : List Int) (k : Nat) :
    k > 0 → kConcatenationMaxSum arr k < MOD := sorry
  
  theorem kconcat_k1_maxsubarray (arr : List Int) :
    kConcatenationMaxSum arr 1 = kConcatenationMaxSum arr 1 := sorry
  
  theorem kconcat_empty (k : Nat) :
    k > 0 → kConcatenationMaxSum [] k = 0 := sorry
  
  theorem kconcat_monotone_positive (arr : List Int) (k : Nat) :
    k > 1 →
    (arr.foldl (· + ·) 0 > 0) →
    kConcatenationMaxSum arr k ≥ kConcatenationMaxSum arr (k-1) := sorry
  
  /--
  info: 9
  -/
  #guard_msgs in
  #eval kConcatenationMaxSum [1, 2] 3
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval kConcatenationMaxSum [1, -2, 1] 5
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval kConcatenationMaxSum [-1, -2] 7

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

