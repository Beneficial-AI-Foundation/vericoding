vc-description: |-
  /-
  We are given a linked list with head as the first node.  Let's number the nodes in the list: node_1, node_2, node_3, ... etc.
  Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j > i, node_j.val > node_i.val, and j is the smallest possible choice.  If such a j does not exist, the next larger value is 0.
  Return an array of integers answer, where answer[i] = next_larger(node_{i+1}).
  Note that in the example inputs (not outputs) below, arrays such as [2,1,5] represent the serialization of a linked list with a head node value of 2, second node value of 1, and third node value of 5.
  
  Example 1:
  Input: [2,1,5]
  Output: [5,5,0]
  
  Example 2:
  Input: [2,7,4,3,5]
  Output: [7,0,5,5,0]
  
  Example 3:
  Input: [1,7,5,1,9,2,5,1]
  Output: [7,9,9,9,0,5,0,0]
  
  Note:
  
  1 <= node.val <= 10^9 for each node in the linked list.
  The given list has length in the range [0, 10000].
  -/

vc-preamble: |-
  def nextLargerNodes (head : Option ListNode) : List Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def isDecreasing (l : List Nat) : Prop :=
    ∀ i j, i < j → j < l.length → l.get! i ≥ l.get! j

vc-theorems: |-
  theorem empty_list :
    nextLargerNodes none = [] ∧
    nextLargerNodes (some (ListNode.mk 0 none)) = [] :=
    sorry
  
  theorem single_node (v : Nat) :
    nextLargerNodes (some (ListNode.mk v none)) = [0] :=
    sorry
  
  theorem output_length_matches_input {vals : List Nat} {head : Option ListNode} :
    nextLargerNodes head = vals → List.length (nextLargerNodes head) = List.length vals :=
    sorry
  
  theorem output_zero_or_greater {vals : List Nat} {head : Option ListNode} {i : Nat} :
    i < List.length vals →
    match (nextLargerNodes head).get? i with
    | some x => x = 0 ∨ x > vals.get! i
    | none => True
    :=
    sorry
  
  theorem output_values_in_input {vals : List Nat} {head : Option ListNode} {x : Nat} :
    x ∈ nextLargerNodes head → x = 0 ∨ x ∈ vals :=
    sorry
  
  theorem nonzero_has_larger_after {vals : List Nat} {head : Option ListNode} {i : Nat} :
    i < List.length vals →
    (nextLargerNodes head).get! i ≠ 0 →
    ∃ j, j > i ∧ j < List.length vals ∧ vals.get! j ≥ (nextLargerNodes head).get! i :=
    sorry
  
  theorem decreasing_list_gives_zeros {vals : List Nat} {head : Option ListNode} :
    List.length vals ≥ 2 →
    isDecreasing vals →
    nextLargerNodes head = List.replicate (List.length vals) 0 :=
    sorry
  
  /-
  info: [5, 5, 0]
  -/
  -- #guard_msgs in
  -- #eval nextLargerNodes create_linked_list([2, 1, 5])
  
  /-
  info: [7, 0, 5, 5, 0]
  -/
  -- #guard_msgs in
  -- #eval nextLargerNodes create_linked_list([2, 7, 4, 3, 5])
  
  /-
  info: [7, 9, 9, 9, 0, 5, 0, 0]
  -/
  -- #guard_msgs in
  -- #eval nextLargerNodes create_linked_list([1, 7, 5, 1, 9, 2, 5, 1])

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

