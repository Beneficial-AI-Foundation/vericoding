vc-description: |-
  Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.


  Example:
  For num = 5 you should return [0,1,1,2,1,2].


  Follow up:

  It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?
  Space complexity should be O(n).
  Can you do it like a boss? Do it without using any builtin function like __builtin_popcount  in c++ or in any other language.



  Credits:Special thanks to @ syedee  for adding this problem and creating all test cases.
vc-preamble: |
  import Imports.AllImports

  def count_bits (n : Nat) : Array Nat := sorry

  def countOnes (n : Nat) : Nat := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def isPowerOfTwo (n : Nat) : Prop := 
    n > 0 ∧ ∃ k, n = 2^k
vc-theorems: |
  theorem count_bits_length (n : Nat) (h : n ≤ 1000) : 
    (count_bits n).size = n + 1 := sorry


  theorem count_bits_value (n : Nat) (h : n ≤ 1000) (i : Nat) (h2 : i ≤ n) 
    (h3 : i < (count_bits n).size) :
    (count_bits n)[i]'h3 = countOnes i := sorry


  theorem count_bits_power_of_two (n : Nat) (h : n ≤ 1000) (i : Nat) (h2 : i ≤ n)
    (h3 : i < (count_bits n).size) :
    i > 0 → isPowerOfTwo i → (count_bits n)[i]'h3 = 1 := sorry

  /--
  info: [0, 1, 1, 2, 1, 2]
  -/
  #guard_msgs in
  #eval count_bits 5

  /--
  info: [0]
  -/
  #guard_msgs in
  #eval count_bits 0

  /--
  info: [0, 1, 1]
  -/
  #guard_msgs in
  #eval count_bits 2
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
