vc-description: |-
  Don't Drink the Water
  
  Given a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.
  
  ```
  ======================
  |   Density Chart    |
  ======================
  | Honey   | H | 1.36 |
  | Water   | W | 1.00 |
  | Alcohol | A | 0.87 |
  | Oil     | O | 0.80 |
  ----------------------
  
  [                            [
   ['H', 'H', 'W', 'O'],        ['O','O','O','O']
   ['W', 'W', 'O', 'W'],  =>    ['W','W','W','W']
   ['H', 'H', 'O', 'O']         ['H','H','H','H']
   ]                           ]
  
   ```
  
   The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.

vc-preamble: |-
  def liquidDensity (l: Liquid) : Float :=
    match l with
    | Liquid.H => 1.36
    | Liquid.W => 1.0
    | Liquid.A => 0.87
    | Liquid.O => 0.8

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def separate_liquids (glass: List (List Liquid)) : List (List Liquid) := sorry
  
  theorem count_preserving (glass: List (List Liquid)) : 
    let input_counts := ((glass.join.filter (fun x => x == Liquid.H)).length,
                        (glass.join.filter (fun x => x == Liquid.W)).length,
                        (glass.join.filter (fun x => x == Liquid.A)).length,
                        (glass.join.filter (fun x => x == Liquid.O)).length);
    let output := separate_liquids glass;
    let output_counts := ((output.join.filter (fun x => x == Liquid.H)).length,
                         (output.join.filter (fun x => x == Liquid.W)).length,
                         (output.join.filter (fun x => x == Liquid.A)).length, 
                         (output.join.filter (fun x => x == Liquid.O)).length);
    input_counts = output_counts := sorry

vc-theorems: |-
  theorem density_layering (glass: List (List Liquid)) :
    let result := separate_liquids glass
    ∀ i j, i < j → j < result.length →
    ∀ k, k < (result.get! i).length →
    liquidDensity ((result.get! i).get! k) ≤ liquidDensity ((result.get! j).get! k) := sorry
  
  theorem empty_glass :
    separate_liquids [] = [] := sorry
  
  /--
  info: expected1
  -/
  #guard_msgs in
  #eval separate_liquids [["H", "H", "W", "O"], ["W", "W", "O", "W"], ["H", "H", "O", "O"]]
  
  /--
  info: expected2
  -/
  #guard_msgs in
  #eval separate_liquids [["A", "H", "W", "O"]]
  
  /--
  info: expected3
  -/
  #guard_msgs in
  #eval separate_liquids []

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

