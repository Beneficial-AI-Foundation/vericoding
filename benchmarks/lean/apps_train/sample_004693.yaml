vc-description: |-
  Create a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.
  
  Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.
  
  Example:
  ```python
  solution(1000) # should return 'M'
  ```
  
  Help:
  ```
  Symbol  Value
  I             1
  V             5
  X             10
  L             50
  C             100
  D             500
  M             1,000
  ```
  
  Remember that there can't be more than 3 identical symbols in a row.
  
  More about roman numerals - http://en.wikipedia.org/wiki/Roman_numerals

vc-preamble: |-
  def solution (n : Nat) : String := sorry
  
  def isSubstring (s₁ s₂ : String) : Bool := sorry
  
  /-- Map Roman numerals to their decimal values -/
  
  def romanValues : List (Char × Nat) := 
    [('I', 1), ('V', 5), ('X', 10), ('L', 50), ('C', 100), ('D', 500), ('M', 1000)]

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def convertToNums (s : String) : List Nat := sorry
  
  theorem monotonically_decreasing_values (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :
    let numericValues := convertToNums (solution n)
    ∀ i j, i < j → j < numericValues.length → 
      (numericValues.get ⟨i, sorry⟩) ≥ (numericValues.get ⟨j, sorry⟩) := sorry

vc-theorems: |-
  theorem valid_roman_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :
    ∀ c, String.contains (solution n) c → c ∈ ['M', 'D', 'C', 'L', 'X', 'V', 'I'] := sorry
  
  theorem length_constraints (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :
    (n ≤ 3 → (solution n).length ≤ 3) ∧ 
    (n ≤ 8 → (solution n).length ≤ 4) ∧
    (n ≤ 39 → (solution n).length ≤ 6) := sorry
  
  theorem no_four_consecutive_chars (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :
    ¬isSubstring "IIII" (solution n) ∧ 
    ¬isSubstring "XXXX" (solution n) ∧ 
    ¬isSubstring "CCCC" (solution n) ∧ 
    ¬isSubstring "MMMM" (solution n) := sorry
  
  theorem valid_subtractive_pairs (n : Nat) (h : 1 ≤ n ∧ n ≤ 3999) :
    ¬isSubstring "IL" (solution n) ∧
    ¬isSubstring "IC" (solution n) ∧
    ¬isSubstring "ID" (solution n) ∧
    ¬isSubstring "IM" (solution n) ∧
    ¬isSubstring "XD" (solution n) ∧
    ¬isSubstring "XM" (solution n) := sorry
  
  /--
  info: 'I'
  -/
  #guard_msgs in
  #eval solution 1
  
  /--
  info: 'MCMXC'
  -/
  #guard_msgs in
  #eval solution 1990
  
  /--
  info: 'MMVIII'
  -/
  #guard_msgs in
  #eval solution 2008

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

