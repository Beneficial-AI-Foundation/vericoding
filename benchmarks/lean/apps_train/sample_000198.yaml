vc-description: |-
  Let's call any (contiguous) subarray B (of A) a mountain if the following properties hold:

  B.length >= 3
  There exists some 0 < i < B.length - 1 such that B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]

  (Note that B could be any subarray of A, including the entire array A.)
  Given an array A of integers, return the length of the longest mountain. 
  Return 0 if there is no mountain.
  Example 1:
  Input: [2,1,4,7,3,2,5]
  Output: 5
  Explanation: The largest mountain is [1,4,7,3,2] which has length 5.

  Example 2:
  Input: [2,2,2]
  Output: 0
  Explanation: There is no mountain.

  Note:

  0 <= A.length <= 10000
  0 <= A[i] <= 10000

  Follow up:

  Can you solve it using only one pass?
  Can you solve it in O(1) space?
vc-preamble: |
  import Imports.AllImports

  def longestMountain (arr : Array Int) : Nat :=
    sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def isSorted (arr : Array Int) : Bool :=
    sorry
vc-theorems: |
  theorem mountain_length_min_or_zero {arr : Array Int} :
    let result := longestMountain arr
    result = 0 ∨ result ≥ 3
    := sorry


  theorem mountain_length_bounded {arr : Array Int} :
    longestMountain arr ≤ arr.size
    := sorry


  theorem flat_sequence_no_mountain {arr : Array Int} :
    let doubled := arr.concatMap (fun x => #[x, x]) 
    longestMountain doubled = 0
    := sorry




  theorem single_element_no_mountain {x : Int} :
    longestMountain #[x] = 0
    := sorry

  /--
  info: 5
  -/
  #guard_msgs in
  #eval longestMountain #[2, 1, 4, 7, 3, 2, 5]

  /--
  info: 0
  -/
  #guard_msgs in
  #eval longestMountain #[2, 2, 2]

  /--
  info: 9
  -/
  #guard_msgs in
  #eval longestMountain #[1, 2, 3, 4, 5, 4, 3, 2, 1]
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible
