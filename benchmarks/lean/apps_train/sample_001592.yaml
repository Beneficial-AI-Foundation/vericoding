vc-description: |-
  We want to generate all the numbers of three digits where:

  - the sum of their digits is equal to 10.

  - their digits are in increasing order (the numbers may have two or more equal contiguous digits)

  The numbers that fulfill the two above constraints are: ```118, 127, 136, 145, 226, 235, 244, 334```

  Make a function that receives two arguments:

  - the sum of digits value 

  - the desired number of digits for the numbers

  The function should output an array with three values: \[1,2,3\]

  1 - the total number of possible numbers

  2 - the minimum number

  3 - the maximum number

  The example given above should be:

  ```python
  find_all(10, 3) == [8, 118, 334]
  ```

  If we have only one possible number as a solution, it should output a result like the one below:

  ```python
  find_all(27, 3) == [1, 999, 999]
  ```

  If there are no possible numbers, the function should output the empty array.

  ```python
  find_all(84, 4) == []
  ```

  The number of solutions climbs up when the number of digits increases.

  ```python
  find_all(35, 6) == [123, 116999, 566666]
  ```

  Features of the random tests:

  * Number of tests: `112`
  * Sum of digits value between `20` and `65`
  * Amount of digits between `2` and `17`
vc-preamble: |
  import Imports.AllImports

  def sumDigits (n : Nat) : Nat := sorry

  def isAscending (n : Nat) : Bool := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def numDigits (n : Nat) : Nat := sorry

  def find_all (sumDig digs : Nat) : Option (Nat × Nat × Nat) := sorry
vc-theorems: |
  theorem empty_for_impossible_sums (sumDig digs : Nat) :
    (sumDig > 9 * digs ∨ sumDig < digs) → find_all sumDig digs = none := sorry


  theorem valid_output_format {sumDig digs : Nat} (res : Nat × Nat × Nat) :
    find_all sumDig digs = some res →
    let (count, first, last) := res
    count > 0 ∧
    numDigits first = digs ∧
    numDigits last = digs ∧ 
    first ≤ last := sorry


  theorem solutions_have_correct_sum {sumDig digs : Nat} (res : Nat × Nat × Nat) :
    find_all sumDig digs = some res →
    let (_, first, last) := res
    sumDigits first = sumDig ∧
    sumDigits last = sumDig := sorry


  theorem solutions_are_ascending {sumDig digs : Nat} (res : Nat × Nat × Nat) :
    find_all sumDig digs = some res →
    let (_, first, last) := res
    isAscending first ∧
    isAscending last := sorry

  /--
  info: [8, 118, 334]
  -/
  #guard_msgs in
  #eval find_all 10 3

  /--
  info: [1, 999, 999]
  -/
  #guard_msgs in
  #eval find_all 27 3

  /--
  info: []
  -/
  #guard_msgs in
  #eval find_all 84 4
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
