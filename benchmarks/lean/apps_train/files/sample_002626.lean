/-
```if-not:ruby
Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.
```
```if:ruby
Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with `nil`s.
```

Examples:

```python
interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
interleave([]) == []
```
-/

-- <vc-helpers>
-- </vc-helpers>

def interleave {α : Type} : List α → List α → List α 
  | l, [] => l
  | [], l => l
  | (x::xs), (y::ys) => x :: y :: interleave xs ys

theorem interleave_single_list {α : Type} (lst : List α) : 
  interleave lst [] = lst := by sorry

theorem interleave_length {α : Type} (l₁ l₂ : List α) :
  List.length (interleave l₁ l₂) = 2 * max (List.length l₁) (List.length l₂) := by sorry

theorem interleave_elements {α : Type} [Inhabited α] (l₁ l₂ : List α) (i : Nat) :
  i < List.length l₁ → List.get! (interleave l₁ l₂) (2*i) = List.get! l₁ i := by sorry

theorem interleave_elements_second {α : Type} [Inhabited α] (l₁ l₂ : List α) (i : Nat) :
  i < List.length l₂ → List.get! (interleave l₁ l₂) (2*i + 1) = List.get! l₂ i := by sorry

theorem interleave_empty_left {α : Type} : 
  interleave ([] : List α) [] = [] := by sorry

theorem interleave_empty_right {α : Type} :
  interleave [] ([] : List α) = [] := by sorry

/-
info: [1, 'c', 2, 'd', 3, 'e']
-/
-- #guard_msgs in
-- #eval interleave [1, 2, 3] ["c", "d", "e"]

/-
info: [1, 4, 2, 5, 3, None]
-/
-- #guard_msgs in
-- #eval interleave [1, 2, 3] [4, 5]

/-
info: [1, 4, 7, 2, 5, 8, 3, 6, 9]
-/
-- #guard_msgs in
-- #eval interleave [1, 2, 3] [4, 5, 6] [7, 8, 9]

-- Apps difficulty: introductory
-- Assurance level: unguarded