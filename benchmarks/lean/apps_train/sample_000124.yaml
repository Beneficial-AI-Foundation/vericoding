vc-description: |-
  Given a string s, return the maximum number of ocurrences of any substring under the following rules:

  The number of unique characters in the substring must be less than or equal to maxLetters.
  The substring size must be between minSize and maxSize inclusive.

   
  Example 1:
  Input: s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
  Output: 2
  Explanation: Substring "aab" has 2 ocurrences in the original string.
  It satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).

  Example 2:
  Input: s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
  Output: 2
  Explanation: Substring "aaa" occur 2 times in the string. It can overlap.

  Example 3:
  Input: s = "aabcabcab", maxLetters = 2, minSize = 2, maxSize = 3
  Output: 3

  Example 4:
  Input: s = "abcde", maxLetters = 2, minSize = 3, maxSize = 3
  Output: 0

   
  Constraints:

  1 <= s.length <= 10^5
  1 <= maxLetters <= 26
  1 <= minSize <= maxSize <= min(26, s.length)
  s only contains lowercase English letters.
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def max_freq (s : String) (max_letters min_size max_size : Nat) : Nat :=
    sorry
vc-theorems: |
  theorem max_freq_basic_bounds 
    (s : String) (max_letters min_size max_size : Nat)
    (h1 : min_size ≤ max_size)
    (h2 : min_size ≤ s.length) :
    let result := max_freq s max_letters min_size max_size
    -- Result is non-negative (implied by Nat)
    -- Result bounded by possible windows
    result ≤ s.length - min_size + 1 := 
  sorry


  theorem max_freq_single_letter
    (s : String) (max_letters min_size max_size : Nat)
    (h1 : max_letters = 1)
    (h2 : min_size = s.length) :
    let result := max_freq s max_letters min_size max_size
    result ≤ 1 :=
  sorry


  theorem max_freq_identical_string
    (s : String) (c : Char)
    (h1 : s.length > 0)
    (h2 : ∀ i : String.Pos, s.get i = c) :
    let min_size := 1
    let result := max_freq s 1 min_size min_size
    result = s.length - min_size + 1 :=
  sorry


  theorem max_freq_binary_string
    (s : String) (window_size : Nat)
    (h1 : s.length ≥ 3)
    (h2 : s.length ≤ 10) 
    (h3 : window_size ≤ s.length)
    (h4 : ∀ i : String.Pos, s.get i = 'a' ∨ s.get i = 'b') :
    let result := max_freq s 2 window_size window_size
    result ≤ s.length - window_size + 1 :=
  sorry

  /--
  info: 2
  -/
  #guard_msgs in
  #eval max_freq "aababcaab" 2 3 4

  /--
  info: 2
  -/
  #guard_msgs in
  #eval max_freq "aaaa" 1 3 3

  /--
  info: 3
  -/
  #guard_msgs in
  #eval max_freq "aabcabcab" 2 2 3
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
