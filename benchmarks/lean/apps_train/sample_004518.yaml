vc-description: |-
  The fusc function is defined recursively as follows:
  
      1. fusc(0) = 0
      2. fusc(1) = 1
      3. fusc(2 * n) = fusc(n)
      4. fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
  
  The 4 rules above are sufficient to determine the value of `fusc` for any non-negative input `n`. For example, let's say you want to compute `fusc(10)`. 
  
  1. `fusc(10) = fusc(5)`, by rule 3.
  2. `fusc(5) = fusc(2) + fusc(3)`, by rule 4.
  3. `fusc(2) = fusc(1)`, by rule 3.
  4. `fusc(1) = 1`, by rule 2.
  5. `fusc(3) = fusc(1) + fusc(2)` by rule 4.
  6. `fusc(1)` and `fusc(2)` have already been computed are both equal to `1`.
  
  Putting these results together `fusc(10) = fusc(5) = fusc(2) + fusc(3) = 1 + 2 = 3`
  
  Your job is to produce the code for the `fusc` function. In this kata, your function will be tested with small values of `n`, so you should not need to be concerned about stack overflow or timeouts. 
  
  Hint: Use recursion.
  
  When done, move on to [Part 2](http://www.codewars.com/kata/the-fusc-function-part-2).

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def fusc (n : Nat) : Nat := sorry
  
  theorem fusc_non_negative (n : Nat) : fusc n ≥ 0 := sorry

vc-theorems: |-
  theorem fusc_even_reduce (n : Nat) (h : n > 0) (h2 : n % 2 = 0) : 
    fusc n = fusc (n / 2) := sorry
  
  theorem fusc_odd_sum (n : Nat) (h : n % 2 = 1) :
    fusc n = fusc (n / 2) + fusc (n / 2 + 1) := sorry
  
  theorem fusc_base_cases :
    fusc 0 = 0 ∧ fusc 1 = 1 := sorry
  
  theorem fusc_monotonic_bound (n : Nat) :
    fusc n ≤ n := sorry
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval fusc 0
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval fusc 1
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval fusc 10

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

