vc-description: |-
  per nextum in unam tum XI conscribementis fac sic

      vestibulo perlegementum da varo.

      morde varo.

      seqis cumula varum.

  cis



  per nextum in unam tum XI conscribementis fac sic

      seqis decumulamenta da varo.

      varum privamentum fodementum da aresulto.

      varum tum III elevamentum tum V multiplicamentum da bresulto.

      aresultum tum bresultum addementum da resulto.



      si CD tum resultum non praestantiam fac sic

          dictum sic f(%d) = %.2f cis tum varum tum resultum egresso describe.

          novumversum egresso scribe.

      cis

      si CD tum resultum praestantiam fac sic

          dictum sic f(%d) = MAGNA NIMIS! cis tum varum egresso describe.

          novumversum egresso scribe.        

      cis

  cis




  -----Input-----

  The input consists of several integers, one per line. Each integer is between -50 and 50, inclusive.


  -----Output-----

  As described in the problem statement.


  -----Example-----
  Input
  0
  1
  -2
  -3
  -4
  -5
  -6
  -7
  -8
  -9
  10

  Output
  f(10) = MAGNA NIMIS!
  f(-9) = -3642.00
  f(-8) = -2557.17
  f(-7) = -1712.35
  f(-6) = -1077.55
  f(-5) = -622.76
  f(-4) = -318.00
  f(-3) = -133.27
  f(-2) = -38.59
  f(1) = 6.00
  f(0) = 0.00
vc-preamble: |
  import Imports.AllImports

  def calculateSequences : List Int → List String := sorry

  structure FormatResult where
    isStartF : Bool
    containsAssign : Bool


  def checkFormat (s : String) : FormatResult :=
    { isStartF := s.data.head? = some 'f',
      containsAssign := s.data.contains '=' }
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def extractValue (s : String) : String := sorry
  def extractNumber (s : String) : Int := sorry
vc-theorems: |
  theorem list_format_properties {inputs : List Int} :
    let result := calculateSequences inputs
    ∀ x ∈ result,
      let fmt := checkFormat x
      fmt.isStartF ∧ fmt.containsAssign := sorry


  theorem value_format_properties {inputs : List Int} :
    let result := calculateSequences inputs
    ∀ x ∈ result,
      let n := extractNumber x
      let val := extractValue x
      (n ≥ 5 ∨ n ≤ -51 → val = "MAGNA NIMIS!") ∧
      (n ≤ 3 → val.data.contains '.') := sorry


  theorem order_matches_reversed {inputs : List Int} : 
    let result := calculateSequences inputs
    let nums := result.map extractNumber
    nums = inputs.reverse := sorry


  theorem known_values {inputs : List Int} (h : inputs.length > 0) :
    let result := calculateSequences inputs
    ∀ x ∈ result,
      let n := extractNumber x
      let val := extractValue x
      (n = 0 → val = "0.00") ∧
      (n = 1 → val = "6.00") ∧ 
      (n = -1 → val = "-4.00") := sorry

  /--
  info: expected1
  -/
  #guard_msgs in
  #eval calculate_sequences [0, 1, -2, -3, -4, -5, -6, -7, -8, -9, 10]
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
