vc-description: |-
  Your job is to write a function that takes a string and a maximum number of characters per line and then inserts line breaks as necessary so that no line in the resulting string is longer than the specified limit.
  
  If possible, line breaks should not split words. However, if a single word is longer than the limit, it obviously has to be split. In this case, the line break should be placed after the first part of the word (see examples below).
  
  Really long words may need to be split multiple times.
  
  #Input
  
  A word consists of one or more letters.
  
  Input text will be the empty string or a string consisting of one or more words separated by single spaces. It will not contain any punctiation or other special characters.
  
  The limit will always be an integer greater or equal to one.
  
  #Examples
  
  **Note:** Line breaks in the results have been replaced with two dashes to improve readability.
  
  1. ("test", 7) -> "test"
  2. ("hello world", 7) -> "hello--world"
  3. ("a lot of words for a single line", 10) -> "a lot of--words for--a single--line"
  4. ("this is a test", 4) -> "this--is a--test"
  5. ("a longword", 6) -> "a long--word"
  6. ("areallylongword", 6) -> "areall--ylongw--ord"
  
  **Note:** Sometimes spaces are hard to see in the test results window.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def word_wrap (text : String) (limit : Nat) : String := sorry
  
  theorem word_wrap_line_length {text : String} {limit : Nat}
    (h_text : ∀ c ∈ text.data, c.isAlpha ∨ c = ' ')
    (h_limit : limit > 0) :
    let result := word_wrap text limit
    ∀ line ∈ result.splitOn "\n", line.length ≤ limit := sorry

vc-theorems: |-
  theorem word_wrap_preserves_content {text : String} {limit : Nat}
    (h_text : ∀ c ∈ text.data, c.isAlpha ∨ c = ' ')
    (h_limit : limit > 0) :
    let result := word_wrap text limit
    (String.join (text.splitOn " ")).data = (String.join (result.replace "\n" "" |>.splitOn " ")).data := sorry
  
  theorem single_word_wrap_properties {text : String} {limit : Nat}
    (h_text : ∀ c ∈ text.data, c.isAlpha)
    (h_text_nonempty : text.length > 0)
    (h_limit : limit > 0)
    (h_limit_bound : limit ≤ text.length) :
    let result := word_wrap text limit
    let lines := result.splitOn "\n"
    (∀ i : Fin lines.length, i.val < lines.length - 1 → (lines[i]).length = limit) ∧
    (match lines.get? (lines.length - 1) with
     | none => 0
     | some lastLine => lastLine.length) ≤ limit ∧
    String.join lines = text := sorry
  
  theorem multiple_words_no_splitting {words : List String} {limit : Nat}
    (h_words_nonempty : words ≠ [])
    (h_words_alpha : ∀ w ∈ words, ∀ c ∈ w.data, c.isAlpha)
    (h_max_word := words.map String.length |>.maximum?)
    (h_limit : ∀ w ∈ words, w.length < limit) :
    let text := String.join (List.intersperse " " words)
    let result := word_wrap text limit
    (result.replace "\n" " ").splitOn " " = words := sorry
  
  /--
  info: 'test'
  -/
  #guard_msgs in
  #eval word_wrap "test" 7
  
  /--
  info: 'hello\nworld'
  -/
  #guard_msgs in
  #eval word_wrap "hello world" 7
  
  /--
  info: 'areall\nylongw\nord'
  -/
  #guard_msgs in
  #eval word_wrap "areallylongword" 6

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

