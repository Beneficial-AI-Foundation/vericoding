vc-description: |-
  Anmol gained a lot of weight last semester. So this semester, he decided to run everyday. There is a very long straight road starting at his hostel. There are N poles on the road - P1, P2, P3,..., PN on the road. All the poles lie on the same side of his hostel. The distance between Pi and his hostel is Di.
  For 1 ≤ i, j ≤ N, i < j implies Di < Dj
  Everyday, Anmol chooses a pole Pi to start running from. He keeps on running until he reaches Pi+K. Whenever he reaches a pole (other than the starting pole), he records the distance traveled since the last pole.

  You are given the distances recorded by him today. Your task is to find the number of distinct values of i such that i + K ≤ N and if he starts at Pi and end at Pi+K, he would end up having exactly the same record of distances (in the same order).

  -----Input-----
  - The first line of the input contains an integer T denoting the number of test cases.
  - The first line of each test case contains two space separated integers N and K.
  - The next line contains N space separated integers D1, D2,..., DN.
  - The next line contains K space separated integers representing the distances recorded by Anmol in the same order.
  .

  -----Output-----
  - For each test case, output a single line containing the answer for that test case.

  -----Constraints-----
  - 1 ≤ T ≤ 10
  - 2 ≤ N ≤ 5 x 104
  - 1 ≤ K < N
  - 1 ≤ Di ≤ 106

  -----Subtasks-----

  -----Subtask #1 (20 points)-----
  - 1 ≤ N ≤ 1000

  -----Subtask #2 (80 points)-----
  - Original constraints

  -----Example-----
  Input:
  3
  5 1
  1 5 10 12 14
  5
  5 2
  5 8 13 16 21
  3 5
  5 3
  2 6 8 11 16
  2 3 5

  Output:
  1
  2
  1

  -----Explanation-----
  Example case 1. If he runs from P2 to P3, he will record (5)
  Example case 2. He can start at P1 or P3
  Example case 3. He can start at P2
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |-
  def solve_running_patterns (n : Nat) (k : Nat) (distances : List Nat) (recorded : List Nat) : Nat :=
    sorry

  /-- The output is a natural number between 0 and n-k -/
vc-theorems: |
  theorem solve_running_patterns_bounds (n k : Nat) (distances recorded : List Nat) 
      (hn : n ≥ 2) (hk : k > 0) (hk2 : k < n)
      (hdist : distances.length = n)
      (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)
      (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j)
      (hrec : recorded.length = k) :
      let result := solve_running_patterns n k distances recorded
      0 ≤ result ∧ result ≤ n - k :=
    sorry

  /-- A pattern matches against itself at least once -/

  theorem solve_running_patterns_self_match (n k : Nat) (distances : List Nat)
      (hn : n ≥ 3) (hk : k > 0) (hk2 : k < n)
      (hdist : distances.length = n)
      (hdist_sorted : ∀ i j, i < j → j < n → distances.get! i ≤ distances.get! j)
      (hdist_unique : ∀ i j, i < j → j < n → distances.get! i ≠ distances.get! j) :
      let diffs := List.zipWith (fun x y => x - y) (distances.drop 1) distances
      let pattern := List.take k diffs
      solve_running_patterns n k distances pattern ≥ 1 :=
    sorry

  /-- Basic cases work correctly -/

  theorem solve_running_patterns_basic_cases :
      solve_running_patterns 2 1 [1,2] [1] = 1 ∧ 
      solve_running_patterns 3 1 [1,2,3] [1] = 2 :=
    sorry

  /--
  info: 1
  -/
  #guard_msgs in
  #eval solve_running_patterns 5 1 [1, 5, 10, 12, 14] [5]

  /--
  info: 2
  -/
  #guard_msgs in
  #eval solve_running_patterns 5 2 [5, 8, 13, 16, 21] [3, 5]

  /--
  info: 1
  -/
  #guard_msgs in
  #eval solve_running_patterns 5 3 [2, 6, 8, 11, 16] [2, 3, 5]
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
