vc-description: |-
  You are a skier (marked below by the `X`). You have made it to the Olympics! Well done.

  ```
  \_\_\_X\_
  \*\*\*\*\*\
  \*\*\*\*\*\*\
  \*\*\*\*\*\*\*\
  \*\*\*\*\*\*\*\*\
  \*\*\*\*\*\*\*\*\*\\.\_\_\_\_/
  ```

  Your job in this kata is to calculate the maximum speed you will achieve during your downhill run. The speed is dictated by the height of the mountain. Each element of the array is a layer of the mountain as indicated by the diagram above (and further below). So for this example the mountain has a height of 5 (5 rows of stars). `Speed` is `mountain height * 1.5`.

  The jump length is calculated by `(mountain height * speed * 9) / 10`. Jump length should be rounded to 2 decimal places.

  You must return the length of the resulting jump as a string in the following format:

  * when less than 10 m: `"X metres: He's crap!"`
  * between 10 and 25 m: `"X metres: He's ok!"`
  * between 25 and 50 m: `"X metres: He's flying!"`
  * when more than 50 m: `"X metres: Gold!!"`

  So in the example case above, the right answer would be `"33.75 metres: He's flying!"`

  Sadly, it takes a lot of time to make arrays look like mountains, so the tests wont all look so nice. To give an example, the above mountain would look as follows in most cases:

  ```
  [*****, ******, *******, ********, *********]
  ```
  Not as much fun, eh?

  *p.s. if you think "metre" is incorrect, please [read this](https://en.wikipedia.org/wiki/Metre#Spelling)*
vc-preamble: |
  import Imports.AllImports

  def ski_jump (mountain: List String) : String := sorry

  def isValidMessage (msg: String) : Bool :=
    msg = "He's crap!" || msg = "He's ok!" || msg = "He's flying!" || msg = "Gold!!"
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def stringToFloat (s: String) : Float := sorry -- helper function

  theorem ski_jump_output_format {mountain : List String} (h : mountain.length > 0) :
    let result := ski_jump mountain
    let parts := result.splitOn " metres: "
    parts.length = 2 ∧ 
    (let number := parts[0]!
     let message := parts[1]!
     stringToFloat number ≥ 0 ∧
     isValidMessage message) :=
  sorry
vc-theorems: |
  theorem jump_length_proportional_to_height {mountain : List String} (h : mountain.length > 0) :
    let result := ski_jump mountain
    let jumpLength := stringToFloat (result.splitOn " metres: ")[0]!
    jumpLength = Float.ofNat mountain.length * (Float.ofNat mountain.length * 1.5) * 0.9 :=
  sorry


  theorem message_thresholds {mountain : List String} (h : mountain.length > 0) :
    let result := ski_jump mountain
    let length := stringToFloat (result.splitOn " metres: ")[0]!
    let message := (result.splitOn "metres: ")[1]!
    (length < 10 → message = "He's crap!") ∧
    (length ≥ 10 ∧ length < 25 → message = "He's ok!") ∧
    (length ≥ 25 ∧ length < 50 → message = "He's flying!") ∧
    (length ≥ 50 → message = "Gold!!") :=
  sorry

  /--
  info: "1.35 metres: He's crap!"
  -/
  #guard_msgs in
  #eval ski_jump ["*"]

  /--
  info: "12.15 metres: He's ok!"
  -/
  #guard_msgs in
  #eval ski_jump ["*", "**", "***"]

  /--
  info: "48.60 metres: He's flying!"
  -/
  #guard_msgs in
  #eval ski_jump ["*", "**", "***", "****", "*****", "******"]
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
