vc-description: |-
  Chef is the event manager of his college. He has been assigned the task to manage the upcoming tech fest. There are $K$ rooms where the event can take place, and at a particular time only one event can be organized in a room for a particular time interval.
  Each event coordinator has their strictly preferred room $P_i$, and if the room is already occupied he simply cancels that event.Chef wants to maximize the total number of events,and so he allows or disallows certain events in order to achieve the task . Chef is busy handling his events so the chef needs your help .
  Given a list of $N$ events with their start time $S_i$,end time $E_i$ and preferred room $P_i$,you need to calculate the maximum number of events that can take place.
  Note that the $i$th event wants to occupy the $p_i$ room from [$s_i$, $f_i$) .
  
  -----Input:-----
  The first line contains an integer $T$ denoting the number of test cases . Each of the next $T$ lines contains two integers $N$ and $K$ , the number of events and the number of rooms respectively . Each of the next $N$ lines contains three integers $s_i$ ,$e_i$ and $p_i$,the start time ,end time and the preferred room of ith event.
  
  -----Output:-----
  Print the maximum number of events that can take place.
  
  -----Constraints-----
  - $1 \leq T \leq 100$
  - $1 \leq N \leq 10^3$
  - $1 \leq  K \leq 10^5$
  - $1 \leq  Si <  Ei \leq 10^9$
  - $1 \leq Pi \leq K$
  
  -----Sample Input:-----
  1
  
  4 2
  1 10 1
  10 20 2
  15 50 2
  20 30 2
  
  -----Sample Output:-----
  3
  
  -----EXPLANATION:-----
  Chef can allow events 1st ,2nd and 4th,to get the maximum 3.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def solve_events (n k : Nat) (events : List Event) : Nat :=
    sorry

vc-theorems: |-
  theorem solve_events_basic_properties {n k : Nat} {events : List Event}
    (h1 : n > 0)
    (h2 : k > 0)
    (h3 : n ≤ 100)
    (h4 : k ≤ 100)
    (h5 : ∀ e ∈ events, e.room ≥ 1 ∧ e.room ≤ k)
    (h6 : ∀ e ∈ events, e.start < e.stop)
    (h7 : ∀ e ∈ events, e.start ≤ 10^5-1)
    (h8 : ∀ e ∈ events, e.stop ≤ 10^5) :
    let result := solve_events n k events
    result ≥ 0 ∧ result ≤ events.length ∧ result ≤ n :=
    sorry
  
  theorem solve_events_empty (n k : Nat)
    (h1 : n > 0)
    (h2 : k > 0)
    (h3 : n ≤ 100)
    (h4 : k ≤ 100) :
    solve_events n k [] = 0 :=
    sorry
  
  theorem solve_events_single (n k start duration : Nat)
    (h1 : n > 0)
    (h2 : k > 0)
    (h3 : n ≤ 100)
    (h4 : k ≤ 100)
    (h5 : start > 0)
    (h6 : start ≤ 10^5-1)
    (h7 : duration > 0)
    (h8 : duration ≤ 100) :
    solve_events n k [{start := start, stop := start + duration, room := 1}] = 1 :=
    sorry
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval solve_events 4 2 [[1, 10, 1], [10, 20, 2], [15, 50, 2], [20, 30, 2]]
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval solve_events 2 1 [[1, 5, 1], [2, 3, 1]]
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval solve_events 3 2 [[1, 2, 1], [2, 3, 1], [1, 3, 2]]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

