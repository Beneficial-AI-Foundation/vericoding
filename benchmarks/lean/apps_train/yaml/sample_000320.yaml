vc-description: |-
  You are given a rows x cols matrix grid. Initially, you are located at the top-left corner (0, 0), and in each step, you can only move right or down in the matrix.
  Among all possible paths starting from the top-left corner (0, 0) and ending in the bottom-right corner (rows - 1, cols - 1), find the path with the maximum non-negative product. The product of a path is the product of all integers in the grid cells visited along the path.
  Return the maximum non-negative product modulo 109 + 7. If the maximum product is negative return -1.
  Notice that the modulo is performed after getting the maximum product.
  
  Example 1:
  Input: grid = [[-1,-2,-3],
                 [-2,-3,-3],
                 [-3,-3,-2]]
  Output: -1
  Explanation: It's not possible to get non-negative product in the path from (0, 0) to (2, 2), so return -1.
  
  Example 2:
  Input: grid = [[1,-2,1],
                 [1,-2,1],
                 [3,-4,1]]
  Output: 8
  Explanation: Maximum non-negative product is in bold (1 * 1 * -2 * -4 * 1 = 8).
  
  Example 3:
  Input: grid = [[1, 3],
                 [0,-4]]
  Output: 0
  Explanation: Maximum non-negative product is in bold (1 * 0 * -4 = 0).
  
  Example 4:
  Input: grid = [[ 1, 4,4,0],
                 [-2, 0,0,1],
                 [ 1,-1,1,1]]
  Output: 2
  Explanation: Maximum non-negative product is in bold (1 * -2 * 1 * -1 * 1 * 1 = 2).
  
  Constraints:
  
  1 <= rows, cols <= 15
  -4 <= grid[i][j] <= 4

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def maxProductPath (grid : List (List Int)) : Int := sorry
  
  def is_valid_result (grid : List (List Int)) (result : Int) : Bool := sorry

vc-theorems: |-
  theorem empty_grid_theorem (n : Nat) : 
    maxProductPath [] = -1 ∧ maxProductPath (List.replicate n []) = -1 := sorry
  
  theorem zero_grid_theorem (rows cols : Nat) (h1 : rows > 0) (h2 : cols > 0) :
    let grid := List.replicate rows (List.replicate cols 0)
    maxProductPath grid = 0 := sorry
  
  theorem all_positive_grid_theorem (rows cols : Nat) (h1 : rows > 0) (h2 : cols > 0) :
    let grid := List.replicate rows (List.replicate cols 1)
    maxProductPath grid = 1 := sorry
  
  theorem result_properties_theorem (grid : List (List Int)) 
    (h1 : grid.length > 0)
    (h2 : ∀ row ∈ grid, row.length = grid.head!.length) :
    let result := maxProductPath grid
    (
      -- Result should be valid
      (result = -1 ∨ (0 ≤ result ∧ result ≤ 10^9 + 7)) ∧
  
      -- If first or last element is 0, result should be 0
      ((grid.head!.head! = 0 ∨ grid.getLast!.getLast! = 0) → result = 0) ∧
  
      -- If grid is 1x1, result should match single element if non-negative
      (grid.length = 1 ∧ grid.head!.length = 1 →
        result = if grid.head!.head! ≥ 0 then grid.head!.head! else -1)
    ) := sorry
  
  /--
  info: -1
  -/
  #guard_msgs in
  #eval maxProductPath [[-1, -2, -3], [-2, -3, -3], [-3, -3, -2]]
  
  /--
  info: 8
  -/
  #guard_msgs in
  #eval maxProductPath [[1, -2, 1], [1, -2, 1], [3, -4, 1]]
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval maxProductPath [[1, 3], [0, -4]]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

