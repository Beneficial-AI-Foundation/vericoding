vc-description: |-
  Triangular numbers count the number of objects that can form an equilateral triangle. The nth triangular number forms an equilateral triangle with n dots on each side (including the vertices).
  Here is a graphic example for the triangular numbers of 1 to 5:
  ```
  n=1: triangular number: 1
  *
  
  n=2: triangular number: 3
   *
  * *
  
  n=3: triangular number: 6
    *
   * *
  * * *
  
  n=4: triangular number: 10
      *
     * *
    * * *
   * * * *
  
   n=5: triangular number: 15
        *
       * *
      * * *
     * * * *
    * * * * *
  ```
  
  Your task is to implement a function ```triangular_range(start, stop)``` that returns a dictionary of all numbers as keys and the belonging triangular numbers as values, where the triangular number is in the range start, stop (including start and stop).
  For example, ```triangular_range(1, 3)``` should return ```{1: 1, 2: 3}``` and ```triangular_range(5, 16)``` should return ```{3: 6, 4: 10, 5: 15}```.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def triangular_range (start stop : Int) : List (Int × Int) := sorry
  
  theorem triangular_range_is_valid (start stop : Int) (h : stop ≥ start) :
    let result := triangular_range start stop
    ∀ (n tri : Int), (n, tri) ∈ result →
      (n > 0 ∧ 
       tri = (n * (n + 1)) / 2 ∧
       start ≤ tri ∧ tri ≤ stop) := 
  sorry

vc-theorems: |-
  theorem triangular_range_single_point (n : Int) (h : n > 0) :
    let tri := (n * (n + 1)) / 2
    triangular_range tri tri = [(n, tri)] ∨ triangular_range tri tri = [] :=
  sorry
  
  theorem triangular_range_empty_invalid_range (start stop : Int) :
    stop < start → triangular_range start stop = [] :=
  sorry
  
  theorem triangular_range_empty_negative (start stop : Int) :
    stop < 0 → triangular_range start stop = [] :=
  sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

