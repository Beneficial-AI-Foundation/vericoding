vc-description: |-
  /-
  A famous casino is suddenly faced with a sharp decline of their revenues. They decide to offer Texas hold'em also online. Can you help them by writing an algorithm that can rank poker hands? 
  
  Task:
  
  Create a poker hand that has a constructor that accepts a string containing 5 cards:
  
  ```python
  hand = PokerHand("KS 2H 5C JD TD")
  ```
  
  The characteristics of the string of cards are:
  
  A space is used as card seperator
  Each card consists of two characters
  The first character is the value of the card, valid characters are:
  `2, 3, 4, 5, 6, 7, 8, 9, T(en), J(ack), Q(ueen), K(ing), A(ce)`
  The second character represents the suit, valid characters are: 
  `S(pades), H(earts), D(iamonds), C(lubs)`
  
  The poker hands must be sortable by rank, the highest rank first:
  
  ```python
  hands = []
  hands.append(PokerHand("KS 2H 5C JD TD"))
  hands.append(PokerHand("2C 3C AC 4C 5C"))
  hands.sort() (or sorted(hands))
  ```
  
  Apply the Texas Hold'em rules for ranking the cards. 
  There is no ranking for the suits.
  An ace can either rank high or rank low in a straight or straight flush. Example of a straight with a low ace:
  `"5C 4D 3C 2S AS"`
  
  Note:  there are around 25000 random tests, so keep an eye on performances.
  -/

vc-preamble: |-
  def VALID_VALUES := ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']
  def VALID_SUITS := ['S', 'H', 'D', 'C'] 
  
  structure Card where
    value : Char
    suit : Char
    deriving Repr
  
  structure Hand where
    cards : List Card
    deriving Repr
  
  def Hand.maxCount (h : Hand) : Nat := sorry
  def Hand.maxCard (h : Hand) : Char := sorry 
  
  def Hand.remaining (h : Hand) : List Char := sorry
  def Hand.isFlush (h : Hand) : Bool := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def Hand.isStraight (h : Hand) : Bool := sorry
  def Hand.gt (h1 h2 : Hand) : Bool := sorry

vc-theorems: |-
  theorem hand_initialization (cards : List Card) (h : Hand) : 
    cards.length = 5 ∧
    ∀ c ∈ cards, c.value ∈ VALID_VALUES ∧ c.suit ∈ VALID_SUITS := sorry
  
  theorem hand_properties (h : Hand) :
    1 ≤ h.maxCount ∧ h.maxCount ≤ 4 ∧
    h.maxCard ∈ VALID_VALUES ∧
    ∀ r ∈ h.remaining, r ∈ VALID_VALUES := sorry
  
  theorem hand_comparison_reflexive (h : Hand) :
    ¬(Hand.gt h h) := sorry
  
  theorem hand_comparison_antisymmetric (h1 h2 : Hand) :
    Hand.gt h1 h2 → ¬(Hand.gt h2 h1) := sorry
  
  theorem hand_comparison_transitive (h1 h2 : Hand) :
    h1 = h2 → ¬(Hand.gt h1 h2) ∧ ¬(Hand.gt h2 h1) := sorry
  
  theorem straight_flush_beats_others (h : Hand) :
    ¬(h.isStraight ∧ h.isFlush) →
    Hand.gt (Hand.mk [
      {value := 'A', suit := 'S'},
      {value := 'K', suit := 'S'}, 
      {value := 'Q', suit := 'S'},
      {value := 'J', suit := 'S'},
      {value := 'T', suit := 'S'}
    ]) h := sorry
  
  theorem flush_consistency (h : Hand) :
    h.isFlush → List.length (List.map Card.suit h.cards) = 5 ∧ 
    ∀ (c1 c2 : Card), c1 ∈ h.cards → c2 ∈ h.cards → c1.suit = c2.suit := sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

