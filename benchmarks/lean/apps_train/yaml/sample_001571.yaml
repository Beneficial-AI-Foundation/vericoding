vc-description: |-
  # Task
   Sorting is one of the most basic computational devices used in Computer Science. 
  
   Given a sequence (length ≤ 1000) of 3 different key values (7, 8, 9), your task is to find the minimum number of exchange operations necessary to make the sequence sorted. 
  
   One operation is the switching of 2 key values in the sequence.
  
  # Example
  
   For `sequence = [7, 7, 8, 8, 9, 9]`, the result should be `0`.
  
   It's already a sorted sequence.
  
   For `sequence = [9, 7, 8, 8, 9, 7]`, the result should be `1`.
  
   We can switching `sequence[0]` and `sequence[5]`.
  
   For `sequence = [8, 8, 7, 9, 9, 9, 8, 9, 7]`, the result should be `4`.
  
   We can:
  ```
   [8, 8, 7, 9, 9, 9, 8, 9, 7] 
   switching sequence[0] and sequence[3]
   --> [9, 8, 7, 8, 9, 9, 8, 9, 7]
   switching sequence[0] and sequence[8]
   --> [7, 8, 7, 8, 9, 9, 8, 9, 9]
   switching sequence[1] and sequence[2]
   --> [7, 7, 8, 8, 9, 9, 8, 9, 9]
   switching sequence[5] and sequence[7]
   --> [7, 7, 8, 8, 8, 9, 9, 9, 9] 
  ```
  So `4` is the minimum number of operations for the sequence to become sorted.
  
  # Input/Output
  
   - `[input]` integer array `sequence`
  
    The Sequence.
  
   - `[output]` an integer
  
    the minimum number of operations.

vc-preamble: |-
  def exchange_sort (sequence : List Int) : Nat :=
    sorry
  
  def isSorted (l : List Int) : Bool :=
    match l with
    | [] => true
    | [_] => true
    | x :: y :: rest => x ≤ y && isSorted (y :: rest)

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def count (x : Int) (l : List Int) : Nat :=
    match l with
    | [] => 0
    | h :: t => (if h = x then 1 else 0) + count x t

vc-theorems: |-
  theorem exchange_sort_nonnegative {sequence : List Int}
    (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :
    exchange_sort sequence ≥ 0 := sorry
  
  theorem exchange_sort_zero_when_sorted {sequence : List Int}
    (h₁ : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9)
    (h₂ : isSorted sequence = true) :
    exchange_sort sequence = 0 := sorry
  
  theorem exchange_sort_bounded_by_length {sequence : List Int}
    (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :
    exchange_sort sequence ≤ sequence.length := sorry
  
  theorem exchange_sort_preserves_frequency {sequence : List Int}
    (h : ∀ x ∈ sequence, x ≥ 7 ∧ x ≤ 9) :
    ∀ x, count x sequence = count x (List.mergeSort (· ≤ ·) sequence) := sorry
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval exchange_sort [7, 7, 8, 8, 9, 9]
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval exchange_sort [9, 7, 8, 8, 9, 7]
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval exchange_sort [8, 8, 7, 9, 9, 9, 8, 9, 7]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

