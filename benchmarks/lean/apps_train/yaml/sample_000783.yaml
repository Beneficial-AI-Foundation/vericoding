vc-description: |-
  In poker, you have 5 cards. There are 10 kinds of poker hands (from highest to lowest):
  
  -  royal flush - ace, king, queen, jack and ten, all in the same suit
  
  -  straight flush - five cards of the same suit in sequence, such
  as 10,9,8,7,6 of clubs; ace can be counted both as the highest card or as the
  lowest card - A,2,3,4,5 of hearts is a straight flush. But 4,3,2,A,K of hearts is not a straight flush - it's just a flush.
  
  -  four of a kind - four cards of the same rank, such as four kings.
  
  -  full house - three cards of one rank plus two cards of another rank
  
  -  flush - five cards of the same suit (but not a straight flush)
  
  -  straight - five cards in order - just like the straight flush, but mixed suits
  
  -  three of a kind - three cards of one rank and two other cards
  
  -  two pairs - two cards of one rank, two cards of another rank, and one more card
  
  -  pair - two cards of the same rank
  
  -  high card - none of the above
  
  Write a program that will help you play poker by telling you what kind of hand you have.
  
  -----Input-----
  
  The first line of input contains the number of test cases (no more than 20). Each test case consists of one line - five space separated cards. Each card is represented by a two-letter (or digit) word. The first character is the rank (A,K,Q,J,T,9,8,7,6,5,4,3 or 2), the second character is the suit (S,H,D,C standing for spades, hearts, diamonds and clubs). The cards can be in any order (but they will not repeat).
  
  -----Output-----
  
  For each test case output one line describing the type of a hand, exactly like in the list above.
  
  -----Example-----
  Input:
  3
  AH KH QH TH JH
  KH 5S 3C 5C 7D
  QH QD 2S QC 2C
  
  Output:
  royal flush
  pair
  full house

vc-preamble: |-
  def Rank.toNat : Rank → Nat 
    | Ace => 14
    | Two => 2
    | Three => 3
    | Four => 4
    | Five => 5
    | Six => 6
    | Seven => 7
    | Eight => 8
    | Nine => 9
    | Ten => 10
    | Jack => 11
    | Queen => 12
    | King => 13
  
  inductive HandResult where
    | RoyalFlush
    | StraightFlush
    | FourOfAKind
    | FullHouse
    | Flush
    | Straight
    | ThreeOfAKind
    | TwoPairs
    | Pair
    | HighCard
    deriving BEq, Repr
  
  structure Card where
    rank : Rank
    suit : Suit
    deriving BEq
  
  abbrev Hand := List Card

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def evaluate_poker_hand (h : Hand) : HandResult := 
    sorry

vc-theorems: |-
  theorem evaluate_poker_hand_returns_valid_result (h : Hand) 
    (h5 : h.length = 5) (hunique : h.Nodup) :
    ∃ (result : HandResult), evaluate_poker_hand h = result :=
  sorry
  
  theorem royal_flush_requires_specific_cards (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.RoyalFlush →
    (∃ (s : Suit), ∀ (c : Card), c ∈ h → c.suit = s) ∧
    h.map Card.rank = [Rank.Ace, Rank.King, Rank.Queen, Rank.Jack, Rank.Ten] :=
  sorry
  
  theorem straight_consecutive_ranks (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.Straight ∨ 
    evaluate_poker_hand h = HandResult.StraightFlush →
    let ranks := (h.map Card.rank).map Rank.toNat
    ∃ (min : Nat), ranks = [min, min+1, min+2, min+3, min+4] ∨ 
                   ranks = [14, 2, 3, 4, 5] :=
  sorry
  
  theorem flush_same_suit (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.Flush ∨ 
    evaluate_poker_hand h = HandResult.StraightFlush ∨
    evaluate_poker_hand h = HandResult.RoyalFlush →
    ∃ (s : Suit), ∀ (c : Card), c ∈ h → c.suit = s :=
  sorry
  
  theorem four_of_kind_has_four_same_rank (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.FourOfAKind →
    ∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 4 :=
  sorry
  
  theorem three_of_kind_has_three_same_rank (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.ThreeOfAKind →
    ∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 3 ∧
    ¬∃ r : Rank, (h.filter (fun c ↦ c.rank == r)).length = 2 :=
  sorry
  
  theorem two_pairs_has_two_pairs (h : Hand)
    (h5 : h.length = 5) (hunique : h.Nodup) :
    evaluate_poker_hand h = HandResult.TwoPairs →
    ∃ r1 r2 : Rank, r1 ≠ r2 ∧
    (h.filter (fun c ↦ c.rank == r1)).length = 2 ∧
    (h.filter (fun c ↦ c.rank == r2)).length = 2 :=
  sorry
  
  /--
  info: 'royal flush'
  -/
  #guard_msgs in
  #eval evaluate_poker_hand ["AH", "KH", "QH", "TH", "JH"]
  
  /--
  info: 'pair'
  -/
  #guard_msgs in
  #eval evaluate_poker_hand ["KH", "5S", "3C", "5C", "7D"]
  
  /--
  info: 'full house'
  -/
  #guard_msgs in
  #eval evaluate_poker_hand ["QH", "QD", "2S", "QC", "2C"]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

