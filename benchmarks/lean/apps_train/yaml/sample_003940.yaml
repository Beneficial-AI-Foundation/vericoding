vc-description: |-
  Consider the numbers `6969` and `9116`. When you rotate them `180 degrees` (upside down), these numbers remain the same. To clarify, if we write them down on a paper and turn the paper upside down, the numbers will be the same. Try it and see! Some numbers such as `2` or `5` don't yield numbers when rotated.
  
  Given a range, return the count of upside down numbers within that range.  For example, `solve(0,10) = 3`, because there are only `3` upside down numbers `>= 0 and < 10`. They are `0, 1, 8`.
  
  More examples in the test cases.
  
  Good luck!
  
  If you like this Kata, please try 
  
  [Simple Prime Streaming](https://www.codewars.com/kata/5a908da30025e995880000e3)
  
  [Life without primes](https://www.codewars.com/kata/59f8750ac374cba8f0000033)
  
  Please also try the performance version of this kata at [Upside down numbers - Challenge Edition ](https://www.codewars.com/kata/59f98052120be4abfa000304)

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def solve (x y : Nat) : Nat := sorry
  
  instance : ToString Nat where
    toString := sorry
  
  /-- For any valid range, the count is non-negative -/

vc-theorems: |-
  theorem solve_nonneg {x y : Nat} (h : x ≤ y) : 
    solve x y ≥ 0 := sorry 
  
  /-- The count is always less than or equal to the range size -/
  
  theorem solve_le_range {x y : Nat} (h : x ≤ y) :
    solve x y ≤ y - x := sorry
  
  /-- Empty range returns 0 -/
  
  theorem solve_empty_range (n : Nat) :
    solve n n = 0 := sorry
  
  /-- Splitting range property - count over split ranges sums to total -/
  
  theorem solve_split_range {x y z : Nat} 
    (h1 : x ≤ y) (h2 : y ≤ z) :
    solve x z = solve x y + solve y z := sorry
  
  /-- For valid rotation numbers, all digits must be from valid set -/
  
  theorem valid_rotation_digits (n : Nat) :
    solve n (n+1) = 1 → ∀ c, c ∈ (ToString.toString n).data → c ∈ ['0', '1', '8', '6', '9'] := sorry
  
  /-- For odd length valid rotation numbers, middle digit has restrictions -/ 
  
  theorem odd_len_middle_digit (n : Nat) (h1 : solve n (n+1) = 1)
    (h2 : (ToString.toString n).length % 2 = 1) :
    let mid := (ToString.toString n).length / 2
    let c := ((ToString.toString n).data.get! mid)
    c ≠ '6' ∧ c ≠ '9' := sorry
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval solve 0 10
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval solve 10 100
  
  /--
  info: 12
  -/
  #guard_msgs in
  #eval solve 100 1000

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

