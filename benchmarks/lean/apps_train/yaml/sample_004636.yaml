vc-description: |-
  This kata is part one of precise fractions series (see pt. 2: http://www.codewars.com/kata/precise-fractions-pt-2-conversion).
  
  When dealing with fractional values, there's always a problem with the precision of arithmetical operations. So lets fix it!
  
  Your task is to implement class ```Fraction``` that takes care of simple fraction arithmetics. Requirements:
  
  * class must have two-parameter constructor `Fraction(numerator, denominator)`; passed values will be non-zero integers, and may be positive or negative.
  * two conversion methods must be supported:
   * `toDecimal()` returns decimal representation of fraction
   * `toString()` returns string with fractional representation of stored value in format:
  
      [ SIGN ] [ WHOLES ] [ NUMERATOR / DENOMINATOR ]
     * **Note**: each part is returned only if it is available and non-zero, with the only possible space character going between WHOLES and fraction. Examples: '-1/2', '3', '-5 3/4'
  
  * The fractional part must always be normalized (ie. the numerator and denominators must not have any common divisors).
  * Four operations need to be implemented: `add`, `subtract`, `multiply` and `divide`. Each of them may take integers as well as another `Fraction` instance as an argument, and must return a new `Fraction` instance.
  * Instances must be immutable, hence none of the operations may modify either of the objects it is called upon, nor the passed argument.
  
   #### Python Notes
  * If one integer is passed into the initialiser, then the fraction should be assumed to represent an integer not a fraction.
  * You must implement the standard operator overrides `__add__`, `__sub__`, `__mul__`, `__div__`, in each case you should support `other` being an `int` or another instance of `Fraction`.
  * Implement `__str__` and `to_decimal` in place of `toString` and `toDecimal` as described above.

vc-preamble: |-
  def toString (n : Int) (d : Int) : String := sorry
  def toDecimal (n : Int) (d : Int) : Float := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def intToFloat (i : Int) : Float := sorry
  def stringToFloat (s : String) : Float := sorry

vc-theorems: |-
  theorem sign_property (n d : Int) (h : d ≠ 0) :
    let s := toString n d
    (n * d < 0 → s.startsWith "-") ∧ 
    (n * d > 0 → ¬s.startsWith "-") := sorry
  
  theorem format_property (n d : Int) (h : d ≠ 0) :
    let s := toString n d
    let parts := (s.dropWhile (·=='-')).splitOn " "
    match parts with
    | [p] => 
      if p.any (·=='/') then
        let nums := p.splitOn "/"
        nums.length = 2 ∧
        nums[0]!.all Char.isDigit ∧
        nums[1]!.all Char.isDigit
      else
        p.all Char.isDigit
    | [whole, frac] =>
      whole.all Char.isDigit ∧
      let fracParts := frac.splitOn "/"
      fracParts.length = 2 ∧
      fracParts[0]!.all Char.isDigit ∧
      fracParts[1]!.all Char.isDigit ∧
      fracParts[0]!.toNat! < fracParts[1]!.toNat!
    | _ => False := sorry
  
  theorem decimal_conversion (n d : Int) (h : d ≠ 0) :
    toDecimal n d = (intToFloat n / intToFloat d) := sorry
  
  theorem string_matches_value (n d : Int) (h : d ≠ 0) :
    let s := toString n d
    let val := 
      if s.any (·==' ') then
        let parts := (s.dropWhile (·=='-')).splitOn " "
        let whole := intToFloat parts[0]!.toInt!
        let fracParts := (parts[1]!.splitOn "/")
        let num := intToFloat fracParts[0]!.toInt!
        let den := intToFloat fracParts[1]!.toInt!
        whole + (num / den)
      else if s.any (·=='/') then
        let parts := (s.dropWhile (·=='-')).splitOn "/"
        (intToFloat parts[0]!.toInt!) / (intToFloat parts[1]!.toInt!)
      else
        stringToFloat s
    toDecimal n d = (if s.startsWith "-" then -val else val) := sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

