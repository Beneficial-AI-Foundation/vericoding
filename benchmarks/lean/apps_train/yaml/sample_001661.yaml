vc-description: |-
  /-
  Task
  
  Create a top-down movement system that would feel highly responsive to the player. In your Update method you have to check for the keys that are currently being pressed, the keys correspond to the enum Direction shown below, based on which key is pressed or released your method should behave this way:
  
  1) When a key is first pressed, the player has to change his direction to that of the current key, without moving
  
  2) If the key is still being pressed during the next Update, the player will move towards his current direction using these vectors: (Up = { 0, +1 } , Down = { 0, -1 }, Left = { -1, 0 }, Right = { +1, 0 })
  
  3) If a new key is pressed, it will gain precedence over the previous key and the player will act as per 1)
  
  4-A) If the current key (A) is released, then the precedence will go back to the previous key (B) (or the one before it, if (B) is not pressed anymore, and so on), then the player will behave as per 1).
  
  4-B) If the current key is released, and no other keys are being pressed, the player will stand still
  
  5) If all keys are released at once, the player will not move nor change direction
  
  6) If multiple keys are pressed at once, the order of precedence will be the following { Up, Down, Left, Right } 
  
  Examples
  
      (n = pressed key, [n] = current key, p() = press, r() = release, (8,2,4,6 = up, down, left, right)):
  
      [] , p(8) -> [8] , p(4,6) -> 86[4] , r(6) -> 8[4] , r(4) -> [8] , r(8) -> []
  
      [] , p(2486) -> 642[8] , r(2,8) -> 6[4] , r(4,6) -> []
  
  This is what you'll need to use in your code (NB: the tile coordinates cannot be changed, you'll need to assign a new Tile each time the player moves):
  
  ```python
  class Tile:
  
      @property
      def x(self):
          return self._x
  
      @property
      def y(self):
          return self._y
  
      def __str__(self):
          return "({},{})".format(self._x, self._y)
  
  class Input:
  
      @staticmethod
      def get_state(direction): # 2, 4, 6, 8
          return Input.STATES[direction] # pressed = true, released = false
  ```
  -/

vc-preamble: |-
  def PlayerMovement.PREC : List Nat := [2, 4, 6, 8]
  
  def PlayerMovement.new (x y : Int) : PlayerMovement := sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def PlayerMovement.update (pm : PlayerMovement) : PlayerMovement := sorry
  
  def Input.set_states (states : List (Nat × Bool)) : Unit := sorry

vc-theorems: |-
  theorem player_movement_initialization (x y : Int) :
    let pm := PlayerMovement.new x y
    pm.position.x = x ∧
    pm.position.y = y ∧
    pm.direction = 8 ∧
    pm.pressed = [false, false, false, false] ∧
    pm.stack = [] := sorry
  
  theorem movement_preserves_invariants (states : List (Nat × Bool)) :
    let pm := PlayerMovement.new 0 0
    let _ := Input.set_states states
    let pm' := pm.update
    List.length pm'.pressed = 4 ∧
    (∀ x ∈ pm'.pressed, x = true ∨ x = false) ∧
    (pm'.direction = 2 ∨ pm'.direction = 4 ∨ pm'.direction = 6 ∨ pm'.direction = 8) ∧
    (∀ x ∈ pm'.stack, x = 2 ∨ x = 4 ∨ x = 6 ∨ x = 8) ∧
    List.Nodup pm'.stack := sorry
  
  theorem precedence (pressed_keys : List (Nat × Bool)) 
    (h1 : ∀ k ∈ pressed_keys, k.1 ∈ PlayerMovement.PREC)
    (h2 : ∀ k ∈ pressed_keys, k.2 = true)
    (h3 : pressed_keys.length > 0) :
    let pm := PlayerMovement.new 0 0
    let _ := Input.set_states pressed_keys
    let pm' := pm.update
    pm'.direction ∈ PlayerMovement.PREC ∧
    ∀ k ∈ pressed_keys, 
      ∃ i j : Nat, 
        PlayerMovement.PREC.get? i = some pm'.direction ∧
        PlayerMovement.PREC.get? j = some k.1 ∧
        i ≤ j := sorry
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval len player.stack
  
  /-
  info: 4
  -/
  -- #guard_msgs in
  -- #eval len player.stack
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval len player.stack

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

