vc-description: |-
  /-
  Given an array of integers nums.
  A pair (i,j) is called good if nums[i] == nums[j] and i < j.
  Return the number of good pairs.
  
  Example 1:
  Input: nums = [1,2,3,1,1,3]
  Output: 4
  Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
  
  Example 2:
  Input: nums = [1,1,1,1]
  Output: 6
  Explanation: Each pair in the array are good.
  
  Example 3:
  Input: nums = [1,2,3]
  Output: 0
  
  Constraints:
  
  1 <= nums.length <= 100
  1 <= nums[i] <= 100
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def numIdenticalPairs (nums : List Int) : Nat := sorry
  
  theorem num_identical_pairs_non_negative (nums : List Int) :
    numIdenticalPairs nums ≥ 0 := sorry

vc-theorems: |-
  theorem empty_or_single_is_zero (nums : List Int) :
    nums.length ≤ 1 → numIdenticalPairs nums = 0 := sorry
  
  theorem all_same_values (nums : List Int) (n : Nat) (x : Int) :
    nums = List.replicate n x → n ≥ 2 →
    numIdenticalPairs nums = n * (n-1) / 2 := sorry
  
  /-
  info: 4
  -/
  -- #guard_msgs in
  -- #eval numIdenticalPairs [1, 2, 3, 1, 1, 3]
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval numIdenticalPairs [1, 1, 1, 1]
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval numIdenticalPairs [1, 2, 3]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

