vc-description: |-
  Given two words and a letter, return a single word that's a combination of both words, merged at the point where the given letter first appears in each word. The returned word should have the beginning of the first word and the ending of the second, with the dividing letter in the middle. You can assume both words will contain the dividing letter.
  
  ## Examples
  
  ```python
  string_merge("hello", "world", "l")      ==>  "held"
  string_merge("coding", "anywhere", "n")  ==>  "codinywhere"
  string_merge("jason", "samson", "s")     ==>  "jasamson"
  string_merge("wonderful", "people", "e") ==>  "wondeople"
  ```

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def string_merge (s1 s2 : String) (c : Char) : String := sorry
  
  def findIndex (s : String) (c : Char) : Option Nat := sorry
  
  structure StringMergeError where
    msg : String

vc-theorems: |-
  theorem string_merge_valid (s1 s2 : String) (c : Char)
    (h1 : s1.length > 0)
    (h2 : s2.length > 0) 
    (h3 : s1.contains c = true)
    (h4 : s2.contains c = true)
    (i1 : Nat) (i2 : Nat)
    (hi1 : findIndex s1 c = some i1)
    (hi2 : findIndex s2 c = some i2) :
    (string_merge s1 s2 c).take i1 = s1.take i1 ∧ 
    (string_merge s1 s2 c).drop i1 = s2.drop i2 ∧
    (string_merge s1 s2 c).length = i1 + s2.length - i2 := sorry
  
  theorem string_merge_invalid (s1 s2 : String) (c : Char)
    (h1 : s1.length > 0)
    (h2 : s2.length > 0)
    (h3 : ¬s1.contains c ∨ ¬s2.contains c) :
    ∃ (err : StringMergeError), string_merge s1 s2 c = err.msg := sorry
  
  /--
  info: 'held'
  -/
  #guard_msgs in
  #eval string_merge "hello" "world" "l"
  
  /--
  info: 'codinywhere'
  -/
  #guard_msgs in
  #eval string_merge "coding" "anywhere" "n"
  
  /--
  info: 'wondeople'
  -/
  #guard_msgs in
  #eval string_merge "wonderful" "people" "e"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

