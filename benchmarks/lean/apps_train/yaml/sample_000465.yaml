vc-description: |-
  Given the array nums consisting of n positive integers. You computed the sum of all non-empty continous subarrays from the array and then sort them in non-decreasing order, creating a new array of n * (n + 1) / 2 numbers.
  Return the sum of the numbers from index left to index right (indexed from 1), inclusive, in the new array. Since the answer can be a huge number return it modulo 10^9 + 7.
  
  Example 1:
  Input: nums = [1,2,3,4], n = 4, left = 1, right = 5
  Output: 13 
  Explanation: All subarray sums are 1, 3, 6, 10, 2, 5, 9, 3, 7, 4. After sorting them in non-decreasing order we have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. 
  
  Example 2:
  Input: nums = [1,2,3,4], n = 4, left = 3, right = 4
  Output: 6
  Explanation: The given array is the same as example 1. We have the new array [1, 2, 3, 3, 4, 5, 6, 7, 9, 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.
  
  Example 3:
  Input: nums = [1,2,3,4], n = 4, left = 1, right = 10
  Output: 50
  
  Constraints:
  
  1 <= nums.length <= 10^3
  nums.length == n
  1 <= nums[i] <= 100
  1 <= left <= right <= n * (n + 1) / 2

vc-preamble: |-
  def range_sum (nums : List Nat) (n : Nat) (left right : Nat) : Nat :=
    sorry
  
  def partialSums (nums : List Nat) (n : Nat) : List Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def listMin (l : List Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem range_sum_output_properties {nums : List Nat} {n left right : Nat}
    (h1 : nums.length = n)
    (h2 : !nums.isEmpty)
    (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 1000)
    (h4 : left ≥ 1 ∧ right ≥ 1)
    (h5 : left ≤ 20 ∧ right ≤ 20) :
    let result := range_sum nums n left right
    result ≥ 0 ∧ result < 10^9 + 7 :=
  sorry
  
  theorem range_sum_monotonic {nums : List Nat} {n left right : Nat}
    (h1 : nums.length = n)
    (h2 : !nums.isEmpty) 
    (h3 : left < right)
    (h4 : right ≤ n) :
    range_sum nums n left (right-1) ≤ range_sum nums n left right :=
  sorry
  
  theorem range_sum_single_element {nums : List Nat} {n k : Nat}
    (h1 : nums.length = n)
    (h2 : !nums.isEmpty)
    (h3 : k ≤ n)
    (h4 : k > 0) :
    let pSums := partialSums nums n
    ∀ h : k - 1 < pSums.length,
    range_sum nums n k k = pSums.get ⟨k-1, h⟩ :=
  sorry
  
  theorem range_sum_full_range {nums : List Nat} {n : Nat}
    (h1 : nums.length = n)
    (h2 : !nums.isEmpty)
    (h3 : ∀ x ∈ nums, x ≥ 1 ∧ x ≤ 100) :
    range_sum nums n 1 (n * (n+1) / 2) > 0 :=
  sorry
  
  theorem range_sum_first_element {nums : List Nat} {n : Nat}
    (h1 : nums.length = n)
    (h2 : !nums.isEmpty) :
    range_sum nums n 1 1 = listMin nums :=
  sorry
  
  /--
  info: 13
  -/
  #guard_msgs in
  #eval range_sum [1, 2, 3, 4] 4 1 5
  
  /--
  info: 6
  -/
  #guard_msgs in
  #eval range_sum [1, 2, 3, 4] 4 3 4
  
  /--
  info: 50
  -/
  #guard_msgs in
  #eval range_sum [1, 2, 3, 4] 4 1 10

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

