vc-description: |-
  There is crazy man named P29892P. He always tries to do crazy things as he thinks. One day he invented a machine and named it as ANGEN. The ANGEN is used to perform range operations. The range operation means performing operations on range values from {L..R}. At any time it performs operations on values in between L to R.
  ANGEN can perform following operations
  U I V - Update the value present at I  with value V
  A L R - Find the sum between range L and R
  M L R - Find the maximum number between L and R
  m L R - Find the minimum number between L and R
  S L R - Find second maximum value in between L and R
  s L R - Find second mimimum value in between L and R
  If it is not possible perform operation ANGEN returns “NA” with out quotes.
  For Invalid operations ANGEN returns “!!!” with out quotes.
  Now P29892P challenging his friends and you too, to build his invention with yourown code. So it's your time to defeat P29892P by implementing his invention with your own ability. Let's go and solve the problem.
  
  -----Input-----
  Input description.
  - The first line of the input contains an integer N denoting the number of integers. 
  - The next line contains N space separated integers."
  - The next line contains a single integer Q denoting the number of Questions.
  -  The next Q lines contains T Question type , L and R.
  
  -----Output-----
  Print output for each question in separate line.
  
  -----Constraints-----
  Should contain all the constraints on the input data that you may have. Format it like:
  - 1 ≤ N ≤ 100000
  - 1 ≤ values[i] ≤ 1000000000
  - 1 ≤ Q ≤ 10000
  - T in { A..Z, a..z }
  - 1 ≤ L ≤ R ≤ N
  
  -----Example-----
  Input:
  6
  1 2 5 3 10 6
  6
  A 1 5
  M 1 3
  m 5 6
  s 3 6
  U 1 7
  S 1 2
  
  Output:
  21
  5
  6
  5
  2
  
  -----Explanation-----
  ...

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def process_angen_operations (nums: List Int) (operations: List (Char × String × String)) : List String :=
    sorry

vc-theorems: |-
  theorem process_operations_basic_props 
    (nums: List Int) 
    (operations: List (Char × String × String))
    (h1: nums.length ≥ 1)
    (h2: ∀ op ∈ operations, 
      (toString op.1 = "U" ∨ toString op.1 = "A" ∨ toString op.1 = "M" ∨ 
       toString op.1 = "m" ∨ toString op.1 = "S" ∨ toString op.1 = "s") ∧
      ((String.toNat! op.2.1) ≤ nums.length) ∧  
      ((String.toNat! op.2.2) ≤ nums.length) ∧
      ((String.toNat! op.2.1) ≤ (String.toNat! op.2.2))) :
    let results := process_angen_operations nums operations
    ∀ r ∈ results, r.length > 0 :=
  sorry
  
  theorem process_operations_arithmetic 
    (nums: List Int)
    (operations: List (Char × String × String))
    (h1: nums.length ≥ 1)
    (op: Char × String × String)
    (h2: op ∈ operations)
    (h3: op.1 = 'A' ∨ op.1 = 'M' ∨ op.1 = 'm') :
    let l := (String.toNat! op.2.1) - 1
    let r := String.toNat! op.2.2
    let subarray := nums.take r |>.drop l
    let result := (process_angen_operations nums operations)[operations.indexOf op]!
    match op.1 with
    | 'A' => result = toString (subarray.foldl (· + ·) 0)
    | 'M' => result = toString (List.maximum? subarray |>.get!)
    | 'm' => result = toString (List.minimum? subarray |>.get!)
    | _ => True :=
  sorry
  
  theorem process_invalid_operations
    (nums: List Int)
    (operations: List (Char × String × String))
    (h1: nums.length ≥ 1)
    (h2: ∀ op ∈ operations, 
      op.1 ≠ 'U' ∧ op.1 ≠ 'A' ∧ op.1 ≠ 'M' ∧ 
      op.1 ≠ 'm' ∧ op.1 ≠ 'S' ∧ op.1 ≠ 's') :
    let results := process_angen_operations nums operations
    ∀ r ∈ results, r = "!!!" :=
  sorry
  
  theorem process_second_extremes
    (nums: List Int)
    (operations: List (Char × String × String))
    (h1: nums.length ≥ 1) 
    (op: Char × String × String)
    (h2: op ∈ operations)
    (h3: op.1 = 'S' ∨ op.1 = 's')
    (h4: (String.toNat! op.2.1) ≤ nums.length)
    (h5: (String.toNat! op.2.2) ≤ nums.length)
    (h6: (String.toNat! op.2.1) ≤ (String.toNat! op.2.2)) :
    let l := (String.toNat! op.2.1) - 1
    let r := String.toNat! op.2.2
    let subarray := nums.take r |>.drop l
    let result := (process_angen_operations nums operations)[operations.indexOf op]!
    (List.length subarray < 2 → result = "NA") ∧
    (List.length subarray ≥ 2 →
      match op.1 with
      | 's' => result.toInt? |>.map (λ x => x ≥ (List.minimum? subarray |>.get!)) |>.getD false
      | 'S' => result.toInt? |>.map (λ x => x ≤ (List.maximum? subarray |>.get!)) |>.getD false
      | _ => True) :=
  sorry
  
  /--
  info: expected
  -/
  #guard_msgs in
  #eval process_angen_operations [1, 2, 5, 3, 10, 6] [("A", "1", "5"), ("M", "1", "3"), ("m", "5", "6"), ("s", "3", "6"), ("U", "1", "7"), ("S", "1", "2")]
  
  /--
  info: ['!!!']
  -/
  #guard_msgs in
  #eval process_angen_operations [1, 2, 3] [("X", "1", "2")]
  
  /--
  info: ['NA']
  -/
  #guard_msgs in
  #eval process_angen_operations [1, 1, 1] [("s", "1", "3")]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

