vc-description: |-
  # Idea
  
  In the world of graphs exists a structure called "spanning tree". It is unique because it's created not on its own, but based on other graphs. To make a spanning tree out of a given graph you should remove all the edges which create cycles, for example:
  ```
  This can become      this      or      this        or       this
  
   A                    A                  A                   A
   |\                   |                   \                  |\
   | \       ==>        |                    \                 | \
   |__\                 |__                 __\                |  \
  B   C                 B  C               B  C                B  C
  ```
  Each *edge* (line between 2 *vertices*, i.e. points) has a weight, based on which you can build minimum and maximum spanning trees (sum of weights of vertices in the resulting tree is minimal/maximal possible).  
  [Wikipedia article](https://en.wikipedia.org/wiki/Spanning_tree) on spanning trees, in case you need it.
  
  ___
  
  # Task
  
  You will receive an array like this: `[["AB", 2], ["BC", 4], ["AC", 1]]` which includes all edges of an arbitrary graph and a string `"min"`/`"max"`. Based on them you should get and return a new array which includes only those edges which form a minimum/maximum spanning trees.
  ```python
  edges = [("AB", 2), ("BC", 4), ("AC", 1)]
  
  make_spanning_tree(edges, "min")    ==>    [("AB", 2), ("AC", 1)]
  make_spanning_tree(edges, "max")    ==>    [("AB", 2), ("BC", 4)]
  ```
  
  ___
  
  # Notes
  
  * All vertices will be connected with each other
  * You may receive cycles, for example - `["AA", n]`
  * The subject of the test are these 3 values: number of vertices included, total weight, number of edges, but **you should not return them**, there's a special function which will analyze your output instead

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def make_spanning_tree (edges : List Edge) (tree_type : String) : List Edge :=
    sorry

vc-theorems: |-
  theorem spanning_tree_subset {edges : List Edge} {tree_type : String} :
    let result := make_spanning_tree edges tree_type
    ∀ e ∈ result, e ∈ edges := by
    sorry
  
  theorem spanning_tree_no_duplicates {edges : List Edge} {tree_type : String} :
    let result := make_spanning_tree edges tree_type
    let result_edges := result.map (·.vertices)
    result_edges.length = result_edges.eraseDups.length := by
    sorry
  
  theorem spanning_tree_no_self_loops {edges : List Edge} {tree_type : String} :
    let result := make_spanning_tree edges tree_type
    ∀ e ∈ result, e.vertices.1 ≠ e.vertices.2 := by
    sorry
  
  theorem spanning_tree_min_property {edges : List Edge} 
    (h : make_spanning_tree edges "min" ≠ []) :
    let result := make_spanning_tree edges "min"
    let result_weights := result.map (·.weight)
    let valid_edges := edges.filter (λ e => e.vertices.1 ≠ e.vertices.2)
    let edge_weights := valid_edges.map (·.weight)
    (result_weights.minimum?.get! : Nat) ≥ edge_weights.minimum?.get! := by
    sorry
  
  theorem spanning_tree_max_property {edges : List Edge}
    (h : make_spanning_tree edges "max" ≠ []) :
    let result := make_spanning_tree edges "max"
    let result_weights := result.map (·.weight)
    let valid_edges := edges.filter (λ e => e.vertices.1 ≠ e.vertices.2)
    let edge_weights := valid_edges.map (·.weight)
    (result_weights.maximum?.get! : Nat) ≤ edge_weights.maximum?.get! := by
    sorry
  
  /--
  info: [('AC', 1), ('AB', 2)]
  -/
  #guard_msgs in
  #eval make_spanning_tree [("AB", 2), ("BC", 4), ("AC", 1)] "min"
  
  /--
  info: [('BC', 4), ('AB', 2)]
  -/
  #guard_msgs in
  #eval make_spanning_tree [("AB", 2), ("BC", 4), ("AC", 1)] "max"
  
  /--
  info: [('AB', 2), ('BC', 3)]
  -/
  #guard_msgs in
  #eval make_spanning_tree [("AA", 1), ("AB", 2), ("BC", 3)] "min"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

