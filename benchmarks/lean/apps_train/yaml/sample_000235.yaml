vc-description: |-
  /-
  We have a set of items: the i-th item has value values[i] and label labels[i].
  Then, we choose a subset S of these items, such that:
  
  |S| <= num_wanted
  For every label L, the number of items in S with label L is <= use_limit.
  
  Return the largest possible sum of the subset S.
  
  Example 1:
  Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1
  Output: 9
  Explanation: The subset chosen is the first, third, and fifth item.
  
  Example 2:
  Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2
  Output: 12
  Explanation: The subset chosen is the first, second, and third item.
  
  Example 3:
  Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1
  Output: 16
  Explanation: The subset chosen is the first and fourth item.
  
  Example 4:
  Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2
  Output: 24
  Explanation: The subset chosen is the first, second, and fourth item.
  
  Note:
  
  1 <= values.length == labels.length <= 20000
  0 <= values[i], labels[i] <= 20000
  1 <= num_wanted, use_limit <= values.length
  -/

vc-preamble: |-
  def largest_vals_from_labels (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat) : Int :=
    sorry
  
  def List.sum : List Int → Int 
    | [] => 0
    | x::xs => x + List.sum xs
  
  def myMax (a b : Int) : Int :=
    if a ≥ b then a else b

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def List.maximum : List Int → Int
    | [] => 0
    | [x] => x
    | x::xs => myMax x (List.maximum xs)

vc-theorems: |-
  theorem largest_vals_sum_bound (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)
    (h1: values.length = labels.length)
    (h2: numWanted > 0)
    (h3: useLimit > 0) :
    largest_vals_from_labels values labels numWanted useLimit ≤ 
      (List.sum (values.filter (λ x => x > 0))) :=
    sorry
  
  theorem largest_vals_nonneg (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)
    (h1: values.length = labels.length)
    (h2: numWanted > 0)
    (h3: useLimit > 0)
    (h4: ∀ x ∈ values, x ≥ 0) :
    largest_vals_from_labels values labels numWanted useLimit ≥ 0 :=
    sorry
  
  theorem largest_vals_use_limit (values: List Int) (labels: List Int) (numWanted: Nat) (useLimit: Nat)
    (h1: values.length = labels.length)
    (h2: numWanted > 0)
    (h3: useLimit > 0)
    (label: Int) : 
    let filtered := (values.zip labels).filter (λ p => p.1 = label)
    filtered.length ≤ useLimit :=
    sorry
  
  theorem largest_vals_single_label (values: List Int) (h: values.length > 0) :
    largest_vals_from_labels values (List.replicate values.length 0) 1 1 = List.maximum values :=
    sorry
  
  /-
  info: 9
  -/
  -- #guard_msgs in
  -- #eval largest_vals_from_labels [5, 4, 3, 2, 1] [1, 1, 2, 2, 3] 3 1
  
  /-
  info: 12
  -/
  -- #guard_msgs in
  -- #eval largest_vals_from_labels [5, 4, 3, 2, 1] [1, 3, 3, 3, 2] 3 2
  
  /-
  info: 16
  -/
  -- #guard_msgs in
  -- #eval largest_vals_from_labels [9, 8, 8, 7, 6] [0, 0, 0, 1, 1] 3 1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

