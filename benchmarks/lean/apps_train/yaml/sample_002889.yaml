vc-description: |-
  /-
  *This kata is inspired by [Project Euler Problem #387](https://projecteuler.net/problem=387)*
  
  ---
  
  A [Harshad number](https://en.wikipedia.org/wiki/Harshad_number) (or Niven number) is a number that is divisible by the sum of its digits. A *right truncatable Harshad number* is any Harshad number that, when recursively right-truncated, results in a Harshad number at each truncation. By definition, 1-digit numbers are **not** right truncatable Harshad numbers.
  
  For example `201` (which is a Harshad number) yields `20`, then `2` when right-truncated, which are all Harshad numbers. Thus `201` is a *right truncatable Harshad number*.
  
  ## Your task
  
  Given a range of numbers (`(a, b)`, both included), return the list of right truncatable Harshad numbers in this range.
  
  ```if-not:javascript
  Note: there are `500` random tests, with 0 <= `a` <= `b` <= 10^(16)
  ```
  ```if:javascript
  Note: there are `500` random tests, with `0 <= a <= b <= Number.MAX_SAFE_INTEGER`
  ```
  
  ## Examples
  
  ```
  0, 20        -->  [10, 12, 18, 20]
  30, 100      -->  [30, 36, 40, 42, 45, 48, 50, 54, 60, 63, 70, 72, 80, 81, 84, 90, 100]
  90, 200      -->  [90, 100, 102, 108, 120, 126, 180, 200]
  200, 210     -->  [200, 201, 204, 207, 209, 210]
  1000, 2000   -->  [1000, 1002, 1008, 1020, 1026, 1080, 1088, 1200, 1204, 1206, 1260, 1800, 2000]
  2200, 2300   -->  []
  9000002182976, 9000195371842  -->  [9000004000000, 9000004000008]
  ```
  
  ---
  
  ## My other katas
  
  If you enjoyed this kata then please try [my other katas](https://www.codewars.com/collections/katas-created-by-anter69)! :-)
  
  #### *Translations are welcome!*
  -/

vc-preamble: |-
  def sumOfDigits (n : Nat) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def rthn_between (a b : Int) : List Int :=
    sorry

vc-theorems: |-
  theorem rthn_between_ordered_bounds {a b : Int} (h : a ≤ b) (h₁ : 0 ≤ a) (h₂ : b ≤ 10000) :
    let result := rthn_between a b
    -- Result is sorted
    (∀ i j, i < j → i < List.length result → j < List.length result → 
      result[i]! ≤ result[j]!) ∧
    -- All numbers within bounds
    (∀ x ∈ result, a ≤ x ∧ x ≤ b) ∧
    -- Each number divisible by sum of its digits
    (∀ x ∈ result, x % sumOfDigits (Int.toNat x) = 0) :=
    sorry
  
  theorem rthn_between_same_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :
    let result := rthn_between n n
    (result ≠ [] → 
      List.length result = 1 ∧
      result[0]! = n ∧ 
      n % sumOfDigits (Int.toNat n) = 0) :=
    sorry
  
  theorem rthn_between_inverted_bounds {n : Int} (h : 0 ≤ n) (h₁ : n ≤ 10000) :
    rthn_between n (n-1) = [] :=
    sorry
  
  theorem rthn_between_edge_cases :
    (rthn_between 0 0 = []) ∧
    (rthn_between (-1) 10 = [10]) :=
    sorry
  
  /-
  info: [10, 12, 18, 20]
  -/
  -- #guard_msgs in
  -- #eval rthn_between 0 20
  
  /-
  info: [200, 201, 204, 207, 209, 210]
  -/
  -- #guard_msgs in
  -- #eval rthn_between 200 210
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval rthn_between 2200 2300

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

