vc-description: |-
  You are given an unweighted, undirected graph. Write a program to check if it's a tree topology.
  
  -----Input-----
  
  The first line of the input file contains two integers N and M --- number of nodes and number of edges in the graph (0 < N <= 10000, 0 <= M <= 20000). Next M lines contain M edges of that graph --- Each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u,v <= N).
  
  -----Output-----
  
  Print YES if the given graph is a tree, otherwise print NO.
  
  -----Example-----
  Input:
  3 2
  1 2
  2 3
  
  Output:
  YES

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def is_tree (n : Nat) (edges : List (Nat × Nat)) : String := sorry
  
  def is_valid_tree_properties (n : Nat) (edges : List (Nat × Nat)) : Bool := sorry

vc-theorems: |-
  theorem single_node_valid (n : Nat) (h : n = 1) :
    is_tree n [] = "YES" := sorry 
  
  theorem tree_properties (n : Nat) (edges : List (Nat × Nat)) :
    is_tree n edges = "YES" → is_valid_tree_properties n edges = true := sorry
  
  theorem line_graph_valid (n : Nat) (h : n ≥ 2) :
    let edges := List.range (n-1) |>.map (fun i => (i+1, i+2))
    is_tree n edges = "YES" := sorry
  
  theorem cycle_invalid (n : Nat) (h : n ≥ 3) :
    let edges := (List.range (n-1) |>.map (fun i => (i+1, i+2))) ++ [(n, 1)]
    is_tree n edges = "NO" := sorry
  
  theorem disconnected_invalid (n : Nat) (h : n ≥ 3) :
    let edges := [(1,2)] ++ 
      (if n > 3 then 
        List.range (n-3) |>.map (fun i => (i+3, i+4))
      else [])
    is_tree n edges = "NO" := sorry
  
  /--
  info: 'YES'
  -/
  #guard_msgs in
  #eval is_tree 3 [(1, 2), (2, 3)]
  
  /--
  info: 'NO'
  -/
  #guard_msgs in
  #eval is_tree 3 [(1, 2), (2, 3), (1, 3)]
  
  /--
  info: 'NO'
  -/
  #guard_msgs in
  #eval is_tree 4 [(1, 2), (3, 4)]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

