vc-description: |-
  Devu loves to play with his dear mouse Jerry.  One day they play a game on 2 dimensional grid of dimensions n * n (n ≥ 2). Jerry is currently at coordinates (sx, sy) and wants to move to location (ex, ey) where cheese is placed by Devu. Also Devu is very cunning and has placed a bomb at location (bx, by). All these three locations are distinct. 
  
  In a single move, Jerry can go either up, down, left or right in the grid such that it never goes out of the grid. Also, it has to avoid the bomb. Find out minimum number of moves Jerry needs. It is guaranteed that it is always possible to do so.
  
  -----Input-----
  - The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows."
  - The first line of each test case contains seven space separated integers n, sx, sy , ex, ey, bx, by. 
  
  -----Output-----
  - For each test case, output a single line containing an integer corresponding to minimum number of moves Jerry needs.
  
  -----Constraints-----
  - 1 ≤ T ≤ 1000
  - 2 ≤ n ≤ 20
  -  1 ≤ sx, sy , ex, ey, bx, by ≤ n 
  - No two or more poitns in the three points are same.
  
  -----Example-----
  Input:
  2
  2 1 1 2 2 1 2
  3 1 1 1 3 1 2
  
  Output:
  2
  4
  
  -----Explanation-----
  Example case 1. ...
  Jerry will move directly (1, 1) to (2, 1) and then to (2, 2) in total 2 moves.
  
  Example case 2. ...

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def abs (x : Int) : Int := if x < 0 then -x else x
  
  def min_moves_to_cheese (n : Int) (sx sy ex ey blockx blocky : Int) : Int := sorry

vc-theorems: |-
  theorem min_moves_manhattan_lower_bound 
    (n : Int) (sx sy ex ey blockx blocky : Int)
    (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4 : ex ≥ 1) (h5 : ey ≥ 1) 
    (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)
    (h8 : sx ≤ 100) (h9 : sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)
    (h12 : blockx ≤ 100) (h13 : blocky ≤ 100) :
    min_moves_to_cheese n sx sy ex ey blockx blocky ≥ (abs (sx - ex) + abs (sy - ey)) := sorry
  
  theorem min_moves_manhattan_upper_bound
    (n : Int) (sx sy ex ey blockx blocky : Int)
    (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4 : ex ≥ 1) (h5 : ey ≥ 1)
    (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)
    (h8 : sx ≤ 100) (h9 : sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)
    (h12 : blockx ≤ 100) (h13 : blocky ≤ 100) :
    min_moves_to_cheese n sx sy ex ey blockx blocky ≤ (abs (sx - ex) + abs (sy - ey) + 2) := sorry
  
  theorem max_detour_implies_blocked_path
    (n : Int) (sx sy ex ey blockx blocky : Int)
    (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4 : ex ≥ 1) (h5 : ey ≥ 1)
    (h6 : blockx ≥ 1) (h7 : blocky ≥ 1)
    (h8 : sx ≤ 100) (h9 : sy ≤ 100) (h10 : ex ≤ 100) (h11 : ey ≤ 100)
    (h12 : blockx ≤ 100) (h13 : blocky ≤ 100)
    (h14 : min_moves_to_cheese n sx sy ex ey blockx blocky = abs (sx - ex) + abs (sy - ey) + 2) :
    ((sx = ex ∧ ex = blockx ∧ min sy ey < blocky ∧ blocky < max sy ey) ∨
     (sy = ey ∧ ey = blocky ∧ min sx ex < blockx ∧ blockx < max sx ex)) := sorry
  
  theorem diagonal_manhattan_distance
    (n : Int) (sx sy ex ey : Int)
    (h1 : n ≥ 2) (h2 : sx ≥ 1) (h3 : sy ≥ 1) (h4 : ex ≥ 1) (h5 : ey ≥ 1)
    (h6 : sx ≤ 100) (h7 : sy ≤ 100) (h8 : ex ≤ 100) (h9 : ey ≤ 100)
    (h10 : sx ≠ ex) (h11 : sy ≠ ey) :
    min_moves_to_cheese n sx sy ex ey 1 1 = abs (sx - ex) + abs (sy - ey) := sorry
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval min_moves_to_cheese 2 1 1 2 2 1 2
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval min_moves_to_cheese 3 1 1 1 3 1 2
  
  /--
  info: 5
  -/
  #guard_msgs in
  #eval min_moves_to_cheese 4 1 1 4 1 2 1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

