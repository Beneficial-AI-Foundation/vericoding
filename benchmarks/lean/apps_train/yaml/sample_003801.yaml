vc-description: |-
  # Task
  Given an array `arr`, find the maximal value of `k` such `a[i] mod k` = `a[j] mod k` for all valid values of i and j.
  
  If it's impossible to find such number (there's an infinite number of `k`s), return `-1` instead.
  
  # Input/Output
  
  `[input]` integer array `arr`
  
  A non-empty array of positive integer.
  
  `2 <= arr.length <= 10`
  
  `1 <= arr[i] <= 100`
  
  `[output]` an integer
  
  The maximum value of `k` or `-1` if there is none.
  
  # Example
  
  For `arr = [1, 2, 3]`, the output should be `1`.
  
  `1` is the only k which satisfies the given conditions.
  
  For `arr = [1, 1, 1]`, the output should be `-1`.
  
  `1 % k = 1` for `any k > 1`, so it's impossible to find the maximum.
  
  For `arr = [5, 2, 8]`, the output should be `3`.
  
  `5 % 3 == 2 % 3 == 8 % 3 == 2`

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def finding_k (arr : List Nat) : Int := sorry
  
  def list_max : List Nat → Nat 
    | [] => 0
    | (x::xs) => max x (list_max xs)

vc-theorems: |-
  theorem finding_k_valid_k_or_minus_one (arr : List Nat) (h : arr ≠ []) : 
    let k := finding_k arr
    if k ≠ -1 then 
      (k > 0) ∧ 
      (k < list_max arr) ∧
      (∀ x, x ∈ arr → ∃ r, x % k = r)
    else
      ∀ k', k' ∈ List.range (list_max arr) → 
      ∃ x y, x ∈ arr ∧ y ∈ arr ∧ x % k' ≠ y % k'
    := sorry
  
  theorem all_same_numbers_return_minus_one (arr : List Nat) (h : arr ≠ []) :
    (∀ x y, x ∈ arr → y ∈ arr → x = y) → finding_k arr = -1 := sorry
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval finding_k [5, 2, 8]
  
  /--
  info: -1
  -/
  #guard_msgs in
  #eval finding_k [1, 1, 1]
  
  /--
  info: 90
  -/
  #guard_msgs in
  #eval finding_k [10, 100]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

