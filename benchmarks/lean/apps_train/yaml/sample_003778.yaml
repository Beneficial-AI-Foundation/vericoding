vc-description: |-
  If you have completed the Tribonacci sequence kata, you would know by now that mister Fibonacci has at least a bigger brother. If not, give it a quick look to get how things work.
  
  Well, time to expand the family a little more: think of a Quadribonacci starting with a signature of 4 elements and each following element is the sum of the 4 previous, a Pentabonacci (well *Cinquebonacci* would probably sound a bit more italian, but it would also sound really awful) with a signature of 5 elements and each following element is the sum of the 5 previous, and so on.
  
  Well, guess what? You have to build a Xbonacci function that takes a **signature** of X elements *- and remember each next element is the sum of the last X elements -* and returns the first **n** elements of the so seeded sequence.
  
  ```
  xbonacci {1,1,1,1} 10 = {1,1,1,1,4,7,13,25,49,94}
  xbonacci {0,0,0,0,1} 10 = {0,0,0,0,1,1,2,4,8,16}
  xbonacci {1,0,0,0,0,0,1} 10 = {1,0,0,0,0,0,1,2,3,6}
  xbonacci {1,1} produces the Fibonacci sequence
  ```

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def xbonacci (signature : List Int) (n : Nat) : List Int :=
    sorry

vc-theorems: |-
  theorem xbonacci_length (signature : List Int) (n : Nat) :
    (xbonacci signature n).length = n :=
    sorry
  
  theorem xbonacci_prefix (signature : List Int) (n : Nat) :
    let x := signature.length
    let prefix_len := min n x
    (xbonacci signature n).take prefix_len = signature.take n :=
    sorry
  
  theorem xbonacci_sum_rule (signature : List Int) (n : Nat) (i : Nat) 
      (h1 : n > signature.length) (h2 : i ≥ signature.length) (h3 : i < n) :
    ((xbonacci signature n).get ⟨i, by {
      rw [xbonacci_length]
      exact h3
    }⟩) = 
    (((xbonacci signature n).drop (i-signature.length)).take signature.length).foldl (· + ·) 0 :=
    sorry
  
  theorem xbonacci_zero_length (signature : List Int) :
    xbonacci signature 0 = [] :=
    sorry
  
  theorem xbonacci_nonnegative (signature : List Int) (n : Nat) :
    signature.all (· ≥ 0) →
    (xbonacci signature n).all (· ≥ 0) :=
    sorry
  
  /--
  info: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
  -/
  #guard_msgs in
  #eval xbonacci [0, 1] 10
  
  /--
  info: [0, 0, 0, 0, 1, 1, 2, 4, 8, 16]
  -/
  #guard_msgs in
  #eval xbonacci [0, 0, 0, 0, 1] 10
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval xbonacci [1, 2, 3] 0

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

