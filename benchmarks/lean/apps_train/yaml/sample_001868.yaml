vc-description: |-
  We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.
  Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:
  
  If A is empty, return null.
  Otherwise, let A[i] be the largest element of A.  Create a root node with value A[i].
  The left child of root will be Construct([A[0], A[1], ..., A[i-1]])
  The right child of root will be Construct([A[i+1], A[i+2], ..., A[A.length - 1]])
  Return root.
  
  Note that we were not given A directly, only a root node root = Construct(A).
  Suppose B is a copy of A with the value val appended to it.  It is guaranteed that B has unique values.
  Return Construct(B).
  
  Example 1:
  
  Input: root = [4,1,3,null,null,2], val = 5
  Output: [5,4,null,1,3,null,null,2]
  Explanation: A = [1,4,2,3], B = [1,4,2,3,5]
  
  Example 2:
  
  Input: root = [5,2,4,null,1], val = 3
  Output: [5,2,4,null,1,null,3]
  Explanation: A = [2,1,5,4], B = [2,1,5,4,3]
  
  Example 3:
  
  Input: root = [5,2,3,null,1], val = 4
  Output: [5,2,4,null,1,3]
  Explanation: A = [2,1,5,3], B = [2,1,5,3,4]
  
  Constraints:
  
  1 <= B.length <= 100

vc-preamble: |-
  def insertIntoMaxTree (root: Option TreeNode) (val: Int) : TreeNode :=
    sorry
  
  def buildTree (vals: List Int) : Option TreeNode :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def treeToList (t: TreeNode) : List Int :=
    sorry
  
  partial def isMaxTree : TreeNode → Bool 
  | TreeNode.node v l r => 
    match l, r with
    | none, none => true 
    | some (TreeNode.node lv ll lr), none => v ≥ lv && isMaxTree (TreeNode.node lv ll lr)
    | none, some (TreeNode.node rv rl rr) => v ≥ rv && isMaxTree (TreeNode.node rv rl rr)
    | some (TreeNode.node lv ll lr), some (TreeNode.node rv rl rr) => 
        v ≥ lv && v ≥ rv && 
        isMaxTree (TreeNode.node lv ll lr) && 
        isMaxTree (TreeNode.node rv rl rr)

vc-theorems: |-
  theorem insert_single_node (val: Int) (h: val > 0) : 
    match insertIntoMaxTree none val with
    | TreeNode.node v l r => v = val ∧ l = none ∧ r = none :=
  sorry
  
  theorem insert_maintains_values (vals: List Int) (new_val: Int)
    (h1: ∀ x, x ∈ vals → x > 0)
    (h2: new_val > 0) 
    (h3: vals ≠ [])
    (h4: ∀ x y, x ∈ vals → y ∈ vals → x ≠ y) :
    let root := buildTree vals
    let result := insertIntoMaxTree root new_val
    let result_list := treeToList result
    (∀ x, x ∈ vals → x ∈ result_list) ∧ new_val ∈ result_list :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

