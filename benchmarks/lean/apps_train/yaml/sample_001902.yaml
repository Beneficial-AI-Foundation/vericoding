vc-description: |-
  Given 2 integers n and start. Your task is return any permutation p of (0,1,2.....,2^n -1) such that :
  
  p[0] = start
  p[i] and p[i+1] differ by only one bit in their binary representation.
  p[0] and p[2^n -1] must also differ by only one bit in their binary representation.
  
  Example 1:
  Input: n = 2, start = 3
  Output: [3,2,0,1]
  Explanation: The binary representation of the permutation is (11,10,00,01). 
  All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]
  
  Example 2:
  Input: n = 3, start = 2
  Output: [2,6,7,5,4,0,1,3]
  Explanation: The binary representation of the permutation is (010,110,111,101,100,000,001,011).
  
  Constraints:
  
  1 <= n <= 16
  0 <= start < 2 ^ n

vc-preamble: |-
  def countOnes (n : Nat) : Nat :=
    sorry
  
  def circularPermutation (n : Nat) (start : Nat) : List Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def listContains (l : List Nat) (n : Nat) : Prop :=
    n ∈ l

vc-theorems: |-
  theorem circularPermutation_length (n : Nat) (start : Nat) 
    (h : start < 2^n) :
    (circularPermutation n start).length = 2^n :=
  sorry
  
  theorem circularPermutation_starts_with_start (n : Nat) (start : Nat)
    (h : start < 2^n) :
    (circularPermutation n start).head! = start :=
  sorry
  
  theorem circularPermutation_contains_all_numbers (n : Nat) (start : Nat)
    (h : start < 2^n) (k : Nat) (hk : k < 2^n):
    listContains (circularPermutation n start) k :=
  sorry
  
  theorem circularPermutation_adjacent_differ_by_one_bit (n : Nat) (start : Nat)
    (h : start < 2^n) (i : Nat) (h2 : i < (circularPermutation n start).length - 1) :
    countOnes ((circularPermutation n start)[i]! ^^^ (circularPermutation n start)[i+1]!) = 1 :=
  sorry
  
  theorem circularPermutation_first_last_differ_by_one_bit (n : Nat) (start : Nat)
    (h : start < 2^n) :
    countOnes ((circularPermutation n start).head! ^^^ (circularPermutation n start).getLast!) = 1 :=
  sorry
  
  theorem circularPermutation_invalid_start (n : Nat) (start : Nat)
    (h : start ≥ 2^n) :
    circularPermutation n start = [] :=
  sorry
  
  /--
  info: [3, 2, 0, 1]
  -/
  #guard_msgs in
  #eval circular_permutation 2 3
  
  /--
  info: [2, 6, 7, 5, 4, 0, 1, 3]
  -/
  #guard_msgs in
  #eval circular_permutation 3 2
  
  /--
  info: [0, 1]
  -/
  #guard_msgs in
  #eval circular_permutation 1 0

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

