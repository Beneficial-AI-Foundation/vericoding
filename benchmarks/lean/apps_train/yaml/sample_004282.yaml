vc-description: |-
  /-
  Complete the function that takes a string as an input, and return a list of all the unpaired characters (i.e. they show up an odd number of times in the string), in the order they were encountered as an array. 
  
  In case of multiple appearances to choose from, take the last occurence of the unpaired character.
  
  **Notes:**
  * A wide range of characters is used, and some of them may not render properly in your browser.
  * Your solution should be linear in terms of string length to pass the last test.
  
  ## Examples
  
  ```
  "Hello World"   -->  ["H", "e", " ", "W", "r", "l", "d"]
  "Codewars"      -->  ["C", "o", "d", "e", "w", "a", "r", "s"]
  "woowee"        -->  []
  "wwoooowweeee"  -->  []
  "racecar"       -->  ["e"]
  "Mamma"         -->  ["M"]
  "Mama"          -->  ["M", "m"]
  ```
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def odd_one_out (s : String) : List Char := sorry
  
  theorem odd_one_out_output_valid (s : String) :
    let result := odd_one_out s
    -- All elements are characters from input string
    (∀ c ∈ result, c ∈ s.data) ∧
    -- Each character appears odd times in original
    (∀ c ∈ result, (s.data.count c) % 2 = 1) ∧
    -- No duplicates
    result.Nodup := by sorry

vc-theorems: |-
  theorem odd_one_out_nonempty (s : String) (h : s ≠ "") :
    let result := odd_one_out s
    (∃ c ∈ s.data, (s.data.count c) % 2 = 1) →
    result ≠ [] := by sorry
  
  theorem odd_one_out_complete (s : String) :
    let result := odd_one_out s
    result.length = (s.data.filter (fun c => (s.data.count c) % 2 = 1)).length := by sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

