vc-description: |-
  You're about to go on a trip around the world! On this trip you're bringing your trusted backpack, that anything fits into. The bad news is that the airline has informed you, that your luggage cannot exceed a certain amount of weight.
  
  To make sure you're bringing your most valuable items on this journey you've decided to give all your items a score that represents how valuable this item is to you. It's your job to pack you bag so that you get the most value out of the items that you decide to bring.
  
  Your input will consist of two arrays, one for the scores and one for the weights. You input will always be valid lists of equal length, so you don't have to worry about verifying your input.
  
  You'll also be given a maximum weight. This is the weight that your backpack cannot exceed.
  
  For instance, given these inputs:
  
      scores = [15, 10, 9, 5]
      weights = [1, 5, 3, 4]
      capacity = 8
  
  The maximum score will be ``29``. This number comes from bringing items ``1, 3 and 4``.
  
  Note: Your solution will have to be efficient as the running time of your algorithm will be put to a test.

vc-preamble: |-
  def List.sum : List Nat → Nat
    | [] => 0
    | x::xs => x + sum xs
  
  def List.minimum : List Nat → Nat
    | [] => 0 
    | [x] => x
    | x::xs => Nat.min x (minimum xs)
  
  def pack_bagpack (scores weights : List Nat) (capacity : Nat) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def max_valid_score (scores weights : List Nat) (capacity : Nat) : Nat :=
    let pairs := List.zip scores weights
    let valid := List.filter (fun p => p.snd ≤ capacity) pairs
    let scores := List.map Prod.fst valid
    match scores with
    | [] => 0
    | x::xs => List.foldl Nat.max x xs

vc-theorems: |-
  theorem pack_backpack_non_negative (scores weights : List Nat) (capacity : Nat) :
    pack_bagpack scores weights capacity ≥ 0 := sorry
  
  theorem pack_backpack_at_most_sum_scores (scores weights : List Nat) (capacity : Nat) :
    pack_bagpack scores weights capacity ≤ List.sum scores := sorry
  
  theorem pack_backpack_zero_if_capacity_too_small 
    (scores weights : List Nat) (capacity : Nat)
    (h : capacity < List.minimum weights) :
    pack_bagpack scores weights capacity = 0 := sorry
  
  theorem pack_backpack_at_least_max_valid_score 
    (scores weights : List Nat) (capacity : Nat)
    (h : scores.length = weights.length)
    (h2 : scores.length > 0) :
    pack_bagpack scores weights capacity ≥ max_valid_score scores weights capacity := sorry
  
  /--
  info: 29
  -/
  #guard_msgs in
  #eval pack_bagpack [15, 10, 9, 5] [1, 5, 3, 4] 8
  
  /--
  info: 60
  -/
  #guard_msgs in
  #eval pack_bagpack [20, 5, 10, 40, 15, 25] [1, 2, 3, 8, 7, 4] 10
  
  /--
  info: 39
  -/
  #guard_msgs in
  #eval pack_bagpack [100, 5, 16, 18, 50] [25, 1, 3, 2, 15] 14

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

