vc-description: |-
  /-
  Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.
  Return the least number of moves to make every value in A unique.
  
  Example 1:
  Input: [1,2,2]
  Output: 1
  Explanation:  After 1 move, the array could be [1, 2, 3].
  
  Example 2:
  Input: [3,2,1,2,1,7]
  Output: 6
  Explanation:  After 6 moves, the array could be [3, 4, 1, 2, 5, 7].
  It can be shown with 5 or less moves that it is impossible for the array to have all unique values.
  
  Note:
  
  0 <= A.length <= 40000
  0 <= A[i] < 40000
  -/

vc-preamble: |-
  def min_increment_for_unique (nums : List Int) : Nat :=
    sorry
  
  def sorted (l : List Int) : List Int :=
    sorry
  
  def makeUnique (nums : List Int) : List Int :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def sumList (l : List Int) : Int :=
    sorry

vc-theorems: |-
  theorem min_increment_nonneg (nums : List Int) :
    min_increment_for_unique nums ≥ 0 :=
    sorry
  
  theorem min_increment_empty (nums : List Int) :
    nums = [] → min_increment_for_unique nums = 0 :=
    sorry
  
  theorem min_increment_single (nums : List Int) (x : Int) : 
    nums = [x] → min_increment_for_unique nums = 0 :=
    sorry
  
  theorem min_increment_sort_invariant (nums : List Int) :
    min_increment_for_unique nums = min_increment_for_unique (sorted nums) :=
    sorry
  
  theorem min_increment_makes_unique (nums : List Int) :
    let result := sorted nums
    let incremented := makeUnique result
    min_increment_for_unique nums = (sumList incremented - sumList result) :=
    sorry
  
  /-
  info: 1
  -/
  -- #guard_msgs in
  -- #eval min_increment_for_unique [1, 2, 2]
  
  /-
  info: 6
  -/
  -- #guard_msgs in
  -- #eval min_increment_for_unique [3, 2, 1, 2, 1, 7]
  
  /-
  info: 0
  -/
  -- #guard_msgs in
  -- #eval min_increment_for_unique []

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

