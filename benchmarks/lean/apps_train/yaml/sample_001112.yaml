vc-description: |-
  In the 2-D world of Flatland, the Circles were having their sports day and wanted to end it with a nice formation. So, they called upon Mr. Sphere from Spaceland for help. Mr Sphere decides to arrange the Circles in square formations. He starts with $N$ Circles and forms the largest possible square using these Circles. He then takes the remaining Circles and repeats the procedure. A square of side $S$ requires $S^2$ Circles to create.
  Find the number of squares he will be able to form at the end of the process.
  
  -----Input:-----
  - First line will contain $T$, number of testcases. Then the testcases follow.
  - Each testcase contains of a single integer $N$.
  
  -----Output:-----
  For each testcase, output a single integer denoting the number of squares.
  
  -----Constraints-----
  - $1 \leq T \leq 1000$
  - $1 \leq N \leq 1000$
  
  -----Sample Input:-----
  2
  
  85
  
  114          
  
  -----Sample Output:-----
  2
  
  4
  
  -----EXPLANATION:-----
  Test case 1 : Mr Sphere forms a square of side 9 using 81 Circles and then forms a square of side 2 using the remaining 4.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def count_squares (n : Nat) : Nat := sorry
  
  /-- Every positive number can be decomposed into a sum of squares,
      and the count of squares is positive and not larger than the input number -/

vc-theorems: |-
  theorem count_squares_basic_properties (n : Nat) (h : n > 0) :
    let result := count_squares n
    0 < result ∧ result ≤ n := sorry
  
  /-- The decomposition count equals 1 for perfect squares -/
  
  theorem count_squares_perfect (n : Nat) (h : n > 0) :
    count_squares (n * n) = 1 := sorry
  
  /-- Basic results for small numbers -/
  
  theorem count_squares_small_numbers :
    count_squares 1 = 1 ∧ 
    count_squares 2 = 2 ∧ 
    count_squares 3 = 3 := sorry
  
  /-- The sum of squares used in decomposition equals the input number -/
  
  theorem count_squares_sum_property (n : Nat) (h : n > 0) :
    ∃ (squares : List Nat),
      squares.length ≤ count_squares n ∧
      (∀ x ∈ squares, ∃ k, x = k * k) ∧
      (squares.foldl (· + ·) 0 = n) := sorry
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval count_squares 85
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval count_squares 114
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval count_squares 10

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

