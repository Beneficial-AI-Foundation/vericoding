vc-description: |-
  We define the score of permutations of combinations, of an integer number (the function to obtain this value:```sc_perm_comb```) as the total sum of all the numbers obtained from the permutations of all the possible combinations of its digits.
  For example we have the number 348.
  ```python
  sc_perm_comb(348) = 3 + 4 + 8 + 34 + 38 + 48 + 43 + 83 + 84 + 348 + 384 + 834 + 843 + 438 + 483  = 3675
  ```
  If the number has a digit 0, the numbers formed by a leading 0 should be discarded:
  ```python
  sc_perm_comb(340) = 3 + 4 + 34 + 30 + 40 + 43 + 340 + 304 + 430 + 403 = 1631
  ```
  If the number has digits that occur more than once, the score the adden will not be taken than twice or more:
  ```python
  sc_perm_comb(333) = 3 + 33 + 333 = 369
  ```
  If the number has only one digit its score is the same number:
  ```python
  sc_perm_comb(6) = 6
  sc_perm_comb(0) = 0
  ```
  
  Enjoy it!!

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def sc_perm_comb (n : Nat) : Nat := sorry
  
  theorem sc_perm_comb_non_negative (n : Nat) :
    sc_perm_comb n ≥ 0 := sorry

vc-theorems: |-
  theorem sc_perm_comb_geq_input (n : Nat) :
    sc_perm_comb n ≥ n := sorry 
  
  theorem sc_perm_comb_single_digit (n : Nat) (h : n ≤ 9) :
    sc_perm_comb n = n := sorry
  
  theorem sc_perm_comb_zero :
    sc_perm_comb 0 = 0 := sorry
  
  theorem sc_perm_comb_two_digits (n : Nat) (h1 : n ≥ 10) (h2 : n ≤ 99) 
      (h3 : n % 10 ≠ n / 10) :
    sc_perm_comb n ≥ n + (n % 10 * 10 + n / 10) := sorry
  
  /--
  info: 3675
  -/
  #guard_msgs in
  #eval sc_perm_comb 348
  
  /--
  info: 1631
  -/
  #guard_msgs in
  #eval sc_perm_comb 340
  
  /--
  info: 369
  -/
  #guard_msgs in
  #eval sc_perm_comb 333

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

