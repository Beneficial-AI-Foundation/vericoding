vc-description: |-
  /-
  # Introduction 
  
  Hamsters are rodents belonging to the subfamily Cricetinae. The subfamily contains about 25 species, classified in six or seven genera. They have become established as popular small house pets, and, partly because they are easy to breed in captivity, hamsters are often used as laboratory animals.
  
  # Task 
  
  Write a function that accepts two inputs: `code` and `message` and returns an encrypted string from `message` using the `code`.   
  The `code` is a string that generates the key in the way shown below:
  
  ```
   1  | h a m s t e r
   2  | i b n   u f
   3  | j c o   v g
   4  | k d p   w
   5  | l   q   x
   6  |         y
   7  |         z
  
  ```
  
  All letters from `code` get number `1`. All letters which directly follow letters from `code` get number `2` (unless they already have a smaller number assigned), etc. It's difficult to describe but it should be easy to understand from the example below:
  
  ```
   1  | a e h m r s t
   2  | b f i n     u
   3  | c g j o     v
   4  | d   k p     w
   5  |     l q     x
   6  |             y
   7  |             z
  
  ```
  
  How does the encoding work using the `hamster` code?    
  
  ```
  a => a1
  b => a2
  c => a3
  d => a4
  e => e1
  f => e2
  ...
  ```
  
  And applying it to strings :
  
  ```
  hamsterMe('hamster', 'hamster')   => h1a1m1s1t1e1r1
  hamsterMe('hamster', 'helpme')    => h1e1h5m4m1e1
  
  ```
  
  And you probably started wondering what will happen if there is no `a` in the `code`.  
  Just add these letters after the last available letter (in alphabetic order) in the `code`.
  
  The key for code `hmster` is:
  ```
   1  | e h m r s t
   2  | f i n     u
   3  | g j o     v
   4  |   k p     w
   5  |   l q     x
   6  |           y
   7  |           z
   8  |           a
   9  |           b
  10  |           c
  11  |           d
  ```
  
  # Additional notes
  
  The `code` will have at least 1 letter.   
  Duplication of letters in `code` is possible and should be handled.    
  The `code` and `message` consist of only lowercase letters.
  -/

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def hamster_me (code : String) (message : String) : String := sorry
  
  theorem hamster_output_contents (code : String) (message : String) (h1 : code ≠ "") :
    let result := hamster_me code message
    ∀ c ∈ result.data, 
      (c ∈ code.data) ∨ ('0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat) := sorry

vc-theorems: |-
  theorem hamster_output_length (code : String) (message : String) (h1 : code ≠ "") :
    let result := hamster_me code message
    (result.data.filter Char.isAlpha).length = message.length := sorry
  
  theorem hamster_deterministic (code : String) (message : String) (h1 : code ≠ "") :
    hamster_me code message = hamster_me code message := sorry
  
  theorem hamster_code_order_invariant (code code' : String) (message : String) 
      (h1 : code ≠ "") (h2 : ∀ c, c ∈ code.data ↔ c ∈ code'.data) :
    hamster_me code message = hamster_me code' message := sorry
  
  theorem hamster_empty_message (code : String) (h1 : code ≠ "") :
    hamster_me code "" = "" := sorry
  
  theorem hamster_single_char_code (message : String) :
    let result := hamster_me "a" message
    ∀ c ∈ result.data,
      c = 'a' ∨ ('0'.toNat ≤ c.toNat ∧ c.toNat ≤ '9'.toNat) := sorry
  
  /-
  info: 'h1a1m1s1t1e1r1'
  -/
  -- #guard_msgs in
  -- #eval hamster_me "hamster" "hamster"
  
  /-
  info: 'h1e1h5m4m1e1'
  -/
  -- #guard_msgs in
  -- #eval hamster_me "hamster" "helpme"
  
  /-
  info: 'h1t8m1s1t1e1r1'
  -/
  -- #guard_msgs in
  -- #eval hamster_me "hmster" "hamster"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

