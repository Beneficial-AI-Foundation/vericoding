vc-description: |-
  Sunita has lots of tasks pending and she has no time to complete.  She needs your help and wants you complete the task.
  You are given a list of integers and two values $N$ and $K$ $-$ the size of array of integers and the numbers of partitions to be made respectively.
  You have to partition the list of integers without changing the order of elements ,into exactly $K$ parts. 
  Calculate Greatest Common Divisor of all $K$ partition and sum up the gcd values for each partition.
  Maximize the sum obtained. 
  Can you help Sunita ? 
  
  -----Input:-----
  - First line will contain $T$, number of test cases. Then the test cases follow. 
  - Each test case contains of a single line of input, two integers $N, K$. 
  - Next line contains $N$ integers $-$ the list of integers.
  
  -----Output:-----
  For each test case, output in a single line integer $-$ the maximal result.
  
  -----Constraints-----
  - $1 \leq T \leq 100$
  - $1 \leq N, K \leq 250$
  - $1 \leq K \leq N$
  - $1 \leq A[i] \leq 1e5$
  
  -----Sample Input:-----
  1
  4 2
  5 6 3 2
  
  -----Sample Output:-----
  6
  
  -----EXPLANATION:-----
  [5] [6 3 2] is the best partition [5 + GCD(6,3,2)] = 6

vc-preamble: |-
  def List.sum : List Nat → Nat 
    | [] => 0
    | x :: xs => x + xs.sum
  
  def gcd_multiple (nums : List Nat) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def max_gcd_partition_sum (n k : Nat) (arr : List Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem gcd_multiple_divides (nums : List Nat) (h : nums ≠ []) :
    let result := gcd_multiple nums
    (∀ n ∈ nums, n % result = 0) ∧ result > 0 := by
    sorry
  
  theorem max_gcd_sum_basic_properties 
    (n k : Nat) (arr : List Nat)
    (h1 : arr.length ≥ n)
    (h2 : k ≤ n) :
    let result := max_gcd_partition_sum n k arr 
    result ≥ 0 ∧ 
    result ≤ (arr.take n).sum := by
    sorry
  
  theorem max_gcd_sum_k_one
    (n : Nat) (arr : List Nat)
    (h : arr.length ≥ n) :
    max_gcd_partition_sum n 1 arr = gcd_multiple (arr.take n) := by
    sorry
  
  theorem max_gcd_sum_k_eq_n
    (n : Nat) (arr : List Nat)
    (h : arr.length ≥ n) :
    max_gcd_partition_sum n n arr = (arr.take n).sum := by
    sorry
  
  theorem max_gcd_sum_identical_elements
    (n k : Nat) 
    (h1 : n ≥ 2)
    (h2 : k = n/2) :
    let arr := List.replicate n 10
    max_gcd_partition_sum n k arr = 10 * k := by
    sorry
  
  /--
  info: 6
  -/
  #guard_msgs in
  #eval max_gcd_partition_sum 4 2 [5, 6, 3, 2]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

