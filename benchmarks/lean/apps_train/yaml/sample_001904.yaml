vc-description: |-
  Consider a directed graph, with nodes labelled 0, 1, ..., n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.
  Each [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.
  Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn't exist).
  
  Example 1:
  Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
  Output: [0,1,-1]
  Example 2:
  Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
  Output: [0,1,-1]
  Example 3:
  Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]
  Output: [0,-1,-1]
  Example 4:
  Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]
  Output: [0,1,2]
  Example 5:
  Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]
  Output: [0,1,1]
  
  Constraints:
  
  1 <= n <= 100
  red_edges.length <= 400
  blue_edges.length <= 400
  red_edges[i].length == blue_edges[i].length == 2
  0 <= red_edges[i][j], blue_edges[i][j] < n

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def shortestAlternatingPaths (n : Nat) (redEdges blueEdges : List Edge) : List Int :=
    sorry

vc-theorems: |-
  theorem empty_path_valid (n : Nat) (edges : List Edge) 
    (h1 : n > 0) (h2 : ∀ e ∈ edges, e.from_ < n ∧ e.to_ < n) :
    let result := shortestAlternatingPaths n edges []
    -- Result length matches n
    List.length result = n
    -- First element is 0
    ∧ List.get! result 0 = 0 
    -- All elements are -1 or valid length < 2n
    ∧ ∀ x ∈ result, x ≥ -1 ∧ (x = -1 ∨ x < 2 * n) :=
  sorry
  
  theorem alternating_path_valid (n : Nat) (redEdges blueEdges : List Edge)
    (h1 : n > 0)
    (h2 : ∀ e ∈ redEdges, e.from_ < n ∧ e.to_ < n)
    (h3 : ∀ e ∈ blueEdges, e.from_ < n ∧ e.to_ < n) :
    let result := shortestAlternatingPaths n redEdges blueEdges
    -- Result length matches n
    List.length result = n
    -- First element is 0
    ∧ List.get! result 0 = 0
    -- All elements are -1 or valid length < 2n 
    ∧ ∀ x ∈ result, x ≥ -1 ∧ (x = -1 ∨ x < 2 * n) :=
  sorry
  
  theorem no_edges (n : Nat) (h : n > 0) :
    let result := shortestAlternatingPaths n ([] : List Edge) ([] : List Edge)
    List.get! result 0 = 0
    ∧ ∀ i, i > 0 → i < n → List.get! result i = -1 := 
  sorry
  
  theorem self_loops :
    let n := 3
    let result := shortestAlternatingPaths n 
      [⟨0, 0⟩] [⟨0, 0⟩]
    List.get! result 0 = 0 :=
  sorry
  
  /--
  info: [0, 1, -1]
  -/
  #guard_msgs in
  #eval shortest_alternating_paths 3 [[0, 1], [1, 2]] []
  
  /--
  info: [0, 1, 2]
  -/
  #guard_msgs in
  #eval shortest_alternating_paths 3 [[0, 1]] [[1, 2]]
  
  /--
  info: [0, 1, 1]
  -/
  #guard_msgs in
  #eval shortest_alternating_paths 3 [[0, 1], [0, 2]] [[1, 0]]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

