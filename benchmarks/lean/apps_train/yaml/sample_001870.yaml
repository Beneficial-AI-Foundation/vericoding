vc-description: |-
  /-
  Given a linked list, remove the n-th node from the end of list and return its head.
  
  Example:
  
  Given linked list: 1->2->3->4->5, and n = 2.
  
  After removing the second node from the end, the linked list becomes 1->2->3->5.
  
  Note:
  
  Given n will always be valid.
  
  Follow up:
  
  Could you do this in one pass?
  -/

vc-preamble: |-
  def removeNthFromEnd (head : Node) (n : Nat) : Option Node :=
    sorry
  
  def create_linked_list (arr : List Int) : Option Node :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def linked_list_to_array (head : Option Node) : List Int :=
    sorry

vc-theorems: |-
  theorem remove_nth_maintains_order {arr : List Int} {n : Nat} 
    (h1 : 0 < n) (h2 : n ≤ arr.length) :
    let head := create_linked_list arr
    let result := removeNthFromEnd (Option.get! head) n
    let result_arr := linked_list_to_array result
    (result_arr.length = arr.length - 1) ∧ 
    (result_arr = (arr.take (arr.length - n)) ++ (arr.drop (arr.length - n + 1))) :=
  sorry
  
  theorem remove_first_element {arr : List Int}
    (h : arr.length > 0) :
    let head := create_linked_list arr
    let result := removeNthFromEnd (Option.get! head) arr.length
    linked_list_to_array result = arr.tail :=
  sorry
  
  theorem remove_last_element {arr : List Int}
    (h : arr.length > 0) :
    let head := create_linked_list arr
    let result := removeNthFromEnd (Option.get! head) 1
    linked_list_to_array result = arr.dropLast :=
  sorry
  
  /-
  info: [1, 2, 3, 5]
  -/
  -- #guard_msgs in
  -- #eval linked_list_to_array removeNthFromEnd(head1, 2)
  
  /-
  info: []
  -/
  -- #guard_msgs in
  -- #eval linked_list_to_array removeNthFromEnd(head2, 1)
  
  /-
  info: [1]
  -/
  -- #guard_msgs in
  -- #eval linked_list_to_array removeNthFromEnd(head3, 1)

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

