vc-description: |-
  In this task you have to code process planner.
  
  You will be given initial thing, target thing and a set of processes to turn one thing into another (in the form of _[process\_name, start\_thing, end\_thing]_). You must return  names of shortest sequence of processes to turn initial thing into target thing, or empty sequence if it's impossible.
  
  If start already equals end, return [], since no path is required.
  
  Example: 
  
  ```python
  test_processes = [
          ['gather', 'field', 'wheat'],
          ['bake', 'flour', 'bread'],
          ['mill', 'wheat', 'flour']
  ];
  
  processes('field', 'bread', test_processes) # should return ['gather', 'mill', 'bake']
  processes('field', 'ferrari', test_processes) # should return []
  processes('field', 'field', test_processes) # should return [], since no processes are needed
  ```
  
  Good luck!

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def processes (start : String) (destination : String) (procs : List Process) : List String :=
    sorry

vc-theorems: |-
  theorem processes_returns_list (start dest : String) (procs : List Process) :
    ∀ x ∈ processes start dest procs, String.isPrefixOf "" x :=
    sorry
  
  theorem processes_valid_path (start dest : String) (procs : List Process) 
    (h : (processes start dest procs).length > 0) :
    (List.foldl
      (fun curr step =>
        match procs.find? (fun p => p.name = step) with
        | some proc => proc.endNode
        | none => curr)
      start
      (processes start dest procs)) = dest :=
    sorry
  
  theorem processes_same_start (s : String) (procs : List Process) :
    processes s s procs = [] :=
    sorry
  
  theorem processes_empty_procs (start dest : String) :
    processes start dest [] = [] :=
    sorry
  
  theorem processes_cycle_detection :
    let cycleProcs := [
      {name := "1", startNode := "a", endNode := "b"},
      {name := "2", startNode := "b", endNode := "c"},
      {name := "3", startNode := "c", endNode := "b"}]
    ; processes "a" "d" cycleProcs = [] :=
    sorry

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded

