vc-description: |-
  Assume that you started to store items in progressively expanding square location, like this for the first 9 numbers:
  
  ```
  05 04 03
  06 01 02
  07 08 09
  ```
  
  And like this for the expanding to include up to the first 25 numbers:
  
  ```
  17 16 15 14 13
  18 05 04 03 12
  19 06 01 02 11
  20 07 08 09 10
  21 22 23 24 25
  ```
  
  You might easily notice that the first - and innermost - layer containes only one number (`01`), the second one  - immediately around it - contains 8 numbers (number in the `02-09` range) and so on.
  
  Your task is to create a function that given a number `n` simply returns the number of layers required to store up to `n` (included).
  
  ```python
  layers(1) == 1
  layers(5) == 2
  layers(25) == 3
  layers(30) == 4
  layers(50) == 5
  ```
  
  **Fair warning:** you will always and only get positive integers, but be ready for bigger numbers in the tests!
  
  If you had fun with this, also try some follow up kata: [progressive spiral number branch](https://www.codewars.com/kata/progressive-spiral-number-branch/) and [progressive spiral number distance](https://www.codewars.com/kata/progressive-spiral-number-distance/).
  
  *[Base idea taken from [here](http://adventofcode.com/2017/day/3)]*

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def layers (n : Nat) : Nat := sorry
  
  theorem layers_positive (n : Nat) (h : n > 0) : 
    layers n > 0 := sorry

vc-theorems: |-
  theorem layer_fits_n (n : Nat) (h : n > 0) :
    let k := layers n
    (2*k - 1)^2 â‰¥ n := sorry
  
  theorem prev_layer_too_small (n : Nat) (h : n > 0) (h2 : layers n > 1) :
    let k := layers n
    (2*(k-1) - 1)^2 < n := sorry
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval layers 1
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval layers 5
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval layers 25

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

