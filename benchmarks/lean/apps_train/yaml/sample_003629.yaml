vc-description: |-
  ```if:javascript
  `Array.prototype.length` will give you the number of top-level elements in an array.
  ```
  ```if:ruby
  `Array#length` will give you the number of top-level elements in an array.
  ```
  ```if:csharp
  The `Length` property of an array will give you the number of top-level elements in an array.
  ```
  ```if:php
  `count()` will give you the number of top-level elements in an array if exactly one argument `$a` is passed in which is the array.
  ```
  ```if:python
  `len(a)` will give you the number of top-level elements in the list/array named `a`.
  ```
  
  Your task is to create a function ```deepCount``` that returns the number of ALL elements within an array, including any within inner-level arrays.
  
  For example:
  
  ```if:javascript
      deepCount([1, 2, 3]);  
      //>>>>> 3
      deepCount(["x", "y", ["z"]]);  
      //>>>>> 4
      deepCount([1, 2, [3, 4, [5]]]);  
      //>>>>> 7
  ```
  ```if:ruby
      deepCount([1, 2, 3]);  
      //>>>>> 3
      deepCount(["x", "y", ["z"]]);  
      //>>>>> 4
      deepCount([1, 2, [3, 4, [5]]]);  
      //>>>>> 7
  ```
  ```if:csharp
      deepCount([1, 2, 3]);  
      //>>>>> 3
      deepCount(["x", "y", ["z"]]);  
      //>>>>> 4
      deepCount([1, 2, [3, 4, [5]]]);  
      //>>>>> 7
  ```
  ```if:php
      deep_c([1, 2, 3]);
      //>>>>> 3
      deep_c(["x", "y", ["z"]]);
      //>>>>> 4
      deep_c([1, 2, [3, 4, [5]]]);
      //>>>>> 7
  ```
  ```if:python
      deepCount([1, 2, 3]);  
      //>>>>> 3
      deepCount(["x", "y", ["z"]]);  
      //>>>>> 4
      deepCount([1, 2, [3, 4, [5]]]);  
      //>>>>> 7
  ```
  
  The input will always be an array.
  
  ```if:php
  In PHP you may *not* assume that the array passed in will be non-associative.
  
  Please note that `count()`, `eval()` and `COUNT_RECURSIVE` are disallowed - you should be able to implement the logic for `deep_c()` yourself ;)
  ```

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def deep_count {α : Type} (l : NestedList α) : Nat :=
    sorry

vc-theorems: |-
  theorem deep_count_nonnegative {α : Type} (l : NestedList α) :
    deep_count l ≥ 0 :=
  sorry
  
  theorem deep_count_geq_outer_length {α : Type} (l : List (NestedList α)) :
    deep_count (NestedList.list l) ≥ l.length :=
  sorry
  
  theorem deep_count_flat_list {α : Type} (l : List α) :
    deep_count (NestedList.list (l.map NestedList.elem)) = l.length :=
  sorry
  
  theorem deep_count_nested_list {α : Type} (outer : List (List α)) :
    deep_count (NestedList.list (outer.map (fun inner => NestedList.list (inner.map NestedList.elem)))) =
    outer.length + (outer.foldl (fun acc l => acc + l.length) 0) :=
  sorry
  
  theorem deep_count_empty {α : Type} :
    deep_count (NestedList.list ([] : List (NestedList α))) = 0 :=
  sorry
  
  theorem deep_count_empty_nested {α : Type} :
    deep_count (NestedList.list [NestedList.list ([] : List (NestedList α))]) = 1 :=
  sorry
  
  theorem deep_count_two_empty {α : Type} :
    deep_count (NestedList.list [NestedList.list ([] : List (NestedList α)), NestedList.list ([] : List (NestedList α))]) = 2 :=
  sorry
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval deep_count [1, 2, 3]
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval deep_count ["x", "y", ["z"]]
  
  /--
  info: 7
  -/
  #guard_msgs in
  #eval deep_count [1, 2, [3, 4, [5]]]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

