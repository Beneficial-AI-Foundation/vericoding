vc-description: |-
  Given a set of integers _S_, the _closure of S under multiplication_ is the smallest set that contains _S_ and such that for any _x, y_ in the closure of _S_, the product _x * y_ is also in the closure of _S_. 
  
  Example 1: Given `S = {2}`, the closure of `S` is the set `{2, 4, 8, 16, 32, 64, ... }`.
  
  Example 2: Given `S = {1, 2, 3}`, the closure of `S` is the set `{1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, 32, 36, ...}`. This set contains, e.g, `6` because `6 = 2 * 3`. It further contains `12` and `18` because `12 = 2 * 6` and `18 = 3 * 6`. Etc. 
  
  Example 3: Given `S` the set of prime numbers, the closure of `S` is the set of all positive integers greater than or equal to `2`. 
  
  Your task is two write a generator function that generates the members of the closure of any given _finite_ set of positive numbers `S` in _ascending order_.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def closure_gen : List Nat → List Nat
    | _ => sorry

vc-theorems: |-
  theorem closure_is_ordered (s: List Nat) (h: s.length > 0) (h₂: ∀ x, x ∈ s → 1 ≤ x ∧ x ≤ 10) (i j: Nat) (h₃: i < j) :
    let res := closure_gen s
    ∀ x y, x ∈ res → y ∈ res → (res.get! i = x ∧ res.get! j = y) → x < y := sorry
  
  theorem minimal_closure (n: Nat) (h: 2 ≤ n ∧ n ≤ 3) :
    let res := closure_gen [n]
    res.get! 0 = n ∧ res.get! 1 = n * n := sorry
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval next closure_gen(2)
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval next g1
  
  /--
  info: 8
  -/
  #guard_msgs in
  #eval next g1

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

