vc-description: |-
  You have d dice, and each die has f faces numbered 1, 2, ..., f.
  Return the number of possible ways (out of fd total ways) modulo 10^9 + 7 to roll the dice so the sum of the face up numbers equals target.
  
  Example 1:
  Input: d = 1, f = 6, target = 3
  Output: 1
  Explanation: 
  You throw one die with 6 faces.  There is only one way to get a sum of 3.
  
  Example 2:
  Input: d = 2, f = 6, target = 7
  Output: 6
  Explanation: 
  You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:
  1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
  
  Example 3:
  Input: d = 2, f = 5, target = 10
  Output: 1
  Explanation: 
  You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.
  
  Example 4:
  Input: d = 1, f = 2, target = 3
  Output: 0
  Explanation: 
  You throw one die with 2 faces.  There is no way to get a sum of 3.
  
  Example 5:
  Input: d = 30, f = 30, target = 500
  Output: 222616187
  Explanation: 
  The answer must be returned modulo 10^9 + 7.
  
  Constraints:
  
  1 <= d, f <= 30
  1 <= target <= 1000

vc-preamble: |-
  def numRollsToTarget (d f t : Nat) : Nat :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def M := 1000000007
  
  theorem impossible_target (d f t : Nat) :
    (t < d ∨ t > d*f) → numRollsToTarget d f t = 0 :=
  sorry

vc-theorems: |-
  theorem single_die_possible (f t : Nat) :
    1 ≤ t ∧ t ≤ f → numRollsToTarget 1 f t = 1 :=
  sorry
  
  theorem single_die_impossible (f t : Nat) :
    (t < 1 ∨ t > f) → numRollsToTarget 1 f t = 0 :=
  sorry
  
  theorem above_max_target (d f : Nat) :
    numRollsToTarget d f (d*f+1) = 0 :=
  sorry
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval numRollsToTarget 1 6 3
  
  /--
  info: 6
  -/
  #guard_msgs in
  #eval numRollsToTarget 2 6 7
  
  /--
  info: 1
  -/
  #guard_msgs in
  #eval numRollsToTarget 2 5 10

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible

