vc-description: |-
  Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.
  
  Example 1:
  
  Input:nums = [1,1,1], k = 2
  Output: 2
  
  Note:
  
  The length of the array is in range [1, 20,000].
  The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def countSubarraysWithSum (nums : List Int) (k : Int) : Nat :=
    sorry

vc-theorems: |-
  theorem empty_list_property (k : Int) :
    countSubarraysWithSum [] k = 0 := by
    sorry
  
  theorem single_element_property (x k : Int) :
    countSubarraysWithSum [x] k = if x = k then 1 else 0 := by
    sorry
  
  theorem uniform_array_property {x : Int} {len : Nat} {arr : List Int} 
      (h1 : len > 0)
      (h2 : arr = List.replicate len x) :
      x ≠ 0 → len ≥ 2 → countSubarraysWithSum arr (2*x) > 0 := by
    sorry
  
  theorem uniform_zeros_property {len : Nat} {arr : List Int}
      (h1 : len > 0)
      (h2 : arr = List.replicate len 0) :
      countSubarraysWithSum arr 0 = len * (len + 1) / 2 := by
    sorry
  
  theorem non_negative_result_property (nums : List Int) (k : Int) :
    countSubarraysWithSum nums k ≥ 0 := by
    sorry
  
  theorem reverse_invariant_property (nums : List Int) (k : Int) :
    countSubarraysWithSum nums k = countSubarraysWithSum (List.reverse nums) k := by
    sorry
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval count_subarrays_with_sum [1, 1, 1] 2
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval count_subarrays_with_sum [1, 2, 3] 3
  
  /--
  info: 3
  -/
  #guard_msgs in
  #eval count_subarrays_with_sum [1, -1, 0] 0

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

