vc-description: |-
  You are given an array A of size N. Let us list down all the subarrays of the given array. There will be a total of N * (N + 1) / 2 subarrays of the given array. Let us sort each of the subarrays in descending order of the numbers in it. 
  
  Now you want to sort these subarrays in descending order. You can compare two subarrays B, C, as follows.
  
  compare(B, C):
  Append N - |B| zeros at the end of the array B.
  Append N - |C| zeros at the end of the array C.
  for i = 1 to N:
  if B[i] < C[i]:
  return B is less than C
  if B[i] > C[i]:
  return B is greater than C
  return B and C are equal.
  
  You are given M queries asking for the maximum element in the pth subarray (1-based indexing).
  
  -----Input-----
  The first line of input contains T, the number of test cases.
  The first line of each test case contains two space separated integers N and M, denoting the array size and the number of queries respectively.
  The next line contains N space-separated integers denoting the array elements.
  
  Each of the next M lines contains a single integer - p.
  
  -----Output-----
  Output a single integer corresponding to the maximum element in the pth subarray.
  
  -----Constraints-----
  - 1 ≤ Ai ≤ 109
  - 1 ≤ p ≤ N+1C2
  
  -----Subtasks-----Subtask #1 (20 points):
  - 1 ≤ T ≤ 20
  - 1 ≤ N ≤ 200
  - 1 ≤ M ≤ 104
  Subtask #2 (30 points):
  - 1 ≤ T ≤ 20
  - 1 ≤ N ≤ 3000
  - 1 ≤ M ≤ 104
  Subtask #3 (50 points):
  - 1 ≤ T ≤ 5
  - 1 ≤ N ≤ 105
  - 1 ≤ M ≤ 105
  
  -----Example-----
  Input:1
  4 2
  3 1 2 4
  1
  5
  
  Output:4
  3

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def solve_max_subarray_query (n : Nat) (arr : List Int) (queries : List Nat) : List Int := sorry
  
  def list_maximum (l : List Int) : Int := 
    match l with
    | [] => 0
    | x::xs => (List.foldl max x xs)

vc-theorems: |-
  theorem length_and_types {n : Nat} {arr : List Int} {queries : List Nat} 
    (h1 : arr.length > 0) 
    (h2 : arr.length ≤ 5)  
    (h3 : queries.length > 0)
    (h4 : queries.length ≤ 3)
    (h5 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100)
    (h6 : ∀ q ∈ queries, 1 ≤ q ∧ q ≤ 15) :
    let result := solve_max_subarray_query n arr queries
    result.length = queries.length := 
  sorry
  
  theorem max_values {n : Nat} {arr : List Int} {queries : List Nat}
    (h1 : arr.length > 0)
    (h2 : arr.length ≤ 4)
    (h3 : queries.length > 0) 
    (h4 : queries.length ≤ 3)
    (h5 : ∀ x ∈ arr, -100 ≤ x ∧ x ≤ 100)
    (h6 : ∀ q ∈ queries, 1 ≤ q ∧ q ≤ 10) :
    let result := solve_max_subarray_query n arr queries
    ∀ x, x ∈ result → x ≤ list_maximum arr :=
  sorry
  
  theorem identical_queries {n : Nat} {arr : List Int}
    (h1 : arr.length > 0)
    (h2 : arr.length ≤ 3) 
    (h3 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10) :
    let queries := List.replicate 3 1
    let result := solve_max_subarray_query n arr queries
    ∀ x y, x ∈ result → y ∈ result → x = y :=
  sorry
  
  /--
  info: [4, 3]
  -/
  #guard_msgs in
  #eval solve_max_subarray_query 4 [3, 1, 2, 4] [1, 5]
  
  /--
  info: [3, 3, 3]
  -/
  #guard_msgs in
  #eval solve_max_subarray_query 3 [1, 2, 3] [1, 2, 3]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

