vc-description: |-
  You need to play around with the provided string (s).
  
  Move consonants forward 9 places through the alphabet.
  If they pass 'z', start again at 'a'.
  
  Move vowels back 5 places through the alphabet.
  If they pass 'a', start again at 'z'.
  For our Polish friends this kata does not count 'y' as a vowel.
  
  Exceptions:
  
  If the character is 'c' or 'o', move it back 1 place.
  For 'd' move it back 3, and for 'e', move it back 4.
  
  If a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.
  
  Provided string will always be lower case, won't be empty and will have no special characters.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def vowel_back (s : String) : String := sorry
  
  theorem vowel_back_same_length (s : String) 
    (h : s.all (fun c => 'a' ≤ c ∧ c ≤ 'z')) 
    (h2 : s.length > 0) : 
    (vowel_back s).length = s.length := sorry

vc-theorems: |-
  theorem vowel_back_lowercase_letters (s : String)
    (h : s.all (fun c => 'a' ≤ c ∧ c ≤ 'z'))
    (h2 : s.length > 0) :
    (vowel_back s).all (fun c => 'a' ≤ c ∧ c ≤ 'z') := sorry
  
  theorem vowel_back_deterministic (s : String)
    (h : s.all (fun c => 'a' ≤ c ∧ c ≤ 'z'))
    (h2 : s.length > 0) :
    vowel_back s = vowel_back s := sorry
  
  theorem vowel_back_consistent_mapping (s : String)
    (h : s.all (fun c => 'a' ≤ c ∧ c ≤ 'z'))
    (h2 : s.length > 0) :
    ∀ i j, i < s.length → j < s.length → 
    s.data[i]? = s.data[j]? → 
    (vowel_back s).data[i]? = (vowel_back s).data[j]? := sorry
  
  /--
  info: 'tabtbvba'
  -/
  #guard_msgs in
  #eval vowel_back "testcase"
  
  /--
  info: 'bnaafvab'
  -/
  #guard_msgs in
  #eval vowel_back "codewars"
  
  /--
  info: 'agvvyuatabtqaaa'
  -/
  #guard_msgs in
  #eval vowel_back "exampletesthere"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

