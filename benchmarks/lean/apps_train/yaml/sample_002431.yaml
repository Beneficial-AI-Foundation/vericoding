vc-description: |-
  At a lemonade stand, each lemonade costs $5. 
  Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).
  Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.
  Note that you don't have any change in hand at first.
  Return true if and only if you can provide every customer with correct change.
  
  Example 1:
  Input: [5,5,5,10,20]
  Output: true
  Explanation: 
  From the first 3 customers, we collect three $5 bills in order.
  From the fourth customer, we collect a $10 bill and give back a $5.
  From the fifth customer, we give a $10 bill and a $5 bill.
  Since all customers got correct change, we output true.
  
  Example 2:
  Input: [5,5,10]
  Output: true
  
  Example 3:
  Input: [10,10]
  Output: false
  
  Example 4:
  Input: [5,5,10,10,20]
  Output: false
  Explanation: 
  From the first two customers in order, we collect two $5 bills.
  For the next two customers in order, we collect a $10 bill and give back a $5 bill.
  For the last customer, we can't give change of $15 back because we only have two $10 bills.
  Since not every customer received correct change, the answer is false.
  
  Note:
  
  0 <= bills.length <= 10000
  bills[i] will be either 5, 10, or 20.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def lemonade_change (bills : List Nat) : Bool := sorry
  
  def countChange (state : Nat × Nat) (bill : Nat) : Nat × Nat :=
    match bill with
    | 5 => (state.1 + 1, state.2)
    | 10 => (state.1 - 1, state.2 + 1)
    | _ => if state.2 ≥ 1 ∧ state.1 ≥ 1 
          then (state.1 - 1, state.2 - 1)
          else (state.1 - 3, state.2)

vc-theorems: |-
  theorem lemonade_change_success 
    {bills : List Nat} 
    (h : lemonade_change bills = true) :
    ∀ p : List Nat, List.isPrefixOf p bills →
    (let state := List.foldl countChange (0, 0) p;
     state.1 ≥ 0 ∧ state.2 ≥ 0) := sorry
  
  theorem lemonade_change_failure  
    {bills : List Nat}
    (h : lemonade_change bills = false) :
    ∃ p : List Nat, List.isPrefixOf p bills ∧
    (let state := List.foldl countChange (0, 0) p;
     state.1 < 0 ∨ state.2 < 0) := sorry
  
  theorem lemonade_change_empty :
    lemonade_change [] = true := sorry
  
  theorem lemonade_change_all_fives (n : Nat) :
    lemonade_change (List.replicate n 5) = true := sorry
  
  /--
  info: True
  -/
  #guard_msgs in
  #eval lemonade_change [5, 5, 5, 10, 20]
  
  /--
  info: True
  -/
  #guard_msgs in
  #eval lemonade_change [5, 5, 10]
  
  /--
  info: False
  -/
  #guard_msgs in
  #eval lemonade_change [5, 5, 10, 10, 20]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

