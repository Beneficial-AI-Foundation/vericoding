vc-description: |-
  /-
  You are given a non-empty string s consisting of lowercase English letters. You have to pick exactly one non-empty substring of s and shift all its letters 'z' $\rightarrow$ 'y' $\rightarrow$ 'x' $\rightarrow \ldots \rightarrow$ 'b' $\rightarrow$ 'a' $\rightarrow$ 'z'. In other words, each character is replaced with the previous character of English alphabet and 'a' is replaced with 'z'.
  
  What is the lexicographically minimum string that can be obtained from s by performing this shift exactly once?
  
  -----Input-----
  
  The only line of the input contains the string s (1 ≤ |s| ≤ 100 000) consisting of lowercase English letters.
  
  -----Output-----
  
  Print the lexicographically minimum string that can be obtained from s by shifting letters of exactly one non-empty substring.
  
  -----Examples-----
  Input
  codeforces
  
  Output
  bncdenqbdr
  
  Input
  abacaba
  
  Output
  aaacaba
  
  -----Note-----
  
  String s is lexicographically smaller than some other string t of the same length if there exists some 1 ≤ i ≤ |s|, such that s_1 = t_1, s_2 = t_2, ..., s_{i} - 1 = t_{i} - 1, and s_{i} < t_{i}.
  -/

vc-preamble: |-
  def isLower (c : Char) : Bool :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def get_min_string_after_shift (s : List Char) : List Char :=
    sorry

vc-theorems: |-
  theorem output_length_matches_input
    (s : List Char)
    (h : ∀ c ∈ s, isLower c) :
    (get_min_string_after_shift s).length = s.length :=
  sorry
  
  theorem output_has_valid_chars
    (s : List Char) 
    (h : ∀ c ∈ s, isLower c) :
    ∀ c ∈ get_min_string_after_shift s, isLower c :=
  sorry
  
  theorem output_changes_at_most_one_segment
    (s : List Char)
    (h : ∀ c ∈ s, isLower c) :
    let result := get_min_string_after_shift s
    let diff_positions := List.range s.length |>.filter (fun i => s.get! i ≠ result.get! i)
    diff_positions.length > 0 →
    (diff_positions.maximum?.getD 0) - (diff_positions.minimum?.getD 0) + 1 = diff_positions.length :=
  sorry
  
  theorem all_a_string
    (s : List Char)
    (h : ∀ c ∈ s, c = 'a')
    (h' : s.length > 0) :
    get_min_string_after_shift s = (List.replicate (s.length - 1) 'a') ++ ['z'] :=
  sorry
  
  theorem shifted_chars_decrease
    (s : List Char)
    (h : ∀ c ∈ s, isLower c) :
    let result := get_min_string_after_shift s
    let diff_positions := List.range s.length |>.filter (fun i => s.get! i ≠ result.get! i)
    ∀ i ∈ diff_positions,
      (s.get! i = 'a' → result.get! i = 'z') ∧
      (s.get! i ≠ 'a' → (result.get! i).toNat = (s.get! i).toNat - 1) :=
  sorry
  
  /-
  info: 'bncdenqbdr'
  -/
  -- #guard_msgs in
  -- #eval get_min_string_after_shift "codeforces"
  
  /-
  info: 'aaacaba'
  -/
  -- #guard_msgs in
  -- #eval get_min_string_after_shift "abacaba"
  
  /-
  info: 'z'
  -/
  -- #guard_msgs in
  -- #eval get_min_string_after_shift "a"

vc-postamble: |-
  -- Apps difficulty: competition
  -- Assurance level: unguarded

