vc-description: |-
  /-
  Given an array of integers arr and an integer target.
  You have to find two non-overlapping sub-arrays of arr each with sum equal target. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is minimum.
  Return the minimum sum of the lengths of the two required sub-arrays, or return -1 if you cannot find such two sub-arrays.
  
  Example 1:
  Input: arr = [3,2,2,4,3], target = 3
  Output: 2
  Explanation: Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.
  
  Example 2:
  Input: arr = [7,3,4,7], target = 7
  Output: 2
  Explanation: Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.
  
  Example 3:
  Input: arr = [4,3,2,6,2,3,4], target = 6
  Output: -1
  Explanation: We have only one sub-array of sum = 6.
  
  Example 4:
  Input: arr = [5,5,4,4,5], target = 3
  Output: -1
  Explanation: We cannot find a sub-array of sum = 3.
  
  Example 5:
  Input: arr = [3,1,1,1,5,1,2,1], target = 3
  Output: 3
  Explanation: Note that sub-arrays [1,2] and [2,1] cannot be an answer because they overlap.
  
  Constraints:
  
  1 <= arr.length <= 10^5
  1 <= arr[i] <= 1000
  1 <= target <= 10^8
  -/

vc-preamble: |-
  def minSumOfLengths (arr : List Int) (target : Int) : Int :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def sumOfSubarray (arr : List Int) (i j : Nat) : Int :=
    (arr.take j).drop i |>.foldl (· + ·) 0

vc-theorems: |-
  theorem edge_cases_return_negative_one (target : Int) :
    minSumOfLengths [] target = -1 ∧ 
    minSumOfLengths [1] (2 : Int) = -1 ∧
    minSumOfLengths [0] (0 : Int) = -1 :=
    sorry
  
  theorem valid_result_bounds {arr : List Int} {target : Int} 
    (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 100)
    (h2 : 1 ≤ target ∧ target ≤ 1000)
    (h3 : arr ≠ [])
    (h4 : minSumOfLengths arr target ≠ -1) :
    2 ≤ minSumOfLengths arr target ∧ minSumOfLengths arr target ≤ arr.length :=
    sorry
  
  theorem negative_result_implies_no_valid_subarrays {arr : List Int} {target : Int}
    (h1 : ∀ x ∈ arr, 0 ≤ x ∧ x ≤ 10)
    (h2 : 0 ≤ target ∧ target ≤ 20)
    (h3 : ¬∃ i j, 0 ≤ i ∧ i < j ∧ j ≤ arr.length ∧ 
         sumOfSubarray arr i j = target) : 
    minSumOfLengths arr target = -1 :=
    sorry
  
  theorem negative_one_implies_no_non_overlapping_subarrays {arr : List Int} {target : Int}
    (h1 : ∀ x ∈ arr, 1 ≤ x ∧ x ≤ 10)
    (h2 : 1 ≤ target ∧ target ≤ 20)
    (h3 : arr.length ≥ 4)
    (h4 : minSumOfLengths arr target = -1) :
    ¬∃ i j k l, 
      0 ≤ i ∧ i < j ∧ j ≤ k ∧ k < l ∧ l ≤ arr.length ∧
      sumOfSubarray arr i j = target ∧ 
      sumOfSubarray arr k l = target :=
    sorry
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval min_sum_of_lengths [3, 2, 2, 4, 3] 3
  
  /-
  info: 2
  -/
  -- #guard_msgs in
  -- #eval min_sum_of_lengths [7, 3, 4, 7] 7
  
  /-
  info: -1
  -/
  -- #guard_msgs in
  -- #eval min_sum_of_lengths [4, 3, 2, 6, 2, 3, 4] 6

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

