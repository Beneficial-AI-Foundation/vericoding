vc-description: |-
  You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. 
  
  Define a pair (u,v) which consists of one element from the first array and one element from the second array.
  
  Find the k pairs (u1,v1),(u2,v2) ...(uk,vk) with the smallest sums.
  
  Example 1:
  
  Given nums1 = [1,7,11], nums2 = [2,4,6],  k = 3
  
  Return: [1,2],[1,4],[1,6]
  
  The first 3 pairs are returned from the sequence:
  [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
  
  Example 2:
  
  Given nums1 = [1,1,2], nums2 = [1,2,3],  k = 2
  
  Return: [1,1],[1,1]
  
  The first 2 pairs are returned from the sequence:
  [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
  
  Example 3:
  
  Given nums1 = [1,2], nums2 = [3],  k = 3 
  
  Return: [1,3],[2,3]
  
  All possible pairs are returned from the sequence:
  [1,3],[2,3]
  
  Credits:Special thanks to @elmirap and @StefanPochmann for adding this problem and creating all test cases.

vc-preamble: |-
  def isSorted (l : List Int) : Bool :=
    sorry

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def k_smallest_pairs (nums1 nums2 : List Int) (k : Nat) : List (Int × Int) :=
    sorry

vc-theorems: |-
  theorem k_smallest_pairs_size (nums1 nums2 : List Int) (k : Nat)
    (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :
    let result := k_smallest_pairs nums1 nums2 k
    List.length result ≤ k ∧ List.length result ≤ List.length nums1 * List.length nums2 :=
  sorry
  
  theorem k_smallest_pairs_elements (nums1 nums2 : List Int) (k : Nat)
    (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :
    let result := k_smallest_pairs nums1 nums2 k
    ∀ pair ∈ result, (List.elem pair.1 nums1 ∧ List.elem pair.2 nums2) :=
  sorry
  
  theorem k_smallest_pairs_ordered (nums1 nums2 : List Int) (k : Nat)
    (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :
    let result := k_smallest_pairs nums1 nums2 k
    ∀ i, i + 1 < result.length →
      (result.get! i).1 + (result.get! i).2 ≤ (result.get! (i+1)).1 + (result.get! (i+1)).2 :=
  sorry
  
  theorem k_smallest_pairs_min_sum (nums1 nums2 : List Int) (k : Nat)
    (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :
    let result := k_smallest_pairs nums1 nums2 k
    result ≠ [] →
      (result.get! 0).1 + (result.get! 0).2 = nums1.get! 0 + nums2.get! 0 :=
  sorry
  
  theorem k_smallest_pairs_all_combinations (nums1 nums2 : List Int)
    (h1 : isSorted nums1 = true) (h2 : isSorted nums2 = true) (h3 : nums1 ≠ []) (h4 : nums2 ≠ []) :
    let k := List.length nums1 * List.length nums2
    let result := k_smallest_pairs nums1 nums2 k
    List.length result = k ∧
    ∀ x ∈ nums1, ∀ y ∈ nums2, ∃ pair ∈ result, pair = (x, y) :=
  sorry

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

