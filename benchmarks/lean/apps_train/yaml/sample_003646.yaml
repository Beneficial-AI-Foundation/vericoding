vc-description: |-
  ## **Task**
  
  You are given a positive integer (`n`), and your task is to find the largest number **less than** `n`, which can be written in the form `a**b`, where `a` can be any non-negative integer and `b` is an integer greater than or equal to `2`. Try not to make the code time out :)
  
  The input range is from `1` to `1,000,000`.
  
  ## **Return**
  
  Return your answer in the form `(x, y)` or (`[x, y]`, depending on the language ), where `x` is the value of `a**b`, and `y` is the number of occurrences of `a**b`. By the way ** means ^ or power, so 2 ** 4 = 16.
  If you are given a number less than or equal to `4`, that is not `1`, return `(1, -1)`, because there is an infinite number of values for it: `1**2, 1**3, 1**4, ...`.  
  If you are given `1`, return `(0, -1)`.
  
  ## **Examples**
  
  ```
   3  -->  (1, -1)  # because it's less than 4
   6  -->  (4, 1)   # because the largest such number below 6 is 4,
                    # and there is only one way to write it: 2**2
  65  -->  (64, 3)  # because there are three occurrences of 64: 2**6, 4**3, 8**2
  90  -->  (81, 2)  # because the largest such number below 90 is 81,
                    # and there are two ways of getting it: 3**4, 9**2
  ```
  By the way, after finishing this kata, please try some of my other katas: [here.](https://www.codewars.com/collections/tonylicodings-authored-katas)

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def largest_power (n: Nat) : Nat × Int := sorry
  
  theorem largest_power_output_format (n: Nat) (h: n ≥ 1) :
    let result := largest_power n
    Nat.zero ≤ result.1 ∧ result.1 < n := sorry

vc-theorems: |-
  theorem largest_power_special_cases :
    largest_power 1 = (0, -1) ∧ 
    largest_power 2 = (1, -1) ∧
    largest_power 3 = (1, -1) ∧ 
    largest_power 4 = (1, -1) := sorry
  
  theorem largest_power_bounds (n: Nat) (h: n ≥ 5) :
    let result := largest_power n
    0 < result.1 ∧ result.1 < n ∧ 
    (result.2 > 0 ∨ result.2 = -1) := sorry
  
  theorem largest_power_is_maximal (n: Nat) (h: n ≥ 5) :
    let result := largest_power n
    ∀ base exp : Nat, base ≥ 2 → exp ≥ 2 →
    base ^ exp < n → base ^ exp ≤ result.1 := sorry
  
  /--
  info: (81, 2)
  -/
  #guard_msgs in
  #eval largest_power 90
  
  /--
  info: (64, 3)
  -/
  #guard_msgs in
  #eval largest_power 65
  
  /--
  info: (0, -1)
  -/
  #guard_msgs in
  #eval largest_power 1

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible

