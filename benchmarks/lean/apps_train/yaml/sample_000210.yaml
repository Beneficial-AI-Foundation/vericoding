vc-description: |-
  Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.
  An array A is a zigzag array if either:
  
  Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > A[3] < A[4] > ...
  OR, every odd-indexed element is greater than adjacent elements, ie. A[0] < A[1] > A[2] < A[3] > A[4] < ...
  
  Return the minimum number of moves to transform the given array nums into a zigzag array.
  
  Example 1:
  Input: nums = [1,2,3]
  Output: 2
  Explanation: We can decrease 2 to 0 or 3 to 1.
  
  Example 2:
  Input: nums = [9,6,1,6,2]
  Output: 4
  
  Constraints:
  
  1 <= nums.length <= 1000
  1 <= nums[i] <= 1000

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def moves_to_make_zigzag (nums: List Nat) : Nat :=
    sorry

vc-theorems: |-
  theorem moves_nonnegative (nums: List Nat) :
    moves_to_make_zigzag nums ≥ 0 :=
  sorry
  
  theorem single_element_zero (nums: List Nat) :
    nums.length = 1 → moves_to_make_zigzag nums = 0 :=
  sorry
  
  theorem zigzag_no_moves (nums: List Nat) (h1: nums.length ≥ 2) 
    (h2: moves_to_make_zigzag nums = 0) 
    (i: Fin nums.length) (h3: 1 ≤ i.val) (h4: i.val < nums.length - 1) :
    let im1 : Fin nums.length := ⟨i.val - 1, sorry⟩
    let ip1 : Fin nums.length := ⟨i.val + 1, sorry⟩
    ((nums.get i > nums.get im1 ∧ nums.get i > nums.get ip1) ∨
     (nums.get i < nums.get im1 ∧ nums.get i < nums.get ip1)) :=
  sorry
  
  theorem symmetric_solution (nums: List Nat) :
    moves_to_make_zigzag nums = moves_to_make_zigzag nums.reverse :=
  sorry
  
  /--
  info: 2
  -/
  #guard_msgs in
  #eval moves_to_make_zigzag [1, 2, 3]
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval moves_to_make_zigzag [9, 6, 1, 6, 2]
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval moves_to_make_zigzag [1]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

