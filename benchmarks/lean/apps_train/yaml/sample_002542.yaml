vc-description: |-
  Help a fruit packer sort out the bad apples. 
  
  There are 7 varieties of apples, all packaged as pairs and stacked in a fruit box. Some of the apples are spoiled. The fruit packer will have to make sure the spoiled apples are either removed from the fruit box or replaced. Below is the breakdown:
  
  Apple varieties are represented with numbers, `1 to 7`
  
  A fruit package is represented with a 2 element array `[4,3]`
  
  A fruit package with one bad apple, or a bad package, is represented with `[2,0]` or `[0,2]`
  
  A fruit package with two bad apples, or a rotten package, is represented with `[0,0]`
  
  A fruit box is represented with:
  
  ```
  [ [ 1, 3 ],
    [ 7, 6 ],
    [ 7, 2 ],
    [ 1, 3 ],
    [ 0, 2 ],
    [ 4, 5 ],
    [ 0, 3 ],
    [ 7, 6 ] ]
  
  ```
  
  Write a program to clear the fruit box off bad apples. 
  
  The INPUT will be a fruit box represented with a 2D array: `[[1,3],[7,6],[7,2],[1,3],[0,2],[4,5],[0,3],[7,6]]`
  
  The OUTPUT should be the fruit box void of bad apples: `[[1,3],[7,6],[7,2],[1,3],[2,3],[4,5],[7,6]]`
  
  Conditions to be met:
  
  1.A bad package should have the bad apple replaced if there is another bad package with a good apple to spare. Else, the bad package should be discarded.
  
  2.The order of the packages in the fruit box should be preserved. Repackaging happens from the top of the fruit box `index = 0` to the bottom `nth index`. Also note how fruits in a package are ordered when repacking. Example shown in INPUT/OUPUT above.
  
  3.Rotten packages should be discarded. 
  
  4.There can be packages with the same variety of apples, e.g `[1,1]`, this is not a problem.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def bad_apples (apples : List (Nat × Nat)) : List (List Nat) :=
    sorry

vc-theorems: |-
  theorem bad_apples_output_structure (apples : List (Nat × Nat)) :
    let result := bad_apples apples
    -- Output is list of lists with exactly 2 elements
    ∀ sublist ∈ result, sublist.length = 2 := by
    sorry
  
  theorem bad_apples_no_zeros (apples : List (Nat × Nat)) :
    let result := bad_apples apples
    -- No zeros in output lists
    ∀ sublist ∈ result, ∀ x ∈ sublist, x ≠ 0 := by
    sorry
  
  theorem bad_apples_values_subset (apples : List (Nat × Nat)) :
    let result := bad_apples apples
    let input_values := (apples.map (fun p => [p.1, p.2])).join.filter (fun n => n ≠ 0)
    -- Output values come from input
    ∀ sublist ∈ result, ∀ x ∈ sublist, x ∈ input_values := by
    sorry
  
  theorem bad_apples_length (apples : List (Nat × Nat)) :
    let result := bad_apples apples
    -- Output no longer than input
    result.length ≤ apples.length := by
    sorry
  
  theorem bad_apples_all_zeros (apples : List (Nat × Nat)) :
    (∀ p ∈ apples, p.1 = 0 ∧ p.2 = 0) →
    -- All zero pairs give empty result  
    bad_apples apples = [] := by
    sorry
  
  theorem bad_apples_value_counts (apples : List (Nat × Nat)) (x : Nat) :
    let result := bad_apples apples
    -- Output value counts don't exceed input counts
    x ≠ 0 →
    let input_count := (apples.map (fun p => [p.1, p.2])).join.filter (fun n => n = x) |>.length
    let output_count := result.join.filter (fun n => n = x) |>.length
    output_count ≤ input_count := by
    sorry
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval bad_apples []
  
  /--
  info: expected
  -/
  #guard_msgs in
  #eval bad_apples [[1, 3], [7, 6], [7, 2], [1, 3], [0, 2], [4, 5], [0, 3], [7, 6]]
  
  /--
  info: []
  -/
  #guard_msgs in
  #eval bad_apples [[0, 0], [0, 0]]

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

