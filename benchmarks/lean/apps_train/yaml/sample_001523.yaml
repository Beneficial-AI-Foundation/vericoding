vc-description: |-
  In this problem the input will consist of a number of lines of English text consisting of the letters of the English alphabet, the punctuation marks ' (apostrophe), . (full stop), , (comma), ; (semicolon), :(colon) and white space characters (blank, newline).
  Your task is print the words in the text in lexicographic order (that is, dictionary order). Each word should appear exactly once in your list. You can ignore the case (for instance, "The" and "the" are to be treated as the same word). There should be no uppercase letters in the output.
  For example, consider the following candidate for the input text: 
  This is a sample piece of text to illustrate this 
  problem.
  
  The corresponding output would read as:
  a
  illustrate
  is
  of
  piece
  problem
  sample
  text
  this
  to
  
  -----Input format-----
  - The first line of input contains a single integer $N$, indicating the number of lines in the input.
  - This is followed by $N$ lines of input text.
  
  -----Output format-----
  - The first line of output contains a single integer $M$ indicating the number of distinct words in the given text. 
  - The next $M$ lines list out these words in lexicographic order.
  
  -----Constraints-----
  - $1 \leq N \leq 10000$
  - There are at most 80 characters in each line.
  - There are at the most 1000 distinct words in the given text.
  
  -----Sample Input-----
  2
  This is a sample piece of text to illustrate this 
  problem. 
  
  -----Sample Output-----
  10
  a
  illustrate
  is
  of
  piece
  problem
  sample
  text
  this
  to

vc-preamble: |-
  def process_text (lines : List String) : List String :=
    sorry
  
  inductive List.LocalSorted : List String → Prop where
    | nil : List.LocalSorted []
    | single (x : String) : List.LocalSorted [x]
    | cons (x y : String) (rest : List String) 
      (h₁ : x ≤ y) (h₂ : List.LocalSorted (y::rest)) : 
      List.LocalSorted (x::y::rest)
  
  inductive List.LocalNodup : List α → Prop where
    | nil : List.LocalNodup []
    | cons (x : α) (xs : List α) 
      (h₁ : x ∉ xs) (h₂ : List.LocalNodup xs) : 
      List.LocalNodup (x::xs)

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def words (s : String) : List String :=
    sorry

vc-theorems: |-
  theorem process_text_output_properties {lines : List String} :
    let result := process_text lines
    -- First element is length of remaining list
    (result.head! = toString (result.tail.length)) ∧ 
    -- Result is sorted
    result.tail.LocalSorted ∧
    -- All elements are lowercase
    (∀ x ∈ result.tail, x = x.toLower) ∧
    -- No duplicates
    result.tail.LocalNodup :=
    sorry
  
  theorem process_text_empty_strings {lines : List String} :
    (∀ x ∈ lines, x = "") → 
    process_text lines = ["0"] :=
    sorry
  
  theorem process_text_case_insensitive_count {lines : List String} 
    (h₁ : ∀ x ∈ lines, x.length > 0)
    (h₂ : ∀ x ∈ lines, ∀ c ∈ x.toList, c.isAlpha ∨ c = ' ') :
    let lines_with_upper := lines ++ (lines.map String.toUpper)
    let result := process_text lines_with_upper
    let original_words := (lines.bind (λ s => words s)).map String.toLower |>.eraseDups
    result.tail.length = original_words.length :=
    sorry
  
  /--
  info: ['0']
  -/
  #guard_msgs in
  #eval process_text [""]
  
  /--
  info: ['1', 'the']
  -/
  #guard_msgs in
  #eval process_text ["The THE the", "THE"]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

