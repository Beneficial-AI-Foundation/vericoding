vc-description: |-
  You are given two positive integers ```a``` and ```b```.

  You can perform the following operations on ```a``` so as to obtain ```b``` :
  ```
  (a-1)/2   (if (a-1) is divisible by 2)
  a/2       (if a is divisible by 2)
  a*2
  ```
  ```b``` will always be a power of 2.

  You are to write a function ```operation(a,b)``` that efficiently returns the minimum number of operations required to transform ```a``` into ```b```.

  For example :
  ```
  operation(2,8) -> 2
  2*2 = 4
  4*2 = 8

  operation(9,2) -> 2
  (9-1)/2 = 4
  4/2 = 2

  operation(1024,1024) -> 0
  ```
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |-
  def operation (a b : Nat) : Nat := sorry

  def isPowerOf2 (n : Nat) : Bool := sorry

  -- Operations are symmetric between powers of 2
vc-theorems: |
  theorem operation_symmetry (a b : Nat) :
    a ≠ 0 → b ≠ 0 → isPowerOf2 a → isPowerOf2 b → 
    operation a b = operation b a := sorry

  -- Number of operations is non-negative

  theorem operation_positive (n target : Nat) : 
    n ≠ 0 → operation n target ≥ 0 := sorry

  -- Triangle inequality through power of 2

  theorem operation_triangle_inequality (a b power2 : Nat) :
    a ≠ 0 → b ≠ 0 → isPowerOf2 power2 →
    operation a b ≤ operation a power2 + operation power2 b := sorry

  -- Self operation vs through power of 2

  theorem operation_with_self (n pow2 : Nat) :
    n ≠ 0 → isPowerOf2 pow2 →
    operation n n ≤ 2 * operation n pow2 := sorry

  /--
  info: 0
  -/
  #guard_msgs in
  #eval operation 1 1

  /--
  info: 1
  -/
  #guard_msgs in
  #eval operation 2 4

  /--
  info: 4
  -/
  #guard_msgs in
  #eval operation 3 8

  /--
  info: 2
  -/
  #guard_msgs in
  #eval operation 4 16

  /--
  info: 2
  -/
  #guard_msgs in
  #eval operation 4 1

  /--
  info: 2
  -/
  #guard_msgs in
  #eval operation 1 4
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded
