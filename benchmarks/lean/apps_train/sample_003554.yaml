vc-description: |-
  Integral numbers can be even or odd.

  Even numbers satisfy `n = 2m` ( with `m` also integral ) and we will ( completely arbitrarily ) think of odd numbers as `n = 2m + 1`.  
  Now, some odd numbers can be more odd than others: when for some `n`, `m` is more odd than for another's. Recursively. :]  
  Even numbers are just not odd.

  # Task

  Given a finite list of integral ( not necessarily non-negative ) numbers, determine the number that is _odder than the rest_.  
  If there is no single such number, no number is odder than the rest; return `Nothing`, `null` or a similar empty value.

  # Examples

  ```python
  oddest([1,2]) => 1
  oddest([1,3]) => 3
  oddest([1,5]) => None
  ```

  # Hint

  Do you _really_ want one? Point or tap here.
vc-preamble: |
  import Imports.AllImports

  def get_oddity (n : Int) : Int :=
    sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def oddest (nums : List Int) : Option Int :=
    sorry
vc-theorems: |
  theorem oddest_empty (nums : List Int) :
    nums = [] → oddest nums = none :=
    sorry


  theorem oddest_in_list {nums : List Int} {result : Int} :
    oddest nums = some result → result ∈ nums :=
    sorry


  theorem oddest_null_tie_or_even {nums : List Int} :
    nums ≠ [] →
    oddest nums = none →
    let oddities := nums.map get_oddity
    let max_odd := oddities.maximum?
    match max_odd with
    | none => True 
    | some m => 
      (oddities.filter (·= m)).length > 1 ∨ m = 0 :=
    sorry


  theorem oddest_output_type (nums : List Int) :
    oddest nums = none ∨ (∃ x, oddest nums = some x) :=
    sorry

  /--
  info: 1
  -/
  #guard_msgs in
  #eval oddest [1, 2]

  /--
  info: 3
  -/
  #guard_msgs in
  #eval oddest [1, 3]

  /--
  info: 7
  -/
  #guard_msgs in
  #eval oddest [1, 3, 5, 7]
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
