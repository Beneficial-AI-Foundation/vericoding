vc-description: |-
  Chef has a sequence of positive integers $A_1, A_2, \ldots, A_N$. He wants to split this sequence into two non-empty (not necessarily contiguous) subsequences $B$ and $C$ such that $\mathrm{GCD}\,(B) + \mathrm{GCD}\,(C)$ is maximum possible. Help him find this maximum value.
  Note: The greatest common divisor (GCD) of a sequence of positive integers is the largest positive integer that divides each element of this sequence. For example, the GCD of the sequence $(8, 12)$ is $4$.
  
  -----Input-----
  - The first line of the input contains a single integer $T$ denoting the number of test cases. The description of $T$ test cases follows.
  - The first line of each test case contains a single integer $N$.
  - The second line contains $N$ space-separated integers $A_1, A_2, \ldots, A_N$.
  
  -----Output-----
  For each test case, print a single line containing one integer — the maximum value of $\mathrm{GCD}\,(B) + \mathrm{GCD}\,(C)$.
  
  -----Constraints-----
  - $1 \le T \le 10$
  - $2 \le N \le 10^5$
  - $1 \le A_i \le 10^9$ for each valid $i$
  
  -----Subtasks-----
  Subtask #1 (20 points): $2 \le N \le 20$
  Subtask #2 (80 points): original constraints
  
  -----Example Input-----
  1              
  4                    
  4 4 7 6                    
  
  -----Example Output-----
  9
  
  -----Explanation-----
  Example case 1: For example, the sequence $A$ can be divided into subsequences $B = (4, 4, 6)$ and $C = (7)$.

vc-preamble: |-
  def gcd : Nat → Nat → Nat
  | a, b => sorry
  
  def max_gcd_sum : List Nat → Nat
  | xs => sorry
  
  def list_max : List Nat → Nat  
  | [] => 0
  | (x::xs) => max x (list_max xs)

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def list_min : List Nat → Nat
  | [] => 0  
  | (x::xs) => min x (list_min xs)

vc-theorems: |-
  theorem matches_reference (nums : List Nat) (h : ∀ x ∈ nums, x > 0) : 
    ∃ result, max_gcd_sum nums = result := by
    sorry
  
  theorem output_larger_than_input (nums : List Nat) (h : ∀ x ∈ nums, x > 0) :
    max_gcd_sum nums ≥ list_max nums ∧ max_gcd_sum nums ≥ list_min nums := by
    sorry
  
  theorem duplicate_handling (nums : List Nat) (dupes : List Nat) 
    (h : ∀ x ∈ nums, x > 0) (h2 : ∀ x ∈ dupes, x ∈ nums) :
    max_gcd_sum nums = max_gcd_sum (nums ++ dupes) := by
    sorry
  
  theorem single_element (x : Nat) (h : x > 0) :
    max_gcd_sum [x] = 2 * x := by
    sorry
  
  /--
  info: 9
  -/
  #guard_msgs in
  #eval max_gcd_sum [4, 4, 7, 6]
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval max_gcd_sum [2, 2, 2]
  
  /--
  info: 15
  -/
  #guard_msgs in
  #eval max_gcd_sum [3, 6, 9, 12]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

