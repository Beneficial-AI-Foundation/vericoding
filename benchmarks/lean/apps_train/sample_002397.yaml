vc-description: |-
  Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 

  Note:
  n is positive and will fit within the range of a 32-bit signed integer (n < 231).


  Example 1:

  Input:
  3

  Output:
  3



  Example 2:

  Input:
  11

  Output:
  0

  Explanation:
  The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def find_nth_digit (n : Nat) : Nat := sorry

  theorem find_nth_digit_in_range (n : Nat) (h : n > 0) :
    let result := find_nth_digit n
    0 ≤ result ∧ result ≤ 9 := sorry
vc-theorems: |
  theorem first_nine_digits_identity (n : Nat) (h1 : n > 0) (h2 : n ≤ 9) :
    find_nth_digit n = n := sorry


  theorem digit_boundaries_valid_10 (offset : Nat) (h : offset ≤ 9) :
    let n := 10 + offset
    let result := find_nth_digit n
    0 ≤ result ∧ result ≤ 9 := sorry


  theorem digit_boundaries_valid_100 (offset : Nat) (h : offset ≤ 9) : 
    let n := 100 + offset
    let result := find_nth_digit n
    0 ≤ result ∧ result ≤ 9 := sorry


  theorem digit_boundaries_valid_1000 (offset : Nat) (h : offset ≤ 9) :
    let n := 1000 + offset
    let result := find_nth_digit n
    0 ≤ result ∧ result ≤ 9 := sorry


  theorem find_nth_digit_deterministic (n : Nat) (h : n > 0) :
    find_nth_digit n = find_nth_digit n := sorry

  /--
  info: 3
  -/
  #guard_msgs in
  #eval find_nth_digit 3

  /--
  info: 0
  -/
  #guard_msgs in
  #eval find_nth_digit 11

  /--
  info: 3
  -/
  #guard_msgs in
  #eval find_nth_digit 1000
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible
