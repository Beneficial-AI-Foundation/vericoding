vc-description: |-
  Given a palindromic string palindrome, replace exactly one character by any lowercase English letter so that the string becomes the lexicographically smallest possible string that isn't a palindrome.
  After doing so, return the final string.  If there is no way to do so, return the empty string.
   
  Example 1:
  Input: palindrome = "abccba"
  Output: "aaccba"

  Example 2:
  Input: palindrome = "a"
  Output: ""

   
  Constraints:

  1 <= palindrome.length <= 1000
  palindrome consists of only lowercase English letters.
vc-preamble: |
  import Imports.AllImports

  def break_palindrome (s : String) : String := sorry 

  def is_palindrome (s : String) : Bool := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def strRepeat (c : Char) (n : Nat) : String := sorry

  theorem single_char_palindrome (n : Nat) (h : n = 1) :
    break_palindrome (strRepeat 'a' n) = "" := sorry
vc-theorems: |
  theorem all_a_string_breaks_to_b (s : String) (h₁ : s.length ≥ 2) (h₂ : ∀ c ∈ s.data, c = 'a') :
    break_palindrome s = (s.dropRight 1).push 'b' := sorry


  theorem break_gives_different_string (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :
    break_palindrome s ≠ s := sorry


  theorem break_gives_non_palindrome (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :
    is_palindrome (break_palindrome s) = false := sorry


  theorem break_preserves_length (s : String) (h₁ : s.length ≥ 2) (h₂ : is_palindrome s = true) :
    (break_palindrome s).length = s.length := sorry

  /--
  info: 'aaccba'
  -/
  #guard_msgs in
  #eval break_palindrome "abccba"

  /--
  info: ''
  -/
  #guard_msgs in
  #eval break_palindrome "a"

  /--
  info: 'ab'
  -/
  #guard_msgs in
  #eval break_palindrome "aa"
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
