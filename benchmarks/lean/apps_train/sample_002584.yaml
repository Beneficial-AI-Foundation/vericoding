vc-description: |-
  Given an array of integers, return the smallest common factors of all integers in the array.

  When i say **Smallest Common Factor** i mean the smallest number above 1 that can divide all numbers in the array without a remainder.

  If there are no common factors above 1, return 1 (technically 1 is always a common factor).
vc-preamble: |
  import Imports.AllImports

  def scf (nums : List Nat) : Nat :=
    sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def listMin (xs : List Nat) : Nat :=
    match xs with
    | [] => 0
    | h::t => t.foldl min h

  partial def minFactor (n : Nat) : Nat :=
    if n ≤ 1 then 1 else
    let rec find (k : Nat) : Nat :=
      if k * k > n then n
      else if n % k = 0 then k
      else find (k + 1)
    find 2
vc-theorems: |
  theorem scf_basic_properties (nums : List Nat) :
    let result := scf nums
    (nums ≠ [] → 1 ≤ result ∧ result ≤ listMin nums) ∧
    (nums = [] → result = 1) ∧
    (∀ n ∈ nums, n % result = 0) ∧
    (result > 1 → ¬ ∃ k, 2 ≤ k ∧ k < result ∧ ∀ n ∈ nums, n % k = 0) :=
    sorry


  theorem scf_identical_numbers (n : Nat) (h : n ≥ 2) :
    let nums := List.replicate 5 n
    scf nums = minFactor n :=
    sorry


  theorem scf_nonpositive_inputs (nums : List Nat) (h : ∀ n ∈ nums, n = 0) :
    scf nums = 1 :=
    sorry

  /--
  info: 2
  -/
  #guard_msgs in
  #eval scf [200, 30, 18, 8, 64, 34]

  /--
  info: 3
  -/
  #guard_msgs in
  #eval scf [21, 45, 51, 27, 33]

  /--
  info: 1
  -/
  #guard_msgs in
  #eval scf []
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
