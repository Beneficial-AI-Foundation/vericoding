vc-description: |-
  Given a number s in their binary representation. Return the number of steps to reduce it to 1 under the following rules:


  If the current number is even, you have to divide it by 2.


  If the current number is odd, you have to add 1 to it.


  It's guaranteed that you can always reach to one for all testcases.
   
  Example 1:
  Input: s = "1101"
  Output: 6
  Explanation: "1101" corressponds to number 13 in their decimal representation.
  Step 1) 13 is odd, add 1 and obtain 14. 
  Step 2) 14 is even, divide by 2 and obtain 7.
  Step 3) 7 is odd, add 1 and obtain 8.
  Step 4) 8 is even, divide by 2 and obtain 4.  
  Step 5) 4 is even, divide by 2 and obtain 2. 
  Step 6) 2 is even, divide by 2 and obtain 1.  

  Example 2:
  Input: s = "10"
  Output: 1
  Explanation: "10" corressponds to number 2 in their decimal representation.
  Step 1) 2 is even, divide by 2 and obtain 1.  

  Example 3:
  Input: s = "1"
  Output: 0

   
  Constraints:

  1 <= s.length <= 500
  s consists of characters '0' or '1'
  s[0] == '1'
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def num_steps (s : String) : Nat := sorry

  theorem num_steps_non_negative (s : String) (h : s.startsWith "1") : 
    num_steps s ≥ 0 := sorry
vc-theorems: |
  theorem single_one_zero_steps : 
    num_steps "1" = 0 := sorry


  theorem min_steps_lower_bound (s : String) (h : s.startsWith "1") :
    num_steps s ≥ s.length - 1 := sorry


  theorem ten_pattern_steps :
    num_steps "10" = 1 := sorry


  theorem alternating_pattern_bound (n : Nat) (h : n ≥ 2) :
    let s := "1" ++ String.mk (List.join (List.replicate n ['0', '1']));
    num_steps s ≥ s.length := sorry

  /--
  info: 6
  -/
  #guard_msgs in
  #eval num_steps "1101"

  /--
  info: 1
  -/
  #guard_msgs in
  #eval num_steps "10"

  /--
  info: 0
  -/
  #guard_msgs in
  #eval num_steps "1"
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded_and_plausible
