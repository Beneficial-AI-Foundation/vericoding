vc-description: |-
  I'm sure you're familiar with factorials – that is, the product of an integer and all the integers below it. 

  For example, `5! = 120`, as `5 * 4 * 3 * 2 * 1 = 120`

  Your challenge is to create a function that takes any number and returns the number that it is a factorial of. So, if your function receives `120`, it should return `"5!"` (as a string).

  Of course, not every number is a factorial of another. In this case, your function would return `"None"` (as a string).

  ### Examples

  * `120` will return `"5!"`
  * `24` will return `"4!"`
  * `150` will return `"None"`
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def reverse_factorial (n : Int) : String := sorry

  theorem forward_reverse_factorial {n : Nat} (h : 1 ≤ n ∧ n ≤ 10) :
    let factorial := (List.range n).foldl (fun x y => x * (y+1)) 1
    reverse_factorial (Int.ofNat factorial) = s!"{n}!" := sorry
vc-theorems: |
  theorem nonmatching_numbers_return_none {n : Int} (h : 1 ≤ n ∧ n ≤ 10000) :
    ¬(∃ k : Nat, (List.range k).foldl (fun x y => x * (y+1)) 1 = Int.toNat n) →
    reverse_factorial n = "None" := sorry


  theorem nonpositive_returns_none {n : Int} (h : n ≤ 0) :
    reverse_factorial n = "None" := sorry


  theorem known_factorials :
    reverse_factorial 1 = "1!" ∧
    reverse_factorial 2 = "2!" ∧
    reverse_factorial 6 = "3!" := sorry

  /--
  info: '5!'
  -/
  #guard_msgs in
  #eval reverse_factorial 120

  /--
  info: '10!'
  -/
  #guard_msgs in
  #eval reverse_factorial 3628800

  /--
  info: 'None'
  -/
  #guard_msgs in
  #eval reverse_factorial 150
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
