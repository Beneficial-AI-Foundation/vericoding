vc-description: |-
  Write a function to find the longest common prefix string amongst an array of strings.

  If there is no common prefix, return an empty string "".

  Example 1:


  Input: ["flower","flow","flight"]
  Output: "fl"


  Example 2:


  Input: ["dog","racecar","car"]
  Output: ""
  Explanation: There is no common prefix among the input strings.


  Note:

  All given inputs are in lowercase letters a-z.
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def longest_common_prefix (strs : List String) : String := sorry

  def min (a b : Nat) : Nat := if a ≤ b then a else b 
vc-theorems: |
  theorem empty_list_returns_empty :
    longest_common_prefix [] = "" := sorry


  theorem single_string_returns_self (s : String) :
    longest_common_prefix [s] = s := sorry


  theorem result_is_prefix_of_all {strs : List String} (h : strs ≠ []) :
    ∀ s ∈ strs, longest_common_prefix strs = s.take (longest_common_prefix strs).length := sorry


  theorem not_longer_than_shortest {strs : List String} (h : strs ≠ []) :
    (longest_common_prefix strs).length ≤ List.foldl min (String.length (List.get! strs 0)) (strs.map String.length) := sorry


  theorem different_prefix_shortens {strs : List String} (h₁ : strs ≠ [])
    (h₂ : (longest_common_prefix strs).length > 0) (different_prefix : String) :
    (longest_common_prefix (strs ++ ["x" ++ different_prefix])).length < (longest_common_prefix strs).length := sorry


  theorem substring_of_first {strs : List String} (h : strs ≠ []) :
    longest_common_prefix strs = (List.get! strs 0).take (longest_common_prefix strs).length := sorry

  /--
  info: 'fl'
  -/
  #guard_msgs in
  #eval longest_common_prefix ["flower", "flow", "flight"]

  /--
  info: ''
  -/
  #guard_msgs in
  #eval longest_common_prefix ["dog", "racecar", "car"]

  /--
  info: 'inters'
  -/
  #guard_msgs in
  #eval longest_common_prefix ["interspecies", "interstellar", "interstate"]
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
