vc-description: |-
  Many years ago, Roman numbers were defined by only `4` digits: `I, V, X, L`, which represented `1, 5, 10, 50`. These were the only digits used. The value of a sequence was simply the sum of digits in it. For instance:
  ```
  IV = VI = 6
  IX = XI = 11
  XXL = LXX = XLX = 70
  ```
  It is easy to see that this system is ambiguous, and some numbers could be written in many different ways. Your goal is to determine how many distinct integers could be represented by exactly `n` Roman digits grouped together. For instance:
  ```Perl
  solve(1) = 4, because groups of 1 are [I, V, X, L]. 
  solve(2) = 10, because the groups of 2 are [II, VI, VV, XI, XV, XX, IL, VL, XL, LL] corresponding to [2,6,10,11,15,20,51,55,60,100]. 
  solve(3) = 20, because groups of 3 start with [III, IIV, IVV, ...etc]
  ```

  `n <= 10E7`

  More examples in test cases. Good luck!
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def solve (n : Nat) : Nat := sorry 

  theorem solve_non_negative (n : Nat) :
    solve n ≥ 0 := sorry
vc-theorems: |
  theorem solve_linear_pattern (n : Nat) :
    n ≥ 12 → solve n = 292 + 49 * (n - 11) := sorry


  theorem solve_initial_sequence (n : Nat) :
    n < 12 → solve n = match n with
      | 0 => 0
      | 1 => 4  
      | 2 => 10
      | 3 => 20
      | 4 => 35
      | 5 => 56
      | 6 => 83
      | 7 => 116
      | 8 => 155
      | 9 => 198
      | 10 => 244
      | 11 => 292
      | _ => 0 := sorry


  theorem solve_strictly_increasing {n : Nat} :
    n > 0 → solve n > solve (n-1) := sorry

  /--
  info: 4
  -/
  #guard_msgs in
  #eval solve 1

  /--
  info: 83
  -/
  #guard_msgs in
  #eval solve 6

  /--
  info: 489999753
  -/
  #guard_msgs in
  #eval solve 10000000
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: guarded_and_plausible
