vc-description: |-
  Once N boys and M girls attended a party. You are given a matrix A of N rows and M columns where Aij is 1 if the i-th boy likes the j-th girl, otherwise it will be 0. Note that it is not necessary that if a boy x likes girl y, then girl y should like boy x.
  You know that if there are two different boys x and y, who both like girl z, then there will be a collision.
  Can you calculate the number of different collisions at this party? Note that order of boys in the collision doesn't matter.
  
  -----Input-----
  The first line contains a single integer T denoting the number of test cases. Then T test cases follow.
  The first line of each test case contains two space separated integers N, M denoting the number of boys and girls, respectively.
  Each of the following N lines contain M characters, each of them is either '0' or '1'.
  
  -----Output-----
  For each test case output a single line containing an integer corresponding to the number of collisions at the party.
  
  -----Constraints-----
  - 1 ≤ T ≤ 100
  - 1 ≤ N, M ≤ 10
  
  -----Example-----
  Input:
  2
  4 3
  111
  100
  110
  000
  2 2
  10
  01
  
  Output:
  4
  0
  
  -----Explanation-----
  Example Case 1. All three boys like the first girl, so there are (1, 2, 1), (1, 3, 1), (2, 3, 1) collisions with her. Boys 1 and 3 both like the second girl so this is one more collision. Only one boy likes the third girl, so there are no collisions with her and thus we have 4 collisions total.
  Example Case 2. For each girl there is only one boy who likes her, so there are no collisions at all.

vc-preamble: |-
  def count_collisions (n m : Nat) (likes : List String) : Nat :=
    sorry
  
  def List.sum (xs : List Nat) : Nat :=
    xs.foldl (· + ·) 0
  
  /-- Helper function to get character from string at position -/

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def getChar? (s : String) (i : Nat) : Option Char :=
    s.data.get? i

vc-theorems: |-
  theorem count_collisions_nonnegative {n m : Nat} {likes : List String} :
    count_collisions n m likes ≥ 0 :=
    sorry 
  
  /-- Helper function to sum a list of natural numbers -/
  
  theorem count_collisions_formula {n m : Nat} {likes : List String} :
    count_collisions n m likes = 
      let colSums := List.range m |>.map (fun col => 
        List.range n |>.filter (fun row => 
          match likes.get? row with
          | none => false
          | some s => match getChar? s col with
            | some '1' => true
            | _ => false
        ) |>.length);
      colSums.map (fun ones => ones * (ones - 1) / 2) |>.sum :=
    sorry
  
  theorem count_collisions_zeros {n m : Nat} {likes : List String}
    (h : ∀ i j, i < n → j < m → 
      match likes.get? i with
      | none => true
      | some s => getChar? s j = some '0') :
    count_collisions n m likes = 0 :=
    sorry
  
  theorem count_collisions_all_ones {n : Nat} {likes : List String}
    (h : ∀ i, i < n → 
      match likes.get? i with
      | none => true 
      | some s => getChar? s 0 = some '1') :
    count_collisions n 1 likes = n * (n - 1) / 2 :=
    sorry
  
  /--
  info: 4
  -/
  #guard_msgs in
  #eval count_collisions 4 3 ["111", "100", "110", "000"]
  
  /--
  info: 0
  -/
  #guard_msgs in
  #eval count_collisions 2 2 ["10", "01"]
  
  /--
  info: 6
  -/
  #guard_msgs in
  #eval count_collisions 3 2 ["11", "11", "11"]

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded

