vc-description: |-
  Given the root of a binary tree, the depth of each node is the shortest distance to the root.
  Return the smallest subtree such that it contains all the deepest nodes in the original tree.
  A node is called the deepest if it has the largest depth possible among any node in the entire tree.
  The subtree of a node is tree consisting of that node, plus the set of all descendants of that node.
   
  Example 1:

  Input: root = [3,5,1,6,2,0,8,null,null,7,4]
  Output: [2,7,4]
  Explanation: We return the node with value 2, colored in yellow in the diagram.
  The nodes coloured in blue are the deepest nodes of the tree.
  Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.

  Example 2:
  Input: root = [1]
  Output: [1]
  Explanation: The root is the deepest node in the tree.

  Example 3:
  Input: root = [0,1,3,null,2]
  Output: [2]
  Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.

   
  Constraints:

  The number of nodes in the tree will be in the range [1, 500].
  The values of the nodes in the tree are unique.
vc-preamble: |
  import Imports.AllImports

  def maxDepth {α : Type} : Tree α → Nat
    | Tree.leaf => 0
    | Tree.node _ l r => max (maxDepth l) (maxDepth r) + 1


  def getDeepestNodes {α : Type} : Tree α → Nat → List (Tree α)
    | _, _ => sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def subtreeWithAllDeepest {α : Type} : Tree α → Tree α
    | t => sorry
vc-theorems: |-
  theorem result_non_none {α : Type} (t : Tree α) :
    subtreeWithAllDeepest t ≠ Tree.leaf := sorry


  theorem deepest_nodes_preserved {α : Type} (t : Tree α) : 
    let result := subtreeWithAllDeepest t
    let maxDepthTree := maxDepth t
    let maxDepthResult := maxDepth result
    let deepestNodesTree := getDeepestNodes t maxDepthTree
    let deepestNodesResult := getDeepestNodes result maxDepthResult
    deepestNodesTree = deepestNodesResult := sorry


  theorem smallest_possible_subtree {α : Type} (t : Tree α) :
    let result := subtreeWithAllDeepest t
    match result with
    | Tree.leaf => True
    | Tree.node _ l r => 
      let leftDepth := maxDepth l
      let rightDepth := maxDepth r
      leftDepth = rightDepth ∨ (leftDepth ≤ rightDepth + 1 ∧ rightDepth ≤ leftDepth + 1) := sorry


  theorem single_node_case {α : Type} (x : α) :
    subtreeWithAllDeepest (Tree.node x Tree.leaf Tree.leaf) = Tree.node x Tree.leaf Tree.leaf := sorry
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: guarded
