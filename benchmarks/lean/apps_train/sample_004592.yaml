vc-description: |-
  John and his wife Ann have decided to go to Codewars. 

  On first day Ann will do one kata and John - he wants to know how it is working - 0 kata.

  Let us call `a(n)` - and `j(n)` - the number of katas done by Ann - and John - at day `n`. We have `a(0) = 1` and in the same manner `j(0) = 0`.

  They have chosen the following rules:

  - On day `n` the number of katas done by Ann should be `n` minus the number of katas done by John at day `t`, `t` being equal to the number of katas done
  by Ann herself at day `n - 1`.

  - On day `n` the number of katas done by John should be `n` minus the number of katas done by Ann at day `t`, `t` being equal to the number of katas done
  by John himself at day `n - 1`.

  Whoops! I think they need to lay out a little clearer exactly what there're getting themselves into!

  # Could you write:
  - 1) two functions `ann` and `john (parameter n)` giving the list of the numbers of katas Ann and John should take on the first n days (see first examples below)? 
  - 2) The total number of katas taken by ann `function sum_ann(n)` and john `function sum_john(n)` - on the first n days? 
   

  The functions in 1) are not tested in Fortran and not tested in Shell.

  # Examples:
  ```
  john(11) -->  [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]
  ann(6) -->  [1, 1, 2, 2, 3, 3]

  sum_john(75) -->  1720
  sum_ann(150) -->  6930
  ```

  # Shell Note:
  sumJohnAndAnn has two parameters:

  first one : n (number of days, $1)

  second one : which($2) ->

  - 1 for getting John's sum

  - 2 for getting Ann's sum.

  See "Sample Tests".

  # Note: 

  Keep an eye on performance.
vc-preamble: |-
  import Imports.AllImports

  def john (n : Nat) : List Nat := sorry
  def ann (n : Nat) : List Nat := sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def sum_john (n : Nat) : Nat := sorry
  def sum_ann (n : Nat) : Nat := sorry
vc-theorems: |
  theorem sequences_start_correctly {n : Nat} (h : n > 0) : 
    (john n).get ⟨0, sorry⟩ = 0 ∧ (ann n).get ⟨0, sorry⟩ = 1 := sorry


  theorem sequence_lengths {n : Nat} (h : n > 0) :
    (john n).length = n ∧ (ann n).length = n := sorry


  theorem sequences_nonnegative {n : Nat} (h : n > 0) :
    (∀ x ∈ john n, x ≥ 0) ∧ (∀ x ∈ ann n, x ≥ 0) := sorry


  theorem sum_functions_match {n : Nat} (h : n > 0) :
    sum_john n = ((john n).foldl (· + ·) 0) ∧ 
    sum_ann n = ((ann n).foldl (· + ·) 0) := sorry


  theorem sequence_relationship {n : Nat} (h : n > 0) :
    ∀ i : Nat, i < n → i > 0 → 
      ((john n).get ⟨i, sorry⟩ = i - (ann n).get ⟨(john n).get ⟨i-1, sorry⟩, sorry⟩) ∧
      ((ann n).get ⟨i, sorry⟩ = i - (john n).get ⟨(ann n).get ⟨i-1, sorry⟩, sorry⟩) := sorry

  /--
  info: [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]
  -/
  #guard_msgs in
  #eval john 11

  /--
  info: [1, 1, 2, 2, 3, 3]
  -/
  #guard_msgs in
  #eval ann 6

  /--
  info: 1720
  -/
  #guard_msgs in
  #eval sum_john 75

  /--
  info: 6930
  -/
  #guard_msgs in
  #eval sum_ann 150
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
