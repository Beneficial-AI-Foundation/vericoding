vc-description: |-
  # Longest Palindromic Substring (Linear)

  A palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g.,
  'madam' or 'racecar'. Even the letter 'x' is considered a palindrome. 

  For this Kata, you are given a string ```s```. Write a function that returns the longest _contiguous_ palindromic substring in ```s``` (it could be the entire string). In the event that there are multiple longest palindromic substrings, return the first to occur.

  I'm not trying to trick you here:
  - You can assume that all inputs are valid strings.
  - Only the letters a-z will be used, all lowercase (your solution should, in theory, extend to more than just the letters a-z though). 

  **NOTE:** Quadratic asymptotic complexity _(O(N^2))_ or above will __NOT__ work here.

  -----

  ## Examples

  ### Basic Tests

  ```
  Input: "babad"
  Output: "bab"
  (Note: "bab" occurs before "aba")
  ```
  ```
  Input: "abababa"
  Output: "abababa"
  ```
  ```
  Input: "cbbd"
  Output: "bb"
  ```

  ### Edge Cases

  ```
  Input: "ab"
  Output: "a"
  ```
  ```
  Input: ""
  Output: ""
  ```
  -----

  ## Testing

  Along with the example tests given:

   - There are **500** tests using strings of length in range [1 - 1,000]
   - There are **50** tests using strings of length in range [1,000 - 10,000]
   - There are **5** tests using strings of length in range [10,000 - 100,000]
   
  All test cases can be passed within 10 seconds, but non-linear solutions will time out every time. _Linear performance is essential_. 

  ## Good Luck!

  -----

  This problem was inspired by [this](https://leetcode.com/problems/longest-palindromic-substring/) challenge on LeetCode. Except this is the performance version :^)
vc-preamble: |
  import Imports.AllImports

  def isPalindrome (s : String) : Bool :=
    sorry


  def isSubstring (sub str : String) : Bool :=
    sorry


  def longest_palindrome (s : String) : String :=
    sorry


  def reverseString (s : String) : String :=
    sorry
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def substring (s : String) (i j : Nat) : String :=
    sorry
vc-theorems: |
  theorem output_is_palindrome {s : String} :
    let result := longest_palindrome s
    result = "" ∨ (result = reverseString result ∧ isSubstring result s)
    := by sorry


  theorem output_is_maximum_length {s : String} :
    let result := longest_palindrome s
    ∀ (i j : Nat), i ≤ s.length → j ≤ s.length →
      let substr := substring s i j
      substr = reverseString substr →
      substr.length ≤ result.length
    := by sorry


  theorem empty_and_single_char_inputs {s : String} :
    (s = "" → longest_palindrome s = "") ∧
    (s.length = 1 → longest_palindrome s = s)
    := by sorry


  theorem palindrome_input_returns_itself {s : String} :
    s ≠ "" →
    s = reverseString s →
    longest_palindrome s = s
    := by sorry

  /--
  info: 'bab'
  -/
  #guard_msgs in
  #eval longest_palindrome "babad"

  /--
  info: 'abababa'
  -/
  #guard_msgs in
  #eval longest_palindrome "abababa"

  /--
  info: 'bb'
  -/
  #guard_msgs in
  #eval longest_palindrome "cbbd"
vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded
