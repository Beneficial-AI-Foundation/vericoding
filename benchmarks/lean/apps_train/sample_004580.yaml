vc-description: |-
  John and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns.
  `ls = [50, 55, 57, 58, 60]`.
  John is tired of driving and he says to Mary that he doesn't want to drive more than `t = 174 miles` and he
  will visit only `3` towns.

  Which distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?

  Example: 

  With list `ls` and 3 towns to visit they can make a choice between: 
  `[50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60]`.

  The sums of distances are then:
  `162, 163, 165, 165, 167, 168, 170, 172, 173, 175`.

  The biggest possible sum taking a limit of `174` into account is then `173` and the distances of the `3` 
  corresponding towns is `[55, 58, 60]`.

  The function `chooseBestSum` (or `choose_best_sum` or ... depending on the language) will take as parameters `t` (maximum sum of distances, integer >= 0), `k` (number of towns to visit, k >= 1) 
  and `ls` (list of distances, all distances are positive or null integers and this list has at least one element).
  The function returns the "best" sum ie the biggest possible sum of `k` distances less than or equal to the given limit `t`, if that sum exists,
  or otherwise nil, null, None, Nothing, depending on the language. With C++, C, Rust, Swift, Go, Kotlin return `-1`.

  Examples: 

  `ts = [50, 55, 56, 57, 58]`
  `choose_best_sum(163, 3, ts) -> 163`

  `xs = [50]`
  `choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, Rust, Swift, Go)`

  `ys = [91, 74, 73, 85, 73, 81, 87]`
  `choose_best_sum(230, 3, ys) -> 228`

  Note: don't modify the input list `ls`
vc-preamble: |
  import Imports.AllImports

  def List.combinations (ls : List α) (k : Nat) : List (List α) :=
    sorry

  abbrev List.sum (ls : List Int) : Int :=
    ls.foldl (· + ·) 0
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def choose_best_sum (t : Int) (k : Nat) (ls : List Int) : Option Int :=
    sorry
vc-theorems: |
  theorem result_not_exceeds_target 
    (t : Int) (k : Nat) (ls : List Int)
    (h1 : t ≥ 1) (h2 : k ≥ 1) (h3 : !ls.isEmpty)
    (h4 : ∀ x ∈ ls, x ≥ 1 ∧ x ≤ 100) :
    (choose_best_sum t k ls).all (· ≤ t) :=
  sorry


  theorem none_if_k_too_large
    (t : Int) (k : Nat) (ls : List Int)
    (h1 : t ≥ 1)
    (h2 : k > ls.length)
    (h3 : ∀ x ∈ ls, x ≥ 1) :
    choose_best_sum t k ls = none :=
  sorry


  theorem result_is_sum_of_k_numbers
    (t : Int) (k : Nat) (ls : List Int)
    (h1 : t ≥ 1) (h2 : k ≥ 1)
    (h3 : ls.length ≥ 5)
    (h4 : ∀ x ∈ ls, x ≥ 1 ∧ x ≤ 100)
    (h5 : (choose_best_sum t k ls).isSome) :
    ∃ subset : List Int,
      subset ∈ ls.combinations k ∧ 
      subset.sum = Option.get! (choose_best_sum t k ls) :=
  sorry


  theorem edge_cases :
    choose_best_sum 100 3 [] = none ∧
    choose_best_sum (-1) 3 [1,2,3] = none ∧ 
    choose_best_sum 100 0 [1,2,3] = none :=
  sorry

  /--
  info: 163
  -/
  #guard_msgs in
  #eval choose_best_sum 163 3 [50, 55, 56, 57, 58]

  /--
  info: None
  -/
  #guard_msgs in
  #eval choose_best_sum 163 3 [50]

  /--
  info: 228
  -/
  #guard_msgs in
  #eval choose_best_sum 230 3 [91, 74, 73, 85, 73, 81, 87]
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
