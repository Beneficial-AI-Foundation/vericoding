vc-description: |-
  Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.
  In general a rational number can be represented using up to three parts: an integer part, a non-repeating part, and a repeating part. The number will be represented in one of the following three ways:
  
  <IntegerPart> (e.g. 0, 12, 123)
  <IntegerPart><.><NonRepeatingPart>  (e.g. 0.5, 1., 2.12, 2.0001)
  <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))
  
  The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.  For example:
  1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)
  Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.
  
  Example 1:
  Input: S = "0.(52)", T = "0.5(25)"
  Output: true
  Explanation:
  Because "0.(52)" represents 0.52525252..., and "0.5(25)" represents 0.52525252525..... , the strings represent the same number.
  
  Example 2:
  Input: S = "0.1666(6)", T = "0.166(66)"
  Output: true
  
  Example 3:
  Input: S = "0.9(9)", T = "1."
  Output: true
  Explanation: 
  "0.9(9)" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]
  "1." represents the number 1, which is formed correctly: (IntegerPart) = "1" and (NonRepeatingPart) = "".
  
  Note:
  
  Each part consists only of digits.
  The <IntegerPart> will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)
  1 <= <IntegerPart>.length <= 4 
  0 <= <NonRepeatingPart>.length <= 4 
  1 <= <RepeatingPart>.length <= 4

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def is_rational_equal (s1 s2 : String) : Bool := sorry
  
  def make_rational_str (n d : Int) : String := sorry

vc-theorems: |-
  theorem equivalent_fractions
    {n1 d1 n2 d2 : Int}
    (h1 : d1 > 0)
    (h2 : d2 > 0) 
    (h3 : n1 ≥ -1000)
    (h4 : n1 ≤ 1000)
    (h5 : d1 ≤ 100)
    (h6 : n2 ≥ -1000)
    (h7 : n2 ≤ 1000)
    (h8 : d2 ≤ 100)
    (h9 : n1 / d1 = n2 / d2) :
    is_rational_equal (make_rational_str n1 d1) (make_rational_str n2 d2) = true :=
  sorry
  
  theorem repeating_nines
    (n : Nat)
    (h1 : n > 0)
    (h2 : n ≤ 9) :
    let s1 := ("0." ++ String.mk (List.replicate n '9') ++ "(9)")
    let s2 := "1."
    is_rational_equal s1 s2 = true :=
  sorry
  
  /--
  info: True
  -/
  #guard_msgs in
  #eval is_rational_equal "0.(52)" "0.5(25)"
  
  /--
  info: True
  -/
  #guard_msgs in
  #eval is_rational_equal "0.1666(6)" "0.166(66)"
  
  /--
  info: True
  -/
  #guard_msgs in
  #eval is_rational_equal "0.9(9)" "1."

vc-postamble: |-
  -- Apps difficulty: interview
  -- Assurance level: unguarded

