vc-description: |-
  You are trying to cross a river by jumping along stones. Every time you land on a stone, you hop forwards by the value of that stone. If you skip *over* a stone then its value doesn't affect you in any way. Eg:

  ```
   x--x-----x-->
  [1][2][5][1]

  ```

  Of course, crossing from the other side might give you a different answer:

  ```
   <--------x--x
     [1][2][5][1]

  ```

  Given an array of positive integers, return the total number of steps it would take to go all the way across the river (and past the end of the array) and then all the way back. All arrays will contain at least one element, and may contain up to 100 elements. 

  ### Examples

  ```
    x--x-----x-->
   [1][2][1][2]
  <----x-----x

  therefore hop_across([1,2,1,2]) = 3 + 2 = 5

     x-----x--------x------>
    [2][2][3][1][1][2][1]
  <--------x--x-----x--x

  therefore hop_across([2,2,3,1,1,2,1]) = 3 + 4 = 7

  ```
vc-preamble: |-
  import Imports.AllImports
vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>
vc-definitions: |
  def hop_across (lst : List Nat) : Nat :=
    sorry
vc-theorems: |
  theorem hop_across_min_hops {lst : List Nat} (h : lst.length > 0) :
    hop_across lst ≥ 2 := sorry


  theorem hop_across_symmetric {lst : List Nat} :
    hop_across lst = hop_across lst.reverse := sorry


  theorem hop_across_max_hops {lst : List Nat} :
    hop_across lst ≤ 2 * lst.length := sorry


  theorem hop_across_single_element {x : Nat} :
    hop_across [x] = 2 := sorry


  theorem hop_across_monotone_scaling {lst : List Nat} (h : lst.length ≥ 2) 
    (h_sorted : ∀ i j, i < j → j < lst.length → lst.get ⟨i, sorry⟩ ≤ lst.get ⟨j, sorry⟩) :
    hop_across (lst.map (· * 2)) ≤ hop_across lst := sorry

  /--
  info: 5
  -/
  #guard_msgs in
  #eval hop_across [1, 2, 1, 2]

  /--
  info: 7
  -/
  #guard_msgs in
  #eval hop_across [2, 2, 3, 1, 1, 2, 1]

  /--
  info: 2
  -/
  #guard_msgs in
  #eval hop_across [1]
vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded
