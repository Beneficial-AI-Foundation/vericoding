vc-description: |-
  ![](http://www.grindtv.com/wp-content/uploads/2015/08/drone.jpg)
  
  The other day I saw an amazing video where a guy hacked some wifi controlled lightbulbs by flying a drone past them. Brilliant.
  
  In this kata we will recreate that stunt... sort of.
  
  You will be given two strings: `lamps` and `drone`. `lamps` represents a row of lamps, currently off, each represented by `x`. When these lamps are on, they should be represented by `o`.
  
  The `drone` string represents the position of the drone `T` (any better suggestion for character??) and its flight path up until this point `=`. The drone always flies left to right, and always begins at the start of the row of lamps. Anywhere the drone has flown, including its current position, will result in the lamp at that position switching on.
  
  Return the resulting `lamps` string. See example tests for more clarity.

vc-preamble: |-

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def fly_by (lamps : String) (drone : String) : String := sorry
  
  def countChar (s : String) (c : Char) : Nat :=
    s.data.filter (· = c) |>.length

vc-theorems: |-
  theorem fly_by_length_preservation {lamps drone : String} 
    (h1 : lamps.all (· = 'x')) 
    (h2 : drone.all (fun c => c = '=' ∨ c = 'T')) :
    (fly_by lamps drone).length = lamps.length := sorry
  
  theorem fly_by_valid_chars {lamps drone : String}
    (h1 : lamps.all (· = 'x'))
    (h2 : drone.all (fun c => c = '=' ∨ c = 'T')) :
    (fly_by lamps drone).all (fun c => c = 'o' ∨ c = 'x') := sorry
  
  theorem fly_by_o_count {lamps drone : String}
    (h1 : lamps.all (· = 'x'))
    (h2 : drone.all (fun c => c = '=' ∨ c = 'T'))
    (h3 : drone.endsWith "T") :
    let result := fly_by lamps drone
    let num_os := countChar result 'o'
    num_os = min (countChar drone '=' + 1) lamps.length := sorry
  
  theorem fly_by_unchanged_suffix {lamps drone : String}
    (h1 : lamps.all (· = 'x'))
    (h2 : drone.all (fun c => c = '=' ∨ c = 'T'))
    (h3 : drone.endsWith "T") :
    let result := fly_by lamps drone
    let num_os := countChar result 'o'
    result.drop num_os = String.mk (List.replicate (lamps.length - num_os) 'x') := sorry
  
  theorem fly_by_minimal_drone {lamps : String}
    (h : lamps.all (· = 'x'))
    (h2 : lamps.length > 0) :
    let result := fly_by lamps "T"
    result.get! 0 = 'o' ∧ 
    result.drop 1 = lamps.drop 1 := sorry
  
  /--
  info: 'ooooox'
  -/
  #guard_msgs in
  #eval fly_by "xxxxxx" "====T"
  
  /--
  info: 'oooxxxxxx'
  -/
  #guard_msgs in
  #eval fly_by "xxxxxxxxx" "==T"
  
  /--
  info: 'ooooooooooxxxxx'
  -/
  #guard_msgs in
  #eval fly_by "xxxxxxxxxxxxxxx" "=========T"

vc-postamble: |-
  -- Apps difficulty: introductory
  -- Assurance level: unguarded

