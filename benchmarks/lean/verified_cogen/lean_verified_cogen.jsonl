{"id": "LJ0000", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_arg_free", "vc-description": "/- Translation of Verus function choose_odd to Lean 4 -/", "vc-preamble": "@[reducible, simp]\ndef chooseOdd_precond : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def chooseOdd (h_precond : chooseOdd_precond) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef chooseOdd_postcond (result: Int) (h_precond : chooseOdd_precond) : Prop :=\n  result % 2 = 1\n\ntheorem chooseOdd_spec_satisfied (h_precond : chooseOdd_precond) :\n    chooseOdd_postcond (chooseOdd h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0001", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_binary_search", "vc-description": "/- Binary search implementation with verification -/", "vc-preamble": "@[reducible, simp]\ndef binarySearch_precond (v : Array Nat) (k : Nat) : Prop :=\n  (∀ i j, i ≤ j → j < v.size → v[i]! ≤ v[j]!) ∧ (∃ i, i < v.size ∧ k = v[i]!)", "vc-helpers": "", "vc-definitions": "def binarySearch (v : Array Nat) (k : Nat) (h_precond : binarySearch_precond v k) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef binarySearch_postcond (v : Array Nat) (k : Nat) (result : Nat) (h_precond : binarySearch_precond v k) : Prop :=\n  result < v.size ∧ k = v[result]!\n\ntheorem binarySearch_spec_satisfied (v : Array Nat) (k : Nat) (h_precond : binarySearch_precond v k) :\n    binarySearch_postcond v k (binarySearch v k h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0002", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_brs1", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Unit :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Prop :=\n  sum[0]! ≤ N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0003", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_brs2", "vc-description": "/- Function myfun that operates on mutable arrays with specific constraints -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.2[0]! ≤ 2 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0004", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_brs3", "vc-description": "/- Function specification for myfun that operates on mutable arrays -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int × Array Int) (h_precond : myfun_precond a sum N) :=\n  result.2[0]! ≤ 3 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0005", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_brs4", "vc-description": "/- Function specification for myfun with array manipulation requirements -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Unit :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Prop :=\n  sum[0]! ≤ 4 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0006", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_brs5", "vc-description": "/- Translation of Verus function with array manipulation contracts -/", "vc-preamble": "-- Precondition definitions\n@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.size = 1 ∧ result[0]! ≤ 5 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0007", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_bubble_v1", "vc-description": "/- Sorting and reordering verification functions -/", "vc-preamble": "def test1_precond (nums : Array Nat) : Prop :=\n  True\n\n@[reducible, simp]\ndef sortedBetween (a : Array Nat) (fromIdx : Int) (toIdx : Int) : Prop :=\n  ∀ i j : Int, fromIdx ≤ i ∧ i < j ∧ j < toIdx → a[i.toNat]! ≤ a[j.toNat]!\n\n@[reducible, simp]\ndef isReorderOf (r : Array Int) (p : Array Nat) (s : Array Nat) : Prop :=\n  r.size = s.size ∧ \n  (∀ i : Int, 0 ≤ i ∧ i < r.size → 0 ≤ r[i.toNat]! ∧ r[i.toNat]! < r.size) ∧\n  (∀ i j : Int, 0 ≤ i ∧ i < j ∧ j < r.size → r[i.toNat]! ≠ r[j.toNat]!) ∧\n  (∀ i : Int, 0 ≤ i ∧ i < r.size → p[i.toNat]! = s[r[i.toNat]!.toNat]!)", "vc-helpers": "", "vc-definitions": "def test1 (nums : Array Nat) (h_precond : test1_precond nums) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef test1_postcond (nums : Array Nat) (result : Array Nat) (h_precond : test1_precond nums) : Prop :=\n  sortedBetween result 0 result.size ∧ \n  ∃ r : Array Int, isReorderOf r result nums\n\ntheorem test1_spec_satisfied (nums : Array Nat) (h_precond : test1_precond nums) :\n    test1_postcond nums (test1 nums h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0008", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_bubble_v2", "vc-description": "/- Test case for a sorting function that produces a sorted reordering of input array -/", "vc-preamble": "def sortedBetween (a : Array Nat) (from_val to_val : Int) : Prop :=\n  ∀ i j : Int, from_val ≤ i ∧ i < j ∧ j < to_val → a[i.toNat]! ≤ a[j.toNat]!\n\ndef isReorderOf (r : Array Int) (p s : Array Nat) : Prop :=\n  r.size = s.size ∧ \n  (∀ i : Int, 0 ≤ i ∧ i < r.size → 0 ≤ r[i.toNat]! ∧ r[i.toNat]! < r.size) ∧\n  (∀ i j : Int, 0 ≤ i ∧ i < j ∧ j < r.size → r[i.toNat]! ≠ r[j.toNat]!) ∧\n  (∀ i : Int, 0 ≤ i ∧ i < r.size → p[i.toNat]! = s[r[i.toNat]!.toNat]!)\n\n@[reducible, simp]\ndef test1_precond (nums : Array Nat) : Prop := True", "vc-helpers": "", "vc-definitions": "def test1 (nums : Array Nat) (h_precond : test1_precond nums) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef test1_postcond (nums : Array Nat) (old_nums : Array Nat) (h_precond : test1_precond nums) : Prop :=\n  sortedBetween nums 0 nums.size ∧ \n  ∃ r : Array Int, isReorderOf r nums old_nums\n\ntheorem test1_spec_satisfied (nums : Array Nat) (old_nums : Array Nat) (h_precond : test1_precond nums) :\n    test1_postcond (test1 nums h_precond) old_nums h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0009", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_cell_2_sum", "vc-description": "/- Function specification for myfun -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array UInt32) (N : UInt32) :=\n  a.size = N.toNat ∧ N.toNat ≤ 0x7FFF_FFFF", "vc-helpers": "", "vc-definitions": "def myfun (a : Array UInt32) (N : UInt32) (h_precond : myfun_precond a N) : UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array UInt32) (N : UInt32) (sum: UInt32) (h_precond : myfun_precond a N) :=\n  sum.toNat ≤ 2 * N.toNat\n\ntheorem myfun_spec_satisfied (a: Array UInt32) (N: UInt32) (h_precond : myfun_precond a N) :\n    myfun_postcond a N (myfun a N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0010", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_choose_odd", "vc-description": "/- Choose an odd element from a vector -/", "vc-preamble": "@[reducible, simp]\ndef chooseOdd_precond (v : Array Nat) : Prop :=\n  ∃ q : Nat, q < v.size ∧ v[q]! % 2 = 1", "vc-helpers": "", "vc-definitions": "def chooseOdd (v : Array Nat) (h_precond : chooseOdd_precond v) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef chooseOdd_postcond (v : Array Nat) (oddIndex : Nat) (h_precond : chooseOdd_precond v) : Prop :=\n  oddIndex < v.size\n\ntheorem chooseOdd_spec_satisfied (v : Array Nat) (h_precond : chooseOdd_precond v) :\n    chooseOdd_postcond v (chooseOdd v h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0011", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_conda", "vc-description": "/- Function myfun with array modification requirements -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Unit :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Prop :=\n  sum[0]! = 2 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0012", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_condg", "vc-description": "/- Function that sets all elements of an array to 0 -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result.1[k.natAbs]! = 0\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0013", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_conditional_average", "vc-description": "/- Function to compute conditional averages of two arrays based on boolean conditions -/", "vc-preamble": "@[reducible, simp]\ndef conditionalAverage_precond (vals_1 : Array UInt64) (vals_2 : Array UInt64) (conds_1 : Array Bool) (conds_2 : Array Bool) (avgs : Array UInt64) :=\n  vals_1.size = vals_2.size ∧\n  vals_1.size = conds_1.size ∧\n  vals_1.size = conds_2.size ∧\n  (∀ idx : Nat, idx < vals_1.size → conds_1[idx]! ∨ conds_2[idx]!) ∧\n  (∀ idx : Nat, idx < vals_1.size → vals_1[idx]! < 1000) ∧\n  (∀ idx : Nat, idx < vals_2.size → vals_2[idx]! < 1000)", "vc-helpers": "", "vc-definitions": "def conditionalAverage (vals_1 : Array UInt64) (vals_2 : Array UInt64) (conds_1 : Array Bool) (conds_2 : Array Bool) (avgs : Array UInt64) (h_precond : conditionalAverage_precond vals_1 vals_2 conds_1 conds_2 avgs) : Array UInt64 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef conditionalAverage_postcond (vals_1 : Array UInt64) (vals_2 : Array UInt64) (conds_1 : Array Bool) (conds_2 : Array Bool) (avgs : Array UInt64) (result : Array UInt64) (h_precond : conditionalAverage_precond vals_1 vals_2 conds_1 conds_2 avgs) :=\n  result.size = vals_1.size ∧\n  (∀ idx : Nat, idx < vals_1.size →\n    ((conds_1[idx]! ∧ conds_2[idx]!) → result[idx]! = (vals_1[idx]! + vals_2[idx]!) / 2) ∧\n    ((conds_1[idx]! ∧ ¬conds_2[idx]!) → result[idx]! = vals_1[idx]!) ∧\n    ((¬conds_1[idx]! ∧ conds_2[idx]!) → result[idx]! = vals_2[idx]!))\n\ntheorem conditionalAverage_spec_satisfied (vals_1 : Array UInt64) (vals_2 : Array UInt64) (conds_1 : Array Bool) (conds_2 : Array Bool) (avgs : Array UInt64) (h_precond : conditionalAverage_precond vals_1 vals_2 conds_1 conds_2 avgs) :\n    conditionalAverage_postcond vals_1 vals_2 conds_1 conds_2 avgs (conditionalAverage vals_1 vals_2 conds_1 conds_2 avgs h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0014", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_condm", "vc-description": "/- Function that modifies an array to satisfy certain parity conditions -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (N : Nat) : Prop :=\n  N > 0 ∧ a.size = N", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (N : Nat) (h_precond : myfun_precond a N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (N : Nat) (result: Array Int) (h_precond : myfun_precond a N) :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result[k.toNat]! % 2 = N % 2\n\ntheorem myfun_spec_satisfied (a: Array Int) (N: Nat) (h_precond : myfun_precond a N) :\n    myfun_postcond a N (myfun a N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0015", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_condn", "vc-description": "/- Function that modifies an array to ensure all elements are bounded by N -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (N : Int) (m : Int) :=\n  N > 0 ∧ a.size = N", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (N : Int) (m : Int) (h_precond : myfun_precond a N m) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (N : Int) (m : Int) (result: Array Int) (h_precond : myfun_precond a N m) :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result[k.toNat]! ≤ N\n\ntheorem myfun_spec_satisfied (a: Array Int) (N: Int) (m: Int) (h_precond : myfun_precond a N m) :\n    myfun_postcond a N m (myfun a N m h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0016", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_fib", "vc-description": "/- Fibonacci sequence implementation with postcondition verification -/", "vc-preamble": "-- Fibonacci specification function using Nat to avoid termination issues\ndef fibo : Nat → Nat\n| 0 => 0\n| 1 => 1\n| n + 2 => fibo n + fibo (n + 1)\n\n-- Helper function to check if fibonacci value fits in i32  \ndef fibo_fits_i32 (n : Nat) : Bool :=\n  fibo n < 0x8000_0000\n\n-- Precondition definitions\n@[reducible, simp]\ndef fibonacci_precond (n : Nat) :=\n  fibo_fits_i32 n ∧ n ≥ 2", "vc-helpers": "", "vc-definitions": "def fibonacci (n : Nat) (h_precond : fibonacci_precond n) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef fibonacci_postcond (n : Nat) (result: Array Int) (h_precond : fibonacci_precond n) :=\n  (∀ i : Nat, 2 ≤ i ∧ i < n → result[i]! = (fibo i : Int)) ∧ result.size = n\n\ntheorem fibonacci_spec_satisfied (n: Nat) (h_precond : fibonacci_precond n) :\n    fibonacci_postcond n (fibonacci n h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0017", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_filter", "vc-description": "/- Function that filters elements from an array x into array y, keeping only elements divisible by 3 -/", "vc-preamble": "@[reducible, simp]\ndef myfun4_precond (x : Array UInt64) (y : Array UInt64) :=\n  y.size = 0", "vc-helpers": "", "vc-definitions": "def myfun4 (x : Array UInt64) (y : Array UInt64) (h_precond : myfun4_precond (x) (y)) : Array UInt64 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun4_postcond (x : Array UInt64) (y : Array UInt64) (result: Array UInt64) (h_precond : myfun4_precond (x) (y)) :=\n  result.toList = x.toList.filter (fun k => k % 3 = 0)\n\ntheorem myfun4_spec_satisfied (x: Array UInt64) (y: Array UInt64) (h_precond : myfun4_precond (x) (y)) :\n    myfun4_postcond (x) (y) (myfun4 (x) (y) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0018", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_filter_v2", "vc-description": "/- Function that filters a vector based on modulo 3 condition -/", "vc-preamble": "@[reducible, simp]\ndef myfun4_precond (x : Array UInt64) (y : Array UInt64) : Prop :=\n  y.size = 0", "vc-helpers": "", "vc-definitions": "def myfun4 (x : Array UInt64) (y : Array UInt64) (h_precond : myfun4_precond x y) : Array UInt64 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun4_postcond (x : Array UInt64) (y_old : Array UInt64) (result : Array UInt64) (h_precond : myfun4_precond x y_old) : Prop :=\n  result.toList = x.toList.filter (fun k => k % 3 = 0)\n\ntheorem myfun4_spec_satisfied (x : Array UInt64) (y : Array UInt64) (h_precond : myfun4_precond x y) :\n    myfun4_postcond x y (myfun4 x y h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0019", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_filter_weak", "vc-description": "/- Function myfun4 that modifies array y based on array x -/", "vc-preamble": "@[reducible, simp]\ndef myfun4_precond (x : Array Nat) (y : Array Nat) : Prop :=\n  y.size = 0", "vc-helpers": "", "vc-definitions": "def myfun4 (x : Array Nat) (y : Array Nat) (h_precond : myfun4_precond x y) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun4_postcond (x : Array Nat) (y : Array Nat) (result_y : Array Nat) (h_precond : myfun4_precond x y) : Prop :=\n  ∀ k, k < result_y.size → result_y[k]! % 3 = 0 ∧ ∃ i, i < x.size ∧ x[i]! = result_y[k]!\n\ntheorem myfun4_spec_satisfied (x : Array Nat) (y : Array Nat) (h_precond : myfun4_precond x y) :\n    myfun4_postcond x y (myfun4 x y h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0020", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_findmax", "vc-description": "/- Function to find the maximum element in a non-empty array -/", "vc-preamble": "@[reducible, simp]\ndef findMax_precond (nums : Array Int) : Prop :=\n  nums.size > 0", "vc-helpers": "", "vc-definitions": "def findMax (nums : Array Int) (h_precond : findMax_precond nums) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findMax_postcond (nums : Array Int) (ret : Int) (h_precond : findMax_precond nums) : Prop :=\n  (∀ i, i < nums.size → nums[i]! ≤ ret) ∧ (∃ i, i < nums.size ∧ nums[i]! = ret)\n\ntheorem findMax_spec_satisfied (nums : Array Int) (h_precond : findMax_precond nums) :\n    findMax_postcond nums (findMax nums h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0021", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_linearsearch", "vc-description": "/- Linear search function that finds the index of a target element in an array -/", "vc-preamble": "@[reducible, simp]\ndef linearSearch_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size < 0x80000000", "vc-helpers": "", "vc-definitions": "def linearSearch (nums : Array Int) (target : Int) (h_precond : linearSearch_precond nums target) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef linearSearch_postcond (nums : Array Int) (target : Int) (ret : Int) (h_precond : linearSearch_precond nums target) : Prop :=\n  ret < nums.size ∧ \n  (ret ≥ 0 → nums[ret.natAbs]! = target) ∧\n  (ret ≥ 0 → ∀ i : Int, 0 ≤ i ∧ i < ret → nums[i.natAbs]! ≠ target) ∧\n  (ret < 0 → ∀ i : Int, 0 ≤ i ∧ i < nums.size → nums[i.natAbs]! ≠ target)\n\ntheorem linearSearch_spec_satisfied (nums : Array Int) (target : Int) (h_precond : linearSearch_precond nums target) :\n    linearSearch_postcond nums target (linearSearch nums target h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0022", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_map", "vc-description": "/- Array increment function with overflow check -/", "vc-preamble": "-- Precondition function for myfun2\n@[reducible, simp]\ndef myfun2_precond (x : Array Int) : Prop :=\n  ∀ k, 0 ≤ k ∧ k < x.size → x[k]! ≤ 0x7FFFBFFB", "vc-helpers": "", "vc-definitions": "def myfun2 (x : Array Int) (h_precond : myfun2_precond x) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun2_postcond (x_old : Array Int) (x_new : Array Int) (h_precond : myfun2_precond x_old) : Prop :=\n  x_new.size = x_old.size ∧ \n  (∀ k, 0 ≤ k ∧ k < x_new.size → x_new[k]! = x_old[k]! + 4)\n\ntheorem myfun2_spec_satisfied (x : Array Int) (h_precond : myfun2_precond x) :\n    myfun2_postcond x (myfun2 x h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0023", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_max_index", "vc-description": "/- Function to find the index of the maximum element in an array -/", "vc-preamble": "@[reducible, simp]\ndef myfun1_precond (x : Array Int) : Prop :=\n  x.size ≥ 1", "vc-helpers": "", "vc-definitions": "def myfun1 (x : Array Int) (h_precond : myfun1_precond x) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun1_postcond (x : Array Int) (max_index : Nat) (h_precond : myfun1_precond x) : Prop :=\n  (∀ k, k < x.size → x[max_index]! ≥ x[k]!) ∧ max_index < x.size\n\ntheorem myfun1_spec_satisfied (x : Array Int) (h_precond : myfun1_precond x) :\n    myfun1_postcond x (myfun1 x h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0024", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_ms1", "vc-description": "/- Function that modifies arrays according to specification -/", "vc-preamble": "-- Precondition definitions\n@[reducible, simp]\ndef myfun_precond (a : Array Nat) (sum : Array Nat) (N : Nat) : Prop :=\n  a.size = N ∧ sum.size = 1 ∧ N > 0", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Nat) (sum : Array Nat) (N : Nat) (h_precond : myfun_precond a sum N) : Array Nat × Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Nat) (sum : Array Nat) (N : Nat) (result : Array Nat × Array Nat) (h_precond : myfun_precond a sum N) : Prop :=\n  result.2[0]! = 0\n\ntheorem myfun_spec_satisfied (a : Array Nat) (sum : Array Nat) (N : Nat) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0025", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_ms2", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Nat) (sum : Array Nat) (N : Nat) :=\n  a.size = N ∧ sum.size = 1 ∧ N > 0", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Nat) (sum : Array Nat) (N : Nat) (h_precond : myfun_precond a sum N) : Array Nat × Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Nat) (sum : Array Nat) (N : Nat) (result_a : Array Nat) (result_sum : Array Nat) (h_precond : myfun_precond a sum N) :=\n  result_sum[0]! ≤ N\n\ntheorem myfun_spec_satisfied (a : Array Nat) (sum : Array Nat) (N : Nat) (h_precond : myfun_precond a sum N) :\n    let (result_a, result_sum) := myfun a sum N h_precond\n    myfun_postcond a sum N result_a result_sum h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0026", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_ms3", "vc-description": "/- Function that takes a mutable array 'a', a mutable array 'sum', and a parameter N -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result[0]! ≤ 2 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0027", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_ms4", "vc-description": "/- Myfun function specification with array manipulation constraints -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.2[0]! ≤ 3 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0028", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_ms5", "vc-description": "/- \nFunction that processes two arrays: a mutable array 'a' and a mutable array 'sum'.\nThe function should ensure that sum[0] is bounded by 4 * N.\n-/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  a.size = N.natAbs ∧ sum.size = 1 ∧ N > 0 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.size = 1 ∧ result[0]! ≤ 4 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0029", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_remove_all_greater", "vc-description": "/- Function to remove all elements greater than a given value from an array -/", "vc-preamble": "@[reducible, simp]\ndef removeAllGreater_precond (v : Array Int) (e : Int) : Prop :=\n  ∀ k1 k2, 0 ≤ k1 → k1 < k2 → k2 < v.size → v[k1]! ≠ v[k2]!", "vc-helpers": "", "vc-definitions": "def removeAllGreater (v : Array Int) (e : Int) (h_precond : removeAllGreater_precond v e) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeAllGreater_postcond (v : Array Int) (e : Int) (result : Array Int) (h_precond : removeAllGreater_precond v e) : Prop :=\n  (∀ k, 0 ≤ k → k < result.size → result[k]! ≤ e ∧ v.toList.contains result[k]!) ∧\n  (∀ k, 0 ≤ k → k < v.size → v[k]! ≤ e → result.toList.contains v[k]!)\n\ntheorem removeAllGreater_spec_satisfied (v : Array Int) (e : Int) (h_precond : removeAllGreater_precond v e) :\n    removeAllGreater_postcond v e (removeAllGreater v e h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0030", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_remove_all_greater_v2", "vc-description": "/- Function to remove all elements greater than a given value from an array -/", "vc-preamble": "@[reducible, simp]\ndef removeAllGreater_precond (v : Array Int) (e : Int) :=\n  ∀ k1 k2, 0 ≤ k1 → k1 < k2 → k2 < v.size → v[k1]! ≠ v[k2]!", "vc-helpers": "", "vc-definitions": "def removeAllGreater (v : Array Int) (e : Int) (h_precond : removeAllGreater_precond v e) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeAllGreater_postcond (v : Array Int) (e : Int) (result: Array Int) (h_precond : removeAllGreater_precond v e) :=\n  (∀ k, k < result.size → result[k]! ≤ e ∧ v.toList.contains result[k]!) ∧\n  (∀ k, k < v.size → v[k]! ≤ e → result.toList.contains v[k]!)\n\ntheorem removeAllGreater_spec_satisfied (v: Array Int) (e: Int) (h_precond : removeAllGreater_precond v e) :\n    removeAllGreater_postcond v e (removeAllGreater v e h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0031", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_res1", "vc-description": "/- Function that operates on mutable vectors with sum constraint -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = Int.natAbs N ∧ b.size = Int.natAbs N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (result : Array Int) (h_precond : myfun_precond a b sum N) : Prop :=\n  result[0]! ≤ 2 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) :\n    myfun_postcond a b sum N (myfun a b sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0032", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_res1o", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ b.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a b sum N) :=\n  result[0]! ≤ 2 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (b: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a b sum N) :\n    myfun_postcond a b sum N (myfun a b sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0033", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_res2o", "vc-description": "/- Lean 4 function specification for myfun -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (c : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ b.size = N.natAbs ∧ c.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (c : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b c sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (b : Array Int) (c : Array Int) (sum : Array Int) (N : Int) (result : Array Int) (h_precond : myfun_precond a b c sum N) :=\n  result[0]! ≤ 3 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (b : Array Int) (c : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b c sum N) :\n    myfun_postcond a b c sum N (myfun a b c sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0034", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s1if", "vc-description": "/- Function that takes a mutable vector a and sum, along with integer N,\n   with specifications about their initial and final states -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond (a) (sum) (N)) :=\n  result[0]! = N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) (myfun (a) (sum) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0035", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s1lif", "vc-description": "/- Function specification for myfun that modifies arrays -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int × Array Int) (h_precond : myfun_precond a sum N) :=\n  result.2[0]! = 2 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0036", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s2if", "vc-description": "/- Function that modifies vectors according to specified contracts -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond (a) (sum) (N)) :=\n  result[0]! = 2 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) (myfun (a) (sum) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0037", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s2lif", "vc-description": "/- Verus function myfun with array and sum manipulation -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a sum N) :=\n  result[0]! = 3 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0038", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s3if", "vc-description": "", "vc-preamble": "/- Function precondition -/\n@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.2[0]! = 3 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0039", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s3lif", "vc-description": "/- Function myfun that takes a mutable array a, a mutable sum array, and parameter N -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a sum N) :=\n  result[0]! = 4 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0040", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s4if", "vc-description": "/- Function that modifies arrays a and sum based on parameter N -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Unit :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Prop :=\n  sum[0]! = 4 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0041", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s4lif", "vc-description": "/- \n   Function that modifies an array and computes a sum based on array size\n-/", "vc-preamble": "-- Precondition definitions\n@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond (a) (sum) (N)) :=\n  result.size ≥ 1 ∧ result[0]! = 5 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) (myfun (a) (sum) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0042", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s5if", "vc-description": "/- Function that processes arrays and computes sum -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int × Array Int) (h_precond : myfun_precond a sum N) :=\n  result.2[0]! = 5 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0043", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s5lif", "vc-description": "/- Function myfun that modifies arrays a and sum according to specified constraints -/", "vc-preamble": "/- Precondition definitions -/\n@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result.2[0]! = 6 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0044", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s12if", "vc-description": "/- -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Nat) : Prop :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Nat) (result: Array Int) (h_precond : myfun_precond a sum N) :=\n  result[0]! = 2 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Nat) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0045", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s22if", "vc-description": "/- Function myfun that modifies arrays to satisfy postcondition -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Nat) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Nat) (result: Array Int) (h_precond : myfun_precond a sum N) :=\n  result[0]! = 3 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Nat) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0046", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s32if", "vc-description": "/- Function for mutating arrays -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Nat) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Nat) (result_a : Array Int) (result_sum : Array Int) (h_precond : myfun_precond a sum N) :=\n  result_sum[0]! = 4 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) :\n    let result := myfun a sum N h_precond\n    myfun_postcond a sum N result.1 result.2 h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0047", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s42if", "vc-description": "/- Function myfun modifies arrays a and sum where sum[0] becomes 5 * N -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Nat) :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond (a) (sum) (N)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Nat) (result: Array Int) (h_precond : myfun_precond (a) (sum) (N)) :=\n  result[0]! = 5 * N\n\ntheorem myfun_spec_satisfied (a: Array Int) (sum: Array Int) (N: Nat) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) (myfun (a) (sum) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0048", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_s52if", "vc-description": "/- Function myfun specification -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Nat) : Prop :=\n  N > 0 ∧ a.size = N ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Nat) (result : Array Int) (h_precond : myfun_precond a sum N) : Prop :=\n  result[0]! = 6 * N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Nat) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0049", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_simple_nested", "vc-description": "/- \nFunction: simple_nested\nThis function demonstrates nested loops and array operations with verification constraints.\n-/", "vc-preamble": "@[reducible, simp]\ndef simpleNested_precond (a : Array Int) (b : Array Int) (N : Int) :=\n  (∀ k : Int, k ≤ b[k.toNat]! ∧ b[k.toNat]! ≤ k + 1) ∧\n  a.size = N.toNat ∧\n  b.size = N.toNat ∧\n  N ≤ 0x3FFF_FFFF", "vc-helpers": "", "vc-definitions": "def simpleNested (a : Array Int) (b : Array Int) (N : Int) (h_precond : simpleNested_precond (a) (b) (N)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef simpleNested_postcond (a : Array Int) (b : Array Int) (N : Int) (sum : Int) (h_precond : simpleNested_precond (a) (b) (N)) :=\n  N ≤ sum ∧ sum ≤ 2 * N\n\ntheorem simpleNested_spec_satisfied (a : Array Int) (b : Array Int) (N : Int) (h_precond : simpleNested_precond (a) (b) (N)) :\n    simpleNested_postcond (a) (b) (N) (simpleNested (a) (b) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0050", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_sina1", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = Int.natAbs N ∧ sum.size = 1", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result : Array Int × Array Int) (h_precond : myfun_precond (a) (sum) (N)) :=\n  ∀ k : Nat, k < Int.natAbs N → result.1[k]! = N\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond (a) (sum) (N)) :\n    myfun_postcond (a) (sum) (N) (myfun (a) (sum) (N) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0051", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_sina2", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (sum : Array Int) (N : Int) (result: Array Int × Array Int) (h_precond : myfun_precond a sum N) :=\n  ∀ k : Nat, 0 ≤ k ∧ k < N.natAbs → result.1[k]? = some (N + 1)\n\ntheorem myfun_spec_satisfied (a : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a sum N) :\n    myfun_postcond a sum N (myfun a sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0052", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_sina3", "vc-description": "/- Function that modifies array elements -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ b.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (result: Array Int) (h_precond : myfun_precond a b sum N) :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result[k.natAbs]! = N + 1\n\ntheorem myfun_spec_satisfied (a: Array Int) (b: Array Int) (sum: Array Int) (N: Int) (h_precond : myfun_precond a b sum N) :\n    myfun_postcond a b sum N (myfun a b sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0053", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_sina4", "vc-description": "/- Function that manipulates array elements -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) :=\n  N > 0 ∧ a.size = N.natAbs ∧ b.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (result : Array Int) (h_precond : myfun_precond a b sum N) :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result[k.natAbs]! = N + 2\n\ntheorem myfun_spec_satisfied (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) :\n    myfun_postcond a b sum N (myfun a b sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0054", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_sina5", "vc-description": "/- Function specification for myfun -/", "vc-preamble": "@[reducible, simp]\ndef myfun_precond (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) : Prop :=\n  N > 0 ∧ a.size = N.natAbs ∧ b.size = N.natAbs ∧ sum.size = 1 ∧ N < 1000", "vc-helpers": "", "vc-definitions": "def myfun (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) : Array Int × Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef myfun_postcond (a_old : Array Int) (b_old : Array Int) (sum_old : Array Int) (N : Int) (result : Array Int × Array Int × Array Int) (h_precond : myfun_precond a_old b_old sum_old N) : Prop :=\n  ∀ k : Int, 0 ≤ k ∧ k < N → result.1[k.natAbs]! = 2 * N + 1\n\ntheorem myfun_spec_satisfied (a : Array Int) (b : Array Int) (sum : Array Int) (N : Int) (h_precond : myfun_precond a b sum N) :\n    myfun_postcond a b sum N (myfun a b sum N h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0055", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_tail_triangle", "vc-description": "/- \nTriangle function verification problem - computing triangular numbers with tail recursion\n-/", "vc-preamble": "/- Define the triangular number function -/\ndef triangle : Nat → Nat\n  | 0 => 0\n  | n + 1 => (n + 1) + triangle n\n\n/- Precondition for tail_triangle function -/\n@[reducible, simp]\ndef tailTriangle_precond (n : Nat) (idx : Nat) (sum : Nat) : Prop :=\n  idx ≤ n ∧ sum = triangle idx ∧ triangle n < 0x100000000", "vc-helpers": "", "vc-definitions": "def tailTriangle (n : Nat) (idx : Nat) (sum : Nat) (h_precond : tailTriangle_precond n idx sum) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef tailTriangle_postcond (n : Nat) (idx : Nat) (sum : Nat) (result : Nat) (h_precond : tailTriangle_precond n idx sum) : Prop :=\n  result = triangle n\n\ntheorem tailTriangle_spec_satisfied (n : Nat) (idx : Nat) (sum : Nat) (h_precond : tailTriangle_precond n idx sum) :\n    tailTriangle_postcond n idx sum (tailTriangle n idx sum h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0056", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_2", "vc-description": "/- Function to find shared elements between two arrays -/", "vc-preamble": "@[reducible, simp]\ndef sharedElements_precond (list1 : Array Int) (list2 : Array Int) := True", "vc-helpers": "", "vc-definitions": "def sharedElements (list1 : Array Int) (list2 : Array Int) (h_precond : sharedElements_precond (list1) (list2)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sharedElements_postcond (list1 : Array Int) (list2 : Array Int) (shared: Array Int) (h_precond : sharedElements_precond (list1) (list2)) :=\n  (∀ i, i < shared.size → (list1.contains shared[i]! ∧ list2.contains shared[i]!)) ∧\n  (∀ i j, i < j → j < shared.size → shared[i]! ≠ shared[j]!)\n\ntheorem sharedElements_spec_satisfied (list1: Array Int) (list2: Array Int) (h_precond : sharedElements_precond (list1) (list2)) :\n    sharedElements_postcond (list1) (list2) (sharedElements (list1) (list2) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0057", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_3", "vc-description": "", "vc-preamble": "-- Specification function for divisibility check\ndef isDivisible (n : Int) (divisor : Int) : Bool :=\n  n % divisor = 0\n\n-- Precondition for isNonPrime\n@[reducible, simp]\ndef isNonPrime_precond (n : Nat) : Prop :=\n  n ≥ 2", "vc-helpers": "", "vc-definitions": "def isNonPrime (n : Nat) (h_precond : isNonPrime_precond n) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isNonPrime_postcond (n : Nat) (result : Bool) (h_precond : isNonPrime_precond n) : Prop :=\n  (∃ k : Int, 2 ≤ k ∧ k < n ∧ isDivisible (n : Int) k) ↔ result\n\ntheorem isNonPrime_spec_satisfied (n : Nat) (h_precond : isNonPrime_precond n) :\n    isNonPrime_postcond n (isNonPrime n h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0058", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_8", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef squareNums_precond (nums : Array Int) : Prop :=\n  ∀ k, 0 ≤ k ∧ k < nums.size → 0 ≤ nums[k]! * nums[k]! ∧ nums[k]! * nums[k]! < 2147483647", "vc-helpers": "", "vc-definitions": "def squareNums (nums : Array Int) (h_precond : squareNums_precond (nums)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef squareNums_postcond (nums : Array Int) (squared: Array Int) (h_precond : squareNums_precond (nums)) : Prop :=\n  nums.size = squared.size ∧ (∀ k, 0 ≤ k ∧ k < nums.size → squared[k]! = nums[k]! * nums[k]!)\n\ntheorem squareNums_spec_satisfied (nums: Array Int) (h_precond : squareNums_precond (nums)) :\n    squareNums_postcond (nums) (squareNums (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0059", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_18", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef removeChars_precond (str1 : Array Char) (str2 : Array Char) := True", "vc-helpers": "", "vc-definitions": "def removeChars (str1 : Array Char) (str2 : Array Char) (h_precond : removeChars_precond str1 str2) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeChars_postcond (str1 : Array Char) (str2 : Array Char) (result : Array Char) (h_precond : removeChars_precond str1 str2) :=\n  (∀ i, i < result.size → (str1.contains result[i]! ∧ ¬str2.contains result[i]!)) ∧\n  (∀ i, i < str1.size → (str2.contains str1[i]! ∨ result.contains str1[i]!))\n\ntheorem removeChars_spec_satisfied (str1 : Array Char) (str2 : Array Char) (h_precond : removeChars_precond str1 str2) :\n    removeChars_postcond str1 str2 (removeChars str1 str2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0060", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_62", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef smallestNum_precond (nums : Array Int) :=\n  nums.size > 0", "vc-helpers": "", "vc-definitions": "def smallestNum (nums : Array Int) (h_precond : smallestNum_precond nums) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef smallestNum_postcond (nums : Array Int) (min : Int) (h_precond : smallestNum_precond nums) :=\n  (∀ i, i < nums.size → min ≤ nums[i]!) ∧ (∃ i, i < nums.size ∧ min = nums[i]!)\n\ntheorem smallestNum_spec_satisfied (nums : Array Int) (h_precond : smallestNum_precond nums) :\n    smallestNum_postcond nums (smallestNum nums h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0061", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_69", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isSubList_precond (main : Array Int) (sub : Array Int) : Prop :=\n  sub.size ≤ main.size", "vc-helpers": "", "vc-definitions": "def isSubList (main : Array Int) (sub : Array Int) (h_precond : isSubList_precond main sub) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSubList_postcond (main : Array Int) (sub : Array Int) (result : Bool) (h_precond : isSubList_precond main sub) : Prop :=\n  result = (∃ k l : Nat, 0 ≤ k ∧ k ≤ (main.size - sub.size) ∧ l = k + sub.size ∧ \n    (∀ i, i < sub.size → main[k + i]! = sub[i]!))\n\ntheorem isSubList_spec_satisfied (main : Array Int) (sub : Array Int) (h_precond : isSubList_precond main sub) :\n    isSubList_postcond main sub (isSubList main sub h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0062", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_70", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef allSequenceEqualLength_precond (seq : Array (Array Int)) :=\n  seq.size > 0", "vc-helpers": "", "vc-definitions": "def allSequenceEqualLength (seq : Array (Array Int)) (h_precond : allSequenceEqualLength_precond seq) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef allSequenceEqualLength_postcond (seq : Array (Array Int)) (result: Bool) (h_precond : allSequenceEqualLength_precond seq) :=\n  (∀ i j, i < seq.size → j < seq.size → seq[i]!.size = seq[j]!.size) ↔ result\n\ntheorem allSequenceEqualLength_spec_satisfied (seq: Array (Array Int)) (h_precond : allSequenceEqualLength_precond seq) :\n    allSequenceEqualLength_postcond seq (allSequenceEqualLength seq h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0063", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_94", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef minSecondValueFirst_precond (arr : Array (Array Int)) :=\n  arr.size > 0 ∧ (∀ i, i < arr.size → arr[i]!.size ≥ 2)", "vc-helpers": "", "vc-definitions": "def minSecondValueFirst (arr : Array (Array Int)) (h_precond : minSecondValueFirst_precond arr) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef minSecondValueFirst_postcond (arr : Array (Array Int)) (first_of_min_second : Int) (h_precond : minSecondValueFirst_precond arr) :=\n  ∃ i, i < arr.size ∧ first_of_min_second = arr[i]![0]! ∧ (∀ j, j < arr.size → arr[i]![1]! ≤ arr[j]![1]!)\n\ntheorem minSecondValueFirst_spec_satisfied (arr : Array (Array Int)) (h_precond : minSecondValueFirst_precond arr) :\n    minSecondValueFirst_postcond arr (minSecondValueFirst arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0064", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_95", "vc-description": "", "vc-preamble": "-- Precondition for smallest_list_length\n@[reducible, simp]\ndef smallestListLength_precond (list : Array (Array Int)) : Prop :=\n  list.size > 0", "vc-helpers": "", "vc-definitions": "def smallestListLength (list : Array (Array Int)) (h_precond : smallestListLength_precond list) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef smallestListLength_postcond (list : Array (Array Int)) (min : Nat) (h_precond : smallestListLength_precond list) : Prop :=\n  min ≥ 0 ∧ \n  (∀ i, i < list.size → min ≤ list[i]!.size) ∧\n  (∃ i, i < list.size ∧ min = list[i]!.size)\n\ntheorem smallestListLength_spec_satisfied (list : Array (Array Int)) (h_precond : smallestListLength_precond list) :\n    smallestListLength_postcond list (smallestListLength list h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0065", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_105", "vc-description": "/- Count true values in a boolean array -/", "vc-preamble": "/- Precondition for count_true -/\n@[reducible, simp]\ndef countTrue_precond (arr : Array Bool) : Prop := True\n\n/- Helper function to count boolean values -/\ndef countBoolean (seq : List Bool) : Int :=\n  match seq with\n  | [] => 0\n  | hd :: tl => countBoolean tl + if hd then 1 else 0", "vc-helpers": "", "vc-definitions": "def countTrue (arr : Array Bool) (h_precond : countTrue_precond arr) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef countTrue_postcond (arr : Array Bool) (count : Nat) (h_precond : countTrue_precond arr) : Prop :=\n  0 ≤ count ∧ count ≤ arr.size ∧ countBoolean arr.toList = count\n\ntheorem countTrue_spec_satisfied (arr : Array Bool) (h_precond : countTrue_precond arr) :\n    countTrue_postcond arr (countTrue arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0066", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_113", "vc-description": "/- Function to check if a text consists entirely of digit characters -/", "vc-preamble": "/- Specification function to check if a character is a digit -/\ndef isDigitSpec (c : Char) : Bool :=\n  c.toNat >= 48 ∧ c.toNat <= 57\n\n@[reducible, simp]\ndef isInteger_precond (text : Array Char) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isInteger (text : Array Char) (h_precond : isInteger_precond text) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isInteger_postcond (text : Array Char) (result: Bool) (h_precond : isInteger_precond text) : Prop :=\n  (∀ i, i < text.size → isDigitSpec text[i]!) ↔ result\n\ntheorem isInteger_spec_satisfied (text: Array Char) (h_precond : isInteger_precond text) :\n    isInteger_postcond text (isInteger text h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0067", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_133", "vc-description": "/- Function to sum all negative numbers in an array -/", "vc-preamble": "-- Function to compute sum of negative numbers from sequence recursively\ndef sum_negative_to (seq : List Int) : Int :=\n  match seq with\n  | [] => 0\n  | h :: t => sum_negative_to t + if h < 0 then h else 0\n\n@[reducible, simp]\ndef sumNegatives_precond (arr : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def sumNegatives (arr : Array Int) (h_precond : sumNegatives_precond (arr)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumNegatives_postcond (arr : Array Int) (sum_neg: Int) (h_precond : sumNegatives_precond (arr)) :=\n  sum_negative_to (arr.toList) = sum_neg\n\ntheorem sumNegatives_spec_satisfied (arr: Array Int) (h_precond : sumNegatives_precond (arr)) :\n    sumNegatives_postcond (arr) (sumNegatives (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0068", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_142", "vc-description": "/- A function that counts identical positions across three arrays -/", "vc-preamble": "@[reducible, simp]\ndef count_identical_precond (arr1 : Array Int) (arr2 : Array Int) (arr3 : Array Int) : Prop :=\n  arr1.size = arr2.size ∧ arr2.size = arr3.size\n\n-- Specification function for counting identical elements\ndef count_identical (s1 : List Int) (s2 : List Int) (s3 : List Int) : Int :=\n  match s1, s2, s3 with\n  | [], _, _ => 0\n  | _, [], _ => 0\n  | _, _, [] => 0\n  | h1::t1, h2::t2, h3::t3 => \n      count_identical t1 t2 t3 + (if h1 = h2 ∧ h2 = h3 then 1 else 0)", "vc-helpers": "", "vc-definitions": "def count_identical_position (arr1 : Array Int) (arr2 : Array Int) (arr3 : Array Int) (h_precond : count_identical_precond arr1 arr2 arr3) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef count_identical_position_postcond (arr1 : Array Int) (arr2 : Array Int) (arr3 : Array Int) (count: Nat) (h_precond : count_identical_precond arr1 arr2 arr3) : Prop :=\n  0 ≤ count ∧ count ≤ arr1.size ∧ count_identical arr1.toList arr2.toList arr3.toList = count\n\ntheorem count_identical_position_spec_satisfied (arr1: Array Int) (arr2: Array Int) (arr3: Array Int) (h_precond : count_identical_precond arr1 arr2 arr3) :\n    count_identical_position_postcond arr1 arr2 arr3 (count_identical_position arr1 arr2 arr3 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0069", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_145", "vc-description": "", "vc-preamble": "-- Define Int bounds for the precondition\naxiom Int.neg_div_two : Int\naxiom Int.pos_div_two : Int\naxiom Int.bounds_assumption : Int.neg_div_two < Int.pos_div_two\n\n@[reducible, simp]\ndef maxDifference_precond (arr : Array Int) : Prop :=\n  arr.size > 0 ∧ (∀ i, i < arr.size → Int.neg_div_two < arr[i]! ∧ arr[i]! < Int.pos_div_two)", "vc-helpers": "", "vc-definitions": "def maxDifference (arr : Array Int) (h_precond : maxDifference_precond arr) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxDifference_postcond (arr : Array Int) (diff: Int) (h_precond : maxDifference_precond arr) : Prop :=\n  ∀ i j, i < arr.size → j < arr.size → arr[i]! - arr[j]! ≤ diff\n\ntheorem maxDifference_spec_satisfied (arr: Array Int) (h_precond : maxDifference_precond arr) :\n    maxDifference_postcond arr (maxDifference arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0070", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_161", "vc-description": "/- Function to remove elements from arr1 that are present in arr2 -/", "vc-preamble": "@[reducible, simp]\ndef removeElements_precond (arr1 : Array Int) (arr2 : Array Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def removeElements (arr1 : Array Int) (arr2 : Array Int) (h_precond : removeElements_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeElements_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : removeElements_precond arr1 arr2) :=\n  (∀ i, i < result.size → (arr1.toList.contains result[i]! ∧ ¬arr2.toList.contains result[i]!)) ∧\n  (∀ i, i < arr1.size → (arr2.toList.contains arr1[i]! ∨ result.toList.contains arr1[i]!))\n\ntheorem removeElements_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : removeElements_precond arr1 arr2) :\n    removeElements_postcond arr1 arr2 (removeElements arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0071", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_170", "vc-description": "", "vc-preamble": "/- Recursive function to compute sum of list elements -/\ndef sumTo (arr : List Int) : Int :=\n  match arr with\n  | [] => 0\n  | _ :: xs => sumTo xs + arr.getLast!\n  termination_by arr.length\n\n@[reducible, simp]\ndef sumRangeList_precond (arr : Array Int) (start : Nat) (endVal : Nat) : Prop :=\n  start ≤ endVal ∧ endVal < arr.size", "vc-helpers": "", "vc-definitions": "def sumRangeList (arr : Array Int) (start : Nat) (endVal : Nat) (h_precond : sumRangeList_precond arr start endVal) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumRangeList_postcond (arr : Array Int) (start : Nat) (endVal : Nat) (sum : Int) (h_precond : sumRangeList_precond arr start endVal) : Prop :=\n  sumTo (arr.toList.drop start |>.take (endVal + 1 - start)) = sum\n\ntheorem sumRangeList_spec_satisfied (arr : Array Int) (start : Nat) (endVal : Nat) (h_precond : sumRangeList_precond arr start endVal) :\n    sumRangeList_postcond arr start endVal (sumRangeList arr start endVal h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0072", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_230", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef inner_expr_replace_blanks_with_chars (str1 : Array Char) (ch : Char) (i : Nat) : Char :=\n  if str1[i]! = Char.ofNat 32 then ch else str1[i]!\n\n@[reducible, simp]\ndef replaceBlanksWithChars_precond (str1 : Array Char) (ch : Char) : Prop := True", "vc-helpers": "", "vc-definitions": "def replaceBlanksWithChars (str1 : Array Char) (ch : Char) (h_precond : replaceBlanksWithChars_precond str1 ch) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceBlanksWithChars_postcond (str1 : Array Char) (ch : Char) (result : Array Char) (h_precond : replaceBlanksWithChars_precond str1 ch) : Prop :=\n  str1.size = result.size ∧ \n  (∀ i, i < str1.size → result[i]! = inner_expr_replace_blanks_with_chars str1 ch i)\n\ntheorem replaceBlanksWithChars_spec_satisfied (str1 : Array Char) (ch : Char) (h_precond : replaceBlanksWithChars_precond str1 ch) :\n    replaceBlanksWithChars_postcond str1 ch (replaceBlanksWithChars str1 ch h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0073", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_240", "vc-description": "/- Function to replace the last element of the first vector with all elements from the second vector -/", "vc-preamble": "@[reducible, simp]\ndef replaceLastElement_precond (first : Array Int) (second : Array Int) : Prop :=\n  first.size > 0", "vc-helpers": "", "vc-definitions": "def replaceLastElement (first : Array Int) (second : Array Int) (h_precond : replaceLastElement_precond first second) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceLastElement_postcond (first : Array Int) (second : Array Int) (replaced_list : Array Int) (h_precond : replaceLastElement_precond first second) : Prop :=\n  replaced_list.toList = (first.toList.take (first.size - 1)) ++ second.toList\n\ntheorem replaceLastElement_spec_satisfied (first : Array Int) (second : Array Int) (h_precond : replaceLastElement_precond first second) :\n    replaceLastElement_postcond first second (replaceLastElement first second h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0074", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_249", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef intersection_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def intersection (arr1 : Array Int) (arr2 : Array Int) (h_precond : intersection_precond (arr1) (arr2)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef intersection_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : intersection_precond (arr1) (arr2)) :=\n  (∀ i, i < result.size → (arr1.contains result[i]! ∧ arr2.contains result[i]!)) ∧\n  (∀ i j, i < j → j < result.size → result[i]! ≠ result[j]!)\n\ntheorem intersection_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : intersection_precond (arr1) (arr2)) :\n    intersection_postcond (arr1) (arr2) (intersection (arr1) (arr2) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0075", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_251", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef insertBeforeEach_precond (arr : Array Int) (elem : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def insertBeforeEach (arr : Array Int) (elem : Int) (h_precond : insertBeforeEach_precond (arr) (elem)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef insertBeforeEach_postcond (arr : Array Int) (elem : Int) (result : Array Int) (h_precond : insertBeforeEach_precond (arr) (elem)) : Prop :=\n  result.size = (2 * arr.size) ∧ \n  (∀ k, k < arr.size → result[2 * k]! = elem) ∧\n  (∀ k, k < arr.size → result[2 * k + 1]! = arr[k]!)\n\ntheorem insertBeforeEach_spec_satisfied (arr : Array Int) (elem : Int) (h_precond : insertBeforeEach_precond (arr) (elem)) :\n    insertBeforeEach_postcond (arr) (elem) (insertBeforeEach (arr) (elem) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0076", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_261", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef elementWiseDivision_precond (arr1 : Array UInt32) (arr2 : Array UInt32) : Prop :=\n  arr1.size = arr2.size ∧ \n  (∀ i, i < arr2.size → arr2[i]! ≠ 0) ∧\n  (∀ m, m < arr1.size → True)", "vc-helpers": "", "vc-definitions": "def elementWiseDivision (arr1 : Array UInt32) (arr2 : Array UInt32) (h_precond : elementWiseDivision_precond arr1 arr2) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseDivision_postcond (arr1 : Array UInt32) (arr2 : Array UInt32) (result : Array UInt32) (h_precond : elementWiseDivision_precond arr1 arr2) : Prop :=\n  result.size = arr1.size ∧\n  (∀ i, i < result.size → result[i]! = arr1[i]! / arr2[i]!)\n\ntheorem elementWiseDivision_spec_satisfied (arr1 : Array UInt32) (arr2 : Array UInt32) (h_precond : elementWiseDivision_precond arr1 arr2) :\n    elementWiseDivision_postcond arr1 arr2 (elementWiseDivision arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0077", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_262", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef splitArray_precond (list : Array Int) (l : Nat) : Prop :=\n  list.size > 0 ∧ 0 < l ∧ l < list.size", "vc-helpers": "", "vc-definitions": "def splitArray (list : Array Int) (l : Nat) (h_precond : splitArray_precond list l) : Array Int × Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef splitArray_postcond (list : Array Int) (l : Nat) (result: Array Int × Array Int) (h_precond : splitArray_precond list l) : Prop :=\n  result.1.toList = list.toList.take l ∧ result.2.toList = list.toList.drop l\n\ntheorem splitArray_spec_satisfied (list: Array Int) (l: Nat) (h_precond : splitArray_precond list l) :\n    splitArray_postcond list l (splitArray list l h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0078", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_273", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef elementWiseSubtract_precond (arr1 : Array Int) (arr2 : Array Int) :=\n  arr1.size = arr2.size ∧ (∀ i, i < arr1.size → -2147483648 ≤ arr1[i]! - arr2[i]! ∧ arr1[i]! - arr2[i]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def elementWiseSubtract (arr1 : Array Int) (arr2 : Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseSubtract_postcond (arr1 : Array Int) (arr2 : Array Int) (result : Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) :=\n  result.size = arr1.size ∧ (∀ i, i < result.size → result[i]! = arr1[i]! - arr2[i]!)\n\ntheorem elementWiseSubtract_spec_satisfied (arr1 : Array Int) (arr2 : Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) :\n    elementWiseSubtract_postcond arr1 arr2 (elementWiseSubtract arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0079", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_282", "vc-description": "", "vc-preamble": "/- Precondition for element_wise_subtract function -/\n@[reducible, simp]\ndef elementWiseSubtract_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  arr1.size = arr2.size ∧ \n  (∀ i, i < arr1.size → -2147483648 ≤ arr1[i]! - arr2[i]! ∧ arr1[i]! - arr2[i]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def elementWiseSubtract (arr1 : Array Int) (arr2 : Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseSubtract_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) : Prop :=\n  result.size = arr1.size ∧ \n  (∀ i, i < result.size → result[i]! = arr1[i]! - arr2[i]!)\n\ntheorem elementWiseSubtract_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : elementWiseSubtract_precond arr1 arr2) :\n    elementWiseSubtract_postcond arr1 arr2 (elementWiseSubtract arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0080", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_284", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef allElementsEquals_precond (arr : Array Int) (element : Int) := True", "vc-helpers": "", "vc-definitions": "def allElementsEquals (arr : Array Int) (element : Int) (h_precond : allElementsEquals_precond arr element) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef allElementsEquals_postcond (arr : Array Int) (element : Int) (result: Bool) (h_precond : allElementsEquals_precond arr element) :=\n  (∀ i, i < arr.size → arr[i]! = element) ↔ result\n\ntheorem allElementsEquals_spec_satisfied (arr: Array Int) (element: Int) (h_precond : allElementsEquals_precond arr element) :\n    allElementsEquals_postcond arr element (allElementsEquals arr element h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0081", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_307", "vc-description": "", "vc-preamble": "-- <vc-preamble>\n@[reducible, simp]\ndef listDeepClone_precond (arr : Array Nat) := \n  True", "vc-helpers": "", "vc-definitions": "def listDeepClone (arr : Array Nat) (h_precond : listDeepClone_precond (arr)) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef listDeepClone_postcond (arr : Array Nat) (copied: Array Nat) (h_precond : listDeepClone_precond (arr)) :=\n  arr.size = copied.size ∧ (∀ i, i < arr.size → arr[i]! = copied[i]!)\n\ntheorem listDeepClone_spec_satisfied (arr: Array Nat) (h_precond : listDeepClone_precond (arr)) :\n    listDeepClone_postcond (arr) (listDeepClone (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0082", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_399", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef bitWiseXor_precond (arr1 : Array UInt32) (arr2 : Array UInt32) :=\n  arr1.size = arr2.size", "vc-helpers": "", "vc-definitions": "def bitWiseXor (arr1 : Array UInt32) (arr2 : Array UInt32) (h_precond : bitWiseXor_precond (arr1) (arr2)) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef bitWiseXor_postcond (arr1 : Array UInt32) (arr2 : Array UInt32) (result: Array UInt32) (h_precond : bitWiseXor_precond (arr1) (arr2)) :=\n  result.size = arr1.size ∧ \n  (∀ i, i < result.size → result[i]! = arr1[i]! ^^^ arr2[i]!)\n\ntheorem bitWiseXor_spec_satisfied (arr1: Array UInt32) (arr2: Array UInt32) (h_precond : bitWiseXor_precond (arr1) (arr2)) :\n    bitWiseXor_postcond (arr1) (arr2) (bitWiseXor (arr1) (arr2) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0083", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_412", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef removeOdds_precond (arr : Array UInt32) := True", "vc-helpers": "", "vc-definitions": "def removeOdds (arr : Array UInt32) (h_precond : removeOdds_precond (arr)) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeOdds_postcond (arr : Array UInt32) (even_list: Array UInt32) (h_precond : removeOdds_precond (arr)) :=\n  even_list.toList = (arr.toList.filter (fun x => x % 2 = 0))\n\ntheorem removeOdds_spec_satisfied (arr: Array UInt32) (h_precond : removeOdds_precond (arr)) :\n    removeOdds_postcond (arr) (removeOdds (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0084", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_414", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef anyValueExists_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def anyValueExists (arr1 : Array Int) (arr2 : Array Int) (h_precond : anyValueExists_precond arr1 arr2) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef anyValueExists_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Bool) (h_precond : anyValueExists_precond arr1 arr2) :=\n  (∃ k, 0 ≤ k ∧ k < arr1.size ∧ arr2.toList.contains (arr1[k]!)) ↔ result\n\ntheorem anyValueExists_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : anyValueExists_precond arr1 arr2) :\n    anyValueExists_postcond arr1 arr2 (anyValueExists arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0085", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_424", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef extractRearChars_precond (s : Array (Array Char)) :=\n  ∀ i, i < s.size → s[i]!.size > 0", "vc-helpers": "", "vc-definitions": "def extractRearChars (s : Array (Array Char)) (h_precond : extractRearChars_precond (s)) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef extractRearChars_postcond (s : Array (Array Char)) (result: Array Char) (h_precond : extractRearChars_precond (s)) :=\n  s.size = result.size ∧ (∀ i, i < s.size → result[i]! = s[i]![s[i]!.size - 1]!)\n\ntheorem extractRearChars_spec_satisfied (s: Array (Array Char)) (h_precond : extractRearChars_precond (s)) :\n    extractRearChars_postcond (s) (extractRearChars (s) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0086", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_426", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef filterOddNumbers_precond (arr : Array UInt32) : Prop := True", "vc-helpers": "", "vc-definitions": "def filterOddNumbers (arr : Array UInt32) (h_precond : filterOddNumbers_precond (arr)) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef filterOddNumbers_postcond (arr : Array UInt32) (odd_list: Array UInt32) (h_precond : filterOddNumbers_precond (arr)) :=\n  odd_list.toList = arr.toList.filter (fun x => x % 2 ≠ 0)\n\ntheorem filterOddNumbers_spec_satisfied (arr: Array UInt32) (h_precond : filterOddNumbers_precond (arr)) :\n    filterOddNumbers_postcond (arr) (filterOddNumbers (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0087", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_431", "vc-description": "", "vc-preamble": "/- No precondition required for this function -/", "vc-helpers": "", "vc-definitions": "def hasCommonElement (list1 : Array Int) (list2 : Array Int) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasCommonElement_postcond (list1 : Array Int) (list2 : Array Int) (result: Bool) :=\n  (∃ i j, i < list1.size ∧ j < list2.size ∧ list1[i]! = list2[j]!) ↔ result\n\ntheorem hasCommonElement_spec_satisfied (list1: Array Int) (list2: Array Int) :\n    hasCommonElement_postcond (list1) (list2) (hasCommonElement (list1) (list2)) := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0088", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_433", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isGreater_precond (arr : Array Int) (number : Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isGreater (arr : Array Int) (number : Int) (h_precond : isGreater_precond arr number) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isGreater_postcond (arr : Array Int) (number : Int) (result: Bool) (h_precond : isGreater_precond arr number) :=\n  (∀ i, i < arr.size → number > arr[i]!) ↔ result\n\ntheorem isGreater_spec_satisfied (arr: Array Int) (number: Int) (h_precond : isGreater_precond arr number) :\n    isGreater_postcond arr number (isGreater arr number h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0089", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_436", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findNegativeNumbers_precond (arr : Array Int) := True", "vc-helpers": "", "vc-definitions": "def findNegativeNumbers (arr : Array Int) (h_precond : findNegativeNumbers_precond arr) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findNegativeNumbers_postcond (arr : Array Int) (negative_list: Array Int) (h_precond : findNegativeNumbers_precond arr) :=\n  (negative_list.toList = (arr.toList.filter (fun x => x < 0)))\n\ntheorem findNegativeNumbers_spec_satisfied (arr: Array Int) (h_precond : findNegativeNumbers_precond arr) :\n    findNegativeNumbers_postcond arr (findNegativeNumbers arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0090", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_445", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef elementWiseMultiplication_precond (arr1 : Array Int) (arr2 : Array Int) :=\n  arr1.size = arr2.size ∧ (∀ i, i < arr1.size → -2147483648 ≤ arr1[i]! * arr2[i]! ∧ arr1[i]! * arr2[i]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def elementWiseMultiplication (arr1 : Array Int) (arr2 : Array Int) (h_precond : elementWiseMultiplication_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseMultiplication_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : elementWiseMultiplication_precond arr1 arr2) :=\n  result.size = arr1.size ∧ (∀ i, i < result.size → result[i]! = arr1[i]! * arr2[i]!)\n\ntheorem elementWiseMultiplication_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : elementWiseMultiplication_precond arr1 arr2) :\n    elementWiseMultiplication_postcond arr1 arr2 (elementWiseMultiplication arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0091", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_447", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef cubeElement_precond (nums : Array Int) :=\n  (∀ k, k < nums.size → -2147483648 ≤ nums[k]! * nums[k]! ∧ nums[k]! * nums[k]! ≤ 2147483647) ∧\n  (∀ k, k < nums.size → -2147483648 ≤ nums[k]! * nums[k]! * nums[k]! ∧ nums[k]! * nums[k]! * nums[k]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def cubeElement (nums : Array Int) (h_precond : cubeElement_precond (nums)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef cubeElement_postcond (nums : Array Int) (cubed: Array Int) (h_precond : cubeElement_precond (nums)) :=\n  ∀ i, i < nums.size → cubed[i]! = nums[i]! * nums[i]! * nums[i]!\n\ntheorem cubeElement_spec_satisfied (nums: Array Int) (h_precond : cubeElement_precond (nums)) :\n    cubeElement_postcond (nums) (cubeElement (nums) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0092", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_454", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef containsZ_precond (text : Array Char) :=\n  True", "vc-helpers": "", "vc-definitions": "def containsZ (text : Array Char) (h_precond : containsZ_precond (text)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef containsZ_postcond (text : Array Char) (result: Bool) (h_precond : containsZ_precond (text)) :=\n  result = (∃ i, i < text.size ∧ (text[i]! = 'Z' ∨ text[i]! = 'z'))\n\ntheorem containsZ_spec_satisfied (text: Array Char) (h_precond : containsZ_precond (text)) :\n    containsZ_postcond (text) (containsZ (text) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0093", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_460", "vc-description": "", "vc-preamble": "/- Precondition: All sub-arrays must be non-empty -/\n@[reducible, simp]\ndef getFirstElements_precond (arr : Array (Array Int)) :=\n  ∀ i, i < arr.size → arr[i]!.size > 0", "vc-helpers": "", "vc-definitions": "def getFirstElements (arr : Array (Array Int)) (h_precond : getFirstElements_precond arr) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef getFirstElements_postcond (arr : Array (Array Int)) (result : Array Int) (h_precond : getFirstElements_precond arr) :=\n  arr.size = result.size ∧ (∀ i, i < arr.size → result[i]! = arr[i]![0]!)\n\ntheorem getFirstElements_spec_satisfied (arr : Array (Array Int)) (h_precond : getFirstElements_precond arr) :\n    getFirstElements_postcond arr (getFirstElements arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0094", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_461", "vc-description": "", "vc-preamble": "-- Helper functions for character case checking\ndef isLowerCase (c : Char) : Bool :=\n  c.toNat ≥ 97 ∧ c.toNat ≤ 122\n\ndef isUpperCase (c : Char) : Bool :=\n  c.toNat ≥ 65 ∧ c.toNat ≤ 90\n\ndef countUppercaseRecursively (seq : List Char) : Nat :=\n  match seq with\n  | [] => 0\n  | c :: cs => countUppercaseRecursively cs + if isUpperCase c then 1 else 0\n\n@[reducible, simp]\ndef countUppercase_precond (text : Array Char) : Prop := True", "vc-helpers": "", "vc-definitions": "def countUppercase (text : Array Char) (h_precond : countUppercase_precond text) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef countUppercase_postcond (text : Array Char) (count : Nat) (h_precond : countUppercase_precond text) : Prop :=\n  count ≤ text.size ∧ countUppercaseRecursively text.toList = count\n\ntheorem countUppercase_spec_satisfied (text : Array Char) (h_precond : countUppercase_precond text) :\n    countUppercase_postcond text (countUppercase text h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0095", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_472", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef containsConsecutiveNumbers_precond (arr : Array Int) : Prop :=\n  arr.size > 0 ∧ (∀ i, i < arr.size → 0 ≤ arr[i]! + 1 ∧ arr[i]! + 1 < 2147483647)", "vc-helpers": "", "vc-definitions": "def containsConsecutiveNumbers (arr : Array Int) (h_precond : containsConsecutiveNumbers_precond arr) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef containsConsecutiveNumbers_postcond (arr : Array Int) (is_consecutive : Bool) (h_precond : containsConsecutiveNumbers_precond arr) : Prop :=\n  is_consecutive = (∀ i j, 0 ≤ i ∧ i < j ∧ j < arr.size ∧ j = i + 1 → arr[i]! + 1 = arr[j]!)\n\ntheorem containsConsecutiveNumbers_spec_satisfied (arr : Array Int) (h_precond : containsConsecutiveNumbers_precond arr) :\n    containsConsecutiveNumbers_postcond arr (containsConsecutiveNumbers arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0096", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_474", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef replaceChars_precond (str1 : Array Char) (old_char : Char) (new_char : Char) := True", "vc-helpers": "/- Helper function for character replacement -/\ndef inner_expr_replace_chars (str1 : Array Char) (old_char : Char) (new_char : Char) (i : Nat) : Char :=\n  if str1[i]! = old_char then new_char else str1[i]!", "vc-definitions": "def replaceChars (str1 : Array Char) (old_char : Char) (new_char : Char) (h_precond : replaceChars_precond str1 old_char new_char) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceChars_postcond (str1 : Array Char) (old_char : Char) (new_char : Char) (result : Array Char) (h_precond : replaceChars_precond str1 old_char new_char) :=\n  str1.size = result.size ∧ \n  (∀ i, i < str1.size → result[i]! = inner_expr_replace_chars str1 old_char new_char i)\n\ntheorem replaceChars_spec_satisfied (str1 : Array Char) (old_char : Char) (new_char : Char) (h_precond : replaceChars_precond str1 old_char new_char) :\n    replaceChars_postcond str1 old_char new_char (replaceChars str1 old_char new_char h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0097", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_476", "vc-description": "", "vc-preamble": "/- Helper functions for recursively computing max and min of a list -/\ndef maxRcur (seq : List Int) : Int :=\n  match seq with\n  | [] => 0  /- Should not happen given preconditions -/\n  | [x] => x\n  | x :: xs => max x (maxRcur xs)\n\ndef minRcur (seq : List Int) : Int :=\n  match seq with\n  | [] => 0  /- Should not happen given preconditions -/\n  | [x] => x  \n  | x :: xs => min x (minRcur xs)\n\n@[reducible, simp]\ndef sumMinMax_precond (arr : Array Int) : Prop :=\n  arr.size > 0 ∧ ∀ i, i < arr.size → -1073741824 < arr[i]! ∧ arr[i]! < 1073741823", "vc-helpers": "", "vc-definitions": "def sumMinMax (arr : Array Int) (h_precond : sumMinMax_precond arr) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sumMinMax_postcond (arr : Array Int) (sum : Int) (h_precond : sumMinMax_precond arr) : Prop :=\n  sum = maxRcur arr.toList + minRcur arr.toList\n\ntheorem sumMinMax_spec_satisfied (arr : Array Int) (h_precond : sumMinMax_precond arr) :\n    sumMinMax_postcond arr (sumMinMax arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0098", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_477", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef toLowercase_precond (str1 : Array Char) := True\n\n@[reducible, simp]\ndef isUpperCase (c : Char) : Bool :=\n  'A' ≤ c ∧ c ≤ 'Z'\n\n@[reducible, simp]\ndef shift32Spec (c : Char) : Char :=\n  Char.ofNat ((c.toNat) + 32)", "vc-helpers": "", "vc-definitions": "def toLowercase (str1 : Array Char) (h_precond : toLowercase_precond (str1)) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef toLowercase_postcond (str1 : Array Char) (result: Array Char) (h_precond : toLowercase_precond (str1)) :=\n  str1.size = result.size ∧ \n  (∀ i, i < str1.size → result[i]! = (if isUpperCase (str1[i]!) then shift32Spec (str1[i]!) else str1[i]!))\n\ntheorem toLowercase_spec_satisfied (str1: Array Char) (h_precond : toLowercase_precond (str1)) :\n    toLowercase_postcond (str1) (toLowercase (str1) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0099", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_554", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findOddNumbers_precond (arr : Array UInt32) : Prop := True", "vc-helpers": "", "vc-definitions": "def findOddNumbers (arr : Array UInt32) (h_precond : findOddNumbers_precond (arr)) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findOddNumbers_postcond (arr : Array UInt32) (odd_numbers: Array UInt32) (h_precond : findOddNumbers_precond (arr)) :=\n  odd_numbers.toList = arr.toList.filter (fun x => x % 2 ≠ 0)\n\ntheorem findOddNumbers_spec_satisfied (arr: Array UInt32) (h_precond : findOddNumbers_precond (arr)) :\n    findOddNumbers_postcond (arr) (findOddNumbers (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0100", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_557", "vc-description": "", "vc-preamble": "/- Function to check if a character is upper case -/\n@[reducible, simp]\ndef isUpperCase (c : Char) : Bool :=\n  c >= 'A' ∧ c <= 'Z'\n\n/- Function to shift character by 32 (upper to lower) -/\n@[reducible, simp]\ndef shift32Spec (c : Char) : Char :=\n  Char.ofNat ((c.toNat) + 32)\n\n/- Function to check if a character is lower case -/\n@[reducible, simp]\ndef isLowerCase (c : Char) : Bool :=\n  c >= 'a' ∧ c <= 'z'\n\n/- Function to shift character by -32 (lower to upper) -/\n@[reducible, simp]\ndef shiftMinus32Spec (c : Char) : Char :=\n  Char.ofNat ((c.toNat) - 32)\n\n/- Function to toggle case of a character -/\n@[reducible, simp]\ndef toToggleCaseSpec (s : Char) : Char :=\n  if isLowerCase s then\n    shiftMinus32Spec s\n  else if isUpperCase s then\n    shift32Spec s\n  else\n    s\n\n/- Precondition for toToggleCase function -/\n@[reducible, simp]\ndef toToggleCase_precond (str1 : Array Char) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def toToggleCase (str1 : Array Char) (h_precond : toToggleCase_precond (str1)) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef toToggleCase_postcond (str1 : Array Char) (toggleCase : Array Char) (h_precond : toToggleCase_precond (str1)) : Prop :=\n  str1.size = toggleCase.size ∧\n  (∀ i, i < str1.size → toggleCase[i]! = toToggleCaseSpec (str1[i]!))\n\ntheorem toToggleCase_spec_satisfied (str1 : Array Char) (h_precond : toToggleCase_precond (str1)) :\n    toToggleCase_postcond (str1) (toToggleCase (str1) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0101", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_567", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isSorted_precond (arr : Array Int) :=\n  arr.size > 0", "vc-helpers": "", "vc-definitions": "def isSorted (arr : Array Int) (h_precond : isSorted_precond (arr)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSorted_postcond (arr : Array Int) (is_sorted: Bool) (h_precond : isSorted_precond (arr)) :=\n  (∀ i j, 0 ≤ i ∧ i < j ∧ j < arr.size → arr[i]! ≤ arr[j]!) ↔ is_sorted\n\ntheorem isSorted_spec_satisfied (arr: Array Int) (h_precond : isSorted_precond (arr)) :\n    isSorted_postcond (arr) (isSorted (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0102", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_572", "vc-description": "", "vc-preamble": "/- Recursive helper function to count frequency -/\ndef countFrequencyRcr (seq : List Int) (key : Int) : Nat :=\n  match seq with\n  | [] => 0\n  | head :: tail => \n      countFrequencyRcr tail key + (if head = key then 1 else 0)\n\n/- Precondition for removeDuplicates -/\n@[reducible, simp]\ndef removeDuplicates_precond (arr : Array Int) := True", "vc-helpers": "", "vc-definitions": "def removeDuplicates (arr : Array Int) (h_precond : removeDuplicates_precond (arr)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeDuplicates_postcond (arr : Array Int) (unique_arr : Array Int) (h_precond : removeDuplicates_precond (arr)) :=\n  unique_arr.toList = arr.toList.filter (fun x => countFrequencyRcr arr.toList x = 1)\n\ntheorem removeDuplicates_spec_satisfied (arr : Array Int) (h_precond : removeDuplicates_precond (arr)) :\n    removeDuplicates_postcond (arr) (removeDuplicates (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0103", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_576", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isSubArray_precond (main : Array Int) (sub : Array Int) : Prop :=\n  sub.size ≤ main.size", "vc-helpers": "", "vc-definitions": "def isSubArray (main : Array Int) (sub : Array Int) (h_precond : isSubArray_precond main sub) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSubArray_postcond (main : Array Int) (sub : Array Int) (result : Bool) (h_precond : isSubArray_precond main sub) : Prop :=\n  result = (∃ k l : Nat, 0 ≤ k ∧ k ≤ (main.size - sub.size) ∧ l = k + sub.size ∧ (main.extract k l).toList = sub.toList)\n\ntheorem isSubArray_spec_satisfied (main : Array Int) (sub : Array Int) (h_precond : isSubArray_precond main sub) :\n    isSubArray_postcond main sub (isSubArray main sub h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0104", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_576_v2", "vc-description": "", "vc-preamble": "/- Helper function to check if sub is a subrange of main starting at position i -/\ndef isSubrangeAt (main : List Int) (sub : List Int) (i : Int) : Bool :=\n  if i < 0 ∨ i + sub.length > main.length then false\n  else sub = (main.drop i.natAbs).take sub.length\n\n@[reducible, simp]\ndef isSubArray_precond (main : Array Int) (sub : Array Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def isSubArray (main : Array Int) (sub : Array Int) (h_precond : isSubArray_precond main sub) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSubArray_postcond (main : Array Int) (sub : Array Int) (result: Bool) (h_precond : isSubArray_precond main sub) : Prop :=\n  result = (∃ k, 0 ≤ k ∧ k ≤ (main.size : Int) - (sub.size : Int) ∧ isSubrangeAt main.toList sub.toList k)\n\ntheorem isSubArray_spec_satisfied (main: Array Int) (sub: Array Int) (h_precond : isSubArray_precond main sub) :\n    isSubArray_postcond main sub (isSubArray main sub h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0105", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_578", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef interleave_precond (s1 : Array Int) (s2 : Array Int) (s3 : Array Int) : Prop :=\n  s1.size = s2.size ∧ s2.size = s3.size ∧ 0 ≤ (s1.size * 3) ∧ (s1.size * 3) ≤ Int.natAbs (Int.ofNat 2147483647)", "vc-helpers": "", "vc-definitions": "def interleave (s1 : Array Int) (s2 : Array Int) (s3 : Array Int) (h_precond : interleave_precond s1 s2 s3) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef interleave_postcond (s1 : Array Int) (s2 : Array Int) (s3 : Array Int) (result : Array Int) (h_precond : interleave_precond s1 s2 s3) : Prop :=\n  result.size = s1.size * 3 ∧ \n  (∀ i : Nat, i < s1.size → result[3 * i]! = s1[i]! ∧ result[3 * i + 1]! = s2[i]! ∧ result[3 * i + 2]! = s3[i]!)\n\ntheorem interleave_spec_satisfied (s1 : Array Int) (s2 : Array Int) (s3 : Array Int) (h_precond : interleave_precond s1 s2 s3) :\n    interleave_postcond s1 s2 s3 (interleave s1 s2 s3 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0106", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_579", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findDissimilar_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def findDissimilar (arr1 : Array Int) (arr2 : Array Int) (h_precond : findDissimilar_precond (arr1) (arr2)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findDissimilar_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : findDissimilar_precond (arr1) (arr2)) :=\n  (∀ i, 0 ≤ i ∧ i < arr1.size → ¬(∃ j, 0 ≤ j ∧ j < arr2.size ∧ arr2[j]! = arr1[i]!) → (∃ k, 0 ≤ k ∧ k < result.size ∧ result[k]! = arr1[i]!)) ∧\n  (∀ i, 0 ≤ i ∧ i < arr2.size → ¬(∃ j, 0 ≤ j ∧ j < arr1.size ∧ arr1[j]! = arr2[i]!) → (∃ k, 0 ≤ k ∧ k < result.size ∧ result[k]! = arr2[i]!)) ∧\n  (∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! ≠ result[j]!)\n\ntheorem findDissimilar_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : findDissimilar_precond (arr1) (arr2)) :\n    findDissimilar_postcond (arr1) (arr2) (findDissimilar (arr1) (arr2) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0107", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_586", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef splitAndAppend_precond (list : Array Int) (n : Nat) :=\n  list.size > 0 ∧ 0 < n ∧ n < list.size", "vc-helpers": "", "vc-definitions": "def splitAndAppend (list : Array Int) (n : Nat) (h_precond : splitAndAppend_precond (list) (n)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef splitAndAppend_postcond (list : Array Int) (n : Nat) (new_list: Array Int) (h_precond : splitAndAppend_precond (list) (n)) :=\n  new_list.toList = (list.toList.drop n) ++ (list.toList.take n)\n\ntheorem splitAndAppend_spec_satisfied (list: Array Int) (n: Nat) (h_precond : splitAndAppend_precond (list) (n)) :\n    splitAndAppend_postcond (list) (n) (splitAndAppend (list) (n) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0108", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_588", "vc-description": "", "vc-preamble": "def maxInt (a b : Int) : Int := if a ≥ b then a else b\ndef minInt (a b : Int) : Int := if a ≤ b then a else b\n\ndef maxRcur : List Int → Int\n  | [] => 0\n  | [x] => x\n  | xs => maxInt xs.getLast! (maxRcur xs.dropLast)\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  sorry\n\ndef minRcur : List Int → Int\n  | [] => 0\n  | [x] => x\n  | xs => minInt xs.getLast! (minRcur xs.dropLast)\ntermination_by xs => xs.length\ndecreasing_by\n  simp_wf\n  sorry\n\n@[reducible, simp]\ndef differenceMaxMin_precond (arr : Array Int) : Prop :=\n  arr.size > 0 ∧ (∀ i, i < arr.size → (-2147483648 / 2) < arr[i]! ∧ arr[i]! < (2147483647 / 2))", "vc-helpers": "", "vc-definitions": "def differenceMaxMin (arr : Array Int) (h_precond : differenceMaxMin_precond arr) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef differenceMaxMin_postcond (arr : Array Int) (diff : Int) (h_precond : differenceMaxMin_precond arr) : Prop :=\n  diff = maxRcur arr.toList - minRcur arr.toList\n\ntheorem differenceMaxMin_spec_satisfied (arr : Array Int) (h_precond : differenceMaxMin_precond arr) :\n    differenceMaxMin_postcond arr (differenceMaxMin arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0109", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_602", "vc-description": "", "vc-preamble": "-- Precondition definitions\n@[reducible, simp]\ndef firstRepeatedChar_precond (str1 : Array Char) : Prop := True\n\n-- Helper recursive function for counting frequency\ndef countFrequencyRcr : List Char → Char → Int\n  | [], _ => 0\n  | head :: tail, key => \n      countFrequencyRcr tail key + if head = key then 1 else 0\n\n-- Check function for first repeated character specification\ndef checkFirstRepeatedChar (str1 : Array Char) (repeatedChar : Option (Nat × Char)) : Prop :=\n  match repeatedChar with\n  | some (idx, rpChar) => \n      (str1.toList.take idx).filter (fun x => countFrequencyRcr str1.toList x ≤ 1) = str1.toList.take idx ∧\n      countFrequencyRcr str1.toList rpChar > 1\n  | none => \n      ∀ k, k < str1.size → countFrequencyRcr str1.toList str1[k]! ≤ 1", "vc-helpers": "", "vc-definitions": "def firstRepeatedChar (str1 : Array Char) (h_precond : firstRepeatedChar_precond str1) : Option (Nat × Char) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef firstRepeatedChar_postcond (str1 : Array Char) (repeatedChar : Option (Nat × Char)) (h_precond : firstRepeatedChar_precond str1) : Prop :=\n  checkFirstRepeatedChar str1 repeatedChar\n\ntheorem firstRepeatedChar_spec_satisfied (str1 : Array Char) (h_precond : firstRepeatedChar_precond str1) :\n    firstRepeatedChar_postcond str1 (firstRepeatedChar str1 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0110", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_605", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isDivisible (n : Int) (divisor : Int) : Bool :=\n  n % divisor = 0\n\n@[reducible, simp]\ndef primeNum_precond (n : Nat) : Prop :=\n  n ≥ 2", "vc-helpers": "", "vc-definitions": "def primeNum (n : Nat) (h_precond : primeNum_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef primeNum_postcond (n : Nat) (result: Bool) (h_precond : primeNum_precond (n)) :=\n  (∀ k : Int, 2 ≤ k → k < n → ¬isDivisible (n : Int) k) ↔ result\n\ntheorem primeNum_spec_satisfied (n: Nat) (h_precond : primeNum_precond (n)) :\n    primeNum_postcond (n) (primeNum (n) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0111", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_610", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef removeKthElement_precond (list : Array Int) (k : Nat) :=\n  list.size > 0 ∧ 0 < k ∧ k < list.size", "vc-helpers": "", "vc-definitions": "def removeKthElement (list : Array Int) (k : Nat) (h_precond : removeKthElement_precond list k) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeKthElement_postcond (list : Array Int) (k : Nat) (new_list : Array Int) (h_precond : removeKthElement_precond list k) :=\n  new_list.toList = (list.toList.take (k - 1)) ++ (list.toList.drop k)\n\ntheorem removeKthElement_spec_satisfied (list : Array Int) (k : Nat) (h_precond : removeKthElement_precond list k) :\n    removeKthElement_postcond list k (removeKthElement list k h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0112", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_616", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef elementWiseModule_precond (arr1 : Array Int) (arr2 : Array Int) :=\n  arr1.size = arr2.size ∧ (∀ i, i < arr2.size → arr2[i]! ≠ 0) ∧ (∀ i, i < arr1.size → Int.emod arr1[i]! arr2[i]! ≥ Int.negSucc 2147483647 ∧ Int.emod arr1[i]! arr2[i]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def elementWiseModule (arr1 : Array Int) (arr2 : Array Int) (h_precond : elementWiseModule_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseModule_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : elementWiseModule_precond arr1 arr2) :=\n  result.size = arr1.size ∧ (∀ i, i < result.size → result[i]! = Int.emod arr1[i]! arr2[i]!)\n\ntheorem elementWiseModule_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : elementWiseModule_precond arr1 arr2) :\n    elementWiseModule_postcond arr1 arr2 (elementWiseModule arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0113", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_618", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef elementWiseDivide_precond (arr1 : Array Nat) (arr2 : Array Nat) :=\n  arr1.size = arr2.size ∧ \n  (∀ i, i < arr2.size → arr2[i]! ≠ 0) ∧\n  (∀ i, i < arr1.size → (arr1[i]! / arr2[i]! : Int) ≥ Int.negSucc 2147483647 ∧ (arr1[i]! / arr2[i]! : Int) ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def elementWiseDivide (arr1 : Array Nat) (arr2 : Array Nat) (h_precond : elementWiseDivide_precond arr1 arr2) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef elementWiseDivide_postcond (arr1 : Array Nat) (arr2 : Array Nat) (result: Array Nat) (h_precond : elementWiseDivide_precond arr1 arr2) :=\n  result.size = arr1.size ∧ (∀ i, i < result.size → result[i]! = arr1[i]! / arr2[i]!)\n\ntheorem elementWiseDivide_spec_satisfied (arr1: Array Nat) (arr2: Array Nat) (h_precond : elementWiseDivide_precond arr1 arr2) :\n    elementWiseDivide_postcond arr1 arr2 (elementWiseDivide arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0114", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_624", "vc-description": "", "vc-preamble": "/- Helper functions for character manipulation -/\n\n@[reducible, simp]\ndef isLowerCase (c : Char) : Bool :=\n  c >= 'a' && c <= 'z'\n\n@[reducible, simp]  \ndef shiftMinus32Spec (c : Char) : Char :=\n  Char.ofNat (c.toNat - 32)\n\n@[reducible, simp]\ndef innerExprToUppercase (str1 : Array Char) (i : Nat) : Char :=\n  if isLowerCase str1[i]! then\n    shiftMinus32Spec str1[i]!\n  else\n    str1[i]!\n\n@[reducible, simp]\ndef toUppercase_precond (str1 : Array Char) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def toUppercase (str1 : Array Char) (h_precond : toUppercase_precond str1) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef toUppercase_postcond (str1 : Array Char) (result : Array Char) (h_precond : toUppercase_precond str1) : Prop :=\n  str1.size = result.size ∧ \n  (∀ i : Nat, i < str1.size → result[i]! = innerExprToUppercase str1 i)\n\ntheorem toUppercase_spec_satisfied (str1 : Array Char) (h_precond : toUppercase_precond str1) :\n    toUppercase_postcond str1 (toUppercase str1 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0115", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_629", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findEvenNumbers_precond (arr : Array Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def findEvenNumbers (arr : Array Nat) (h_precond : findEvenNumbers_precond (arr)) : Array Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findEvenNumbers_postcond (arr : Array Nat) (even_numbers: Array Nat) (h_precond : findEvenNumbers_precond (arr)) :=\n  even_numbers.toList = arr.toList.filter (fun x => x % 2 = 0)\n\ntheorem findEvenNumbers_spec_satisfied (arr: Array Nat) (h_precond : findEvenNumbers_precond (arr)) :\n    findEvenNumbers_postcond (arr) (findEvenNumbers (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0116", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_644", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef reverseToK_precond (list : Array Int) (n : Nat) : Prop :=\n  list.size > 0 ∧ 0 < n ∧ n < list.size", "vc-helpers": "", "vc-definitions": "def reverseToK (list : Array Int) (n : Nat) (h_precond : reverseToK_precond list n) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef reverseToK_postcond (list : Array Int) (n : Nat) (result : Array Int) (h_precond : reverseToK_precond list n) : Prop :=\n  result.toList = (list.toList.take n).reverse ++ (list.toList.drop n)\n\ntheorem reverseToK_spec_satisfied (list : Array Int) (n : Nat) (h_precond : reverseToK_precond list n) :\n    reverseToK_postcond list n (reverseToK list n h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0117", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_728", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef addList_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  arr1.size = arr2.size ∧ (∀ i, i < arr1.size → -2147483648 ≤ arr1[i]! + arr2[i]! ∧ arr1[i]! + arr2[i]! ≤ 2147483647)", "vc-helpers": "", "vc-definitions": "def addList (arr1 : Array Int) (arr2 : Array Int) (h_precond : addList_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef addList_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : addList_precond arr1 arr2) : Prop :=\n  result.size = arr1.size ∧ (∀ i, i < result.size → result[i]! = arr1[i]! + arr2[i]!)\n\ntheorem addList_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : addList_precond arr1 arr2) :\n    addList_postcond arr1 arr2 (addList arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0118", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_732", "vc-description": "", "vc-preamble": "/- Lean imports and setup -/\n\n/- Helper specification functions -/\n@[reducible, simp]\ndef isSpaceCommaDotSpec (c : Char) : Bool :=\n  (c = ' ') ∨ (c = ',') ∨ (c = '.')\n\n@[reducible, simp]\ndef innerExprReplaceWithColon (str1 : Array Char) (k : Nat) : Char :=\n  if isSpaceCommaDotSpec str1[k]! then ':' else str1[k]!\n\n/- Precondition for replaceWithColon -/\n@[reducible, simp]\ndef replaceWithColon_precond (str1 : Array Char) : Prop := True", "vc-helpers": "", "vc-definitions": "def replaceWithColon (str1 : Array Char) (h_precond : replaceWithColon_precond (str1)) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceWithColon_postcond (str1 : Array Char) (result : Array Char) (h_precond : replaceWithColon_precond (str1)) : Prop :=\n  str1.size = result.size ∧ \n  (∀ k : Nat, k < result.size → result[k]! = innerExprReplaceWithColon str1 k)\n\ntheorem replaceWithColon_spec_satisfied (str1 : Array Char) (h_precond : replaceWithColon_precond (str1)) :\n    replaceWithColon_postcond (str1) (replaceWithColon (str1) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0119", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_733", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findFirstOccurrence_precond (arr : Array Int) (target : Int) : Prop :=\n  ∀ i j, i < j → j < arr.size → arr[i]! ≤ arr[j]!", "vc-helpers": "", "vc-definitions": "def findFirstOccurrence (arr : Array Int) (target : Int) (h_precond : findFirstOccurrence_precond arr target) : Option Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findFirstOccurrence_postcond (arr : Array Int) (target : Int) (index : Option Nat) (h_precond : findFirstOccurrence_precond arr target) : Prop :=\n  match index with\n  | some idx => idx < arr.size ∧ (∀ k, k < idx → arr[k]! ≠ target) ∧ arr[idx]! = target\n  | none => ∀ k, k < arr.size → arr[k]! ≠ target\n\ntheorem findFirstOccurrence_spec_satisfied (arr : Array Int) (target : Int) (h_precond : findFirstOccurrence_precond arr target) :\n    findFirstOccurrence_postcond arr target (findFirstOccurrence arr target h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0120", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_741", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef allCharactersSame_precond (charArr : Array Char) : Prop :=\n  charArr.size > 0", "vc-helpers": "", "vc-definitions": "def allCharactersSame (charArr : Array Char) (h_precond : allCharactersSame_precond (charArr)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef allCharactersSame_postcond (charArr : Array Char) (result: Bool) (h_precond : allCharactersSame_precond (charArr)) : Prop :=\n  (∀ i, 1 ≤ i ∧ i < charArr.size → charArr[0]! = charArr[i]!) ↔ result\n\ntheorem allCharactersSame_spec_satisfied (charArr: Array Char) (h_precond : allCharactersSame_precond (charArr)) :\n    allCharactersSame_postcond (charArr) (allCharactersSame (charArr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0121", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_743", "vc-description": "", "vc-preamble": "-- Specification function for rotation split point\ndef rotationSplit (len : Nat) (n : Nat) : Int :=\n  len - (n % len)\n\n-- Precondition for rotate_right function\n@[reducible, simp]\ndef rotateRight_precond (list : Array UInt32) (n : Nat) : Prop :=\n  list.size > 0", "vc-helpers": "", "vc-definitions": "def rotateRight (list : Array UInt32) (n : Nat) (h_precond : rotateRight_precond list n) : Array UInt32 :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef rotateRight_postcond (list : Array UInt32) (n : Nat) (newList : Array UInt32) (h_precond : rotateRight_precond list n) : Prop :=\n  newList.size = list.size ∧ \n  newList.toList = (list.toList.drop (rotationSplit list.size n).natAbs) ++ (list.toList.take (rotationSplit list.size n).natAbs)\n\ntheorem rotateRight_spec_satisfied (list : Array UInt32) (n : Nat) (h_precond : rotateRight_precond list n) :\n    rotateRight_postcond list n (rotateRight list n h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0122", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_755", "vc-description": "", "vc-preamble": "/- Helper spec function to find minimum value in a sequence -/\ndef minSpec (seq : List Int) : Int :=\n  if h : seq.length = 1 then\n    seq[0]!\n  else if seq.length = 0 then\n    0\n  else\n    let laterMin := minSpec (seq.tail)\n    if seq[0]! ≤ laterMin then\n      seq[0]!\n    else\n      laterMin\ntermination_by seq.length\n\n@[reducible, simp]\ndef secondSmallest_precond (numbers : Array Int) :=\n  numbers.size ≥ 2", "vc-helpers": "", "vc-definitions": "def secondSmallest (numbers : Array Int) (h_precond : secondSmallest_precond (numbers)) : (Nat × Nat) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef secondSmallest_postcond (numbers : Array Int) (indices : Nat × Nat) (h_precond : secondSmallest_precond (numbers)) :=\n  (∀ k : Nat, k < numbers.size → k ≠ indices.1 → numbers[indices.1]! = minSpec (numbers.toList) → numbers[k]! ≥ numbers[indices.2]!) ∧\n  (∃ k : Nat, k < numbers.size ∧ k ≠ indices.1 ∧ numbers[k]! = numbers[indices.2]!)\n\ntheorem secondSmallest_spec_satisfied (numbers : Array Int) (h_precond : secondSmallest_precond (numbers)) :\n    secondSmallest_postcond (numbers) (secondSmallest (numbers) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0123", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_760", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef hasOnlyOneDistinctElement_precond (arr : Array Int) := True", "vc-helpers": "", "vc-definitions": "def hasOnlyOneDistinctElement (arr : Array Int) (h_precond : hasOnlyOneDistinctElement_precond (arr)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasOnlyOneDistinctElement_postcond (arr : Array Int) (result: Bool) (h_precond : hasOnlyOneDistinctElement_precond (arr)) :=\n  (∀ i, 1 ≤ i → i < arr.size → arr[0]! = arr[i]!) ↔ result\n\ntheorem hasOnlyOneDistinctElement_spec_satisfied (arr: Array Int) (h_precond : hasOnlyOneDistinctElement_precond (arr)) :\n    hasOnlyOneDistinctElement_postcond (arr) (hasOnlyOneDistinctElement (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0124", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_764", "vc-description": "", "vc-preamble": "/- Helper function to check if a character is a digit -/\ndef isDigit (c : Char) : Bool :=\n  (c.val >= 48) ∧ (c.val <= 57)\n\n/- Recursive function to count digits in a sequence of characters -/\ndef countDigitsRecursively (seq : List Char) : Nat :=\n  match seq with\n  | [] => 0\n  | h :: t => countDigitsRecursively t + if isDigit h then 1 else 0\ntermination_by seq.length\n\n@[reducible, simp]\ndef countDigits_precond (text : Array Char) : Prop := True", "vc-helpers": "", "vc-definitions": "def countDigits (text : Array Char) (h_precond : countDigits_precond text) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef countDigits_postcond (text : Array Char) (count : Nat) (h_precond : countDigits_precond text) : Prop :=\n  count ≤ text.size ∧ countDigitsRecursively text.toList = count\n\ntheorem countDigits_spec_satisfied (text : Array Char) (h_precond : countDigits_precond text) :\n    countDigits_postcond text (countDigits text h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0125", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_769", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef difference_precond (arr1 : Array Int) (arr2 : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def difference (arr1 : Array Int) (arr2 : Array Int) (h_precond : difference_precond arr1 arr2) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef difference_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Array Int) (h_precond : difference_precond arr1 arr2) :=\n  (∀ i, i < arr1.size → ¬(arr2.toList.contains arr1[i]!) → result.toList.contains arr1[i]!) ∧\n  (∀ i, i < arr2.size → ¬(arr1.toList.contains arr2[i]!) → result.toList.contains arr2[i]!) ∧\n  (∀ i j, i < j → j < result.size → result[i]! ≠ result[j]!)\n\ntheorem difference_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : difference_precond arr1 arr2) :\n    difference_postcond arr1 arr2 (difference arr1 arr2 h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0126", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_775", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isOddAtOddIndex_precond (arr : Array Nat) : Prop := True", "vc-helpers": "", "vc-definitions": "def isOddAtOddIndex (arr : Array Nat) (h_precond : isOddAtOddIndex_precond arr) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isOddAtOddIndex_postcond (arr : Array Nat) (result: Bool) (h_precond : isOddAtOddIndex_precond arr) :=\n  (∀ i, i < arr.size → (i % 2 = arr[i]! % 2)) ↔ result\n\ntheorem isOddAtOddIndex_spec_satisfied (arr: Array Nat) (h_precond : isOddAtOddIndex_precond arr) :\n    isOddAtOddIndex_postcond arr (isOddAtOddIndex arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0127", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_790", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isEvenAtEvenIndex_precond (arr : Array Nat) := True", "vc-helpers": "", "vc-definitions": "def isEvenAtEvenIndex (arr : Array Nat) (h_precond : isEvenAtEvenIndex_precond (arr)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isEvenAtEvenIndex_postcond (arr : Array Nat) (result: Bool) (h_precond : isEvenAtEvenIndex_precond (arr)) :=\n  (∀ i, i < arr.size → ((i % 2) = (arr[i]! % 2))) ↔ result\n\ntheorem isEvenAtEvenIndex_spec_satisfied (arr: Array Nat) (h_precond : isEvenAtEvenIndex_precond (arr)) :\n    isEvenAtEvenIndex_postcond (arr) (isEvenAtEvenIndex (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0128", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_798", "vc-description": "", "vc-preamble": "/- Helper function to compute sum of a list recursively -/\ndef sumTo : List Int → Int\n  | [] => 0  \n  | xs => \n    if h : xs = [] then 0 \n    else \n      have h_len : xs.length - 1 < xs.length := by\n        have : xs.length > 0 := by\n          cases xs with\n          | nil => simp at h\n          | cons _ _ => simp\n        omega\n      sumTo (xs.dropLast) + xs.getLast!\ntermination_by xs => xs.length\n\n@[reducible, simp]\ndef sum_precond (arr : Array Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def sum (arr : Array Int) (h_precond : sum_precond arr) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef sum_postcond (arr : Array Int) (result : Int) (h_precond : sum_precond arr) : Prop :=\n  sumTo (arr.toList) = result\n\ntheorem sum_spec_satisfied (arr : Array Int) (h_precond : sum_precond arr) :\n    sum_postcond arr (sum arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0129", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_804", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isEven (n : Nat) : Bool :=\n  n % 2 = 0\n\n@[reducible, simp]\ndef isProductEven_precond (arr : Array Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def isProductEven (arr : Array Nat) (h_precond : isProductEven_precond (arr)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isProductEven_postcond (arr : Array Nat) (result: Bool) (h_precond : isProductEven_precond (arr)) :=\n  result ↔ (∃ k, k < arr.size ∧ isEven (arr[k]!))\n\ntheorem isProductEven_spec_satisfied (arr: Array Nat) (h_precond : isProductEven_precond (arr)) :\n    isProductEven_postcond (arr) (isProductEven (arr) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0130", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_807", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef findFirstOdd_precond (arr : Array UInt32) : Prop := True\n\n@[reducible, simp]\ndef checkFindFirstOdd (arr : Array UInt32) (index : Option Nat) : Prop :=\n  match index with\n  | some idx => \n    (∀ i, i < idx → arr[i]! % 2 = 0) ∧ arr[idx]! % 2 ≠ 0\n  | none => \n    ∀ k, k < arr.size → arr[k]! % 2 = 0", "vc-helpers": "", "vc-definitions": "def findFirstOdd (arr : Array UInt32) (h_precond : findFirstOdd_precond arr) : Option Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef findFirstOdd_postcond (arr : Array UInt32) (index : Option Nat) (h_precond : findFirstOdd_precond arr) : Prop :=\n  checkFindFirstOdd arr index\n\ntheorem findFirstOdd_spec_satisfied (arr : Array UInt32) (h_precond : findFirstOdd_precond arr) :\n    findFirstOdd_postcond arr (findFirstOdd arr h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0131", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_808", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef containsK_precond (arr : Array Int) (k : Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def containsK (arr : Array Int) (k : Int) (h_precond : containsK_precond (arr) (k)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef containsK_postcond (arr : Array Int) (k : Int) (result: Bool) (h_precond : containsK_precond (arr) (k)) :=\n  (∃ i : Nat, i < arr.size ∧ arr[i]! = k) ↔ result\n\ntheorem containsK_spec_satisfied (arr: Array Int) (k: Int) (h_precond : containsK_precond (arr) (k)) :\n    containsK_postcond (arr) (k) (containsK (arr) (k) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0132", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_task_id_809", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isSmaller_precond (arr1 : Array Int) (arr2 : Array Int) :=\n  arr1.size = arr2.size", "vc-helpers": "", "vc-definitions": "def isSmaller (arr1 : Array Int) (arr2 : Array Int) (h_precond : isSmaller_precond (arr1) (arr2)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSmaller_postcond (arr1 : Array Int) (arr2 : Array Int) (result: Bool) (h_precond : isSmaller_precond (arr1) (arr2)) :=\n  (∀ i, i < arr1.size → arr1[i]! > arr2[i]!) ↔ result\n\ntheorem isSmaller_spec_satisfied (arr1: Array Int) (arr2: Array Int) (h_precond : isSmaller_precond (arr1) (arr2)) :\n    isSmaller_postcond (arr1) (arr2) (isSmaller (arr1) (arr2) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0133", "language": "lean", "source": "verified_cogen", "source_id": "proofsynthesis_trigger", "vc-description": "", "vc-preamble": "-- Spec function f translated from Verus\ndef f (seq : List Nat) (i : Int) : Prop :=\n  seq[i.natAbs]! = i + 2\n\n@[reducible, simp]\ndef getElementCheckProperty_precond (arr : Array Nat) (i : Nat) : Prop :=\n  arr.size > 0 ∧ 0 < i ∧ i < arr.size ∧ (∀ i : Int, f arr.toList i)", "vc-helpers": "", "vc-definitions": "def getElementCheckProperty (arr : Array Nat) (i : Nat) (h_precond : getElementCheckProperty_precond arr i) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef getElementCheckProperty_postcond (arr : Array Nat) (i : Nat) (ret : Nat) (h_precond : getElementCheckProperty_precond arr i) : Prop :=\n  ret = i + 2 ∧ ret = arr[i]!\n\ntheorem getElementCheckProperty_spec_satisfied (arr : Array Nat) (i : Nat) (h_precond : getElementCheckProperty_precond arr i) :\n    getElementCheckProperty_postcond arr i (getElementCheckProperty arr i h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0134", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_abs", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef abs_precond (x : Int) : Prop :=\n  x ≠ Int.negSucc 2147483647", "vc-helpers": "", "vc-definitions": "def abs (x : Int) (h_precond : abs_precond x) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef abs_postcond (x : Int) (result : Int) (h_precond : abs_precond x) : Prop :=\n  result ≥ 0 ∧ (result = x ∨ result = -x)\n\ntheorem abs_spec_satisfied (x : Int) (h_precond : abs_precond x) :\n    abs_postcond x (abs x h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0135", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_arithmetic_weird", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef arithmeticWeird_precond : Prop := True", "vc-helpers": "", "vc-definitions": "def arithmeticWeird (h_precond : arithmeticWeird_precond) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arithmeticWeird_postcond (result: Int) (h_precond : arithmeticWeird_precond) :=\n  result < 10\n\ntheorem arithmeticWeird_spec_satisfied (h_precond : arithmeticWeird_precond) :\n    arithmeticWeird_postcond (arithmeticWeird h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0136", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_array_append", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef arrayAppend_precond (a : Array Int) (b : Int) := True", "vc-helpers": "", "vc-definitions": "def arrayAppend (a : Array Int) (b : Int) (h_precond : arrayAppend_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arrayAppend_postcond (a : Array Int) (b : Int) (result: Array Int) (h_precond : arrayAppend_precond (a) (b)) :=\n  result.size = a.size + 1 ∧ (∀ i, i < result.size → (if i < a.size then result[i]! = a[i]! else result[i]! = b))\n\ntheorem arrayAppend_spec_satisfied (a: Array Int) (b: Int) (h_precond : arrayAppend_precond (a) (b)) :\n    arrayAppend_postcond (a) (b) (arrayAppend (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0137", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_array_concat", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef arrayConcat_precond (a : Array Int) (b : Array Int) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def arrayConcat (a : Array Int) (b : Array Int) (h_precond : arrayConcat_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arrayConcat_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arrayConcat_precond (a) (b)) :=\n  result.size = a.size + b.size ∧\n  (∀ i, 0 ≤ i ∧ i < a.size → result[i]! = a[i]!) ∧\n  (∀ i, 0 ≤ i ∧ i < b.size → result[i + a.size]! = b[i]!)\n\ntheorem arrayConcat_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayConcat_precond (a) (b)) :\n    arrayConcat_postcond (a) (b) (arrayConcat (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0138", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_array_copy", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef arrayCopy_precond (a : Array Int) := True", "vc-helpers": "", "vc-definitions": "def arrayCopy (a : Array Int) (h_precond : arrayCopy_precond (a)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arrayCopy_postcond (a : Array Int) (result: Array Int) (h_precond : arrayCopy_precond (a)) :=\n  result.size = a.size ∧ (∀ i, i < a.size → result[i]! = a[i]!)\n\ntheorem arrayCopy_spec_satisfied (a: Array Int) (h_precond : arrayCopy_precond (a)) :\n    arrayCopy_postcond (a) (arrayCopy (a) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0139", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_array_product", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef arrayProduct_precond (a : Array Int) (b : Array Int) : Prop :=\n  a.size = b.size", "vc-helpers": "", "vc-definitions": "def arrayProduct (a : Array Int) (b : Array Int) (h_precond : arrayProduct_precond (a) (b)) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef arrayProduct_postcond (a : Array Int) (b : Array Int) (result: Array Int) (h_precond : arrayProduct_precond (a) (b)) :=\n  result.size = a.size ∧ (∀ i, i < a.size → result[i]! = (a[i]! * b[i]!))\n\ntheorem arrayProduct_spec_satisfied (a: Array Int) (b: Array Int) (h_precond : arrayProduct_precond (a) (b)) :\n    arrayProduct_postcond (a) (b) (arrayProduct (a) (b) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0140", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_barrier", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef barrier_precond (arr : Array Int) (p : Nat) :=\n  arr.size > 0 ∧ p < arr.size", "vc-helpers": "", "vc-definitions": "def barrier (arr : Array Int) (p : Nat) (h_precond : barrier_precond arr p) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef barrier_postcond (arr : Array Int) (p : Nat) (result : Bool) (h_precond : barrier_precond arr p) :=\n  (∀ k l, k ≤ p ∧ p < l ∧ l < arr.size → arr[k]! < arr[l]!) ↔ result\n\ntheorem barrier_spec_satisfied (arr : Array Int) (p : Nat) (h_precond : barrier_precond arr p) :\n    barrier_postcond arr p (barrier arr p h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0141", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_binary_search", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef binarySearch_precond (arr : Array Int) (target : Int) : Prop :=\n  ∀ i j, i < j → j < arr.size → arr[i]! ≤ arr[j]!", "vc-helpers": "", "vc-definitions": "def binarySearch (arr : Array Int) (target : Int) (h_precond : binarySearch_precond arr target) : Option Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef binarySearch_postcond (arr : Array Int) (target : Int) (result : Option Nat) (h_precond : binarySearch_precond arr target) : Prop :=\n  match result with\n  | some index => arr[index]! = target ∧ arr.size > 0 ∧ index < arr.size\n  | none => ∀ i, i < arr.size → arr[i]! ≠ target\n\ntheorem binarySearch_spec_satisfied (arr : Array Int) (target : Int) (h_precond : binarySearch_precond arr target) :\n    binarySearch_postcond arr target (binarySearch arr target h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0142", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_binary_search_recursive", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef binarySearchRecursive_precond (v : Array Int) (elem : Int) (c : Nat) (f : Nat) :=\n  v.size ≤ 100000 ∧ \n  (∀ i j, i < j ∧ j < v.size → v[i]! ≤ v[j]!) ∧\n  c ≤ f + 1 ∧ f + 1 ≤ v.size ∧\n  (∀ k, k < c → v[k]! ≤ elem) ∧\n  (∀ k, f < k ∧ k < v.size → v[k]! > elem)", "vc-helpers": "", "vc-definitions": "def binarySearchRecursive (v : Array Int) (elem : Int) (c : Nat) (f : Nat) (h_precond : binarySearchRecursive_precond v elem c f) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef binarySearchRecursive_postcond (v : Array Int) (elem : Int) (c : Nat) (f : Nat) (p : Int) (_ : binarySearchRecursive_precond v elem c f) :=\n  -1 ≤ p ∧ p < v.size ∧\n  (∀ u, u ≤ p → v[u.natAbs]! ≤ elem) ∧\n  (∀ w, p < w ∧ w < v.size → v[w.natAbs]! > elem)\n\ntheorem binarySearchRecursive_spec_satisfied (v : Array Int) (elem : Int) (c : Nat) (f : Nat) (h_precond : binarySearchRecursive_precond v elem c f) :\n    binarySearchRecursive_postcond v elem c f (binarySearchRecursive v elem c f h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0143", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_cubes", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef cubes_precond (len : Nat) : Prop := True", "vc-helpers": "", "vc-definitions": "def cubes (len : Nat) (h_precond : cubes_precond len) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef cubes_postcond (len : Nat) (result : Array Int) (h_precond : cubes_precond len) : Prop :=\n  result.size = len ∧ (∀ i : Nat, i < len → result[i]! = i * i * i)\n\ntheorem cubes_spec_satisfied (len : Nat) (h_precond : cubes_precond len) :\n    cubes_postcond len (cubes len h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0144", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_has_close_elements", "vc-description": "", "vc-preamble": "/- Specification function for absolute value -/\ndef absSpec (i : Int) : Int :=\n  if i < 0 then -i else i\n\n/- Precondition for hasCloseElements function -/\n@[reducible, simp]\ndef hasCloseElements_precond (numbers : Array Int) (threshold : Int) : Prop :=\n  threshold > 0 ∧ \n  ∀ i j, 0 ≤ i ∧ i < numbers.size ∧ 0 ≤ j ∧ j < numbers.size → \n    numbers[i]! - numbers[j]! < 2147483647 ∧ -(numbers[i]! - numbers[j]!) < 2147483647", "vc-helpers": "", "vc-definitions": "def hasCloseElements (numbers : Array Int) (threshold : Int) (h_precond : hasCloseElements_precond numbers threshold) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasCloseElements_postcond (numbers : Array Int) (threshold : Int) (flag : Bool) (h_precond : hasCloseElements_precond numbers threshold) : Prop :=\n  flag = (∃ i j, 0 ≤ i ∧ 0 ≤ j ∧ i < numbers.size ∧ j < numbers.size ∧ i ≠ j ∧ absSpec (numbers[i]! - numbers[j]!) < threshold)\n\ntheorem hasCloseElements_spec_satisfied (numbers : Array Int) (threshold : Int) (h_precond : hasCloseElements_precond numbers threshold) :\n    hasCloseElements_postcond numbers threshold (hasCloseElements numbers threshold h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0145", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_has_only_one_distinct_element", "vc-description": "", "vc-preamble": "/- No preconditions required for this function -/", "vc-helpers": "", "vc-definitions": "def hasOnlyOneDistinctElement (a : Array Int) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef hasOnlyOneDistinctElement_postcond (a : Array Int) (result: Bool) :=\n  (result → (∀ i j, i < a.size → j < a.size → a[i]! = a[j]!)) ∧\n  (¬result → (∃ i j, i < a.size ∧ j < a.size ∧ a[i]! ≠ a[j]!))\n\ntheorem hasOnlyOneDistinctElement_spec_satisfied (a: Array Int) :\n    hasOnlyOneDistinctElement_postcond (a) (hasOnlyOneDistinctElement (a)) := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0146", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_index_wise_addition", "vc-description": "", "vc-preamble": "-- Precondition definitions\n@[reducible, simp]\ndef indexWiseAddition_precond (a : Array (Array Int)) (b : Array (Array Int)) : Prop :=\n  a.size = b.size ∧\n  (∀ i, i < a.size → a[i]!.size = b[i]!.size) ∧\n  (∀ i, i < a.size → ∀ j, j < a[i]!.size → a[i]![j]! + b[i]![j]! ≤ 2147483647) ∧\n  (∀ i, i < a.size → ∀ j, j < a[i]!.size → a[i]![j]! + b[i]![j]! ≥ -2147483648)", "vc-helpers": "", "vc-definitions": "def indexWiseAddition (a : Array (Array Int)) (b : Array (Array Int)) (h_precond : indexWiseAddition_precond a b) : Array (Array Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef indexWiseAddition_postcond (a : Array (Array Int)) (b : Array (Array Int)) (c : Array (Array Int)) (h_precond : indexWiseAddition_precond a b) : Prop :=\n  c.size = a.size ∧\n  (∀ i, i < c.size → c[i]!.size = a[i]!.size) ∧\n  (∀ i, i < c.size → ∀ j, j < c[i]!.size → c[i]![j]! = a[i]![j]! + b[i]![j]!)\n\ntheorem indexWiseAddition_spec_satisfied (a : Array (Array Int)) (b : Array (Array Int)) (h_precond : indexWiseAddition_precond a b) :\n    indexWiseAddition_postcond a b (indexWiseAddition a b h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0147", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_integer_square_root", "vc-description": "", "vc-preamble": "@[reducible, simp]  \ndef integerSquareRoot_precond (n : Int) := n ≥ 1", "vc-helpers": "", "vc-definitions": "def integerSquareRoot (n : Int) (h_precond : integerSquareRoot_precond (n)) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef integerSquareRoot_postcond (n : Int) (result: Int) (h_precond : integerSquareRoot_precond (n)) :=\n  0 ≤ result * result ∧ result * result ≤ n ∧ n < (result + 1) * (result + 1)\n\ntheorem integerSquareRoot_spec_satisfied (n: Int) (h_precond : integerSquareRoot_precond (n)) :\n    integerSquareRoot_postcond (n) (integerSquareRoot (n) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0148", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_intersperse", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef intersperse_precond (numbers : Array Int) (delim : Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def intersperse (numbers : Array Int) (delim : Int) (h_precond : intersperse_precond numbers delim) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef intersperse_postcond (numbers : Array Int) (delim : Int) (res: Array Int) (h_precond : intersperse_precond numbers delim) : Prop :=\n  (numbers.size = 0 → res.size = 0) ∧ \n  (numbers.size ≠ 0 → res.size = 2 * numbers.size - 1) ∧\n  (∀ i, 0 ≤ i ∧ i < res.size ∧ i % 2 = 0 → res[i]! = numbers[i / 2]!) ∧\n  (∀ i, 0 ≤ i ∧ i < res.size ∧ i % 2 = 1 → res[i]! = delim)\n\ntheorem intersperse_spec_satisfied (numbers: Array Int) (delim: Int) (h_precond : intersperse_precond numbers delim) :\n    intersperse_postcond numbers delim (intersperse numbers delim h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0149", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_is_non_prime", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isNonPrime_precond (n : Nat) : Prop :=\n  n ≥ 2", "vc-helpers": "", "vc-definitions": "def isNonPrime (n : Nat) (h_precond : isNonPrime_precond (n)) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isNonPrime_postcond (n : Nat) (result: Bool) (h_precond : isNonPrime_precond (n)) : Prop :=\n  result = true ↔ ∃ k : Int, 2 ≤ k ∧ k < n ∧ (n : Int) % k = 0\n\ntheorem isNonPrime_spec_satisfied (n: Nat) (h_precond : isNonPrime_precond (n)) :\n    isNonPrime_postcond (n) (isNonPrime (n) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0150", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_is_sorted", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef isSorted_precond (lst : Array Int) :=\n  lst.size ≥ 1", "vc-helpers": "", "vc-definitions": "def isSorted (lst : Array Int) (h_precond : isSorted_precond lst) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef isSorted_postcond (lst : Array Int) (result : Bool) (h_precond : isSorted_precond lst) :=\n  (result → ∀ i j, 0 ≤ i ∧ i < j ∧ j < lst.size → lst[i]! ≤ lst[j]!) ∧\n  (¬result → ∃ i j, 0 ≤ i ∧ i < j ∧ j < lst.size ∧ lst[i]! > lst[j]!)\n\ntheorem isSorted_spec_satisfied (lst : Array Int) (h_precond : isSorted_precond lst) :\n    isSorted_postcond lst (isSorted lst h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0151", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_largest_prime_factor", "vc-description": "", "vc-preamble": "/- Specification predicate to check if a number is prime -/\n@[reducible, simp]\ndef isPrimePred (n : Nat) : Prop :=\n  ∀ k : Nat, 2 ≤ k → k < n → n % k ≠ 0\n\n/- Precondition for largestPrimeFactor function -/\n@[reducible, simp]\ndef largestPrimeFactor_precond (n : Nat) : Prop :=\n  2 ≤ n ∧ n ≤ 4294967294", "vc-helpers": "", "vc-definitions": "def largestPrimeFactor (n : Nat) (h_precond : largestPrimeFactor_precond n) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef largestPrimeFactor_postcond (n : Nat) (result : Nat) (_ : largestPrimeFactor_precond n) : Prop :=\n  1 ≤ result ∧ result ≤ n ∧ (result = 1 ∨ (result > 1 ∧ isPrimePred result))\n\ntheorem largestPrimeFactor_spec_satisfied (n : Nat) (h_precond : largestPrimeFactor_precond n) :\n    largestPrimeFactor_postcond n (largestPrimeFactor n h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0152", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_last_position", "vc-description": "", "vc-preamble": "/- Lean 4 version of last_position function for finding the last occurrence of an element in an array -/\n\n@[reducible, simp]\ndef lastPosition_precond (a : Array Int) (elem : Int) :=\n  0 < a.size ∧ a.size < 100000 ∧ (∃ i, i < a.size ∧ a[i]! = elem)", "vc-helpers": "", "vc-definitions": "def lastPosition (a : Array Int) (elem : Int) (h_precond : lastPosition_precond a elem) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef lastPosition_postcond (a : Array Int) (elem : Int) (result: Nat) (h_precond : lastPosition_precond a elem) :=\n  result < a.size ∧ (∀ i, result < i ∧ i < a.size → a[i]! ≠ elem) ∧ a[result]! = elem\n\ntheorem lastPosition_spec_satisfied (a: Array Int) (elem: Int) (h_precond : lastPosition_precond a elem) :\n    lastPosition_postcond a elem (lastPosition a elem h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0153", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_max_array", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef maxArray_precond (nums : Array Int) := \n  nums.size ≥ 1", "vc-helpers": "", "vc-definitions": "def maxArray (nums : Array Int) (h_precond : maxArray_precond nums) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxArray_postcond (nums : Array Int) (idx : Nat) (h_precond : maxArray_precond nums) :=\n  0 ≤ idx ∧ idx < nums.size ∧ (∀ i, i < nums.size → nums[i]! ≤ nums[idx]!)\n\ntheorem maxArray_spec_satisfied (nums : Array Int) (h_precond : maxArray_precond nums) :\n    maxArray_postcond nums (maxArray nums h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0154", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_max_dafny_lsp", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef maxDafnyLsp_precond (a : Array Int) := a.size > 0", "vc-helpers": "", "vc-definitions": "def maxDafnyLsp (a : Array Int) (h_precond : maxDafnyLsp_precond (a)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxDafnyLsp_postcond (a : Array Int) (x: Nat) (h_precond : maxDafnyLsp_precond (a)) :=\n  0 ≤ x ∧ x < a.size ∧ (∀ k, 0 ≤ k ∧ k < a.size → a[k]! ≤ a[x]!)\n\ntheorem maxDafnyLsp_spec_satisfied (a: Array Int) (h_precond : maxDafnyLsp_precond (a)) :\n    maxDafnyLsp_postcond (a) (maxDafnyLsp (a) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0155", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_remove_duplicates", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef removeDuplicates_precond (a : Array Int) := a.size ≥ 1\n\ndef inArray (a : Array Int) (x : Int) : Prop :=\n  ∃ i, i < a.size ∧ a[i]! = x", "vc-helpers": "", "vc-definitions": "def removeDuplicates (a : Array Int) (h_precond : removeDuplicates_precond a) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeDuplicates_postcond (a : Array Int) (result: Array Int) (h_precond : removeDuplicates_precond a) :=\n  (∀ i, i < result.size → inArray a result[i]!) ∧ \n  (∀ i j, i < j → j < result.size → result[i]! ≠ result[j]!)\n\ntheorem removeDuplicates_spec_satisfied (a: Array Int) (h_precond : removeDuplicates_precond a) :\n    removeDuplicates_postcond a (removeDuplicates a h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0156", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_remove_element", "vc-description": "", "vc-preamble": "/- Precondition definition for removeElement -/\n@[reducible, simp]\ndef removeElement_precond (a : Array Int) (pos : Nat) :=\n  0 ≤ pos ∧ pos < a.size", "vc-helpers": "", "vc-definitions": "def removeElement (a : Array Int) (pos : Nat) (h_precond : removeElement_precond a pos) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeElement_postcond (a : Array Int) (pos : Nat) (result : Array Int) (h_precond : removeElement_precond a pos) :=\n  result.size = a.size - 1 ∧ \n  (∀ i, i < pos → result[i]! = a[i]!) ∧ \n  (∀ i, pos ≤ i ∧ i < result.size → result[i]! = a[i + 1]!)\n\ntheorem removeElement_spec_satisfied (a : Array Int) (pos : Nat) (h_precond : removeElement_precond a pos) :\n    removeElement_postcond a pos (removeElement a pos h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0157", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_remove_elements", "vc-description": "", "vc-preamble": "/- Helper function to check if an element exists in an array -/\n@[reducible, simp]\ndef inArray (a : Array Int) (x : Int) : Prop :=\n  ∃ i, i < a.size ∧ a[i]! = x\n\n@[reducible, simp]  \ndef removeElements_precond (a : Array Int) (b : Array Int) : Prop := \n  True", "vc-helpers": "", "vc-definitions": "def removeElements (a : Array Int) (b : Array Int) (h_precond : removeElements_precond a b) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef removeElements_postcond (a : Array Int) (b : Array Int) (c : Array Int) (h_precond : removeElements_precond a b) : Prop :=\n  (∀ k, k < c.size → inArray a c[k]! ∧ ¬inArray b c[k]!) ∧\n  (∀ i j, i < j ∧ j < c.size → c[i]! ≠ c[j]!)\n\ntheorem removeElements_spec_satisfied (a : Array Int) (b : Array Int) (h_precond : removeElements_precond a b) :\n    removeElements_postcond a b (removeElements a b h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0158", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_replace", "vc-description": "", "vc-preamble": "-- Precondition for replace function (no specific requirements in this case)\n@[reducible, simp]\ndef replace_precond (a : Array Int) (x : Int) (y : Int) := True", "vc-helpers": "", "vc-definitions": "def replace (a : Array Int) (x : Int) (y : Int) (h_precond : replace_precond a x y) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replace_postcond (a_old : Array Int) (x : Int) (y : Int) (a_new : Array Int) (h_precond : replace_precond a_old x y) :=\n  a_new.size = a_old.size ∧ \n  (∀ k, k < a_old.size → a_old[k]! = x → a_new[k]! = y) ∧\n  (∀ k, k < a_old.size → a_old[k]! ≠ x → a_new[k]! = a_old[k]!)\n\ntheorem replace_spec_satisfied (a_old : Array Int) (x : Int) (y : Int) (h_precond : replace_precond a_old x y) :\n    replace_postcond a_old x y (replace a_old x y h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0159", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_replace_chars", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef replaceChars_precond (s : Array Char) (old : Char) (new : Char) : Prop := True", "vc-helpers": "", "vc-definitions": "def replaceChars (s : Array Char) (old : Char) (new : Char) (h_precond : replaceChars_precond s old new) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef replaceChars_postcond (s : Array Char) (old : Char) (new : Char) (result: Array Char) (h_precond : replaceChars_precond s old new) : Prop :=\n  result.size = s.size ∧ \n  (∀ i, i < result.size → result[i]! = (if s[i]! = old then new else s[i]!))\n\ntheorem replaceChars_spec_satisfied (s: Array Char) (old: Char) (new: Char) (h_precond : replaceChars_precond s old new) :\n    replaceChars_postcond s old new (replaceChars s old new h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0160", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_reverse", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef reverse_precond (a : Array Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def reverse (a : Array Int) (h_precond : reverse_precond a) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef reverse_postcond (a : Array Int) (result: Array Int) (h_precond : reverse_precond a) : Prop :=\n  result.size = a.size ∧ (∀ i, i < result.size → result[i]! = a[a.size - 1 - i]!)\n\ntheorem reverse_spec_satisfied (a: Array Int) (h_precond : reverse_precond a) :\n    reverse_postcond a (reverse a h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0161", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_rolling_max", "vc-description": "", "vc-preamble": "-- Recursive function to compute maximum of a sequence\ndef seq_max (a : List Int) : Int :=\n  match a with\n  | [] => -2147483648  -- i32::MIN equivalent\n  | [x] => x\n  | x :: xs => max x (seq_max xs)\n\n@[reducible, simp]\ndef rollingMax_precond (numbers : Array Int) : Prop := True", "vc-helpers": "", "vc-definitions": "def rollingMax (numbers : Array Int) (h_precond : rollingMax_precond numbers) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef rollingMax_postcond (numbers : Array Int) (result : Array Int) (h_precond : rollingMax_precond numbers) : Prop :=\n  result.size = numbers.size ∧ \n  (∀ i, i < numbers.size → result[i]! = seq_max (numbers.toList.take (i + 1)))\n\ntheorem rollingMax_spec_satisfied (numbers : Array Int) (h_precond : rollingMax_precond numbers) :\n    rollingMax_postcond numbers (rollingMax numbers h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0162", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_smallest_list_length", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef smallestListLength_precond (lists : Array (Array Int)) :=\n  lists.size > 0", "vc-helpers": "", "vc-definitions": "def smallestListLength (lists : Array (Array Int)) (h_precond : smallestListLength_precond (lists)) : Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef smallestListLength_postcond (lists : Array (Array Int)) (result: Nat) (h_precond : smallestListLength_precond (lists)) :=\n  (∃ i, i < lists.size ∧ result = lists[i]!.size) ∧ \n  (∀ i, i < lists.size → result ≤ lists[i]!.size)\n\ntheorem smallestListLength_spec_satisfied (lists: Array (Array Int)) (h_precond : smallestListLength_precond (lists)) :\n    smallestListLength_postcond (lists) (smallestListLength (lists) h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0163", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_smallest_missing_number", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef smallestMissingNumber_precond (s : Array Int) :=\n  (∀ i j, 0 ≤ i → i < j → j < s.size → s[i]! ≤ s[j]!) ∧ \n  (∀ i, 0 ≤ i → i < s.size → s[i]! ≥ 0) ∧ \n  s.size ≤ 100000", "vc-helpers": "", "vc-definitions": "def smallestMissingNumber (s : Array Int) (h_precond : smallestMissingNumber_precond s) : Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef smallestMissingNumber_postcond (s : Array Int) (v : Int) (h_precond : smallestMissingNumber_precond s) :=\n  0 ≤ v ∧ \n  (∀ i, 0 ≤ i → i < s.size → s[i]! ≠ v) ∧ \n  (∀ k, 0 ≤ k → k < v → ∃ j, 0 ≤ j ∧ j < s.size ∧ s[j]! = k)\n\ntheorem smallestMissingNumber_spec_satisfied (s : Array Int) (h_precond : smallestMissingNumber_precond s) :\n    smallestMissingNumber_postcond s (smallestMissingNumber s h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0164", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_string_xor", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef stringXor_precond (a : Array Char) (b : Array Char) : Prop :=\n  a.size = b.size ∧ \n  (∀ i, i < a.size → a[i]! = '0' ∨ a[i]! = '1') ∧\n  (∀ i, i < b.size → b[i]! = '0' ∨ b[i]! = '1')", "vc-helpers": "", "vc-definitions": "def stringXor (a : Array Char) (b : Array Char) (h_precond : stringXor_precond a b) : Array Char :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef stringXor_postcond (a : Array Char) (b : Array Char) (result: Array Char) (h_precond : stringXor_precond a b) : Prop :=\n  result.size = a.size ∧ \n  (∀ i, i < result.size → result[i]! = '0' ∨ result[i]! = '1') ∧\n  (∀ i, i < result.size → result[i]! = (if a[i]! = b[i]! then '0' else '1'))\n\ntheorem stringXor_spec_satisfied (a: Array Char) (b: Array Char) (h_precond : stringXor_precond a b) :\n    stringXor_postcond a b (stringXor a b h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0165", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_two_sum", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef twoSum_precond (nums : Array Int) (target : Int) : Prop :=\n  nums.size ≥ 2 ∧ \n  (∃ i j, 0 ≤ i ∧ i < j ∧ j < nums.size ∧ nums[i]! + nums[j]! = target) ∧\n  (∀ i j, 0 ≤ i ∧ i < nums.size ∧ 0 ≤ j ∧ j < nums.size → \n    nums[i]! + nums[j]! ≤ 2147483647 ∧ nums[i]! + nums[j]! ≥ -2147483648)", "vc-helpers": "", "vc-definitions": "def twoSum (nums : Array Int) (target : Int) (h_precond : twoSum_precond nums target) : (Nat × Nat) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef twoSum_postcond (nums : Array Int) (target : Int) (result : Nat × Nat) (h_precond : twoSum_precond nums target) : Prop :=\n  let (i, j) := result\n  0 ≤ i ∧ i < nums.size ∧\n  0 ≤ j ∧ j < nums.size ∧\n  i ≠ j ∧\n  nums[i]! + nums[j]! = target\n\ntheorem twoSum_spec_satisfied (nums : Array Int) (target : Int) (h_precond : twoSum_precond nums target) :\n    twoSum_postcond nums target (twoSum nums target h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0166", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_two_way_sort", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef twoWaySort_precond (a : Array Bool) : Prop :=\n  a.size ≤ 100000", "vc-helpers": "", "vc-definitions": "def twoWaySort (a : Array Bool) (h_precond : twoWaySort_precond a) : Array Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef twoWaySort_postcond (a_old : Array Bool) (result : Array Bool) (h_precond : twoWaySort_precond a_old) : Prop :=\n  result.size = a_old.size ∧ \n  result.toList.count true = a_old.toList.count true ∧\n  result.toList.count false = a_old.toList.count false ∧\n  ∀ i j, 0 ≤ i → i < j → j < result.size → ¬result[i]! ∨ result[j]!\n\ntheorem twoWaySort_spec_satisfied (a : Array Bool) (h_precond : twoWaySort_precond a) :\n    twoWaySort_postcond a (twoWaySort a h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0167", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_unique", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef unique_precond (a : Array Int) : Prop :=\n  ∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def unique (a : Array Int) (h_precond : unique_precond a) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef unique_postcond (a : Array Int) (result: Array Int) (h_precond : unique_precond a) : Prop :=\n  ∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! < result[j]!\n\ntheorem unique_spec_satisfied (a : Array Int) (h_precond : unique_precond a) :\n    unique_postcond a (unique a h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0168", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_unique_better", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef uniqueBetter_precond (a : Array Int) : Prop :=\n  ∀ i j, 0 ≤ i ∧ i < j ∧ j < a.size → a[i]! ≤ a[j]!", "vc-helpers": "", "vc-definitions": "def uniqueBetter (a : Array Int) (h_precond : uniqueBetter_precond a) : Array Int :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef uniqueBetter_postcond (a : Array Int) (result: Array Int) (h_precond : uniqueBetter_precond a) :=\n  ∀ i j, 0 ≤ i ∧ i < j ∧ j < result.size → result[i]! < result[j]!\n\ntheorem uniqueBetter_spec_satisfied (a: Array Int) (h_precond : uniqueBetter_precond a) :\n    uniqueBetter_postcond a (uniqueBetter a h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0169", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_wip_max_segment_sum", "vc-description": "", "vc-preamble": "/- Recursive sum function for array segments -/\ndef sum (a : Array Int) (s : Int) (t : Int) : Int :=\n  if s < 0 ∨ s ≥ t ∨ t > a.size then\n    0\n  else\n    a[t.toNat - 1]! + sum a s (t - 1)\ntermination_by (t - s).toNat\n\n@[reducible, simp]\ndef maxSegmentSum_precond (a : Array Int) (s : Nat) (t : Nat) : Prop :=\n  True", "vc-helpers": "", "vc-definitions": "def maxSegmentSum (a : Array Int) (s : Nat) (t : Nat) (h_precond : maxSegmentSum_precond a s t) : Nat × Nat :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef maxSegmentSum_postcond (a : Array Int) (s : Nat) (t : Nat) (result : Nat × Nat) (h_precond : maxSegmentSum_precond a s t) : Prop :=\n  let (i, j) := result\n  (0 ≤ i ∧ i ≤ j ∧ j ≤ a.size) ∧ \n  (∀ k l : Int, 0 ≤ k ∧ k ≤ l ∧ l ≤ a.size → sum a k l ≤ sum a i j)\n\ntheorem maxSegmentSum_spec_satisfied (a : Array Int) (s : Nat) (t : Nat) (h_precond : maxSegmentSum_precond a s t) :\n    maxSegmentSum_postcond a s t (maxSegmentSum a s t h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0170", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_wip_mcontained", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef strictSorted (arr : Array Int) : Prop :=\n  ∀ k l : Nat, k < l → l < arr.size → arr[k]! < arr[l]!\n\n@[reducible, simp]\ndef mcontained_precond (v : Array Int) (w : Array Int) (n : Nat) (m : Nat) : Prop :=\n  n ≤ m ∧ strictSorted v ∧ strictSorted w ∧ v.size ≥ n ∧ w.size ≥ m", "vc-helpers": "", "vc-definitions": "def mcontained (v : Array Int) (w : Array Int) (n : Nat) (m : Nat) (h_precond : mcontained_precond v w n m) : Bool :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef mcontained_postcond (v : Array Int) (w : Array Int) (n : Nat) (m : Nat) (b : Bool) (h_precond : mcontained_precond v w n m) : Prop :=\n  b → (∀ k : Nat, k < n → (∃ j : Nat, j < m ∧ v[k]! = w[j]!))\n\ntheorem mcontained_spec_satisfied (v : Array Int) (w : Array Int) (n : Nat) (m : Nat) (h_precond : mcontained_precond v w n m) :\n    mcontained_postcond v w n m (mcontained v w n m h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
{"id": "LJ0171", "language": "lean", "source": "verified_cogen", "source_id": "rustbench_wip_transpose_matrix", "vc-description": "", "vc-preamble": "@[reducible, simp]\ndef transpose_precond (matrix : Array (Array Int)) : Prop :=\n  matrix.size > 0 ∧ \n  (∀ i, i < matrix.size → matrix[i]!.size = matrix[0]!.size) ∧\n  (∀ i, i < matrix.size → matrix[i]!.size = matrix.size)", "vc-helpers": "", "vc-definitions": "def transpose (matrix : Array (Array Int)) (h_precond : transpose_precond matrix) : Array (Array Int) :=\n  sorry", "vc-theorems": "@[reducible, simp]\ndef transpose_postcond (matrix : Array (Array Int)) (result : Array (Array Int)) (h_precond : transpose_precond matrix) : Prop :=\n  result.size = matrix[0]!.size ∧\n  (∀ i, i < result.size → result[i]!.size = matrix.size) ∧\n  (∀ i j, i < result.size → j < result[i]!.size → result[i]![j]! = matrix[j]![i]!)\n\ntheorem transpose_spec_satisfied (matrix : Array (Array Int)) (h_precond : transpose_precond matrix) :\n    transpose_postcond matrix (transpose matrix h_precond) h_precond := by\n  sorry", "vc-postamble": ""}
