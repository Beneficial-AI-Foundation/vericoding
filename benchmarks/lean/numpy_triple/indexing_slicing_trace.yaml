vc-description: |-
  /- 
  {
    "name": "numpy.trace",
    "category": "Diagonal operations",
    "description": "Return the sum along diagonals of the array",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.trace.html",
    "doc": "Return the sum along diagonals of the array.\n\nIf \`a\` is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements \`\`a[i,i+offset]\`\` for all i.\n\nIf \`a\` has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of \`a\` with \`axis1\` and \`axis2\` removed.\n\nParameters\n----------\na : array_like\n    Input array, from which the diagonals are taken.\noffset : int, optional\n    Offset of the diagonal from the main diagonal. Can be both positive and negative.\naxis1, axis2 : int, optional\n    Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken.\ndtype : dtype, optional\n    Determines the data-type of the returned array and of the accumulator where the elements are summed.\nout : ndarray, optional\n    Array into which the output is placed.\n\nReturns\n-------\nsum_along_diagonals : ndarray\n    If \`a\` is 2-D, the sum along the diagonal is returned. If \`a\` has larger dimensions, then an array of sums along diagonals is returned.",
  }
  -/

  /-  numpy.trace: Return the sum along diagonals of the array.
      
      For a 2D matrix, computes the sum of elements along the diagonal
      with an optional offset. For offset=0, it computes the sum of 
      elements a[i,i] for all valid i. For positive offset, it sums
      a[i,i+offset], and for negative offset, it sums a[i-offset,i].
      
      This implementation focuses on the 2D case as the core functionality.
  -/

  /-  Specification: numpy.trace returns the sum along the diagonal.
      
      For a 2D matrix with given offset, the trace is the sum of all
      elements a[i,j] where j = i + offset and both i,j are valid indices.
      
      Precondition: True
      Postcondition: Result equals the sum of diagonal elements with given offset
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def trace {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int) : Id Float :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem trace_spec {rows cols : Nat} (a : Vector (Vector Float cols) rows) (offset : Int) :
      ⦃⌜True⌝⦄
      trace a offset
      ⦃⇓result => ⌜
        -- The result is the sum of all valid diagonal elements with the given offset
        -- For offset ≥ 0: sum a[i][i+offset] for valid i where i+offset < cols
        -- For offset < 0: sum a[i-offset][i] for valid i where i-offset ≥ 0
        (if offset ≥ 0 then
          -- For non-negative offset: sum elements where row index i and column index i+offset are both valid
          ∃ (valid_indices : List (Fin rows × Fin cols)),
            (∀ ij ∈ valid_indices, ij.2.val = ij.1.val + offset.natAbs) ∧
            result = valid_indices.foldl (fun acc ij => acc + (a.get ij.1).get ij.2) 0
        else
          -- For negative offset: sum elements where row index i+|offset| and column index i are both valid
          ∃ (valid_indices : List (Fin rows × Fin cols)),
            (∀ ij ∈ valid_indices, ij.1.val = ij.2.val + offset.natAbs) ∧
            result = valid_indices.foldl (fun acc ij => acc + (a.get ij.1).get ij.2) 0)
      ⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
