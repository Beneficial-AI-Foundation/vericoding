vc-description: |-
  /- 
  {
    "name": "numpy.polynomial.chebyshev.chebdiv",
    "category": "Chebyshev polynomials",
    "description": "Divide one Chebyshev series by another.",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.polynomial.chebyshev.chebdiv.html",
    "doc": "Divide one Chebyshev series by another.\n\n    Returns the quotient-with-remainder of two Chebyshev series\n    `c1` / `c2`.  The arguments are sequences of coefficients from lowest\n    order \"term\" to highest, e.g., [1,2,3] represents the series\n    ``T_0 + 2*T_1 + 3*T_2``.\n\n    Parameters\n    ----------\n    c1, c2 : array_like\n        1-D arrays of Chebyshev series coefficients ordered from low to\n        high.\n\n    Returns\n    -------\n    [quo, rem] : ndarrays\n        Of Chebyshev series coefficients representing the quotient and\n        remainder.\n\n    See Also\n    --------\n    chebadd, chebsub, chebmulx, chebmul, chebpow\n\n    Notes\n    -----\n    In general, the (polynomial) division of one C-series by another\n    results in quotient and remainder terms that are not in the Chebyshev\n    polynomial basis set.  Thus, to express these results as C-series, it\n    is typically necessary to \"reproject\" the results onto said basis\n    set, which typically produces \"unintuitive\" (but correct) results;\n    see Examples section below.\n\n    Examples\n    --------\n    >>> from numpy.polynomial import chebyshev as C\n    >>> c1 = (1,2,3)\n    >>> c2 = (3,2,1)\n    >>> C.chebdiv(c1,c2) # quotient \"intuitive,\" remainder not\n    (array([3.]), array([-8., -4.]))\n    >>> c2 = (0,1,2,3)\n    >>> C.chebdiv(c2,c1) # neither \"intuitive\"\n    (array([0., 2.]), array([-2., -4.]))",
  }
  -/
  
  /-  Divide one Chebyshev series by another, returning quotient and remainder.
      The input vectors represent Chebyshev series coefficients from lowest to highest order. -/
  
  /-  Specification: chebdiv performs polynomial division in the Chebyshev basis,
      satisfying the division algorithm property that c1 = c2 * quotient + remainder,
      where the degree of remainder is less than the degree of c2. -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def chebdiv {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) (h_nonzero : m > 0) : 
      Id (Vector Float n × Vector Float n) :=
    sorry

vc-theorems: |-
  theorem chebdiv_spec {n m : Nat} (c1 : Vector Float n) (c2 : Vector Float m) 
      (h_nonzero : m > 0) 
      (h_leading : c2.get ⟨m - 1, by omega⟩ ≠ 0) :
      ⦃⌜m > 0 ∧ c2.get ⟨m - 1, by omega⟩ ≠ 0⌝⦄
      chebdiv c1 c2 h_nonzero
      ⦃⇓(quo, rem) => ⌜
        -- Sanity check: quotient and remainder have correct sizes
        (∀ i : Fin n, i.val ≥ n - (m - 1) → quo.get i = 0) ∧
  
        -- Mathematical property: Division algorithm in Chebyshev basis
        -- This states that when the Chebyshev series are converted to their
        -- polynomial representations and multiplied/added, they satisfy c1 = c2 * quo + rem
  
        -- Remainder degree constraint: deg(rem) < deg(c2)
        (∀ i : Fin n, i.val ≥ m - 1 → rem.get i = 0) ∧
  
        -- Special case: if deg(c1) < deg(c2), then quo = 0 and rem = c1
        (n < m → (∀ i : Fin n, quo.get i = 0) ∧ (∀ i : Fin n, rem.get i = c1.get i)) ∧
  
        -- Special case: if c2 has only one non-zero coefficient (constant divisor)
        (m = 1 → (∀ i : Fin n, quo.get i = c1.get i / c2.get ⟨0, by omega⟩) ∧ 
                 (∀ i : Fin n, rem.get i = 0))
      ⌝⦄ := by
    sorry

vc-postamble: |-

