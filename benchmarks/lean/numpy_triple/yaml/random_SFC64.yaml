vc-description: |-
  /- 
  {
    "name": "numpy.random.SFC64",
    "description": "BitGenerator for the SFC64 pseudo-random number generator",
    "url": "https://numpy.org/doc/stable/reference/random/bit_generators/sfc64.html",
    "doc": "SFC64(seed=None)\n\nBitGenerator for the SFC64 pseudo-random number generator.\n\nSFC64 is a chaotic RNG that uses a 256-bit state. It is very fast and appears to be very robust to statistical tests.\n\nParameters:\n- seed : None, int, array_like[ints], SeedSequence, BitGenerator, Generator\n    A seed to initialize the BitGenerator",
  }
  -/
  
  /-  SFC64 pseudo-random number generator with 256-bit state -/
  
  /-  Specification: SFC64 initializes a 256-bit state from seed -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do
  
  /-- SFC64 state containing 256 bits split into four 64-bit words -/
  structure SFC64State where
    a : UInt64
    b : UInt64  
    c : UInt64
    counter : UInt64

vc-helpers: |-

vc-definitions: |-
  def sfc64 (seed : Option UInt64) : Id SFC64State :=
    sorry

vc-theorems: |-
  theorem sfc64_spec (seed : Option UInt64) :
      ⦃⌜True⌝⦄
      sfc64 seed
      ⦃⇓state => ⌜(seed.isNone → state.a = 0 ∧ state.b = 0 ∧ state.c = 0 ∧ state.counter = 0) ∧
                   (seed.isSome → ∃ s : UInt64, seed = some s ∧ 
                     (state.a ≠ 0 ∨ state.b ≠ 0 ∨ state.c ≠ 0 ∨ state.counter ≠ 0)) ∧
                   (∀ s1 s2 : UInt64, s1 ≠ s2 → 
                     ∃ state1 state2 : SFC64State, 
                       (sfc64 (some s1)).run = state1 ∧ (sfc64 (some s2)).run = state2 ∧
                       (state1.a ≠ state2.a ∨ state1.b ≠ state2.b ∨ state1.c ≠ state2.c ∨ state1.counter ≠ state2.counter))⌝⦄ := by
    sorry

vc-postamble: |-

