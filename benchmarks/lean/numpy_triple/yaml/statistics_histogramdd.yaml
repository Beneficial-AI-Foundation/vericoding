vc-description: |-
  /- 
  {
    "name": "numpy.histogramdd",
    "category": "Histograms",
    "description": "Compute the multidimensional histogram of some data",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.histogramdd.html",
    "doc": "numpy.histogramdd(sample, bins=10, range=None, density=None, weights=None)\n\nCompute the multidimensional histogram of some data.\n\nParameters\n----------\nsample : (N, D) array, or (N, D) list of arrays\n    The data to be histogrammed.\n    Note the unusual interpretation of sample when an array_like:\n    * When an array, each row is a coordinate in a D-dimensional space - such as histogramdd(np.array([p1, p2, p3])).\n    * When a list of arrays, each array is the list of values for single coordinate - such as histogramdd([X, Y, Z]).\nbins : sequence or int, optional\n    The bin specification:\n    * A sequence of arrays describing the monotonically increasing bin edges along each dimension.\n    * The number of bins for each dimension (nx, ny, ... =bins)\n    * The number of bins for all dimensions (nx=ny=...=bins).\nrange : sequence, optional\n    A sequence of length D, each an optional (lower, upper) tuple giving the outer bin edges to be used if the edges are not given explicitly in bins.\ndensity : bool, optional\n    If False, the default, returns the number of samples in each bin. If True, returns the probability density function at the bin.\nweights : (N,) array_like, optional\n    An array of values w_i weighing each sample (x_i, y_i, z_i, ...).\n\nReturns\n-------\nH : ndarray\n    The multidimensional histogram of sample x.\nedges : list\n    A list of D arrays describing the bin edges for each dimension.",
  }
  -/
  
  /-  Compute the multidimensional histogram of some data.
      For simplicity, we focus on 2D histograms with fixed dimensions. -/
  
  /-  Specification: histogramdd computes a 2D histogram with correct bin counts and edges -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def histogramdd {n : Nat} (sample : Vector (Float × Float) n) (bins_x bins_y : Nat) : 
      Id (Vector (Vector Float bins_x) bins_y × Vector Float (bins_x + 1) × Vector Float (bins_y + 1)) :=

vc-implementation: |-
  -- <vc-implementation>
    sorry
  -- </vc-implementation>

vc-condition: |-
  theorem histogramdd_spec {n : Nat} (sample : Vector (Float × Float) n) (bins_x bins_y : Nat) 
      (h_bins_x_pos : bins_x > 0) (h_bins_y_pos : bins_y > 0) :
      ⦃⌜bins_x > 0 ∧ bins_y > 0⌝⦄
      histogramdd sample bins_x bins_y
      ⦃⇓result => 
        let (hist, edges_x, edges_y) := result
        ⌜-- The histogram has the correct dimensions
        (hist.toArray.size = bins_y) ∧
        (∀ i : Fin bins_y, (hist.get i).toArray.size = bins_x) ∧
        -- The edges have the correct sizes
        (edges_x.toArray.size = bins_x + 1) ∧
        (edges_y.toArray.size = bins_y + 1) ∧
        -- The edges are monotonically increasing
        (∀ i : Fin bins_x, edges_x.get ⟨i.val, by omega⟩ < edges_x.get ⟨i.val + 1, by omega⟩) ∧
        (∀ i : Fin bins_y, edges_y.get ⟨i.val, by omega⟩ < edges_y.get ⟨i.val + 1, by omega⟩) ∧
        -- The histogram counts are non-negative
        (∀ i : Fin bins_y, ∀ j : Fin bins_x, (hist.get i).get j ≥ 0) ∧
        -- Each sample point falls into exactly one bin
        (∀ p : Float × Float, p ∈ sample.toArray →
          ∃ i : Fin bins_y, ∃ j : Fin bins_x,
            edges_y.get ⟨i.val, by omega⟩ ≤ p.snd ∧ p.snd < edges_y.get ⟨i.val + 1, by omega⟩ ∧
            edges_x.get ⟨j.val, by omega⟩ ≤ p.fst ∧ p.fst < edges_x.get ⟨j.val + 1, by omega⟩)⌝⦄ := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-

