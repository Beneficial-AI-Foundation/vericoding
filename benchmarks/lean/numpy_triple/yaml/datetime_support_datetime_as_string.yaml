vc-description: |-
  /- 
  {
    "name": "numpy.datetime_as_string",
    "category": "Datetime conversion",
    "description": "Convert an array of datetimes into an array of strings",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.datetime_as_string.html",
    "doc": "datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\n\nConvert an array of datetimes into an array of strings.\n\nParameters\n----------\narr : array_like of datetime64\n    The array of UTC timestamps to format.\nunit : str\n    One of None, 'auto', or a :ref:\`datetime unit <arrays.dtypes.dateunits>\`.\ntimezone : {'naive', 'UTC', 'local'} or tzinfo\n    Timezone information to use when displaying the datetime. If 'UTC', end with a Z to indicate UTC time. If 'local', convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with 'local', but use the specified timezone.\ncasting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}\n    Casting to allow when changing between datetime units.\n\nReturns\n-------\nstr_arr : ndarray\n    An array of strings the same shape as \`arr\`.\n\nExamples\n--------\n>>> import numpy as np\n>>> import pytz\n>>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n>>> d\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n       '2002-10-27T07:30'], dtype='datetime64[m]')\n\nSetting the timezone to UTC shows the same information, but with a Z suffix\n\n>>> np.datetime_as_string(d, timezone='UTC')\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n       '2002-10-27T07:30Z'], dtype='<U35')",
  }
  -/
  
  /-  Convert an array of datetime64 values to an array of strings.
  
      Converts each datetime64 value in the input vector to its string representation.
      The format depends on the timezone option: 'naive' produces no suffix,
      'UTC' adds 'Z' suffix, and 'local' would add timezone offset.
  
      For simplicity, we focus on the core conversion from datetime64 to ISO format strings.
  -/
  
  /-  Specification: datetime_as_string converts each datetime64 to its string representation.
  
      Precondition: True (no special preconditions)
      Postcondition: Each datetime64 is converted to a properly formatted ISO 8601 string
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do
  
  /-- Time unit for datetime64 -/
  inductive TimeUnit : Type where
    /-- Years unit ('Y') -/
    | years : TimeUnit   
    /-- Days unit ('D') -/
    | days : TimeUnit    
    /-- Hours unit ('h') -/
    | hours : TimeUnit   
    /-- Minutes unit ('m') -/
    | minutes : TimeUnit 
    /-- Seconds unit ('s') -/
    | seconds : TimeUnit 
    /-- Milliseconds unit ('ms') -/
    | milliseconds : TimeUnit 
    /-- Microseconds unit ('us') -/
    | microseconds : TimeUnit 
    /-- Nanoseconds unit ('ns') -/
    | nanoseconds : TimeUnit
  
  /-- DateTime64 structure representing offset from Unix epoch -/
  structure DateTime64 where
    /-- Offset value from 1970-01-01T00:00:00 -/
    offset : Int          
    /-- Time unit of the offset -/
    unit : TimeUnit       
    /-- Always UTC with +0000 offset -/
    is_utc : Bool := true
  
  /-- Timezone formatting options -/
  inductive TimezoneOption : Type where
    /-- No timezone suffix -/
    | naive : TimezoneOption  
    /-- Add 'Z' suffix for UTC -/
    | UTC : TimezoneOption    
    /-- Add local timezone offset -/
    | local : TimezoneOption

vc-helpers: |-

vc-definitions: |-
  def datetime_as_string {n : Nat} (arr : Vector DateTime64 n) (timezone : TimezoneOption := TimezoneOption.naive) : Id (Vector String n) :=
    sorry

vc-theorems: |-
  theorem datetime_as_string_spec {n : Nat} (arr : Vector DateTime64 n) (timezone : TimezoneOption := TimezoneOption.naive) :
      ⦃⌜True⌝⦄
      datetime_as_string arr timezone
      ⦃⇓result => ⌜
        -- Each string is non-empty and represents a valid datetime
        (∀ i : Fin n, result[i].length > 0) ∧
        -- Format consistency: string format depends on timezone option
        (match timezone with
         | TimezoneOption.naive => ∀ i : Fin n, ¬result[i].endsWith "Z"
         | TimezoneOption.UTC => ∀ i : Fin n, result[i].endsWith "Z"
         | TimezoneOption.local => True) ∧  -- Simplified for local timezone
        -- Each datetime is represented as a valid ISO 8601 string
        (∀ i : Fin n, result[i].contains '-' ∨ result[i].length ≥ 4) ∧
        -- String precision matches the datetime unit precision
        (∀ i : Fin n, match arr[i].unit with
         | TimeUnit.years => result[i].length ≥ 4    -- At least "YYYY"
         | TimeUnit.days => result[i].length ≥ 10    -- At least "YYYY-MM-DD"
         | TimeUnit.hours => result[i].length ≥ 13   -- At least "YYYY-MM-DDTHH"
         | TimeUnit.minutes => result[i].length ≥ 16 -- At least "YYYY-MM-DDTHH:MM"
         | TimeUnit.seconds => result[i].length ≥ 19 -- At least "YYYY-MM-DDTHH:MM:SS"
         | TimeUnit.milliseconds => result[i].length ≥ 23 -- Include milliseconds
         | TimeUnit.microseconds => result[i].length ≥ 26 -- Include microseconds
         | TimeUnit.nanoseconds => result[i].length ≥ 29) -- Include nanoseconds
      ⌝⦄ := by
    sorry

vc-postamble: |-

