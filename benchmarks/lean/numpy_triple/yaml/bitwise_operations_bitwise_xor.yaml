vc-description: |-
  /- 
  {
    "name": "numpy.bitwise_xor",
    "category": "Elementwise bit operations",
    "description": "Compute the bit-wise XOR of two arrays element-wise",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.bitwise_xor.html",
    "doc": "Compute the bit-wise XOR of two arrays element-wise.\n\nComputes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator ^.\n\nParameters\n----------\nx1, x2 : array_like\n    Only integer and boolean types are handled.\n    If x1.shape != x2.shape, they must be broadcastable to a common shape.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored.\nwhere : array_like, optional\n    This condition is broadcast over the input.\n\nReturns\n-------\nout : ndarray or scalar\n    Result.\n\nExamples\n--------\n>>> np.bitwise_xor(13, 17)\n28\n>>> np.bitwise_xor(31, 5)\n26\n>>> np.bitwise_xor([31,3], 5)\narray([26, 6])\n>>> np.bitwise_xor([31,3], [5,6])\narray([26, 5])\n>>> np.array([True, True]) ^ np.array([False, True])\narray([True, False])",
  }
  -/
  
  /-  numpy.bitwise_xor: Compute the bit-wise XOR of two arrays element-wise.
  
      Computes the bit-wise XOR (exclusive OR) of the underlying binary representation 
      of the integers in the input arrays. This ufunc implements the C/Python 
      operator ^.
  
      For each pair of corresponding elements in x1 and x2, the result contains
      the bitwise XOR of their binary representations. Each bit position in the
      result is 1 if and only if exactly one of the corresponding bits in x1 and x2 is 1.
  
      Examples:
      - 13 ^ 17 = 28 (binary: 01101 ^ 10001 = 11100)
      - 31 ^ 5 = 26 (binary: 11111 ^ 00101 = 11010)
      - 31 ^ 3 = 28 (binary: 11111 ^ 00011 = 11100)
  
      Note: This specification currently handles only non-negative integers.
      For negative integers, NumPy uses two's complement representation,
      which requires a more complex formalization in Lean.
  -/
  
  /-  Specification: bitwise_xor returns a vector where each element is the 
      bitwise XOR of the corresponding elements from x1 and x2.
  
      Precondition: All elements are non-negative (to simplify the specification)
  
      Postcondition: 
      1. For non-negative integers, each element of the result is the bitwise XOR 
         of corresponding inputs
      2. The result preserves the mathematical properties of bitwise XOR:
         - Commutativity: x ^ y = y ^ x
         - Associativity: (x ^ y) ^ z = x ^ (y ^ z)
         - Identity: x ^ 0 = x (0 acts as identity)
         - Self-inverse: x ^ x = 0 (every element is its own inverse)
         - Involution: (x ^ y) ^ y = x (applying XOR twice with same value gives original)
      3. For Boolean values (0 or 1), XOR acts as logical exclusive OR
      4. The result bit at position k is 1 iff exactly one of the input bits at position k is 1
      5. XOR with all-1s mask acts as bitwise NOT: x ^ (2^k - 1) = (2^k - 1) - x for x < 2^k
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-

vc-definitions: |-
  def bitwise_xor {n : Nat} (x1 x2 : Vector Int n) : Id (Vector Int n) :=
    sorry

vc-theorems: |-
  theorem bitwise_xor_spec {n : Nat} (x1 x2 : Vector Int n) 
      (h_nonneg : ∀ i : Fin n, x1.get i ≥ 0 ∧ x2.get i ≥ 0) :
      ⦃⌜∀ i : Fin n, x1.get i ≥ 0 ∧ x2.get i ≥ 0⌝⦄
      bitwise_xor x1 x2
      ⦃⇓result => ⌜(∀ i : Fin n, result.get i = Int.ofNat (Int.toNat (x1.get i) ^^^ Int.toNat (x2.get i))) ∧
                  (∀ i : Fin n, result.get i ≥ 0) ∧
                  (∀ i : Fin n, x1.get i = 0 → result.get i = x2.get i) ∧
                  (∀ i : Fin n, x2.get i = 0 → result.get i = x1.get i) ∧
                  (∀ i : Fin n, x1.get i = x2.get i → result.get i = 0)⌝⦄ := by
    sorry

vc-postamble: |-

