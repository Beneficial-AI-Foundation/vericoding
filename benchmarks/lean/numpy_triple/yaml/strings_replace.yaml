vc-description: |-
  /- 
  {
    "name": "numpy.strings.replace",
    "category": "String operations",
    "description": "For each element in a, return a copy of the string with occurrences of substring old replaced by new",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.strings.replace.html",
    "doc": "For each element in `a`, return a copy of the string with occurrences of substring `old` replaced by `new`.\n\nParameters\n----------\na : array_like, with `StringDType`, `bytes_` or `str_` dtype\nold : array_like, with `StringDType`, `bytes_` or `str_` dtype\nnew : array_like, with `StringDType`, `bytes_` or `str_` dtype\ncount : array_like, with any integer dtype, optional\n    Maximum number of occurrences to replace. -1 (the default) means replace all occurrences.\n\nReturns\n-------\nout : ndarray\n    Output array of `StringDType`, `bytes_` or `str_` dtype,\n    depending on input types",
  }
  -/
  
  /-  numpy.strings.replace: For each element in a, return a copy of the string with 
      occurrences of substring old replaced by new.
  
      Replaces occurrences of the substring 'old' with 'new' in each string element.
      The replacement is done from left to right, and if count is specified, only
      the first 'count' occurrences are replaced. If count is -1 or negative,
      all occurrences are replaced.
  -/
  
  /-  Specification for numpy.strings.replace: Returns a vector where each element is the
      result of replacing occurrences of old substring with new substring.
  
      Mathematical Properties:
      1. Element-wise replacement: Each result element is the original string with replacements
      2. Count limiting: If count[i] >= 0, at most count[i] replacements are made
      3. Complete replacement: If count[i] < 0, all occurrences are replaced
      4. Identity preservation: If old[i] doesn't occur in a[i], result[i] = a[i]
      5. Zero count behavior: If count[i] = 0, no replacements occur
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-signature: |-
  def replace {n : Nat} (a : Vector String n) (old : Vector String n) (new : Vector String n) (count : Vector Int n) : Id (Vector String n) :=

vc-implementation: |-
  -- <vc-implementation>
    sorry
  -- </vc-implementation>

vc-condition: |-
  theorem replace_spec {n : Nat} (a : Vector String n) (old : Vector String n) (new : Vector String n) (count : Vector Int n) :
      ⦃⌜∀ i : Fin n, count.get i = 0 ∨ old.get i ≠ ""⌝⦄
      replace a old new count
      ⦃⇓result => ⌜∀ i : Fin n,
        -- Zero count behavior: if count is 0, no replacements occur
        (count.get i = 0 → result.get i = a.get i) ∧
        -- Identity property: if old doesn't occur, result equals original
        ((∀ pos : Nat, pos + (old.get i).length ≤ (a.get i).length → 
          ¬(((a.get i).drop pos).take (old.get i).length = old.get i)) → 
          result.get i = a.get i) ∧
        -- Basic replacement property: result contains the transformed string
        (∃ (num_replacements : Nat),
          -- Number of replacements is bounded by count (if non-negative)
          (count.get i ≥ 0 → num_replacements ≤ Int.natAbs (count.get i)) ∧
          -- If count is negative, all possible non-overlapping occurrences are replaced
          (count.get i < 0 → 
            ∃ positions : List Nat,
              positions.length = num_replacements ∧
              (∀ p ∈ positions, 
                p + (old.get i).length ≤ (a.get i).length ∧
                ((a.get i).drop p).take (old.get i).length = old.get i) ∧
              -- Positions are sorted and non-overlapping
              (positions.Pairwise (· ≤ ·)) ∧
              (∀ j k : Nat, j < k → j < positions.length → k < positions.length →
                positions[j]! + (old.get i).length ≤ positions[k]!)) ∧
          -- If count is non-negative, we replace min(count, total_occurrences)
          (count.get i ≥ 0 → 
            ∃ total_occurrences : Nat,
              num_replacements = min (Int.natAbs (count.get i)) total_occurrences ∧
              (∃ positions : List Nat,
                positions.length = total_occurrences ∧
                (∀ p ∈ positions, 
                  p + (old.get i).length ≤ (a.get i).length ∧
                  ((a.get i).drop p).take (old.get i).length = old.get i) ∧
                -- Positions are sorted and non-overlapping
                (positions.Pairwise (· ≤ ·)) ∧
                (∀ j k : Nat, j < k → j < positions.length → k < positions.length →
                  positions[j]! + (old.get i).length ≤ positions[k]!))))
      ⌝⦄ := by

vc-proof: |-
  -- <vc-proof>
    sorry
  -- </vc-proof>

vc-postamble: |-

