vc-description: |-
  /- 
  {
    "name": "numpy.ravel_multi_index",
    "category": "Index generation",
    "description": "Converts a tuple of index arrays into an array of flat indices",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.ravel_multi_index.html",
    "doc": "Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.\n\nParameters\n----------\nmulti_index : tuple of array_like\n    A tuple of integer arrays, one array for each dimension.\ndims : tuple of ints\n    The shape of array into which the indices from multi_index apply.\nmode : {'raise', 'wrap', 'clip'}, optional\n    Specifies how out-of-bounds indices are handled.\norder : {'C', 'F'}, optional\n    Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.\n\nReturns\n-------\nraveled_indices : ndarray\n    An array of indices into the flattened version of an array of dimensions dims.",
  }
  -/
  
  /-  Convert 2D multi-indices to flat indices using C-style (row-major) ordering.
  
      Takes arrays of row and column indices and converts them to flat indices
      for an array with given dimensions. The conversion uses row-major ordering
      where flat_index = row_index * cols + col_index.
  
      The function requires that all indices are within bounds of the specified dimensions.
  -/
  
  /-  Specification: ravel_multi_index converts 2D indices to flat indices using row-major ordering.
  
      Precondition: All row and column indices must be within bounds
      Postcondition: Each flat index is computed as row_index * cols + col_index
  
      Mathematical properties:
      1. The flat index correctly represents the 2D position in a flattened array
      2. All resulting indices are within bounds of the flattened array
      3. The conversion preserves the ordering relationship between multi-indices
  
      This specification captures the essential behavior of NumPy's ravel_multi_index
      for the 2D case with C-style ordering. The function maps 2D coordinates to
      their corresponding positions in a flattened representation of the array.
  -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def ravel_multi_index {n : Nat} (row_indices col_indices : Vector Nat n) 
      (rows cols : Nat) 
      (h_rows_valid : ∀ i : Fin n, row_indices.get i < rows)
      (h_cols_valid : ∀ i : Fin n, col_indices.get i < cols) : Id (Vector Nat n) :=
    sorry

vc-theorems: |-
  theorem ravel_multi_index_spec {n : Nat} (row_indices col_indices : Vector Nat n) 
      (rows cols : Nat) 
      (h_rows_valid : ∀ i : Fin n, row_indices.get i < rows)
      (h_cols_valid : ∀ i : Fin n, col_indices.get i < cols) :
      ⦃⌜∀ i : Fin n, row_indices.get i < rows ∧ col_indices.get i < cols⌝⦄
      ravel_multi_index row_indices col_indices rows cols h_rows_valid h_cols_valid
      ⦃⇓result => ⌜∀ i : Fin n, result.get i = row_indices.get i * cols + col_indices.get i ∧
                                result.get i < rows * cols⌝⦄ := by
    sorry

vc-postamble: |-

