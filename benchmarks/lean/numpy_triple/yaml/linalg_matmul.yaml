vc-description: |-
  /- 
  {
    "name": "numpy.linalg.matmul",
    "category": "Matrix and vector products",
    "description": "Matrix product of two arrays",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.linalg.matmul.html",
    "doc": "Matrix product of two arrays. The behavior depends on the arguments:\n- If both arguments are 2-D they are multiplied like conventional matrices\n- If either argument is N-D, N > 2, it is treated as a stack of matrices\n- If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions\n- If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions\n\nThis is the same as the @ operator.",
  }
  -/
  
  /-  Matrix multiplication for 2D matrices. 
      Computes the matrix product of two 2D arrays following standard matrix multiplication rules.
      The result matrix C has dimensions (m x p) where A is (m x n) and B is (n x p). -/
  
  /-  Specification: Matrix multiplication produces a result where each element is the dot product 
      of the corresponding row from the first matrix and column from the second matrix.
  
      Mathematical properties:
      1. Dimensions are compatible: A is m×n, B is n×p, result is m×p
      2. Each element C[i][j] = sum of A[i][k] * B[k][j] for k from 0 to n-1
      3. The operation preserves the fundamental matrix multiplication identity
      4. Non-commutativity: A*B ≠ B*A in general (handled by type system)
      5. Associativity: (A*B)*C = A*(B*C) when dimensions are compatible -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  -- <vc-helpers>
  -- </vc-helpers>

vc-definitions: |-
  def matmul {m n p : Nat} (A : Vector (Vector Float n) m) (B : Vector (Vector Float p) n) : 
      Id (Vector (Vector Float p) m) :=
    sorry

vc-theorems: |-
  theorem matmul_spec {m n p : Nat} (A : Vector (Vector Float n) m) (B : Vector (Vector Float p) n) :
      ⦃⌜True⌝⦄
      matmul A B
      ⦃⇓C => ⌜∀ i : Fin m, ∀ j : Fin p, 
                (C.get i).get j = List.sum (List.zipWith (· * ·) 
                  (A.get i).toList 
                  (List.map (fun row => row.get j) B.toList))⌝⦄ := by
    sorry

vc-postamble: |-

