vc-description: |-
  /-  Packs binary-valued elements into bits in a UInt8 array.
      Each group of 8 binary values is packed into one UInt8.
      The result is padded with zeros if needed. -/

  /-  Specification: packbits correctly packs binary values into UInt8 bytes according to bitorder.
      For big-endian: first element goes to MSB (bit 7)
      For little-endian: first element goes to LSB (bit 0) -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do
  
  /-  Enumeration for bit ordering in packbits -/
  
  inductive BitOrder
    | big    -- MSB first (default): bit 7 is first element
    | little -- LSB first: bit 0 is first element

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def packbits {n : Nat} (a : Vector Bool n) (bitorder : BitOrder := BitOrder.big) : 
      Id (Vector UInt8 ((n + 7) / 8)) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem packbits_spec {n : Nat} (a : Vector Bool n) (bitorder : BitOrder := BitOrder.big) :
      ⦃⌜True⌝⦄
      packbits a bitorder
      ⦃⇓result => ⌜∀ byte_idx : Fin ((n + 7) / 8), 
                    result.get byte_idx = 
                      (match bitorder with
                       | BitOrder.big => 
                         -- Big-endian: bit 7 is first, bit 0 is last
                         let start_idx := byte_idx.val * 8
                         let bits_in_byte := min 8 (n - start_idx)
                         (List.range bits_in_byte).foldl (fun acc bit_pos =>
                           if h : start_idx + bit_pos < n then
                             let bit := if a.get ⟨start_idx + bit_pos, h⟩ then 1 else 0
                             acc ||| (bit <<< (7 - bit_pos)).toUInt8
                           else acc
                         ) 0
                       | BitOrder.little => 
                         -- Little-endian: bit 0 is first, bit 7 is last  
                         let start_idx := byte_idx.val * 8
                         let bits_in_byte := min 8 (n - start_idx)
                         (List.range bits_in_byte).foldl (fun acc bit_pos =>
                           if h : start_idx + bit_pos < n then
                             let bit := if a.get ⟨start_idx + bit_pos, h⟩ then 1 else 0
                             acc ||| (bit <<< bit_pos).toUInt8
                           else acc
                         ) 0)⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
