vc-description: |-
  /- 
  {
    "name": "numpy.argsort",
    "category": "Sorting",
    "description": "Returns the indices that would sort an array",
    "url": "https://numpy.org/doc/stable/reference/generated/numpy.argsort.html",
    "doc": "Returns the indices that would sort an array.\n\nPerform an indirect sort along the given axis using the algorithm specified\nby the \`kind\` keyword. It returns an array of indices of the same shape as\n\`a\` that index data along the given axis in sorted order.\n\nParameters\n----------\na : array_like\n    Array to sort.\naxis : int or None, optional\n    Axis along which to sort. The default is -1 (the last axis). If None,\n    the flattened array is used.\nkind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional\n    Sorting algorithm. The default is 'quicksort'.\norder : str or list of str, optional\n    When \`a\` is an array with fields defined, this argument specifies\n    which fields to compare first, second, etc.\nstable : bool, optional\n    Sort stability. If \`\`True\`\`, the returned array will maintain\n    the relative order of \`\`a\`\` values which compare as equal.\n\nReturns\n-------\nindex_array : ndarray, int\n    Array of indices that sort \`a\` along the specified \`axis\`.\n    If \`a\` is one-dimensional, \`\`a[index_array]\`\` yields a sorted \`a\`.\n    More generally, \`\`take_along_axis(a, index_array, axis=axis)\`\`\n    always yields the sorted \`a\`, irrespective of dimensionality.",
  }
  -/

  /-  Returns the indices that would sort a vector in ascending order -/

  /-  Specification: argsort returns indices that sort the input array -/

vc-preamble: |-
  import Std.Do.Triple
  import Std.Tactic.Do
  open Std.Do

vc-helpers: |-
  <vc-helpers>
  </vc-helpers>

vc-signature: |-
  def argsort {n : Nat} (a : Vector Float n) : Id (Vector (Fin n) n) :=

vc-implementation: |-
  <vc-implementation>
    sorry
  </vc-implementation>

vc-condition: |-
  theorem argsort_spec {n : Nat} (a : Vector Float n) :
      ⦃⌜True⌝⦄
      argsort a
      ⦃⇓indices => ⌜-- The result is a permutation of all indices
                     (∀ i : Fin n, ∃ j : Fin n, indices.get j = i) ∧
                     (∀ i j : Fin n, indices.get i = indices.get j → i = j) ∧
                     -- The indices produce a sorted sequence
                     (∀ i j : Fin n, i < j → a.get (indices.get i) ≤ a.get (indices.get j)) ∧
                     -- For equal elements, maintain relative order (stable sort)
                     (∀ i j : Fin n, i < j → a.get (indices.get i) = a.get (indices.get j) → indices.get i < indices.get j)⌝⦄ := by

vc-proof: |-
  <vc-proof>
    sorry
  </vc-proof>

vc-postamble: |-
